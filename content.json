{"posts":[{"title":"00-Javaæ•°ç»„éå†æ€§èƒ½å¯¹æ¯”","text":"ä¸‰ç§éå†æ–¹å¼æ€§èƒ½å¯¹æ¯” å¾ªç¯ä¸æ•°ç»„çš„lengthæ¯”è¾ƒ 12345678910public class JavaMain { static Object[] objs = new Object[10000000]; static int zero() { int sum = 0; for(int i = 0; i &lt; objs.length; i++) { sum ^= objs[i].hashCode(); } return sum; }} å°†æ•°ç»„lengthå­˜åœ¨æ–¹æ³•æ ˆä¸­ 1234567891011public class JavaMain { static Object[] objs = new Object[10000000]; static int one() { int sum = 0; int len = objs.length; for(int i = 0; i &lt; len; i++) { sum ^= objs[i].hashCode(); } return sum; }} for-eachå¾ªç¯ 12345678910public class JavaMain { static Object[] objs = new Object[10000000]; static int two() { int sum = 0; for (Object obj : objs) { sum ^= obj.hashCode(); } return sum; }} æµ‹è¯•é€Ÿåº¦123456789101112131415161718192021222324252627public class JavaMain { static Object[] objs = new Object[10000000]; static long run(IntSupplier f) { long start = System.currentTimeMillis(); int result = 0; for(int i = 0; i &lt; 100; i++) { result = f.getAsInt(); } long end = System.currentTimeMillis(); System.out.println(&quot;result = &quot; + result + &quot;, time = &quot; + (end - start) / 1000.0); return end - start; } public static void main(String[] args) { for (int i = 0; i &lt; objs.length; i++) { objs[i] = new Object(); objs[i].hashCode(); // é¦–æ¬¡è®¡ç®—hashcodeæ›´æ…¢ï¼Œå…ˆç¼“å­˜ } for (int i = 0; i &lt; 10; i++) { long zeroTime = run(JavaMain::zero); long oneTime = run(JavaMain::one); long twoTime = run(JavaMain::two); System.out.printf(&quot;2æ¯”1å¿«: %.2f%%\\n&quot;, ((double)oneTime - twoTime) / oneTime * 100); System.out.printf(&quot;2æ¯”0å¿«: %.2f%%\\n&quot;, ((double)zeroTime - twoTime) / zeroTime * 100); System.out.printf(&quot;1æ¯”0å¿«: %.2f%%\\n&quot;, ((double)zeroTime - oneTime) / oneTime * 100); } }} æµ‹è¯•ç»“æœ123456result = 360970567, time = 1.393result = 360970567, time = 1.174result = 360970567, time = 0.8862æ¯”1å¿«: 24.53%2æ¯”0å¿«: 36.40%1æ¯”0å¿«: 18.65% å¯¹æ¯”å­—èŠ‚ç ä½¿ç”¨javap -cæŸ¥çœ‹å­—èŠ‚ğŸ´ 123456789101112131415161718192021static int zero();Code: 0: iconst_0 1: istore_0 2: iconst_0 3: istore_1 4: iload_1 5: getstatic #7 // Field objs:[Ljava/lang/Object; 8: arraylength 9: if_icmpge 29 12: iload_0 13: getstatic #7 // Field objs:[Ljava/lang/Object; 16: iload_1 17: aaload 18: invokevirtual #13 // Method java/lang/Object.hashCode:()I 21: ixor 22: istore_0 23: iinc 1, 1 26: goto 4 29: iload_0 30: ireturn æ•°ç»„çš„lengthå¹¶ä¸æ˜¯ä¸€ä¸ªå­—æ®µï¼Œæ²¡æœ‰é€šè¿‡getfieldè·å– 1234567891011121314151617181920212223static int one();Code: 0: iconst_0 1: istore_0 2: getstatic #7 // Field objs:[Ljava/lang/Object; 5: arraylength 6: istore_1 7: iconst_0 8: istore_2 9: iload_2 10: iload_1 11: if_icmpge 31 14: iload_0 15: getstatic #7 // Field objs:[Ljava/lang/Object; 18: iload_2 19: aaload 20: invokevirtual #13 // Method java/lang/Object.hashCode:()I 23: ixor 24: istore_0 25: iinc 2, 1 28: goto 9 31: iload_0 32: ireturn æ¯æ¬¡ä½¿ç”¨arraylengthè·å–æ•°ç»„é•¿åº¦ä¼šæ›´æ…¢ï¼Œå…·ä½“arraylengthåšäº†ä»€ä¹ˆå¯ä»¥çœ‹è¿™ç¯‡æ–‡ç« JVMæ˜¯å¦‚ä½•å¾—åˆ°æ•°ç»„é•¿åº¦çš„ zeroå’Œoneå¯¹æ¯” zeroæ¯æ¬¡å¾ªç¯å‰ï¼Œè¦ä¾æ¬¡æ‰§è¡Œiload_1, getstatic, arraylength, if_icmpge oneæ¯æ¬¡å¾ªç¯å‰ï¼Œè¦ä¾æ¬¡æ‰§è¡Œiload_2, iload_1, if_icmpge oneåªéœ€è¦è™šæ‹Ÿæœºè¯»å–ä¸¤ä¸ªæ“ä½œæ•°è¿›è¡Œæ¯”è¾ƒå°±å¯ä»¥ï¼Œè€Œzeroéœ€è¦é€šè¿‡getstaticè·å–æ•°ç»„å¯¹è±¡ï¼Œarraylengthè·å–é•¿åº¦ 123456789101112131415161718192021222324252627static int two();Code: 0: iconst_0 1: istore_0 2: getstatic #7 // Field objs:[Ljava/lang/Object; 5: astore_1 6: aload_1 7: arraylength 8: istore_2 9: iconst_0 10: istore_3 11: iload_3 12: iload_2 13: if_icmpge 35 16: aload_1 17: iload_3 18: aaload 19: astore 4 21: iload_0 22: aload 4 24: invokevirtual #13 // Method java/lang/Object.hashCode:()I 27: ixor 28: istore_0 29: iinc 3, 1 32: goto 11 35: iload_0 36: ireturn oneå’Œtwoå¯¹æ¯” åœ¨å¾ªç¯å‰ï¼Œä¸¤è€…éƒ½æ˜¯é€šè¿‡iloadè¯»å–æ•°ç»„é•¿åº¦å’Œå½“å‰indexå¯¹æ¯” åœ¨å¾ªç¯ä½“ä¸­ oneæ¯æ¬¡éœ€è¦getstaticè·å–æ•°ç»„å¯¹è±¡ï¼Œç„¶åæ ¹æ®åç§»é‡å–å‡ºå¯¹åº”ä½ç½®çš„å¯¹è±¡ twoåœ¨å¾ªç¯å¼€å§‹å‰ï¼Œå°±å°†æ•°ç»„å¯¹è±¡å­˜åœ¨æœ¬åœ°æ–¹æ³•æ ˆä¸­ï¼Œä¸éœ€è¦ä½¿ç”¨getstaticæ¥è·å–æ•°ç»„å¯¹è±¡ å¼ºçƒˆæ€€ç–‘æ˜¯getstaticæ€§èƒ½è¿‡äºæ‹‰èƒ¯ï¼Œå¯¼è‡´ä¸‰è€…å¾ªç¯é€Ÿåº¦å·®å¼‚å¤§ å°†æ•°ç»„å¯¹è±¡ä½œä¸ºå‚æ•°ä¼ é€’åˆ°å‡½æ•°ä¸­æµ‹è¯•ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class JavaMain { static Object[] objs = new Object[10000000]; static int zero(Object[] objs) { int sum = 0; for(int i = 0; i &lt; objs.length; i++) { sum ^= objs[i].hashCode(); } return sum; } static int one(Object[] objs) { int sum = 0; int len = objs.length; for(int i = 0; i &lt; len; i++) { sum ^= objs[i].hashCode(); } return sum; } static int two(Object[] objs) { int sum = 0; for (Object obj : objs) { sum ^= obj.hashCode(); } return sum; } static long run(Function&lt;Object[], Integer&gt; f) { long start = System.currentTimeMillis(); int result = 0; for(int i = 0; i &lt; 100; i++) { result = f.apply(objs); } long end = System.currentTimeMillis(); System.out.println(&quot;result = &quot; + result + &quot;, time = &quot; + (end - start) / 1000.0); return end - start; } public static void main(String[] args) { for (int i = 0; i &lt; objs.length; i++) { objs[i] = new Object(); objs[i].hashCode(); } for (int i = 0; i &lt; 10; i++) { long zeroTime = run(JavaMain::zero); long oneTime = run(JavaMain::one); long twoTime = run(JavaMain::two); System.out.printf(&quot;2æ¯”1å¿«: %.2f%%\\n&quot;, ((double)oneTime - twoTime) / oneTime * 100); System.out.printf(&quot;2æ¯”0å¿«: %.2f%%\\n&quot;, ((double)zeroTime - twoTime) / zeroTime * 100); System.out.printf(&quot;1æ¯”0å¿«: %.2f%%\\n&quot;, ((double)zeroTime - oneTime) / oneTime * 100); } }} æ¯”è¾ƒç»“æœ123456789101112131415161718result = 360970567, time = 0.85result = 360970567, time = 0.871result = 360970567, time = 0.8732æ¯”1å¿«: -0.23%2æ¯”0å¿«: -2.71%1æ¯”0å¿«: -2.41%result = 360970567, time = 0.864result = 360970567, time = 0.847result = 360970567, time = 0.8492æ¯”1å¿«: -0.24%2æ¯”0å¿«: 1.74%1æ¯”0å¿«: 2.01%result = 360970567, time = 0.851result = 360970567, time = 0.849result = 360970567, time = 0.8622æ¯”1å¿«: -1.53%2æ¯”0å¿«: -1.29%1æ¯”0å¿«: 0.24% ä¸‰ç§æ–¹æ³•éš¾åˆ†ä¼¯ä»² å­—èŠ‚ç å¯¹æ¯”12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091Compiled from &quot;JavaMain.java&quot;public class test.JavaMain { static java.lang.Object[] objs; public test.JavaMain(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return static int zero(java.lang.Object[]); Code: 0: iconst_0 1: istore_1 2: iconst_0 3: istore_2 4: iload_2 5: aload_0 6: arraylength 7: if_icmpge 25 10: iload_1 11: aload_0 12: iload_2 13: aaload 14: invokevirtual #7 // Method java/lang/Object.hashCode:()I 17: ixor 18: istore_1 19: iinc 2, 1 22: goto 4 25: iload_1 26: ireturn static int one(java.lang.Object[]); Code: 0: iconst_0 1: istore_1 2: aload_0 3: arraylength 4: istore_2 5: iconst_0 6: istore_3 7: iload_3 8: iload_2 9: if_icmpge 27 12: iload_1 13: aload_0 14: iload_3 15: aaload 16: invokevirtual #7 // Method java/lang/Object.hashCode:()I 19: ixor 20: istore_1 21: iinc 3, 1 24: goto 7 27: iload_1 28: ireturn static int two(java.lang.Object[]); Code: 0: iconst_0 1: istore_1 2: aload_0 3: astore_2 4: aload_2 5: arraylength 6: istore_3 7: iconst_0 8: istore 4 10: iload 4 12: iload_3 13: if_icmpge 36 16: aload_2 17: iload 4 19: aaload 20: astore 5 22: iload_1 23: aload 5 25: invokevirtual #7 // Method java/lang/Object.hashCode:()I 28: ixor 29: istore_1 30: iinc 4, 1 33: goto 10 36: iload_1 37: ireturn static {}; Code: 0: ldc #77 // int 10000000 2: anewarray #2 // class java/lang/Object 5: putstatic #17 // Field objs:[Ljava/lang/Object; 8: return} ä¸‰è€…åŒºåˆ«ä¸å¤§ï¼Œæ€»ä½“è€—æ—¶åŒºåˆ«ä¹Ÿä¸å¤§ï¼Œå¯è§arraylengthæŒ‡ä»¤å¹¶ä¸æ˜¯æ€§èƒ½ç“¶é¢ˆï¼Œè€Œæ˜¯getstaticæœ‰è¾ƒå¤§å½±å“åŒæ ·ï¼Œæˆ‘ä¹Ÿæµ‹è¯•äº†ä¸é€šè¿‡å‡½æ•°å‚æ•°ä¼ é€’ï¼Œè€Œå°†æ•°ç»„å’Œä¸‰ä¸ªæ–¹æ³•æ”¹æˆéstaticä¿®é¥°çš„ï¼Œä¸‰è€…å·®å¼‚è¾ƒå¤§ï¼Œå¯è§getFieldæŒ‡ä»¤çš„æ€§èƒ½å¼€é”€ä¹Ÿè¦æ¯”loadå¤§ ç»“è®ºåœ¨éå†æ•°ç»„æ—¶ï¼Œä¸è®ºæ˜¯ä½¿ç”¨æ•°ç»„çš„lengthï¼Œæå‰å­˜å‚¨æ•°ç»„é•¿åº¦ï¼Œè¿˜æ˜¯ä½¿ç”¨for-eachï¼Œå·®åˆ«ä¸å¤§ï¼Œé‡è¦çš„æ˜¯å…ˆå°†æ•°ç»„å¯¹è±¡æ”¾åˆ°æœ¬åœ°æ–¹æ³•æ ˆï¼Œé¿å…é¢‘ç¹æ‰§è¡Œgetstaticå’ŒgetfieldæŒ‡ä»¤ï¼Œé€ æˆæ€§èƒ½å½±å“ã€‚ å’Œå…«è‚¡å®‰å“æ€§èƒ½ä¼˜åŒ–æ‰€å½’å’çš„åŸå› ç¨æœ‰ä¸åŒã€‚","link":"/home/2024/09/13/Java%E5%9F%BA%E7%A1%80/00-Java%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"title":"å®ä¹ ç¬”è®°-2","text":"retrofit å‚è€ƒ â€“ Retrofit + RxJava ï¼‹ OkHttp è®©ç½‘ç»œè¯·æ±‚å˜çš„ç®€å•-åŸºç¡€ç¯‡","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8813%E6%97%A5/"},{"title":"å®ä¹ ç¬”è®°-1","text":"px dp sp çš„åŒºåˆ« px å…¶å®å°±æ˜¯åƒç´ å•ä½ï¼Œæ¯”å¦‚æˆ‘ä»¬é€šå¸¸è¯´çš„æ‰‹æœºåˆ†è¾¨åˆ—è¡¨800*400éƒ½æ˜¯pxçš„å•ä½ sp åŒdpç›¸ä¼¼ï¼Œè¿˜ä¼šæ ¹æ®ç”¨æˆ·çš„å­—ä½“å¤§å°åå¥½æ¥ç¼©æ”¾ dp è™šæ‹Ÿåƒç´ ï¼Œåœ¨ä¸åŒçš„åƒç´ å¯†åº¦çš„è®¾å¤‡ä¸Šä¼šè‡ªåŠ¨é€‚é… éšè—çŠ¶æ€æ ä»»åŠ¡æ  åœ¨api30ä¹‹å‰1getWindow().getDecorView().setSystemUIVisibility(View.SYSTEM_UI_FLAG_FULLSCREEN) api30å12345WindowCompat.setDecorFitsSystemWindows(window, false)WindowInsetsControllerCompat(window, window.decorView).let { it.hide(WindowInsetsCompat.Type.systemBars()) //it.systemBarsBehavior = WindowInsetsControllerCompat.BEHAVIOR_SHOW_BARS_BY_TOUCH} androidx.core ä¾èµ–çš„ç‰ˆæœ¬è‡³å°‘1.5 è®¾ç½®å¯¼èˆªæ ï¼ŒçŠ¶æ€æ é¢œè‰²12window.statusBarColor = Color.TRANSPARENTwindow.navigationBarColor = Color.TRANSPARENT fragment ç”Ÿå‘½å‘¨æœŸ onCreateView ä¸onActivityCreated çš„åŒºåˆ«onCreateViewæ¯æ¬¡åˆ›å»ºã€ç»˜åˆ¶è¯¥Fragmentçš„Viewç»„ä»¶æ—¶å›è°ƒè¯¥æ–¹æ³•ï¼ŒFragmentå°†ä¼šæ˜¾ç¤ºè¯¥æ–¹æ³•è¿”å›çš„Viewç»„ä»¶ã€‚ onActivityCreatedå½“Fragmentæ‰€åœ¨çš„Activityè¢«å¯åŠ¨å®Œæˆåå›è°ƒè¯¥æ–¹æ³•ã€‚ ä¿å­˜viewçš„çŠ¶æ€çš„æ—¶å€™éœ€è¦ç”¨onActivityCreated è®¿é—®çˆ¶activityçš„viewå±‚çš„æ—¶å€™éœ€è¦åœ¨onActivityCreated æ–¹æ³•é‡Œé¢åš å¦‚æœviewæ˜¯é™æ€çš„ï¼Œå°±å¯ä»¥åœ¨onCreateViewä¹‹åå–å¾—viewè¿›è¡Œæ“ä½œ å¦‚æœviewæ˜¯åŠ¨æ€çš„ï¼Œåˆ™éœ€è¦åœ¨onActivityCreatedåfind 1 é™æ€å¸ƒå±€1.1 Viewå’ŒViewGroupé™æ€å¸ƒå±€éƒ½æ˜¯ç”±Viewå’ŒViewGroupç»§æ‰¿è€Œæ¥ã€‚ é™æ€å¸ƒå±€æ ‘çŠ¶å›¾ Viewæ˜¯æ‰€æœ‰çš„UIç»„ä»¶éƒ½è¦ç»§æ‰¿å¹¶å®ç°çš„ï¼Œä¸€ä¸ªViewè¦åœ¨å±å¹•ä¸Šå æ®ä¸€å—çŸ©å½¢åŒºåŸŸã€‚ ViewGroupæ˜¯ä¸€ä¸ªå®¹å™¨ï¼Œå¯ä»¥å°†Viewæ·»åŠ è¿›ViewGroupä¸­ï¼ŒViewGroupå¯ä»¥å¯¹å…¶å†…çš„Viewè¿›è¡Œå¸ƒå±€ï¼ŒViewGroupå¯ä»¥æ·»åŠ å…¶ä»–çš„ViewGroupã€‚ æ‰€æœ‰çš„æ§ä»¶éƒ½æ˜¯ä»Viewç»§æ‰¿è€Œæ¥ï¼ŒViewGroupæ˜¯Viewçš„ä¸€ä¸ªé‡è¦å­ç±»ï¼Œç»å¤§å¤šæ•°å¸ƒå±€éƒ½æ˜¯ä»ViewGroupç»§æ‰¿è€Œæ¥ã€‚ 1.3 å…­å¤§å¸ƒå±€1.3.1 LinearLayoutlineæ˜¯çº¿çš„æ„æ€ï¼Œlinearæ˜¯çº¿æ€§çš„æ„æ€ï¼Œè¿™ä¸ªå¸ƒå±€å°±æ˜¯çº¿æ€§å¸ƒå±€ã€‚åªèƒ½æ¨ªç€æ’ï¼Œæˆ–è€…åªèƒ½ç«–ç€æ’ã€‚å…³é”®å±æ€§æ˜¯orientationï¼Œè¿™ä¸ªæ˜¯æ–¹å‘çš„æ„æ€ã€‚è¿™ä¸ªæœ‰ä¸¤ä¸ªé€‰é¡¹ verticalï¼Œhorizontalã€‚æ˜¯ä¸æ˜¯è§‰å¾—å¤ªé•¿è®°ä¸ä½å‘¢ï¼Œæœ‰ä¸€ä¸ªç®€ä¾¿çš„è®°å¿†æ–¹æ³•ï¼Œåˆ©ç”¨IDEçš„è‡ªåŠ¨æç¤ºåŠŸèƒ½ï¼Œåªè¦è®°ä½ç¬¬ä¸€ä¸ªå­—æ¯å°±å¯ä»¥äº†å¯¹å§ï¼Œå¯ä»¥æŠŠhè®°ä½œæ¨ªï¼ˆhengï¼‰è¿™æ ·å°±ä¸ä¼šé”™äº†ã€‚ 1.3.2 RelativeLayoutrelativeæ˜¯ç›¸å¯¹çš„æ„æ€ï¼Œè¿™ä¸ªå¸ƒå±€æ˜¯ç›¸å¯¹å¸ƒå±€ã€‚ç›¸å¯¹å¸ƒå±€å°±æ˜¯ä¾æ®çˆ¶å…ƒç´ å’ŒæŸå…ƒç´ è¿›è¡Œç›¸å¯¹å¸ƒå±€ã€‚æœ‰ä¸‰ç§ç±»å‹çš„å±æ€§ï¼š å±æ€§å€¼æ˜¯trueæˆ–falseandroid:layout_centerHrizontal æ°´å¹³å±…ä¸­android:layout_centerVertical å‚ç›´å±…ä¸­android:layout_centerInparent ç›¸å¯¹äºçˆ¶å…ƒç´ å®Œå…¨å±…ä¸­ã€‚android:layout_alignParentBottom ä½äºçˆ¶å…ƒç´ çš„ä¸‹è¾¹ç¼˜android:layout_alignParentTop ä½äºçˆ¶å…ƒç´ çš„ä¸Šè¾¹ç¼˜android:layout_alignParentLeft ä½äºçˆ¶å…ƒç´ çš„å·¦è¾¹ç¼˜android:layout_alignParentRight ä½äºçˆ¶å…ƒç´ çš„å³è¾¹ç¼˜å±æ€§å€¼æ˜¯â€@id/*â€œandroid:layout_below åœ¨æŸå…ƒç´ çš„ä¸‹æ–¹android:layout_above åœ¨æŸå…ƒç´ çš„ä¸Šæ–¹andorid:layout_toRightOf åœ¨æŸå…ƒç´ çš„å³æ–¹android:layout_toLeftOf åœ¨æŸå…ƒç´ çš„å·¦æ–¹android:layout_alignBottom å’ŒæŸå…ƒç´ ä¸‹æ–¹å¯¹é½android:layout_alignTop å’ŒæŸå…ƒç´ ä¸Šæ–¹å¯¹é½android:layout_alignRight å’ŒæŸå…ƒç´ å³æ–¹å¯¹é½android:layout_alignLeft å’ŒæŸå…ƒç´ å·¦æ–¹å¯¹é½å±æ€§å€¼æ˜¯æ•°å€¼android:layout_marginLeft ç¦»æŸå…ƒç´ å·¦è¾¹ç¼˜çš„è·ç¦»android:layout_marginRight ç¦»æŸå…ƒç´ å³è¾¹ç¼˜çš„è·ç¦»android:layout_marginTop ç¦»æŸå…ƒç´ ä¸Šè¾¹ç¼˜çš„è·ç¦»android:layout_marginBottom ç¦»æŸå…ƒç´ ä¸‹è¾¹ç¼˜çš„è·ç¦»ä¸Šé¢è¿™ä¸¤ç§æ˜¯æœ€å¸¸ç”¨çš„ä¸¤ç§å¸ƒå±€ï¼ŒåŸºæœ¬èƒ½å®Œæˆä¸€äº›åŸºæœ¬çš„å¸ƒå±€äº†ã€‚ 1.3.3 è‡ªå®šä¹‰å¸ƒå±€ è‡ªå®šä¹‰æ˜¯å¯¹ViewGroupè¿›è¡Œç»§æ‰¿ï¼Œä¸€èˆ¬è¦å®ç°ä»¥ä¸‹æ–¹æ³•ï¼š é‡å†™onMeasure()æ–¹æ³•å¯¹å­Viewè¿›è¡Œæµ‹é‡ã€‚åœ¨onMeasureä¸­è®¡ç®—childViewçš„æµ‹é‡å€¼ä»¥åŠæ¨¡å¼ï¼Œä»¥åŠè®¾ç½®è‡ªå·±çš„å®½å’Œé«˜ã€‚ é‡å†™onLayout()æ–¹æ³•ç¡®å®šå­Viewçš„ä½ç½®ï¼Œå¯¹æ‰€æœ‰childViewè¿›è¡Œå®šä½ï¼ˆè®¾ç½®childViewçš„ç»˜åˆ¶åŒºåŸŸï¼‰ã€‚è‡ªå®šä¹‰ViewGroupæ˜¯å¾ˆæœ‰å¿…è¦çš„ï¼Œå› ä¸ºå½“å®˜æ–¹ç»™å‡ºçš„ç©ºé—´æ— æ³•æ»¡è¶³è‡ªå·±çš„éœ€æ±‚æ—¶ï¼Œå°±éœ€è¦è‡ªå·±å–å®šä¹‰ä¸€ç§å¸ƒå±€äº†ã€‚ 1.3.4 FrameLayoutæ¡†æ¶å¸ƒå±€ï¼Œç¬¬ä¸€ä¸ªæ§ä»¶æ”¾åœ¨æœ€åº•å±‚çš„å·¦ä¸Šè§’ï¼Œç„¶ååé¢çš„æ§ä»¶åœ¨å·¦ä¸Šè§’ä¸€å±‚ä¸€å±‚çš„è¦†ç›–ä¸Šå»ã€‚ç±»ä¼¼äºPså›¾å±‚çš„æ ·å­ã€‚ 1.3.5 TableLayoutè¡¨æ ¼å¸ƒå±€ï¼Œé¡¾åæ€ä¹‰ï¼Œå°±æ˜¯ä¸€ä¸ªè¡¨æ ¼ã€‚å®ƒéµå¾ªç€ä»¥ä¸‹ç»“æ„ï¼š 12345678&lt;TableLayout&gt; &lt;TableRow&gt; &lt;!-åœ¨è¿™é‡Œå¡«å……ç¬¬ä¸€è¡Œçš„å…ƒç´ -&gt; &lt;/TableRow&gt; &lt;TableRow&gt; &lt;!-åœ¨è¿™é‡Œå¡«å……ç¬¬äºŒè¡Œçš„å…ƒç´ -&gt; &lt;/TableRow&gt; &lt;/TableLayout&gt; è¿˜æœ‰å‡ ä¸ªé‡è¦å±æ€§ï¼š å†™åœ¨TableLayoutä¸­çš„å±æ€§ android:stretchColumns è®¾ç½®ç¬¬å‡ åˆ—ä¸ºä¼¸å±•(0è¡¨ç¤ºç¬¬ä¸€åˆ—) ndroid:shrinkColumns è®¾ç½®ç¬¬å‡ åˆ—ä¸ºæ”¶ç¼© android:collapseColumns è®¾ç½®ç¬¬å‡ åˆ—ä¸ºéšè— å†™åœ¨TableRowé‡Œçš„æ§ä»¶é‡Œçš„å±æ€§ android:layout_column è®¾ç½®æ§ä»¶åœ¨ç¬¬å‡ åˆ— android:layout_span è®¾ç½®æ§ä»¶èƒ½è·¨å¤šå°‘åˆ— 1.3.6 AbsoluteLayoutç»å¯¹å¸ƒå±€ï¼Œå·²ç»è¢«æ·˜æ±°äº†çš„å¸ƒå±€ã€‚ æ‰€æœ‰æ§ä»¶éƒ½è¦è®¾ç½®x,yåæ ‡ï¼Œä½¿ç”¨ç»å¯¹çš„å¸ƒå±€ã€‚ android:layout_x //æ§ä»¶xåæ ‡android:layout_y //æ§ä»¶yåæ ‡ 1.4 æ§ä»¶ 1.4.1 androidè‡ªå¸¦æ§ä»¶1.4.2 è‡ªå®šä¹‰æ§ä»¶è‡ªå®šä¹‰æ§ä»¶æœ‰ä¸‰ç§æ–¹æ³•ï¼š å¯¹ç°æœ‰æ§ä»¶è¿›è¡Œæ‰©å±•ï¼Œç»§æ‰¿æ§ä»¶åé‡å†™onDraw()æ–¹æ³•ï¼Œåœ¨å›è°ƒçˆ¶ç±»æ–¹æ³•å‰å®ç°è‡ªå·±çš„é€»è¾‘ã€‚ é€šè¿‡ç»„åˆæ¥å®ç°æ–°çš„æ§ä»¶ é‡å†™Viewæ¥å®ç°å…¨æ–°çš„æ§ä»¶123456@Overrideprotected void onDraw(Canvas canvas){ //åœ¨å›è°ƒä¹‹å‰å®ç°è‡ªå·±é€»è¾‘ã€‚ super.onDraw(canvas); //åœ¨å›è°ƒä¹‹åå®ç°è‡ªå·±é€»è¾‘ã€‚} 2 åŠ¨æ€å¸ƒå±€2.1 ç”¨ç±»ä¿®æ”¹xmlå¯ä»¥ä½¿ç”¨findViewByIdæ‰¾åˆ°æƒ³è¦è¿›è¡Œæ¥ç®¡çš„æ§ä»¶ï¼Œç„¶åå†ä¿®æ”¹å…¶ä¸­çš„å±æ€§ï¼Œç„¶åè¾¾åˆ°åŠ¨æ€çš„ç›®çš„ã€‚ 2.2 åŠ¨æ€ç”Ÿæˆé¦–å…ˆåˆ›å»ºä¸€ä¸ªå¸ƒå±€ç®¡ç†å™¨ï¼Œç„¶åä½¿ç”¨setContentView()å°†å¸ƒå±€ç®¡ç†å™¨ç»˜åˆ¶å‡ºæ¥,ä¹‹åå†ç”¨addView()æ–¹æ³•åŠ å…¥æ§ä»¶å…ƒç´  Drawableç±»åŠXMLDrawableçš„ä½¿ç”¨ä¸€.æ€§è´¨å¯ç›´æ¥ä½¿ç”¨.pngã€.jpgã€.gifã€9.pngç­‰å›¾ç‰‡ä½œä¸ºèµ„æº,ä¹Ÿå¯ä½¿ç”¨å¤šç§XMLæ–‡ä»¶ä½œä¸ºèµ„æºã€‚ï¼ˆå°±æ˜¯è¿™äº›èµ„æºéƒ½èƒ½ç”ŸæˆDrawableå¯¹è±¡ï¼‰ã€‚å¹¶å¯¹XMLæ–‡ä»¶ä½œå‡ºç›¸å…³å¤„ç† äºŒ.XMLDrawable1.StateListDrawable(selector)ä½œç”¨ï¼šStateListDrawableå¯¹è±¡æ‰€æ˜¾ç¤ºçš„Drawableå¯¹è±¡ä¼šéšç€ç›®æ ‡ç»„ä»¶çŠ¶æ€çš„æ”¹å˜è€Œæ”¹å˜ ç»„æˆï¼š 123æ ¹å…ƒç´ &lt;selector/&gt;ï¼Œå­å…ƒç´ &lt;item/&gt;å­å…ƒç´ &lt;item/&gt;çš„å±æ€§ï¼šandroid:coloræˆ–android:drawableandroid:state_xxx:çŠ¶æ€ 2.LayerDrawable(pså›¾å±‚)ä½œç”¨ï¼šå¯åŒ…å«ä¸€ä¸ªDrawableæ•°ç»„ï¼Œç³»ç»Ÿä¼šæŒ‰ç…§Drawableå¯¹è±¡çš„æ•°ç»„é¡ºåºç»˜åˆ¶ï¼Œç´¢å¼•è¶Šå¤§è¶Šè¢«ç»˜åˆ¶åœ¨ä¸Šå±‚ 12345æ ¹å…ƒç´ ï¼š&lt;layer-list&gt; å­å…ƒç´ ï¼š&lt;item/&gt;å­å…ƒç´ çš„å±æ€§ï¼šandroid:drawable ä½œä¸ºLayerDrawableçš„Drawableå¯¹è±¡android:id ä¸ºDrawableå¯¹è±¡æŒ‡å®šæ ‡è¯†ç¬¦android:buttom|top...ç­‰ æŒ‡å®šDrawableçš„ç»˜åˆ¶ä½ç½® 3.ShapeDrawableä½œç”¨ï¼šè®¾ç½®ä¸€ä¸ªåŸºæœ¬çš„å‡ ä½•å›¾å½¢ï¼ˆçŸ©å½¢ã€åœ†å½¢ã€çº¿æ¡ç¯ï¼‰ 12345678910æ ¹å…ƒç´ ï¼š&lt;shape/&gt;æ ¹å…ƒç´ çš„å±æ€§ï¼šandroid:shape=[&quot;rectangle&quot;|&quot;oval&quot;|&quot;line&quot;|&quot;ring&quot;]å­å…ƒç´ ï¼š&lt;corners/&gt;ï¼šè®¾ç½®æ•´ä½“æˆ–è€…å››ä¸ªè¾¹è§’çš„å¼§åº¦&lt;gradient/&gt;:æ¸å˜ï¼ˆå¯é€‰æ‹©æ¸å˜çš„è§’åº¦ä½†å¿…é¡»æ˜¯45çš„å€æ•°ï¼Œé»˜è®¤ä¸º0ï¼Œæ¸å˜çš„ä¸­å¿ƒç‚¹ï¼Œæ¸å˜çš„ç±»å‹ï¼Œæ¸å˜çš„åŠå¾„å’Œå¼€å§‹å’Œç»ˆæ­¢çš„é¢œè‰²ï¼‰&lt;padding/&gt;:å†…è¾¹è· ï¼ˆå¯ä»¥æ§åˆ¶å››å‘¨çš„è¾¹è·ï¼‰&lt;size/&gt;:å½¢çŠ¶çš„å¤§å° ï¼ˆè®¾ç½®å½¢çŠ¶çš„å®½é«˜ï¼‰&lt;solid/&gt;:å•ç§é¢œè‰²å¡«å…… &lt;stroke/&gt;:ç»˜åˆ¶è¾¹æ¡† 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:dither=[&quot;true&quot; | &quot;false&quot;] //å°†åœ¨ä½å›¾çš„åƒç´ é…ç½®ä¸å±å¹•ä¸åŒæ—¶ï¼ˆä¾‹å¦‚ï¼šARGB 8888 ä½å›¾å’Œ RGB 565 å±å¹•ï¼‰å¯ç”¨ä½å›¾çš„æŠ–åŠ¨ï¼›å€¼ä¸ºâ€œfalseâ€æ—¶åˆ™åœç”¨æŠ–åŠ¨ã€‚é»˜è®¤å€¼ä¸º trueã€‚ android:shape=[&quot;rectangle&quot; | &quot;oval&quot; | &quot;line&quot; | &quot;ring&quot;]//åˆ†åˆ«ä¸ºçŸ©å½¢ã€æ¤­åœ†ã€çº¿ã€ç¯ã€‚é»˜è®¤ä¸ºçŸ©å½¢rectangle android:innerRadius=&quot;integer&quot; // shapeä¸ºringæ—¶æœ‰æ•ˆï¼Œå†…ç¯åŠå¾„ android:innerRadiusRatio=&quot;float&quot; // shapeä¸ºringæ—¶æœ‰æ•ˆï¼Œå†…ç¯çš„åšåº¦æ¯”ï¼Œå³ç¯çš„å›¾å½¢å®½åº¦ä¸å†…ç¯åŠå¾„çš„æ¯”ä¾‹ï¼ŒæŒ‰ç…§è¿™ä¸ªæ¯”ä¾‹è®¡ç®—å†…ç¯åŠå¾„ï¼Œé»˜è®¤ä¸º3ï¼Œå¯è¢«innerRadiuså€¼è¦†ç›– android:thickness=&quot;integer&quot; // shapeä¸ºringæ—¶æœ‰æ•ˆï¼Œç¯çš„åšåº¦ android:thicknessRatio=&quot;float&quot; // shapeä¸ºringæ—¶æœ‰æ•ˆï¼Œç¯çš„åšåº¦æ¯”ï¼Œå³ç¯çš„å›¾å½¢å®½åº¦ä¸ç¯çš„åšåº¦çš„æ¯”ä¾‹ï¼ŒæŒ‰ç…§è¿™ä¸ªæ¯”ä¾‹è®¡ç®—ç¯çš„åšåº¦ï¼Œé»˜è®¤ä¸º9ï¼Œå¯è¢«thicknesså€¼è¦†ç›– android:tint=&quot;color&quot; // ç»™shapeç€è‰² android:tintMode=[&quot;src_in&quot; | &quot;src_atop&quot; | &quot;src_over&quot; | &quot;add&quot; | &quot;multiply&quot; | &quot;screen&quot;] // ç€è‰²ç±»å‹ android:useLevel=[&quot;true&quot; | &quot;false&quot;] // è¾ƒå°‘ç”¨ï¼Œä¸€èˆ¬è®¾ä¸ºfalseï¼Œå¦åˆ™å›¾å½¢ä¸æ˜¾ç¤ºã€‚ä¸ºtrueæ—¶å¯åœ¨LevelListDrawableä½¿ç”¨ android:visible=[&quot;true&quot; | &quot;false&quot;] &gt; &lt;!-- åœ†è§’ --&gt; &lt;corners android:radius=&quot;integer&quot; // åœ†è§’åŠå¾„ï¼Œè®¾ç½®ä¸‹é¢å››ä¸ªå±æ€§æ—¶ï¼Œå¯¹åº”çš„ä½ç½®å±æ€§ä¼šè¢«è¦†ç›– android:topLeftRadius=&quot;integer&quot; // å·¦ä¸Šè§’åœ†è§’åŠå¾„ android:topRightRadius=&quot;integer&quot; // å³ä¸Šè§’åœ†è§’åŠå¾„ android:bottomLeftRadius=&quot;integer&quot; // å·¦ä¸‹è§’åœ†è§’åŠå¾„ android:bottomRightRadius=&quot;integer&quot; // å³ä¸‹è§’åœ†è§’åŠå¾„ /&gt; &lt;!-- æ¸å˜ --&gt; &lt;gradient android:type=[&quot;linear&quot; | &quot;radial&quot; | &quot;sweep&quot;]// æ¸å˜ç±»å‹ï¼Œçº¿æ€§ã€æ”¾å°„æ€§ã€æ‰«ææ€§ï¼›é»˜è®¤ä¸ºçº¿æ€§ android:angle=&quot;integer&quot; // æ¸å˜è§’åº¦ï¼Œæ¸å˜ç±»å‹ä¸ºlinearæ—¶æœ‰æ•ˆï¼›é»˜è®¤ä¸º0ï¼Œä»å·¦è‡³å³æ¸å˜ï¼Œè§’åº¦é€†æ—¶é’ˆæ–¹å‘è®¡ç®—ï¼Œè§’åº¦éœ€è¦æ—¶45çš„æ•´æ•°å€æ•° android:centerColor=&quot;integer&quot; // æ¸å˜ä¸­é—´ä½ç½®é¢œè‰² android:startColor=&quot;color&quot; // æ¸å˜å¼€å§‹ä½ç½®é¢œè‰² android:endColor=&quot;color&quot; // æ¸å˜ç»“æŸä½ç½®é¢œè‰² android:centerX=&quot;float&quot; // è®¾ç½®æ¸å˜ä¸­å¿ƒçš„Xåæ ‡ï¼Œå–å€¼åŒºé—´[0,1]ï¼Œé»˜è®¤ä¸º0.5ï¼Œå³ä¸­å¿ƒä½ç½® android:centerY=&quot;float&quot; // è®¾ç½®æ¸å˜ä¸­å¿ƒçš„Yåæ ‡ï¼Œå–å€¼åŒºé—´[0,1]ï¼Œé»˜è®¤ä¸º0.5ï¼Œå³ä¸­å¿ƒä½ç½® android:gradientRadius=&quot;integer&quot; // typeä¸ºæ”¾å°„æ€§æ¸å˜radialæ—¶æœ‰æ•ˆï¼Œæ¸å˜çš„åŠå¾„ android:useLevel=[&quot;true&quot; | &quot;false&quot;] // ä¸shapeä¸­è¯¥å±æ€§çš„ä¸€è‡´ /&gt; &lt;!-- å†…è¾¹è· --&gt; &lt;padding android:left=&quot;integer&quot; // å·¦è¾¹è· android:top=&quot;integer&quot; // ä¸Šè¾¹è· android:right=&quot;integer&quot; // å³è¾¹è· android:bottom=&quot;integer&quot; // ä¸‹è¾¹è· /&gt; &lt;!-- å¤§å° --&gt; &lt;size android:width=&quot;integer&quot; // å›¾å½¢å®½åº¦ android:height=&quot;integer&quot; // å›¾å½¢é«˜åº¦ /&gt; &lt;!-- å¡«å…… --&gt; &lt;solid android:color=&quot;color&quot; // å›¾å½¢çš„å¡«å……è‰² /&gt; &lt;!-- æè¾¹ --&gt; &lt;stroke android:width=&quot;integer&quot; // æè¾¹çš„å®½åº¦ android:color=&quot;color&quot; // æè¾¹çš„é¢œè‰² android:dashWidth=&quot;integer&quot; // è™šçº¿å®½åº¦ android:dashGap=&quot;integer&quot; // è™šçº¿é—´éš” /&gt;&lt;/shape&gt; å¯è®¾ç½®ç”»ç¬”çš„é¢œè‰²å’Œç²—ç»†å¹¶è®¾ç½®æ¯ç”»ä¸€æ¡çº¿çš„é•¿åº¦å’Œé—´è·ä¸”å¿…é¡»ä¸¤è€…éƒ½è®¾ç½®æ‰æœ‰æ•ˆ 4.ClipDrawableä½œç”¨ï¼šä»Drawableä¸Šæˆªå–ä¸€ä¸ªâ€å›¾ç‰‡ç‰‡æ®µâ€ 123456æ ¹å…ƒç´ ï¼š&lt;clip&gt; ä¸ä½¿ç”¨å­å…ƒç´ ã€‚æ ¹å…ƒç´ å±æ€§ï¼š android:drawable: é€‰å®šDrawableå¯¹è±¡android:clipOrientation:æŒ‡å®šæˆªå–æ–¹å‘android:gravity:ä»ä»€ä¹ˆåœ°æ–¹å¼€å§‹æˆªå– æ€»ç»“ï¼šé€‰å®šå›¾ç‰‡å¹¶é€‰æ‹©æ–¹å‘ä¸ä½ç½®æˆªå–å›¾ç‰‡ ä½¿ç”¨ï¼šä»javaä¸­è·å–ClipDrawableå¹¶ç”¨setLevel()æ”¹å˜æˆªå–å¤§å° //setLevel()åªèƒ½ä»0~10000 123456&lt;!--res/drawable/test_clip.xml--&gt;&lt;clip xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:drawable=&quot;@mipmap/start&quot; android:clipOrientation=&quot;horizontal&quot; android:gravity=&quot;center&quot;&gt;&lt;/clip&gt; 123456789101112131415&lt;!--res/layout/activity_main.xml--&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;com.chen.android.test.MainActivity&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/test_clip&quot;/&gt;&lt;/LinearLayout&gt; 12345678910111213141516171819202122232425262728293031323334353637/*å®ç°å›¾ç‰‡æ¸æ¸å±•å¼€çš„æ•ˆæœ*/public class MainActivity extends AppCompatActivity { int data = 0; int what = 0X11; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ImageView img = (ImageView)findViewById(R.id.imageView); //ImageView.getDrawable()è·å–çš„æ˜¯å½“å‰æ§ä»¶é‡Œçš„å›¾ç‰‡ï¼Œè¿”å›çš„æ˜¯Drawableç±»å‹,è¿˜æœ‰è¯´æ˜Drawableå¯¹è±¡å¯éšæ„å˜æˆå­å¯¹è±¡å¹¶è°ƒç”¨å­å¯¹è±¡çš„æ–¹æ³• final ClipDrawable clipDrawable = (ClipDrawable)img.getDrawable(); //åˆ›å»ºHandlerç­‰å¾…è®¡æ—¶å™¨ä¼ é€çš„ä¿¡æ¯ï¼Œä½¿å›¾ç‰‡æ‰©å±• final Handler mHandler = new Handler(){ @Override public void handleMessage(Message msg) { super.handleMessage(msg); if (msg.what == what){ clipDrawable.setLevel(data);//æ‰©å¤§æˆªå–çš„å›¾ç‰‡é¢ç§¯ data += 200; } } }; //åˆ›å»ºè®¡æ—¶å™¨ final Timer timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { if (data &gt;= 10000){ timer.cancel(); } mHandler.obtainMessage(what).sendToTarget(); } },0,300); }} 5.AnimationDrawableç®€ä»‹ï¼šæ”¾åœ¨res/animä¸‹ï¼Œæ”¯æŒé€å¸§åŠ¨ç”»å’Œè¡¥é—´åŠ¨ç”» 12345678910111213æ ¹å…ƒç´ ï¼š&lt;set&gt; æ ¹å…ƒç´ å±æ€§ï¼šandroid:interpolator=&quot;å‚æ•°&quot;linear_interpolatorï¼šåŒ€é€Ÿå˜æ¢ accelerate_interpolarï¼šåŠ é€Ÿå˜æ¢decelerate_interpolatorï¼šå‡é€Ÿå˜æ¢android:shareInterpolator= &quot;true|false&quot; ï¼šæ˜¯å¦è®©èµ„æºçš„interpolatorä¸æ ¹å…ƒç´ ç›¸åŒandroid:duration=&quot;æ—¶é—´&quot;ï¼šå®šä¹‰æŒç»­æ—¶é—´å­å…ƒç´ (åŒæ ·å¯ä»¥è®¾ç½®duration)&lt;alpha&gt;ï¼šè®¾ç½®å¼€å§‹å’Œç»“æŸçš„é€æ˜åº¦&lt;scale&gt;ï¼šè®¾ç½®ç¼©æ”¾çš„ä¸­å¿ƒã€å¼€å§‹çš„Xï¼ŒYçš„å°ºå¯¸å’Œç»“æŸæ—¶X,Yçš„å°ºå¯¸&lt;translate&gt;ï¼šè®¾ç½®å›¾ç‰‡çš„å¼€å§‹ä½ç½®å’Œç»“æŸä½ç½®è¿›è¡Œä½ç§»&lt;rotate&gt;ï¼šè®¾ç½®æ—‹è½¬çš„ä¸­å¿ƒã€å¼€å§‹çš„è§’åº¦å’Œç»“æŸæ—¶å€™çš„è§’åº¦ æ³¨æ„ï¼šåˆ©ç”¨android:fillAfter=â€true|falseâ€ï¼šè®¾ç½®ä¿ç•™åçš„çŠ¶æ€ï¼ˆå“ªä¸ªçŠ¶æ€æƒ³ä¿ç•™å°±ç”¨è¿™ä¸ªï¼Œå¦‚æœéƒ½åƒå°±æ”¾åœ¨setä¸­ï¼‰ ä½¿ç”¨ï¼šåˆ©ç”¨AnimationUtilsçš„é™æ€æ–¹æ³•loadAninmation(Context context,int resId) 123456789101112131415161718192021222324&lt;!--åœ¨res/anim/test_animtaionä¸­--&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@android:anim/linear_interpolator&quot; android:shareInterpolator=&quot;true&quot; android:fillAfter=&quot;true&quot;&gt; &lt;alpha android:fromAlpha=&quot;50.0&quot; android:toAlpha=&quot;100.0&quot; /&gt; &lt;scale android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:fromXScale=&quot;1.0&quot; android:fromYScale=&quot;1.0&quot; android:toXScale=&quot;1.5&quot; android:toYScale=&quot;1.5&quot; android:duration=&quot;3000&quot; /&gt; &lt;translate android:fromXDelta=&quot;30&quot; android:toXDelta=&quot;300&quot; android:fromYDelta=&quot;40&quot; android:toYDelta=&quot;90&quot; android:duration=&quot;3000&quot;/&gt;&lt;/set&gt; 123456789101112131415/*å®ç°åŠ¨ç”»*/public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ImageView img = (ImageView)findViewById(R.id.imageView); /*åˆ©ç”¨å·¥å…·ç±»è·å–å¯¹è±¡*/ Animation animation= AnimationUtils.loadAnimation(this,R.anim.test_animation); /*å°†åŠ¨ç”»é™„åŠ åœ¨å›¾ç‰‡ä¸Š*/ img.startAnimation(animation); }}","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8812%E6%97%A5/"},{"title":"å®ä¹ ç¬”è®°-3","text":"åœ¨å®‰å“ä¸­æ˜¾ç¤ºgifå›¾ç‰‡ä½¿ç”¨WebView 123456&lt;WebView android:id=&quot;@+id/runWebView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_centerVertical=&quot;true&quot; /&gt; 12345678runWebView.loadDataWithBaseURL(null,&quot;&lt;html&gt; &lt;body bgcolor='#f3f3f3'&gt; &lt;div align=center&gt; &lt;IMG src='file:///android_asset/run.gif'/&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&quot;, &quot;text/html&quot;, &quot;UTF-8&quot;,null); å®ç°åº•éƒ¨çŠ¶æ€æ ä½¿ç”¨recyclerview + gridlayoutmanager12345val rc_btm_navi = findViewById&lt;RecyclerView&gt;(R.id.rc_btm_navi)rc_btm_navi.layoutManager = GridLayoutManager(this,1).apply { orientation = GridLayoutManager.HORIZONTAL}rc_btm_navi.adapter = navi_adapter() adaperä¸­è·å–å±å¹•å®½åº¦ï¼Œåˆ›å»ºviewæ—¶è®¾ç½®viewçš„å®½åº¦1234567891011override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): view_holder { val view: View = LayoutInflater.from(parent.context) .inflate( R.layout.item_navi, parent, false ) view.layoutParams.width = getScreenWidth(activity) / navi_arr.size return view_holder(view)} è‡ªå®šä¹‰ä¸‹æ‹‰åˆ·æ–°(æ²¡å­¦ä¼š) TRANSLUCENT åŠé€æ˜ rectFç±» Rect F holds four float coordinates for a rectangle . The rectangleis represented by the coordinates of its 4 edges ( left , top , rightbottom ). These fields can be accessed directly . Use width () andheight () to retrieve the rectangle â€™ s width and height . Note :most methods do not check to see that the coordinates are sortedcorrectly ( i . e . left &lt;= right and top &lt;= bottom ). ViewFlipper(ç¿»è½¬è§†å›¾) å°±æ˜¯é¦–æ¬¡å®‰è£…è½¯ä»¶åçš„åŠŸèƒ½ä»‹ç»é¡µé¢ ä½¿ç”¨å¯¼å…¥å›¾ç‰‡123456789101112131415&lt;ViewFlipper android:id=&quot;@+id/vflp_help&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:inAnimation=&quot;@anim/right_in&quot; android:outAnimation=&quot;@anim/right_out&quot; android:flipInterval=&quot;3000&quot;&gt; &lt;include layout=&quot;@layout/page_help_one&quot; /&gt; &lt;include layout=&quot;@layout/page_help_two&quot; /&gt; &lt;include layout=&quot;@layout/page_help_three&quot; /&gt; &lt;include layout=&quot;@layout/page_help_four&quot; /&gt; &lt;!--æ­¤å¤„ä¸ºé™æ€å¯¼å…¥--&gt;&lt;/ViewFlipper&gt; 123456789//åŠ¨æ€å¯¼å…¥for(int i = 0;i &lt; resId.length;i++){ vflp_help.addView(getImageView(resId[i]));}private ImageView getImageView(int resId){ ImageView img = new ImageView(this); img.setBackgroundResource(resId); return img;} ç¿»åŠ¨æ‰‹åŠ¨ç¿»åŠ¨ è‡ªå®šä¹‰ä¸€ä¸ªGestureListener åˆ›å»ºä¸€ä¸ªGestureDetector é‡å†™activityçš„onTouchEvent12345678910111213141516171819private class MyGestureListener extends GestureDetector.SimpleOnGestureListener { @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float v, float v1) { if(e1.getX() - e2.getX() &gt; MIN_MOVE){ vflp_help.setInAnimation(mContext,R.anim.right_in); vflp_help.setOutAnimation(mContext, R.anim.right_out); vflp_help.showNext(); }else if(e2.getX() - e1.getX() &gt; MIN_MOVE){ vflp_help.setInAnimation(mContext,R.anim.left_in); vflp_help.setOutAnimation(mContext, R.anim.left_out); vflp_help.showPrevious(); } return true; }}@Overridepublic boolean onTouchEvent(MotionEvent event) { return mDetector.onTouchEvent(event);} 12//è‡ªåŠ¨ç¿»åŠ¨vflp_help.startFlipping(); fragmentä¸­å®ç°è§¦æ‘¸äº‹ä»¶å‚è€ƒ","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8814%E6%97%A5/"},{"title":"å®ä¹ ç¬”è®°-4","text":"ImageViewçš„å‚æ•°1android:adjustViewBounds=&quot;true&quot; å¯¹åº”æºç 1234567@android.view.RemotableViewMethodpublic void setAdjustViewBounds(boolean adjustViewBounds) { mAdjustViewBounds = adjustViewBounds; if (adjustViewBounds) { setScaleType(ScaleType.FIT_CENTER); }} åº”ç”¨åœºæ™¯ å½“å®½é«˜æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªè®¾ç½®ä¸ºwrapContentçš„æ—¶å€™æ˜¯æœ‰ç”¨ï¼ŒæŒ‡å®šä¸€ä¸ªå®½oré«˜ï¼Œå†æ ¹æ®drawableçš„æ¯”ä¾‹ç¡®å®šå¦ä¸€ä¸ªé«˜/å®½çš„å€¼ åè°ƒè€…å¸ƒå±€ CoordinateLayoutä½œç”¨åè°ƒå­ View ä¹‹é—´äº¤äº’çš„å®¹å™¨ ä½¿ç”¨ä¾‹1 ç‚¹å‡»FloatingActionBarå¼¹å‡ºsneakbarï¼Œå¦‚æœä¸é€‚ç”¨CoordinateLayoutï¼Œä¼šå¯¼è‡´å¼¹å‡ºçš„SneakBaré®æŒ¡ä½FAB layout_scrollFlags scroll|exitUntilCollapsedå¦‚æœAppBarLayoutçš„ç›´æ¥å­æ§ä»¶è®¾ç½®è¯¥å±æ€§,è¯¥å­æ§ä»¶å¯ä»¥æ»šåŠ¨,å‘ä¸Šæ»šåŠ¨NestedScrollViewå‡ºçˆ¶å¸ƒå±€(ä¸€èˆ¬ä¸ºCoordinatorLayout)æ—¶,ä¼šæŠ˜å åˆ°é¡¶ç«¯,å‘ä¸‹æ»šåŠ¨æ—¶NestedScrollViewå¿…é¡»æ»šåŠ¨åˆ°æœ€ä¸Šé¢çš„æ—¶å€™æ‰èƒ½æ‹‰å‡ºè¯¥å¸ƒå±€ scroll|enterAlwaysåªè¦å‘ä¸‹æ»šåŠ¨è¯¥å¸ƒå±€å°±ä¼šæ˜¾ç¤ºå‡ºæ¥,åªè¦å‘ä¸Šæ»‘åŠ¨è¯¥å¸ƒå±€å°±ä¼šå‘ä¸Šæ”¶ç¼© scroll|enterAlwaysCollapsedå‘ä¸‹æ»šåŠ¨NestedScrollViewåˆ°æœ€åº•ç«¯æ—¶è¯¥å¸ƒå±€æ‰ä¼šæ˜¾ç¤ºå‡ºæ¥å¦‚æœä¸è®¾ç½®æ”¹å±æ€§,åˆ™æ”¹å¸ƒå±€ä¸èƒ½æ»‘åŠ¨ snapæ»‘åŠ¨æ—¶çš„å¼¹æ€§ CollapsingToolbarLayoutå®ƒçš„ç›´æ¥å­å¸ƒå±€å¯ä»¥ä½¿ç”¨çš„å±æ€§:app:layout_collapseMode(æŠ˜å æ¨¡å¼) pin:åœ¨æ»‘åŠ¨è¿‡ç¨‹ä¸­,æ­¤è‡ªå¸ƒå±€ä¼šå›ºå®šåœ¨å®ƒæ‰€åœ¨çš„ä½ç½®ä¸åŠ¨,ç›´åˆ°CollapsingToolbarLayoutå…¨éƒ¨æŠ˜å æˆ–è€…å…¨éƒ¨å±•å¼€ parallax:è§†å·®æ•ˆæœï¼Œåœ¨æŠ˜å çš„æ—¶å€™ä¼šæœ‰ä¸ªè§†å·®æŠ˜å çš„æ•ˆæœ ä¸è®¾ç½®:è·ŸéšNestedScrollViewçš„æ»‘åŠ¨ä¸€èµ·æ»‘åŠ¨,NestedScrollViewæ»‘åŠ¨å¤šå°‘è·ç¦»ä»–å°±ä¼šè·Ÿç€èµ°å¤šå°‘è·ç¦» è‡ªå®šä¹‰Behavioré€šå¸¸è‡ªå®šä¹‰Behavioråˆ†ä¸ºä¸¤ç§æƒ…å†µï¼š æŸä¸ªViewä¾èµ–å¦ä¸€ä¸ªViewï¼Œç›‘å¬å…¶ä½ç½®ã€å°ºå¯¸ç­‰çŠ¶æ€çš„å˜åŒ–ã€‚ æŸä¸ªViewç›‘å¬CoordinatorLayoutå†…å®ç°äº†NestedScrollingChildæ¥å£çš„å­Viewçš„æ»‘åŠ¨çŠ¶æ€å˜åŒ–(ä¹Ÿæ˜¯ä¸€ç§ä¾èµ–å…³ç³»)ã€‚ åªæœ‰CoordinatorLayoutçš„ç›´æ¥å­å¸ƒå±€æ‰èƒ½å“åº” æ•ˆæœç¤ºä¾‹ å¯overrideçš„å‡ ä¸ªå‡½æ•° onInterceptTouchEvent()ï¼šæ˜¯å¦æ‹¦æˆªè§¦æ‘¸äº‹ä»¶ onTouchEvent()ï¼šå¤„ç†è§¦æ‘¸äº‹ä»¶ layoutDependsOn()ï¼šç¡®å®šä½¿ç”¨Behaviorçš„Viewè¦ä¾èµ–çš„Viewçš„ç±»å‹ onDependentViewChanged()ï¼šå½“è¢«ä¾èµ–çš„ViewçŠ¶æ€æ”¹å˜æ—¶å›è°ƒ onDependentViewRemoved()ï¼šå½“è¢«ä¾èµ–çš„Viewç§»é™¤æ—¶å›è°ƒ onMeasureChild()ï¼šæµ‹é‡ä½¿ç”¨Behaviorçš„Viewå°ºå¯¸ onLayoutChild()ï¼šç¡®å®šä½¿ç”¨Behaviorçš„Viewä½ç½® onStartNestedScroll()ï¼šåµŒå¥—æ»‘åŠ¨å¼€å§‹ï¼ˆACTION_DOWNï¼‰ï¼Œç¡®å®šBehavioræ˜¯å¦è¦ç›‘å¬æ­¤æ¬¡äº‹ä»¶ onStopNestedScroll()ï¼šåµŒå¥—æ»‘åŠ¨ç»“æŸï¼ˆACTION_UPæˆ–ACTION_CANCELï¼‰ onNestedScroll()ï¼šåµŒå¥—æ»‘åŠ¨è¿›è¡Œä¸­ï¼Œè¦ç›‘å¬çš„å­ Viewçš„æ»‘åŠ¨äº‹ä»¶å·²ç»è¢«æ¶ˆè´¹ onNestedPreScroll()ï¼šåµŒå¥—æ»‘åŠ¨è¿›è¡Œä¸­ï¼Œè¦ç›‘å¬çš„å­ Viewå°†è¦æ»‘åŠ¨ï¼Œæ»‘åŠ¨äº‹ä»¶å³å°†è¢«æ¶ˆè´¹ï¼ˆä½†æœ€ç»ˆè¢«è°æ¶ˆè´¹ï¼Œå¯ä»¥é€šè¿‡ä»£ç æ§åˆ¶ï¼‰ onNestedFling()ï¼šè¦ç›‘å¬çš„å­ Viewåœ¨å¿«é€Ÿæ»‘åŠ¨ä¸­ onNestedPreFling()ï¼šè¦ç›‘å¬çš„å­Viewå³å°†å¿«é€Ÿæ»‘åŠ¨ (å‚è€ƒ)[https://www.jianshu.com/p/b987fad8fcb4] NestedScrollView NestedScrollView ä¸ ScrollView ä¸€æ ·ï¼Œå†…éƒ¨åªèƒ½å®¹çº³ä¸€ä¸ªå­æ§ä»¶ã€‚å½“å­˜åœ¨å¤šä¸ªç»„ä»¶ï¼ˆäº§ç”Ÿæ»‘åŠ¨å†²çªæ—¶ï¼‰ï¼Œè§£å†³å†²çªçš„åŠæ³•ï¼š1android:nestedScrollingEnabled=&quot;false&quot; RecyclerView å®ç°ç€‘å¸ƒæµæ•ˆæœ 1ï¼‰é€šè¿‡LinearLayoutManagerï¼šæˆ‘ä»¬å¯ä»¥å®ç°æ¨ªå‘ã€çºµå‘çš„åˆ—è¡¨æ•ˆæœ 2ï¼‰é€šè¿‡GridLayoutManagerï¼šæˆ‘ä»¬å¯ä»¥å®ç°åƒGridViewä¸€æ ·çš„ç½‘æ ¼å¸ƒå±€ 3ï¼‰é€šè¿‡StaggeredGridLayoutManagerï¼šæˆ‘ä»¬å¯ä»¥å®ç°ç€‘å¸ƒæµçš„æ•ˆæœ ç½‘ç»œè¯·æ±‚è¸©å‘æ˜ç ä¼ è¾“ D/OkHttp: &lt;â€“ HTTP FAILED: java.net.UnknownServiceException: CLEARTEXT communication to japi.juhe.cn not permitted by network security policy ä¸ºä¿è¯ç”¨æˆ·æ•°æ®å’Œè®¾å¤‡çš„å®‰å…¨ï¼ŒGoogleé’ˆå¯¹ä¸‹ä¸€ä»£ Android ç³»ç»Ÿ(Android P) çš„åº”ç”¨ç¨‹åºï¼Œå°†è¦æ±‚é»˜è®¤ä½¿ç”¨åŠ å¯†è¿æ¥ï¼Œè¿™æ„å‘³ç€ Android P å°†ç¦æ­¢ App ä½¿ç”¨æ‰€æœ‰æœªåŠ å¯†çš„è¿æ¥ï¼Œå› æ­¤è¿è¡Œ Android P ç³»ç»Ÿçš„å®‰å“è®¾å¤‡æ— è®ºæ˜¯æ¥æ”¶æˆ–è€…å‘é€æµé‡ï¼Œæœªæ¥éƒ½ä¸èƒ½æ˜ç ä¼ è¾“ã€‚ åœ¨resæ–‡ä»¶å¤¹ä¸‹åˆ›å»ºä¸€ä¸ªxmlæ–‡ä»¶å¤¹ï¼Œç„¶ååˆ›å»ºä¸€ä¸ªnetwork_security_config.xmlæ–‡ä»¶ï¼Œæ–‡ä»¶å†…å®¹å¦‚ä¸‹ï¼š1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted=&quot;true&quot; /&gt;&lt;/network-security-config&gt; æ¥ç€ï¼Œåœ¨AndroidManifest.xmlæ–‡ä»¶ä¸‹çš„applicationæ ‡ç­¾å¢åŠ ä»¥ä¸‹å±æ€§1android:networkSecurityConfig=&quot;@xml/network_security_config&quot; å£°æ˜æƒé™ 12&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; æ³¨æ„æ ‡ç­¾æ˜¯uses-permissionï¼Œä¸æ˜¯permission","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8817%E6%97%A5/"},{"title":"å®ä¹ ç¬”è®°-7","text":"FragmentActivityå’ŒActivityçš„å…·ä½“åŒºåˆ«åœ¨å“ªé‡Œfragmentæ˜¯3.0ä»¥åçš„ä¸œè¥¿ï¼Œä¸ºäº†åœ¨ä½ç‰ˆæœ¬ä¸­ä½¿ç”¨fragmentå°±è¦ç”¨åˆ°android-support-v4.jarå…¼å®¹åŒ…,fragmentActivityæä¾›äº†æ“ä½œfragmentçš„ä¸€äº›æ–¹æ³•ï¼Œå…¶åŠŸèƒ½è·Ÿ3.0åŠä»¥åçš„ç‰ˆæœ¬çš„Activityçš„åŠŸèƒ½ä¸€æ ·ã€‚ 1ã€fragmentactivity ç»§æ‰¿è‡ªactivityï¼Œç”¨æ¥è§£å†³android3.0 ä¹‹å‰æ²¡æœ‰fragmentçš„apiï¼Œæ‰€ä»¥åœ¨ä½¿ç”¨çš„æ—¶å€™éœ€è¦å¯¼å…¥supportåŒ…ï¼ŒåŒæ—¶ç»§æ‰¿fragmentActivityï¼Œè¿™æ ·åœ¨activityä¸­å°±èƒ½åµŒå…¥fragmentæ¥å®ç°ä½ æƒ³è¦çš„å¸ƒå±€æ•ˆæœã€‚ 2ã€å½“ç„¶3.0ä¹‹åä½ å°±å¯ä»¥ç›´æ¥ç»§æ‰¿è‡ªActivityï¼Œå¹¶ä¸”åœ¨å…¶ä¸­åµŒå…¥ä½¿ç”¨fragmentäº†ã€‚ 3ã€è·å¾—Managerçš„æ–¹å¼ä¹Ÿä¸åŒ 3.0ä»¥ä¸‹ï¼šgetSupportFragmentManager() 3.0ä»¥ä¸Šï¼šgetFragmentManager()ï¼ˆå·²å¼ƒç”¨ï¼‰ activity è½¬åœºåŠ¨ç”» å‚è€ƒ ä½¿ç”¨windowAnimationå’ŒActivityAnimation windowAnimationåŒ…å« windowEnterAnimation windowExitAnimation ActivityAnimationåŒ…å« android:activityOpenEnterAnimation android:activityOpenExitAnimation android:activityCloseEnterAnimation android:activityCloseExitAnimation åœ¨é¡¹ç›®ä¸­WindowAnimationçš„æ§åˆ¶æƒå¤§äºActivityçš„æ§åˆ¶æƒï¼Œå³åœ¨Activityè½¬åœºè¿‡ç¨‹ä¸­ï¼Œå¦‚æœåŒæ—¶è®¾ç½®äº†WindowAnimationå’ŒActivityAnimation,é‚£ä¹ˆ å¯èƒ½ï¼ˆå› ä¸ºè¿™ç§æƒ…å†µéå¸¸å¤šï¼‰ åªä¼šæ‰§è¡ŒWindowAnimation å¯¹äºWindowAnimationçš„å®šä¹‰å¾ˆç®€å•ï¼Œåœ¨style.xmlæ–‡ä»¶ä¸­åªéœ€è¦ç»§æ‰¿Animation.Styleå³å¯ overridePendingTransition åªèƒ½ç´§è·ŸstartActivityå’Œfinishä¹‹åè°ƒç”¨ xml styleåœ¨values/styles.xmlä¸‹ 1234567891011&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.DayNight.NoActionBar&quot;&gt; &lt;item name=&quot;android:windowAnimationStyle&quot;&gt;@style/myActivityOutEnterAnima&lt;/item&gt;&lt;/style&gt;&lt;style name=&quot;myActivityOutEnterAnima&quot; parent=&quot;@android:style/Animation.Activity&quot;&gt;&lt;!-- å®šä¹‰activityçš„è¿›å‡ºåœºåŠ¨ç”» --&gt; &lt;item name=&quot;android:activityOpenEnterAnimation&quot;&gt;@anim/enter_from_right&lt;/item&gt; &lt;item name=&quot;android:activityOpenExitAnimation&quot;&gt;@anim/out_to_left&lt;/item&gt; &lt;item name=&quot;android:activityCloseEnterAnimation&quot;&gt;@anim/enter_from_left&lt;/item&gt; &lt;item name=&quot;android:activityCloseExitAnimation&quot;&gt;@anim/out_to_right&lt;/item&gt;&lt;/style&gt; æœ€åç»™Application/activityé…ç½®themeé€‰é¡¹ 5.0ä»¥å å†…ç½®Activityåˆ‡æ¢åŠ¨ç”»å¸¸ç”¨å‚æ•° enterï¼šç”¨äºå†³å®šç¬¬ä¸€æ¬¡æ‰“å¼€å½“å‰Activityæ—¶çš„åŠ¨ç”» exit : ç”¨äºå†³å®šé€€å‡ºå½“å‰Activityæ—¶çš„åŠ¨ç”» reenter: ç”¨äºå†³å®šå¦‚æœå½“å‰Activityå·²ç»æ‰“å¼€è¿‡ï¼Œå¹¶ä¸”å†æ¬¡æ‰“å¼€è¯¥Activityæ—¶çš„åŠ¨ç”» shared elements:ç”¨äºå†³å®šåœ¨ä¸¤ä¸ªActivityä¹‹é—´åˆ‡æ¢æ—¶ï¼ŒæŒ‡å®šä¸¤ä¸ªActivityä¸­å¯¹åº”çš„Viewçš„è¿‡æ¸¡æ•ˆæœ æ­¥éª¤1.åœ¨setContentView()ä¹‹å‰æ‰§è¡Œï¼Œç”¨äºå‘Šè¯‰Windowé¡µé¢åˆ‡æ¢éœ€è¦ä½¿ç”¨åŠ¨ç”»æ¥ä¸‹æ¥å°±æ˜¯åŠ è½½åˆ‡æ¢åŠ¨ç”»1getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS); 2.åŠ è½½åˆ‡æ¢åŠ¨ç”»123Transition explode = TransitionInflater .from(this) .inflateTransition(R.transition.explode); 3.å‘Šè¯‰Windowï¼Œå½“å‰çš„Activityåœ¨ä»€ä¹ˆæƒ…å†µä¸‹ä½¿ç”¨ä¸Šé¢çš„åŠ¨ç”»123getWindow().setExitTransition(explode);getWindow().setEnterTransition(explode);getWindow().setReenterTransition(explode); æˆ–è€…åœ¨ä¸»é¢˜ä¸­æ·»åŠ  123&lt;item name=&quot;android:windowExitTransition&quot;&gt;@transition/explode&lt;/item&gt;&lt;item name=&quot;android:windowEnterTransition&quot;&gt;@transition/explode&lt;/item&gt;&lt;item name=&quot;android:windowReenterTransition&quot;&gt;@transition/explode&lt;/item&gt; 4.è°ƒç”¨startActivityæ—¶ï¼Œå°†Transitionå˜æˆbundle1startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(this).toBundle()); ä½¿ç”¨å†…ç½®åŠ¨ç”»åœ¨res/transitionç›®å½•ä¸‹ï¼Œæ–°å»ºxmlæ–‡ä»¶ 123&lt;explode xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;300&quot; /&gt; 123456&lt;slide xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:slideEdge=&quot;end&quot; android:duration=&quot;300&quot; /&gt; &lt;!--slideEdgeè¡¨ç¤ºèµ·å§‹æ»‘åŠ¨çš„ä¾§è¾¹ä½ç½®--&gt; &lt;!-- start, end top,bottom --&gt; å¦‚æœä¸å¸Œæœ›çŠ¶æ€æ ï¼Œå¯¼èˆªæ è·Ÿéšä¸€èµ·æ‰§è¡ŒåŠ¨ç”»ï¼Œå¯ä»¥æ·»åŠ  target excludeId 123456789&lt;slide xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:slideEdge=&quot;end&quot; android:duration=&quot;300&quot;&gt; &lt;target android:excludeId=&quot;@android:id/navigationBarBackground&quot;/&gt; &lt;target android:excludeId=&quot;@android:id/statusBarBackground&quot;/&gt; &lt;/slide&gt; &lt;!--slideEdgeè¡¨ç¤ºèµ·å§‹æ»‘åŠ¨çš„ä¾§è¾¹ä½ç½®--&gt; &lt;!-- start, end top,bottom --&gt; 123&lt;fade xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;300&quot; /&gt; sharedElementæ•ˆæœå…±äº«å…ƒç´ æ•ˆæœï¼Œä¸å‰é¢å‡ ç§æ•ˆæœä¸åŒçš„æ˜¯ï¼Œå…±äº«å…ƒç´ æ•ˆæœæ˜¯å°†å‰é¢ä¸€ä¸ªActivityçš„æŸä¸ªå­Viewä¸åé¢ä¸€ä¸ªActivityçš„æŸä¸ªå­Viewä¹‹é—´æœ‰è¿‡æ¸¡æ•ˆæœ 1.å°†ä¸¤ä¸ªActivityä¸­éœ€è¦è¿‡æ¸¡çš„ViewåŠ ä¸ŠAndroid:transitionNameå±æ€§ä¸¤ä¸ªViewçš„android:transitionNameå±æ€§å–å€¼è¦ä¸€è‡´ 2.è°ƒç”¨startActivityï¼ŒmakeTransitionAnimationæ—¶æ·»åŠ ç¬¬äºŒä¸ªå‚æ•°â€“ç¬¬ä¸€ä¸ªActivityä¸­çš„viewå¯¹è±¡ï¼Œç¬¬ä¸‰ä¸ªå‚æ•°â€“transitionName1startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(this, SharedView, &quot;TransitionName&quot;).toBundle()) æ·»åŠ å¤šä¸ªviewåŒæ—¶å…·æœ‰Transitionè¿‡åº¦åˆ‡æ¢æ•ˆæœæŠŠSharedViewå’ŒTransitionNameç»„æˆä¸€ä¸ªPairï¼Œä¾æ¬¡ç©¿ç»™makeSceneTransitionAnimation 123Pair first = new Pair&lt;&gt;(firstSharedView, ViewCompat.getTransitionName(firstSharedView));Pair second = new Pair&lt;&gt;(secondSharedView, ViewCompat.getTransitionName(secondSharedView));ActivityOptionsCompat.makeSceneTransitionAnimation(activity, first, second); è‡ªå®šä¹‰è¿‡æ¸¡åŠ¨ç”»è½¨è¿¹è·¯å¾„1.åˆ›å»ºä¸€ä¸ªViewçš„è¿‡æ¸¡ç§»åŠ¨çš„è½¨è¿¹è·¯å¾„PathMotionç±» æˆ‘ä»¬å¯ä»¥åˆ›å»ºArcMotionå¯¹è±¡ï¼ŒArcMotionæ˜¯PathMotionå­ç±»ï¼Œæ˜¯ä¸ªæ›²çº¿è·¯å¾„ã€‚æƒ³è¦äº†è§£æ›´å¤šArcMotionå¯ä»¥æŸ¥çœ‹ï¼š ArcMotionå®˜æ–¹æ–‡æ¡£ 2.å®šä¹‰ChangeBoundsç±»æˆ‘ä»¬è‡ªå®šä¹‰ä¸€ä¸ªç»§æ‰¿ChangeBoundsçš„ç±»ï¼Œä¸»è¦é‡å†™createAnimatorå‡½æ•°ï¼Œå³åˆ›å»ºä½ è¦æ‰§è¡Œçš„åŠ¨ç”»ã€‚è¿™ä¸ªå‡½æ•°ç”±3ä¸ªå‚æ•°ï¼š ViewGroup sceneRootï¼šå±å¹•æ ¹Viewï¼Œå³DecorViewï¼Œç¬¬äºŒä¸ªActivityçš„DecorViewã€‚ TransitionValues startValues ï¼šå±æ€§åŠ¨ç”»çš„èµ·å§‹å±æ€§å€¼ï¼ŒTransitionValues å¯¹è±¡å†…éƒ¨æœ‰å„Mapç±»å‹çš„å±æ€§valuesï¼Œç”¨äºä¿å­˜éœ€è¦æ‰§è¡Œå±æ€§åŠ¨ç”»çš„å±æ€§ã€‚è¿™ä¸ªé‡Œé¢çš„å±æ€§å€¼æ˜¯åœ¨å‡½æ•°captureStartValuesé‡Œæ”¾ç½®ï¼Œå› æ­¤ä½ å¯ä»¥é‡å†™captureStartValueså‡½æ•°ï¼Œå¹¶æŠŠä½ è‡ªå®šä¹‰çš„å±æ€§åŠ¨ç”»ä¸­çš„å±æ€§æ”¾è¿›å»ã€‚ TransitionValues endValuesï¼šä¸startValuesç±»ä¼¼ï¼Œè¡¨ç¤ºå±æ€§åŠ¨ç”»ç»“æŸæ—¶çš„å±æ€§å€¼ã€‚å¯ä»¥é€šè¿‡é‡å†™captureEndValueså‡½æ•°ï¼Œå¹¶æŠŠä½ è‡ªå®šä¹‰çš„å±æ€§åŠ¨ç”»é‡Œé¢çš„æœ€ç»ˆå±æ€§å€¼æ”¾è¿›å»ã€‚ è‡ªåŠ¨å¼¹èµ·è½¯é”®ç›˜1234567891011window.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE)et.postDelayed({ runOnUiThread { et.isFocusable = true et.isFocusableInTouchMode = true et.requestFocus() et.findFocus() val inputManager = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager inputManager.showSoftInput(et, InputMethodManager.SHOW_IMPLICIT) }},300) ä»£ç æ··æ·†application åˆå§‹åŒ–å‡å°‘log å¿…é¡»åŠ debugviewbindingæµ·å¤–å·¥ä½œæ³¨æ„äº‹é¡¹ æµ·å¤–appå¼€å‘æ—¶ä¸èƒ½è¿å…¬å¸wifiï¼Œå¿…é¡»æ–­ç½‘ï¼Œæˆ–è€…ç”¨4g ä¸ä¼šçš„ä¸œè¥¿è‡ªå·±è§£å†³ä¸äº†ï¼Œå¤§èƒ†å’ŒåŒäº‹è¯·æ•™å’ŒåŒäº‹åè°ƒæ—¶é—´å’Œè¿›åº¦ã€‚ å¿ƒæ€ä¸Š åˆ«äººæŒ‡å‡ºé—®é¢˜ï¼Œæœ‰è‡ªå·±åˆ¤æ–­ï¼Œè¦å®¢è§‚","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8821%E6%97%A5/"},{"title":"å®ä¹ ç¬”è®°-6","text":"recyclerview åˆ·æ–°æ•°ç»„è¶Šç•Œé—®é¢˜å±æ€§åŠ¨ç”» å‚è€ƒ recyclerview ç‚¹å‡»ä½ç§»","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8820%E6%97%A5/"},{"title":"å®ä¹ ç¬”è®°-5","text":"gitç›¸å…³çŸ¥è¯† å‚è€ƒ æ–°å»ºä»£ç åº“12345678## å½“å‰ç›®å½• æ–°å»ºä¸€ä¸ªGitä»£ç åº“$ git init ## æ–°å»ºä¸€ä¸ªç›®å½•ï¼Œå°†å…¶åˆå§‹åŒ–ä¸ºGitä»£ç åº“$ git init [project-name] ## ä¸‹è½½ä¸€ä¸ªé¡¹ç›®å’Œå®ƒçš„æ•´ä¸ªä»£ç å†å²$ git clone [url] é…ç½®123456789## æ˜¾ç¤ºå½“å‰çš„Gité…ç½®$ git config --list ## ç¼–è¾‘Gité…ç½®æ–‡ä»¶$ git config -e [--global] ## è®¾ç½®æäº¤ä»£ç æ—¶çš„ç”¨æˆ·ä¿¡æ¯$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; å¢åŠ /åˆ é™¤æ–‡ä»¶123456789101112131415161718192021## æ·»åŠ æŒ‡å®šæ–‡ä»¶åˆ°æš‚å­˜åŒº$ git add [file1] [file2] ... ## æ·»åŠ æŒ‡å®šç›®å½•åˆ°æš‚å­˜åŒºï¼ŒåŒ…æ‹¬å­ç›®å½•$ git add [dir] ## æ·»åŠ å½“å‰ç›®å½•çš„æ‰€æœ‰æ–‡ä»¶åˆ°æš‚å­˜åŒº$ git add . ## æ·»åŠ æ¯ä¸ªå˜åŒ–å‰ï¼Œéƒ½ä¼šè¦æ±‚ç¡®è®¤## å¯¹äºåŒä¸€ä¸ªæ–‡ä»¶çš„å¤šå¤„å˜åŒ–ï¼Œå¯ä»¥å®ç°åˆ†æ¬¡æäº¤$ git add -p ## åˆ é™¤å·¥ä½œåŒºæ–‡ä»¶ï¼Œå¹¶ä¸”å°†è¿™æ¬¡åˆ é™¤æ”¾å…¥æš‚å­˜åŒº$ git rm [file1] [file2] ... ## åœæ­¢è¿½è¸ªæŒ‡å®šæ–‡ä»¶ï¼Œä½†è¯¥æ–‡ä»¶ä¼šä¿ç•™åœ¨å·¥ä½œåŒº$ git rm --cached [file] ## æ”¹åæ–‡ä»¶ï¼Œå¹¶ä¸”å°†è¿™ä¸ªæ”¹åæ”¾å…¥æš‚å­˜åŒº$ git mv [file-original] [file-renamed] -p å‚æ•°çš„æç¤º1234567891011121314y - stage this hunkn - do not stage this hunkq - quit; do not stage this hunk nor any of the remaining onesa - stage this hunk and all later hunks in the filed - do not stage this hunk nor any of the later hunks in the fileg - select a hunk to go to/ - search for a hunk matching the given regexj - leave this hunk undecided, see next undecided hunkJ - leave this hunk undecided, see next hunkk - leave this hunk undecided, see previous undecided hunkK - leave this hunk undecided, see previous hunks - split the current hunk into smaller hunkse - manually edit the current hunk? - print help ä»£ç æäº¤123456789101112131415161718## æäº¤æš‚å­˜åŒºåˆ°ä»“åº“åŒº$ git commit -m [message] ## æäº¤æš‚å­˜åŒºçš„æŒ‡å®šæ–‡ä»¶åˆ°ä»“åº“åŒº$ git commit [file1] [file2] ... -m [message] ## æäº¤å·¥ä½œåŒºè‡ªä¸Šæ¬¡commitä¹‹åçš„å˜åŒ–ï¼Œç›´æ¥åˆ°ä»“åº“åŒº$ git commit -a ## æäº¤æ—¶æ˜¾ç¤ºæ‰€æœ‰diffä¿¡æ¯$ git commit -v ## ä½¿ç”¨ä¸€æ¬¡æ–°çš„commitï¼Œæ›¿ä»£ä¸Šä¸€æ¬¡æäº¤## å¦‚æœä»£ç æ²¡æœ‰ä»»ä½•æ–°å˜åŒ–ï¼Œåˆ™ç”¨æ¥æ”¹å†™ä¸Šä¸€æ¬¡commitçš„æäº¤ä¿¡æ¯$ git commit --amend -m [message] ## é‡åšä¸Šä¸€æ¬¡commitï¼Œå¹¶åŒ…æ‹¬æŒ‡å®šæ–‡ä»¶çš„æ–°å˜åŒ–$ git commit --amend [file1] [file2] ... åˆ†æ”¯123456789101112131415161718192021222324252627282930313233343536373839404142## åˆ—å‡ºæ‰€æœ‰æœ¬åœ°åˆ†æ”¯$ git branch ## åˆ—å‡ºæ‰€æœ‰è¿œç¨‹åˆ†æ”¯$ git branch -r ## åˆ—å‡ºæ‰€æœ‰æœ¬åœ°åˆ†æ”¯å’Œè¿œç¨‹åˆ†æ”¯$ git branch -a ## æ–°å»ºä¸€ä¸ªåˆ†æ”¯ï¼Œä½†ä¾ç„¶åœç•™åœ¨å½“å‰åˆ†æ”¯$ git branch [branch-name] ## ä»¥è¿œç¨‹åˆ†æ”¯ä¸ºåŸºç¡€æ–°å»ºä¸€ä¸ªåˆ†æ”¯ï¼Œå¹¶åˆ‡æ¢åˆ°è¯¥åˆ†æ”¯$ git checkout -b [branch] origin/[remote-branch] ## æ–°å»ºä¸€ä¸ªåˆ†æ”¯ï¼ŒæŒ‡å‘æŒ‡å®šcommit$ git branch [branch] [commit] ## æ–°å»ºä¸€ä¸ªåˆ†æ”¯ï¼Œä¸æŒ‡å®šçš„è¿œç¨‹åˆ†æ”¯å»ºç«‹è¿½è¸ªå…³ç³»$ git branch --track [branch] [remote-branch] ## åˆ‡æ¢åˆ°æŒ‡å®šåˆ†æ”¯ï¼Œå¹¶æ›´æ–°å·¥ä½œåŒº$ git checkout [branch-name] ## åˆ‡æ¢åˆ°ä¸Šä¸€ä¸ªåˆ†æ”¯$ git checkout - ## å»ºç«‹è¿½è¸ªå…³ç³»ï¼Œåœ¨ç°æœ‰åˆ†æ”¯ä¸æŒ‡å®šçš„è¿œç¨‹åˆ†æ”¯ä¹‹é—´$ git branch --set-upstream [branch] [remote-branch] ## åˆå¹¶æŒ‡å®šåˆ†æ”¯åˆ°å½“å‰åˆ†æ”¯$ git merge [branch] ## é€‰æ‹©ä¸€ä¸ªcommitï¼Œåˆå¹¶è¿›å½“å‰åˆ†æ”¯$ git cherry-pick [commit] ## åˆ é™¤åˆ†æ”¯$ git branch -d [branch-name] ## åˆ é™¤è¿œç¨‹åˆ†æ”¯$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] æ ‡ç­¾ Git å¯ä»¥ç»™ä»“åº“å†å²ä¸­çš„æŸä¸€ä¸ªæäº¤æ‰“ä¸Šæ ‡ç­¾ï¼Œä»¥ç¤ºé‡è¦ã€‚ æ¯”è¾ƒæœ‰ä»£è¡¨æ€§çš„æ˜¯äººä»¬ä¼šä½¿ç”¨è¿™ä¸ªåŠŸèƒ½æ¥æ ‡è®°å‘å¸ƒç»“ç‚¹ï¼ˆ v1.0 ã€ v2.0 ç­‰ç­‰ï¼‰ã€‚ You have to commit first before tagging1234567891011121314151617181920212223242526272829303132## åˆ—å‡ºæ‰€æœ‰tag$ git tag## æŸ¥çœ‹tagçš„ä¿¡æ¯$ git show [tag] ## æ–°å»ºä¸€ä¸ªtagåœ¨å½“å‰commit$ git tag -a v1.4 -m &quot;my version 1.4&quot;## è½»é‡æ ‡ç­¾$ git tag [tag]## è½»é‡æ ‡ç­¾æœ¬è´¨ä¸Šæ˜¯å°†æäº¤æ ¡éªŒå’Œå­˜å‚¨åˆ°ä¸€ä¸ªæ–‡ä»¶ä¸­ï¼Œæ²¡æœ‰ä¿å­˜ä»»ä½•å…¶ä»–ä¿¡æ¯ã€‚ ## æ–°å»ºä¸€ä¸ªtagåœ¨æŒ‡å®šcommit$ git tag [tag] [commit] ## åˆ é™¤æœ¬åœ°tag$ git tag -d [tag] ## åˆ é™¤è¿œç¨‹tag$ git push origin :refs/tags/[tagName] ## æŸ¥çœ‹tagä¿¡æ¯$ git show [tag] ## æäº¤æŒ‡å®štag$ git push [remote] [tag] ## æäº¤æ‰€æœ‰tag$ git push [remote] --tags ## æ–°å»ºä¸€ä¸ªåˆ†æ”¯ï¼ŒæŒ‡å‘æŸä¸ªtag$ git checkout -b [branch] [tag] æŸ¥çœ‹ä¿¡æ¯123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960## æ˜¾ç¤ºæœ‰å˜æ›´çš„æ–‡ä»¶ï¼Œæœ¬åœ°æœªcommitçš„æ–‡ä»¶$ git status ## æ˜¾ç¤ºå½“å‰åˆ†æ”¯çš„ç‰ˆæœ¬å†å²$ git log ## æ˜¾ç¤ºcommitå†å²ï¼Œä»¥åŠæ¯æ¬¡commitå‘ç”Ÿå˜æ›´çš„æ–‡ä»¶$ git log --stat ## æœç´¢æäº¤å†å²ï¼Œæ ¹æ®å…³é”®è¯$ git log -S [keyword] ## æ˜¾ç¤ºæŸä¸ªcommitä¹‹åçš„æ‰€æœ‰å˜åŠ¨ï¼Œæ¯ä¸ªcommitå æ®ä¸€è¡Œ$ git log [tag] HEAD --pretty=format:%s ## æ˜¾ç¤ºæŸä¸ªcommitä¹‹åçš„æ‰€æœ‰å˜åŠ¨ï¼Œå…¶&quot;æäº¤è¯´æ˜&quot;å¿…é¡»ç¬¦åˆæœç´¢æ¡ä»¶$ git log [tag] HEAD --grep feature ## æ˜¾ç¤ºæŸä¸ªæ–‡ä»¶çš„ç‰ˆæœ¬å†å²ï¼ŒåŒ…æ‹¬æ–‡ä»¶æ”¹å$ git log --follow [file]$ git whatchanged [file] ## æ˜¾ç¤ºæŒ‡å®šæ–‡ä»¶ç›¸å…³çš„æ¯ä¸€æ¬¡diff$ git log -p [file] ## æ˜¾ç¤ºè¿‡å»5æ¬¡æäº¤$ git log -5 --pretty --oneline ## æ˜¾ç¤ºæ‰€æœ‰æäº¤è¿‡çš„ç”¨æˆ·ï¼ŒæŒ‰æäº¤æ¬¡æ•°æ’åº$ git shortlog -sn ## æ˜¾ç¤ºæŒ‡å®šæ–‡ä»¶æ˜¯ä»€ä¹ˆäººåœ¨ä»€ä¹ˆæ—¶é—´ä¿®æ”¹è¿‡$ git blame [file] ## æ˜¾ç¤ºæš‚å­˜åŒºå’Œå·¥ä½œåŒºçš„å·®å¼‚$ git diff ## æ˜¾ç¤ºæš‚å­˜åŒºå’Œä¸Šä¸€ä¸ªcommitçš„å·®å¼‚$ git diff --cached [file] ## æ˜¾ç¤ºå·¥ä½œåŒºä¸å½“å‰åˆ†æ”¯æœ€æ–°commitä¹‹é—´çš„å·®å¼‚$ git diff HEAD ## æ˜¾ç¤ºä¸¤æ¬¡æäº¤ä¹‹é—´çš„å·®å¼‚$ git diff [first-branch]...[second-branch] ## æ˜¾ç¤ºä»Šå¤©ä½ å†™äº†å¤šå°‘è¡Œä»£ç $ git diff --shortstat &quot;@{0 day ago}&quot; ## æ˜¾ç¤ºæŸæ¬¡æäº¤çš„å…ƒæ•°æ®å’Œå†…å®¹å˜åŒ–$ git show [commit] ## æ˜¾ç¤ºæŸæ¬¡æäº¤å‘ç”Ÿå˜åŒ–çš„æ–‡ä»¶$ git show --name-only [commit] ## æ˜¾ç¤ºæŸæ¬¡æäº¤æ—¶ï¼ŒæŸä¸ªæ–‡ä»¶çš„å†…å®¹$ git show [commit]:[filename] ## æ˜¾ç¤ºå½“å‰åˆ†æ”¯çš„æœ€è¿‘å‡ æ¬¡æäº¤$ git reflog è¿œç¨‹åŒæ­¥1234567891011121314151617181920212223## ä¸‹è½½è¿œç¨‹ä»“åº“çš„æ‰€æœ‰å˜åŠ¨$ git fetch [remote] ## æ˜¾ç¤ºæ‰€æœ‰è¿œç¨‹ä»“åº“$ git remote -v ## æ˜¾ç¤ºæŸä¸ªè¿œç¨‹ä»“åº“çš„ä¿¡æ¯$ git remote show [remote] ## å¢åŠ ä¸€ä¸ªæ–°çš„è¿œç¨‹ä»“åº“ï¼Œå¹¶å‘½å$ git remote add [shortname] [url] ## å–å›è¿œç¨‹ä»“åº“çš„å˜åŒ–ï¼Œå¹¶ä¸æœ¬åœ°åˆ†æ”¯åˆå¹¶$ git pull [remote] [branch] ## ä¸Šä¼ æœ¬åœ°æŒ‡å®šåˆ†æ”¯åˆ°è¿œç¨‹ä»“åº“$ git push [remote] [branch] ## å¼ºè¡Œæ¨é€å½“å‰åˆ†æ”¯åˆ°è¿œç¨‹ä»“åº“ï¼Œå³ä½¿æœ‰å†²çª$ git push [remote] --force ## æ¨é€æ‰€æœ‰åˆ†æ”¯åˆ°è¿œç¨‹ä»“åº“$ git push [remote] --all æ’¤é”€12345678910111213141516171819202122232425262728293031## æ¢å¤æš‚å­˜åŒºçš„æŒ‡å®šæ–‡ä»¶åˆ°å·¥ä½œåŒº$ git checkout [file] ## æ¢å¤æŸä¸ªcommitçš„æŒ‡å®šæ–‡ä»¶åˆ°æš‚å­˜åŒºå’Œå·¥ä½œåŒº$ git checkout [commit] [file] ## æ¢å¤æš‚å­˜åŒºçš„æ‰€æœ‰æ–‡ä»¶åˆ°å·¥ä½œåŒº$ git checkout . ## é‡ç½®æš‚å­˜åŒºçš„æŒ‡å®šæ–‡ä»¶ï¼Œä¸ä¸Šä¸€æ¬¡commitä¿æŒä¸€è‡´ï¼Œä½†å·¥ä½œåŒºä¸å˜$ git reset [file] ## é‡ç½®æš‚å­˜åŒºä¸å·¥ä½œåŒºï¼Œä¸ä¸Šä¸€æ¬¡commitä¿æŒä¸€è‡´$ git reset --hard ## é‡ç½®å½“å‰åˆ†æ”¯çš„æŒ‡é’ˆä¸ºæŒ‡å®šcommitï¼ŒåŒæ—¶é‡ç½®æš‚å­˜åŒºï¼Œä½†å·¥ä½œåŒºä¸å˜$ git reset [commit] ## é‡ç½®å½“å‰åˆ†æ”¯çš„HEADä¸ºæŒ‡å®šcommitï¼ŒåŒæ—¶é‡ç½®æš‚å­˜åŒºå’Œå·¥ä½œåŒºï¼Œä¸æŒ‡å®šcommitä¸€è‡´$ git reset --hard [commit] ## é‡ç½®å½“å‰HEADä¸ºæŒ‡å®šcommitï¼Œä½†ä¿æŒæš‚å­˜åŒºå’Œå·¥ä½œåŒºä¸å˜$ git reset --keep [commit] ## æ–°å»ºä¸€ä¸ªcommitï¼Œç”¨æ¥æ’¤é”€æŒ‡å®šcommit## åè€…çš„æ‰€æœ‰å˜åŒ–éƒ½å°†è¢«å‰è€…æŠµæ¶ˆï¼Œå¹¶ä¸”åº”ç”¨åˆ°å½“å‰åˆ†æ”¯$ git revert [commit] ## æš‚æ—¶å°†æœªæäº¤çš„å˜åŒ–ç§»é™¤ï¼Œç¨åå†ç§»å…¥$ git stash$ git stash pop gitåˆ†æ”¯ç®¡ç†masteråˆ†æ”¯å’Œå¼€å‘åˆ†æ”¯ ä¸»åˆ†æ”¯åªç”¨æ¥åˆ†å¸ƒé‡å¤§ç‰ˆæœ¬ï¼Œæ—¥å¸¸å¼€å‘åº”è¯¥åœ¨å¦ä¸€æ¡åˆ†æ”¯ä¸Šå®Œæˆã€‚æˆ‘ä»¬æŠŠå¼€å‘ç”¨çš„åˆ†æ”¯ï¼Œå«åšDevelopã€‚ åˆ›å»ºdevelopåˆ†æ”¯1git checkout -b develop master åˆå¹¶12345## åˆ‡æ¢åˆ°Masteråˆ†æ”¯git checkout master## å¯¹Developåˆ†æ”¯è¿›è¡Œåˆå¹¶git merge --no-ff develop --no-ffå‚æ•° é»˜è®¤æƒ…å†µä¸‹ï¼ŒGitæ‰§è¡Œâ€å¿«è¿›å¼åˆå¹¶â€ï¼ˆfast-farward mergeï¼‰ï¼Œä¼šç›´æ¥å°†Masteråˆ†æ”¯æŒ‡å‘Developåˆ†æ”¯ã€‚ ä½¿ç”¨--no-ffå‚æ•°ï¼Œä¼šæ‰§è¡Œæ­£å¸¸åˆå¹¶ï¼Œåœ¨Masteråˆ†æ”¯ä¸Šç”Ÿæˆä¸€ä¸ªæ–°èŠ‚ç‚¹ åŠŸèƒ½åˆ†æ”¯ ä¸ºäº†å¼€å‘æŸç§ç‰¹å®šåŠŸèƒ½ï¼Œä»Developåˆ†æ”¯ä¸Šé¢åˆ†å‡ºæ¥çš„ã€‚å¼€å‘å®Œæˆåï¼Œè¦å†å¹¶å…¥Developã€‚ åŠŸèƒ½åˆ†æ”¯çš„åå­—ï¼Œå¯ä»¥é‡‡ç”¨feature-*çš„å½¢å¼å‘½åã€‚ åˆ›å»ºä¸€ä¸ªåŠŸèƒ½åˆ†æ”¯ï¼š1git checkout -b feature-x develop å¼€å‘å®Œæˆåï¼Œå°†åŠŸèƒ½åˆ†æ”¯åˆå¹¶åˆ°developåˆ†æ”¯ï¼š123git checkout developgit merge --no-ff feature-x åˆ é™¤featureåˆ†æ”¯ï¼š1git branch -d feature-x é¢„å‘å¸ƒåˆ†æ”¯ æŒ‡å‘å¸ƒæ­£å¼ç‰ˆæœ¬ä¹‹å‰ï¼ˆå³åˆå¹¶åˆ°Masteråˆ†æ”¯ä¹‹å‰ï¼‰ï¼Œæˆ‘ä»¬å¯èƒ½éœ€è¦æœ‰ä¸€ä¸ªé¢„å‘å¸ƒçš„ç‰ˆæœ¬è¿›è¡Œæµ‹è¯•ã€‚ é¢„å‘å¸ƒåˆ†æ”¯æ˜¯ä»Developåˆ†æ”¯ä¸Šé¢åˆ†å‡ºæ¥çš„ï¼Œé¢„å‘å¸ƒç»“æŸä»¥åï¼Œå¿…é¡»åˆå¹¶è¿›Developå’ŒMasteråˆ†æ”¯ã€‚å®ƒçš„å‘½åï¼Œå¯ä»¥é‡‡ç”¨release-*çš„å½¢å¼ã€‚ åˆ›å»ºä¸€ä¸ªé¢„å‘å¸ƒåˆ†æ”¯ï¼š1git checkout -b release-1.2 develop ç¡®è®¤æ²¡æœ‰é—®é¢˜åï¼Œåˆå¹¶åˆ°masteråˆ†æ”¯ï¼š123456git checkout mastergit merge --no-ff release-1.2## å¯¹åˆå¹¶ç”Ÿæˆçš„æ–°èŠ‚ç‚¹ï¼Œåšä¸€ä¸ªæ ‡ç­¾git tag -a 1.2 å†åˆå¹¶åˆ°developåˆ†æ”¯ï¼š123git checkout developgit merge --no-ff release-1.2 æœ€åï¼Œåˆ é™¤é¢„å‘å¸ƒåˆ†æ”¯ï¼š1git branch -d release-1.2 ä¿®è¡¥bugåˆ†æ”¯ ä¿®è¡¥bugåˆ†æ”¯æ˜¯ä»Masteråˆ†æ”¯ä¸Šé¢åˆ†å‡ºæ¥çš„ã€‚ä¿®è¡¥ç»“æŸä»¥åï¼Œå†åˆå¹¶è¿›Masterå’ŒDevelopåˆ†æ”¯ã€‚å®ƒçš„å‘½åï¼Œå¯ä»¥é‡‡ç”¨fixbug-*çš„å½¢å¼ã€‚ åˆ›å»ºä¸€ä¸ªä¿®è¡¥bugåˆ†æ”¯ï¼š12git checkout -b fixbug-0.1 master## ä»¥masteråˆ†æ”¯ä¸ºåŸºç¡€ï¼Œåˆ›å»ºä¸€ä¸ªåˆ†æ”¯ ä¿®è¡¥ç»“æŸåï¼Œåˆå¹¶åˆ°masteråˆ†æ”¯ï¼š12345678git checkout master## åˆ‡æ¢åˆ°masteråˆ†æ”¯git merge --no-ff fixbug-0.1#åˆå¹¶åˆ†æ”¯git tag -a 0.1.1## æ‰“tag å†åˆå¹¶åˆ°developåˆ†æ”¯ï¼š123git checkout developgit merge --no-ff fixbug-0.1 æœ€åï¼Œåˆ é™¤â€ä¿®è¡¥bugåˆ†æ”¯â€ï¼š1git branch -d fixbug-0.1 ç‰ˆæœ¬å›é€€-æ’¤é”€æ–‡ä»¶ä¿®æ”¹ï¼ˆé’ˆå¯¹æ–‡ä»¶ä¿®æ”¹çš„æ¢å¤ï¼‰ å‚è€ƒ è‡ªå®šä¹‰ç»„ä»¶ä¹‹â€“è‡ªå®šä¹‰xmlå±æ€§step1. è‡ªå®šä¹‰å±æ€§åç§° åœ¨valuesä¸­åˆ›å»ºä¸€ä¸ªxmlæ–‡ä»¶ï¼Œå¹¶ä¸”åœ¨å…¶ä¸­å†™ä¸Šä½ éœ€è¦çš„è‡ªå®šä¹‰å±æ€§çš„åç§°ä»¥åŠç±»å‹ã€‚12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;MyTitle&quot;&gt; &lt;!--name æŒ‡å‘è‡ªå®šä¹‰ç»„ä»¶çš„ç±»å--&gt; &lt;attr name=&quot;textColor&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;titleText&quot; format=&quot;string&quot;/&gt; &lt;attr name=&quot;leftText&quot; format=&quot;string&quot;/&gt; &lt;attr name=&quot;rightText&quot; format=&quot;string&quot;/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; step2. å°†å±æ€§åç§°ä¸æ§ä»¶å…³è”1234567891011//ä»xmlçš„å±æ€§ä¸­è·å–åˆ°å­—ä½“é¢œè‰²ä¸stringTypedArray ta=context.obtainStyledAttributes(attrs,R.styleable.MyTitle);colorText=ta.getColor(R.styleable.MyTitle_textColor,Color.BLACK);textLeft=ta.getString(R.styleable.MyTitle_leftText);textTitle=ta.getString(R.styleable.MyTitle_titleText);textRight=ta.getString(R.styleable.MyTitle_rightText);ta.recycle();//public void recycle ()ï¼š//Give back a previously retrieved array, for later re-use.//å›æ”¶ TypedArray,ç”¨äºåç»­è°ƒç”¨æ—¶å¯å¤ç”¨ä¹‹ã€‚å½“è°ƒç”¨è¯¥æ–¹æ³•åï¼Œä¸èƒ½å†æ“ä½œè¯¥å˜é‡ã€‚//è¯¥ç±»æ²¡æœ‰å…¬å…±çš„æ„é€ å‡½æ•°ï¼Œåªæä¾›é™æ€æ–¹æ³•è·å–å®ä¾‹ï¼Œæ˜¾ç„¶æ˜¯ä¸€ä¸ªå…¸å‹çš„å•ä¾‹æ¨¡å¼ã€‚è¿™ä¸ª array æ˜¯ä»ä¸€ä¸ª array poolçš„æ± ä¸­è·å–çš„ã€‚ step3. ä»ç¬¬ä¸‰æ–¹å‘½åç©ºé—´è·å–åˆ°è‡ªå®šä¹‰å±æ€§åç§°1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:my_view=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;!--æ·»åŠ è¿™ä¸ª å‘½åç©ºé—´--&gt; &lt;com.example.double2.viewxmltest.MyView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@android:color/holo_blue_dark&quot; my_view:leftText=&quot;Back&quot; my_view:rightText=&quot;Go&quot; my_view:textColor=&quot;#fff&quot; my_view:titleText=&quot;MyViewTest&quot;/&gt; &lt;!--æ·»åŠ å±æ€§--&gt;&lt;/RelativeLayout&gt;","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8819%E6%97%A5/"},{"title":"å®ä¹ ç¬”è®°-8","text":"ç»„ä»¶mergeç±»å.()çš„å†™æ³•123456789inline fun AppCompatActivity.fragmentTransaction(block: FragmentTransaction.() -&gt; Unit): Boolean { kotlin.runCatching { val t = supportFragmentManager.beginTransaction() block.invoke(t) t.commitNowAllowingStateLoss() return true } return false} 1234/* æ–°çš„åç¨‹job */fun newWorkerThreadCoroutineJob(block: suspend CoroutineScope.() -&gt; Unit): Job { return GlobalScope.launch(context = Dispatchers.IO, block = block)} android-jobåº« åƒè€ƒ kotlinåŸºç¤kotlin æºç¨‹ é¡¶å±‚ä¸»åç¨‹? åç¨‹æ˜¯è½»é‡çº§çš„çº¿ç¨‹ delay æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„ æŒ‚èµ·å‡½æ•° ï¼Œå®ƒä¸ä¼šé€ æˆçº¿ç¨‹é˜»å¡ï¼Œä½†æ˜¯ä¼š æŒ‚èµ· åç¨‹ï¼Œå¹¶ä¸”åªèƒ½åœ¨åç¨‹ä¸­ä½¿ç”¨ã€‚12345678910import kotlinx.coroutines.*fun main() { GlobalScope.launch { // åœ¨åå°å¯åŠ¨ä¸€ä¸ªæ–°çš„åç¨‹å¹¶ç»§ç»­ delay(1000L) // éé˜»å¡çš„ç­‰å¾… 1 ç§’é’Ÿï¼ˆé»˜è®¤æ—¶é—´å•ä½æ˜¯æ¯«ç§’ï¼‰ println(&quot;World!&quot;) // åœ¨å»¶è¿Ÿåæ‰“å°è¾“å‡º } println(&quot;Hello,&quot;) // åç¨‹å·²åœ¨ç­‰å¾…æ—¶ä¸»çº¿ç¨‹è¿˜åœ¨ç»§ç»­ Thread.sleep(2000L) // é˜»å¡ä¸»çº¿ç¨‹ 2 ç§’é’Ÿæ¥ä¿è¯ JVM å­˜æ´»} delayæ˜¯éé˜»å¡çš„ï¼Œsleepæ˜¯é˜»å¡çš„ æŠ›æ£„sleepï¼Œä½¿ç”¨runBlockingèˆ‡delay123456789101112import kotlinx.coroutines.*fun main() { GlobalScope.launch { // åœ¨åå°å¯åŠ¨ä¸€ä¸ªæ–°çš„åç¨‹å¹¶ç»§ç»­ delay(1000L) println(&quot;World!&quot;) } println(&quot;Hello,&quot;) // ä¸»çº¿ç¨‹ä¸­çš„ä»£ç ä¼šç«‹å³æ‰§è¡Œ runBlocking { // ä½†æ˜¯è¿™ä¸ªè¡¨è¾¾å¼é˜»å¡äº†ä¸»çº¿ç¨‹ delay(2000L) // â€¦â€¦æˆ‘ä»¬å»¶è¿Ÿ 2 ç§’æ¥ä¿è¯ JVM çš„å­˜æ´» } } å­å”ç¨‹çš„joinæ–¹æ³•123456val job = GlobalScope.launch { // å¯åŠ¨ä¸€ä¸ªæ–°åç¨‹å¹¶ä¿æŒå¯¹è¿™ä¸ªä½œä¸šçš„å¼•ç”¨ delay(1000L) println(&quot;World!&quot;)}println(&quot;Hello,&quot;)job.join() // ç­‰å¾…ç›´åˆ°å­åç¨‹æ‰§è¡Œç»“æŸ suspendé—œéµå­—objecté—œéµå­—èƒ½è‡ªå‹•å¯¦ç¾å–®ä¾‹æ¨¡å¼çš„classï¼Œä¸èƒ½è¢«è³¦å€¼123object Test { val a = 0;} å°æ‡‰çš„å­—ç¯€ç¢¼ 1234567891011121314151617public final class Test { private static final int a; @NotNull public static final Test INSTANCE; public final int getA() { return a; } private Test() { } static { Test var0 = new Test(); INSTANCE = var0; }} ä¼´ç”Ÿå°è±¡ åœ¨ JVM å¹³å°ï¼Œå¦‚æœä½¿ç”¨ @JvmStatic æ³¨è§£ï¼Œä½ å¯ä»¥å°†ä¼´ç”Ÿå¯¹è±¡çš„æˆå‘˜ç”Ÿæˆä¸ºçœŸæ­£çš„é™æ€æ–¹æ³•å’Œå­—æ®µã€‚æ›´è¯¦ç»†ä¿¡æ¯è¯·å‚è§Java äº’æ“ä½œæ€§ä¸€èŠ‚ ã€‚ handlerè®“å­ç¶«ç¨‹çµæŸåçš„çµæœå‚³éçµ¦ä¸»ç¶«ç¨‹ï¼Œ çµ¦ä¸»ç¶«ç¨‹æ›´æ–°ç•Œé¢handlerç•°æ­¥é€šä¿¡ç³»çµ±ï¼šHandlerï¼Œmessageï¼ŒLooperï¼Œ MessageQueueLooper:ä¸»ç¶«ç¨‹ä¸æ–·å¾æ¶ˆæ¯éšŠåˆ—ä¸­æ‹¿æ¶ˆæ¯çš„æ±è¥¿å­ç¶«ç¨‹â€“æ‹¿åˆ°ä¸»ç¶«ç¨‹çš„handlerï¼ŒsendMessageâ€“&gt;ä¸»ç¶«ç¨‹çš„Handlerç³»çµ±â€“å¾æ¶ˆæ¯éšŠåˆ—ä¸­æ‹¿åˆ°æ¶ˆæ¯ï¼Œäº¤çµ¦ä¸»ç¶«ç¨‹ï¼ŒhandleMessageâ€“&gt;ä¸»ç¶«ç¨‹","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8822%E6%97%A5/"},{"title":"projects","text":"fedml: deployment and modification to combine with Hyperledger fabric repo fabric: deployment and combination with fedml repo Yaml-Requests: read your yaml config file to generate python function repo Algorithm: notes for leetcode and other oj repo","link":"/home/2022/10/22/projects/"},{"title":"å®ä¹ ç¬”è®°-9","text":"APPæ–°æ‰‹è’™å±‚å¼•å¯¼å®ç°æ–¹å¼1SmartGuideViewåº“ github é“¾æ¥ æ•™ç¨‹ TourGuideåº“ github ä½¿ç”¨Dialogè‡ªå®šä¹‰æ˜¾ç¤ºè½¯é”®ç›˜12345678910111213141516binding.etSearchSearchBar.postDelayed({ runOnUiThread { binding.etSearchSearchBar.apply { isFocusable = true isFocusableInTouchMode = true requestFocus() findFocus() } val inputManager = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager inputManager.showSoftInput( binding.etSearchSearchBar, InputMethodManager.SHOW_IMPLICIT ) }}, 300)","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8824%E6%97%A5/"},{"title":"å®ä¹ ç¬”è®°-10","text":"è¯»å–è½¯ä»¶ å£°æ˜æƒé™123456789&lt;uses-permission android:name=&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot; /&gt;&lt;!-- å¯¹äºå®‰å“11å¼€å§‹ --&gt;&lt;uses-permission android:name=&quot;android.permission.QUERY_ALL_PACKAGES&quot; tools:ignore=&quot;QueryAllPackagesPermission&quot; /&gt;&lt;queries&gt; &lt;intent&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;/intent&gt;&lt;/queries&gt; 12345val pm = context.applicationContext.packageManagerval installedApplications = pm.getInstalledApplications(0)installedApplications.forEach {info -&gt; //handle info} è¯¥æ“ä½œæ¯”è¾ƒè€—æ—¶,åœ¨æ–°çº¿ç¨‹æˆ–åç¨‹jobä¸­æ‰§è¡Œ è·å–åº”ç”¨Label(åº”ç”¨å) , åº”ç”¨å›¾æ ‡å’Œåº”ç”¨å®‰è£…æ—¶é—´123info.loadIcon(pm)pm.getApplicationLabel(info)pm.getPackageInfo(name, 0).firstInstallTime å¸è½½è½¯ä»¶ å‘é€intent 1234val intent = Intent(Intent.ACTION_DELETE)intent.data = Uri.parse(&quot;package:$packageName&quot;)intent.putExtra(Intent.EXTRA_RETURN_RESULT, true)mStartActivity.launch(intent) æ³¨å†ŒStartActivityForResult 123456private val mStartActivity = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { val adapter = binding.rvSearchResult.adapter as AppsAdapter adapter.deletionResult(it != null &amp;&amp; it.resultCode == Activity.RESULT_OK) } ActivityResultContract12345678910111213//ç¬¬ä¸€æ­¥ï¼Œæ³¨å†Œäº¤äº’æ•°æ®å›è°ƒç›‘å¬val contact = registerForActivityResult(ActivityResultContracts.PickContact()) { uri : Uri? -&gt; //å¦‚æœUriä¸ºnullï¼Œè¯´æ˜ç”¨æˆ·æ²¡æœ‰æ“ä½œç›´æ¥è¿”å›ï¼Œè¿™é‡Œä»£ç ä¼šåœ¨ä¸‹é¢è¡¥è´´å‡ºæ¥ï¼Œå› ä¸ºæ¶‰åŠè·¨è¿›ç¨‹äº¤äº’ï¼Œä»£ç æ¯”è¾ƒé•¿ï¼Œä¸æƒ³è´´è¿™é‡Œå½±å“é˜…è¯»æ•ˆç‡ â€¦â€¦}//ç¬¬äºŒæ­¥ï¼Œintentï¼Œå’ŒåŸæ¥ä¸€æ ·xxx.setOnClickListener { val intent = Intent(Intent.ACTION_PICK) intent.addCategory(Intent.CATEGORY_DEFAULT) intent.setType(&quot;vnd.android.cursor.dir/phone_v2&quot;) contact.launch(intent)}","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8825%E6%97%A5/"},{"title":"å®ä¹ ç¬”è®°-11","text":"Intent Actionç›¸å…³chooserå¯è‡ªå®šä¹‰æ ‡é¢˜ï¼Œå¼¹å‡ºè½¯ä»¶é€‰æ‹©å™¨ 123456789Intent intent = new Intent();intent.setAction(Intent.ACTION_SEND);intent.setType(&quot;text/plain&quot;);Intent intent2 = new Intent();intent2.setAction(Intent.ACTION_CHOOSER);intent2.putExtra(Intent.EXTRA_TITLE, &quot;please selete a app&quot;);//extra intentintent2.putExtra(Intent.EXTRA_INTENT, intent);startActivity(intent2); æ–¹ä¾¿èµ·è§ï¼Œå¯ä»¥ä½¿ç”¨ 1Intent.createChooser(Intent,CharSequence) ACTION_CONFIGURATION_CHANGEDè®¾å¤‡çš„è®¾ç½®æ”¹å˜ï¼Œorientationï¼Œlocaleç­‰ Configuration1Configuration config = getResources().getConfiguration(); requestedOrientationæ›´æ”¹æ­¤Activityçš„æ‰€éœ€æ–¹å‘ã€‚å¦‚æœ Activity å½“å‰å¤„äºå‰å°æˆ–ä»¥å…¶ä»–æ–¹å¼å½±å“å±å¹•æ–¹å‘ï¼Œåˆ™å±å¹•å°†ç«‹å³æ›´æ”¹ï¼ˆå¯èƒ½å¯¼è‡´ Activity é‡æ–°å¯åŠ¨ï¼‰ã€‚å¦åˆ™ï¼Œè¿™å°†åœ¨ä¸‹æ¬¡Activityå¯è§æ—¶ä½¿ç”¨ã€‚ 12345678landscapeï¼šé™åˆ¶ç•Œé¢ä¸ºæ¨ªå±ï¼Œæ—‹è½¬å±å¹•ä¹Ÿä¸ä¼šæ”¹å˜å½“å‰çŠ¶æ€ã€‚portraitï¼šé™åˆ¶ç•Œé¢ä¸ºç«–å±ï¼Œæ—‹è½¬å±å¹•ä¹Ÿä¸ä¼šæ”¹å˜å½“å‰çŠ¶æ€ã€‚sensor:æ ¹æ®ä¼ æ„Ÿå™¨å®šä½æ–¹å‘ï¼Œæ—‹è½¬æ‰‹æœº90åº¦ï¼Œ180,270,360ï¼Œç•Œé¢éƒ½ä¼šå‘ç”Ÿå˜åŒ–ã€‚sensorLandscapeï¼šï¼ˆæ¨ªå±çš„æ—‹è½¬ï¼Œä¸ä¼šå‡ºç°ç«–å±çš„ç°è±¡ï¼‰æ ¹æ®ä¼ æ„Ÿå™¨å®šä½æ–¹å‘ï¼Œæ—‹è½¬æ‰‹æœº180åº¦ç•Œé¢æ—‹è½¬ã€‚ä¸€èˆ¬æ¨ªå±æ¸¸æˆä¼šæ˜¯è¿™ä¸ªå±æ€§ã€‚sensorPortraitï¼šï¼ˆç«–å±çš„æ—‹è½¬ï¼Œä¸ä¼šå‡ºç°æ¨ªå±çš„ç°è±¡ï¼‰æ ¹æ®ä¼ æ„Ÿå™¨å®šä½æ–¹å‘ï¼Œæ—‹è½¬æ‰‹æœº180åº¦ç•Œé¢ä¼šæ—‹è½¬ã€‚unspecifiedï¼šç”±ç³»ç»Ÿé€‰æ‹©æ˜¾ç¤ºæ–¹å‘ï¼Œä¸åŒçš„è®¾å¤‡å¯èƒ½ä¼šæœ‰æ‰€ä¸åŒã€‚ï¼ˆæ—‹è½¬æ‰‹æœºï¼Œç•Œé¢ä¼šè·Ÿç€æ—‹è½¬ï¼‰user:ç”¨æˆ·å½“å‰çš„é¦–é€‰æ–¹å‘ã€‚nosensorï¼šä¸ç”±ä¼ æ„Ÿå™¨ç¡®å®šæ–¹å‘ã€‚æ—‹è½¬è®¾å¤‡çš„æ—¶å€™ï¼Œç•Œé¢ä¸ä¼šè·Ÿç€æ—‹è½¬ã€‚åˆå§‹ç•Œé¢æ–¹å‘ç”±ç³»ç»Ÿæä¾›ã€‚ SystemClock12345678910111ã€public static long currentThreadTimeMillis () è¿”åœ¨å½“å‰çº¿ç¨‹è¿è¡Œçš„æ¯«ç§’æ•°ã€‚2ã€public static long elapsedRealtime () è¿”å›ç³»ç»Ÿå¯åŠ¨åˆ°ç°åœ¨çš„æ¯«ç§’æ•°ï¼ŒåŒ…å«ä¼‘çœ æ—¶é—´ã€‚3ã€public static long elapsedRealtimeNanos () è¿”å›ç³»ç»Ÿå¯åŠ¨åˆ°ç°åœ¨çš„çº³ç§’æ•°ï¼ŒåŒ…å«ä¼‘çœ æ—¶é—´ã€‚4ã€public static boolean setCurrentTimeMillis (long millis) è®¾ç½®å½“å‰çš„&quot;å¢™&quot;æ—¶é—´ï¼Œè¦æ±‚è°ƒç”¨è¿›ç¨‹æœ‰è®¸å¯æƒé™ã€‚è¿”å›æ˜¯å¦æˆåŠŸã€‚5ã€public static void sleep (long ms) ç­‰å¾…ç»™å®šçš„æ—¶é—´ã€‚å’ŒThread.sleep(millis)ç±»ä¼¼ï¼Œä½†æ˜¯å®ƒä¸ä¼šæŠ›å‡ºInterruptedExceptionå¼‚å¸¸ã€‚äº‹ä»¶è¢«æ¨è¿Ÿåˆ°ä¸‹ä¸€ä¸ªä¸­æ–­æ“ä½œã€‚è¯¥æ–¹æ³•ç›´åˆ°æŒ‡å®šçš„æ—¶é—´è¿‡å»æ‰è¿”å›ã€‚6ã€public static long uptimeMillis () è¿”å›ç³»ç»Ÿå¯åŠ¨åˆ°ç°åœ¨çš„æ¯«ç§’æ•°ï¼Œä¸åŒ…å«ä¼‘çœ æ—¶é—´ã€‚å°±æ˜¯è¯´ç»Ÿè®¡ç³»ç»Ÿå¯åŠ¨åˆ°ç°åœ¨çš„éä¼‘çœ æœŸæ—¶é—´ã€‚ Java çš„å¼ºå¼•ç”¨ã€å¼±å¼•ç”¨ã€è½¯å¼•ç”¨ã€è™šå¼•ç”¨ 1ã€å¼ºå¼•ç”¨ï¼ˆStrongReferenceï¼‰ å¼ºå¼•ç”¨æ˜¯ä½¿ç”¨æœ€æ™®éçš„å¼•ç”¨ã€‚å¦‚æœä¸€ä¸ªå¯¹è±¡å…·æœ‰å¼ºå¼•ç”¨ï¼Œé‚£åƒåœ¾å›æ”¶å™¨ç»ä¸ä¼šå›æ”¶å®ƒã€‚ å½“å†…å­˜ç©ºé—´ä¸è¶³ï¼ŒJavaè™šæ‹Ÿæœºå®æ„¿æŠ›å‡ºOutOfMemoryErroré”™è¯¯ï¼Œä½¿ç¨‹åºå¼‚å¸¸ç»ˆæ­¢ï¼Œä¹Ÿä¸ä¼šé éšæ„å›æ”¶å…·æœ‰å¼ºå¼•ç”¨çš„å¯¹è±¡æ¥è§£å†³å†…å­˜ä¸è¶³çš„é—®é¢˜ã€‚ 2ã€è½¯å¼•ç”¨ï¼ˆSoftReferenceï¼‰ å¦‚æœä¸€ä¸ªå¯¹è±¡åªå…·æœ‰è½¯å¼•ç”¨ï¼Œåˆ™å†…å­˜ç©ºé—´è¶³å¤Ÿï¼Œåƒåœ¾å›æ”¶å™¨å°±ä¸ä¼šå›æ”¶å®ƒï¼›å¦‚æœå†…å­˜ç©ºé—´ä¸è¶³äº†ï¼Œå°±ä¼šå›æ”¶è¿™äº›å¯¹è±¡çš„å†…å­˜ã€‚åªè¦åƒåœ¾å›æ”¶å™¨æ²¡æœ‰å›æ”¶å®ƒï¼Œè¯¥å¯¹è±¡å°±å¯ä»¥è¢«ç¨‹åºä½¿ç”¨ã€‚è½¯å¼•ç”¨å¯ç”¨æ¥å®ç°å†…å­˜æ•æ„Ÿçš„é«˜é€Ÿç¼“å­˜ã€‚ å†…å­˜ä¸è¶³æ—¶æ‰å›æ”¶ 3ã€å¼±å¼•ç”¨ï¼ˆWeakReferenceï¼‰ å¼±å¼•ç”¨ä¸è½¯å¼•ç”¨çš„åŒºåˆ«åœ¨äºï¼šåªå…·æœ‰å¼±å¼•ç”¨çš„å¯¹è±¡æ‹¥æœ‰æ›´çŸ­æš‚çš„ç”Ÿå‘½å‘¨æœŸã€‚åœ¨åƒåœ¾å›æ”¶å™¨çº¿ç¨‹æ‰«æå®ƒæ‰€ç®¡è¾–çš„å†…å­˜åŒºåŸŸçš„è¿‡ç¨‹ä¸­ï¼Œä¸€æ—¦å‘ç°äº†åªå…·æœ‰å¼±å¼•ç”¨çš„å¯¹è±¡ï¼Œä¸ç®¡å½“å‰å†…å­˜ç©ºé—´è¶³å¤Ÿä¸å¦ï¼Œéƒ½ä¼šå›æ”¶å®ƒçš„å†…å­˜ã€‚ä¸è¿‡ï¼Œç”±äºåƒåœ¾å›æ”¶å™¨æ˜¯ä¸€ä¸ªä¼˜å…ˆçº§å¾ˆä½çš„çº¿ç¨‹ï¼Œå› æ­¤ä¸ä¸€å®šä¼šå¾ˆå¿«å‘ç°é‚£äº›åªå…·æœ‰å¼±å¼•ç”¨çš„å¯¹è±¡ã€‚ åªè¦è¢«gcæ‰«æåˆ°ï¼Œæ— è®ºæ˜¯å¦ç¼ºå†…å­˜éƒ½å›æ”¶ 4ã€è™šå¼•ç”¨ï¼ˆPhantomReferenceï¼‰ â€œè™šå¼•ç”¨â€é¡¾åæ€ä¹‰ï¼Œå°±æ˜¯å½¢åŒè™šè®¾ï¼Œä¸å…¶ä»–å‡ ç§å¼•ç”¨éƒ½ä¸åŒï¼Œè™šå¼•ç”¨å¹¶ä¸ä¼šå†³å®šå¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸã€‚å¦‚æœä¸€ä¸ªå¯¹è±¡ä»…æŒæœ‰è™šå¼•ç”¨ï¼Œé‚£ä¹ˆå®ƒå°±å’Œæ²¡æœ‰ä»»ä½•å¼•ç”¨ä¸€æ ·ï¼Œåœ¨ä»»ä½•æ—¶å€™éƒ½å¯èƒ½è¢«åƒåœ¾å›æ”¶å™¨å›æ”¶ã€‚ è™šå¼•ç”¨ä¸»è¦ç”¨æ¥è·Ÿè¸ªå¯¹è±¡è¢«åƒåœ¾å›æ”¶å™¨å›æ”¶çš„æ´»åŠ¨ã€‚è™šå¼•ç”¨ä¸è½¯å¼•ç”¨å’Œå¼±å¼•ç”¨çš„ä¸€ä¸ªåŒºåˆ«åœ¨äºï¼šè™šå¼•ç”¨å¿…é¡»å’Œå¼•ç”¨é˜Ÿåˆ— ï¼ˆReferenceQueueï¼‰è”åˆä½¿ç”¨ã€‚å½“åƒåœ¾å›æ”¶å™¨å‡†å¤‡å›æ”¶ä¸€ä¸ªå¯¹è±¡æ—¶ï¼Œå¦‚æœå‘ç°å®ƒè¿˜æœ‰è™šå¼•ç”¨ï¼Œå°±ä¼šåœ¨å›æ”¶å¯¹è±¡çš„å†…å­˜ä¹‹å‰ï¼ŒæŠŠè¿™ä¸ªè™šå¼•ç”¨åŠ å…¥åˆ°ä¸ä¹‹ å…³è”çš„å¼•ç”¨é˜Ÿåˆ—ä¸­ã€‚","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8826%E6%97%A5/"},{"title":"å®ä¹ ç¬”è®°-12","text":"PendingIntentè®¤è¯† PendIntentå…¶å®æ˜¯Intentçš„å°è£… ä¸æ˜¯ç«‹åˆ»æ‰§è¡ŒæŸä¸ªè¡Œä¸ºï¼Œè€Œæ˜¯æ»¡è¶³æŸäº›æ¡ä»¶æˆ–è§¦å‘æŸäº›äº‹ä»¶åæ‰æ‰§è¡ŒæŒ‡å®šçš„è¡Œä¸º æˆ‘ä»¬çš„ Activity å¦‚æœè®¾ç½®äº† exported = falseï¼Œå…¶ä»–åº”ç”¨å¦‚æœä½¿ç”¨ Intent å°±è®¿é—®ä¸åˆ°è¿™ä¸ª Activityï¼Œä½†æ˜¯ä½¿ç”¨ PendingIntent æ˜¯å¯ä»¥çš„ã€‚ å³ï¼šPendingIntentå°†æŸä¸ªåŠ¨ä½œçš„è§¦å‘æ—¶æœºäº¤ç»™å…¶ä»–åº”ç”¨ï¼›è®©é‚£ä¸ªåº”ç”¨ä»£è¡¨è‡ªå·±å»æ‰§è¡Œé‚£ä¸ªåŠ¨ä½œï¼ˆæƒé™éƒ½ç»™ä»–ï¼‰ è·å–PendingIntent12345getActivity()getActivities()getBroadcast()getService()getForegroundService() 12345å‚æ•°:Context - ä¸Šä¸‹æ–‡å¯¹è±¡requestCode - è¯·æ±‚ç Intent - è¯·æ±‚æ„å›¾ç”¨ä»¥æŒ‡æ˜å¯åŠ¨ç±»åŠæ•°æ®ä¼ é€’flags -å…³é”®æ ‡å¿—ä½ flags FLAG_CANCEL_CURRENT å…ˆå°†å½“å‰å·²æœ‰çš„PendingIntentå–æ¶ˆï¼Œç„¶åé‡æ–°ç”Ÿæˆä¸€ä¸ªPendingIntentå¯¹è±¡ã€‚ FLAG_NO_CREATE å¦‚æœå½“å‰ç³»ç»Ÿä¸­ä¸å­˜åœ¨ç›¸åŒçš„PendingIntentå¯¹è±¡ï¼Œç³»ç»Ÿå°†è¿”å›nullï¼Œå¦åˆ™è¿”å›å·²æœ‰å¯¹è±¡ FLAG_ONE_SHOT è¯¥PendingIntentåªä½œç”¨ä¸€æ¬¡ã€‚åœ¨è¯¥PendingIntentå¯¹è±¡é€šè¿‡send()æ–¹æ³•è§¦å‘è¿‡åï¼ŒPendingIntentå°†è‡ªåŠ¨è°ƒç”¨cancel()è¿›è¡Œé”€æ¯ï¼Œé‚£ä¹ˆå¦‚æœä½ å†è°ƒç”¨send()æ–¹æ³•çš„è¯ï¼Œç³»ç»Ÿå°†ä¼šè¿”å›ä¸€ä¸ªSendIntentExceptionã€‚ FLAG_UPDATE_CURRENT æ›´æ–°ä¹‹å‰PendingIntentä¸­çš„Intentå¯¹è±¡æ•°æ®ï¼Œä¾‹å¦‚æ›´æ–°Intentä¸­çš„Extras FLAG_IMMUTABLE åˆ›å»ºçš„PendingIntentæ˜¯ä¸å¯å˜çš„ï¼Œä½¿ç”¨sendæ–¹æ³•å‘é€çš„é™„åŠ Intentä¼šè¢«å¿½ç•¥ åŸç† Aåº”ç”¨å¸Œæœ›è®©Båº”ç”¨å¸®å¿™è§¦å‘ä¸€ä¸ªè¡Œä¸ºï¼Œè¿™æ˜¯è·¨åº”ç”¨çš„é€šä¿¡ éœ€è¦ Android ç³»ç»Ÿä½œä¸ºä¸­é—´äººï¼Œè¿™é‡Œçš„ä¸­é—´äººå°±æ˜¯ ActivityManagerã€‚ Aåº”ç”¨åˆ›å»ºå»º PendingIntentï¼Œåœ¨åˆ›å»º PendingIntent çš„è¿‡ç¨‹ä¸­ï¼Œå‘ ActivityManager æ³¨å†Œäº†è¿™ä¸ª PendingIntentï¼Œæ‰€ä»¥ï¼Œå³ä½¿Aåº”ç”¨æ­»äº†ï¼Œå½“å®ƒå†æ¬¡è‹é†’æ—¶ï¼Œåªè¦æä¾›ç›¸åŒçš„å‚æ•°ï¼Œè¿˜æ˜¯å¯ä»¥è·å–åˆ°ä¹‹å‰é‚£ä¸ª PendingIntent çš„ã€‚ å½“ A å°† PendingIntent è°ƒç”¨ç³»ç»Ÿ API æ¯”å¦‚ AlarmManager.set()ï¼Œå®é™…æ˜¯å°†æƒé™ç»™äº†Båº”ç”¨ï¼Œè¿™æ—¶å€™ï¼Œ Båº”ç”¨å¯ä»¥æ ¹æ®å‚æ•°ä¿¡æ¯ï¼Œæ¥ä» ActivityManager è·å–åˆ° A è®¾ç½®çš„ PendingIntent Canvas ç›¸å½“äºä¸€ä¸ªé€æ˜å›¾å±‚ æ¯æ¬¡è°ƒç”¨canvas.drawXXXXç³»åˆ—å‡½æ•°æ¥ç»˜å›¾ï¼Œéƒ½ä¼šäº§ç”Ÿä¸€ä¸ªå…¨æ–°çš„Canvasç”»å¸ƒã€‚ å¦‚æœåœ¨DrawXXXå‰ï¼Œè°ƒç”¨å¹³ç§»ã€æ—‹è½¬ç­‰å‡½æ•°æ¥å¯¹Canvasè¿›è¡Œäº†æ“ä½œï¼Œé‚£ä¹ˆè¿™ä¸ªæ“ä½œæ˜¯ä¸å¯é€†çš„ï¼æ¯æ¬¡äº§ç”Ÿçš„ç”»å¸ƒæœ€æ–°ä½ç½®éƒ½æ˜¯è¿™äº›æ“ä½œåçš„ä½ç½®ã€‚ åœ¨Canvasä¸å±å¹•åˆæˆæ—¶ï¼Œè¶…å‡ºå±å¹•èŒƒå›´çš„å›¾åƒæ˜¯ä¸ä¼šæ˜¾ç¤ºå‡ºæ¥çš„ã€‚ rotateå‡½æ•° 12345678910public class MyTextView extends TextView { public MyTextView(Context context, AttributeSet attrs) { super(context, attrs); } @Override protected void onDraw(Canvas canvas) { canvas.rotate(-90); super.onDraw(canvas); } } translateå‡½æ•°123void translate(float dx, float dy)// float dxï¼šæ°´å¹³æ–¹å‘å¹³ç§»çš„è·ç¦»ï¼Œæ­£æ•°æŒ‡å‘æ­£æ–¹å‘ï¼ˆå‘å³ï¼‰å¹³ç§»çš„é‡ï¼Œè´Ÿæ•°ä¸ºå‘è´Ÿæ–¹å‘ï¼ˆå‘å·¦ï¼‰å¹³ç§»çš„é‡// float dy: å‚ç›´æ–¹å‘å¹³ç§»çš„è·ç¦»ï¼Œæ­£æ•°æŒ‡å‘æ­£æ–¹å‘ (å‘ä¸‹) å¹³ç§»é‡ï¼Œè´Ÿæ•°ä¸ºå‘è´Ÿæ–¹å‘ (å‘ä¸Š) å¹³ç§»é‡ æ‰­æ›²ï¼ˆskewï¼‰å…¶å®æˆ‘è§‰å¾—è¯‘æˆæ–œåˆ‡æ›´åˆé€‚ï¼Œåœ¨PSä¸­çš„è¿™ä¸ªåŠŸèƒ½å°±å·®ä¸å¤šå«æ–œåˆ‡ã€‚ä½†è¿™é‡Œè¿˜æ˜¯ç›´è¯‘å§ï¼Œå¤§å®¶éƒ½æ˜¯è¿™ä¸ªåå­—ã€‚çœ‹ä¸‹å®ƒçš„æ„é€ å‡½æ•°ï¼š 123void skew (float sx, float sy)//float sx:å°†ç”»å¸ƒåœ¨xæ–¹å‘ä¸Šå€¾æ–œç›¸åº”çš„è§’åº¦ï¼Œsxå€¾æ–œè§’åº¦çš„tanå€¼//float sy:å°†ç”»å¸ƒåœ¨yè½´æ–¹å‘ä¸Šå€¾æ–œç›¸åº”çš„è§’åº¦ï¼Œsyä¸ºå€¾æ–œè§’åº¦çš„tanå€¼ save restoreæ¯æ¬¡saveï¼Œå°†å½“å‰ç”»å¸ƒçŠ¶æ€ä¿å­˜åˆ°ä¸€ä¸ªçŠ¶æ€æ ˆä¸­ï¼Œrestoreä»æ ˆé¡¶å–å‡ºä¸€ä¸ªçŠ¶æ€æ¢å¤åˆ°ç”»å¸ƒä¸Š SDCard123456Environment.MEDIA_UNMOUNTED // ç”¨æˆ·æ‰‹å·¥åˆ°æ‰‹æœºè®¾ç½®ä¸­å¸è½½sdå¡ä¹‹åçš„çŠ¶æ€ Environment.MEDIA_REMOVED // ç”¨æˆ·æ‰‹åŠ¨å¸è½½ï¼Œç„¶åå°†sdå¡ä»æ‰‹æœºå–å‡ºä¹‹åçš„çŠ¶æ€ Environment.MEDIA_BAD_REMOVAL // ç”¨æˆ·æœªåˆ°æ‰‹æœºè®¾ç½®ä¸­æ‰‹åŠ¨å¸è½½sdå¡ï¼Œç›´æ¥æ‹¨å‡ºä¹‹åçš„çŠ¶æ€ Environment.MEDIA_SHARED // æ‰‹æœºç›´æ¥è¿æ¥åˆ°ç”µè„‘ä½œä¸ºuç›˜ä½¿ç”¨ä¹‹åçš„çŠ¶æ€ Environment.MEDIA_CHECKINGS // æ‰‹æœºæ­£åœ¨æ‰«æsdå¡è¿‡ç¨‹ä¸­çš„çŠ¶æ€ Environment.MEDIA_MOUNTED //æŒ‚è½½åˆ°æŒ‚è½½ç‚¹ä¸Šä¸”æœ‰è¯»å†™æƒé™","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8827%E6%97%A5/"},{"title":"å®ä¹ ç¬”è®°-18","text":"åè°ƒé—®é¢˜ éœ€è¦SceneEventçš„Observerï¼ˆâˆšï¼‰ è·³è½¬é—®é¢˜ï¼ˆâˆšï¼‰ï¼š batteryé”™è¯¯è·³è½¬åˆ°boostï¼Œboosté”™è¯¯è·³è½¬åˆ°boost MainPageActivityåœ¨ä»»åŠ¡æ ˆä¸­æ—¶ï¼Œç‚¹å‡»é€šçŸ¥æŒ‰é’®ä¸è·³è½¬åˆ°åŠŸèƒ½é¡µé¢ï¼Œæ²¡æœ‰å¤„ç†onNewIntent åœ¨ä»€ä¹ˆä½ç½®startServiceï¼ˆâˆšï¼‰ startActivityçš„è¿‡ç¨‹ å¦‚æœintentæŒ‡æ˜äº†Componentï¼Œç›´æ¥é€šè¿‡componentæ‰¾åˆ°ActivityInfoï¼Œå¦åˆ™ å¦‚æœIntentæŒ‡å®šäº†ç»„ä»¶æ‰€åœ¨åŒ…åï¼Œé€šè¿‡åŒ…åè·å–ActivityInfoï¼Œå¦åˆ™ é€šè¿‡ActivityIntentResolverç­‰ç±»çš„queryIntentForPackageè¿›è¡Œæ¨¡ç³ŠåŒ¹é…ï¼Œå¦‚Actionï¼ŒCategory","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%8814%E6%97%A5/"},{"title":"å®ä¹ ç¬”è®°-19","text":"SlidingPaneLayoutwindowSizeClass â€“ å±å¹•å¸ƒå±€å†³ç­–ActivityEmbeddingNavigationRailBox With Constraints â€“ ä¸åŒå±•ç¤ºå†…å®¹å†³ç­–Custom Layout â€“ ä¸åŒæ–¹å¼å¸ƒå±€Scaffold","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%8815%E6%97%A5/"},{"title":"å®ä¹ ç¬”è®°-21","text":"åç¨‹å–æ¶ˆé—®é¢˜å¯ä»¥è‡ªåŠ¨å–æ¶ˆçš„lifecycleScope","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%8817%E6%97%A5/"},{"title":"å®ä¹ ç¬”è®°-17","text":"åè°ƒé—®é¢˜ outsideLauncher å®‰å“ä¸­çš„å•ä¾‹æ¨¡å¼ LayoutInflatorä¹Ÿæ˜¯ä¸€ä¸ªSystemService SYSTEM_SERVICE_FETCHERSæ˜¯ä¸€ä¸ªhashMapï¼Œä¿å­˜ServiceName-&gt;ServiceFetcherçš„å•ä¾‹ ServiceFetctoræ˜¯ä¸€ä¸ªæ¥å£ï¼Œå®šä¹‰äº† T getService(ContextImpl ctx); å®‰å“ä¸­çš„Builderæ¨¡å¼ éš”ç¦»getterï¼Œsetterï¼Œåœ¨å¯¹è±¡ç”Ÿæˆæ—¶å¯¹æˆå‘˜å˜é‡é…ç½®ï¼Œç”Ÿæˆåå±è”½ dialog","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%8811%E6%97%A5/"},{"title":"å®ä¹ ç¬”è®°-20","text":"AppçœŸæ­£çš„å…¥å£ActivityThread ä¸­çš„mainæ–¹æ³•ï¼Œä¸€ä¸ªåº”ç”¨ç¨‹åºå¯¹åº”ä¸€ä¸ªActivityThreadå¯¹è±¡ï¼ŒZygoteå­µåŒ–å‡ºä¸€ä¸ªè¿›ç¨‹åï¼Œå°±ä¼šæ‰§è¡Œmainæ–¹æ³• å‡†å¤‡Looperå’Œæ¶ˆæ¯é˜Ÿåˆ— thread.attach()æ–¹æ³•ç»‘å®šåˆ°ActivityManagerServiceä¸­ attachæ–¹æ³•1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283private void attach(boolean system, long startSeq) { sCurrentActivityThread = this; mConfigurationController = new ConfigurationController(this); mSystemThread = system; if (!system) { android.ddm.DdmHandleAppName.setAppName(&quot;&lt;pre-initialized&gt;&quot;, UserHandle.myUserId()); RuntimeInit.setApplicationObject(mAppThread.asBinder()); final IActivityManager mgr = ActivityManager.getService(); try { mgr.attachApplication(mAppThread, startSeq); // } catch (RemoteException ex) { throw ex.rethrowFromSystemServer(); } // Watch for getting close to heap limit. BinderInternal.addGcWatcher(new Runnable() { @Override public void run() { if (!mSomeActivitiesChanged) { return; } Runtime runtime = Runtime.getRuntime(); long dalvikMax = runtime.maxMemory(); long dalvikUsed = runtime.totalMemory() - runtime.freeMemory(); if (dalvikUsed &gt; ((3*dalvikMax)/4)) { if (DEBUG_MEMORY_TRIM) Slog.d(TAG, &quot;Dalvik max=&quot; + (dalvikMax/1024) + &quot; total=&quot; + (runtime.totalMemory()/1024) + &quot; used=&quot; + (dalvikUsed/1024)); mSomeActivitiesChanged = false; try { ActivityTaskManager.getService().releaseSomeActivities(mAppThread); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } } }); } else { // Don't set application object here -- if the system crashes, // we can't display an alert, we just want to die die die. android.ddm.DdmHandleAppName.setAppName(&quot;system_process&quot;, UserHandle.myUserId()); try { mInstrumentation = new Instrumentation(); mInstrumentation.basicInit(this); ContextImpl context = ContextImpl.createAppContext( this, getSystemContext().mPackageInfo); mInitialApplication = context.mPackageInfo.makeApplication(true, null); mInitialApplication.onCreate(); } catch (Exception e) { throw new RuntimeException( &quot;Unable to instantiate Application():&quot; + e.toString(), e); } } ViewRootImpl.ConfigChangedCallback configChangedCallback = (Configuration globalConfig) -&gt; { synchronized (mResourcesManager) { // TODO (b/135719017): Temporary log for debugging IME service. if (Build.IS_DEBUGGABLE &amp;&amp; mHasImeComponent) { Log.d(TAG, &quot;ViewRootImpl.ConfigChangedCallback for IME, &quot; + &quot;config=&quot; + globalConfig); } // We need to apply this change to the resources immediately, because upon returning // the view hierarchy will be informed about it. if (mResourcesManager.applyConfigurationToResources(globalConfig, null /* compat */, mInitialApplication.getResources().getDisplayAdjustments())) { mConfigurationController.updateLocaleListFromAppContext( mInitialApplication.getApplicationContext()); // This actually changed the resources! Tell everyone about it. final Configuration updatedConfig = mConfigurationController.updatePendingConfiguration(globalConfig); if (updatedConfig != null) { sendMessage(H.CONFIGURATION_CHANGED, globalConfig); mPendingConfiguration = updatedConfig; } } } }; ViewRootImpl.addConfigCallback(configChangedCallback);}","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%8816%E6%97%A5/"},{"title":"å®ä¹ ç¬”è®°-22","text":"LiveData, MutableLiveDataé˜²æ­¢æš´éœ²å­ç±»æŸäº›æ–¹æ³•12val name: LiveData&lt;NameBean&gt; get() = _nameprivate val _name = MutableLiveData&lt;NameBean&gt;() ç•Œé¢æ€§èƒ½ä¼˜åŒ–ViewStubæ ¹æ®æ¡ä»¶åˆ¤æ–­æŸäº›æ§ä»¶æ˜¾ç¤ºï¼ŒæŸäº›ä¸æ˜¾ç¤ºæ—¶ï¼Œå¯ä»¥ä½¿ç”¨ViewStubæ¥å‡å°‘ä¸å¿…è¦çš„å®ä¾‹åŒ–å¼€é”€ã€‚ android.view.ViewStubï¼ŒViewStub æ˜¯ä¸€ä¸ªè½»é‡çº§çš„Viewï¼Œå®ƒä¸€ä¸ªçœ‹ä¸è§çš„ï¼Œä¸å å¸ƒå±€ä½ç½®ï¼Œå ç”¨èµ„æºéå¸¸å°çš„æ§ä»¶ã€‚å¯ä»¥ä¸ºViewStubæŒ‡å®šä¸€ä¸ªå¸ƒå±€ï¼Œåœ¨Inflateå¸ƒå±€çš„æ—¶å€™ï¼Œåªæœ‰ ViewStubä¼šè¢«åˆå§‹åŒ–ï¼Œç„¶åå½“ViewStubè¢«è®¾ç½®ä¸ºå¯è§çš„æ—¶å€™ï¼Œæˆ–æ˜¯è°ƒç”¨äº†ViewStub.inflate()çš„æ—¶å€™ã€‚ ViewStubçš„å±€é™æ€§ ViewStubåªèƒ½Inflateä¸€æ¬¡ï¼Œä¹‹åViewStubå¯¹è±¡ä¼šè¢«ç½®ä¸ºç©ºã€‚æŒ‰å¥è¯è¯´ï¼ŒæŸä¸ªè¢«ViewStubæŒ‡å®šçš„å¸ƒå±€è¢«Inflateåï¼Œå°±ä¸ä¼šå¤Ÿå†é€šè¿‡ViewStubæ¥æ§åˆ¶å®ƒäº†ã€‚ ViewStubåªèƒ½ç”¨æ¥Inflateä¸€ä¸ªå¸ƒå±€æ–‡ä»¶ï¼Œè€Œä¸æ˜¯æŸä¸ªå…·ä½“çš„Viewï¼Œå½“ç„¶ä¹Ÿå¯ä»¥æŠŠViewå†™åœ¨æŸä¸ªå¸ƒå±€æ–‡ä»¶ä¸­ã€‚ åŸºäºä»¥ä¸Šçš„ç‰¹ç‚¹ï¼Œé‚£ä¹ˆå¯ä»¥è€ƒè™‘ä½¿ç”¨ViewStubçš„æƒ…å†µæœ‰ï¼š åœ¨ç¨‹åºçš„è¿è¡ŒæœŸé—´ï¼ŒæŸä¸ªå¸ƒå±€åœ¨Inflateåï¼Œå°±ä¸ä¼šæœ‰å˜åŒ–ï¼Œé™¤éé‡æ–°å¯åŠ¨ã€‚ å› ä¸ºViewStubåªèƒ½Inflateä¸€æ¬¡ï¼Œä¹‹åä¼šè¢«ç½®ç©ºï¼Œæ‰€ä»¥æ— æ³•æŒ‡æœ›åé¢æ¥ç€ä½¿ç”¨ViewStubæ¥æ§åˆ¶å¸ƒå±€ã€‚æ‰€ä»¥å½“éœ€è¦åœ¨è¿è¡Œæ—¶ä¸æ­¢ä¸€æ¬¡çš„æ˜¾ç¤ºå’Œéšè—æŸä¸ªå¸ƒå±€ï¼Œé‚£ä¹ˆViewStubæ˜¯åšä¸åˆ°çš„ã€‚è¿™æ—¶å°±åªèƒ½ä½¿ç”¨Viewçš„å¯è§æ€§æ¥æ§åˆ¶äº†ã€‚ æƒ³è¦æ§åˆ¶æ˜¾ç¤ºä¸éšè—çš„æ˜¯ä¸€ä¸ªå¸ƒå±€æ–‡ä»¶ï¼Œè€ŒéæŸä¸ªViewã€‚ å› ä¸ºè®¾ç½®ç»™ViewStubçš„åªèƒ½æ˜¯æŸä¸ªå¸ƒå±€æ–‡ä»¶çš„Idï¼Œæ‰€ä»¥æ— æ³•è®©å®ƒæ¥æ§åˆ¶æŸä¸ªViewã€‚ æ‰€ä»¥ï¼Œå¦‚æœæƒ³è¦æ§åˆ¶æŸä¸ªView(å¦‚Buttonæˆ–TextView)çš„æ˜¾ç¤ºä¸éšè—ï¼Œæˆ–è€…æƒ³è¦åœ¨è¿è¡Œæ—¶ä¸æ–­çš„æ˜¾ç¤ºä¸éšè—æŸä¸ªå¸ƒå±€æˆ–Viewï¼Œåªèƒ½ä½¿ç”¨Viewçš„å¯è§æ€§æ¥æ§åˆ¶ã€‚ startService","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%8818%E6%97%A5/"},{"title":"å®ä¹ ç¬”è®°-15","text":"gradleå…¨å±€é…ç½®é…ç½®GRADLE_USER_HOMEç¯å¢ƒå˜é‡","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%888%E6%97%A5/"},{"title":"å®ä¹ ç¬”è®°-23","text":"MutableLiveDataè¸©å‘ä½¿ç”¨MutableLiveDataçš„observerå¯¹æ•°æ®è¿›è¡Œè§‚å¯Ÿï¼Œè·³è½¬ç•Œé¢è¿”å›ååˆ é™¤listä¸­çš„å…ƒç´ ï¼Œå‡ºç°CurrentModificationExceptionæ”¹ç”¨Vectorç­‰çº¿ç¨‹å®‰å…¨çš„é›†åˆ BinderBinder ä¸å…¶ä»–IPCçš„æ¯”è¾ƒ binder å…±äº«å†…å­˜ Socket æ‹·è´ä¸€æ¬¡ 0 1 C/Sæ¨¡å¼ï¼Œæ˜“ç”¨æ€§é«˜ æ§åˆ¶è´Ÿè½½ï¼Œæ˜“ç”¨æ€§å·® C/Så¼€é”€å¤§ ä¸ºæ¯ä¸ªAppåˆ†é…UID è®¿é—®æ¥å…¥ç‚¹æ˜¯å¼€æ”¾çš„ï¼Œä¸å®‰å…¨ è®¿é—®æ¥å…¥ç‚¹æ˜¯å¼€æ”¾çš„ï¼Œä¸å®‰å…¨ å…±äº«å†…å­˜ ä¸¤ä¸ªmmapï¼ŒBinderä¸€ä¸ªmmap AIDLbindServiceåˆ°onConnectionä¹‹é—´ asInterfaceä¼šè·å¾—Proxyï¼Œè°ƒç”¨ä»£ç†å¯¹è±¡çš„æ–¹æ³•ä¼šè°ƒç”¨mRemote.transact,ä¼ é€’è°ƒç”¨çš„æ–¹æ³•çš„ç¼–ç ï¼Œå¹¶æŒ‚èµ·å½“å‰è¿›ç¨‹ èƒ½å¤Ÿå¯åŠ¨æœåŠ¡æ‰€åœ¨è¿›ç¨‹å’ŒæœåŠ¡","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%8822%E6%97%A5/"},{"title":"å®ä¹ ç¬”è®°-13","text":"ä¸ºä»€ä¹ˆç”¨SurfaceViewä¸ç”¨è‡ªå®šä¹‰ç»„ä»¶ å°ç»„ä»¶åœ¨å¸ƒå±€ä¸Šçš„å±€é™æ€§ åªæ”¯æŒåŸç”Ÿæ§ä»¶ï¼Œä¸”ä¸æ”¯æŒä»–ä»¬çš„åä»£ éš¾ä»¥åŠ¨æ€æ›´æ–°åŠ¨ç”»1234567891011121314151617FrameLayoutLinearLayoutRelativeLayoutGridLayoutAnalogClockButtonChronometerImageButtonImageViewProgressBarTextViewViewFlipperListViewGridViewStackViewAdapterViewFlipper åªèƒ½æ˜¾ç¤ºåœ¨æŸä¸€å± ä¼˜åŒ–ç©ºé—´ å£çº¸çš„æ“ä½œå’Œéƒ¨åˆ†launcherçš„æ“ä½œå†²çª åªèƒ½åœ¨å³ä¾§ï¼Œå¯¹å·¦æ’‡å­ä¸å‹å¥½ ä¸¤ä¸ªwallpaperçš„drawFrameæ–¹æ³•ç›¸ä¼¼ï¼Œå¯ä»¥è¿›ä¸€æ­¥æŠ½è±¡","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%882%E6%97%A5/"},{"title":"å®ä¹ ç¬”è®°-14","text":"æ›´æ–°æ¡Œé¢å°ç»„ä»¶ Handleræ›´æ–°ï¼šåªèƒ½åšæŒå‡ ç§’é’Ÿ Serviceå‘é€å¹¿æ’­æ›´æ–° Serviceçš„contextä»onReceiveè·å–ï¼Œä¸€åˆ‡æ­£å¸¸ã€‚ä¼šå­˜åœ¨ä¿æ´»çš„é—®é¢˜ï¼Œè‡³å°‘30åˆ†é’Ÿç³»ç»Ÿæ‰è°ƒç”¨onUpdateä¸€æ¬¡ ä½¿ç”¨lateinitä¿å­˜onUpdateçš„contextï¼Œä¼šæŠ¥é”™lateinit property mContext has not been initialized onUpdateæš´åŠ›é€’å½’ ç‚¹å‡»åæ— æ³•æ›´æ–°","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%887%E6%97%A5/"},{"title":"å®ä¹ ç¬”è®°-16","text":"Android Viewç»˜åˆ¶æµç¨‹performTraversals()è·å–Surfaceå¯¹è±¡ï¼ŒperformMeasure-ä¸ˆé‡Viewæ ‘çš„å„ä¸ªviewçš„å¤§å°ï¼ŒperformLayout-å¯¹æ•´ä¸ªè§†å›¾æ ‘è¿›è¡Œå¸ƒå±€ï¼ŒperformDrawï¼Œå¯¹è§†å›¾æ ‘è¿›è¡Œç»˜åˆ¶æºç è§£æ ç¬¬ä¸€é˜¶æ®µï¼Œç¡®å®šactivityçš„å®½é«˜123456789if(Activityçª—å£æ˜¯ç¬¬ä¸€æ¬¡è¢«è¯·æ±‚æ‰§è¡Œæµ‹é‡ã€å¸ƒå±€å’Œç»˜åˆ¶æ“ä½œ){ if(å¦‚æœçª—å£çš„ç±»å‹æ˜¯æœ‰çŠ¶æ€æ çš„){ Activityçª—å£æ‰€éœ€è¦çš„å®½åº¦å’Œé«˜åº¦å°±æ˜¯é™¤äº†çŠ¶æ€æ ; }else{ Activityçª—å£æ‰€éœ€è¦çš„å®½åº¦å’Œé«˜åº¦å°±æ˜¯æ•´ä¸ªå±å¹•çš„å®½é«˜; }}else{ Activityçª—å£çš„å®½é«˜ä¸ºframeæˆå‘˜å˜é‡ä¸­çš„ä¿å­˜çš„ä¸Šä¸€æ¬¡æµ‹é‡ã€å¸ƒå±€å’Œç»˜åˆ¶æ—¶çš„å€¼;} æ’åºä¸­æ–‡æŒ‰ç…§æ‹¼éŸ³æ’åº 1234567list.sortBy { try { URLEncoder.encode(it.label.lowercase(), &quot;GBK&quot;) } catch (e:Exception) { &quot;&quot; }} 123Comparator cmp = Collator.getInstance(java.util.Locale.CHINA);cmp.compare(s1,s2);Arrays.sort(arr, cmp); VectorDrawablemergeæ ‡ç­¾å°†mergeä¸‹çš„æ‰€æœ‰viewç›´æ¥æ·»åŠ åˆ°æ ¹æ ‡ç­¾ä¸‹","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%889%E6%97%A5/"},{"title":"Kotlinå­¦ä¹ ç¬”è®°â€”â€”Activityæ´»åŠ¨è·³è½¬","text":"ä¼ é€é…å¯¹å­—æ®µæ•°æ®æ‰“å¼€ä¸€ä¸ªæ–°é¡µé¢1startActivity&lt;secondActivity&gt;() æ³¨æ„ è¿™ä¸ªå‡½æ•°éœ€è¦ankoåº“çš„æ”¯æŒ æ‰“å¼€é¡µé¢å¹¶å‘æ–°é¡µé¢ä¼ é€’å‚æ•°ä½¿ç”¨å…³é”®å­—to1234startActivity&lt;secondActivity&gt;( &quot;start_time&quot; to currentTime.toString(), &quot;message&quot; to &quot;good Morning&quot; ) ä½¿ç”¨Pairç±»1234startActivity&lt;secondActivity&gt; ( Pair(&quot;start_time&quot;, currentTime.toString(), Pair(&quot;message&quot;, &quot;good Morning&quot;)) åœ¨æ–°é¡µé¢ä¸­è·å–å‚æ•°123val bundle = intent.extrasval start_time = bundle.getString(&quot;start_time&quot;)val message = bundle.getString(&quot;message&quot;) è¡¥å……1. intentå‚è€ƒï¼šAndroidç»„ä»¶ç³»åˆ—â€”-Intentè¯¦è§£ Intentçš„æ¦‚å¿µï¼šAndroidä¸­æä¾›äº†Intentæœºåˆ¶æ¥ååŠ©åº”ç”¨é—´çš„äº¤äº’ä¸é€šè®¯ï¼Œæˆ–è€…é‡‡ç”¨æ›´å‡†ç¡®çš„è¯´æ³•æ˜¯ï¼ŒIntentä¸ä»…å¯ç”¨äºåº”ç”¨ç¨‹åºä¹‹é—´ï¼Œä¹Ÿå¯ç”¨äºåº”ç”¨ç¨‹åºå†…éƒ¨çš„activity, serviceå’Œbroadcast receiverä¹‹é—´çš„äº¤äº’ã€‚Intentè¿™ä¸ªè‹±è¯­å•è¯çš„æœ¬æ„æ˜¯â€œç›®çš„ã€æ„å‘ã€æ„å›¾â€ã€‚ Intentæ˜¯ä¸€ç§è¿è¡Œæ—¶ç»‘å®šï¼ˆruntime binding)æœºåˆ¶ï¼Œå®ƒèƒ½åœ¨ç¨‹åºè¿è¡Œçš„è¿‡ç¨‹ä¸­è¿æ¥ä¸¤ä¸ªä¸åŒçš„ç»„ä»¶ã€‚é€šè¿‡Intentï¼Œä½ çš„ç¨‹åºå¯ä»¥å‘Androidè¡¨è¾¾æŸç§è¯·æ±‚æˆ–è€…æ„æ„¿ï¼ŒAndroidä¼šæ ¹æ®æ„æ„¿çš„å†…å®¹é€‰æ‹©é€‚å½“çš„ç»„ä»¶æ¥å“åº”ã€‚ activityã€serviceå’Œbroadcast receiverä¹‹é—´æ˜¯é€šè¿‡Intentè¿›è¡Œé€šä¿¡çš„ï¼Œè€Œå¦å¤–ä¸€ä¸ªç»„ä»¶Content Provideræœ¬èº«å°±æ˜¯ä¸€ç§é€šä¿¡æœºåˆ¶ï¼Œä¸éœ€è¦é€šè¿‡Intentã€‚æˆ‘ä»¬æ¥çœ‹ä¸‹é¢è¿™ä¸ªå›¾å°±çŸ¥é“äº†ï¼š å¦‚æœActivity1éœ€è¦å’ŒActivity2è¿›è¡Œè”ç³»ï¼ŒäºŒè€…ä¸éœ€è¦ç›´æ¥è”ç³»ï¼Œè€Œæ˜¯é€šè¿‡Intentä½œä¸ºæ¡¥æ¢ã€‚é€šä¿—æ¥è®²ï¼ŒIntnetç±»ä¼¼äºä¸­ä»‹ã€åª’å©†çš„è§’è‰²ã€‚ 2. bundleå‚è€ƒAndroidä¸­Bundleç±»çš„ä½œç”¨ Androidä¸­Bundleç±»çš„ä½œç”¨ Bundleç±»ç”¨ä½œæºå¸¦æ•°æ®ï¼Œå®ƒç±»ä¼¼äºMapï¼Œç”¨äºå­˜æ”¾key-valueåå€¼å¯¹å½¢å¼çš„å€¼ æ ¹æ®googleå®˜æ–¹çš„æ–‡æ¡£ï¼ˆhttp://developer.android.com/reference/android/os/Bundle.htmlï¼‰ Bundleç±»æ˜¯ä¸€ä¸ªkey-valueå¯¹ï¼Œâ€œA mapping from String values to various Parcelable types.â€ ä¼ é€åºåˆ—åŒ–æ•°æ®12@Parcelizedata class MessageInfo(val content: String, val send_time: String) : Parcelable {} æ³¨æ„ æ³¨è§£@Parcelizeä¸æ˜¯æ²¡æœ‰ç”¨çš„ï¼Œå®ƒå¯ä»¥å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œè®©ç¼–è¯‘å™¨è‡ªåŠ¨å®ç°writeToParcelã€createFromParcelã€newArrayã€describeContentså››ä¸ªæ–¹æ³• è¦åœ¨build.gradleçš„æ–‡ä»¶æœ«å°¾æ·»åŠ å¦‚ä¸‹å‡ è¡Œ123androidExtensions { experimental = true} è¿™æ ·ä»¥åï¼Œå°±å¯ä»¥åœ¨é¡µé¢ä¹‹é—´ä¼ é€’æ´»åŠ¨è·³è½¬çš„åºåˆ—åŒ–æ•°æ®äº†12val request = MessageInfo(&quot;ä½ å¥½ä½ å¥½ï¼&quot;, currentTime.toString())startActivity&lt;secondActivity&gt;(&quot;message&quot; to request) åœ¨è·³è½¬åçš„é¡µé¢è·å–æ•°æ®1val request = intent.extras.getParcelabel&lt;MessageInfo&gt;(&quot;message)//è·å¾—æ•°æ® è·³è½¬æ—¶æŒ‡å®šå¯åŠ¨æ¨¡å¼ å¯åŠ¨æ ‡å¿— å¯¹åº”ankoåº“å‡½æ•° è¯´æ˜ å¤‡æ³¨ Intent.FLAG_ACTIVITY_NEW_TAST intent.newTask() å¼€å¯ä¸€ä¸ªæ–°ä»»åŠ¡ã€‚è¿™ä¸ªå€¼ç±»ä¼¼äºlaunchMode=â€standardâ€ï¼Œä¸åŒä¹‹å¤„åœ¨äºï¼Œå¦‚æœåŸæ¥ä¸å­˜åœ¨æ´»åŠ¨æ ˆï¼Œè¿™ä¸ªæ ‡å¿—å°±ä¼šåˆ›å»ºä¸€ä¸ªæ–°æ ˆ Intent.FLAG_ACTIVITY_SINGLE_TOP intent.singleTop() å½“æ ˆé¡¶ä¸ºå¾…è·³è½¬çš„activityå®ä¾‹æ—¶ï¼Œé‡ç”¨æ ˆé¡¶çš„å®ä¾‹ï¼Œè¯¥å€¼ç­‰åŒäºlaunchMode=â€singleTopâ€ Intent.FLAG_ACTIVITY_CLEAR_TOP intent.clrarTop() å½“æ ˆä¸­å­˜åœ¨å¾…è·³è½¬çš„activityå®ä¾‹æ—¶ï¼Œé‡æ–°åˆ›å»ºä¸€ä¸ªæ–°å®ä¾‹ï¼Œå¹¶å°†åŸå®ä¾‹ä¸Šæ–¹æ‰€æœ‰å®ä¾‹æ¸…é™¤ã€‚è¯¥å€¼ä¸launchMode=â€singleTaskâ€ç›¸ä¼¼ï¼Œä½†æ˜¯launchMode=â€singleTaskâ€é‡‡ç”¨onNewIntenå¯ç”¨åŸä»»åŠ¡ï¼Œè€Œè¿™ä¸ªæ ‡å¿—å…ˆonDestroyå†onCreateåˆ›å»ºæ–°ä»»åŠ¡ Intent.FLAG_ACTIVITY_NO_HISTORY intent.noHistory() è¿™ä¸ªæ ‡å¿—ä¸launchMode=â€standardâ€ç›¸ä¼¼ï¼Œä½†æ ˆä¸­ä¸ä¿å­˜æ–°å¯åŠ¨çš„activityå®ä¾‹ã€‚ä¸‹æ¬¡æ— è®ºä½¿ç”¨å“ªç§æ–¹æ³•å†å¯åŠ¨è¯¥å®ä¾‹ï¼Œéƒ½è¦èµ°å®Œstandardçš„å®Œæ•´æµç¨‹ Intent.FLAG_ACTIVITY_CLEAR_TAST intent.clearTask() è¿™ä¸ªæ ‡å¿—éå¸¸æš´åŠ›ï¼Œè·³è½¬åˆ°æ–°é¡µé¢æ—¶ï¼Œæ ˆä¸­åŸæœ‰å®ä¾‹éƒ½è¢«æ¸…ç©ºã€‚è¿™ä¸ªflagè¦ç»“åˆnewTaskä½¿ç”¨ å¤„ç†è¿”å›æ•°æ®å½“ä»ä¸€ä¸ªé¡µé¢è·³è½¬å›åŸæ¥çš„é¡µé¢æ—¶ï¼Œæœ‰å¯èƒ½è¦å‘ä¸Šä¸€ä¸ªactivityè¿”å›ä¸€äº›æ•°æ® ç¬¬ä¸€ä¸ªé¡µé¢æ‰“å¼€ç¬¬äºŒä¸ªé¡µé¢æ—¶ï¼Œæ”¹ç”¨startActivityForResult12val info = MessageInfo(&quot;å»å§ï¼å»å§ï¼&quot;, currentTime.toString())startActivityForResult&lt;secondActivity&gt;(0, &quot;goï¼goï¼goï¼&quot; to info)//ä¼ é€’ç»™ç¬¬äºŒä¸ªé¡µé¢çš„æ•°æ® ç¬¬äºŒä¸ªé¡µé¢é€€å‡ºæ—¶ï¼Œæ·»åŠ ä¼ é€æ•°æ®123456val info = MessageInfo(&quot;å›æ¥äº†ï¼å›æ¥äº†ï¼&quot;, currentTime.toString())//è¿”å›ç»™ç¬¬ä¸€ä¸ªé¡µé¢çš„æ•°æ®//MessageInfoç±»æ˜¯ä¹‹å‰å†™çš„ç»§æ‰¿Parcelable çš„ data classval intent = Intent()intent.putExtra(&quot;back&quot;, info)setResult(Activity.RESULT_OK, intent)finish() ä¸Šä¸€ä¸ªé¡µé¢æ¥å—è¿”å›å€¼123456override fun onActivityResult(RequestCode:Int, resultCode:Int, data:Intent?) { if (data != null) { val response = data.extras.getParcelable&lt;MessageInfo&gt;(&quot;back&quot;) //è·å–äº†MessageInfoç±»çš„å¯¹è±¡ }} onRestart()å‡½æ•°å‚è€ƒï¼š Activityçš„onRestart()æ–¹æ³•è°ƒç”¨æ—¶æœº ä¸¤åˆ†é’Ÿå½»åº•è®©ä½ æ˜ç™½Android Activityç”Ÿå‘½å‘¨æœŸ(å›¾æ–‡)! https://blog.csdn.net/liuhe688/article/details/6733407 è°ƒç”¨æ—¶æœº æŒ‰ä¸‹homeé”®ä¹‹åï¼Œç„¶ååˆ‡æ¢å›æ¥ï¼Œä¼šè°ƒç”¨onRestart()ã€‚ ä»æœ¬Activityè·³è½¬åˆ°å¦ä¸€ä¸ªActivityä¹‹åï¼ŒæŒ‰backé”®è¿”å›åŸæ¥Activityï¼Œä¼šè°ƒç”¨onRestart(); ä»æœ¬Activityåˆ‡æ¢åˆ°å…¶ä»–çš„åº”ç”¨ï¼Œç„¶åå†ä»å…¶ä»–åº”ç”¨åˆ‡æ¢å›æ¥ï¼Œä¼šè°ƒç”¨onRestart(); åº”ç”¨åœºæ™¯åœ¨ç™»å½•é¡µé¢ä¸Šï¼Œç”¨æˆ·å¿˜è®°å¯†ç ï¼Œç‚¹å‡»â€å¿˜è®°å¯†ç â€å¹¶è·³è½¬åˆ°ç›¸åº”é¡µé¢ï¼Œå½“è¿”å›ç™»å½•é¡µé¢æ—¶ï¼Œæœ€å¥½è‡ªåŠ¨æ¸…ç©ºåŸæ¥çš„å¯†ç ï¼Œå¦‚æœè¿™ä¸ªæ“ä½œå†™åœ¨onActivityResultä¸Šï¼Œé‚£ä¹ˆå½“ç”¨æˆ·æ‰“å¼€â€æ‰¾å›å¯†ç â€é¡µé¢ï¼Œä¸å±äºè°ƒç”¨onActivityResultçš„æ—¶æœº å®ä¾‹1234override fun onRestart() { //do what u wanna do super.onRestart()}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Activity%E6%B4%BB%E5%8A%A8%E8%B7%B3%E8%BD%AC/"},{"title":"Kotlinå­¦ä¹ ç¬”è®°â€”â€”BroadCast","text":"1#define å°æ¯›é©´ xml æ”¶å‘å¹¿æ’­ä½¿ç”¨åœºæ™¯ï¼šFragmentæƒ³è¦å‘å¤–ä¼ é€’ä¿¡æ¯ åœ¨Fragmentä¸­å‘é€å¹¿æ’­1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class BlankFragment : Fragment() { var ctx:Context? = null var mPosition:Int = 0 var mInageId:Int = 0 var mDesc:String = &quot;&quot; var title:String = &quot;&quot; val colorNames = listOf&lt;String&gt;(&quot;çº¢è‰²&quot;,&quot;é»„è‰²&quot;,&quot;ç»¿è‰²&quot;,&quot;é’è‰²&quot;,&quot;è“è‰²&quot;) val colors = intArrayOf(Color.RED, Color.YELLOW, Color.GREEN, Color.CYAN, Color.BLUE) var mSeq:Int = 0 override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { ctx = activity if (arguments != null) { mPosition = arguments!!.getInt(&quot;position&quot;, 0) mInageId = arguments!!.getInt(&quot;image_id&quot;, 0) mDesc = arguments!!.getString(&quot;desc&quot;) title = arguments!!.getString(&quot;title&quot;) } val view = inflater.inflate(R.layout.show_info, container, false) view.findViewById&lt;ImageView&gt;(R.id.imageView).setImageResource(mInageId) view.findViewById&lt;TextView&gt;(R.id.textView).text = mDesc view.findViewById&lt;Button&gt;(R.id.se).setOnClickListener { ctx!!.selector(&quot;é€‰æ‹©é¢œè‰²&quot;, colorNames) { mSeq = it val intent = Intent(BlankFragment.EVENT) intent.putExtra(&quot;seq&quot;, it) intent.putExtra(&quot;color&quot;, colors[it]) ctx!!.sendBroadcast(intent)//å‘é€å¹¿æ’­ } } return view } companion object { const val EVENT:String = &quot;changeColor&quot;//constï¼Œç¼–è¯‘æœŸå¸¸é‡ fun newInstance(position:Int, image_id:Int, desc:String, title:String) : BlankFragment { val fragment = BlankFragment() val bundle = Bundle() bundle.putInt(&quot;position&quot;, position) bundle.putInt(&quot;image_id&quot;, image_id) bundle.putString(&quot;desc&quot;, desc) bundle.putString(&quot;title&quot;, title) fragment.arguments = bundle return fragment } }} åœ¨è¦æ¥æ”¶å¹¿æ’­çš„é¡µé¢æ³¨å†Œreceiver1234567891011121314151617181920212223242526272829303132333435363738394041class MainActivity : FragmentActivity(){ private var BGChangeRecever:myBgChangeRecever? = null override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) var vp:ViewPager = findViewById(R.id.vp) var title: PagerTabStrip = findViewById(R.id.title) val pics = arrayOf(R.mipmap.basic, R.mipmap.close, R.mipmap.debug, R.mipmap.edit) val list:MutableList&lt;itemInfo&gt; = mutableListOf() for (i in pics.indices) { list.add(itemInfo((i+1).toString(), pics[i], ((i+1)*(i+1)).toString())) } vp.adapter = infoPagerAdapter(supportFragmentManager, list) vp.currentItem = 0 } public override fun onStart() { super.onStart() BGChangeRecever = myBgChangeRecever() val filiter = IntentFilter(BlankFragment.EVENT)//å¹¿æ’­è¿‡æ»¤å™¨ï¼Œè¿‡æ»¤æ‰å‚æ•°ä»¥å¤–çš„å¹¿æ’­ registerReceiver(BGChangeRecever,filiter)//å¼€å§‹æ—¶æ³¨å†Œæ¥æ”¶å™¨ } public override fun onStop() { unregisterReceiver(BGChangeRecever)//ç»“æŸå‰æ³¨é”€æ¥æ”¶å™¨ super.onStop() } private inner class myBgChangeRecever : BroadcastReceiver() {//å¹¿æ’­æ¥æ”¶å™¨ override fun onReceive(context: Context?, intent: Intent?) {//æ¥æ”¶å¹¿æ’­åæ‰§è¡Œçš„æ“ä½œ if (intent != null) { val color = intent.getIntExtra(&quot;color&quot;, Color.GREEN) textView2.setTextColor(color) } } }} æ¥æ”¶ç³»ç»Ÿå¹¿æ’­é™æ€æ³¨å†Œæ²¡å­¦ä¼š åŠ¨æ€æ³¨å†Œ1234567891011121314151617181920212223242526272829303132333435363738394041424344class MainActivity : AppCompatActivity() { var receiver:broadCastRecever = broadCastRecever() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) } override fun onDestroy() { super.onDestroy() receiver.unRegiste() } override fun onStart() { super.onStart() receiver.registe(this) } inner class broadCastRecever : BroadcastReceiver() { private var isRegisted = false var allBroadCast = arrayOf(Intent.ACTION_TIME_TICK, Intent.ACTION_SCREEN_ON, Intent.ACTION_SCREEN_OFF) var registTo:Context? = null override fun onReceive(context: Context?, intent: Intent?) { text.append(&quot;æ”¶åˆ°ï¼š${(intent?.action?:&quot;empty&quot;)}\\n&quot;) } fun registe(context: Context) { if (!isRegisted) { var filter:IntentFilter = IntentFilter() for (item in allBroadCast) { filter.addAction(item) } context.registerReceiver(this@broadCastRecever, filter) isRegisted = true registTo = context } } fun unRegiste() { if (isRegisted) { registTo?.unregisterReceiver(this@broadCastRecever) isRegisted = false } } }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94BroadCast/"},{"title":"Kotlinå­¦ä¹ ç¬”è®°â€”â€”Button","text":"å®ç°çŸ­æŒ‰é•¿æŒ‰çš„æ–¹æ³•è°ƒç”¨å‡½æ•° æ–¹æ³• å‚æ•° å‚æ•°è§£é‡Š è¿”å›å€¼ å¤‡æ³¨ setOnClickListener lambdaè¡¨è¾¾å¼ lambdaçš„å‚æ•°ä¸ºå‘ç”Ÿç‚¹å‡»åŠ¨ä½œçš„Viewï¼Œè¿”å›å€¼Unit Unit ç›¸å½“äºoverride fun onClickListener(v:View) setOnLongClickListener lambdaè¡¨è¾¾å¼ lambdaçš„å‚æ•°ä¸ºå‘ç”Ÿç‚¹å‡»åŠ¨ä½œçš„Viewï¼Œè¿”å›å€¼Boolean(trueè¡¨ç¤ºè¿™ä¸ªäº‹ä»¶å·²ç»æ¶ˆè€—å®Œäº†ï¼Œfalseè¡¨ç¤ºäº‹ä»¶ç»§ç»­ä¼ é€’ï¼Œä¼šè§¦å‘ä¸€æ¬¡çŸ­æŒ‰äº‹ä»¶) Unit ç›¸å½“äºoverride fun onLongClick(v:View):Boolean ä¾‹å­1234567btn.setOnClickListener { toast(&quot;click&quot;)}btn.setOnLongClickListener { toast(&quot;Long Click&quot;) true} ä½¿ç”¨å†…éƒ¨ç±»ä¾‹å­12345678910//åœ¨Activityç±»é‡Œé¢/*inner å…³é”®å­—ï¼Œè®¿é—®å¤–éƒ¨ç±»çš„æ•°æ®ç»§æ‰¿View.onClickListener*/private inner class MyClickListener : View.onClickListener { override fun onClick(v:View) { toast.(&quot;æ‚¨ç‚¹å‡»äº†ï¼š${(v as Button).text}&quot;) }} å®ç°æ¥å£è®©å½“å‰Activityå®ç°OnClickListenerå’ŒOnLongClickListenerä¸¤ä¸ªæ¥å£ ä¾‹å­12345678910111213141516171819class MainActivity : AppCompatActivity() , OnClickListener, OnLongClickListener { override fun onClick(v: View?) { var text:TextView = findViewById(R.id.text) text.append(&quot;hello world\\n&quot;) } override fun onLongClick(v: View?): Boolean { toast(&quot;å“å‘€ï¼Œä¸€ç›´æŒ‰ç€äººå®¶å¹²ä»€ä¹ˆå•¦~~&quot;) return true } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) var start:FloatingActionButton = findViewById(R.id.start) start.setOnLongClickListener(this) start.setOnClickListener(this) }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Button/"},{"title":"Kotlinå­¦ä¹ ç¬”è®°â€”â€”Fragment","text":"1#define å°æ¯›é©´ xml ä½¿ç”¨æ–¹æ³•Fragmentä¸ViewPageræ­é…ï¼Œå®ç°ç¿»é¡µï¼Œå®ç°æ¯é¡µå¤šä¸ªæ§ä»¶ å†™å¥½æ¯ä¸ªitemçš„å°æ¯›é©´æ–‡ä»¶å’Œæ•°æ®ä¼ é€ç±» ç»§æ‰¿Fragmentç±»ï¼Œè‡ªå®šä¹‰ä¸€ä¸ªfragment12345678910111213141516171819202122232425262728293031323334353637383940class BlankFragment : Fragment() { var ctx:Context? = null var mPosition:Int = 0 var mInageId:Int = 0 var mDesc:String = &quot;&quot; var title:String = &quot;&quot; val colorNames = listOf&lt;String&gt;(&quot;çº¢è‰²&quot;,&quot;é»„è‰²&quot;,&quot;ç»¿è‰²&quot;,&quot;é’è‰²&quot;,&quot;è“è‰²&quot;) val colors = intArrayOf(Color.RED, Color.YELLOW, Color.GREEN, Color.CYAN, Color.BLUE) var mSeq:Int = 0 override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { ctx = activity if (arguments != null) { mPosition = arguments!!.getInt(&quot;position&quot;, 0) mInageId = arguments!!.getInt(&quot;image_id&quot;, 0) mDesc = arguments!!.getString(&quot;desc&quot;) title = arguments!!.getString(&quot;title&quot;) }//è·å–æ•°æ® val view = inflater.inflate(R.layout.show_info, container, false) view.findViewById&lt;ImageView&gt;(R.id.imageView).setImageResource(mInageId) view.findViewById&lt;TextView&gt;(R.id.textView).text = mDesc //æ˜¾ç¤ºæ•°æ® return view } companion object { fun newInstance(position:Int, image_id:Int, desc:String, title:String) : BlankFragment {//è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œåˆ›å»ºæ–°çš„fragment val fragment = BlankFragment() val bundle = Bundle() bundle.putInt(&quot;position&quot;, position) bundle.putInt(&quot;image_id&quot;, image_id) bundle.putString(&quot;desc&quot;, desc) bundle.putString(&quot;title&quot;, title) fragment.arguments = bundle return fragment } }} ViewPagerçš„é€‚é…å™¨1234567891011class infoPagerAdapter(val fragManger: FragmentManager, val itemList:MutableList&lt;itemInfo&gt;) : FragmentStatePagerAdapter(fragManger) { override fun getCount(): Int = itemList.size override fun getItem(p0: Int): Fragment { val item = itemList[p0] return BlankFragment.newInstance(p0, item.pic, item.desc, item.name) } override fun getPageTitle(position: Int): CharSequence? { return itemList[position].name }} 4.ç»™ViewPageræ·»åŠ é€‚é…å™¨12345678910111213class MainActivity : FragmentActivity(){//è¿™ä¸ªæ—¶å€™ï¼Œç»§æ‰¿çš„æ˜¯FragmentActivity override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) var vp:ViewPager = findViewById(R.id.vp) var title: PagerTabStrip = findViewById(R.id.title) val list:MutableList&lt;itemInfo&gt; = mutableListOf() //çœç•¥ä¸­é—´ç»™listèµ‹å€¼çš„è¿‡ç¨‹ vp.adapter = infoPagerAdapter(supportFragmentManager, list) vp.currentItem = 0 }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Fragment/"},{"title":"Kotlinå­¦ä¹ ç¬”è®°â€”â€”EditText","text":"è¾“å…¥ç›‘å¬å™¨æ–¹ä¾¿èµ·è§ï¼Œåœ¨activityçš„å†…éƒ¨å†™ä¸€ä¸ªå†…éƒ¨ç±»ï¼Œç”¨æ¥ç›‘å¬è¾“å…¥ ç¼–å†™ç›‘å¬å™¨1234567891011inner class EditWatcher : TextWatcher { override fun afterTextChanged(s:Editable) { } override fun beforeTextChanged(s:CharSequence, start:Int, count:Int, after:Int) { } override fun onTextChanged(s:CharSequence, start:Int, count:Int, after:Int) { }} æ³¨æ„ æŠŠEditableç›´æ¥toString()å°±æ˜¯ç”¨æˆ·å½“å‰çš„è¾“å…¥ ä½¿ç”¨ç›‘å¬å™¨1et.addTextChangedListener(EditWatcher()) æ•ˆæœ1. è‡ªåŠ¨éšè—è¾“å…¥æ³•é¢æ¿12345678910111213141516171819202122232425private inner class EditWatcher(val type:String, val len:Int, val edit:EditText) : TextWatcher { override fun afterTextChanged(s:Editable) { var str:String = s.toString() if (str.indexOf(&quot;\\n&quot;) &gt;= 0 || str.indexOf(&quot;\\r&quot;) &gt;= 0 || str.indexOf(&quot; &quot;) &gt;= 0) { str = str.replace(&quot;\\r&quot;, &quot;&quot;).replace(&quot;\\n&quot;, &quot;&quot;).replace(&quot; &quot;, &quot;&quot;) } if (str.length &gt; len) { toast(&quot;${type}æœ€é•¿${len}ä½ï¼&quot;) edit.setText(str.substring(0, len)) //å¤§äºlençš„æ—¶å€™å†æˆªå–å­ä¸² val imm = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager //è½¯é”®ç›˜å¦‚æœå·²ç»æ‰“å¼€åˆ™å…³é—­ä¹‹ if (imm.isActive) { imm.toggleSoftInput(0, InputMethodManager.HIDE_NOT_ALWAYS) } } } override fun beforeTextChanged(s:CharSequence, start:Int, count:Int, after:Int) { } override fun onTextChanged(s:CharSequence, start:Int, count:Int, after:Int) { }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94EditText/"},{"title":"Kotlinå­¦ä¹ ç¬”è®°â€”â€”GridView","text":"Kotlinå­¦ä¹ ç¬”è®°â€”â€”GridView1#define å°æ¯›é©´ xml ä½¿ç”¨æ–¹æ³• è®¾è®¡å¥½ç•Œé¢ æ–°å»ºä¸€ä¸ªå°æ¯›é©´æ–‡ä»¶ï¼Œè¿™ä¸ªå°æ¯›é©´æ–‡ä»¶æ˜¯GridViewä¸­ï¼Œæ¯ä¸€ä¸ªItemçš„ç•Œé¢å¸ƒå±€æ–‡ä»¶ ï¼ˆå¯é€‰ï¼‰ç¼–å†™ä¸€ä¸ªæ•°æ®ç±»ï¼Œç”¨æ¥ä¿å­˜æ¯ä¸ªitemä¸­çš„æ•°æ®ï¼Œç”¨data classå¯ä»¥å¾ˆæ–¹ä¾¿ ç¼–å†™ä¸€ä¸ªç»§æ‰¿BaseAdapteré€‚é…å™¨çš„ç±»123456789101112131415161718192021222324252627282930313233343536class GridAdapter(private val context: Context, private val strList:MutableList&lt;myItems&gt;, private val background:Int) : BaseAdapter() { override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View { var view = convertView val holder:ViewHolder if (convertView == null) { view = LayoutInflater.from(context).inflate(R.layout.item, null) //æˆ‘çŒœè¿™ä¸ªå‡½æ•°çš„ä½œç”¨æ˜¯æŒ‡å®šè¿™ä¸ªç±»æ‰€å¯¹åº”çš„å°æ¯›é©´æ–‡ä»¶ holder = ViewHolder() holder.myLayout = view.findViewById&lt;LinearLayout&gt;(R.id.all) holder.desc = view.findViewById&lt;TextView&gt;(R.id.textView) holder.pic = view.findViewById&lt;ImageView&gt;(R.id.imageView) view.tag = holder } else { holder = (view?.tag) as ViewHolder } //ä»¥ä¸Šæ˜¯å›ºå®šæ ¼å¼ val myItem = strList[position] //ä¼ è¿›æ¥çš„æ•°æ®æ•°ç»„ï¼Œé€‚é…å™¨æ ¹æ®æ•°ç»„å¤§å°åå¤è°ƒç”¨è¿™ä¸ªå‡½æ•°æ„é€ ViewList //positionæ˜¯å½“å‰ä½ç½®ï¼Œå¯¹åº”æ•°ç»„ä¸‹æ ‡ //holder.myLayout.setBackgroundColor(background) holder.desc.text = myItem.desc holder.pic.setImageResource(myItem.image) //ä»¥ä¸Šæ˜¯è‡ªå®šä¹‰æ¯ä¸ªæ§ä»¶çš„æ˜¾ç¤ºå†…å®¹ return view!! } override fun getItem(position: Int): Any = strList[position] override fun getItemId(position: Int): Long = position.toLong() override fun getCount(): Int = strList.size inner class ViewHolder { lateinit var myLayout:LinearLayout lateinit var desc: TextView lateinit var pic: ImageView }} å¦‚æœç¼–å†™äº†æ•°æ®ç±»ï¼ˆèµ·äº†ä¸€ä¸ªc++ä¸­ç»“æ„ä½“çš„ä½œç”¨ï¼Œå› ä¸ºæ•°ç»„åªèƒ½ä¼ é€’ä¸€ä¸ªï¼‰ï¼Œåˆ›å»ºå¯¹åº”çš„Listå¹¶ä¸”èµ‹å€¼ ç»™GridViewæ·»åŠ é€‚é…å™¨123456789var grid:GridView = findViewById(R.id.panel)var pics = arrayOf(R.mipmap.a, R.mipmap.b, R.mipmap.c, R.mipmap.d, R.mipmap.e, R.mipmap.f, R.mipmap.g, R.mipmap.h)var descs = arrayOf(&quot;è¶…çº§å¤§å¸…å“¥åˆ˜ç”œç”œ&quot;, &quot;åˆ˜ç”œç”œæœ€å–œæ¬¢çš„å¤§æ˜æ˜Ÿå‘¨å‘¨&quot;, &quot;åˆ˜ç”œç”œæœ€å–œæ¬¢çš„æ€§æ„Ÿè£¸ç”·&quot;, &quot;åˆ˜ç”œç”œæœ€æƒ³å…»çš„æ©˜çŒ«&quot;, &quot;è¿˜æ˜¯è¶…çº§å¤§å¸…å“¥åˆ˜ç”œç”œ&quot;, &quot;åˆ˜ç”œç”œæœ€å–œæ¬¢çš„åŠ¨ç”»äººç‰©ç±³å¥‡&quot;, &quot;è¿˜æ˜¯åˆ˜ç”œç”œæœ€å–œæ¬¢çš„åŠ¨ç”»äººç‰©ç±³å¥‡&quot;, &quot;ç”¨æ¥å‡‘æ•°çš„å‘é™…çº¿å“¥&quot;)var data:MutableList&lt;myItems&gt; = mutableListOf()for (i in pics.indices) { data.add(myItems(descs[i], pics[i]))}grid.adapter = GridAdapter(this, data, Color.GRAY)grid.numColumns = 2//è®¾ç½®åˆ—æ•°","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94GridView/"},{"title":"Kotlinå­¦ä¹ ç¬”è®°â€”â€”ListView","text":"1#define å°æ¯›é©´ xml ä½¿ç”¨æ–¹æ³• è®¾è®¡å¥½ç•Œé¢ æ–°å»ºä¸€ä¸ªå°æ¯›é©´æ–‡ä»¶ï¼Œè¿™ä¸ªå°æ¯›é©´æ–‡ä»¶æ˜¯ListViewä¸­ï¼Œæ¯ä¸€ä¸ªItemçš„ç•Œé¢å¸ƒå±€æ–‡ä»¶ ï¼ˆå¯é€‰ï¼‰ç¼–å†™ä¸€ä¸ªæ•°æ®ç±»ï¼Œç”¨æ¥ä¿å­˜æ¯ä¸ªitemä¸­çš„æ•°æ®ï¼Œç”¨data classå¯ä»¥å¾ˆæ–¹ä¾¿ ç¼–å†™ä¸€ä¸ªç»§æ‰¿BaseAdapteré€‚é…å™¨çš„ç±»123456789101112131415161718192021222324252627282930313233343536373839class ListViewAdapter(private val context: Context, private val strList:MutableList&lt;myItems&gt;, private val background:Int) : BaseAdapter() { override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View { var view = convertView val holder:ViewHolder if (convertView == null) { view = LayoutInflater.from(context).inflate(R.layout.item, null) //æˆ‘çŒœè¿™ä¸ªå‡½æ•°çš„ä½œç”¨æ˜¯æŒ‡å®šè¿™ä¸ªç±»æ‰€å¯¹åº”çš„å°æ¯›é©´æ–‡ä»¶ holder = ViewHolder() holder.ll_item = view.findViewById&lt;LinearLayout&gt;(R.id.ll_item) holder.iv_icon = view.findViewById&lt;ImageView&gt;(R.id.iv_icon) holder.tv_name = view.findViewById&lt;TextView&gt;(R.id.tv_name) holder.tv_desc = view.findViewById&lt;TextView&gt;(R.id.tv_desc) view.tag = holder } else { holder = (view?.tag) as ViewHolder } //ä»¥ä¸Šæ˜¯å›ºå®šæ ¼å¼ val myItem = strList[position] //ä¼ è¿›æ¥çš„æ•°æ®æ•°ç»„ï¼Œé€‚é…å™¨æ ¹æ®æ•°ç»„å¤§å°åå¤è°ƒç”¨è¿™ä¸ªå‡½æ•°æ„é€ ViewList //positionæ˜¯å½“å‰ä½ç½®ï¼Œå¯¹åº”æ•°ç»„ä¸‹æ ‡ holder.ll_item.setBackgroundColor(background) holder.iv_icon.setImageResource(myItem.image) holder.tv_name.text = myItem.name holder.tv_desc.text = myItem.desc //ä»¥ä¸Šæ˜¯è‡ªå®šä¹‰æ¯ä¸ªæ§ä»¶çš„æ˜¾ç¤ºå†…å®¹ï¼Œæ ¹æ®ä¹‹å‰ä¼ è¿›æ¥çš„Listé‡Œé¢çš„æ•°æ® return view!! } override fun getItem(position: Int): Any = strList[position] override fun getItemId(position: Int): Long = position.toLong() override fun getCount(): Int = strList.size inner class ViewHolder { lateinit var ll_item:LinearLayout lateinit var iv_icon:ImageView lateinit var tv_name:TextView lateinit var tv_desc:TextView }} å¦‚æœç¼–å†™äº†æ•°æ®ç±»ï¼ˆèµ·äº†ä¸€ä¸ªc++ä¸­ç»“æ„ä½“çš„ä½œç”¨ï¼Œå› ä¸ºæ•°ç»„åªèƒ½ä¼ é€’ä¸€ä¸ªï¼‰ï¼Œåˆ›å»ºå¯¹åº”çš„Listå¹¶ä¸”èµ‹å€¼ ç»™ListViewæ·»åŠ é€‚é…å™¨1234567891011121314var item:MutableList&lt;myItems&gt; = mutableListOf()val imageIds = arrayOf(R.mipmap.a, R.mipmap.b, R.mipmap.c, R.mipmap.d, R.mipmap.e)var name = arrayOf(&quot;è¶…çº§å¤§å¸…å“¥åˆ˜ç”œç”œ&quot;, &quot;è¿˜æ˜¯è¶…çº§å¤§å¸…å“¥åˆ˜ç”œç”œ&quot;, &quot;å¯çˆ±çš„æ©˜çŒ«&quot;, &quot;æ€§æ„Ÿè£¸ç”·&quot;,&quot;å‘¨å‘¨&quot;)var desc = arrayOf(&quot;æ˜¯ä»–æ˜¯ä»–å°±æ˜¯ä»–ï¼Œæˆ‘ä»¬çš„å¤§å¸…å“¥ï¼Œåˆ˜å¤©å¤©&quot;, &quot;æ˜¯ä»–æ˜¯ä»–è¿˜æ˜¯ä»–ï¼Œæˆ‘ä»¬çš„å¤§å¸…å“¥ï¼Œåˆ˜å¤©å¤©&quot;, &quot;åˆ˜å¤©å¤©æœ€æƒ³å…»çš„æ©˜çŒ«&quot;, &quot;åˆ˜å¤©å¤©æœ€å–œæ¬¢çš„æ€§æ„Ÿè£¸ç”·&quot;,&quot;åˆ˜å¤©å¤©æœ€å–œæ¬¢çš„å¤§æ˜æ˜Ÿå‘¨å‘¨&quot;)//å„ç§æ•°æ®setContentView(R.layout.activity_clickhere)for (i in imageIds.indices) { item.add(myItems(name[i], desc[i], imageIds[i]))}//åˆå§‹åŒ–è¦ä¼ é€’çš„Listvar list:ListView = findViewById&lt;ListView&gt;(R.id.list)list.adapter = ListViewAdapter(this,item ,Color.WHITE)//ä½ åˆšæ‰è‡ªå·±å†™çš„é€‚é…å™¨ç±»//ä¸ºListViewæ·»åŠ é€‚é…å™¨","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94ListView/"},{"title":"Kotlinå­¦ä¹ ç¬”è®°â€”â€”RadioButtonå’ŒRadioGroup","text":"RadioButtonçš„ä½¿ç”¨æ‹–æ‹½å‡ºRadioButtonï¼Œå’ŒRadioGroupï¼ŒæŠŠRadioButtonæ‹–åˆ°RadioGroupçš„å­éƒ¨ä»¶ä¸‹ RadioGroupçš„ä½¿ç”¨ æ–¹æ³• ä½¿ç”¨ å¤‡æ³¨ android:orientation è®¾ç½®RadioGroupä¸­RadioButtonçš„æ’åˆ—æ–¹å¼ â€œverticalâ€ä¸ºå‚ç›´ï¼Œâ€horizontalâ€ä¸ºæ°´å¹³ setOnCheckedChangeListener è®¾ç½®é€‰æ‹©æ”¹å˜æ—¶çš„æ“ä½œ æ—  ç‰¹å®šæ•ˆæœRadioButtonå¤šè¡Œå¤šåˆ—æ˜¾ç¤ºè§£å†³æ–¹æ¡ˆ1å¤šä¸ªButtonGroupï¼Œå½“ä¸€ä¸ªgroupçš„æŒ‰é’®è¢«é€‰æ‹©åï¼Œæ¸…é™¤å…¶ä»–æŒ‰é’®çš„é€‰æ‹© è§£å†³æ–¹æ¡ˆ2é‡å†™ RadioGroup çš„ onMeasureã€onLayout å®ç° RadioButton å¤šè¡Œå¤šåˆ—æ’åˆ—å‚è€ƒæ•™ç¨‹ï¼ˆæ¥è‡ªcsdnï¼‰å›¾ç‰‡ç¼–è¾‘å™¨â€“é‡å†™ RadioGroup çš„ onMeasureã€onLayout å®ç° RadioButton å¤šè¡Œå¤šåˆ—æ’åˆ—","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RadioButton%E5%92%8CRadioGroup/"},{"title":"Kotlinå­¦ä¹ ç¬”è®°â€”â€”RecyclerView","text":"1#define å°æ¯›é©´ xml å¸ƒå±€ç®¡ç†å™¨LinearLayoutManagerç±»ä¼¼äºçº¿æ€§å¸ƒå±€ æ„é€  (Context context) (Context context,int orientation,boolean reverseLayout) (Context context, AttributeSet attrs, int defStyleAttr,int defStyleRes) å‚æ•° è§£é‡Š Context context ä¸Šä¸‹æ–‡ï¼Œåˆå§‹åŒ–æ—¶ï¼Œæ„é€ æ–¹æ³•å†…éƒ¨åŠ è½½èµ„æºç”¨ int orientation æ–¹å‘ï¼Œå‚ç›´å’Œæ°´å¹³ï¼Œé»˜è®¤ä¸ºå‚ç›´ boolean reverseLayout æ˜¯å¦å€’åºï¼Œè®¾ç½®ä¸ºTrueï¼Œä»æœ€åä¸€ä¸ªitemå¼€å§‹ï¼Œå€’åºåŠ è½½ã€‚æ­¤æ—¶ï¼ŒRecyclerViewç¬¬ä¸€ä¸ªitemæ˜¯æ·»åŠ è¿›Adapterä¸­çš„æœ€åä¸€ä¸ªï¼Œæœ€åä¸€ä¸ªitemæ˜¯ç¬¬ä¸€ä¸ªåŠ è¿›Adapterçš„æ•°æ®,RecyclerViewä¼šè‡ªåŠ¨æ»‘åˆ°æœ«å°¾ å‚è€ƒè‹±å‹‡é’é“œ5 GridLayoutManagerç±»ä¼¼GridView æ„é€  è§£é‡Š (Context context, int spanCount) spanCountä¸ºåˆ—æ•° (Context context, int spanCount, int orientation,boolean reverseLayout) orientationåœ¨GridLayoutManagerä¸­æœ‰é™æ€å¸¸é‡ StaggeredGridLayoutManagerç€‘å¸ƒæµ æ„é€  è§£é‡Š (int spanCount, int orientation) æ˜¾ç„¶æ³• ä½¿ç”¨æ–¹æ³• å†™ä¸€ä¸ªåŸºç¡€é€‚é…å™¨1234567891011121314151617181920212223242526272829303132//abstractæŠ½è±¡ç±»ä½œä¸ºåŸºç±»abstract class RecyclerBaseAdapter&lt;VH: RecyclerView.ViewHolder&gt;(val context:Context) : RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;(), AdapterView.OnItemClickListener, AdapterView.OnItemLongClickListener { //ä¸å°æ¯›é©´æ–‡ä»¶ç»‘å®š val inflater:LayoutInflater = LayoutInflater.from(context) override abstract fun getItemCount(): Int override abstract fun onCreateViewHolder(p0: ViewGroup, p1: Int): RecyclerView.ViewHolder override fun getItemViewType(position: Int): Int = 0 override fun getItemId(position: Int): Long = position.toLong() var itemClickListener:AdapterView.OnItemClickListener? = null fun setOnItemClickListener(listener:AdapterView.OnItemClickListener) { this.itemClickListener = listener } var itemLongClickListener: AdapterView.OnItemLongClickListener? = null fun setOnItemLongClickLostenner(listener: AdapterView.OnItemLongClickListener) { this.itemLongClickListener = listener } override fun onItemClick(parent: AdapterView&lt;*&gt;?, view: View?, position: Int, id: Long) { } override fun onItemLongClick(parent: AdapterView&lt;*&gt;?, view: View?, position: Int, id: Long): Boolean { return true }} è®¾è®¡å¥½itemçš„å°æ¯›é©´æ–‡ä»¶ï¼Œå†™å¥½ä¼ é€æ•°æ®çš„ç±» å®Œæˆä¸šåŠ¡é€»è¾‘çš„é€‚é…å™¨1234567891011121314151617181920212223class RecyclerGridAdapter(context:Context, private val infos:MutableList&lt;RecyclerInfo&gt;) : RecyclerBaseAdapter&lt;RecyclerView.ViewHolder&gt;(context) { //ç»§æ‰¿åˆšæ‰çš„åŸºç¡€ç±» override fun getItemCount(): Int = infos.size override fun onCreateViewHolder(p0: ViewGroup, p1: Int): RecyclerView.ViewHolder { val view: View = inflater.inflate(R.layout.layout ,p0, false) return ItemHoder(view) } override fun onBindViewHolder(p0: RecyclerView.ViewHolder, p1: Int) { val vh = p0 as ItemHoder vh.pic.setImageResource(infos[p1].pic) vh.text.text = infos[p1].text } inner class ItemHoder(view:View): RecyclerView.ViewHolder(view) { val ll = view.findViewById&lt;ConstraintLayout&gt;(R.id.ll) var pic = view.findViewById&lt;ImageView&gt;(R.id.pic) var text = view.findViewById&lt;TextView&gt;(R.id.text) }} ä¸ºRecyclerViewæ·»åŠ å¸ƒå±€ç®¡ç†å™¨å’Œé€‚é…å™¨12345678910111213141516171819202122232425262728293031323334353637class MainActivity : AppCompatActivity() { var l:RecyclerView? = null override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) var data:MutableList&lt;RecyclerInfo&gt; = mutableListOf() //çœç•¥ä¸ºdataèµ‹å€¼çš„ä»£ç  l = findViewById(R.id.l) l?.layoutManager = LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false) val adapter = RecyclerGridAdapter(this, data) adapter.setOnItemClickListener(adapter) adapter.setOnItemLongClickLostenner(adapter) l?.adapter = adapter l?.itemAnimator = DefaultItemAnimator() l?.addItemDecoration(SpacesItemDecoration(30)) } override fun onCreateOptionsMenu(menu: Menu?): Boolean { menu?.add(&quot;LinearLayoutManager(çº¿æ€§)&quot;) menu?.add(&quot;GridLayoutManager(ç½‘æ ¼)&quot;) menu?.add(&quot;StaggeredGridLayoutManager(ç€‘å¸ƒæµ)&quot;) return super.onCreateOptionsMenu(menu) } override fun onOptionsItemSelected(item: MenuItem?): Boolean { if (item != null) {//èœå•ä¸­é€‰æ‹©å„ç§å¸ƒå±€ when(item.title) { &quot;LinearLayoutManager(çº¿æ€§)&quot; -&gt; l?.layoutManager = LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false) &quot;GridLayoutManager(ç½‘æ ¼)&quot; -&gt; l?.layoutManager = GridLayoutManager(this, 2) &quot;StaggeredGridLayoutManager(ç€‘å¸ƒæµ)&quot; -&gt; l?.layoutManager = StaggeredGridLayoutManager(2, StaggeredGridLayoutManager.VERTICAL) else -&gt; toast(&quot;error&quot;) } } return super.onOptionsItemSelected(item) }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RecyclerView/"},{"title":"Kotlinå­¦ä¹ ç¬”è®°â€”â€”SharedPreference","text":"12#define å°æ¯›é©´ xml#define SPS SharedPreferences çŸ¥è¯†è¡¥å……æ¨¡æ¿ç±» Anyç±»â€”â€”ç›¸å½“äºjavaä¸­çš„Objectç±» &lt;*&gt;â€”â€”ç›¸å½“äºjavaä¸­çš„&lt;?&gt;è¡¨ç¤ºä¸åŒäºæ¨¡æ¿ç±»çš„T å§”æ‰˜å±æ€§å¾…è¡¥å…… lazyä¿®é¥°ç¬¦è®©å˜é‡åœ¨é¦–æ¬¡ä½¿ç”¨çš„æ—¶å€™èµ‹å€¼ ä¸lateinitçš„åŒºåˆ«ï¼š lateinitæ˜¯åœ¨åˆ›å»ºå˜é‡æ—¶ä¸èµ‹å€¼ï¼Œæƒ³ç¼–è¯‘å™¨ä¿è¯åœ¨ä½¿ç”¨ä¹‹å‰ä¼šèµ‹å€¼ï¼Œè¿™æ ·è¿™ä¸ªå˜é‡ä»ç„¶ä¼šè¢«å½“åšéç©ºå˜é‡ lazyæ˜¯åˆ›å»ºå˜é‡æ—¶â€èµ‹å€¼â€ï¼Œä½†æ˜¯çœŸæ­£èµ‹å€¼æ˜¯åœ¨é¦–æ¬¡ä½¿ç”¨çš„æ—¶å€™æ‰èµ‹å€¼ withå‡½æ•°1with(å‡½æ•°å¤´è¯­å¥){å‡½æ•°ä½“è¯­å¥} å‡½æ•°å¤´è¯­å¥å…ˆäºå‡½æ•°ä½“è¯­å¥æ‰§è¡Œï¼Œå‡½æ•°å¤´è¯­å¥ä¼šè¿”å›ä¸€ä¸ªå€¼ å‡½æ•°ä½“è¯­å¥ä¼šåœ¨å¤´è¯­å¥çš„è¿”å›å¯¹è±¡çš„å‘½åç©ºé—´ä¸­æ‰§è¡Œï¼Œä½“è¯­å¥å¯ä»¥ç›´æ¥è°ƒç”¨å¤´éƒ¨è¿”å›çš„ç±»çš„æ–¹æ³• ä½¿ç”¨åœºæ™¯SharedPreferencesæ˜¯Androidä¸­æœ€ç®€å•çš„æ•°æ®å‚¨å­˜æ–¹å¼ ä½¿ç”¨æ–¹æ³•æ–¹æ³•ä¸€è§ˆSharedPreferencesç±»çš„æ–¹æ³•ï¼ˆæ³¨æ„æœ€åæœ‰ä¸€ä¸ªsï¼‰ æ–¹æ³• å‚æ•° è§£é‡Š getSharedPreferences String + MODD åˆå§‹åŒ–ä¸€ä¸ªSPSã€‚ç¬¬ä¸€ä¸ªStringæ˜¯æ–‡ä»¶åï¼Œä¸str.xmlæ–‡ä»¶å…±äº«å‚æ•°ã€‚ç¬¬äºŒä¸ªå‚æ•°æ˜¯å‚æ•°çš„æ“ä½œæ¨¡å¼ï¼Œæ˜¯Contextç±»ä¸­çš„é™æ€å¸¸é‡ï¼ˆè¿™ä¸ªå‡½æ•°ä¸æ˜¯SPSçš„æ–¹æ³•ï¼Œæ˜¯Contextçš„ï¼Œä½†æ˜¯ä¸ºäº†æ–¹ä¾¿èµ·è§å†™åœ¨è¿™é‡Œï¼‰ getString key-value obviously getInt key-value obviously getBoolean key-value obviously getFloat key-value obviously getLong key-value obviously ç¼–å†™ä¸€ä¸ªUtilç±»123456789101112131415161718192021222324252627282930313233343536373839class SharedPreferencesUtil&lt;T&gt;(val context: Context, val name:String, val default:T) : ReadWriteProperty&lt;Any?, T&gt; { val prefs: SharedPreferences by lazy { context.getSharedPreferences(&quot;default&quot;, Context.MODE_PRIVATE) } override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T { return findPreference(name, default) } override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) { putPreference(name, value) } private fun findPreference(name:String, default: T) : T = with(prefs){ return when (default) { is Long -&gt; getLong(name, default) is String -&gt; getString(name, default) is Int -&gt; getInt(name, default) is Boolean -&gt; getBoolean(name, default) is Float -&gt; getFloat(name, default) else -&gt; throw IllegalArgumentException(&quot;Unsupport type&quot;) } as T } private fun &lt;T&gt; putPreference(name:String, value:T) = with(prefs.edit()) { when (value) { is Long -&gt; putLong(name, value) is String -&gt; putString(name, value) is Int -&gt; putInt(name, value) is Boolean -&gt; putBoolean(name, value) is Float -&gt; putFloat(name, value) else -&gt; throw IllegalArgumentException(&quot;Unsupport type&quot;) }.apply() //commitå’Œapplyéƒ½è¡¨ç¤ºæäº¤ //åº”è¯¥æ˜¯å¯¹when-elseè¯­å¥çš„è¿”å›å€¼è°ƒç”¨applyæ–¹æ³• }} ä½¿ç”¨1234var name:String by SharedPreferencesUtil(this, &quot;name&quot;, &quot;&quot;)var age:Int by SharedPreferencesUtil(this, &quot;age&quot;, 0)var marriage:Boolean by SharedPreferencesUtil(this, &quot;marriage&quot;, true)//ä»¥ä¸Šä¸‰ä¸ªå˜é‡å°±è¢«â€œæœ¬åœ°åŒ–â€ä¿å­˜äº†","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94SharedPreference/"},{"title":"Kotlinå­¦ä¹ ç¬”è®°â€”â€”Spinner","text":"androidæä¾›çš„spinner1234567891011121314151617181920212223class MainActivity : AppCompatActivity() { val strs = arrayOf(&quot;1&quot;, &quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;, &quot;6&quot;, &quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;11&quot;,&quot;12&quot;,&quot;13&quot;,&quot;14&quot;,&quot;15&quot;,&quot;16&quot;) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val sp = findViewById&lt;View&gt;(R.id.spinner) as Spinner val startAdapter = ArrayAdapter(this, R.layout.support_simple_spinner_dropdown_item, strs) startAdapter.setDropDownViewResource(R.layout.support_simple_spinner_dropdown_item) sp.prompt = &quot;è¯·é€‰æ‹©&quot; sp.adapter = startAdapter sp.setSelection(0) var listen = myItemClickListener() sp.onItemSelectedListener = listen } internal inner class myItemClickListener : AdapterView.OnItemSelectedListener { override fun onNothingSelected(parent: AdapterView&lt;*&gt;?) { } override fun onItemSelected(parent: AdapterView&lt;*&gt;?, view: View?, position: Int, id: Long) { toast(&quot;ä½ çš„é€‰æ‹©æ˜¯ï¼š${strs[position]}&quot;) } }} æ­¥éª¤ ä¸€ä¸ªArrayAdapterï¼Œå‚æ•°åˆ†åˆ«æ˜¯thisï¼ŒR.layout.support_simple_spinner_dropdown_itemï¼ŒArray&lt;String&gt;ï¼ˆåˆ°æ—¶å€™çš„itemï¼‰ åˆšæ‰çš„ArrayAdapterè®¾ç½®æ•ˆç‡è§†çª—èµ„æºï¼Œè°ƒç”¨setDropDownViewResourceå‡½æ•°ï¼Œå‚æ•°æ˜¯R.layout.support_simple_spinner_dropdown_item æŠŠArrayAdapterèµ‹å€¼ç»™spinnerçš„adapteræˆå‘˜ è®¾ç½®é»˜è®¤é€‰é¡¹ï¼ŒsetSelection å¦‚æœæƒ³è®©spinnerä¸ºå¯¹è¯æ¡†å½¢å¼çš„ï¼Œåœ¨xmlæ–‡ä»¶ä¸­è®¾ç½®android:spinnerMode=&quot;Dialog&quot;,spinnerçš„promptæˆå‘˜ä¸ºè®¾ç½®å¯¹è¯æ¡†æ ‡é¢˜çš„æ¥å£ æ–°å»ºä¸€ä¸ªå†…éƒ¨ç±»ï¼Œç›‘å¬ä¸‹æ‹‰é€‰æ‹©ï¼Œç»§æ‰¿AdapterView.OnItemSelectedListenerï¼Œé‡è½½onNothingSelectedå’ŒonItemSelectedä¸¤ä¸ªæ–¹æ³• æ–°å»ºç›‘å¬å™¨å¯¹è±¡ï¼Œé€šè¿‡spinnerçš„onItemSelectedListenerè®¾ç½®ä¸ºç›‘å¬å™¨ ankoåº“æä¾›çš„spinnerâ€”â€”selector1234567val strs = Arrayof(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)aTextView.text = &quot;å‡è£…è¿™æ˜¯ä¸€ä¸ªspinnerï¼Œå…¶å®æˆ‘æ˜¯TextView&quot;aTextView.setOnClickListener { selector(&quot;è¯·é€‰æ‹©&quot;, strs) { i -&gt; toast(&quot;ä½ çš„é€‰æ‹©æ˜¯ï¼š${strs[i]}&quot;) }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Spinner/"},{"title":"Kotlinå­¦ä¹ ç¬”è®°â€”â€”TextView","text":"æ–‡æœ¬å±æ€§è®¾ç½®å‡½æ•° æ–¹æ³• è¯´æ˜ å¤‡æ³¨ text å½“å‰æ–‡æœ¬å†…å®¹ å¯ä»¥ç›´æ¥èµ‹å€¼ï¼Œæ›´æ”¹å†…å®¹ï¼Œå¯ä»¥å½“åšå˜é‡ï¼Œè·å–å†…å®¹ textSize æ–‡æœ¬å¤§å° Floatç±»å‹ setTextColor è®¾ç½®æ–‡æœ¬é¢œè‰² ä¸Colorç±»ä¸€èµ·ä½¿ç”¨ setBackgroundColor è®¾ç½®èƒŒæ™¯è‰² ä¸Colorç±»ä¸€èµ·ä½¿ç”¨ gravity è®¾ç½®å¯¹é½æ–¹å¼ ä¸Gravityä¸€èµ·ä½¿ç”¨ï¼Œå¤šç§å¯¹é½æ–¹å¼ç”¨orè¿æ¥ ellipsize å¤šä½™æ–‡æœ¬çš„çœç•¥æ–¹å¼ ä¸TruncateAtä¸€èµ·ä½¿ç”¨ setSingleLine æ˜¯å¦å•è¡Œæ˜¾ç¤º å‚æ•°Boolean isFocusable æ˜¯å¦å¯è·å¾—ç„¦ç‚¹ å¯èµ‹å€¼ï¼Œæ›´æ”¹å±æ€§ï¼Œå¯ä»¥å–å€¼ isFocusableInTouchMode æ˜¯å¦åœ¨è§¦æ‘¸æ—¶è·å¾—ç„¦ç‚¹ å¯èµ‹å€¼ï¼Œæ›´æ”¹å±æ€§ï¼Œå¯ä»¥å–å€¼ è¡¥å……ColorColorç±»ä¸­çš„å¸¸ç”¨é™æ€æˆå‘˜ åç§° å‚æ•° ä½œç”¨ rgb ä¸‰ä¸ªrã€gã€bå€¼ è¿”å›ä¸€ä¸ªå¯¹åº”rgbçš„Colorå¯¹è±¡ å…¶ä»–é™æ€æˆå‘˜å¸¸é‡ æ—  yellowã€greenã€redã€greyç­‰å¯¹åº”é¢œè‰²çš„Colorå¯¹è±¡ GravityColorç±»ä¸­çš„å¸¸ç”¨é™æ€æˆå‘˜ åç§° ä½œç”¨ LEFT å·¦å¯¹é½ RIGHT å³å¯¹é½ CENTER å±…ä¸­ TruncateAtColorç±»ä¸­çš„å¸¸ç”¨é™æ€æˆå‘˜ åç§° ä½œç”¨ START çœç•¥å·åœ¨å¼€å¤´ MIDDLE çœç•¥å·åœ¨ä¸­é—´ END çœç•¥å·åœ¨æœ«å°¾ MARQUEE è·‘é©¬ç¯æ˜¾ç¤ºï¼Œä¸€å®šè¦è®¾ç½®ä¸ºå•è¡Œæ˜¾ç¤º ç‰¹å®šæ•ˆæœè·‘é©¬ç¯æ˜¾ç¤ºï¼Œè‡ªåŠ¨æ»šåŠ¨ï¼Œä¸éœ€è¦è·å¾—ç„¦ç‚¹ é‡è½½isFocusedå‡½æ•°ï¼Œè®©å…¶æ°¸è¿œè¿”å›trueï¼Œé»˜è®¤ä¸€ç›´åœ¨è·å¾—ç„¦ç‚¹ è®¾ç½®å•è¡Œæ˜¾ç¤º è®¾ç½®Focusable12345678910111213141516class MyTextView : TextView { init { this.gravity = Gravity.LEFT or Gravity.CENTER this.ellipsize = TextUtils.TruncateAt.MARQUEE this.setSingleLine(true) this.isFocusable = true this.isFocusableInTouchMode = true } constructor(context: Context) : super(context) constructor(context: Context, attrs: AttributeSet?) : super(context, attrs) constructor(context: Context, attrs: AttributeSet?, style: Int) : super(context, attrs, style) override fun isFocused(): Boolean { return true }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94TextView/"},{"title":"Kotlinå­¦ä¹ ç¬”è®°â€”â€”ankoåº“","text":"å¼¹å‡ºåå¸ æ–¹æ³• å‚æ•° è§£é‡Š å¤‡æ³¨ toast CharSequence å¼¹å‡ºçŸ­åå¸ ç›¸å½“äºToast.makeText(this, &quot;String&quot;, Toast.Toast.LENGTH_SHORT).show() longToast CharSequence å¼¹å‡ºé•¿åå¸ ç›¸å½“äºToast.makeText(this, &quot;String&quot;, Toast.Toast.LENGTH_LONG).show() åƒç´ è½¬æ¢æ–¹æ³• æ–¹æ³• è¯´æ˜ dip dip è½¬ px sp sp è½¬ px px2dip px è½¬ dip px2sp px è½¬ sp dimen dip è½¬ sp å¼¹å‡ºè­¦å‘Šçª—å£12345678alert(&quot;å¯¹è¯æ¡†å†…å®¹&quot;, &quot;å¯¹è¯æ¡†æ ‡é¢˜&quot;) { positiveButton(&quot;ç¡®è®¤&quot;) { //ç‚¹æŒ‰ç¡®è®¤åæ‰§è¡Œçš„æ“ä½œ } negativeButton(&quot;å–æ¶ˆ&quot;) { //ç‚¹æŒ‰å–æ¶ˆåæ‰§è¡Œçš„æ“ä½œ }}.show()","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94anko%E5%BA%93/"},{"title":"Kotlinå­¦ä¹ ç¬”è®°â€”â€”TabLayout","text":"1#define å°æ¯›é©´ xml ä½¿ç”¨åœºæ™¯å¦‚æœæƒ³è®©ViewPagerçš„tabæ ‡ç­¾å’ŒToolbaråˆäºŒä¸ºä¸€çš„è¯ï¼Œå¯ä»¥åœ¨Toolbarä¸­åµŒå¥—TabLayout ä½¿ç”¨æ–¹æ³• ç¼–å†™å¥½å°æ¯›é©´æ–‡ä»¶ï¼ŒæŠŠTabLayoutåµŒå¥—åˆ°Toolbarä¸­ï¼Œç¼–å†™å¥½æ¯ä¸€é¡µçš„å°æ¯›é©´å¸ƒå±€æ–‡ä»¶ï¼Œå†™å¥½ä¼ é€’æ•°æ®çš„ç±» ç¼–å†™Fragment1234567891011121314151617181920212223242526272829303132333435363738class BlankFragment : Fragment() { var ctx:Context? = null var mPosition:Int = 0 var mInageId:Int = 0 var mDesc:String = &quot;&quot; var title:String = &quot;&quot; override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { ctx = activity if (arguments != null) { mPosition = arguments!!.getInt(&quot;position&quot;, 0) mInageId = arguments!!.getInt(&quot;image_id&quot;, 0) mDesc = arguments!!.getString(&quot;desc&quot;) title = arguments!!.getString(&quot;title&quot;) } val view = inflater.inflate(R.layout.item, container, false) val pic:ImageView = view.findViewById(R.id.imageView) val desc:TextView = view.findViewById(R.id.textView) pic.setImageResource(mInageId) desc.text = mDesc return view } companion object { fun newInstance(position:Int, image_id:Int, desc:String, title:String) : BlankFragment { val fragment = BlankFragment() val bundle = Bundle() bundle.putInt(&quot;position&quot;, position) bundle.putInt(&quot;image_id&quot;, image_id) bundle.putString(&quot;desc&quot;, desc) bundle.putString(&quot;title&quot;, title) fragment.arguments = bundle return fragment } }} ç¼–å†™ViewPagerçš„é€‚é…å™¨1234567891011class infoPagerAdapter(val fragManger: FragmentManager, val itemList:MutableList&lt;itemInfo&gt;) : FragmentStatePagerAdapter(fragManger) { override fun getCount(): Int = itemList.size override fun getItem(p0: Int): Fragment { val item = itemList[p0] return BlankFragment.newInstance(p0, item.pic, item.desc, item.name) } override fun getPageTitle(position: Int): CharSequence? { return itemList[position].name }} ç»™ViewPageræ·»åŠ é€‚é…å™¨12345678910111213141516171819202122232425262728293031323334353637383940class the_pics : AppCompatActivity() , TabLayout.OnTabSelectedListener { override fun onTabReselected(p0: TabLayout.Tab?) {} override fun onTabUnselected(p0: TabLayout.Tab?) { } override fun onTabSelected(p0: TabLayout.Tab?) { if (p0 != null) vp.currentItem = p0.position //å¦‚æœç”¨æˆ·ç‚¹å‡»äº†æŸä¸ªæ ‡ç­¾ï¼ŒæŠŠä¸‹é¢ViewPagerä¹Ÿæ»šåŠ¨åˆ°ç›¸åº”ä½ç½® //ä»¥ä¸Šä¸‰ä¸ªé‡è½½å‡½æ•°éƒ½æ˜¯Toolbarä¸Šçš„æ ‡ç­¾äº§ç”Ÿäº‹ä»¶åç›¸åº”çš„æ“ä½œ } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_the_pics) val bar:android.support.v7.widget.Toolbar = findViewById(R.id.bar) setSupportActionBar(bar) supportActionBar?.title = &quot;&quot; bar.setNavigationOnClickListener { setResult(Activity.RESULT_OK) finish() }//è®¾ç½®Toolbarçš„è¿”å›å¯¼èˆªé”®çš„clickç›‘å¬å™¨ var data:MutableList&lt;itemInfo&gt; = mutableListOf() /*çœç•¥dataçš„èµ‹å€¼è¿‡ç¨‹*/ tab_title.addOnTabSelectedListener(this) vp.adapter = infoPagerAdapter(supportFragmentManager, data) vp.addOnPageChangeListener(object : ViewPager.SimpleOnPageChangeListener() { override fun onPageSelected(position: Int) { tab_title.getTabAt(position)!!.select()//è®©æ ‡ç­¾æ çš„ç¬¬positionä¸ªå˜æˆè¢«é€‰æ‹©çŠ¶æ€ //è¿™ä¸ªé‡è½½å‡½æ•°æ˜¯ViewPagerä¸Šæœ‰Pageçš„æ”¹å˜åè°ƒç”¨çš„å‡½æ•° } }) }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94TabLayout/"},{"title":"Kotlinå­¦ä¹ ç¬”è®°â€”â€”ViewPager","text":"1#define å°æ¯›é©´ xml ä½¿ç”¨æ–¹æ³• åœ¨æ´»åŠ¨é¡µé¢æ·»åŠ ViewPagerï¼Œå¦‚æœéœ€è¦tabæ ‡ç­¾ï¼Œåœ¨ViewPageré‡ŒåµŒå¥—PagerTabStripæˆ–PagerTitleStrip è®¾è®¡ä¼ é€æ•°æ®çš„ç±»ï¼ˆä¸€å¼ å›¾å’Œä¸€ä¸ªæ ‡é¢˜å°±è¶³å¤Ÿï¼‰ ç¼–å†™ViewPagerçš„é€‚é…å™¨12345678910111213141516171819202122232425262728293031class ImagePagerAdapter(val context: Context, val itemList:MutableList&lt;itemInfo&gt;) : PagerAdapter() { val views = mutableListOf&lt;ImageView&gt;() init { for (item in itemList) { val view = ImageView(context) //view.layoutParams = ActionBar.LayoutParams(ActionBar.LayoutParams.MATCH_PARENT, ActionBar.LayoutParams.WRAP_CONTENT) view.layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT) view.setImageResource(item.pic) view.scaleType = ImageView.ScaleType.FIT_CENTER views.add(view) } } override fun isViewFromObject(p0: View, p1: Any): Boolean = (p0 === p1) override fun getCount(): Int = views.size override fun destroyItem(container: ViewGroup, position: Int, `object`: Any) { container.removeView(views[position]) } override fun instantiateItem(container: ViewGroup, position: Int): Any { container.addView(views[position]) return views[position] } override fun getPageTitle(position: Int): CharSequence? { return itemList[position].desc }//ä¸PagerTabStripæˆ–é…åˆä½¿ç”¨} ç»™PagerViewæ·»åŠ é€‚é…å™¨å’Œé¡µé¢æ”¹å˜çš„Listener123456789101112131415161718192021222324252627282930313233class MainActivity : AppCompatActivity(), ViewPager.OnPageChangeListener { override fun onPageScrollStateChanged(p0: Int) { } override fun onPageScrolled(p0: Int, p1: Float, p2: Int) { } override fun onPageSelected(p0: Int) { Toast.makeText(this, p0.toString(), Toast.LENGTH_SHORT).show() } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) //supportActionBar?.hide() var vp:ViewPager = findViewById(R.id.vp) val pics = arrayOf(R.mipmap.basic, R.mipmap.close, R.mipmap.debug, R.mipmap.edit) val list:MutableList&lt;itemInfo&gt; = mutableListOf() for (i in pics.indices) { list.add(itemInfo((i+1).toString(), pics[i])) } vp.adapter = ImagePagerAdapter(this, list) vp.currentItem = 0 vp.addOnPageChangeListener(this) var title: PagerTabStrip = findViewById(R.id.title) title.setTextSize(TypedValue.COMPLEX_UNIT_SP, 20f) title.setTextColor(Color.RED) }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94ViewPager/"},{"title":"Kotlinå­¦ä¹ ç¬”è®°â€”â€”åŸºç¡€è¯­æ³•ç¯‡ä¹‹æ§åˆ¶è¯­å¥","text":"ifâ€¦elseâ€¦ç”¨æ³•Kotlinä¸­if...else...åŸºæœ¬ç”¨æ³•ä¸C/C++ï¼Œjavaä¸­ç›¸åŒ ä¾‹å­12345678button.setOnClickListener { if (flag) { text.text = &quot;I love you, at the first sight of you.&quot; } else { text.text = &quot;I love three things in this world.Sun, moon and you. &quot; + &quot;Sun for morning, moon for night, and you forever.&quot; }} è€ŒKotlinçš„if elseå¯ä»¥æœ‰è¿”å›å€¼ ä¾‹å­12345678button.setOnClickListener { text.text = if (flag) { &quot;I love you, at the first sight of you.&quot; } else { &quot;I love three things in this world.Sun, moon and you. &quot; + &quot;Sun for morning, moon for night, and you forever.&quot; }} Kotlinä¸­æ²¡æœ‰javaï¼ŒC/C++çš„ä¸‰ç›®è¿ç®—ç¬¦ï¼Œä½†æ˜¯å¯ä»¥ç”¨ifâ€¦elseâ€¦å–ä»£ ä¾‹å­1234567button.setOnClickListener { text.text = if (flag) (16).toString() else (153.6).toString() /* åƒæäº†ä¸‰ç›®å…ƒç®—ç¬¦ï¼š(å‡è£…è¿™é‡Œæ˜¯C/C++æˆ–java) text.text = flag ? (16).toString() : (153.6).toString(); */} whenâ€¦elseâ€¦ç”¨æ³•Kotlinä¸­çš„when...else...å¤šè·¯åˆ†æ”¯ç›¸å½“äºC/C++ï¼Œjavaä¸­çš„switch...case...ï¼Œä½†æ˜¯ç”¨æ³•ç¨æœ‰ä¸åŒ Kotlinçš„when...else...å’ŒKotlinçš„if...else...ä¸€æ ·ï¼Œå…è®¸æœ‰è¿”å›å€¼ Kotlinçš„when...else...å„ä¸ªåˆ†æ”¯ä¸­ï¼Œå¯ä»¥ä¸æ˜¯å¸¸é‡ï¼Œå˜é‡ä¹Ÿå¯ä»¥ Kotlinçš„when...else...ä¸ç”¨å†™breakï¼Œæ¯ä¸ªåˆ†æ”¯ç»“æŸåè‡ªåŠ¨é€€å‡ºwhen...else...è¯­å¥å— ä¾‹å­123456789button.setOnClickListener { text.text = when(type) { 1,2,3 -&gt; &quot;I love you, at the first sight of you.&quot;//å¤šä¸ªå€¼èµ°åŒä¸€ä¸ªåˆ†æ”¯ï¼Œç”¨é€—å·éš”å¼€ in 4..10 -&gt; &quot;I love three things in this world.Sun, moon and you. &quot; + &quot;Sun for morning, moon for night, and you forever.&quot;//è¡¨ç¤ºåœ¨4åˆ°10ä¹‹é—´ !in 1..10 -&gt; &quot;We don't talk anymore.&quot;//è¡¨ç¤ºä¸åœ¨1åˆ°10ä¹‹é—´ else -&gt; &quot;error&quot; }} å¾ªç¯forå¾ªç¯Kotlinå±…ç„¶å–æ¶ˆäº†å¸¸è§çš„forå¾ªç¯ï¼Œtmd éå†å¾ªç¯1. for-inå¾ªç¯ç±»ä¼¼C++/javaä¸­çš„for_eachå½¢å¼çš„å¾ªç¯ï¼Œå¯ä»¥å¯¹å­—ç¬¦ä¸²ã€æ•°ç»„ã€Array&lt;&gt;, é˜Ÿåˆ—ã€æ˜ å°„ã€é›†åˆè¿›è¡Œéå† ä¾‹å­123456btn.setOnClickListener { var str:String = &quot;0123456789&quot; for (item in str) {//itemè‡ªåŠ¨ç±»å‹æ¨æ–­ Toast.makeText(this, &quot;${item}&quot;, Toast.Toast.LENGTH_SHORT).show() }} ä¾‹å­(ä¸‹æ ‡æ•°ç»„éå†)123456btn.setOnClickListener { var str:String = &quot;0123456789&quot; for (i in str.indices) {//indicesæ˜¯ä¸‹æ ‡æ•°ç»„ Toast.makeText(this, &quot;${str[i]}&quot;, Toast.Toast.LENGTH_SHORT).show() }} æ¡ä»¶å¾ªç¯æ ¼å¼123456for(i in 11 until 66) {}//å·¦é—­å³å¼€åŒºé—´ï¼Œ[11,66)for (i in 23..89 step 4) {}//æ¯æ¬¡å¾ªç¯ï¼Œi += 4ï¼Œå¦‚æœæ¡ä»¶å…è®¸ï¼Œå¯ä»¥åˆ°89for (i in 50 downTo 7) {}//ä»50 é€’å‡åˆ° 7 whileå¾ªç¯ç”¨æ³•åŒjava/C/C++ do-whileå¾ªç¯ç”¨æ³•åŒjava/C/C++ è·³å‡ºå¤šé‡å¾ªç¯å’Œjavaç±»ä¼¼ï¼Œå¦‚æœæƒ³ä¸€æ¬¡æ€§è·³å‡ºå¤šä¸ªå¾ªç¯ï¼Œå¯ä»¥åœ¨å¾ªç¯å¤–é¢åŠ â€æ ‡ç­¾â€ ä¾‹å­123456789101112var i:Int = 0var j:Int = 0@outside while (i &lt;= 10) { j = 10; while (i * j != 50) { j-- if (j == 0) { break@outside } } i++}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87%E4%B9%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"},{"title":"Kotlinå­¦ä¹ ç¬”è®°â€”â€”åŸºç¡€è¯­æ³•ç¯‡ä¹‹æ•°æ®ç±»å‹","text":"ä¸€ã€åŸºæœ¬æ•°æ®ç±»å‹Kotlinçš„æ•°æ®ç±»å‹ æ•°æ®ç±»å‹åç§° Kotlinçš„æ•°æ®ç±»å‹ æ•´å‹ Int é•¿æ•´å‹ Long æµ®ç‚¹å‹ Float åŒç²¾åº¦æµ®ç‚¹å‹ Double å¸ƒå°”å‹ Boolean å£°æ˜å˜é‡1234567891011var integer:Int//ä¸€èˆ¬ç”¨æ³•var/val + æ ‡è¯†ç¬¦ + : + ç±»å‹åï¼Œvarè¡¨ç¤ºå˜é‡val integer1:Int = 0//valè¡¨ç¤ºå¸¸é‡ï¼Œç›¸å½“äºjavaä¸­çš„finalï¼Œc++ä¸­çš„constvar str = &quot;this is a string&quot;//æ²¡æœ‰&quot;:String&quot;ï¼Œæ­¤æ—¶åªè¦ä¿è¯ç¼–è¯‘å™¨å¯ä»¥çŸ¥é“å˜é‡çš„ç±»å‹ï¼Œåˆ™ç¼–è¯‘å™¨å¯ä»¥å®Œæˆç±»å‹æ¨æ–­var flt:Float = 5f//fè¡¨ç¤ºæ•°æ®ä¸ºfloatç±»å‹var tobar:Toolbar? = findViewById&lt;Toolbar&gt;(R.id.toolbar)/*ç±»å‹åå+'?'è¡¨ç¤ºè¯¥å˜é‡ä¸ºå¯ç©ºå˜é‡ï¼Œkotlinä¸ºäº†é˜²æ­¢javaä¸­NullPointerExceptionï¼Œé»˜è®¤æ‰€æœ‰çš„å˜é‡éƒ½æ˜¯ä¸å¯ç©ºï¼ˆä¸èƒ½ä¸ºnullçš„ï¼‰ï¼Œå¦‚æœè¦è®©å˜é‡ä¸ºç©ºï¼Œéœ€è¦+'?'ï¼Œæ­¤æ—¶ï¼Œç¼–è¯‘å™¨ä¼šå¼ºåˆ¶ç¨‹åºå‘˜å¯¹æ‰€æœ‰å¯ç©ºå˜é‡è¿›è¡Œéç©ºåˆ¤æ–­*/ Kotlinçš„ç±»å‹è½¬æ¢å¼ºåˆ¶ç±»å‹è½¬æ¢12var double:Double = 16.0val dbl2Int:Int = (double as Int) æ•°æ®è½¬æ¢å‡½æ•°åœ¨kotlinçš„ä¸–ç•Œä¸­ï¼Œä¸€åˆ‡éƒ½æ˜¯ç±»å’Œå¯¹è±¡ï¼ŒåŸºæœ¬æ•°æ®ç±»å‹ä¹Ÿæ˜¯ï¼Œå…¶ä¸­ç”¨äºæ•°æ®è½¬æ¢çš„æˆå‘˜å‡½æ•° Kotlinçš„æ•°æ®ç±»å‹è½¬æ¢å‡½æ•° toInt toLong toFloat toDouble toChar toString äºŒã€å­—ç¬¦ä¸²å­—ç¬¦ä¸²ä¸å…¶ä»–åŸºæœ¬æ•°æ®ç±»å‹è½¬æ¢ Stringçš„æˆå‘˜å‡½æ•° å¤‡æ³¨ toInt toLong toFloat toDouble toBoolean toCharArray è¿”å›çš„æ˜¯CharArrayä¸æ˜¯Array&lt;Char&gt; å­—ç¬¦ä¸²çš„å¸¸ç”¨æ–¹æ³• Stringçš„æˆå‘˜å‡½æ•° è§£é‡Š indexOf æŸ¥æ‰¾å­ä¸² substring è·å–å­ä¸² replace æ›¿æ¢å­ä¸² split æŒ‰ç‰¹å®šå­—ç¬¦åˆ†éš”å­ä¸²ï¼Œè¿”å›å€¼æ˜¯List&lt;String&gt; å­—ç¬¦ä¸²æ‹¼æ¥12345678val str1:String = &quot;æˆ‘åˆ˜æ™¯å¤©å®‡å®™ç¬¬ä¸€å¸…ï¼&quot;val integer:Int = 8848val text:TextView = findViewById&lt;TextView&gt;(R.id.text)val strCat:String = &quot;str1 = ${str1} integer = $integer, å½“å‰textä¸­æ˜¾ç¤ºçš„å†…å®¹æ˜¯ï¼š${text.text}&quot;/*$å˜é‡å${è¡¨è¾¾å¼}*/ ä¸‰ã€æ•°ç»„Kotlinçš„æ•°ç»„ç±»å‹ æ•°ç»„åç§° åˆå§‹åŒ–æ–¹æ³• æ•°ç»„åç§° åˆå§‹åŒ–æ–¹æ³• IntArray intArrayOf Array&lt;Int&gt; ArrayOf LongArray longArrayOf Array&lt;Long&gt; ArrayOf FloatArray floatArrayOf Array&lt;Float&gt; ArrayOf DoubleArray doubleArrayOf Array&lt;Double&gt; ArrayOf BooleanArray booleanArrayOf Array&lt;Boolean&gt; ArrayOf CharArray charArrayOf Array&lt;Char&gt; ArrayOf null null Array&lt;String&gt; ArrayOf æ•°ç»„å¸¸ç”¨æ–¹æ³• æˆå‘˜ è§£é‡Š size æ•°ç»„é•¿åº¦ get(index) è·å–å…ƒç´  set(index, value) ä¿®æ”¹å…ƒç´ å€¼ ps:kotlinä¹Ÿå¯ä»¥é€šè¿‡ä¸‹æ ‡å¼•ç”¨å…ƒç´ å’Œä¿®æ”¹å…ƒç´  å››ã€å®¹å™¨Kotlinçš„å®¹å™¨ Kotlinå®¹å™¨ åç§° åˆå§‹åŒ–æ–¹æ³• åªè¯»é›†åˆ Set setOf å¯å˜é›†åˆ MutableSet mutableSetOf åªè¯»é˜Ÿåˆ— Set listOf å¯å˜é˜Ÿåˆ— MutableSet mutableListOf åªè¯»æ˜ å°„ Set mapOf å¯å˜æ˜ å°„ MutableSet mutableMapOf å®¹å™¨çš„é€šç”¨å¸¸ç”¨æ–¹æ³• æ–¹æ³•å è¿”å›å€¼ è§£é‡Š isEmpty() Boolean åˆ¤æ–­æ˜¯å¦ä¸ºç©º isNotEmpty() Boolean åˆ¤æ–­æ˜¯å¦ä¸ºéç©º clear() Unitï¼ˆçŒœæµ‹ï¼‰ æ¸…ç©ºå®¹å™¨ï¼ˆæ‰¾ä¸åˆ°è¿™ä¸ªæ–¹æ³•ï¼‰ contains(value) Boolean æŸ¥æ‰¾æœ‰æ²¡æœ‰è¿™ä¸ªå…ƒç´  iterator() å¯¹åº”çš„è¿­ä»£å™¨ è¿”å›å®¹å™¨çš„è¿­ä»£å™¨ count() Int è·å–å…ƒç´ ä¸ªæ•° size Int è·å–å…ƒç´ ä¸ªæ•° ps:åªè¯»å®¹å™¨åˆå§‹åŒ–åå°±ä¸å¯æ›´æ”¹äº† å®¹å™¨çš„è¿­ä»£å™¨çš„å¸¸ç”¨æ–¹æ³• æ–¹æ³•å è§£é‡Š hasNext() ç±»ä¼¼javaçš„Scannerçš„hasNextæ–¹æ³• next() ç±»ä¼¼javaçš„Scannerçš„Nextæ–¹æ³• é›†åˆKotliné›†åˆçš„ç‰¹æ€§ é›†åˆå†…éƒ¨å…ƒç´ ä¸æŒ‰ç…§é¡ºåºæ’åˆ—ï¼Œæ— æ³•ä¸‹æ ‡è®¿é—® é›†åˆå†…éƒ¨å…ƒç´ å…·æœ‰å”¯ä¸€æ€§ MutableSetçš„å…ƒç´ å˜æ›´æ–¹æ³• æ–¹æ³• è§£é‡Š add(element) æ·»åŠ å…ƒç´  remove(element) ç§»é™¤æŸä¸ªå…ƒç´  æ˜ å°„åˆå§‹åŒ–æ–¹æ³•123456var map1:map&lt;String, int&gt; = mapOf(&quot;1&quot; to 1, &quot;2&quot; to 2, &quot;3&quot; to 3)var map2:mutableMap&lt;String, Boolean&gt; = mutableMapOf(Pair(&quot;a&quot;, true), Pair(&quot;b&quot;, false))/*ä¸è®ºæ˜¯mapè¿˜æ˜¯mutableMapï¼Œéƒ½å¯ä»¥ä½¿ç”¨ key to valueå’ŒPair(Key, Value)*/ Mapå’ŒMutableMapçš„å¸¸ç”¨æ–¹æ³• æ–¹æ³• è¿”å›å€¼ è§£é‡Š Map MutableMap containsKey(key) Boolean åˆ¤æ–­æ˜¯å¦æœ‰æŒ‡å®šé”®çš„å…ƒç´  âˆš âˆš containsValue(value) Boolean åˆ¤æ–­æ˜¯å¦æœ‰æŒ‡å®šå€¼çš„å…ƒç´  âˆš âˆš put(key, value) String? æ·»åŠ å…ƒç´  Ã— âˆš remove(key) String? ç§»é™¤å…ƒç´  Ã— âˆš remove(keyï¼Œ value) Boolean ç§»é™¤å…ƒç´  Ã— âˆš é˜Ÿåˆ—é˜Ÿåˆ—çš„å¸¸ç”¨æ–¹æ³• æ–¹æ³• è¿”å›å€¼ è§£é‡Š List MutableList get(index) ElementType è¿”å›å¯¹åº”ä½ç½®çš„å…ƒç´  âˆš âˆš [index] ElementType ä¸‹æ ‡è¿ç®— âˆš âˆš add(element) Unit å‘é˜Ÿå°¾æ·»åŠ å…ƒç´  Ã— âˆš set(index, element) ElementType ä¿®æ”¹æŒ‡å®šä½ç½®çš„å…ƒç´  Ã— âˆš removeAt(index) Int ç§»é™¤æŒ‡å®šä½ç½®çš„å…ƒç´  Ã— âˆš sortBy{æ’åºæ¡ä»¶} Unit æŒ‰ç…§æ’åºæ¡ä»¶å‡åºæ’åˆ— Ã— âˆš sortByDescending{æ’åºæ¡ä»¶} Unit æŒ‰ç…§æ’åºæ¡ä»¶é™åºæ’åˆ— Ã— âˆš sort() Unit æ’åº Ã— âˆš äº”ã€ç±»å‹åˆ¤æ–­ä¾‹å­12345if (varable is String) { //Do somethingï¼Œ} else if (varable is Int) { //or you will do something} ä¾‹å­12345when (varable) { is String -&gt; //Do something is Int -&gt; //or you will do something else -&gt; //nothing} å…­ã€ç©ºå®‰å…¨1234567891011121314var i:Int = 0//Kotliné»˜è®¤çš„å˜é‡æ˜¯ä¸å¯ä¸ºç©º(null)çš„var str:String? = null//å¦‚æœæƒ³è®©ä¸€ä¸ªå˜é‡ä¸ºç©ºï¼Œè¦åœ¨ç±»å‹ååé¢åŠ '?'i = str?.length //å¯ç©ºå˜é‡åœ¨è°ƒç”¨æ–¹æ³•æ—¶ï¼Œåœ¨åé¢åŠ ä¸Š'?'ï¼Œä¸€æ—¦å¯ç©ºå˜é‡strçš„å€¼ä¸ºç©ºï¼Œè¿”å›nulltry { i = str!!.length} catch(e: Exception) { Toast.makeText(this, &quot;é‡åˆ°${e}é”™è¯¯&quot;, Toast.LENGTH_SHORT).show()}//å¯ç©ºå˜é‡åŠ !!ï¼Œè¡¨ç¤ºå¦‚æœä¸ºç©ºï¼ŒæŠ›å‡ºå¼‚å¸¸i = str?.length : -1//è¡¨ç¤ºå¦‚æœsträ¸ºç©ºï¼Œåˆ™å€¼ä¸º0","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"Kotlinå­¦ä¹ ç¬”è®°â€”â€”åŸºç¡€è¯­æ³•ç¯‡ä¹‹å‡½æ•°","text":"å‡½æ•°çš„ä¸€èˆ¬å½¢å¼12345fun mathodName(/*para list*/) : String/*return value type*/ { /* function body */} ä¸Cã€C++æˆ–javaçš„ä¸åŒ å¦‚æœè¦é‡è½½ï¼Œåœ¨funå‰é¢åŠ override å¦‚æœæƒ³è®©å­ç±»é‡è½½ï¼Œè¦åŠ openå…³é”®è¯ï¼ˆç±»ä¹Ÿä¸€æ ·ï¼‰ å¯ä»¥å®šä¹‰å…¨å±€å‡½æ•°ï¼Œå‡½æ•°ä¸æ˜¯å¿…é¡»å†™åœ¨ç±»é‡Œ å¯ä»¥æœ‰é»˜è®¤å‚æ•°ï¼Œä¸”é»˜è®¤å‚æ•°ä¸å¿…æ”¾åœ¨æœ€åå‡ ä¸ª123456789101112fun TextView.println(str:CharSequence) { append(&quot;\\n${str}&quot;)}fun TextView.print(str:CharSequence) { append(str)}//è¿™ä¸ªä¸œè¥¿æ˜¯æ‰©å±•å‡½æ•°ï¼Œåé¢è¯´fun func(str:String = &quot;å“ˆå“ˆå“ˆ&quot;,i:Int, j:Double) {//strçš„é»˜è®¤å‚æ•°&quot;å“ˆå“ˆå“ˆ&quot; val text:TextView = findViewById(R.id.text) text.print(&quot;$str&quot;) text.println(&quot;$i&quot;) text.println(&quot;$j&quot;)} æ­¤æ—¶ï¼Œåœ¨è°ƒç”¨æ—¶ï¼Œå¦‚æœç¬¬ä¸€ä¸ªä¸é‡‡ç”¨é»˜è®¤å‚æ•°ï¼Œåˆ™æŒ‰ç…§é¡ºåºä¼ é€’ä¸‰ä¸ªå‚æ•°ï¼Œå¦åˆ™æŒ‰ç…§ä»¥ä¸‹å½¢å¼ä¼ é€’å‚æ•°1func(i = 10, j = 20.5) å¯å˜å‚æ•°ï¼Œåœ¨å‚æ•°åˆ—è¡¨ä¸­ï¼Œå‚æ•°åç§°å‰ç”¨varargï¼ˆvar = varable, arg = å‚æ•°ï¼‰ä¿®é¥°1234567fun appendString(tag:String, vararg info:String?) : String { var str:String = &quot;${tag}&quot; for (item in info) { str = &quot;${str}\\n${item}&quot; } return str} Kotlinçš„ç‰¹æ®Šå‡½æ•°æ³›å‹å‡½æ•°/å†…è”å‡½æ•°ä¾‹å­1234567fun&lt;T&gt; appendString(tag:String, vararg info:T?) : String { var str:String = &quot;${tag}&quot; for (item in info) { str = &quot;${str}\\n${item.toString()}&quot; } return str} åœ¨funåé¢åŠ å…¥&lt;æ³›å‹åˆ—è¡¨&gt;,è¡¨ç¤ºæ³›å‹å‡½æ•° è°ƒç”¨æ–¹æ³•123btn.setOnClickListener { text.text = appendString&lt;Int&gt;(&quot;è½¬åŒ–&quot;, 1,2,3,4,5,6,7,8,9)} æ³¨æ„ åªæœ‰æ³›å‹ç±»æ‰æ‹¥æœ‰æˆå‘˜æ³›å‹å‡½æ•°ï¼Œæˆ–è€…å¯ä»¥æŠŠæ³›å‹å‡½æ•°ä½œä¸ºå…¨å±€å‡½æ•° Kotlinæ˜¯å¼ºç±»å‹çš„è¯­è¨€ï¼Œå¦‚æœéœ€è¦å³ä¼ é€’Numberç±»ç»§æ‰¿çš„ç±»å¯¹è±¡ï¼Œè€Œä¸ç»§æ‰¿å…¶ä»–ç±»å¯¹è±¡ï¼Œä¸èƒ½å†™&lt;Number&gt; è¦å†™æˆ&lt;reified T : Number&gt;,è¿™ä¸ªå†™æ³•ç­‰ä»·äºjavaçš„&lt;T extends Number&gt; ç®€åŒ–å‡½æ•°Kotlinä¸­ï¼Œå‡½æ•°çš„å®šä¹‰å½¢å¼å’Œå˜é‡ååˆ†ç›¸ä¼¼ï¼Œè¿™æ˜¯å› ä¸ºå‡½æ•°ä¹Ÿæ˜¯ä¸€ç§ç‰¹æ®Šå˜é‡ï¼Œå¯ä»¥å¯¹ä»–èµ‹å€¼ ä¾‹å­1fun factorial(n:Int):Int = if(n &lt;= 1) n else n*factorial(n-1) å°¾é€’å½’å‡½æ•°åœ¨funä¹‹å‰åŠ ä¸Šå…³é”®å­—tailrec(tailâ€”â€”å°¾å·´ï¼Œrecâ€”â€”ä¸çŸ¥é“)ï¼Œå‘Šè¯‰ç¼–è¯‘å™¨è¿™æ˜¯ä¸€ä¸ªå°¾é€’å½’å‡½æ•°ï¼Œç¼–è¯‘å™¨å¯ä»¥è‡ªåŠ¨ä¼˜åŒ–æˆå¾ªç¯ ä¾‹å­12tailrec fun findFixPoint(x:Double = 1.0) : Double = if (x == Math.cos(x)) x else findFixPoint(Math.cos(x)) é«˜é˜¶å‡½æ•°ä¼ å…¥çš„å‚æ•°æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œä¸ªäººè®¤ä¸ºç›¸å½“äºC/C++çš„å‡½æ•°æŒ‡é’ˆï¼Œæˆ–è€…è¯´ä¼ é€’äº†ä¸€ä¸ªå‡½æ•°å˜é‡ ä¾‹å­1234567891011121314fun&lt;T&gt; maxCustom(array:Array&lt;T&gt;, greater:(T,T) -&gt; Boolean) : T? { /* è¿™ä¸ªåœ°æ–¹ greater(T, T) -&gt; Boolean è¡¨ç¤ºä¸€ä¸ªå‡½æ•°åä¸ºgreaterï¼Œå‚æ•°ä¸ºä¸¤ä¸ªTç±»å‹ï¼Œè¿”å›å€¼çš„Booleançš„å‡½æ•° */ var max:T? = null for (item in array) { if (max == null || greater(item, max)) { max = item } } return max} è°ƒç”¨1234val arr:Array&lt;Int&gt; = arrayOf(1,2,3)btn.setOnClickListener { text.text = &quot;æœ€å¤§å€¼ä¸º${maxCustom&lt;Int&gt;(arr, {a,b -&gt; a &gt; b}).toString()}&quot;}//ä½¿ç”¨lambadè¡¨è¾¾å¼ ç³»ç»Ÿå¢å¼ºå‡½æ•°æ‰©å±•å‡½æ•°å¯ä»¥ç»™å·²æœ‰çš„ç±»ä¸­æ·»åŠ å‡½æ•°ï¼Œä½œä¸ºæˆå‘˜å‡½æ•° ä¾‹å­123456fun TextView.println(str:CharSequence) { append(&quot;${str}\\n&quot;)}fun TextView.print(str:CharSequence) { append(str)} è°ƒç”¨å’Œæ­£å¸¸æˆå‘˜å‡½æ•°ä¸€æ ·è°ƒç”¨ 123456val text:TextView = findViewById(R.id.text)val btn:Button = findViewById(R.id.btn)btn.setOnClickListener { text.println(&quot;123&quot;) text.print(&quot;demo&quot;)} å•ä¾‹å¯¹è±¡ç”¨objectæ›¿æ¢classï¼Œè¿™æ ·å…¶ä¸­çš„æ‰€æœ‰å‡½æ•°éƒ½æ˜¯é™æ€æˆå‘˜å‡½æ•°äº† ç›¸å½“äºstaticä¿®é¥°ç¬¦","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87%E4%B9%8B%E5%87%BD%E6%95%B0/"},{"title":"å®ä¹ ç¬”è®°-24","text":"è®¾å¤‡åˆ°è®¾å¤‡æ–‡ä»¶ä¼ è¾“å¦‚æœæ‚¨çš„åº”ç”¨ä»¥ Android 11 æˆ–æ›´é«˜ç‰ˆæœ¬ä¸ºç›®æ ‡å¹³å°ï¼Œæ‚¨å°†æ— æ³•ä½¿ç”¨ allowBackup å±æ€§åœç”¨åº”ç”¨æ–‡ä»¶çš„è®¾å¤‡åˆ°è®¾å¤‡è¿ç§»ã€‚ç³»ç»Ÿä¼šè‡ªåŠ¨å¯ç”¨æ­¤åŠŸèƒ½ã€‚ ä¸è¿‡ï¼Œå³ä½¿æ‚¨çš„åº”ç”¨ä»¥ Android 11 æˆ–æ›´é«˜ç‰ˆæœ¬ä¸ºç›®æ ‡å¹³å°ï¼Œæ‚¨ä¹Ÿå¯ä»¥é€šè¿‡å°† allowBackup å±æ€§è®¾ä¸º false æ¥åœç”¨åº”ç”¨æ–‡ä»¶çš„äº‘ç«¯å¤‡ä»½å’Œæ¢å¤ã€‚ é SDK æ¥å£é™åˆ¶ç›¸æœºåª’ä½“ intent æ“ä½œéœ€è¦ç³»ç»Ÿé»˜è®¤ç›¸æœºä» Android 11 å¼€å§‹ï¼Œåªæœ‰é¢„è£…çš„ç³»ç»Ÿç›¸æœºåº”ç”¨å¯ä»¥å“åº”ä»¥ä¸‹ intent æ“ä½œï¼š android.media.action.VIDEO_CAPTUREandroid.media.action.IMAGE_CAPTUREandroid.media.action.IMAGE_CAPTURE_SECUREå¦‚æœæœ‰å¤šä¸ªé¢„è£…çš„ç³»ç»Ÿç›¸æœºåº”ç”¨å¯ç”¨ï¼Œç³»ç»Ÿä¼šæ˜¾ç¤ºä¸€ä¸ªå¯¹è¯æ¡†ï¼Œä¾›ç”¨æˆ·é€‰æ‹©åº”ç”¨ã€‚å¦‚æœæ‚¨å¸Œæœ›è‡ªå·±çš„åº”ç”¨ä½¿ç”¨ç‰¹å®šçš„ç¬¬ä¸‰æ–¹ç›¸æœºåº”ç”¨æ¥ä»£è¡¨å…¶æ•è·å›¾ç‰‡æˆ–è§†é¢‘ï¼Œå¯ä»¥é€šè¿‡ä¸º intent è®¾ç½®è½¯ä»¶åŒ…åç§°æˆ–ç»„ä»¶æ¥ä½¿è¿™äº› intent å˜å¾—æ˜ç¡®ã€‚ åº”ç”¨æ‰“åŒ…å’Œå®‰è£…ç°åœ¨è¿˜å¿…é¡»ä½¿ç”¨ APK ç­¾åæ–¹æ¡ˆ v2 æˆ–æ›´é«˜ç‰ˆæœ¬è¿›è¡Œç­¾å Toastopen fun setView(view: View!): Unit Deprecated: Custom toast views are deprecated. Apps can create a standard text toast with the Custom toast views are deprecated. ä»¥ Android 11 æˆ–æ›´é«˜ç‰ˆæœ¬ä¸ºç›®æ ‡å¹³å°çš„åº”ç”¨ä¼šå‘ç°æ–‡æœ¬æ¶ˆæ¯æ¡†å—åˆ°ä»¥ä¸‹è´Ÿé¢å½±å“ï¼š getView() æ–¹æ³•è¿”å› nullã€‚ ä»¥ä¸‹æ–¹æ³•çš„è¿”å›å€¼å¹¶ä¸åæ˜ å®é™…å€¼ï¼Œå› æ­¤æ‚¨ä¸åº”åœ¨åº”ç”¨ä¸­ä¾èµ–äºå®ƒä»¬ï¼š getHorizontalMargin() getVerticalMargin() getGravity() getXOffset() getYOffset() ä»¥ä¸‹æ–¹æ³•æ˜¯ç©ºæ“ä½œï¼Œå› æ­¤æ‚¨çš„åº”ç”¨ä¸åº”ä½¿ç”¨å®ƒä»¬ï¼š setMargin() setGravity()","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%89%E5%8D%9311%E6%96%B0%E7%89%B9%E6%80%A7/"},{"title":"Kotlinå­¦ä¹ ç¬”è®°â€”â€”lambda","text":"å‚è€ƒæ–‡çŒ®â€”â€”kotlinä¹‹Lambdaç¼–ç¨‹æ¥è‡ªç®€ä¹¦ä½œè€…â€”â€”ç¨‹è‡ªèˆŸ Kotlin lambdaè¯­æ³•12345678910111213btn.setOnClickListener ((View v) -&gt; { toast(&quot;click&quot;)})btn.setOnclickListener { toast(&quot;click&quot;)}btn.setOnLongClickListener { toast(&quot;Long Click&quot;) true//lambddaçš„è¿”å›å€¼ï¼Œä¸å†™return}{a:Int, b:String -&gt; String (a + b.toDouble()).toString()} å®Œæ•´å†™æ³•123456789{a:Int, b:String, c:Long/*è¾“å…¥å‚æ•°åˆ—è¡¨*/ -&gt; String/*è¿”å›å€¼ç±»å‹*/ /*lambda body*/ var temp:Double = a + b.toDouble() if (c == 0L) { &quot;error&quot; } else { (temp.toDouble() + c).toString() }//è¿”å›å€¼(ä¸è¦å†™return)} çœç•¥å‚æ•°çš„å†™æ³•12345{ /* lambda body */} lambdaçš„ä½¿ç”¨ ä½œä¸ºé«˜é˜¶å‡½æ•°çš„å‚æ•°ï¼Œæ¯”å¦‚setOnclickListenerï¼ŒListçš„sortç³»åˆ—å‡½æ•° è°ƒç”¨runæ–¹æ³•1run { toast(&quot;run&quot;) } Lambdaè¡¨è¾¾å¼ä¹Ÿå¯ä»¥ä¼ é€’ç»™ä¸€ä¸ªé«˜é˜¶å‡½æ•°å½“åšå‚æ•°,å› æ­¤ä¸Šè¿°ä»£ç ä¸­1view.setOnClickListener({v -&gt; viewClicked(v) }) åœ¨ Kotlin ä¸­æœ‰ä¸€ä¸ªçº¦å®šï¼Œå¦‚æœå‡½æ•°çš„æœ€åä¸€ä¸ªå‚æ•°æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå¹¶ä¸”ä½ ä¼ é€’ä¸€ä¸ª lambda è¡¨è¾¾å¼ä½œä¸ºç›¸åº”çš„å‚æ•°ï¼Œä½ å¯ä»¥åœ¨åœ†æ‹¬å·ä¹‹å¤–æŒ‡å®šå®ƒå› æ­¤å¯ä»¥å®ç°å¦‚ä¸‹1view.setOnClickListener() {v -&gt; viewClicked(v) } åœ¨ Kotlinä¸­è¿˜æœ‰å¦å¤–ä¸€ä¸ªçº¦å®šï¼Œå¦‚æœä¸€ä¸ªå‡½æ•°çš„å‚æ•°åªæœ‰ä¸€ä¸ªï¼Œå¹¶ä¸”å‚æ•°ä¹Ÿæ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œé‚£ä¹ˆå¯ä»¥çœç•¥åœ†æ‹¬å·1view.setOnClickListener{v -&gt; viewClicked(v) } ä½¿ç”¨é»˜è®¤å‚æ•°åç§°ï¼ˆæ³¨æ„ï¼‰12//ä½¿ç”¨é»˜è®¤å‚æ•°åç§°people.maxBy { it.age} //&quot;it&quot;æ˜¯è‡ªåŠ¨ç”Ÿæˆçš„å‚æ•°åç§° é»˜è®¤åç§°itåªä¼šåœ¨å®å‚åç§°æ²¡æœ‰æ˜¾ç¤ºçš„æŒ‡å®šæ—¶å€™æ‰ä¼šç”Ÿæˆã€‚itèƒ½å¤§å¤§ç¼©çŸ­ç®€åŒ–ä»£ç ï¼Œä½†æ˜¯ä¸åº”è¯¥æ»¥ç”¨ï¼Œå°¤å…¶æ˜¯åœ¨lambdaåµŒå¥—æƒ…å†µä¸‹ï¼Œæœ€å¥½æ˜¾ç¤ºå£°æ˜lambdaå‚æ•°ã€‚å¦åˆ™å¾ˆéš¾ææ¸…itå¼•ç”¨çš„åˆ°åº•æ˜¯å“ªä¸ªå€¼ï¼Œæœ¬æœ«å€’ç½®ã€‚","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94lambda/"},{"title":"å®ä¹ ç¬”è®°-25","text":"åˆ›å»ºå‹å•ä¾‹ä¼˜ç‚¹ èŠ‚çœèµ„æº å†…å­˜ é‡å¯¹è±¡ä¸­åŒ…å«çš„ioï¼Œæ–‡ä»¶æŒ‡é’ˆ è°ƒç”¨æ–¹ä¾¿ ç¼ºç‚¹ é€‚ç”¨äºæ˜‚è´µå¯¹è±¡ï¼Œå¯¹äºè½»é‡å¯¹è±¡ï¼Œä¸ºäº†ç»´æŠ¤å•ä¾‹é€ æˆçš„åŒæ­¥ç­‰å¼€é”€æ¯”åˆ›å»ºä¸€ä¸ªå¯¹è±¡æ›´é«˜ã€‚å¾—ä¸å¿å¤± ä¸æ–¹ä¾¿mockï¼Œï¼ˆå¯ä»¥æŠŠå•ä¾‹å¯¹è±¡ä½œä¸ºå‡½æ•°å‚æ•°åˆ™å¯ä»¥mockï¼‰ï¼Œç›¸è¾ƒäºé™æ€æ–¹æ³•æ›´æ–¹ä¾¿ï¼ˆé™æ€æ–¹æ³•éœ€è¦ä»£ç†çš„æ–¹å¼mockï¼‰ æµ‹è¯•æ—¶å¸¸å¸¸å¹¶è¡Œæµ‹è¯•ï¼Œä½¿ç”¨å•ä¾‹ä¼šé™ä½æ•ˆç‡å‡½æ•°å¼ç¼–ç¨‹ï¼Œæ‹·è´äº‘æ§ï¼Œæ‰“ç‚¹ Alexé™æ€å·¥å…·æ–¹æ³•ï¼Œå°‘ç”¨ï¼Œä¸è¦æœ‰çŠ¶æ€ï¼Œç¡®ä¿æ°¸è¿œä¸ä¼šå˜ å»ºé€ è€… æ„å»ºä¸€ä¸ªå‚æ•°éå¸¸å¤æ‚çš„å¯¹è±¡ï¼Œä½†æ˜¯å¸¸ç”¨çš„ç»„åˆå¾ˆæœ‰é™ï¼Œå†™ä¸€ä¸ªbuilderæä¾›å¸¸ç”¨ç»„åˆï¼Œbuilderå†…éƒ¨è‡ªå·±å¡«å……å…¶ä»–çš„å‚æ•° ä¸è¿ç»­è°ƒç”¨æ²¡æœ‰å…³ç³»ï¼Œå¯ä»¥é“¾å¼è°ƒç”¨çš„å«fluentApi ä¼˜ç‚¹ å®Œæ•´æ€§ åˆ›å»ºå¯¹è±¡çš„åˆæ³•æ€§ï¼Œåœ¨buildæ—¶æ£€æŸ¥/é»˜è®¤å€¼ çµæ´»æ€§ å·¥å‚é™æ€å·¥å‚çº¿ç¨‹æ± ï¼Œcollectionså°è£…æ„é€ å™¨ï¼Œç®€åŒ–æ„é€  å®ä¾‹å·¥å‚è§£è€¦æ—¶ï¼Œä¸å¸Œæœ›ç±»æŒæœ‰ä¸éœ€è¦çš„ç±»ï¼Œä½¿ç”¨factoryæŒæœ‰è¯¥å¯¹è±¡ æŠ½è±¡å·¥å‚è¿”å›æŠ½è±¡/æ¥å£ï¼Œæ–¹ä¾¿ä¿®æ”¹ï¼Œé€‰æ‹©ä¸åŒå®ç° ç»“æ„å‹æ·»åŠ æ–°éœ€æ±‚ï¼ŒåŠ åˆ¤æ–­ï¼Œæ—¶å°è¯•ï¼š ä»£ç†æ¨¡å¼ï¼ˆæ„é€ å™¨ä¼ å…¥å§”æ‰˜äººï¼‰ wrapper å¿«æ·é”®ï¼Œdouble shiftï¼Œ æœ delegate method é™æ€ä»£ç†ï¼ˆæ­£å¸¸ï¼‰åŠ¨æ€ä»£ç†ï¼ˆåå°„ï¼‰è£…é¥°å™¨ï¼ˆç›¸äº’ç»„åˆä»£ç†ï¼‰ wrapper å†…éƒ¨çœ‹ä¸ºä»£ç†-å§”æ‰˜ ç»™æ‰§è¡ŒåŒ…ä¸€å±‚çš®ï¼Œæ¯å±‚çš®å®ç°ä¸€ç§åŠŸèƒ½ï¼ˆå¦‚å¯¹cloudåŠ ç¼“å­˜ã€sdkæ¨¡å¼ï¼‰ï¼ŒåŒ…çš„é¡ºåºä¸åŒï¼Œè°ƒç”¨é¡ºåºä¹Ÿä¸åŒ ç»„åˆæ¨¡å¼ï¼ˆå¯¹è±¡æŒæœ‰ï¼‰ wrapper eg å¯¹æ–¹æ³•è®¡æ•°ï¼Œå¦‚æœæ˜¯ç»§æ‰¿ï¼ˆæ¨èé»˜è®¤finalï¼Œ kotliné»˜è®¤finalï¼‰ï¼Œå­ç±»çš„è¡Œä¸ºæ”¹å˜äº†çˆ¶ç±»çš„è¡Œä¸ºï¼ˆçˆ¶ç±»è°ƒç”¨è‡ªå·±è®¡è¿‡æ•°çš„æ–¹æ³•ï¼‰ï¼Œç»„åˆæ¨¡å¼é¿å…äº†è¿™ç§æƒ…å†µ å±€é™æ€§ï¼Œå†…éƒ¨çš„ç‰¹æ€§æ— æ³•è®¿é—® ç»„åˆç”±äºç»§æ‰¿","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"LeetCode-32","text":"ç¬¬ 388 åœºå‘¨èµ›100233. é‡æ–°åˆ†è£…è‹¹æœ è´ªå¿ƒ 1234567891011121314151617class Solution {public: int minimumBoxes(vector&lt;int&gt;&amp; apple, vector&lt;int&gt;&amp; capacity) { int need = accumulate(apple.begin(), apple.end(), 0); sort(capacity.begin(), capacity.end()); int ans = 0, total = 0; for(int i = capacity.size() - 1; i &gt;= 0; i--) { if(total &lt; need) { total += capacity[i]; ans++; } else { break; } } return ans; }}; 100247. å¹¸ç¦å€¼æœ€å¤§åŒ–çš„é€‰æ‹©æ–¹æ¡ˆ è´ªå¿ƒ 123456789101112class Solution {public: long long maximumHappinessSum(vector&lt;int&gt;&amp; happiness, int k) { long long ans = 0; int len = happiness.size(); sort(happiness.begin(), happiness.end()); for(int i = 0; i &lt; k; i++) { ans += max(happiness[len - 1 - i] - i, 0); } return ans; }}; 100251. æ•°ç»„ä¸­çš„æœ€çŸ­éå…¬å…±å­å­—ç¬¦ä¸² æš´åŠ› 12345678910111213141516171819202122232425262728293031323334353637class Solution { string min(string &amp;a, string&amp; b) { int len_a = a.length(); int len_b = b.length(); if(len_a != len_b) return len_a &lt; len_b ? a : b; return std::min(a, b); }public: vector&lt;string&gt; shortestSubstrings(vector&lt;string&gt;&amp; arr) { int len = arr.size(); vector&lt;string&gt; res(len); for(int i = 0; i &lt; len; i++) { int strlen_i = arr[i].length(); string min_substri = arr[i]; bool find_min = false; for(int sub_strlen = strlen_i; sub_strlen &gt; 0; sub_strlen--) { for(int start_index = 0; start_index &lt;= strlen_i - sub_strlen; start_index++) { bool flag = true; string substri = arr[i].substr(start_index, sub_strlen); for(int j = 0; j &lt; len; j++) { if(i == j) continue; if(arr[j].find(substri) != string::npos) { flag = false; break; } } if(flag) { min_substri = min(min_substri, substri); find_min = true; } } } if(find_min) res[i] = min_substri; } return res; }}; 100216. K ä¸ªä¸ç›¸äº¤å­æ•°ç»„çš„æœ€å¤§èƒ½é‡å€¼è¶…æ—¶12345678910111213141516171819202122232425class Solution {public: long long maximumStrength(vector&lt;int&gt;&amp; nums, int k) { int len = nums.size(); vector&lt;vector&lt;long long&gt;&gt; dp(k+1, vector&lt;long long&gt;(len+1, LLONG_MIN)); vector&lt;long long&gt; prefix_sum(len+1, 0); for(int i = 1; i &lt;= len; i++) { prefix_sum[i] = prefix_sum[i-1] + nums[i-1]; } long long sign = 1; fill(dp[0].begin(), dp[0].end(), 0); for(int seperator = 1; seperator &lt;= k; seperator++) { dp[seperator][0] = 0; for(int i = 1; i &lt;= len; i++) { for(int j = seperator-1; j &lt; i; j++) { dp[seperator][i] = max(dp[seperator][i], dp[seperator-1][j] + (k - seperator + 1) * sign * (prefix_sum[i] - prefix_sum[j])); } // cout &lt;&lt; dp[seperator][i] &lt;&lt; &quot;,&quot;; } sign *= -1; // cout &lt;&lt; endl; } return *max_element(dp[k].begin() + k, dp[k].end()); }}; AC æŠŠå«ä¸‹æ ‡jçš„å’Œå«ä¸‹æ ‡seperatoråˆ†å¼€ï¼Œå¯ä»¥å‡å°‘ä¸€æ¬¡å¾ªç¯ 123456789101112131415161718192021222324252627class Solution {public: long long maximumStrength(vector&lt;int&gt;&amp; nums, int k) { int len = nums.size(); vector&lt;vector&lt;long long&gt;&gt; dp(k+1, vector&lt;long long&gt;(len+1, 0)); vector&lt;long long&gt; prefix_sum(len+1, 0); for(int i = 1; i &lt;= len; i++) { prefix_sum[i] = prefix_sum[i-1] + nums[i-1]; } long long sign = 1; fill(dp[0].begin(), dp[0].end(), 0); for(int seperator = 1; seperator &lt;= k; seperator++) { dp[seperator][seperator-1] = LLONG_MIN; long long mx = LLONG_MIN; for(int i = seperator; i &lt;= len - k + seperator; i++) { // for(int j = seperator-1; j &lt; i; j++) { mx = max(mx, dp[seperator - 1][i - 1] - prefix_sum[i - 1] * (k - seperator + 1) * sign); dp[seperator][i] = max(dp[seperator][i - 1], prefix_sum[i] * (k - seperator + 1) * sign + mx); // } // cout &lt;&lt; dp[seperator][i] &lt;&lt; &quot;,&quot;; } sign *= -1; // cout &lt;&lt; endl; } return *max_element(dp[k].begin() + k, dp[k].end()); }}; ç¬¬ 387 åœºå‘¨èµ›3069. å°†å…ƒç´ åˆ†é…åˆ°ä¸¤ä¸ªæ•°ç»„ä¸­ I123456789101112131415161718192021class Solution {public: vector&lt;int&gt; resultArray(vector&lt;int&gt;&amp; nums) { int len = nums.size(), arr1 = 0; vector&lt;int&gt; arr2; arr2.push_back(nums[1]); for(int i = 2; i &lt; len; i++) { if(nums[arr1] &gt; arr2.back()) { nums[++arr1] = nums[i]; } else { arr2.push_back(nums[i]); } } arr1++; for(int i = arr1; i &lt; len; i++) { nums[i] = arr2[i - arr1]; } // cout &lt;&lt; arr1 &lt;&lt; endl; return nums; }}; 3070. å…ƒç´ å’Œå°äºç­‰äº k çš„å­çŸ©é˜µçš„æ•°ç›®12345678910111213141516171819202122232425class Solution {public: int countSubmatrices(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int k) { int m = grid.size(), n = grid[0].size(); int ans = 0; if(grid[0][0] &lt;= k) ans++; for(int i = 1; i &lt; m; i++) { grid[i][0] += grid[i-1][0]; if(grid[i][0] &lt;= k) ans++; } for(int j = 1; j &lt; n; j++) { grid[0][j] += grid[0][j-1]; if(grid[0][j] &lt;= k) ans++; } for(int i = 1; i &lt; m; i++) { for(int j = 1; j &lt; n; j++) { grid[i][j] += grid[i-1][j] + grid[i][j-1] - grid[i-1][j-1]; if(grid[i][j] &lt;= k) ans++; else break; } } return ans; // grid[i][j] - grid[a][j] - grid[i][b] + grid[a][b]; }}; 3071. åœ¨çŸ©é˜µä¸Šå†™å‡ºå­—æ¯ Y æ‰€éœ€çš„æœ€å°‘æ“ä½œæ¬¡æ•°123456789101112131415161718192021222324class Solution {public: int minimumOperationsToWriteY(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int y[3] = {0}, cnt[3] = {0}, n = grid.size(); for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { cnt[grid[i][j]]++; if((i == j &amp;&amp; j &lt;= n/2) || (i+j == n-1 &amp;&amp; j &gt;= n/2) || (j == n/2 &amp;&amp; i &gt;= n/2)) { y[grid[i][j]]++; } } } auto cal = [&amp;](int y_val, int noty_val, int other_val) { return y[noty_val] + y[other_val] + cnt[y_val] + cnt[other_val] - y[y_val] - y[other_val]; }; return min( min(cal(0, 1, 2), cal(0, 2, 1)), min( min(cal(1, 0, 2), cal(1, 2, 0)), min(cal(2, 0, 1), cal(2, 1, 0)) ) ); }}; 3072. å°†å…ƒç´ åˆ†é…åˆ°ä¸¤ä¸ªæ•°ç»„ä¸­ II ç¦»æ•£åŒ– + æ ‘çŠ¶æ•°ç»„ ç¬¬ 381 åœºå‘¨èµ›3014. è¾“å…¥å•è¯éœ€è¦çš„æœ€å°‘æŒ‰é”®æ¬¡æ•° Iæ€è·¯1 æŒ‰ç…§å­—ç¬¦å‡ºç°æ¬¡æ•°åˆ†é…æŒ‰é”®çš„ä½ç½® 123456789101112131415161718192021222324252627class Solution {public: int minimumPushes(string word) { int alpha_cnt[26] = {0}; int key_cnt[8] = {0}; int cur_key = 0; auto cmp = [&amp;alpha_cnt](int i, int j) { return alpha_cnt[i] &lt; alpha_cnt[j]; }; priority_queue&lt;int, vector&lt;int&gt;, decltype(cmp)&gt; q(cmp); for(char c : word) { alpha_cnt[c - 'a']++; } for(int i = 0; i &lt; 26; i++) { if(alpha_cnt[i]) q.push(i); } int ans = 0; while(!q.empty()) { int top = q.top(); q.pop(); key_cnt[cur_key]++; ans += key_cnt[cur_key] * alpha_cnt[top]; cur_key = (cur_key + 1) % 8; } return ans; }}; æ€è·¯2 æ²¡çœ‹åˆ°é¢˜ç›®è¯´æ‰€æœ‰å­—æ¯éƒ½æ˜¯ä¸åŒçš„ï¼Œå¯ä»¥ç®€åŒ– 123456789class Solution {public: int minimumPushes(string word) { int n = word.length(); int div8 = n &gt;&gt; 3; int mod8 = n &amp; 0b111; return (((div8 + 1) * div8) &lt;&lt; 2) + (div8 + 1) * mod8; }}; 3015. æŒ‰è·ç¦»ç»Ÿè®¡æˆ¿å±‹å¯¹æ•°ç›® I1234567891011121314class Solution {public: vector&lt;int&gt; countOfPairs(int n, int x, int y) { vector&lt;int&gt; ans(n); for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= n; j++) { if(i == j) continue; int dis = min(abs(i - j), abs(min(i, j) - min(x, y)) + abs(max(x, y) - max(i, j)) + 1); ans[dis - 1]++; } } return ans; }}; 3016. è¾“å…¥å•è¯éœ€è¦çš„æœ€å°‘æŒ‰é”®æ¬¡æ•° II123456789101112131415161718192021222324252627class Solution {public: int minimumPushes(string word) { int alpha_cnt[26] = {0}; int key_cnt[8] = {0}; int cur_key = 0; auto cmp = [&amp;alpha_cnt](int i, int j) { return alpha_cnt[i] &lt; alpha_cnt[j]; }; priority_queue&lt;int, vector&lt;int&gt;, decltype(cmp)&gt; q(cmp); for(char c : word) { alpha_cnt[c - 'a']++; } for(int i = 0; i &lt; 26; i++) { if(alpha_cnt[i]) q.push(i); } int ans = 0; while(!q.empty()) { int top = q.top(); q.pop(); key_cnt[cur_key]++; ans += key_cnt[cur_key] * alpha_cnt[top]; cur_key = (cur_key + 1) % 8; } return ans; }}; 3017. æŒ‰è·ç¦»ç»Ÿè®¡æˆ¿å±‹å¯¹æ•°ç›® II æƒ³åˆ†ç±»è®¡ç®—ï¼Œä½†æ˜¯æ²¡ç®—å‡ºæ¥","link":"/home/2024/03/10/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93-%E5%91%A8%E8%B5%9B1/"},{"title":"Kotlinå­¦ä¹ ç¬”è®°â€”â€”åŸºç¡€è¯­æ³•ç¯‡ä¹‹ç±»å’Œå¯¹è±¡","text":"ç±»çš„æ„é€ Kotlinç±»çš„å†™æ³• Kotlinç±»çš„æ„é€ å‡½æ•°åˆ†ä¸ºä¸»æ„é€ å‡½æ•°å’ŒäºŒçº§æ„é€ å‡½æ•° ä¸»æ„é€ å‡½æ•°çš„ç‰¹ç‚¹â€”â€”å‡½æ•°åä¸ºinitï¼Œå‚æ•°è¦å†™åœ¨ç±»ååé¢ï¼ˆä¸‹é¢ä¸¾ä¾‹ï¼‰ï¼Œä¸€èˆ¬ç”¨äºåˆå§‹åŒ– å¦‚æœè¦åœ¨javaä¸­è°ƒç”¨kotlinçš„ç±»ï¼Œè¦åœ¨ç±»åå‰é¢åŠ ä¸Š@JvmOverloadsï¼ˆè®©javaèƒ½å¤Ÿè¯†åˆ«é»˜è®¤å‚æ•°ï¼‰ï¼Œå¹¶ä¸”è¡¥å……constructorå…³é”®å­— ä¸»æ„é€ å‡½æ•°çš„å‚æ•°å†™åœ¨ç±»ååï¼Œå¦‚æœæ²¡æœ‰@JvmOverloadsä¿®é¥°ï¼Œconstructorå…³é”®å­—å¯çœç•¥ï¼ˆä¸æ˜¯æŒ‡äºŒçº§æ„é€ å‡½æ•°çš„constructorï¼Œæ˜¯ç±»ååé¢çš„ï¼‰ äºŒçº§æ„é€ å‡½æ•°ç”¨constructorå…³é”®å­— äºŒçº§æ„é€ å‡½æ•°çš„ç‰¹ç‚¹â€”â€”å¯æœ‰å¯æ— ï¼Œç›¸äº’ç‹¬ç«‹ï¼Œå¦‚æœæœ‰ä¸»æ„é€ å‡½æ•°ï¼Œå…ˆè°ƒç”¨ä¸»æ„é€ å‡½æ•° ä¾‹å­123456789101112131415161718class Animal (type:String = &quot;åŠ¨ç‰©&quot;, name:String) { //æ²¡æœ‰@JvmOverloadsä¿®é¥°ï¼Œå¯ä»¥çœç•¥constructor //ç­‰ä»·ä»¥ä¸‹å†™æ³•//class Animal constructor(type:String = &quot;åŠ¨ç‰©&quot;, name:String) { var Type:String = &quot;&quot; var Name:String = &quot;&quot; var Age:Int = 0 var Sex:String = &quot;&quot; init { Type = type Name = name } constructor(type:String = &quot;åŠ¨ç‰©&quot;, name:String, age:Int, sex:String) : this(type, name){ Age = age Sex = sex }} ç±»çš„æˆå‘˜ç±»çš„æˆå‘˜å±æ€§è§‚å¯Ÿä¸Šè¿°ä»£ç ï¼Œæ„é€ å‡½æ•°ä¼ å…¥çš„å‚æ•°å’Œæˆå‘˜å˜é‡ä¸€ä¸€å¯¹åº”ï¼Œå¯¹äºè¿™äº›å˜é‡ï¼ŒKotlinæä¾›ç®€ä¾¿å†™æ³•ï¼Œåœ¨å‚æ•°åä¹‹å‰åŠ ä¸Švalæˆ–var ä¾‹å­1234567891011class Animal (var type:String = &quot;åŠ¨ç‰©&quot;, var name:String) { //åªæœ‰ä¸»æ„é€ å‡½æ•°ä¸­æ‰å¯ä»¥æœ‰æˆå‘˜å±æ€§ var sex:Int = 0 var age = 0 constructor(type:String = &quot;åŠ¨ç‰©&quot;, name:String, age:Int, sex:Int) : this(type, name){ this.sex = sex this.age = age }}//åˆ°æ—¶å€™å¯ä»¥ç›´æ¥è°ƒç”¨æˆå‘˜å˜é‡typeï¼Œnameç­‰ ä¼´ç”Ÿå¯¹è±¡å’Œé™æ€å±æ€§æƒ³è¦è®©ç±»å…·æœ‰ç±»ä¼¼javaä¸­é™æ€æˆå‘˜å‡½æ•°å’Œé™æ€æˆå‘˜å˜é‡ï¼Œè¦ç”¨åˆ°ä¼´ç”Ÿå¯¹è±¡ï¼Œç›¸å½“äºjavaä¸­çš„staticä»£ç å—å„¿ ä¾‹å­1234567891011121314151617181920212223class Animal (var type:String = &quot;åŠ¨ç‰©&quot;, var name:String) { var sex:Int = 0 var age = 0 constructor(type:String = &quot;åŠ¨ç‰©&quot;, name:String, age:Int, sex:Int) : this(type, name){ this.sex = sex this.age = age } companion object StaticMembers { val MALE:Int = 0 val FEMALE:Int = 1 val UNKNOWNSEX:Int = 2 val UNDIFINEDSEX:Int = 3 fun sexToString(sex:Int):String { return when(sex) { MALE -&gt; &quot;Male&quot; FEMALE -&gt; &quot;Female&quot; UNKNOWNSEX -&gt; &quot;UnKnownSex&quot; UNDIFINEDSEX -&gt; &quot;UnDefindSex&quot; else -&gt; &quot;Invalid input&quot; } } }} ç±»çš„ç»§æ‰¿åœ¨Kotlinä¸­ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œç±»æ˜¯ä¸å…è®¸è¢«ç»§æ‰¿çš„ï¼Œæˆå‘˜å‡½æ•°ä¹Ÿæ˜¯ä¸å…è®¸é‡å†™çš„ï¼Œåªæœ‰åŠ ä¸Šopenä¿®é¥°ç¬¦ï¼Œè¢«ä¿®é¥°çš„ç±»æ‰å¯ä»¥è¢«ç»§æ‰¿ï¼Œè¢«ä¿®é¥°çš„å‡½æ•°æ‰å¯ä»¥è¢«é‡å†™ï¼ŒKotlinçš„ç±»å’Œå‡½æ•°é»˜è®¤ç›¸å½“äºjavaçš„finalç±»å’Œæ–¹æ³• Kotlinä¸­çš„å¼€æ”¾æ€§ä¿®é¥°ç¬¦ å¼€æ”¾æ€§ä¿®é¥°ç¬¦ è¯´æ˜ public å¯¹æ‰€æœ‰äººå¼€æ”¾ï¼ŒKotlinçš„ç±»ã€å‡½æ•°å˜é‡ä¸åŠ ä¿®é¥°å…¨éƒ¨éƒ½æ˜¯public internal å¯¹äºæœ¬æ¨¡å—å¼€æ”¾ protected å¯¹äºè‡ªå·±å’Œå­ç±»å¼€æ”¾ private ç§æœ‰ï¼Œä¸èƒ½å’Œopenä¸€èµ·ä½¿ç”¨ æŠ½è±¡ç±»å†™æ³•ï¼š 123abstract class demo() { abstract fun func1():Int} æ¥å£123456interface interDemo { fun func1():String fun func2():String { return &quot;I'm tired&quot; }} æ³¨æ„ Kotlinä¸å…è®¸å¤šç»§æ‰¿ï¼Œé€šè¿‡æ¥å£æ¥é—´æ¥å®ç°å¤šç»§æ‰¿ æŠ½è±¡ç±»ä¸èƒ½å®šä¹‰å¯¹è±¡ kotlinå…è®¸åœ¨æ¥å£å†…éƒ¨å®ç°æŸä¸ªæ–¹æ³• æ¥å£å†…éƒ¨çš„æ‰€æœ‰æ–¹æ³•é»˜è®¤éƒ½æ˜¯openç±»å‹é»˜è®¤æ˜¯æŠ½è±¡çš„ ç»§æ‰¿çš„æ—¶å€™ï¼ŒåŸºç±»çš„æˆå‘˜å±æ€§ä¸ç”¨åŠ valæˆ–var å‡ ç§ç‰¹æ®Šçš„ç±»åµŒå¥—ç±»æ³¨æ„ åµŒå¥—ç±»å°±æ˜¯åœ¨ç±»é‡Œé¢å†å†™ä¸€ä¸ªç±» æ™®é€šçš„åµŒå¥—ç±»ä¸èƒ½è®¿é—®å¤–éƒ¨ç±»çš„æ•°æ® ä¾‹å­1234567class outerClass(var otrName:String = &quot;outer name&quot;) { class innerClass(var inrName:String = &quot;inner name&quot;) { fun getInfo():String { return &quot;æˆ‘çš„åå­—æ˜¯ï¼š${inrName}&quot; } }} å†…éƒ¨ç±» å¯ä»¥è®¿é—®å¤–éƒ¨ç±»æ•°æ®çš„åµŒå¥—ç±»1234567class outerClass(var otrName:String = &quot;outer name&quot;) { inner class innerClass(var inrName:String = &quot;inner name&quot;) { fun getInfo():String { return &quot;å†…éƒ¨ç±»çš„åå­—æ˜¯ï¼š${inrName}\\nå¤–éƒ¨ç±»çš„åå­—æ˜¯ï¼š${otrName}&quot; } }} æšä¸¾ç±»å’Œå¯†å°ç±»å…ˆä¸å­¦ æ•°æ®ç±»åœ¨ç±»åå‰åŠ ä¸Šdataä¿®é¥° ç‰¹ç‚¹ è¿™ç§ç±»è‡ªåŠ¨ç”Ÿæˆæ¯ä¸ªå­—æ®µçš„getå’Œsetæ–¹æ³• equalsæ–¹æ³•ï¼Œæ¯”è¾ƒæ¯ä¸€ä¸ªæ•°æ® æä¾›copyæ–¹æ³•ï¼Œç”¨äºå¤åˆ¶æ•°æ®å¯¹è±¡ æä¾›toStingæ–¹æ³• æ³¨æ„ å¿…é¡»æœ‰ä¸»æ„é€ å‡½æ•°ï¼Œä¸”è‡³å°‘ä¸€ä¸ªå‚æ•° è¾“å…¥å‚æ•°å‰é¢å¿…é¡»è¦åŠ valæˆ–var æ•°æ®ç±»ä¸èƒ½æ˜¯åŸºç±»ï¼Œä¸èƒ½æ˜¯å­ç±»ï¼Œä¸èƒ½æ˜¯æŠ½è±¡ç±»ï¼Œä¸èƒ½æ˜¯å†…éƒ¨ç±»ï¼Œä¸èƒ½æ˜¯å¯†å°ç±» æ¨¡æ¿ç±»ç±»ååé¢æ·»åŠ &lt;/*æ³›å‹åˆ—è¡¨*/&gt;ï¼Œè¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªæ¨¡æ¿ç±» ä¾‹å­123class MyArray&lt;T&gt; (var arr:Array&lt;T&gt;) { }","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87%E4%B9%8B%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"title":"LeetCode-11","text":"2020-07-2755. è·³è·ƒæ¸¸æˆæ€è·¯ å¯¹numsæ•°ç»„ï¼Œä»¤nums[i] += i,è¿™æ ·è¡¨ç¤ºiä½ç½®æœ€è¿œå¯ä»¥èµ°åˆ°çš„è·ç¦» ç®—æ³• ä»i = 0å¼€å§‹å¯¹äºå½“å‰iï¼Œå¯ä»¥ä»0èµ°åˆ°nums[i]ï¼Œé€‰å–0-nums[i]çš„æœ€å¤§å€¼ï¼Œå¦‚æœæœ€å¤§å€¼å¤§äºç­‰äºn-1ï¼Œåˆ™å¯ä»¥åˆ°è¾¾æœ€åï¼Œè‹¥å°äºï¼Œé‡å¤è¿™ä¸ªæ­¥éª¤ï¼Œé™¤éi=æœ€å¤§å€¼ï¼Œåˆ™ä¸èƒ½åˆ°è¾¾æœ€å ä¸ºäº†é™ä½æ—¶é—´å¤æ‚åº¦ï¼Œåˆ›å»ºä¸€ä¸ªæ•°ç»„vï¼Œv[i] = max(nums[k]), k = 0,1,â€¦,i ACä»£ç 12345678910111213141516171819202122232425class Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { int n = int(nums.size()); for(int i = 0; i &lt; n; i++) { nums[i] += i; } vector&lt;int&gt; v; int max = nums[0]; for(int i = 0; i &lt; n; i++) { if (nums[i] &gt; max) { max = nums[i]; } v.push_back(max); } int i = 0; while (i != v[i]) { i = v[i]; if (i &gt;= n-1) { return true; } } return false || n == 1; }}; ä¼˜åŒ–å‚è€ƒå·²ç»æäº¤çš„ä»£ç ï¼Œå¯ä»¥ä¸åˆ›å»ºæ•°ç»„vï¼Œä¹Ÿç”¨O(n)çš„æ—¶é—´å®Œæˆ ä¼˜åŒ–ä»£ç 123456789101112131415161718class Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { int n = int(nums.size()); int i = 0; int max = nums[0]; while (i &lt;= max) { if (max &lt; i + nums[i]) { max = i + nums[i]; } if (max &gt;= n-1) { return true; } i++; } return false || n == 1; }}; è¿™é“é¢˜leetcodeä¸Šçš„æµ‹é€Ÿä¸å‡†ï¼Œæ²¡æœ‰å‚è€ƒä»·å€¼ï¼Œç›¸åŒå‚è€ƒä»£ç èƒ½è·‘å‡ºä¸åŒçš„é€Ÿåº¦ã€‚ 16. æœ€æ¥è¿‘çš„ä¸‰æ•°ä¹‹å’ŒACä»£ç 123456789101112131415161718class Solution {public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) { sort(nums.begin(), nums.end()); int mincut = nums[0] + nums[1] + nums[2]; for(int i = 0; i &lt; (int)nums.size() - 2; i ++) { int j = i + 1, k = nums.size() - 1; while(j &lt; k) { int threesum = nums[i] + nums[j] + nums[k]; if(abs(threesum - target) &lt; abs(mincut - target)) mincut = threesum; if(threesum == target) return target; else if(threesum &lt; target) j ++; else k --; } } return mincut; }}; ä¼˜åŒ–è·³è¿‡ä¸€äº›ä¸ç”¨è€ƒè™‘çš„å€¼ï¼Œ1.å’Œä¸Šæ¬¡æšä¸¾çš„æ•°ç›¸åŒçš„å€¼ï¼Œ2.å·²ç»ç­‰äºtargetçš„æƒ…å†µ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution {public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) { sort(nums.begin(), nums.end()); int n = nums.size(); int best = 1e7; // æ ¹æ®å·®å€¼çš„ç»å¯¹å€¼æ¥æ›´æ–°ç­”æ¡ˆ // æšä¸¾ a for (int i = 0; i &lt; n; ++i) { // ä¿è¯å’Œä¸Šä¸€æ¬¡æšä¸¾çš„å…ƒç´ ä¸ç›¸ç­‰ if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) { continue; } // ä½¿ç”¨åŒæŒ‡é’ˆæšä¸¾ b å’Œ c int j = i + 1, k = n - 1; while (j &lt; k) { int sum = nums[i] + nums[j] + nums[k]; // å¦‚æœå’Œä¸º target ç›´æ¥è¿”å›ç­”æ¡ˆ if (sum == target) { return target; } if (abs(sum - target) &lt; abs(best - target)) { best = sum; } if (sum &gt; target) { // å¦‚æœå’Œå¤§äº targetï¼Œç§»åŠ¨ c å¯¹åº”çš„æŒ‡é’ˆ int k0 = k - 1; // ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªä¸ç›¸ç­‰çš„å…ƒç´  while (j &lt; k0 &amp;&amp; nums[k0] == nums[k]) { --k0; } k = k0; } else { // å¦‚æœå’Œå°äº targetï¼Œç§»åŠ¨ b å¯¹åº”çš„æŒ‡é’ˆ int j0 = j + 1; // ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªä¸ç›¸ç­‰çš„å…ƒç´  while (j0 &lt; k &amp;&amp; nums[j0] == nums[j]) { ++j0; } j = j0; } } } return best; }}; 61. æ—‹è½¬é“¾è¡¨ACä»£ç 123456789101112131415161718192021222324class Solution {public: ListNode* rotateRight(ListNode* head, int k) { if(head == NULL) { return head; } int n = 0; ListNode *p = head; while (p-&gt;next != NULL) { n++; p = p-&gt;next; } n++; k %= n; p-&gt;next = head; p = head; for (int i = 0; i &lt; n - k - 1; i++) { p = p-&gt;next; } ListNode* new_head = p-&gt;next; p-&gt;next = NULL; return new_head; }}; ç»éªŒçœ‹ä¼¼ç®€å•çš„é¢˜ï¼Œå‘ç°äº†è‡ªå·±çš„çŸ¥è¯†æ¼æ´ï¼Œå›¾éå†çš„æ—¶å€™è¦æœ‰visitæ•°ç»„è®°å½•å®ƒæ˜¯å¦è®¿é—®è¿‡ï¼Œæ­¤å¤„ç”¨mapä»£æ›¿ã€‚ 133. å…‹éš†å›¾ACä»£ç 123456789101112131415161718192021222324class Solution {public: Node* cloneGraph(Node* node) { if(node == NULL) return NULL; unordered_map&lt;Node*, Node*&gt; m; queue&lt;Node*&gt; q; q.push(node); Node* head = new Node(node-&gt;val, vector&lt;Node*&gt;{}); m[node]=head; while (!q.empty()) { Node* temp = q.front(); q.pop(); for (Node* child: temp-&gt;neighbors) { if(!m.count(child)) { m[child] = new Node(child-&gt;val, vector&lt;Node*&gt;{}); q.push(child); } m[temp]-&gt;neighbors.push_back(m[child]); } } return head; }}; 120. ä¸‰è§’å½¢æœ€å°è·¯å¾„å’Œè¶…æ—¶ç®—æ³• æ™®é€šçš„æœç´¢123456789101112131415161718192021222324252627282930class Solution {public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) { int ni = int(triangle.size()); vector&lt;int&gt; v(ni, 0); vector&lt;int&gt; index(ni, 0); int sum = INT_MAX; while(v[0] == 0) { int t_sum = 0; for (int j = 0; j &lt; ni; j++) { t_sum += triangle[j][index[j]]; } if (t_sum &lt; sum) { sum = t_sum; } int i = ni-1; while (i &gt; 0 &amp;&amp; v[i] == 1) { v[i] = 0; i--; } index[i]++; for (int j = i+1; j &lt; ni ; j++) { index[j] = index[j-1]; } v[i] = 1; } return sum; }}; ä¼˜åŒ–æ€è·¯ä¸€ä¸ªä¸ªæšä¸¾ä¼šè¶…æ—¶ï¼Œè¦ç”¨åŠ¨æ€è§„åˆ’ ACä»£ç 12345678910111213141516class Solution {public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) { int ni = int(triangle.size()); vector&lt;int&gt; v(ni, 0); v[0] = triangle[0][0]; for (int i = 1; i &lt; ni; i++) { v[i] = v[i-1] + triangle[i][i]; for (int j = i - 1; j &gt; 0; j--) { v[j] = min(v[j-1],v[j]) + triangle[i][j]; } v[0] += triangle[i][0]; } return *min_element(v.begin(), v.end()); }}; 2020-07-2833. æœç´¢æ—‹è½¬æ’åºæ•°ç»„ACä»£ç 12345678910111213141516171819202122232425262728293031class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { int l = 0, h = int(nums.size())-1; while (l &lt;= h) { int mid = (h-l)/2+l; if (nums[mid] == target) { return mid; } if (nums[mid] &gt; nums[l]) { if (target &gt;= nums[l] &amp;&amp; target &lt; nums[mid]) { h = mid - 1; } else { l = mid + 1; } } else if (nums[mid] == nums[l]) { if (h == l) { return -1; } l++; } else { if (target &lt;= nums[h] &amp;&amp; target &gt; nums[mid]) { l = mid + 1; } else { h = mid - 1; } } } return -1; }}; æ€è·¯ äºŒåˆ†æŸ¥æ‰¾æ³•ï¼Œç”±äºæ˜¯ä¸¤æ®µæœ‰åºï¼Œåˆ†åˆ«æœ‰å‡ ç§æƒ…å†µï¼Œä¸”æ²¡æœ‰ç›¸ç­‰å…ƒç´  nums[mid] &gt; nums[l]ï¼Œè¯´æ˜l-midä¸ºä¸¥æ ¼çš„å‡åºï¼Œå¦‚æœtargetåœ¨nums[l]-nums[mid]ä¹‹é—´ï¼Œh=mid-1ï¼Œå¦åˆ™l=mid+1ã€‚åˆ‡æ¢åˆ°l-hä¹‹é—´æœç´¢ nums[mid] == nums[l]ï¼Œè¯´æ˜ (l+h)/2 = l, h=l-1 æˆ– h=l h=l-1ï¼Œä»¤l=h h=lï¼Œmid=h=lï¼Œè¯´æ˜æ— è§£ï¼Œreturn -1 nums[mid] &lt; nums[h]ï¼Œè¯´æ˜mid-hä¸ºä¸¥æ ¼å‡åºï¼Œå¦‚æœtargetåœ¨nums[mid]-nums[h]ä¹‹é—´ï¼Œl=mid+1ï¼Œå¦åˆ™h=mid-1ã€‚åˆ‡æ¢åˆ°l-hä¹‹é—´æœç´¢ 74. æœç´¢äºŒç»´çŸ©é˜µACä»£ç 123456789101112131415161718192021222324class Solution {public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) { int m = int(matrix.size()); if (m &lt;= 0) { return false; } int n = int(matrix[0].size()); int num = m*n; int l = 0,h = num-1; while (l &lt;= h) {// äºŒåˆ†æŸ¥æ‰¾æ³• int mid = (h-l)/2+l; if (matrix[(mid)/n][(mid)%n] == target) {//ç®—å‡ºmidå¯¹åº”çš„ä¸‹æ ‡å°±è¡Œ return true; } else if (matrix[(mid)/n][(mid)%n] &gt; target) { h = mid-1; } else { l = mid+1; } } return false; }};","link":"/home/2020/07/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9311/"},{"title":"Kotlinå­¦ä¹ ç¬”è®°â€”â€”åŸºç¡€è¯­æ³•ç¯‡ä¹‹ç‰¹æ®Šè¿ç®—ç¬¦","text":"å‚è€ƒæ–‡çŒ®â€”â€”Kotlinå­¦ä¹ ä¹‹è¿ç®—ç¬¦æ¥è‡ªç®€ä¹¦ä½œè€…â€”â€”Hunter_Arley ç­‰å€¼åˆ¤æ–­ è¿ç®—ç¬¦ è§£é‡Š é‡è½½å‡½æ•° a == b åˆ¤æ–­abæ˜¯å¦ç»“æ„ç›¸ç­‰ï¼Œç›¸å½“äºjavaä¸­a.equals(b)æˆ–b.equals(a) a?.equals(b)?:b===null a != b åˆ¤æ–­abæ˜¯å¦ç»“æ„ä¸ç­‰ï¼Œç›¸å½“äºjavaä¸­!a.equals(b)æˆ–!b.equals(a) !(a?.equals(b)ï¼Ÿ:b===null) === åˆ¤æ–­æ˜¯å¦ç»“æ„ç›¸ç­‰ä¸”å¼•ç”¨ç›¸åŒ ps: Kotlinä¸­çš„==ç”¨æ¥æ¯”è¾ƒä¸¤ä¸ªå…ƒç´ æ˜¯å¦ç›¸åŒï¼Œæ¯”å¦‚å­—ç¬¦ä¸²çš„å†…å®¹ï¼Œæ•´æ•°ï¼Œæµ®ç‚¹æ•°çš„å€¼ï¼Œè€Œä¸æ¯”è¾ƒå¼•ç”¨æ˜¯å¦ç›¸åŒï¼Œè€Œ===è¡¨ç¤ºæ¯”è¾ƒå†…å®¹æ˜¯å¦ç›¸åŒï¼Œä¸”å¼•ç”¨æ˜¯å¦ç›¸åŒ æ–°å¢è¿ç®—ç¬¦ è¿ç®—ç¬¦ è§£é‡Š é‡è½½å‡½æ•° is åˆ¤æ–­å˜é‡æ˜¯å¦ä¸ºæŸä¸ªç±»å‹ a in b æ£€æŸ¥å…ƒç´ aæ˜¯å¦åœ¨bä¸­ b.contains(a) ä¸‹æ ‡è¿ç®—ç¬¦ æ“ä½œç¬¦ å‡½æ•° a[i] a.get(i) a[i,j] a.get(i,j) a[i_1,â€¦,i_n] a.get(i_1,â€¦,i_n) a[i]=b a.set(i,b) a[i,j]=b a.set(i,j,b) a[i_1,â€¦,i_n]=b a.set(i_1,â€¦,i_n,b) ä¸Javaä¸åŒï¼ŒKotlinçš„è¿™ä¸ªè¿ç®—ç¬¦ä¸ä»…å¯ä»¥ç”¨åœ¨æ•°ç»„å˜é‡åï¼Œä¹Ÿå¯ä»¥ç”¨åœ¨é›†åˆå˜é‡åï¼Œå¯ä»¥æ–¹ä¾¿åœ°è°ƒç”¨å’Œæ“ä½œæ•°ç»„å’Œé›†åˆä¸­çš„å…ƒç´ ã€‚ ä½ã€é€»è¾‘è¿ç®—ç¬¦ Javaä½è¿ç®—ç¬¦ Kotlin Kotlinå‡½æ•° æè¿° ~a æ—  a.inv() æŒ‰ä½å–é a&amp;b a and b a.and(b) æŒ‰ä½ä¸ a | b a or b a.or(b) æŒ‰ä½æˆ– a^b a xor b a.xor(b) æŒ‰ä½å¼‚æˆ– a&lt;&lt; b a shl b a.shl(b) å·¦ç§»bä½ a&gt;&gt;b a shr b a.shr(b) å³ç§»bä½ a&gt;&gt;&gt;b a ushr b a.ushr(b) æ— ç¬¦å·å³ç§»bä½","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87%E4%B9%8B%E7%89%B9%E6%AE%8A%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"title":"LeetCode-10","text":"2020-07-25Z å­—å½¢å˜æ¢ACä»£ç 123456789101112131415161718192021222324252627282930class Solution {public: string convert(string s, int numRows) { if (numRows &lt;= 1) { return s; } int n = s.size(); string temp[numRows]; int t_numRows = 0; int p = 0; while(p &lt; n) { while(p &lt; n &amp;&amp; t_numRows &lt; numRows) { temp[t_numRows] += s[p]; p++; t_numRows++; } t_numRows = numRows -2; while (p &lt; n &amp;&amp; t_numRows &gt; 0) { temp[t_numRows] += s[p]; p++; t_numRows--; } } string res; for(int i = 0 ; i &lt; numRows; i++) { res = res + temp[i]; } return res; }}; ä¼˜åŒ–æ€è·¯ ä¸¤å±‚whileå¾ªç¯å¤šæ¬¡åˆ¤æ–­p&lt;n,æ•ˆç‡åº•ä¸‹ï¼Œå®é™…ä¸Šåªéœ€è¦å½“t_numRows==0æˆ–t_numRows==numRows-1æ—¶æ”¹å˜æ–¹å‘å³å¯ å®é™…ä¸Šéœ€è¦çš„stringæ•°ç»„é•¿åº¦æ˜¯min(n, numRows) ä¼˜åŒ–ä»£ç 1234567891011121314151617181920212223class Solution {public: string convert(string s, int numRows) { if (numRows &lt;= 1) { return s; } int n = int(s.size()); int len = min(numRows, n); vector&lt;string&gt; temp(len); int t_numRows = 0; bool goingDown = false; for(int i = 0; i &lt; n; i++) { temp[t_numRows] += s[i]; if (t_numRows == 0 || t_numRows == numRows-1) { goingDown = !goingDown; } t_numRows += goingDown ? 1 :-1; } string res; for (int i = 0; i &lt; len; i++) res += temp[i]; return res; }}; å†æ¬¡ä¼˜åŒ–å¯ä»¥ç›´æ¥æ‰¾æ–°æ—§æ•°åˆ—çš„æ•°å­—å…³ç³»ï¼Œç›´æ¥è®¡ç®— ä¼˜åŒ–ä»£ç 123456789101112131415161718192021222324252627282930313233class Solution {public: string convert(string s, int numRows) { if (numRows &lt;= 1) { return s; } int len_s = int(s.size()); int unit =(2*numRows-2); int n = len_s/unit; int remain = len_s%unit; string res(len_s, 0); for (int i = 0; i &lt; len_s; i++) { int p = 0; if (i%unit == 0) { p = i/unit+1; } else { int r = i%unit + 1,c = i/unit+1; if (r &gt; numRows) { r = unit-r+2; p = 1; } else if (r == numRows) { p = 1-c; } p += n + (n*2)*(r-2) + 2*(c-1) + min(r-1, remain)+1; if (remain &gt; numRows) { p += max(r-(unit-remain+2),0); } } res[p-1] = s[i]; } return res; }}; æœ€ç»ˆæˆç»© æ‰§è¡Œç”¨æ—¶ï¼š8 ms, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†98.89%çš„ç”¨æˆ· å†…å­˜æ¶ˆè€—ï¼š7.7 MB, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ· ### 75. é¢œè‰²åˆ†ç±»ACä»£ç  è®¡æ•°12345678910111213141516class Solution {public: void sortColors(vector&lt;int&gt;&amp; nums) { int n[3] = {0}; for(int i : nums) { n[i]++; } int x = 0; for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; n[i]; j++) { nums[j+x] = i; } x += n[i]; } }}; ä¼˜åŒ– ä¸‰æŒ‡é’ˆæ³•123456789101112131415161718192021class Solution {public: void sortColors(vector&lt;int&gt;&amp; nums) { int f,t = int(nums.size())-1,m; f = m = 0; while (m &lt;= t) { if (nums[m] == 0) { swap(nums[m++], nums[f++]); } else if (nums[m] == 2) { swap(nums[m], nums[t--]); } else { m++; } } } void xchg(int&amp; a, int&amp; b) { a = a+b; b = a-b; a = a-b; }}; 129. æ±‚æ ¹åˆ°å¶å­èŠ‚ç‚¹æ•°å­—ä¹‹å’ŒACä»£ç 1234567891011121314151617181920212223class Solution {public: int sum = 0; void go(TreeNode* root, int num) { if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) { sum += num*10+root-&gt;val; return; } if (root-&gt;left != NULL) { go(root-&gt;left, num*10+root-&gt;val); } if (root-&gt;right != NULL) { go(root-&gt;right, num*10+root-&gt;val); } } int sumNumbers(TreeNode* root) { if (root == NULL) { return 0; } go(root, 0); return sum; }}; 29. ä¸¤æ•°ç›¸é™¤ACä»£ç 12345678910111213141516171819202122232425262728class Solution {public: unsigned int i2ui(int n) { return (n&lt;0&amp;&amp;n != -2147483648)?-n:((n == -2147483648) ? 2147483648 : n); } int divide(int dividend, int divisor) { bool neg = (dividend&lt;0)^(divisor&lt;0); unsigned int a = i2ui(dividend), b = i2ui(divisor); unsigned int res = 0; unsigned int tb = b; unsigned int add = 1; while((tb &amp; 0x80000000)==0) { tb &lt;&lt;= 1; add &lt;&lt;= 1; } while (a &gt;= b) { if (a &gt;= tb) { res += add; a -= tb; } add &gt;&gt;=1; tb &gt;&gt;= 1; } res = (res &gt; 2147483647 &amp;&amp; !neg) ? INT_MAX : res; int ires = neg ? ((res&gt;2147483648)?INT_MAX:-res) : res; return ires; }}; æ€è·¯åˆ©ç”¨æœ€åŸºæœ¬çš„åˆ—ç«–å¼æ³•ï¼Œå…ˆè½¬æˆæ­£æ•°ï¼Œå†è®¡ç®— ä¼˜åŒ– ä¸æ»¡è¶³é¢˜ç›®çš„å‡è®¾æˆ‘ä»¬çš„ç¯å¢ƒåªèƒ½å­˜å‚¨ 32 ä½æœ‰ç¬¦å·æ•´æ•°çš„æ¡ä»¶ ç±»ä¼¼ä¸Šé¢çš„ç®—æ³•ï¼ŒæŠŠæ‰€æœ‰æ•°è½¬åŒ–ä¸ºè´Ÿæ•°ï¼Œå†å¯¹divisor=0x80000000æ—¶ç‰¹åˆ¤ ä¼˜åŒ–ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: int nabs(int n) { return (n &gt; 0)? -n : n; } int divide(int dividend, int divisor) { int neg = ((dividend&lt;0)^(divisor&lt;0)); dividend = nabs(dividend); divisor = nabs(divisor); int sub = 1; if (divisor==INT_MIN) { return (dividend == INT_MIN) ? 1 : 0; } int t_divisor = -divisor; while((t_divisor &amp; 0x40000000)==0) { t_divisor &lt;&lt;= 1; sub &lt;&lt;= 1; } int res = 0;// cout &lt;&lt; t_divisor &lt;&lt; &quot; &quot; &lt;&lt; sub &lt;&lt; endl; while (dividend &lt;= divisor &amp;&amp; sub != 0) { if (dividend &lt;= -t_divisor) { dividend += t_divisor; res -= sub; } sub &gt;&gt;= 1; t_divisor &gt;&gt;= 1; } if (dividend &lt;= divisor) { res = (res == INT_MIN)? res : res-1;// cout &lt;&lt; res &lt;&lt; endl; } res = !neg ? ((res==-2147483648)?INT_MAX:-res) : res; return res; }}; æœ€ç»ˆæˆç»© æ‰§è¡Œç”¨æ—¶ï¼š0 ms, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ· å†…å­˜æ¶ˆè€—ï¼š6 MB, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ· 36. æœ‰æ•ˆçš„æ•°ç‹¬ACä»£ç 12345678910111213141516171819202122232425262728293031323334class Solution {public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { for (int i = 0; i &lt; 9; i++) { int r[9] = {0}; int c[9] = {0}; int s[9] = {0}; for (int j = 0; j &lt; 9; j++) { if (board[i][j] != '.') { r[board[i][j]-'1']++; } if (board[j][i] != '.') { c[board[j][i]-'1']++; } } int a = i/3; int b = i%3; for (int ii = 3*a; ii &lt; 3*(a+1); ii++) { for (int ij = 3*b; ij &lt; 3*(b+1); ij++) { if (board[ii][ij] != '.') { s[board[ii][ij]-'1']++; } } } for (int j = 0; j &lt; 9; j++) { if (r[j] &gt; 1 || c[j] &gt; 1 || s[j] &gt; 1) { return false; } } } return true; }}; 5. æœ€é•¿å›æ–‡å­ä¸²ACä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution {public: map&lt;int ,int, greater&lt;int&gt;&gt; m; int rb=0,re=0; string longestPalindrome(string s) { int n = int(s.size()); if (n &lt;= 0) { return &quot;&quot;; } go(s, 0, n); for (int off = 1; off &lt; n; off++) { go(s, off, n); go(s, 0, n-off); } while (!m.empty()) { int sub = m.begin()-&gt;first; int sum = m.begin()-&gt;second; int beg = (sum-sub)/2; int end = (sum+sub)/2; if(go(s, beg,end) &amp;&amp; ((re-rb) &gt; (end-beg))) break; } return s.substr(rb, re-rb); } bool go(string&amp; s,int beg, int end) { int pos = isPalindrome(s, beg, end); if (pos != beg) { end -= pos-beg; beg = pos; m[end-beg]=end+beg; return false; }else { m.erase(end-beg); if ((end-beg) &gt; (re-rb)) { rb = beg; re = end; } return true; } } int isPalindrome(string&amp; s, int beg, int end) { int res = -1; for(int i = 0; i &lt; (end-beg)/2; i++) { if(s[beg+i] != s[end-1 - i] &amp;&amp; i &gt; res) res = i; } return beg+res+1; }}; ä¼˜åŒ–å‚è€ƒä¼˜ç§€çš„é¢˜è§£ï¼Œå¤§è‡´æ€æƒ³æ˜¯æŠŠæ¯ä¸ªå­—ç¬¦ä½œä¸ºä¸­å¿ƒï¼Œå‘å·¦å³å±•å¼€ 123456789101112131415161718192021222324252627282930class Solution {public: int l=0,h=0; string longestPalindrome(string s) { int n = int(s.size()); if (n &lt;= 1) { return s; } for (int i = 0; i &lt; n; i++) { i = findLongest(s, i, n); } return s.substr(l, h-l+1); } int findLongest(const string&amp; s,int i, int n) { int high = i; while (high &lt; n-1 &amp;&amp; s[high+1] == s[i]) { high++; }// ä¸­éƒ¨å­—ç¬¦å…¨éƒ¨ç›¸åŒ int ans = high; while (i &gt; 0 &amp;&amp; high &lt; n-1 &amp;&amp; s[i-1]==s[high+1]) { i--; high++;//å‘ä¸¤è¾¹å±•å¼€ } if ((high - i) &gt; h-l) { h = high; l = i; //æ›´æ–°æœ€é•¿ä¸²çš„ä½ç½® } return ans; }}; 62. ä¸åŒè·¯å¾„æ€è·¯å¤§ä½¬ä»¬éƒ½æ˜¯ç”¨dpï¼Œè€Œæˆ‘æ˜¯æ¨å…¬å¼ï¼Œå°±æ˜¯è¿™ä¹ˆç®€å• ACä»£ç 12345678910111213141516171819202122232425262728class Solution {public: int uniquePaths(int m, int n) { if (m &gt; n) { m = m+n; n = m-n; m = m-n; } int res = n; if (m &lt; 2) { return 1; } if (m == 2) { return n; } vector&lt;int&gt; v(m-2, 0); for (int i = 1; i &lt;= n-1; i++) { v[0] += i; for (int j = 1; j &lt; m - 2; j++) { v[j] += v[j-1]; } } for (int i = 0; i &lt; m -2; i++) { res += v[i]; } return res; }}; æœ€ç»ˆæˆç»© æ‰§è¡Œç”¨æ—¶ï¼š0 ms, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ· å†…å­˜æ¶ˆè€—ï¼š5.9MB, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ· 63. ä¸åŒè·¯å¾„ IIACä»£ç 123456789101112131415161718192021222324252627282930313233class Solution {public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) { int n = int(obstacleGrid.size()); int m = int(obstacleGrid[0].size()); bool swap = false; if (m &gt; n) { m = m+n; n = m-n; m = m-n; swap = true; } vector&lt;long long&gt; v(m+1, 0); long long t_v0 = 1; for (int i = 0; i &lt; n; i++) { if ((!swap &amp;&amp; obstacleGrid[n-i-1][m-1]) || (swap &amp;&amp; obstacleGrid[m-1][n-1-i])) { v[0] = 0; } else { v[0] = t_v0; } t_v0 = v[0]; for(int j = 1; j &lt; m; j++) { if ((!swap &amp;&amp; obstacleGrid[n-i-1][m-1-j]) || (swap &amp;&amp; obstacleGrid[m-1-j][n-1-i])) { v[j] = 0; } else { v[j] += v[j-1]; } } } return (int)v[m-1]; }}; ä¼˜åŒ–1ä¸éœ€è¦è½¬ç½®ï¼Œè¿™ä¸ªé—®é¢˜æ¥è‡ªäºè¯•é”™è¿‡ç¨‹ä¸­çš„é”™è¯¯åˆ¤æ–­çœ‹äº†é¢˜è§£ä»¥åå‘ç°è‡ªå·±çš„ä»£ç å’Œå®ƒæƒŠäººçš„ç›¸ä¼¼ï¼ŒåŸæ¥æˆ‘æ— å¸ˆè‡ªé€šå­¦ä¼šåŠ¨è§„äº†ï¼Ÿï¼Ÿå“ˆå“ˆå“ˆå“ˆ ä¼˜åŒ–1ä»£ç 12345678910111213141516171819202122232425class Solution {public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) { int n = int(obstacleGrid.size()); int m = int(obstacleGrid[0].size()); vector&lt;long long&gt; v(m+1, 0); long long t_v0 = 1; for (int i = 0; i &lt; n; i++) { if (obstacleGrid[n-i-1][m-1]) { v[0] = 0; } else { v[0] = t_v0; } t_v0 = v[0]; for(int j = 1; j &lt; m; j++) { if (obstacleGrid[n-i-1][m-1-j]) { v[j] = 0; } else { v[j] += v[j-1]; } } } return (int)v[m-1]; }};","link":"/home/2020/07/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9310/"},{"title":"LeetCode-14","text":"927. ä¸‰ç­‰åˆ†123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution {public: vector&lt;int&gt; threeEqualParts(vector&lt;int&gt;&amp; arr) { int sum = countOne(arr); int len = arr.size(); if(sum % 3 != 0) { return {-1,-1}; } if(sum == 0) { return {0, len -1}; } int p1,p2,p3; p1 = p2 = p3 = 0; int i = 0; int cur = 0; while(i &lt; len) { if(arr[i] == 1) { if(cur == 0) { p1 = i; } else if(cur == sum/3) { p2 = i; } else if(cur == 2*sum/3) { p3 = i; } cur++; } i++; } //æŠŠ1å¹³å‡åˆ†æˆ3ä»½ï¼Œp1 p2 p3åˆ†åˆ«æ‰¾åˆ°ä¸‰æ®µçš„ç¬¬ä¸€ä¸ª1çš„ä½ç½® // printf(&quot;%d %d %d\\n&quot;, p1, p2, p3); int x = p1,y = p2,z = p3; int farclen = len - p3; if(p1 + farclen &gt; p2 || p2 + farclen &gt; p3) { return {-1, -1}; } while(x &lt; p2 &amp;&amp; y &lt; p3 &amp;&amp; z &lt; len) { if(arr[x] != arr[y] || arr[y] != arr[z]) { return {-1, -1}; } x++;y++;z++; } // printf(&quot;%d %d %d\\n&quot;, x, y, z); return {p1+farclen-1, p2+farclen}; } int countOne(vector&lt;int&gt;&amp; arr) { int count = 0; for(int a : arr) { count += a; } return count; }}; éš¾ï¼Œçœ‹æ‡‚è§£ææ€è·¯åæ‰å†™å‡ºæ¥çš„ åˆšå¼€å§‹çš„æ€è·¯æ˜¯æ‰¾0ï¼ŒæŠŠ1åˆ†æˆäº†næ®µï¼Œå–n/3 , 2n/3å’Œ næ®µåé¢çš„0ï¼Œç„¶åå‘å³ç§»åŠ¨åŒæŒ‡é’ˆæ¯”è¾ƒ åæ¥å‘ç°æœ‰è¶…çº§é•¿çš„è¾“å…¥ï¼Œè¶…æ—¶äº† è§£æçš„æ€è·¯ä¸æˆ‘åˆšå¥½ç›¸åï¼Œå…ˆæ•°1çš„ä¸ªæ•°ï¼Œå¦‚æœæ˜¯0æˆ–è€…ä¸èƒ½è¢«3æ•´é™¤ï¼Œè¯´æ˜ä¸èƒ½åˆ†æˆä¸‰æ®µ 1çš„ä¸ªæ•°ä¸ºnï¼Œæ‰¾åˆ°ç¬¬0 n/3 2n/3ä¸ª1ï¼Œè®°ä¸ºp1, p2, p3 p3åˆ°åæœ«å°¾çš„é•¿åº¦å°±æ˜¯ä¸‰ä¸ªå­ä¸²çš„é•¿åº¦ï¼Œå¦‚æœp1 æˆ– p2 + å­—ä¸²é•¿åº¦åˆ†åˆ«å¤§äºp2 p3ï¼Œè¯´æ˜æ— è§£ ç„¶åå‘åæ¯”è¾ƒï¼Œè‹¥åé¢çš„æ•°å®Œå…¨ç›¸åŒåˆ™æœ‰è§£ 1636. æŒ‰ç…§é¢‘ç‡å°†æ•°ç»„å‡åºæ’åº123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; frequencySort(vector&lt;int&gt;&amp; nums) { int freq[205] = {0}; for(int v : nums) { freq[100+v]++; } int invfreq[205][205] = {0}; int count[205] = {0}; for(int i = 0; i &lt; 205; i++) { invfreq[freq[i]][count[freq[i]]++] = i-100; } int numsc = 0; for(int i = 1; i &lt; 205; i++) { for(int j = count[i]-1; j &gt;= 0; j--) { //printf(&quot;%d %d\\n&quot;, i, invfreq[i][j]); for(int k = 0; k &lt; i; k++) { nums[numsc++] = invfreq[i][j]; } } } return nums; }}; ç®€å•ï¼Œä½†æ˜¯è¿˜æ˜¯é”™äº†å‡ æ¬¡ï¼ˆæ²¡è®¤çœŸè¯»é¢˜ï¼Œæ²¡å‘ç°åŒé¢‘ç‡çš„è¦é™åºæ’åˆ—ï¼‰ å…ˆç”¨mapè®¡ç®—æ¯ä¸ªæ•°å­—çš„å‡ºç°æ¬¡æ•°ï¼Œhashä¸º100+i å†æŠŠmapåšå€’æ’ç´¢å¼•ï¼Œç”±äºhashæ˜¯100+iï¼Œé‚£ä¹ˆå€’æ’åçš„ç´¢å¼•ä¹Ÿè‡ªç„¶ä»¥å‡åºæ’å¥½åºäº† æ ¹æ®å€’æ’ç´¢å¼•è¿›è¡Œè¾“å‡ºã€‚ 1624. ä¸¤ä¸ªç›¸åŒå­—ç¬¦ä¹‹é—´çš„æœ€é•¿å­å­—ç¬¦ä¸²1234567891011121314151617181920212223242526class Solution {public: int maxLengthBetweenEqualCharacters(string s) { int left[26] = {0}; int right[26] = {0}; int len = s.size(); for(int i = 0; i &lt; len; i++) { if(left[s[i]-'a'] == 0) { left[s[i]-'a'] = i+1; } } for(int i = len-1; i &gt;= 0; i--) { if(right[s[i]-'a'] == 0) { right[s[i]-'a'] = i+1; } } int max = 0; int flag = false; for(int i = 0; i &lt; 26; i++) { int x = right[i] - left[i] - 1; max = max &gt; x ? max : x; if(x+1 &gt; 0) flag = true; } return flag ? max : -1; }}; ç®€å•ï¼Œæ•°ä¸€ä¸‹æ¯ä¸ªå­—æ¯ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®å’Œæœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼Œç›¸å‡-1å–æœ€å¤§å€¼ï¼Œå†å¯¹ä¸å­˜åœ¨çš„æƒ…å†µè¿›è¡Œç‰¹æ®Šæ ‡è®°ï¼Œä¹Ÿå°±æ˜¯æ‰€æœ‰å­—æ¯ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®å’Œæœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½®å…¨éƒ½ç›¸åŒçš„æƒ…å†µ 827. æœ€å¤§äººå·¥å²›ä¼˜åŒ–åˆ°æœ€çŸ­çš„ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution { int indexMap[505][505] = {0}; //å²›å±¿ç‚¹ï¼Œå¯¹åº”ä¸€ä¸ªå²› int areaMap[505*505] = {0}; //å²›å±¿ç‚¹ï¼Œå¯¹åº”ä¸€ä¸ªå²› int n; const vector&lt;int&gt; d = {0, -1, 0, 1, 0};public: int largestIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { n = grid.size(); int islandCount = 0; int max2area = 0; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(grid[i][j] == 1) { if(indexMap[i][j] == 0) { indexMap[i][j] == ++islandCount; dfs(grid, i, j, islandCount); max2area = max2area &gt; areaMap[islandCount] ? max2area : areaMap[islandCount]; } } } } for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { unordered_set&lt;int&gt; neighbour; int areai = 1; if(grid[i][j] == 0) { for(int k = 0; k &lt; 4; k++) { if(valid(i, j , k) &amp;&amp; grid[i + d[k]][j + d[k+1]] == 1) { if(neighbour.count(indexMap[i + d[k]][j + d[k+1]]) == 0) { areai += areaMap[indexMap[i + d[k]][j + d[k+1]]]; neighbour.insert(indexMap[i + d[k]][j + d[k+1]]); } } } max2area = max2area &gt; areai ? max2area : areai; } } } return max2area; } bool valid(int i, int j, int k) { int x = i + d[k]; int y = j + d[k+1]; return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &lt; n; } void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, int index) { if(indexMap[x][y] != 0) return; indexMap[x][y] = index; areaMap[index]++; for(int k = 0; k &lt; 4; k++) { if(valid(x, y, k) &amp;&amp; grid[x + d[k]][y + d[k+1]] == 1) { dfs(grid, x + d[k], y + d[k+1], index); } } }}; ä½†æ˜¯è¿™æ ·æ•ˆç‡ç‰¹åˆ«ä½ï¼Œä¸»è¦æ˜¯validå‡½æ•°å¤ªä½ä¸‹äº† ä¸ç”¨valid12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Solution {private: int indexMap[505][505] = {0}; //å²›å±¿ç‚¹ï¼Œå¯¹åº”ä¸€ä¸ªå²› int areaMap[505*505] = {0}; //å²›å±¿ç‚¹ï¼Œå¯¹åº”ä¸€ä¸ªå²› int n;public: int largestIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { n = grid.size(); int islandCount = 0; bool find0 = false; bool find1 = false; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(grid[i][j] == 1) { find1 = true; if(indexMap[i][j] == 0) { ++islandCount; indexMap[i][j] == islandCount; dfs(grid, i, j, islandCount); } } else { find0 = true; } } } int max2area = 0; if(!find0 &amp;&amp; find1) return n*n; if(find0 &amp;&amp; !find1) return 1; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { set&lt;int&gt; neighbour; int areai = 1; if(grid[i][j] == 0) { if(j-1 &gt;= 0 &amp;&amp; grid[i][j-1] == 1) { neighbour.insert(indexMap[i][j-1]); } if(i-1 &gt;= 0 &amp;&amp; grid[i-1][j] == 1) { neighbour.insert(indexMap[i-1][j]); } if(j+1 &lt; n &amp;&amp; grid[i][j+1] == 1) { neighbour.insert(indexMap[i][j+1]); } if(i+1 &lt; n &amp;&amp; grid[i+1][j] == 1) { neighbour.insert(indexMap[i+1][j]); } for(set&lt;int&gt;::iterator ite = neighbour.begin(); ite != neighbour.end(); ite++) { areai += areaMap[*ite]; } max2area = max2area &gt; areai ? max2area : areai; } } } return max2area; } void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, int index) { if(indexMap[x][y] != 0) return; indexMap[x][y] = index; areaMap[index]++; if(y-1 &gt;= 0 &amp;&amp; grid[x][y-1] == 1) { dfs(grid, x, y-1, index); } if(y+1 &lt; n &amp;&amp; grid[x][y+1] == 1) { dfs(grid, x, y+1, index); } if(x+1 &lt; n &amp;&amp; grid[x+1][y] == 1) { dfs(grid, x+1, y, index); } if(x-1 &gt;= 0 &amp;&amp; grid[x-1][y] == 1) { dfs(grid, x-1, y, index); } }}; é¦–æ¬¡é€šè¿‡çš„ä»£ç ï¼Œæ¯”è¾ƒå†—é•¿123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110class Solution {private: struct Island { int area; int index; Island(int a, int i):area(a), index(i) {} }; bool edgeMap[505][505]; //è¾¹ç•Œç‚¹ï¼Œå¯¹åº”çš„å“ªä¸ªå²› Island* islandMap[505][505]; //å²›å±¿ç‚¹ï¼Œå¯¹åº”ä¸€ä¸ªå²› // vector&lt;Island*&gt; allIsland; //æ–¹ä¾¿å›æ”¶å†…å­˜ int n;public: int largestIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { n = grid.size(); int island_count = 0; bool find0 = false; bool find1 = false; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(grid[i][j] == 1) { find1 = true; Island *island = nullptr; if(islandMap[i][j] == nullptr) { island = new Island(0, island_count++); dfs(grid, i, j, island); } else { island = islandMap[i][j]; } if(j-1 &gt;= 0 &amp;&amp; grid[i][j-1] == 0) { edgeMap[i][j-1] = true; } if(i-1 &gt;= 0 &amp;&amp; grid[i-1][j] == 0) { edgeMap[i-1][j] = true; } } else { find0 = true; Island *island = nullptr; if(j-1 &gt;= 0 &amp;&amp; grid[i][j-1] == 1) { edgeMap[i][j] = true; } if(i-1 &gt;= 0 &amp;&amp; grid[i-1][j] == 1) { edgeMap[i][j] = true; } } } } // int max_area = 0; int max2area = 0; if(!find0 &amp;&amp; find1) return n*n; if(find0 &amp;&amp; !find1) return 1; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { set&lt;Island*&gt; neighbour; int areai = 1; if(edgeMap[i][j]) { if(j-1 &gt;= 0 &amp;&amp; grid[i][j-1] == 1) { Island *island = islandMap[i][j-1]; neighbour.insert(island); } if(i-1 &gt;= 0 &amp;&amp; grid[i-1][j] == 1) { Island *island = islandMap[i-1][j]; neighbour.insert(island); } if(j+1 &lt; n &amp;&amp; grid[i][j+1] == 1) { Island *island = islandMap[i][j+1]; neighbour.insert(island); } if(i+1 &lt; n &amp;&amp; grid[i+1][j] == 1) { Island *island = islandMap[i+1][j]; neighbour.insert(island); } for(set&lt;Island*&gt;::iterator ite = neighbour.begin(); ite != neighbour.end(); ite++) { areai += (*ite)-&gt;area; } max2area = max2area &gt; areai ? max2area : areai; } } } return max2area; // return max_area &gt; max2area ? max_area : max2area; } void addDot(int x, int y) { edgeMap[x][y] = true; } void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, Island *island) { if(islandMap[x][y] != nullptr) return; islandMap[x][y] = island; island-&gt;area++; // printf(&quot;add %p x=%d y=%d, area=%d\\n&quot;, island, x, y, island-&gt;area); if(y-1 &gt;= 0 &amp;&amp; grid[x][y-1] == 1) { dfs(grid, x, y-1, island); } if(y+1 &lt; n &amp;&amp; grid[x][y+1] == 1) { dfs(grid, x, y+1, island); } if(x+1 &lt; n &amp;&amp; grid[x+1][y] == 1) { dfs(grid, x+1, y, island); } if(x-1 &gt;= 0 &amp;&amp; grid[x-1][y] == 1) { dfs(grid, x-1, y, island); } }}; å†™äº†å¾ˆä¹…ï¼Œå…¶å®å’Œé¢˜è§£çš„æ€è·¯æ˜¯ä¸€æ¨¡ä¸€æ ·çš„","link":"/home/2022/10/22/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9314/"},{"title":"LeetCode-13","text":"1640. èƒ½å¦è¿æ¥å½¢æˆæ•°ç»„123456789101112131415161718192021222324class Solution {public: bool canFormArray(vector&lt;int&gt;&amp; arr, vector&lt;vector&lt;int&gt;&gt;&amp; pieces) { int arr_map[105] = {0}; int len_arr = arr.size(); for(int i = 0; i &lt; len_arr; i++) { arr_map[arr[i]] = i+1; } int pie_len = pieces.size(); for(int i = 0; i &lt; pie_len; i++) { int i_len = pieces[i].size(); int diff = arr_map[pieces[i][0]]; if(diff == 0) { return false; } for(int j = 1; j &lt; i_len; j++) { if(diff != arr_map[pieces[i][j]] - j) { return false; } } } return true; }}; 4msï¼Œå’Œæœ€å¿«çš„æ€è·¯åˆšå¥½ç›¸åï¼Œç”¨mapå­˜å‚¨arrçš„indexï¼Œæœ€å¿«çš„æ€è·¯æ˜¯åè¿‡æ¥ï¼Œç”¨mapå­˜ä¸€ä¸ªpieceçš„ç¬¬ä¸€ä¸ªindex 123456789101112131415161718192021222324class Solution {public: bool canFormArray(vector&lt;int&gt;&amp; arr, vector&lt;vector&lt;int&gt;&gt;&amp; pieces) { int arr_map[105] = {0}; int len_arr = arr.size(); int pie_len = pieces.size(); for(int i = 0; i &lt; pie_len; i++) { arr_map[pieces[i][0]] = i+1; } int i = 0; while(i &lt; len_arr) { int row = arr_map[arr[i]]; if(row == 0) return false; vector&lt;int&gt;&amp; subv = pieces[row-1]; int i_len = subv.size(); for(int j = 0; j &lt; i_len; j++, i++) { if(arr[i] != subv[j]) { return false; } } } return true; }}; 707. è®¾è®¡é“¾è¡¨12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273struct List { List *next; int val; List(int val0, List* next0 = nullptr):val(val0), next(next0) {}};class MyLinkedList {private: List *root; List *tail; int size; inline List* getNode(int&amp; index) { List *move = root; while(index &gt; 0 &amp;&amp; move-&gt;next != nullptr) { move = move-&gt;next; index--; } return move; }public: MyLinkedList() { root = new List(0); tail = root; size = 0; } int get(int index) { List *move = getNode(index); return (move-&gt;next == nullptr) ? -1 : move-&gt;next-&gt;val; } void addAtHead(int val) { List* node = new List(val, root-&gt;next); root-&gt;next = node; if(root == tail) { tail = node; } size++; } void addAtTail(int val) { List* node = new List(val, tail-&gt;next); tail-&gt;next = node; tail = node; size++; } void addAtIndex(int index, int val) { List *move = getNode(index); if(index &gt; 0) { return; } List* node = new List(val, move-&gt;next); move-&gt;next = node; if(move == tail) { tail = node; } size++; } void deleteAtIndex(int index) { List *move = getNode(index); List *target = move-&gt;next; if(target != nullptr) { move-&gt;next = target-&gt;next; if(target == tail) { tail = move; } delete target; size--; } }}; 60ms -&gt; 36ms ä¹‹å‰å†…éƒ¨å‡½æ•°getNodeæœ‰ä¸¤ä¸ªå‚æ•°ï¼Œç¬¬äºŒä¸ªå‚æ•°offç”¨äºè¿”å›indexå’Œæ‰¾åˆ°çš„èŠ‚ç‚¹çš„è·ç¦»å·®è·ã€‚å°†è¿™ä¸ªå‚æ•°ä¼˜åŒ–æ‰ï¼Œç»´æŠ¤ä¸€ä¸ªsizeæ›¿ä»£ã€‚ 1652. æ‹†ç‚¸å¼¹12345678910111213141516171819202122232425262728293031323334353637class Solution {public: vector&lt;int&gt; decrypt(vector&lt;int&gt;&amp; code, int k) { int len = code.size(); if(k &gt; 0) { vector&lt;int&gt; after(len, 0); for(int i = 0; i &lt; k; i++) { after[0] += code[(i+1)%len]; } for(int i = 1; i &lt; len; i++) { if(i + k &lt; len) { after[i] = after[i-1] - code[i] + code[(i+k)]; } else { after[i] = after[i-1] - code[i] + code[(i+k)- len]; } // cout &lt;&lt; (i+k+1)%len &lt;&lt; &quot; &quot; &lt;&lt; code[(i+k)%len] &lt;&lt; endl; } return after; } if(k &lt; 0) { vector&lt;int&gt; before(len, 0); for(int i = 0; i &lt; -k; i++) { before[0] += code[(i + k + len)%len]; } for(int i = 1; i &lt; len; i++) { if ((i -1 + k) &gt;= 0) { before[i] = before[i-1] - code[(i -1 + k)] + code[i-1]; } else { before[i] = before[i-1] - code[(i -1 + k + len)] + code[i-1]; } // cout &lt;&lt; (i+k+len)%len &lt;&lt; endl; } return before; } return vector&lt;int&gt;(len, 0); }}; 4ms -&gt; 0ms ä¹‹å‰ä½¿ç”¨å–ä½™è¾¾åˆ°é¢˜ç›®æ‰€è¯´çš„â€œå¾ªç¯æ•°ç»„â€çš„æ•ˆæœï¼Œåæ¥çœ‹é¢˜è§£ä¸Šç›´æ¥æŠŠæ•°ç»„copyä¸€ä»½ï¼Œåˆ›å»ºä¸€ä¸ª2né•¿çš„æ•°ç»„é¿å…è¶Šç•Œã€‚è¿™é‡Œä¸å–ä½™ï¼Œè¶Šç•Œåç›´æ¥åŠ æˆ–å‡å»æ•°ç»„é•¿åº¦ã€‚ 788. æ—‹è½¬æ•°å­—123456789101112131415161718192021222324252627class Solution {public: int rotatedDigits(int n) { int goodDigits[10] = {0, 1, 5, -1, -1, 2, 9, -1, 8, 6}; int count = 0; for(int i = 1; i &lt;= n; i++) { bool flag1 = false; bool flag2 = false; int cur_i = i; while(cur_i != 0) { int mod = cur_i % 10; if(goodDigits[mod] != mod) { flag1 = true; } if(goodDigits[mod] == -1) { flag2 = true; } cur_i /= 10; } if(flag1 &amp;&amp; !flag2) { count++; // printf(&quot;%d, &quot;, i); } } return count; }}; ç¬¬ä¸€æ¬¡æäº¤æ²¡æœ‰æ³¨æ„è¯»é¢˜ï¼Œæ•°å­—çš„æ¯ä¸€ä½éƒ½è¦èƒ½åè½¬ï¼Œä¸”è‡³å°‘æœ‰ä¸€ä½åè½¬åä¸åŸæ¥ä¸åŒï¼Œå¯¼è‡´é€»è¾‘é”™è¯¯ã€‚ é¢è¯•é¢˜ 17.19. æ¶ˆå¤±çš„ä¸¤ä¸ªæ•°å­—12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution {public: vector&lt;int&gt; missingTwo(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int a = -1,b = -1; for(int i = 0; i &lt; len; i++) { while(nums[i] - 1 != i &amp;&amp; nums[i] != -1) { if(nums[i]-1 == len) { swap(nums[i], a); } else if(nums[i]-1 == len+1) { swap(nums[i], b); } else { swap(nums[i], nums[nums[i] - 1]); } } } while(a - 1 != len &amp;&amp; a != -1) { if(a-1 == len) { swap(a, a); } else if(a-1 == len+1) { swap(a, b); } else { swap(a, nums[a - 1]); } } while(b - 1 != len+1 &amp;&amp; b != -1) { if(b-1 == len) { swap(b, a); } else if(b-1 == len+1) { swap(b, b); } else { swap(b, nums[b - 1]); } } vector&lt;int&gt; ret(2); int count = 0; for(int i = 0; i &lt; len; i++) { if(nums[i] - 1 != i) { ret[count] = i+1; count++; if(count &gt;= 2) break; } } if(count &lt; 2 &amp;&amp; a-1 != len) { ret[count] = len+1; count++; } if(count &lt; 2 &amp;&amp; b-1 != len) { ret[count] = len+2; count++; } return ret; } void inline swap(int &amp;a, int &amp;b) { int temp = a; a = b; b = temp; }}; ä¹‹å‰åšè¿‡ç±»ä¼¼çš„é¢˜ç›®ï¼Œæ•°å­—æ˜¯1 - Nï¼Œå°±æŠŠä»–ä»¬ä¸€ç›´äº¤æ¢ï¼Œæ•°å­—Nå°±æ”¾åˆ°ä½ç½®Nï¼Œç›´åˆ°å½“å‰å¾ªç¯è®¡æ•°å˜é‡içš„ä½ç½®å¯¹åº”çš„æ•°å­—å’Œiç›¸åŒæˆ–ä¸º-1 æ³¨æ„åˆ°å‚æ•°ä¼ å…¥çš„æ•°ç»„åªæœ‰N-2çš„é•¿åº¦ï¼Œè€Œé¢˜ç›®è¦æ±‚ä½¿ç”¨ç©ºé—´O(1)çš„åŸåœ°ç®—æ³•ï¼Œåˆ›å»ºä¸¤ä¸ªå˜é‡a, bå¹¶èµ‹åˆå€¼ä¸º-1ï¼Œåˆ†åˆ«ä½œä¸ºåŸæ¥æ•°ç»„çš„å»¶é•¿ï¼Œé‡åˆ°è¿™ä¸¤ä¸ªä½ç½®æ—¶è¿›è¡Œç‰¹æ®Šåˆ¤æ–­ã€‚ åæ¥çœ‹ä»£ç çš„æ—¶å€™å‘ç°ç¬¬48è¡Œçš„åˆ¤æ–­å†™é”™äº†ï¼Œåº”è¯¥æ˜¯count &lt; 2 &amp;&amp; b-1 != len+1ï¼Œä½†æ˜¯ä»£ç ä¾æ—§é€šè¿‡æµ‹è¯•äº†ï¼Œçœ‹æ¥æµ‹è¯•æ ·ä¾‹è¿˜æ˜¯ä¸å¤Ÿå…¨ã€‚ é¢è¯•é¢˜ 01.02. åˆ¤å®šæ˜¯å¦äº’ä¸ºå­—ç¬¦é‡æ’123456789101112131415161718class Solution {public: bool CheckPermutation(string s1, string s2) { int len = s1.size(); if(len != s2.size()) return false; int m1[26] = {0}, m2[26] = {0}; for(int i = 0; i &lt; len; i++) { m1[s1[i]-'a']++; m2[s2[i]-'a']++; } for(int i = 0; i &lt; 26; i++) { if(m1[i] != m2[i]) { return false; } } return true; }}; ç®€å•é¢˜ï¼Œç›´æ¥ç»Ÿè®¡å­—æ¯é¢‘ç‡å°±å¥½ é¢è¯•é¢˜ 17.09. ç¬¬ k ä¸ªæ•°123456789101112131415161718192021222324252627class Solution {public: int getKthMagicNumber(int k) { vector&lt;int&gt; kth(k); int p1,p2,p3; p1 = p2 = p3 = 0; kth[0] = 1; for(int i = 1; i &lt; k; i++) { int a, b,c; // printf(&quot;%d %d %d %d\\n&quot;, p1, p2, p3, i); a = kth[p1] * 3; b = kth[p2] * 5; c = kth[p3] * 7; kth[i] = min(a, min(b,c)); if(kth[i] == a) { p1++; } if(kth[i] == b) { p2++; } if(kth[i] == c) { p3++; } } return kth[k-1]; }}; æ¯”è¾ƒéš¾ï¼Œå°è¯•äº†å¾ˆå¤šæ¬¡ï¼Œæœ€åçœ‹é¢˜è§£æ‰å†™å‡ºæ¥ã€‚ åˆšå¼€å§‹æƒ³å…ˆç”¨ç´ æ•°ç­›ç®—å‡ºè¶³å¤Ÿçš„ç´ æ•°ï¼Œå†åˆ©ç”¨ç´ æ•°æ•°ç»„ï¼Œä»1ï¼Œ3ï¼Œ5ï¼Œ7ä¹‹åå¼€å§‹ï¼Œæ‰€æœ‰çš„éç´ æ•°å¥‡æ•°ä¸­ä¸€ä¸ªä¸ªç­›é€‰å‡ºä¸å«æœ‰é™¤3ï¼Œ5ï¼Œ7å¤–å…¶ä»–ç´ æ•°çš„æ•°ã€‚ä½†æ˜¯åæ¥å‘ç°è¿™æ ·ä¼šè¶…æ—¶ï¼Œæ ·ä¾‹è¾“å…¥251æ—¶éœ€è¦350ä¸‡ä¸ªç´ æ•°ï¼Œå…‰æ˜¯ç®—ç´ æ•°å°±å·²ç»è¶…æ—¶äº†ã€‚ æœ€åæ‰ç”¨äº†é¢˜è§£çš„dpï¼Œæ¯æ¬¡ç®—å‡ºä¸€ä¸ªï¼Œå¦‚æœæ˜¯ä¹˜3å°±æŠŠ3çš„æŒ‡é’ˆå‘åç§»ï¼Œ5å’Œ7åŒç†ï¼Œè¿™æ ·å°±å¯ä»¥é€ä¸ªç”±å°åˆ°å¤§ç®—å‡ºç¬¬kä¸ªæ•°ã€‚ é¢è¯•é¢˜ 01.09. å­—ç¬¦ä¸²è½®è½¬12345678910111213141516171819202122class Solution {public: bool isFlipedString(string s1, string s2) { int len = s1.size(); int i = 0; if(len == 0) return true; for(i; i &lt; len; i++) { bool flag = true; for(int j = 0; j &lt; len; j++) { if(s1[(i+j)%len] != s2[j]) { flag = false; break; } } if(flag) { return true; } } return false; }}; æœ€å¼€å§‹æš´åŠ›ç›´æ¥æœï¼Œçœ‹äº†é¢˜è§£åå¯ä»¥æ„é€ string s = s1 + s1ï¼Œç„¶åä½¿ç”¨kmpæœç´¢sä¸­æ˜¯å¦æœ‰s2å­ä¸² é¢è¯•é¢˜ 01.08. é›¶çŸ©é˜µ1234567891011121314151617181920212223242526272829class Solution {public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int m = matrix.size(); if(m &lt;= 0) return; int n = matrix[0].size(); vector&lt;bool&gt; r(m, false), c(n, false); // bool r[10000] = {false}, c[10000] = {false}; for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; n; j++) { if(matrix[i][j] == 0) { r[i] = true; c[j] = true; } } } for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; n; j++) { if(r[i]) { matrix[i][j] = 0; } if(c[j]) { matrix[i][j] = 0; } } } }}; ç®€å•é¢˜ï¼Œç›´æ¥è®°å½•æŸè¡ŒæŸåˆ—æ˜¯å¦æœ‰0ï¼Œç„¶åæ ¹æ®æ¯è¡Œæ¯åˆ—çš„flagæ›´æ–°å°±å¥½äº† 1694. é‡æ–°æ ¼å¼åŒ–ç”µè¯å·ç 1234567891011121314151617181920212223242526272829303132class Solution {public: string reformatNumber(string number) { string ret; int len = number.size(); int count_n = 0; int count = 0; for(int i = 0; i &lt; len; i++) { if(number[i] &gt;= '0' &amp;&amp; number[i] &lt;= '9') { ret.push_back(number[i]); count++; if(count%3 == 0) { ret.push_back('-'); } count_n = count%3; } } // printf(&quot;%d %d\\n&quot;, count_n, count); if(count_n == 0) { ret.pop_back(); } else if(count_n == 1 &amp;&amp; count &gt;= 3) { int off = count / 3; count += off; char t = ret[count-2]; ret[count-2] = ret[count-3]; ret[count-3] = t; // printf(&quot;%c %c\\n&quot;, ret[count-2], ret[count-3]); } return ret; }}; ç®€å•é¢˜ï¼Œç¬¬ä¸€æ¬¡æäº¤æ—¶å¿˜è®°ä¹‹å‰æ·»åŠ è¿‡å­—ç¬¦-,æƒ³é€šè¿‡æœ€åä½™æ•°å¯¹ç»“å°¾4ä¸ªçš„å­—ç¬¦çš„æƒ…å†µè¿›è¡Œç‰¹æ®Šå¤„ç†ï¼Œç›´æ¥ç”¨å­—ç¬¦çš„è®¡æ•°å™¨countå¿˜è®°åŠ ä¸Šæ·»åŠ çš„-çš„ä¸ªæ•° 777. åœ¨LRå­—ç¬¦ä¸²ä¸­äº¤æ¢ç›¸é‚»å­—ç¬¦12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution {public: int len; bool canTransform(string start, string end) { int i,j = 0; int len = start.size(); if(end.size() != len) { return false; } char t[10005] = {0}; int t_i = 0; for(char c: start) { if(c != 'X') { t[t_i] = c; t_i++; } } int t_len = t_i; t_i = 0; for(char c : end) { if(c == 'X') { continue; } if(t_i &lt; t_len &amp;&amp; c == t[t_i]) { t_i++; } else { return false; } } if(t_i != t_len) return false; while(j &lt; len) { if(end[j] == 'L') { int it = j; while(it &lt; len &amp;&amp; start[it] == 'X') { it++; } if(it &lt; len &amp;&amp; start[it] == 'L') { char temp_c = start[it]; start[it] = start[j]; start[j] = temp_c; } else { return false; } } else if(end[j] == 'R') { int it = j; while(it &gt;= 0 &amp;&amp; start[it] == 'X') { it--; } if(it &gt;= 0 &amp;&amp; start[it] == 'R') { char temp_c = start[it]; start[it] = start[j]; start[j] = temp_c; } else { return false; } } else { } j++; } return j == len &amp;&amp; start[j-1] == end[len-1]; }}; æ¯”è¾ƒéš¾ ç¬¬ä¸€æ¬¡çš„æ€è·¯æ˜¯ç›´æ¥å¿½ç•¥Xï¼Œæ¯”è¾ƒLå’ŒRçš„åºåˆ—æ˜¯å¦ç›¸åŒï¼Œè¿™ä¸ªæ˜¾ç„¶æ˜¯æ²¡æœ‰å®Œå…¨è€ƒè™‘å®Œå…¨ ç¬¬äºŒæ¬¡æ‰“ç®—è¿›è¡Œæœç´¢ï¼Œç”Ÿæˆæ‰€æœ‰å·¦ç§»å³ç§»åçš„æƒ…å†µï¼Œå’Œendè¿›è¡Œå¯¹æ¯”ï¼Œä½†æ˜¯æ²¡æœ‰è€ƒè™‘åˆ°Lï¼ŒRå¯ä»¥å¤šæ¬¡ç§»åŠ¨ï¼ŒLå¤šæ¬¡ç§»åŠ¨çš„è¯å°±è¦è¿›è¡Œå¤šæ¬¡çš„å›æº¯ï¼Œéå¸¸éº»çƒ¦ ç¬¬ä¸‰æ¬¡çœŸæ­£ç†è§£é¢˜æ„ï¼Œæ ¹æ®endå¯¹startè¿›è¡Œç§»åŠ¨ï¼Œåœ¨ç»“åˆç¬¬ä¸€æ¬¡çš„æ€è·¯æ¯”è¾ƒä¸€ä¸‹å¿½ç•¥Xçš„LRåºåˆ—æ˜¯å¦å®Œå…¨ç›¸åŒã€‚ 1784. æ£€æŸ¥äºŒè¿›åˆ¶å­—ç¬¦ä¸²å­—æ®µ1234567891011121314class Solution {public: bool checkOnesSegment(string s) { int count = 0; int i = 0; int length = s.size(); while(i &lt; length) { while(i &lt; length &amp;&amp; s[i] == '1') i++; count++; while(i &lt; length &amp;&amp; s[i] == '0') i++; } return count &lt;= 1; }}; ç®€å•ï¼Œæœ‰æ‰‹å°±è¡Œï¼Œå°±æ˜¯ç»Ÿè®¡æœ‰å‡ ç¾¤è¿ç»­çš„1 921. ä½¿æ‹¬å·æœ‰æ•ˆçš„æœ€å°‘æ·»åŠ 12345678910111213141516171819class Solution {public: int minAddToMakeValid(string s) { stack&lt;char&gt; sta; int count = 0; for(char c : s) { if(c == '(') { sta.push(c); } else { if(sta.empty()) { count++; } else { sta.pop(); } } } return count + sta.size(); }}; é¢˜ç›®çš„æ ·ä¾‹å¥½åƒæœ‰é”™è¯¯è¿˜æ˜¯æˆ‘æ²¡çœ‹æ‡‚ï¼Œæ€»ä¹‹æ˜¯æ‹¬å·åŒ¹é…ï¼Œé—®æœ‰å‡ ä¸ªä¸åŒ¹é…çš„ æ¯æ¬¡å‡ºç°å³æ‹¬å·ä¸”æ²¡æœ‰å·¦æ‹¬å·åŒ¹é…æ—¶ï¼Œè®¡æ•°å™¨++ï¼Œå­—ç¬¦ä¸²å˜é‡ç»“æŸåï¼Œåœ¨åŠ ä¸Šæ ˆä¸­å‰©ä½™çš„æ²¡åŒ¹é…çš„å·¦æ‹¬å·çš„ä¸ªæ•°å°±å¥½äº†ã€‚ 811. å­åŸŸåè®¿é—®è®¡æ•°12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;string&gt; subdomainVisits(vector&lt;string&gt;&amp; cpdomains) { unordered_map&lt;string, int&gt; m; for(string&amp; s : cpdomains) { char domain[105] = {0}; int num; sscanf(s.c_str(), &quot;%d %s&quot;, &amp;num, domain); int length = strlen(domain); int i = 0; m[domain] +=num; while(i &lt; length) { while(i &lt; length &amp;&amp; domain[i] != '.') i++; if(i &gt;= length) break; char subdomain[105] = {0}; for(int j = 0; j &lt; length - i - 1; j++) { subdomain[j] = domain[i+1+j]; } m[subdomain] += num; i++; } } vector&lt;string&gt; v; for(unordered_map&lt;string, int&gt;::iterator i = m.begin(); i != m.end(); i++) { char str[105] = {0}; sprintf(str, &quot;%d %s&quot;, i-&gt;second, i-&gt;first.c_str()); v.push_back(str); } return v; }}; æ¯”è¾ƒç®€å•ï¼Œæ‰¾ä¸ªmapç»Ÿè®¡æ¯ä¸ªåŸŸåçš„å‡ºç°ä¸ªæ•°å°±è¡Œï¼Œç„¶åä»å·¦å¾€å³æ‰¾.ï¼Œæ‰¾åˆ°åæ‹¿åˆ°å­ä¸²ï¼Œmapä¸­ç»Ÿè®¡æ‰€æœ‰å­ä¸²çš„å‡ºç°ä¸ªæ•°ã€‚","link":"/home/2022/10/22/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9313/"},{"title":"LeetCode-16","text":"934. æœ€çŸ­çš„æ¡¥1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution {public: int indexMap[105][105] = {0}; //å²›å±¿ç‚¹ï¼Œå¯¹åº”ä¸€ä¸ªå²› int n; int edgex[105*105] = {0}; int edgey[105*105] = {0}; int edgei[105*105] = {0}; int edgej[105*105] = {0}; int edgecount = 0; int edgeicount = 0; int shortestBridge(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { n = grid.size(); int islandCount = 0; int p1x,p1y; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(grid[i][j] == 1 &amp;&amp; indexMap[i][j] == 0) { ++islandCount; dfs(grid, i, j, islandCount); } } } int min=INT_MAX; for(int i = 0; i &lt; edgecount; i++) { for(int j = 0; j &lt; edgeicount; j++) { int path = abs(edgex[i]-edgei[j]) + abs(edgey[i] - edgej[j]) - 1; if(min &gt;= path) { min = path; } } } return min; } void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, int index) { if(x &lt; 0 || y &lt; 0 || x &gt;= n || y &gt;= n) return; if(indexMap[x][y] != 0 || grid[x][y] != 1) return; indexMap[x][y] = index; bool flag = (y-1 &gt;= 0 &amp;&amp; grid[x][y-1] == 0) || (y+1 &lt; n &amp;&amp; grid[x][y+1] == 0) || (x+1 &lt; n &amp;&amp; grid[x+1][y] == 0) || (x-1 &gt;= 0 &amp;&amp; grid[x-1][y] == 0); dfs(grid, x, y-1, index); dfs(grid, x, y+1, index); dfs(grid, x+1, y, index); dfs(grid, x-1, y, index); if(flag) { if(indexMap[x][y]==1) { edgex[edgecount]=x; edgey[edgecount]=y; edgecount++; } else if(indexMap[x][y]==2) { edgei[edgeicount]=x; edgej[edgeicount]=y; edgeicount++; } } }}; å’Œä¹‹å‰å†™çš„ä¸€é“é¢˜æœ‰ç‚¹åƒï¼Œ827. æœ€å¤§äººå·¥å²›827. æœ€å¤§äººå·¥å²›æˆ‘å…ˆdfsæ‰¾åˆ°æ‰€æœ‰è¿é€šå­å›¾å’ŒåŒ…å›´å²›çš„0ç‚¹ï¼Œç„¶åæ‰¾è¿™äº›ç‚¹ä¸­æœ‰æ— åŒæ—¶åŒ…å›´å¤šä¸ªå²›çš„ï¼ŒæŠŠä»–ä»¬çš„é¢ç§¯åŠ èµ·æ¥å–æœ€å¤§å€¼ è¿™é“é¢˜ä¹Ÿå¯ä»¥ä½¿ç”¨ç›¸åŒçš„æ–¹æ³•ï¼Œæ‰¾åˆ°æ¯ä¸ªå²›å±¿çš„è¾¹ç•Œç‚¹ï¼Œç„¶åè®¡ç®—è¾¹ç•Œç‚¹çš„è·ç¦»(åªæœ‰ä¸¤ä¸ªå²›ï¼Œä¸¤ä¸ªå²›ä¹‹é—´è‚¯å®šæ˜¯å¯ä»¥è¿é€šçš„ï¼Œä¸”ä¸ç®¡ä½¿ç”¨é‚£æ¡é€”å¾„ï¼Œæœ€çŸ­è·ç¦»ä¸€å®šæ˜¯ $ abs(x_1 - x_2) + abs(y_1-y_2)-1 $) çœ‹ç­”æ¡ˆ1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution {public: void dfs(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; grid, queue&lt;pair&lt;int, int&gt;&gt; &amp;qu) { if (x &lt; 0 || y &lt; 0 || x &gt;= grid.size() || y &gt;= grid[0].size() || grid[x][y] != 1) { return; } qu.emplace(x, y); grid[x][y] = -1; dfs(x - 1, y, grid, qu); dfs(x + 1, y, grid, qu); dfs(x, y - 1, grid, qu); dfs(x, y + 1, grid, qu); } int shortestBridge(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); vector&lt;vector&lt;int&gt;&gt; dirs = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}}; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (grid[i][j] == 1) { queue&lt;pair&lt;int, int&gt;&gt; qu; dfs(i, j, grid, qu); int step = 0; while (!qu.empty()) { int sz = qu.size(); for (int i = 0; i &lt; sz; i++) { auto [x, y] = qu.front(); qu.pop(); for (int k = 0; k &lt; 4; k++) { int nx = x + dirs[k][0]; int ny = y + dirs[k][1]; if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n) { if (grid[nx][ny] == 0) { qu.emplace(nx, ny); grid[nx][ny] = -1; } else if (grid[nx][ny] == 1) { return step; } } } } step++; } } } } return 0; }}; å¯¹äºä¸€ä¸ªä¸º1çš„ç‚¹ï¼Œå…ˆdfså§æ‰€æœ‰åœ¨åŒä¸€ä¸ªå²›å±¿å†…çš„1æ”¾å…¥é˜Ÿåˆ—qä¸­å¯¹äºé˜Ÿåˆ—ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹ï¼ŒæŠŠåŒ…å›´ä»–ä»¬çš„0å…¥é˜Ÿï¼Œåå¤æ“ä½œï¼Œç›´åˆ°é‡åˆ°1ä¹Ÿå°±æ˜¯åœ¨å²›å±¿é™„è¿‘ç”»åœˆï¼Œé‡åˆ°1å¯¹åº”çš„åœˆæ•°å°±æ˜¯ç»“æœã€‚ 915. åˆ†å‰²æ•°ç»„123456789101112131415161718192021222324252627282930class Solution {public: int partitionDisjoint(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; max(n+1); max[0] = INT_MIN; vector&lt;int&gt; min(n); min[n-1] = nums[n-1]; for(int i = 0; i &lt; n; i++) { if(nums[i] &gt; max[i]) { max[i+1] = nums[i]; } else { max[i+1] = max[i]; } } for(int i = n-2; i &gt;= 0; i--) { if(nums[i] &lt; min[i+1]) { min[i] = nums[i]; } else { min[i] = min[i+1]; } } for(int i = 1; i &lt; n; i++) { if(max[i] &lt;= min[i]) { return i; } } return -1; }}; æ²¡æƒ³åˆ°ä¼šè¿™ä¹ˆæ…¢ ä¼˜åŒ–1 maxæ•°ç»„æ²¡å¿…è¦ ä¸ç”¨vector 12345678910111213141516171819202122232425class Solution {public: int partitionDisjoint(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int min[100005] = {0}; min[n-1] = nums[n-1]; for(int i = n-2; i &gt;= 0; i--) { if(nums[i] &lt; min[i+1]) { min[i] = nums[i]; } else { min[i] = min[i+1]; } } int max = nums[0]; for(int i = 1; i &lt; n; i++) { if(max &lt;= min[i]) { return i; } if(max &lt; nums[i]) { max = nums[i]; } } return -1; }}; 1768. äº¤æ›¿åˆå¹¶å­—ç¬¦ä¸²12345678910111213141516171819202122class Solution {public: string mergeAlternately(string word1, string word2) { string ret; int len1 = word1.size(), len2 = word2.size(); int i = 0; for(; i &lt; len1 &amp;&amp; i &lt; len2; i++) { ret.push_back(word1[i]); ret.push_back(word2[i]); } if(len1 &lt; len2) { for(; i &lt; len2; i++) { ret.push_back(word2[i]); } } else { for(; i &lt; len1; i++) { ret.push_back(word1[i]); } } return ret; }}; 1235. è§„åˆ’å…¼èŒå·¥ä½œ123456789101112131415161718192021class Solution {public: int jobScheduling(vector&lt;int&gt;&amp; startTime, vector&lt;int&gt;&amp; endTime, vector&lt;int&gt;&amp; profit) { int n = startTime.size(); vector&lt;int&gt; index(n); for(int i = 0; i &lt; n; i++) { index[i] = i; } sort(index.begin(), index.end(), [&amp;](int a, int b)-&gt;bool {return endTime[a] &lt; endTime[b];}); vector&lt;int&gt; dp(n+1); for(int i = 1; i &lt;= n; i++) { int j = index[i-1]; int k = i-2; for(; k &gt;= 0; k--) { if(endTime[index[k]] &lt;= startTime[j]) break; } dp[i] = max(dp[i-1], dp[k+1] + profit[j]); } return dp[n]; }}; å¼€å§‹æƒ³ç”¨è´ªå¿ƒï¼Œç»™æ—¶è–ªæ’åºï¼Œä¸€æ¬¡é€‰æ‹©ï¼Œä½†æ˜¯å‘ç°è¿™æ ·å¾—åˆ°çš„ä¸æ˜¯profitæœ€å¤§ï¼Œè€Œæ˜¯å·¥ä½œæ—¶é—´æ›´çŸ­çš„æƒ…å†µä¸‹çš„æ”¶ç›Šæœ€å¤§çœ‹äº†ç­”æ¡ˆåè‡ªå·±å†™çš„ï¼Œå‘ç°æ˜¯ä¸€ä¸ªéå¸¸å…¸å‹çš„dpé—®é¢˜ å®˜æ–¹é¢˜è§£123456789101112131415161718192021class Solution {public: int jobScheduling(vector&lt;int&gt; &amp;startTime, vector&lt;int&gt; &amp;endTime, vector&lt;int&gt; &amp;profit) { int n = startTime.size(); vector&lt;vector&lt;int&gt;&gt; jobs(n); for (int i = 0; i &lt; n; i++) { jobs[i] = {startTime[i], endTime[i], profit[i]}; } sort(jobs.begin(), jobs.end(), [](const vector&lt;int&gt; &amp;job1, const vector&lt;int&gt; &amp;job2) -&gt; bool { return job1[1] &lt; job2[1]; }); vector&lt;int&gt; dp(n + 1); for (int i = 1; i &lt;= n; i++) { int k = upper_bound(jobs.begin(), jobs.begin() + i - 1, jobs[i - 1][0], [&amp;](int st, const vector&lt;int&gt; &amp;job) -&gt; bool { return st &lt; job[1]; }) - jobs.begin(); dp[i] = max(dp[i - 1], dp[k] + jobs[i - 1][2]); } return dp[n]; }}; å¤ä¹  769. æœ€å¤šèƒ½å®Œæˆæ’åºçš„å—è¿™ä¸ªé¢˜ä¹‹å‰æ²¡æœ‰çœ‹å¤ªæ‡‚ï¼Œç°åœ¨å†çœ‹ä¸€æ¬¡ é¢˜è§£1123456789101112131415161718class Solution { public int maxChunksToSorted(int[] arr) { int n = arr.length, ans = 0; for (int i = 0, j = 0, min = n, max = -1; i &lt; n; i++) { min = Math.min(min, arr[i]); max = Math.max(max, arr[i]); if (j == min &amp;&amp; i == max) { ans++; j = i + 1; min = n; max = -1; } } return ans; }}ä½œè€…ï¼šAC_OIeré“¾æ¥ï¼šhttps://leetcode.cn/problems/max-chunks-to-make-sorted/solution/by-ac_oier-4uny/æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ è¿™ä¸ªé¢˜è§£æ¯”å®˜æ–¹çš„å¥½ç†è§£ä¸€ç‚¹ï¼Œjæ¯”iè½åä¸€ç‚¹å½“iï¼ŒjåŒºé—´å†…æ‹¥æœ‰iï¼Œjä¸¤ä¸ªæ•°æ—¶ï¼Œä¸”iæ˜¯æœ€å¤§å€¼ï¼Œjçš„æœ€å°å€¼ï¼Œè¿™æ—¶å¯¹è¿™ä¸ªåŒºé—´æ’åºï¼Œå¯ä»¥è®©max = iåˆ°içš„ä½ç½®ï¼Œmin = jåˆ°jçš„ä½ç½®ä¹Ÿå°±æ˜¯è¯´iï¼ŒjåŒºé—´å†…æ‰€æœ‰æ•°å­—éƒ½æ‰¾åˆ°äº†è‡ªå·±çš„ä½ç½®ã€‚è¿™å°±æ‰¾åˆ°äº†ä¸€ä¸ªåˆ’åˆ†ï¼Œé‡å¤è¿™æ ·åšï¼Œå°±å¯ä»¥æ‰¾åˆ°æ‰€æœ‰åŒºé—´ é¢˜è§£2123456789101112131415161718192021222324class Solution {public: int maxChunksToSorted(vector&lt;int&gt;&amp; arr) { stack&lt;int&gt; stk; for (int v : arr) { if (stk.empty() || v &gt;= stk.top()) { stk.push(v); } else { int mx = stk.top(); stk.pop(); while (!stk.empty() &amp;&amp; stk.top() &gt; v) { stk.pop(); } stk.push(mx); } } return stk.size(); }};ä½œè€…ï¼šlcbiné“¾æ¥ï¼šhttps://leetcode.cn/problems/max-chunks-to-make-sorted/solution/by-lcbin-jgrv/æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ ä»¥æ•°æ® å•è°ƒæ ˆå•è°ƒæ ˆï¼šåˆ†ä¸ºå•è°ƒé€’å¢å’Œå•è°ƒé€’å‡æ ˆ(æ ˆå†…å…ƒç´ æˆé€’å¢æˆ–è€…é€’å‡æ€§) å•è°ƒæ ˆçš„ä½œç”¨ æŠŠåºåˆ—ä¸­æ¯ä¸ªå…ƒç´ æ”¾åˆ°å•è°ƒæ ˆä¸­è¿›è¡Œç»´æŠ¤å°±å¯ä»¥åœ¨ O(n) çš„æ—¶é—´å¤æ‚åº¦å†…æ±‚å‡ºåŒºé—´æ¯ä¸ªå…ƒç´ ä¸ºæœ€å¤§å€¼/æœ€å°å€¼æ—¶ å•è°ƒæ ˆçš„æ€§è´¨å¦‚ä¸‹ï¼š å…ƒç´ åŠ å…¥æ ˆå‰ä¼šæŠŠæ ˆé¡¶ç ´åå•è°ƒæ€§çš„å…ƒç´ åˆ é™¤ ä¸€èˆ¬ä½¿ç”¨å•è°ƒæ ˆçš„é¢˜ç›®å…·æœ‰ä»¥ä¸‹çš„ä¸¤ç‚¹ ç¦»è‡ªå·±æœ€è¿‘ï¼ˆæ ˆçš„åè¿›å…ˆå‡ºçš„æ€§è´¨ï¼‰ æ¯”è‡ªå·±å¤§ï¼ˆå°ï¼‰ã€é«˜(ä½) æ¿å­ï¼š 12345678910111213stack&lt;int&gt; stk;for (éå†è¿™ä¸ªæ•°ç»„){ if (æ ˆç©º || æ ˆé¡¶å…ƒç´ å¤§äºç­‰äºå½“å‰æ¯”è¾ƒå…ƒç´ ){ å…¥æ ˆ; } else{ while (æ ˆä¸ä¸ºç©º &amp;&amp; æ ˆé¡¶å…ƒç´ å°äºå½“å‰å…ƒç´ ){ æ ˆé¡¶å…ƒç´ å‡ºæ ˆ; æ›´æ–°ç»“æœ; } å½“å‰æ•°æ®å…¥æ ˆ; }} 1822. æ•°ç»„å…ƒç´ ç§¯çš„ç¬¦å·1234567891011121314class Solution {public: int arraySign(vector&lt;int&gt;&amp; nums) { bool ret = false; for(int n : nums) { if(n==0){ return 0; } else if (n&lt;0) { ret=!ret; } } return ret?-1:1; }}; æ¯”è¾ƒç®€å•ï¼Œå°±æ˜¯æ•°æ•°çš„é—®é¢˜","link":"/home/2022/10/25/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9316/"},{"title":"LeetCode-15","text":"904. æ°´æœæˆç¯®123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: int totalFruit(vector&lt;int&gt;&amp; fruits) { int len = fruits.size(); vector&lt;int&gt; v(len); int i = 0; int cur = fruits[i]; i++; int max_diff = 1; int typea = fruits[0], typeb = -1, typec = -1; vector&lt;int&gt; last(len+1); int curr = 0; int j = 1; while(j &lt; len) { while(j &lt; len &amp;&amp; fruits[j] == fruits[curr]) { j++; } last[j] = curr; curr = j; j++; } while(i &lt; len) { int diff = 1; typeb = typec = -1; while(i &lt; len) { if(fruits[i] != typea &amp;&amp; fruits[i] != typeb) { if(typeb == -1) { typeb = fruits[i]; } else if(typec == -1) { typec = fruits[i]; } } if(typec == -1) { diff++; } else { break; } i++; } max_diff = diff &gt; max_diff ? diff : max_diff; if(i-1 &gt;= 0 &amp;&amp; i &lt; len){ typea = fruits[i-1]; i = last[i]+1; } } return max_diff; }}; æƒ³æ³•å¾ˆç®€å•ï¼Œå°±æ˜¯ä»å·¦å¾€å³éå†ï¼Œæ•°å½“å‰é‡åˆ°äº†å‡ ç§æ°´æœï¼Œå½“é‡åˆ°ç¬¬ä¸‰ç§æ°´æœåï¼Œæ›´æ–°ä¸€ä¸‹è£…å…¥æ°´æœçš„æœ€å¤§å€¼ï¼Œä¸‰ç§æ°´æœè®°å½•ä¸ºtypea, typeb, typecç„¶åå›æº¯ï¼Œæ‰¾åˆ°å‰ä¸€ä¸ªèŠ‚ç‚¹åœ¨å·¦ä¾§æœ€åä¸€ä¸ªtypeaåç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼ˆå…¶å®ä¹Ÿæ˜¯typeaæœ€åå‡ºç°çš„ä½ç½®çš„åä¸¤ä¸ªä½ç½®ï¼‰ ä¼˜åŒ–(ç©ºé—´ï¼Œæ”¾å¼ƒlastæ•°ç»„)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: int totalFruit(vector&lt;int&gt;&amp; fruits) { int len = fruits.size(); vector&lt;int&gt; v(len); int i = 0; int cur = fruits[i]; i++; int max_diff = 1; int typea = fruits[0], typeb = -1, typec = -1; while(i &lt; len) { int diff = 1; typeb = typec = -1; int lasta = i-1, lastb = 0; while(i &lt; len) { if(fruits[i] != typea &amp;&amp; fruits[i] != typeb) { if(typeb == -1) { typeb = fruits[i]; } else if(typec == -1) { typec = fruits[i]; } } if(fruits[i] == typea) { lasta = i; } else if(fruits[i] == typeb) { lastb = i; } if(typec == -1) { diff++; } else { break; } i++; } max_diff = diff &gt; max_diff ? diff : max_diff; if(i-1 &gt;= 0 &amp;&amp; i &lt; len){ if(fruits[i-1] == typea) { i = lastb + 2; } else if(fruits[i-1] == typeb) { typea = typeb; i = lasta + 2; } // printf(&quot;%d, %d, %d\\n&quot;, i, lasta, lastb); } } return max_diff; }}; 1441. ç”¨æ ˆæ“ä½œæ„å»ºæ•°ç»„1234567891011121314151617181920class Solution {public: vector&lt;string&gt; buildArray(vector&lt;int&gt;&amp; target, int n) { int cur = 0; int len = target.size(); vector&lt;string&gt; ret; for(int i = 0; i &lt; len; i++) { int diff = target[i] - cur; cur = target[i]; if(diff &gt; 1) { for(int j = 0; j &lt; diff-1; j++) { ret.push_back(&quot;Push&quot;); ret.push_back(&quot;Pop&quot;); } } ret.push_back(&quot;Push&quot;); } return ret; }}; ä¼˜åŒ–ï¼Œä½¿ç”¨emplace_back()push_back()æ–¹æ³•è¦è°ƒç”¨æ„é€ å‡½æ•°å’Œå¤åˆ¶æ„é€ å‡½æ•°ï¼Œè¿™ä¹Ÿå°±ä»£è¡¨ç€è¦å…ˆæ„é€ ä¸€ä¸ªä¸´æ—¶å¯¹è±¡ï¼Œç„¶åæŠŠä¸´æ—¶çš„copyæ„é€ å‡½æ•°æ‹·è´æˆ–è€…ç§»åŠ¨åˆ°å®¹å™¨æœ€åé¢ã€‚è€Œemplace_back()åœ¨å®ç°æ—¶ï¼Œåˆ™æ˜¯ç›´æ¥åœ¨å®¹å™¨çš„å°¾éƒ¨åˆ›å»ºè¿™ä¸ªå…ƒç´ ï¼Œçœå»äº†æ‹·è´æˆ–ç§»åŠ¨å…ƒç´ çš„è¿‡ç¨‹ã€‚ 123456789101112131415161718class Solution {public: vector&lt;string&gt; buildArray(vector&lt;int&gt;&amp; target, int n) { int cur = 0; int len = target.size(); vector&lt;string&gt; ret; for(int i = 0; i &lt; len; i++) { int diff = target[i] - cur - 1; cur = target[i]; for(int j = 0; j &lt; diff; j++) { ret.emplace_back(&quot;Push&quot;); ret.emplace_back(&quot;Pop&quot;); } ret.emplace_back(&quot;Push&quot;); } return ret; }}; 769. æœ€å¤šèƒ½å®Œæˆæ’åºçš„å—1234567891011121314151617class Solution {public: int maxChunksToSorted(vector&lt;int&gt;&amp; arr) { int count = 0; int len = arr.size(); int maxx = 0; for(int i = 0; i &lt; len; i++) { if(arr[i] &gt;= maxx) { maxx = arr[i]; } if(maxx == i) { count++; } } return count; }}; å¦‚æœåœ¨æ‰¾åˆ°ä¸‹ä¸€ä¸ªæœ€å¤§å€¼ä¹‹å‰ï¼Œå½“å‰æœ€å¤§å€¼èƒ½æ‰¾åˆ°æœ€å¤§ä½ç½®ï¼Œåˆ™å­˜åœ¨ä¸€ä¸ªç»„ 940. ä¸åŒçš„å­åºåˆ— IIcomming soon 902. æœ€å¤§ä¸º N çš„æ•°å­—ç»„åˆ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution {public: vector&lt;int&gt; digitscount; int len; int bit; int hasdigit[10] = {0}; int atMostNGivenDigitSet(vector&lt;string&gt;&amp; digits, int n) { digitscount = vector&lt;int&gt;(11); string nstr = toString(n); bit = nstr.size(); len = digits.size(); for(int i = 0; i &lt; len; i++) { hasdigit[digits[i][0]-'0']=1; } digitscount[digits[0][0]-'0'+1]++; for(int i = 1; i &lt; len; i++) { for(int j = digits[i-1][0]-'0'+1; j &lt;= digits[i][0]-'0'; j++) { digitscount[j+1] = digitscount[j]; } digitscount[digits[i][0]-'0'+1]++; } for(int i = digits[len-1][0]-'0'+1; i &lt; 10; i++) { digitscount[i+1] = digitscount[i]; } int count = 0; if(len == 1) { count = bit-1; } else { count = len*(1-pow(len, bit-1))/(1-len); } return count + cal(bit-1, digits, nstr); } int cal(int i, vector&lt;string&gt;&amp; digits, string&amp; nstr) { if(i &lt; 0) return 1; int x = digitscount[nstr[i]-'0']; return x*pow(len, i) + hasdigit[nstr[i]-'0']*cal(i-1, digits, nstr); } long long pow(long long x, long long n) { long long res = 1; while(n) { if(n&amp;1){ res *= x; } n /= 2; x *= x; } return res; } string toString(int n) { string ret = &quot;&quot;; while(n) { ret.push_back(n%10 + '0'); n/=10; } return ret; }}; æ€æƒ³å¾ˆç®€å•ï¼Œé¦–å…ˆæœ‰nä¸ªæ•°å­—å¯ä»¥ç”¨ï¼Œæ¯ä¸ªæ•°å­—ä½¿ç”¨æ¬¡æ•°ä¸é™ï¼Œæ‰€ä»¥æ±‚æŒ‡æ•°ç›®æ ‡æ•°å­—æ˜¯nä½æ•°ï¼Œé‚£ä¹ˆä»»æ„çš„1ä½æ•°åˆ°n-1ä½æ•°çš„ä»»æ„ç»„åˆéƒ½æ˜¯å¯ä»¥ä½¿ç”¨çš„å¯¹äºnä½æ•°çš„æƒ…å†µï¼Œé€æ¬¡è€ƒè™‘æ¯ä¸€ä½ï¼Œå¯¹äºç¬¬iä½ï¼Œ è‹¥ç¬¬iä½ä½¿ç”¨çš„æ•°å­—å°äºç›®æ ‡æ•°å­—çš„ç¬¬iä½ï¼Œåé¢çš„æ•°å­—å¯ä»¥ä»»æ„ç»„åˆ è‹¥ç¬¬iä½ä½¿ç”¨çš„æ•°å­—ç­‰äºç›®æ ‡æ•°å­—çš„ç¬¬iä½ï¼ˆå‰ææ˜¯digitsæ•°ç»„ä¸­æœ‰è¿™ä¸ªæ•°ï¼‰ï¼Œåˆ™ $ 1 \\times (ç¬¬i+1ä½) $ çš„æƒ…å†µ ä¸¤ç§æƒ…å†µä¹‹å’Œå°±æ˜¯ç»“æœ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œpowä½¿ç”¨long longé˜²æ­¢ç»“æœæº¢å‡º ä¼˜åŒ– é¿å…åå¤ä½¿ç”¨powå‡½æ•° å½“hasdigitå·²ç»æ˜¯0äº†ï¼Œæ— éœ€åç»­è®¡ç®— 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution {public: vector&lt;int&gt; digitscount; int len; int bit; int hasdigit[10] = {0}; int atMostNGivenDigitSet(vector&lt;string&gt;&amp; digits, int n) { digitscount = vector&lt;int&gt;(11); string nstr = toString(n); bit = nstr.size(); len = digits.size(); for(int i = 0; i &lt; len; i++) { hasdigit[digits[i][0]-'0']=1; } digitscount[digits[0][0]-'0'+1]++; for(int i = 1; i &lt; len; i++) { for(int j = digits[i-1][0]-'0'+1; j &lt;= digits[i][0]-'0'; j++) { digitscount[j+1] = digitscount[j]; } digitscount[digits[i][0]-'0'+1]++; } for(int i = digits[len-1][0]-'0'+1; i &lt; 10; i++) { digitscount[i+1] = digitscount[i]; } int count = 0; if(len == 1) { count = bit-1; } else { count = len*(1-pow(len, bit-1))/(1-len); } return count + cal(bit-1, digits, nstr, pow(len, bit-1)); } int cal(int i, vector&lt;string&gt;&amp; digits, string&amp; nstr, int power) { if(i &lt; 0) return 1; int x = digitscount[nstr[i]-'0']; if(hasdigit[nstr[i]-'0'] == 0) { return x*power; } return x*power + hasdigit[nstr[i]-'0']*cal(i-1, digits, nstr, power/len); } long long pow(long long x, long long n) { long long res = 1; while(n) { if(n&amp;1){ res *= x; } n /= 2; x *= x; } return res; } string toString(int n) { string ret = &quot;&quot;; while(n) { ret.push_back(n%10 + '0'); n/=10; } return ret; }}; å¿«é€Ÿå¹‚ç®—æ³•ï¼š ä»ä»£ç åæ¨å¯çŸ¥ï¼Œå®é™…ä¸ŠæŠŠnçœ‹ä½œäºŒè¿›åˆ¶æ•° å‡è®¾$ n = 110011001b $ ï¼Œåˆ™$ x^n = x + x^8 + x^{16} + x^{128} + x^{256} $ ç­‰ä»·äº$$ \\sum_0^n n_i \\times x^{2^i} (iä»å³åˆ°å·¦ä¸º0,1,2â€¦) $$ 817. é“¾è¡¨ç»„ä»¶1234567891011121314151617181920212223class Solution {public: int numComponents(ListNode* head, vector&lt;int&gt;&amp; nums) { bool m[10005] = {false}; for(int num : nums) { m[num] = true; } int component_count = 0; while(head != nullptr &amp;&amp; !m[head-&gt;val]) { head = head-&gt;next; } while(head) { while(head != nullptr &amp;&amp; m[head-&gt;val]) { head = head-&gt;next; } while(head != nullptr &amp;&amp; !m[head-&gt;val]) { head = head-&gt;next; } component_count++; } return component_count; }}; é€‚å½“å±•å¼€å¾ªç¯ï¼Œå¯ä»¥å‡å°‘ä¸å¿…è¦çš„åˆ¤æ–­ 1790. ä»…æ‰§è¡Œä¸€æ¬¡å­—ç¬¦ä¸²äº¤æ¢èƒ½å¦ä½¿ä¸¤ä¸ªå­—ç¬¦ä¸²ç›¸ç­‰12345678910111213141516171819202122class Solution {public: bool areAlmostEqual(string s1, string s2) { int len = s1.size(); if(s2.size() != len) return false; if(s1 == s2) return true; int diff1 = -1; for(int i = 0; i &lt; len; i++) { if(s1[i] != s2[i]) { if(diff1 == -1) { diff1 = i; } else { char a = s2[diff1]; s2[diff1] = s2[i]; s2[i] = a; return s1 == s2; } } } return false; }}; å¯ä»¥è½»æ˜“åœ°ç”¨è„šè¶¾å¤´æƒ³åˆ°ï¼Œä¸¤ä¸ªå­—ç¬¦ä¸²åªèƒ½æœ‰ä¸¤å¤„ä¸åŒï¼Œé•¿åº¦ç›¸åŒ å½“æ‰¾åˆ°ç¬¬äºŒä¸ªå­—ç¬¦ä¸²åè¿›è¡Œäº¤æ¢ï¼Œå¦‚æœäº¤æ¢åå’Œs1ç›¸ç­‰ï¼Œåˆ™okï¼Œå¦åˆ™ä¸ok ä¼˜åŒ– é˜²æ­¢é‡å¤æ¯”è¾ƒdiff1 ä¸ diff2ä¹‹é—´çš„å­—ç¬¦123456789101112131415161718192021222324class Solution {public: bool areAlmostEqual(string s1, string s2) { int len = s1.size(); if(s2.size() != len) return false; if(s1 == s2) return true; int diff1 = -1; for(int i = 0; i &lt; len; i++) { if(s1[i] != s2[i]) { if(diff1 == -1) { diff1 = i; } else { for(int j = i+1; j &lt; len; j++) { if(s1[j] != s2[j]) { return false; } } return s2[diff1] == s1[i] &amp;&amp; s2[i] == s1[diff1]; } } } return false; }}; 856. æ‹¬å·çš„åˆ†æ•°12345678910111213141516171819202122232425class Solution {public: int scoreOfParentheses(string s) { stack&lt;int&gt; score; int len = s.size(); score.push(0); for(int i = 0; i &lt; len; i++) { if(s[i] == '(') { score.push(0); } else { int sc1 = score.top(); score.pop(); int sc2 = score.top(); score.pop(); if(sc1 == 0) { sc1+=1; } else { sc1*=2; } score.push(sc1+sc2); } } return score.top(); }}; è¿›è¡Œæ ˆçš„æ¨¡æ‹Ÿï¼Œé‡åˆ°å·¦æ‹¬å·pushä¸€ä¸ª0ï¼Œè¡¨ç¤ºè¯¥å·¦æ‹¬å·å†…éƒ¨çš„å¹³è¡¡æ‹¬å·åˆ†æ•°æ€»å’Œå½“é‡åˆ°ä¸€ä¸ªå³æ‹¬å·ï¼Œpopä¸€ä¸ªscoreï¼Œå¦‚æœæ˜¯0ï¼Œè¯´æ˜æ˜¯()ï¼Œåˆ™å¯¹è¯¥score+1ï¼Œå¦‚æœä¸æ˜¯0ï¼Œåˆ™è¯¥scoreä¹˜ä»¥2ä»æ ˆä¸­å†popä¸€ä¸ªscoreè®°ä¸ºscore2ï¼Œscore2ä¸scoreç›¸åŠ åå…¥æ ˆä¸ºäº†é˜²æ­¢æœ€å¤–ç«¯çš„æ‹¬å·æ— æ³•å–å‡ºä¸¤ä¸ªscoreï¼Œåœ¨éå†så‰å…ˆpushä¸€ä¸ª0æœ€ç»ˆæ ˆé¡¶å…ƒç´ å°±æ˜¯æœ€åç»“æœ 1700. æ— æ³•åƒåˆé¤çš„å­¦ç”Ÿæ•°é‡12345678910111213141516171819202122class Solution {public: int countStudents(vector&lt;int&gt;&amp; students, vector&lt;int&gt;&amp; sandwiches) { queue&lt;int&gt; stuqueue; int len = students.size(); for(int i = 0; i &lt; len; i++) { stuqueue.push(students[i]); } for(int i = 0; i &lt; len; i++) { int count = 0; while(count &lt; len &amp;&amp; stuqueue.front() != sandwiches[i]) { int front = stuqueue.front(); stuqueue.pop(); stuqueue.push(front); count++; } if(count == len) return stuqueue.size(); stuqueue.pop(); } return stuqueue.size(); }}; ä¼˜åŒ–ï¼Œç›´æ¥æ¨¡æ‹Ÿæ•ˆç‡å¤ªä½äº†123456789101112131415161718class Solution {public: int countStudents(vector&lt;int&gt;&amp; students, vector&lt;int&gt;&amp; sandwiches) { int len = students.size(); int s1 = accumulate(students.begin(), students.end(), 0); int s0 = len - s1; for(int i = 0; i &lt; len; i++) { if(sandwiches[i] == 0 &amp;&amp; s0 != 0) { s0--; } else if(sandwiches[i] == 1 &amp;&amp; s1 != 0) { s1--; } else { return s0+s1; } } return s0+s1; }}; å½“å­¦ç”Ÿæ— æ³•æ‹¿æ ˆé¡¶çš„ä¸œè¥¿æ—¶ï¼Œä¸€å®šæ˜¯å› ä¸ºå‰©ä¸‹çš„æ‰€æœ‰äººéƒ½ä¸åƒå½“å‰æ ˆé¡¶å…ƒç´ ã€‚ ä¸é˜Ÿåˆ—çš„å…ˆåé¡ºåºæ— å…³ ä»æ ˆé¡¶åˆ°æ ˆåº•ï¼Œé‡åˆ°æŸä¸ªé£Ÿç‰©åªè¦åœ¨é˜Ÿåˆ—é‡Œéšä¾¿æ‰¾ä¸€ä¸ªå­¦ç”Ÿå°±å¥½äº†ã€‚å¦‚æœæ°å¥½èƒ½åƒå®Œï¼Œåˆ™è¿”å›0ï¼Œå¦‚æœé‡åˆ°æŸä¸ªé£Ÿç‰©æ²¡äººåƒäº†ï¼Œå°±è¿”å›å‰©ä¸‹çš„äººæ•°ã€‚ æ ¹æ®é¢˜æ„ï¼Œæˆ‘ä»¬å¯ä»¥çŸ¥é“æ ˆé¡¶çš„ä¸‰æ˜æ²»èƒ½å¦è¢«æ‹¿èµ°å–å†³äºé˜Ÿåˆ—å‰©ä½™çš„å­¦ç”Ÿä¸­æ˜¯å¦æœ‰å–œæ¬¢å®ƒçš„. åªè¦å½“å‰æ ˆé¡¶çš„ä¸œè¥¿å­¦ç”Ÿä¸å–œæ¬¢ï¼Œå°±ä¼šä¸€ç›´å‘åæ’é˜Ÿï¼Œç›´åˆ°å‡ºç°å–œæ¬¢çš„ä¸œè¥¿ä¸ºæ­¢ï¼Œæ‰€ä»¥å¯ä»¥ä¸è€ƒè™‘å½“å‰é˜Ÿåˆ—çš„é¡ºåºã€‚ 779. ç¬¬Kä¸ªè¯­æ³•ç¬¦å·123456789101112131415161718192021222324class Solution {public: int kthGrammar(int n, int k) { stack&lt;int&gt; route; while(k&gt;1) { route.push(k%2); k = k%2 + k/2; } //route.push(1); string a = &quot;01&quot;,b = &quot;10&quot;; string cur = a; int next = 0; while(!route.empty()) { if(cur[next] == '0') { cur = a; } else { cur = b; } next=1-route.top(); route.pop(); } return cur[next]-'0'; }}; ç±»ä¼¼å®Œå…¨äºŒå‰æ ‘çš„æ€æƒ³ï¼Œ10çš„çˆ¶èŠ‚ç‚¹æ˜¯1ï¼Œ01çš„çˆ¶èŠ‚ç‚¹æ˜¯0æ¯”å¦‚éœ€è¦ç¬¬nè¡Œçš„ç¬¬kä¸ªï¼Œé‚£ä¹ˆå…¶çˆ¶èŠ‚ç‚¹æ˜¯ç¬¬n-1è¡Œç¬¬$ \\lceil n/2 \\rceil = n/2 + n%2 $ä¸ªæ•°ç”±äºåªæœ‰0å’Œ1ä¸¤ç§æƒ…å†µï¼Œå¯¹äºkï¼Œå¦‚æœk%2 == 1,åˆ™æ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„å·¦å­èŠ‚ç‚¹ï¼Œå¦åˆ™æ˜¯å³å­èŠ‚ç‚¹æ•…å¯ä»¥è®¡ç®— $ (\\lceil n/2 \\rceil)%2 $ï¼Œä¾æ¬¡æ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼Œæ ¹èŠ‚ç‚¹ä¸€å®šæ˜¯0ï¼Œstackä¸­æœ€åä¸€ä¸ªæ•°ä¸€å®šæ˜¯1åˆ™ä»0ç”Ÿæˆ01ï¼Œå†æ ¹æ®stackä¸­å‰©ä¸‹çš„æ•°ï¼Œå¦‚æœæ˜¯1ï¼Œåˆ™æ˜¯01çš„å·¦èŠ‚ç‚¹0ï¼Œåˆç”Ÿæˆ01ï¼›å¦‚æœæ˜¯0ï¼Œåˆ™æ˜¯01çš„å³èŠ‚ç‚¹1ï¼Œç”Ÿæˆ10ï¼Œç”¨è¿™ç§æ–¹æ³•é€æ¸ç”Ÿæˆåˆ°å¶èŠ‚ç‚¹ä»¥k=14ä¸ºä¾‹ï¼Œç¥–å…ˆä¾æ¬¡æ˜¯7ï¼Œ4ï¼Œ2ï¼Œ1ï¼Œstackä¸­ä¾æ¬¡æ˜¯ï¼Œ1ï¼Œ0ï¼Œ0ï¼Œ1ï¼Œ0åˆ™ 0 -&gt; 01 -&gt; 10 -&gt; 01 -&gt; 01 -&gt; 1 0010110011010010110100110010110 è¿™ä¸ªç®—æ³•ç”šè‡³ä¸éœ€è¦ç”¨nè¿™ä¸ªå‚æ•° ä¼˜åŒ–-ä½¿ç”¨ä½è¿ç®—1234567891011121314151617181920212223class Solution {public: int kthGrammar(int n, int k) { stack&lt;int&gt; route; while(k&gt;1) { route.push(k%2); k = k%2 + k/2; } int cur = 0x01; int next = 1; while(!route.empty()) { cur = (cur &gt;&gt; next)&amp;0x01; if(cur == 0) { cur = 0x01; } else { cur = 0x02; } next=route.top(); route.pop(); } return (cur&gt;&gt;next)&amp;0x01; }}; 524. é€šè¿‡åˆ é™¤å­—æ¯åŒ¹é…åˆ°å­—å…¸é‡Œæœ€é•¿å•è¯1234567891011121314151617181920212223242526class Solution {public: string findLongestWord(string s, vector&lt;string&gt;&amp; dictionary) { // sort(dictionary.begin(), dictionary.end()); int lend = dictionary.size(); int lens = s.size(); int maxlen = 0; string maxstr = &quot;&quot;; for(int i = 0; i &lt; lend; i++) { int j = 0, k = 0; int leni = dictionary[i].size(); for(; k &lt; leni &amp;&amp; j &lt; lens; j++) { if(s[j] == dictionary[i][k]) k++; } if(leni &gt;= maxlen &amp;&amp; k &gt;= leni) { if(maxlen == leni) { maxstr = dictionary[i] &gt; maxstr ? maxstr : dictionary[i]; } else { maxstr = dictionary[i]; } maxlen = leni; } } return maxstr; }}; æš´åŠ›ï¼Œå¹²å°±å®Œäº† ä¼˜åŒ–(æŠ„ç­”æ¡ˆå°±å®Œäº‹)1234567891011121314151617181920212223242526class Solution: def findLongestWord(self, s: str, dictionary: List[str]) -&gt; str: m = len(s) f = [[0] * 26 for _ in range(m)] f.append([m] * 26) for i in range(m - 1, -1, -1): for j in range(26): if ord(s[i]) == j + 97: f[i][j] = i else: f[i][j] = f[i + 1][j] print(f) res = &quot;&quot; for t in dictionary: match = True j = 0 for i in range(len(t)): if f[j][ord(t[i]) - 97] == m: match = False break j = f[j][ord(t[i]) - 97] + 1 if match: if len(t) &gt; len(res) or (len(t) == len(res) and t &lt; res): res = t return res å¤§æ¦‚å°±æ˜¯ç”Ÿæˆä¸€ä¸ªè¡¨ï¼Œå¦‚æœf[i][j]ä¸æ˜¯mï¼Œå°±è¡¨ç¤ºç¬¬iä½æˆ–ç¬¬iä½ä¹‹åå¯ä»¥å–åˆ°è¿™ä¸ªå­—ç¬¦ä¸ºäº†ä¿è¯æŒ‰ç…§é¡ºåºä½¿ç”¨å­—æ¯è¡¨sä¸­çš„å­—ç¬¦ï¼Œj=f[i][j]ï¼Œè¡¨ç¤ºä¸‹ä¸€æ¬¡è¦ä»è¿™ä¸ªä½ç½®å¼€å§‹å–å­—ç¬¦ 81. æœç´¢æ—‹è½¬æ’åºæ•°ç»„ II12345678910111213141516171819202122232425262728class Solution {public: bool search(vector&lt;int&gt;&amp; nums, int target) { int len = nums.size(); int k = 1; for(int i = 1; i &lt; len; i++, k++) { if(nums[i] &lt; nums[i-1]) { break; } } k = len - k; // cout &lt;&lt; k &lt;&lt; endl; int l = 0, r = len; while(l &lt;= r) { int mid = (r - l)/2 + l; // cout &lt;&lt; nums[(mid - k + len)%len] &lt;&lt; endl; if(target == nums[(mid - k + len)%len]) { return true; } else if(target &lt; nums[(mid - k + len)%len]) { r = mid-1; } else { l = mid+1; } } // cout &lt;&lt; l &lt;&lt; r &lt;&lt; endl; return target == nums[(r - k + len)%len] || target == nums[(l - k + len)%len]; }}; O(n)çš„ç®—æ³•ä¸å¤ªå¥½ ä¼˜åŒ–123456789101112131415161718192021222324252627282930313233343536class Solution {public: bool search(vector&lt;int&gt; &amp;nums, int target) { int n = nums.size(); if (n == 0) { return false; } if (n == 1) { return nums[0] == target; } int l = 0, r = n - 1; while (l &lt;= r) { int mid = (l + r) / 2; if (nums[mid] == target) { return true; } if (nums[l] == nums[mid] &amp;&amp; nums[mid] == nums[r]) { ++l; --r; } else if (nums[l] &lt;= nums[mid]) { if (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) { r = mid - 1; } else { l = mid + 1; } } else { if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - 1]) { l = mid + 1; } else { r = mid - 1; } } } return false; }}; åˆ†æˆäº†ä¸¤ä¸ªé€’å¢åŒºé—´ï¼Œå·¦è¾¹è¾ƒå¤§çš„å’Œå³è¾¹è¾ƒå°çš„å¦‚æœmidè½åœ¨å·¦è¾¹åŒºé—´ï¼Œå¦‚æœmidå¤§äºtarget ä¸” targetä¹Ÿè½åœ¨è¾ƒå¤§çš„åŒºé—´ï¼Œå‘å·¦ç§»åŠ¨ï¼Œå¦åˆ™å‘å³ç§»åŠ¨å¦‚æœmidè½åœ¨å³è¾¹åŒºé—´ï¼Œå¦‚æœmidå°äºtarget ä¸” targetä¹Ÿè½åœ¨è¾ƒå¤§çš„åŒºé—´ï¼Œå‘å³ç§»åŠ¨ï¼Œå¦åˆ™å‘å·¦ç§»åŠ¨å¦‚æœç‰¹æ®Šæƒ…å†µ[1,1,0,1,1,1]ï¼Œåˆ™ç›´æ¥ç¼©å°åŒºé—´å¤§å°ï¼Œé€æ¸é€¼è¿‘ 540. æœ‰åºæ•°ç»„ä¸­çš„å•ä¸€å…ƒç´ 1234567891011121314151617181920212223242526272829303132class Solution {public: int singleNonDuplicate(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int l = 0, r = len; while(l &lt;= r) { int mid = (r - l)/2 + l; if(mid%2 == 0) { if(mid &gt; 0 &amp;&amp; nums[mid-1] == nums[mid]) { r = mid-1; continue; } if (mid &lt; len-1 &amp;&amp; nums[mid+1] == nums[mid]) { l = mid+1; continue; } return nums[mid]; } else { if(mid &gt; 0 &amp;&amp; nums[mid-1] == nums[mid]) { l = mid+1; continue; } if (mid &lt; len-1 &amp;&amp; nums[mid+1] == nums[mid]) { r = mid-1; continue; } return nums[mid]; } } return nums[l]; }}; å¦‚æœä¸‹æ ‡æ˜¯å¶æ•°ï¼Œå¦‚æœå·¦è¾¹æ²¡æœ‰å•ä¸ªæ•°å­—ï¼Œé‚£ä¹ˆæˆ‘å³è¾¹åº”è¯¥å’Œæˆ‘ä¸€æ ·ï¼Œé‚£ä¹ˆå•ä¸ªæ•°å­—å°±åœ¨æˆ‘å³è¾¹ï¼Œå¦åˆ™å°±åœ¨æˆ‘å·¦è¾¹å¦‚æœä¸‹æ ‡æ˜¯å¥‡æ•°ï¼Œå¦‚æœå·¦è¾¹æ²¡æœ‰å•ä¸ªæ•°å­—ï¼Œé‚£ä¹ˆæˆ‘å·¦è¾¹åº”è¯¥å’Œæˆ‘ä¸€æ ·ï¼Œé‚£ä¹ˆå•ä¸ªæ•°å­—å°±åœ¨æˆ‘å³è¾¹ï¼Œå¦åˆ™å°±åœ¨æˆ‘å·¦è¾¹ ä¼˜åŒ–å¦‚æœmidæ˜¯å¥‡æ•°ï¼Œå¤„ç†æˆå¶æ•° 1234567891011121314151617class Solution {public: int singleNonDuplicate(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int l = 0, r = len-1; while(l &lt; r) { int mid = (r - l)/2 + l; mid -= mid &amp; 1; if (nums[mid+1] == nums[mid]) { l = mid+2; } else { r = mid; } } return nums[l]; }}; 154. å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼ II12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {public: int findMin(vector&lt;int&gt;&amp; nums) { int len = nums.size(); if (len == 1) { return nums[0]; } if (len == 2) { return min(nums[0], nums[1]); } int l = 0, r = len-1; while (l &lt;= r) { int mid = (l + r) / 2; if (nums[l] == nums[mid] &amp;&amp; nums[mid] == nums[r]) { ++l; --r; } else if (nums[l] &lt;= nums[mid]) { if(nums[mid] &lt;= nums[r]) return nums[l]; if(mid &lt; len-1) { if (nums[mid] &lt;= nums[mid+1]) { l = mid + 1; } else { return nums[mid+1]; } } else { return nums[mid]; } } else { if(mid &gt; 0) { if (nums[mid] &lt; nums[mid-1]) { return nums[mid]; } else { r = mid -1; } } else { return nums[mid]; } } } return nums[r]; }}; ä¼˜åŒ–ï¼Œå»æ‰ä¸å¿…è¦çš„åˆ¤æ–­1234567891011121314151617181920212223242526272829class Solution {public: int findMin(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int l = 0, r = len-1; while (l &lt; r) { int mid = (l + r) / 2; if (nums[l] == nums[mid] &amp;&amp; nums[mid] == nums[r]) { ++l; --r; } else if (nums[l] &lt;= nums[mid]) { if(nums[mid] &lt;= nums[r]) return nums[l]; if (nums[mid] &lt;= nums[mid+1]) { l = mid + 1; } else { return nums[mid+1]; } } else { if (nums[mid] &lt; nums[mid-1]) { return nums[mid]; } else { r = mid -1; } } } return nums[r]; }}; é¢˜è§£æ€è·¯123456789101112131415161718class Solution {public: int findMin(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int l = 0, r = len-1; while (l &lt; r) { int mid = (l + r) / 2; if (nums[mid] == nums[r]) { --r; } else if (nums[r] &lt;= nums[mid]) { l = mid + 1; } else { r = mid; } } return nums[r]; }}; ä¸éœ€è¦å…³æ³¨å·¦è¾¹çš„æƒ…å†µï¼Œä¹‹å‰çš„ä»£ç æ¯”è¾ƒå¯¹ç§°ï¼Œå¯ä»¥çœ‹å‡ºå¯ä»¥ç®€åŒ–midæ¯”rå¤§ï¼Œè¯´æ˜è½åœ¨äº†å·¦ä¾§è¾ƒå¤§çš„åŒºé—´ï¼Œå³ç§»å¦‚æœmidæ¯”rå°ï¼Œè¯´æ˜è½åœ¨äº†å³ä¾§çš„è¾ƒå°åŒºé—´ï¼Œå·¦ç§»ï¼Œä½†ä¸ç¡®å®šæˆ‘æ˜¯ä¸æ˜¯æœ€å°å€¼ï¼Œæ•…r=midä¸å‡1 901. è‚¡ç¥¨ä»·æ ¼è·¨åº¦12345678910111213141516171819202122class StockSpanner {public: vector&lt;int&gt; stocks; int len; StockSpanner() { len = 0; } int next(int price) { stocks.push_back(price); len++; int m = 0; for(int i = len-1; i &gt;= 0; i--) { if(stocks[i] &lt;= price) { m++; } else { break; } } return m; }}; æ˜¾ç„¶å¤ªæ…¢äº† ä¼˜åŒ–1234567891011121314151617181920212223242526272829303132333435363738394041424344class StockSpanner {public: vector&lt;int&gt; peak; vector&lt;int&gt; stocks; int len; int peaklen; int l1, l2; StockSpanner() { len = 0; peaklen = 0; } int next(int price) { len++; stocks.push_back(price); if(len == 1) { return 1; } if(len == 2) { if(stocks[len-2] &gt; price) { peaklen++; peak.push_back(len-2); } return 1 + (stocks[len-2] &lt;= price); } int a = stocks[len-1], b = stocks[len-2], c = stocks[len-3]; if(b &gt;= a &amp;&amp; b &gt; c) { peaklen++; peak.push_back(len-2); } int pk = peaklen-1; while(pk &gt;= 0 &amp;&amp; stocks[peak[pk]] &lt;= price) { pk--; } if(pk &lt; 0) { return len; } int i; for(i = peak[pk]; i &lt; len &amp;&amp; stocks[i] &gt; price; i++) { } if(i == len-1) return 1; return len - i; }}; è‚¡ä»·çš„å˜åŒ–æ˜¯æ³¢åŠ¨çš„ï¼Œä¼šå‡ºç°æ³¢å³°å’Œæ³¢è°·ï¼Œæ‰¾åˆ°å‰ä¸€ä¸ªæ¯”æˆ‘å¤§çš„æ³¢å³°ï¼Œå‘åæŸ¥æ‰¾ï¼Œå°±å¯ä»¥æ‰¾åˆ°å¯¹åº”çš„ä½ç½® å†ä¼˜åŒ–æ‰¾åˆ°æ³¢å³°ï¼Œè¿˜å¯ä»¥è®°å½•æ³¢è°·ï¼Œè¿™æ ·æ³¢å³°æ³¢è°·ä¹‹é—´å¯ä»¥äºŒåˆ†æŸ¥æ‰¾ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class StockSpanner {public: vector&lt;pair&lt;int, int&gt;&gt; peak; vector&lt;int&gt; stocks; int len; int peaklen; int valleylen; int l1, l2; StockSpanner() { len = 0; peaklen = 0; valleylen = 0; } int next(int price) { len++; stocks.push_back(price); if(len == 1) { return 1; } if(len == 2) { if(stocks[len-2] &gt; price) { peaklen++; peak.push_back(pair&lt;int,int&gt;(len-2, INT_MAX)); } return 1 + (stocks[len-2] &lt;= price); } int a = stocks[len-1], b = stocks[len-2], c = stocks[len-3]; if(b &gt;= a &amp;&amp; b &gt; c) { peaklen++; peak.push_back(pair&lt;int, int&gt;(len-2, INT_MAX)); } else if(b &lt;= a &amp;&amp; b &lt; c) { peak[peaklen-1].second = len-2; } int pk = peaklen-1; while(pk &gt;= 0 &amp;&amp; stocks[peak[pk].first] &lt;= price) { pk--; } if(pk &lt; 0) { return len; } if(peak[pk].second == INT_MAX) return 1; auto ite = lower_bound(stocks.begin()+peak[pk].first,stocks.begin()+peak[pk].second+1,price, greater&lt;int&gt;()); if(ite == stocks.end()) return 1; return stocks.end() - ite; }}; debugæ²¡deå‡ºæ¥ çœ‹ç­”æ¡ˆ123456789101112131415161718192021class StockSpanner {public: StockSpanner() { this-&gt;stk.emplace(-1, INT_MAX); this-&gt;idx = -1; } int next(int price) { idx++; while (price &gt;= stk.top().second) { stk.pop(); } int ret = idx - stk.top().first; stk.emplace(idx, price); return ret; }private: stack&lt;pair&lt;int, int&gt;&gt; stk; int idx;}; å¥½åƒæ˜¯ä¸€æ ·çš„æ€è·¯ï¼Œä½†æ˜¯æˆ‘åƒä¸ªå‚»å­ 347. å‰ K ä¸ªé«˜é¢‘å…ƒç´ 1234567891011121314151617181920212223242526class Solution {public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int, int&gt; frequent; int len = nums.size(); for(int i = 0; i &lt; len; i++) { frequent[nums[i]]++; } sort(nums.begin(), nums.end(), [&amp;](int a, int b) -&gt; bool { if(frequent[a] != frequent[b]) { return frequent[a] &gt; frequent[b]; } return a &lt; b; }); vector&lt;int&gt; res; res.push_back(nums[0]); int count = 1; for(int i = 1; count &lt; k; i++) { if(nums[i] != nums[i-1]) { res.push_back(nums[i]); count++; } } return res; }}; ä¼˜åŒ–ä¸‰æ¬¡éå† 1234567891011121314151617181920212223class Solution {public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int, int&gt; frequent; map&lt;int, set&lt;int&gt;&gt; inv; int len = nums.size(); for(int i = 0; i &lt; len; i++) { frequent[nums[i]]++; } for(int i = 0; i &lt; len; i++) { inv[frequent[nums[i]]].insert(nums[i]); } vector&lt;int&gt; res; int count = 0; for(auto ite = inv.rbegin(); ite != inv.rend() &amp;&amp; count &lt; k; ite++) { for(auto jte = ite-&gt;second.begin(); jte != ite-&gt;second.end(); jte++) { res.push_back(*jte); count++; } } return res; }};","link":"/home/2022/10/22/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9315/"},{"title":"LeetCode-19","text":"1710. å¡è½¦ä¸Šçš„æœ€å¤§å•å…ƒæ•°1234567891011121314151617181920class Solution {public: int maximumUnits(vector&lt;vector&lt;int&gt;&gt;&amp; boxTypes, int truckSize) { sort(boxTypes.begin(), boxTypes.end(), [](vector&lt;int&gt;&amp; x, vector&lt;int&gt;&amp; y)-&gt;bool { return x[1] &gt; y[1]; }); int n = boxTypes.size(); int ret = 0; for(int i = 0; i &lt; n; i++) { if(truckSize) { ret += min(truckSize, boxTypes[i][0])*boxTypes[i][1]; truckSize -= min(truckSize, boxTypes[i][0]); } else { break; } } return ret; }};// 50 + 27 + 14 = 91 ç®€å•é¢˜ï¼Œæ’ä¸ªåºå°±è¡Œ 775. å…¨å±€å€’ç½®ä¸å±€éƒ¨å€’ç½®1234567891011class Solution {public: bool isIdealPermutation(vector&lt;int&gt;&amp; nums) { for (int i = 0; i &lt; nums.size(); i++) { if (abs(nums[i] - i) &gt; 1) { return false; } } return true; }}; æœ€å¼€å§‹æƒ³å¤æ‚äº†ï¼Œæƒ³ç”¨å·®åˆ†æ•°ç»„ç»Ÿè®¡ä¸ªæ•° 39. ç»„åˆæ€»å’Œ1234567891011121314151617181920212223242526class Solution {public: int n; int target; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { this-&gt;target = target; n = candidates.size(); vector&lt;int&gt; vec; search(0, 0, vec, move(candidates)); return res; } void search(int index, int sum, vector&lt;int&gt; &amp; vec, vector&lt;int&gt;&amp;&amp; candidates) { if(sum == target) { res.push_back(vec); return; } if(sum &gt; target) return; vec.push_back(candidates[index]); search(index, sum+candidates[index], vec, move(candidates)); vec.pop_back(); if(index+1 &lt; n) { search(index+1, sum, vec, move(candidates)); } }}; ç¡¬æœï¼Œä¸è¦é‡å¤å°±å¥½äº† 792. åŒ¹é…å­åºåˆ—çš„å•è¯æ•°è¶…æ—¶1123456789101112131415161718192021222324252627282930313233class Solution {public:int n; int numMatchingSubseq(string s, vector&lt;string&gt;&amp; words) { n = s.size(); int count = 0; int len = words.size(); for(int i = 0; i &lt; len; i++) { if(isSubstr(move(s), move(words[i]))) { count++; } } return count; } bool isSubstr(string&amp;&amp; s, string&amp;&amp; word) { int nw = word.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(nw, 0)); dp[0][0]=(word[0]==s[0]); for(int i=1;i&lt;n;i++) { dp[i][0] = max(dp[i-1][0], int(word[0]==s[i])); } for(int i=1;i&lt;nw;i++){ dp[0][i] = max(dp[0][i-1], int(s[0]==word[i])); } for(int j = 1; j &lt; nw; j++) { for(int i = 1; i &lt; n; i++) { dp[i][j] = max(dp[i-1][j-1] + int(s[i] == word[j]),max(dp[i-1][j],dp[i][j-1])); } } //cout &lt;&lt; dp[n-1][nw-1] &lt;&lt; endl; return dp[n-1][nw-1]==nw; }}; è¶…æ—¶212345678910111213141516171819202122232425262728class Solution {public:int n; int numMatchingSubseq(string s, vector&lt;string&gt;&amp; words) { n = s.size(); int count = 0; int len = words.size(); unordered_map&lt;string, bool&gt; m; for(int i = 0; i &lt; len; i++) { if(m.count(words[i])) { count++; } else if(isSubstr(move(s), move(words[i]))) { m[words[i]] = true; count++; } } return count; } bool isSubstr(string&amp;&amp; s, string&amp;&amp; word) { int nw = word.size(); for(int i = 0, j = 0; i &lt; nw; i++) { for(;j&lt;n &amp;&amp; word[i] != s[j]; j++); if(j == n) return false; j++; } return true; }};","link":"/home/2022/11/15/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9319/"},{"title":"LeetCode-18","text":"1668. æœ€å¤§é‡å¤å­å­—ç¬¦ä¸²1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: int maxRepeating(string sequence, string word) { int len1 = sequence.size(); int len2 = word.size(); int maxk = 0, k = 0; for(int i = 0; i &lt; len1;) { bool flag = true; int next = i+1; bool flag1 = false; for(int j = 0; j &lt; len2; j++) { if(sequence[i+j] != word[j]) { flag = false; break; } if(!flag1 &amp;&amp; j != 0 &amp;&amp; sequence[i+j] == word[0]) { next = i+j; flag1=true; } } // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; maxk &lt;&lt; endl; if(flag) { k++; i += len2; } else { maxk = max(k, maxk); if(k == 0) { i+=1; } else { i = i-len2+1; } k = 0; } // cout &lt;&lt; i &lt;&lt; endl; } return max(maxk, k); }}; ç¬¨æ–¹æ³•ï¼Œä»å³å‘å·¦æ‰¾ï¼Œé€‚å½“å›æº¯ 754. åˆ°è¾¾ç»ˆç‚¹æ•°å­—è§£æ³•11234567891011121314151617181920class Solution {public: int reachNumber(int target) { target = abs(target); int n = (sqrt(8.0*target+1)-1)/2; //8.0,é˜²æ­¢intæº¢å‡º int sum = (n+1)*n/2; if(sum == target) { return n; } int diff = target-sum; if((n % 2 == 1 &amp;&amp; diff % 2 == 0) || (n % 2 == 0 &amp;&amp; diff % 2 == 1)) { n += 1; } else if(diff %2 == 1) { n += 2; } else { n += 3; } return n; }}; è¿™é“é¢˜ç›´æ¥æš´åŠ›æœç´¢æ˜¯ä¸å¯è¡Œçš„ï¼Œç®—æ³•æˆä¸º$ O( 2^{ target } ) $ çº§åˆ« è€ƒè™‘åˆ°åªæ±‚æ­¥æ•°ï¼Œè´Ÿæ•°targetå¯ä»¥è½¬åŒ–æˆæ­£æ•°å¤„ç†é¦–å…ˆè®¡ç®— $ sum = 1 + 2 + 3 + â€¦ + i + â€¦ + n &lt;= target $, å¦‚æœ $ sum==target $ï¼Œåˆ™nå°±æ˜¯æ­¥æ•°å¦åˆ™å¯¹sumè¿›è¡Œè°ƒæ•´ï¼Œè®° $ diff = target-sum &lt;= n $ (ä¸€å®šå°äºn+1)ï¼Œæ‰€ä»¥éœ€è¦å…ˆå‡å°sumï¼Œå†åŠ ä¸Šå‡ ä¸ªæ•°ï¼Œä½¿å¾—æ–°çš„sumç­‰äºtargetæƒ…å†µä¸€ï¼Œç¬¬iæ­¥æ”¹ä¸ºå‘å·¦ï¼Œå†åŠ ä¸Šn+1, ä¹Ÿå°±æ˜¯ $ sum - 2i + n+1 $ï¼Œè°ƒæ•´å‰åçš„å·®ä¸º $ delta = n + 1 -2i $, $ i = 1,2,3,â€¦,n; delta = n-1, n-3, n-5 â€¦ $ã€‚è¿™ç§æƒ…å†µå¯¹äºdiffå¥‡æ•°nå¶æ•°ï¼Œæˆ–diffå¶æ•°nå¥‡æ•°çš„æƒ…å†µé€‚ç”¨ï¼Œæ€»è®¡æ­¥æ•°n+1æƒ…å†µäºŒï¼Œç¬¬iæ­¥æ”¹ä¸ºå‘å·¦ï¼Œå†åŠ ä¸Šn+1å’Œn+2ï¼Œä¹Ÿå°±æ˜¯ $ sum - 2i + n+1 + n+2 $ï¼Œè°ƒæ•´å‰åçš„å·®ä¸º $ delta = 2(n-i) + 3 $, $ i = 1,2,3,â€¦,n; delta = 3, 5, 7, 9, â€¦ $ã€‚è¿™ç§æƒ…å†µå¯¹äºdiffå¥‡æ•°ä¸”diff &gt;= 3çš„æƒ…å†µé€‚ç”¨ï¼Œæ€»è®¡æ­¥æ•°n+2æƒ…å†µä¸‰ï¼Œå‡å»n+1,åŠ ä¸Šn+2ï¼Œæ˜¾ç„¶ä½¿ç”¨äºdiff=1çš„æƒ…å†µï¼Œæ€»è®¡æ­¥æ•°n+2ï¼Œå¯ä»¥å’Œæƒ…å†µäºŒåˆå¹¶æƒ…å†µå››ï¼Œä»¥ä¸Šæ²¡æœ‰è¦†ç›–åˆ°çš„æƒ…å†µï¼Œä¸¾ä¸ªä¾‹å­å¯çŸ¥ï¼Œæ€»è®¡æ­¥æ•°n+3 è§£æ³•2123456789101112131415161718class Solution {public: int reachNumber(int target) { target = abs(target); int sum = 0; int n = 0; while(sum &lt; target) { n++; sum += n; } if((sum-target) % 2 == 0) return n; while((sum-target)%2) { n++; sum += n; } return n; }}; è®¡ç®— $ sum=1+2+3+â€¦+n &gt;= target $æƒ…å†µä¸€ï¼šå¦‚æœ $ diff = sum-target &lt;= n $ æ˜¯å¶æ•°ï¼Œåˆ™æ­¥æ•°å°±æ˜¯nã€‚ ç”±äºdiff &lt;= n,æ‰€ä»¥å¯ä»¥è®©ç¬¬iæ­¥å˜æˆå‘å·¦ï¼Œå³ $ sum - 2i, i=0,1,2,3,â€¦,n+1 $ï¼Œåˆ™åˆšå¥½å¯ä»¥å˜æˆtargetå…¶ä»–æƒ…å†µï¼šå¦‚æœdiffæ˜¯å¥‡æ•°ï¼Œåˆ™ç»§ç»­åœ¨sumçš„åŸºç¡€ä¸ŠåŠ n,ç›´åˆ°diffä¸ºå¶æ•° æ–¹æ³•31234567891011121314class Solution {public: int reachNumber(int target) { target = abs(target); int sum = 0; int n = 0; while(sum &lt; target) { n++; sum += n; } if((sum-target) % 2 == 0) return n; return n + n%2 +1; }}; æ ¹æ®æ–¹æ³•1ï¼Œè°ƒæ•´çš„æ­¥æ•°æœ€å¤š3æ­¥ï¼Œè¿›ä¸€æ­¥åˆ†æï¼Œå½“diffä¸ºå¥‡æ•°æ—¶ï¼ŒsumåŠ å‡ ä¸ªæ•°å¯ä»¥å˜æˆå¶æ•°ï¼Œæ ¹æ®å…¬å¼ $$ sum = n(n+1)/2 $$å¯çŸ¥ï¼šnå¶æ•°ï¼Œsumå¶æ•°ï¼Œn+1å¥‡æ•°ï¼Œsum=sum+n+1åsumå˜å¥‡æ•°$$ n = 4i, sum=2i(2i+1) $$ nå¥‡æ•°ï¼Œsumå¥‡æ•°ï¼Œn+1å¶æ•°ï¼Œn+2å¥‡æ•°ï¼Œsum=sum+n+1+n+2åsumå˜å¶æ•°$$ n = 4i+1, sum=(4i+1)(2i+1) $$nå¶æ•°ï¼Œsumå¥‡æ•°ï¼Œn+1å¥‡æ•°ï¼Œsum=sum+n+1åsumå˜å¶æ•°$$ n = 4i+2, sum=(2i+1)(4i+3) $$nå¥‡æ•°ï¼Œsumå¶æ•°ï¼Œn+1å¶æ•°ï¼Œn+2å¥‡æ•°sum=sum+n+1+n+2åsumå˜å¥‡æ•°$$ n = 4i+3, sum=(4i+3)(2i+2) $$ ç”±äºdiffä¸ºå¥‡æ•°ï¼Œåˆ™sumä¸ºå¥‡æ•°æ—¶è¦å˜æˆå¶æ•°ï¼Œå¦åˆ™å˜æˆå¥‡æ•°æ•´ç†ä¸Šé¢çš„è®¨è®ºï¼Œå¯çŸ¥è°ƒæ•´çš„æ­¥æ•°ä¸ºn%2+1ï¼Œæ€»æ­¥æ•°ä¸ºn+n%2+1 1106. è§£æå¸ƒå°”è¡¨è¾¾å¼1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {private: const static int NOT = '!'; const static int AND = '&amp;'; const static int OR = '|';public: bool parseBoolExpr(string expression) { stack&lt;char&gt; ops; stack&lt;char&gt; value; int len = expression.size(); for(int i = 0; i &lt; len; i++) { if(expression[i] == 't' || expression[i] == 'f') { value.push(expression[i]); } else if(expression[i] == NOT || expression[i] == AND || expression[i] == OR) { ops.push(expression[i]); } else if(expression[i] == '(') { value.push('('); } else if(expression[i] == ')') { char op = ops.top(); ops.pop(); bool res = value.top() == 't'? true : false; value.pop(); if(op == NOT) { res = !res; if(!value.empty()) { value.pop(); } } else { while(!value.empty() &amp;&amp; value.top() != '(') { bool temp = value.top() == 't'? true : false; if (op == AND) { res &amp;= temp; } else if(op == OR) { res |= temp; } value.pop(); } if(!value.empty()) { value.pop(); } } value.push(res ? 't' : 'f'); } } return value.top() == 't'? true : false; }}; å°±æ˜¯å†™ä¸€ä¸ªè®¡ç®—å™¨ï¼Œéš¾ç‚¹åœ¨äºnå…ƒè¿ç®—ï¼Œéœ€è¦åœ¨æ•°å€¼æ ˆä¸­ä¿å­˜æ‹¬å·ï¼Œä»¥åˆ¤æ–­æ¯ä¸ªæ“ä½œä½œç”¨äºé‚£äº›å€¼ 1678. è®¾è®¡ Goal è§£æå™¨1234567891011121314151617181920class Solution {public: string interpret(string command) { string s; int len = command.size(); for(int i = 0; i &lt; len; i++) { if(command[i] == 'G') { s.push_back('G'); } else if(command[i] == '(') { if(command[i+1] == ')') { s.push_back('o'); } else { s.push_back('a'); s.push_back('l'); } } } return s; }}; 816. æ¨¡ç³Šåæ ‡123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: int len; vector&lt;string&gt; ambiguousCoordinates(string s) { len = s.size(); vector&lt;string&gt; coord; for(int i = 2; i &lt; len-1; i++) { vector&lt;string&gt; n1; vector&lt;string&gt; n2; gen(move(s), 1, i, n1); int len1 = n1.size(); if(len1 &lt;=0) continue; gen(move(s), i, len-1, n2); int len2 = n2.size(); if(len2 &lt;= 0) continue; for(int k1 = 0; k1 &lt; len1; k1++) { for(int k2=0; k2&lt; len2; k2++) { coord.push_back(&quot;(&quot; + n1[k1] + &quot;, &quot; + n2[k2] + &quot;)&quot;); } } } return coord; } void gen(string&amp;&amp; s, int i, int j, vector&lt;string&gt;&amp; ret) { if(s[j-1] == '0' &amp;&amp; s[i] =='0' &amp;&amp; j-i&gt;1) { return; } if(s[j-1] == '0') { ret.push_back(s.substr(i, j-i)); return; } if(s[i] == '0') { ret.push_back(&quot;0.&quot; + s.substr(i+1, j-i-1)); return; } for(int k = i; k &lt; j-1; k++) { ret.push_back(s.substr(i, k-i+1) + &quot;.&quot; + s.substr(k+1, j-k-1)); } ret.push_back(s.substr(i, j-i)); return; }}; 1684. ç»Ÿè®¡ä¸€è‡´å­—ç¬¦ä¸²çš„æ•°ç›®1234567891011121314151617181920212223class Solution {public: int countConsistentStrings(string allowed, vector&lt;string&gt;&amp; words) { bool all[129] = {false}; for(char c : allowed) { all[c] = true; } int count = 0; for(string &amp;w : words ) { bool flag = true; for(char c : w) { if(!all[c]) { flag = false; break; } } if(flag) { count++; } } return count; }}; ä½è¿ç®—1234567891011121314151617181920212223class Solution {public: int countConsistentStrings(string allowed, vector&lt;string&gt;&amp; words) { int all = 0; for(char c : allowed) { all |= 1 &lt;&lt; (c-'a'); } int count = 0; for(string &amp;w : words ) { bool flag = true; for(char c : w) { if(!((all &gt;&gt; (c-'a'))&amp;1)) { flag = false; break; } } if(flag) { count++; } } return count; }}; é¢˜ä¸­è¯´æ˜äº† allowedåªåŒ…å«26ä¸ªå­—æ¯ï¼Œæ‰€ä»¥ç”¨ä¸€ä¸ªintå°±å¯ä»¥è¡¨ç¤ºå­—ç¬¦æ˜¯å¦å­˜åœ¨ 764. æœ€å¤§åŠ å·æ ‡å¿—å‰ç¼€å’Œ12345678910111213141516171819202122232425262728293031323334353637class Solution {public: int orderOfLargestPlusSign(int n, vector&lt;vector&lt;int&gt;&gt;&amp; mines) { vector&lt;vector&lt;int&gt;&gt; mat(n, vector&lt;int&gt;(n, 1)), x(n, vector&lt;int&gt;(n+1, n)),y(n+1, vector&lt;int&gt;(n, n)); for(auto mine : mines) { mat[mine[0]][mine[1]] = 0; } for(int i = n-1; i &gt;= 0; i--) { for(int j = n-1; j &gt;= 0; j--) { if(mat[i][j] == 1) { x[i][j] = x[i][j+1]; } else { x[i][j] = j; } if(mat[j][i] == 1) { y[j][i] = y[j+1][i]; } else { y[j][i] = j; } } } vector&lt;int&gt; miny(n, -1); int maxx = 0; for(int i = 0; i &lt; n; i++) { int minx = -1; for(int j = 0; j &lt; n; j++) { if(mat[i][j] == 0) { minx = j; miny[j] = i; } else { maxx = max(maxx, min(min(x[i][j] - j , j - minx), min(y[i][j] - i , i - miny[j]))); } } } return maxx; }}; åˆšå¼€å§‹æƒ³ç”¨dpï¼Œä½†æ˜¯æƒ³æ³•ä¸å¯¹ï¼Œè¯•äº†7.8æ¬¡ï¼Œæœ€åæƒ³åˆ°æ­£ç¡®çš„æ–¹æ³•x, yè®°å½•ç‚¹(i, j) å³æµ‹/ä¸‹æ–¹ç¬¬ä¸€ä¸ª0çš„åæ ‡ï¼Œminxè®°å½•å·¦æ–¹ç¬¬ä¸€ä¸ª0çš„åæ ‡ï¼Œminyè®°å½•ä¸Šæ–¹ç¬¬ä¸€ä¸ª0çš„ä½ç½®matç”¨æ¥ä¿å­˜è¿™ä¸ªçŸ©é˜µåŠ å·çš„é˜¶æ•°ä¸º(i, j)åæ ‡åˆ°ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘ä¸Šæœ€è¿‘çš„0çš„è·ç¦»çš„æœ€å°å€¼è¦æ³¨æ„ç‰¹æ®Šå€¼çš„å¤„ç†ï¼Œå³ä¾§/ä¸‹æ–¹æ²¡æœ‰0ï¼Œåˆ™è®°å…¶åæ ‡ä¸ºn,ä¸Šæ–¹/å·¦ä¾§æ²¡æœ‰0è®°ä¸º-1 ä¸€ç›´ä»¥ä¸ºåªæœ‰æŠŠæŸä¸€ä¾§çš„æ•°å…¨éƒ½åŠ èµ·æ¥æ‰ç®—å‰ç¼€å’Œåªè¦æ˜¯æŠŠæ¯ä¸ªä½ç½®ä¹‹å‰çš„ä¸€ç»´çº¿æ®µæˆ–äºŒç»´çŸ©å½¢é¢„å…ˆå­˜å‚¨ï¼Œå°±å«åšå‰ç¼€å’Œ/ç§¯åˆ†å›¾ å¤§ä½¬çš„è§£æ³•1234567891011121314151617181920212223class Solution {public: int orderOfLargestPlusSign(int n, vector&lt;vector&lt;int&gt;&gt;&amp; mines) { vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, n)); for (auto&amp; e : mines) dp[e[0]][e[1]] = 0; for (int i = 0; i &lt; n; ++i) { int left = 0, right = 0, up = 0, down = 0; for (int j = 0, k = n - 1; j &lt; n; ++j, --k) { left = dp[i][j] ? left + 1 : 0; right = dp[i][k] ? right + 1 : 0; up = dp[j][i] ? up + 1 : 0; down = dp[k][i] ? down + 1 : 0; dp[i][j] = min(dp[i][j], left); dp[i][k] = min(dp[i][k], right); dp[j][i] = min(dp[j][i], up); dp[k][i] = min(dp[k][i], down); } } int ans = 0; for (auto&amp; e : dp) ans = max(ans, *max_element(e.begin(), e.end())); return ans; }}; å…¶å®ä»”ç»†ä¸€çœ‹ï¼Œå’Œæˆ‘æ˜¯ä¸€æ ·çš„ï¼Œä¸€ä¸ªä¸€ç»´forä¸¤ä¸ªäºŒç»´forï¼Œä½†æ˜¯å¾ˆçŸ­dpå­˜çš„æ˜¯åˆ°æœ€è¿‘çš„ä¸€ä¸ª0çš„é•¿åº¦ ä¼˜åŒ–ç©ºé—´123456789101112131415161718192021222324class Solution {public: int orderOfLargestPlusSign(int n, vector&lt;vector&lt;int&gt;&gt;&amp; mines) { vector&lt;vector&lt;int&gt;&gt; mat(n, vector&lt;int&gt;(n, n)); for(auto mine : mines) mat[mine[0]][mine[1]] = 0; for(int i = 0; i &lt; n; i++) { int l = -1,r = n,u = -1,d = n; for(int j = 0, k = n-1; j &lt; n; j++, k--) { l = mat[i][j] ? l : j; u = mat[j][i] ? u : j; r = mat[i][k] ? r : k; d = mat[k][i] ? d : k; mat[i][j] = min(mat[i][j], j - l); mat[j][i] = min(mat[j][i], j - u); mat[i][k] = min(mat[i][k], r - k); mat[k][i] = min(mat[k][i], d - k); } } int maxx = INT_MIN; for(vector&lt;int&gt;&amp; vec : mat) maxx = max(maxx, *max_element(vec.begin(), vec.end())); return maxx; }}; å‚è€ƒå¤§ä½¬çš„æ–¹æ³•ï¼ŒæŠŠæˆ‘çš„æ€è·¯ä¼˜åŒ–æˆåªç”¨ä¸€ä¸ªäºŒç»´æ•°ç»„è¿™é‡Œè¦æ³¨æ„matåˆå§‹åŒ–ä¸ºnï¼Œå¦‚æœåˆå§‹åŒ–ä¸º1çš„è¯åé¢æ²¡åŠæ³•æ‰¾æœ€å°å€¼ã€‚ 462. æœ€å°æ“ä½œæ¬¡æ•°ä½¿æ•°ç»„å…ƒç´ ç›¸ç­‰ IIå‰ç¼€å’Œ1234567891011121314151617class Solution {public: int minMoves2(vector&lt;int&gt;&amp; nums) { int len = nums.size(); long long int minn = INT_MAX; vector&lt;int&gt; preSum(len, 0); preSum[0] = nums[0]; sort(nums.begin(), nums.end()); for(int i = 1; i &lt; len; i++) { preSum[i] = preSum[i-1] + nums[i]; } for(long long int i = 0; i &lt; len; i++) { minn = min(minn, (i+1)*nums[i] - preSum[i] + preSum[len-1] - preSum[i] - (len-i -1)*nums[i]); } return minn; }}; å…ˆæ’åºï¼Œå‡è®¾ç¬¬iä¸ªæ•°æ˜¯èƒ½ä½¿æ€»ä½“è°ƒæ•´æ•°æœ€å°çš„æ•°ï¼Œé‚£ä¹ˆæ€»çš„è°ƒæ•´æ¬¡æ•°ä¸º$$ i \\times nums_i - \\sum_{ j=0 }^{ j=i-1 }(nums_i) + \\sum_{ j=i+1 }^{ j=n-1 }(nums_j) - (n - i -1) \\times nums_i $$$$ i = 0,1,â€¦,n-1 $$å¹¶ä½¿ç”¨å‰ç¼€å’Œä¼˜åŒ–æ‰¾ä»–çš„æœ€å°å€¼å³å¯ æ•°å­¦æ–¹æ³•123456789101112class Solution {public: int minMoves2(vector&lt;int&gt;&amp; nums) { int len = nums.size(); long long int sum = 0; sort(nums.begin(), nums.end()); for(long long int i = 0; i &lt; len; i++) { sum += abs(nums[i] - nums[len/2]); } return sum; }}; æ’åºåï¼Œä¸­ä½æ•°ä¹‹ä¸€åˆšå¥½å°±æ˜¯æ‰€æ±‚å…ƒç´ å‡è®¾ $ a_i a_j; i+j=len-1 $ ä¸ºä¸¤ä¸ªå¾…è°ƒæ•´å…ƒç´ $ h $ ä¸ºæœ€ç»ˆè°ƒæ•´åçš„æ•°ï¼Œé‚£ä¹ˆ $$ h = a_j - d_j = d_i - a_i $$ä¹Ÿå°±æ˜¯ $$ a_j - a_i = d_j + d_i $$å¯¹äºå…³äºä¸­å¿ƒå¯¹ç§°çš„æ•°ï¼Œä¸ç®¡è¦è°ƒæ•´æˆä»–ä»¬ä¸­é—´çš„å“ªä¸€ä¸ªæ•°ï¼Œè°ƒæ•´çš„æ­¥æ•°ä¹‹å’Œæ€»æ˜¯ $ a_j - a_i $ æ‰€ä»¥æ ¹æœ¬ä¸éœ€è¦çŸ¥é“æœ€ç»ˆè°ƒæ•´æˆå“ªä¸ªæ•°ï¼Œåªè¦è®¡ç®—å¯¹ç§°ä½ç½®çš„ä¸¤ä¸ªæ•°çš„å·®å€¼ä¹‹å’Œå³å¯ 123456789101112class Solution {public: int minMoves2(vector&lt;int&gt;&amp; nums) { int len = nums.size(); long long int sum = 0; sort(nums.begin(), nums.end()); for(long long int i = 0; i &lt; len/2; i++) { sum += nums[len-1-i] - nums[i]; } return sum; }}; ä¸æ’åºæ‰¾åˆ°ç¬¬len/2å°çš„æ•°123456789101112class Solution {public: int minMoves2(vector&lt;int&gt;&amp; nums) { int len = nums.size(); nth_element(nums.begin(), nums.begin() + len/2, nums.end()); int sum = 0; for(int i = 0; i &lt; len; i++) { sum += abs(nums[i] - nums[len/2]); } return sum; }}; è‡ªå·±å®ç°partition 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: int minMoves2(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int i = 0, j = len; int k = 0; for(;;) { k = partition(nums, i ,j); if(k == len/2) { break; } else if(k &gt; len/2) { j = k; } else { i = k+1; } } int sum = 0; for(int i = 0; i &lt; len; i++) { sum += abs(nums[i] - nums[k]); } return sum; } int partition(vector&lt;int&gt;&amp; nums, int i, int j) { int target = i; j--; while(i &lt; j) { while(j &gt; i &amp;&amp; nums[j] &gt;= nums[target]) { j--; } if(nums[j] &lt; nums[target])swap(nums[target], nums[j]); target = j; while(j &gt; i &amp;&amp; nums[i] &lt;= nums[target]) { i++; } if(nums[i] &gt; nums[target])swap(nums[target], nums[i]); target = i; } return i; }}; å¤ªæ…¢äº†ã€‚ã€‚ã€‚ å»æ‰swap 123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: int minMoves2(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int i = 0, j = len-1; int k = 0; for(;;) { k = partition(nums, i, j); if(k == len/2) { break; } else if(k &gt; len/2) { j = k-1; } else { i = k+1; } } int sum = 0; for(int i = 0; i &lt; len; i++) { sum += abs(nums[i] - nums[k]); } return sum; } int partition(vector&lt;int&gt;&amp; nums, int i, int j) { int pivot = nums[i]; while(i &lt; j) { while(j &gt; i &amp;&amp; nums[j] &gt;= pivot) { j--; } nums[i] = nums[j]; while(j &gt; i &amp;&amp; nums[i] &lt;= pivot) { i++; } nums[j] = nums[i]; } nums[i] = pivot; return i; }}; 470. ç”¨ Rand7() å®ç° Rand10()123456class Solution {public: int rand10() { return rand()%10+1; }}; æ»¡èº«åéª¨ 202. å¿«ä¹æ•°1234567891011121314151617181920class Solution {public: bool isHappy(int n) { while(n != 1) { n = next(n); if(n == 4) { return false; } } return true; } int next(int n) { int sum = 0; while(n) { sum += (n%10)*(n%10); n /= 10; } return sum; }}; å¤§å®¶éƒ½æœ‰ç›¸åŒçš„å¾ªç¯èŠ‚ å¿«æ…¢æŒ‡é’ˆ12345678910111213141516171819202122class Solution {public: bool isHappy(int n) { int nn = n; do { n = next(n); nn = next(nn); if(nn == 1) return true; nn = next(nn); if(nn == 1) return true; } while(n != nn); return false; } int next(int n) { int sum = 0; while(n) { sum += (n%10)*(n%10); n /= 10; } return sum; }}; 123456789101112131415161718192021class Solution {public: bool isHappy(int n) { int nn = n; do { n = next(n); if(n == 1) return true; nn = next(nn); nn = next(nn); } while(n != nn); return false; } int next(int n) { int sum = 0; while(n) { sum += (n%10)*(n%10); n /= 10; } return sum; }}; 790. å¤šç±³è¯ºå’Œæ‰˜ç±³è¯ºå¹³é“º12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;double&gt; frac; int sum = 0; int numTilings(int n) { frac = vector&lt;double&gt;(n+1, 1); for(int i = 2; i &lt;= n; i++) { frac[i] = (i * frac[i-1]); } calcualte(n, n, 0, 1); return sum; } void calcualte(int k, int n, int count, double div) { if(k &gt;= 3) { for(int i = n/k; i &gt;= 0; i--) { double div1 = (div*frac[i]); for(int j = (n-i*k)/k; j &gt;= 0; j--) { calcualte(k-1, n - i*k - j*k, count + i + j, (div1*frac[j]) ); } } } else if(k == 2) { for(int i = n/k; i&gt;=0; i--) { calcualte(k-1, n-i*k, count + i, (div*frac[i])); } } else { sum = int(sum + frac[count + n]/div/frac[n])%1000000007; } }}; æ²¡é€šè¿‡ï¼Œæ€è·¯ä¸å¯¹ï¼Œç®—é˜¶ä¹˜æº¢å‡ºï¼Œæ‰¾å‡ºæ‰€æœ‰ç»„åˆçš„ä»£ä»·ä¹Ÿå¤ªå¤§ åœ¨è¿™ä¸ªåœ°æ–¹æˆ‘çŠ¯äº†ä¸€ä¸ªé”™è¯¯ï¼Œå°±æ˜¯è®¤ä¸º $ \\frac{a}{b} \\quad mod\\quad c = \\frac{a\\quad mod\\quad c}{b\\quad mod\\quad c} $æ­£ç¡®çš„å…³ç³»æ˜¯ï¼Œ $ \\frac{a}{b}\\quad mod\\quad c = \\frac{a\\quad mod\\quad (b \\cdot c)}{b} $ ï¼Œè¯æ˜ï¼š$ \\frac{a}{b}\\quad mod\\quad c = k $$ \\frac{a}{b} = x \\cdot c + k $$ a = b \\cdot x \\cdot c + b \\cdot k $$ a\\quad mod\\quad (b \\cdot c) = b \\cdot k $$ a\\quad mod\\quad (b \\cdot c) / b = k $$ \\frac{a}{b}\\quad mod\\quad c = \\frac{a\\quad mod\\quad (b \\cdot c)}{b} $ $ a^n \\quad mod \\quad c = (a \\cdot a^{n-1}) \\quad mod \\quad c = ((a \\quad mod \\quad c) \\cdot (a^{n-1} \\quad mod \\quad c)) \\quad mod \\quad c$ dp123456789101112131415#define MOD 1000000007class Solution {public: int numTilings(int n) { vector&lt;vector&lt;long long&gt;&gt; dp(n+1, vector&lt;long long&gt;(4, 0)); dp[0][3] = 1; for(int i = 1; i &lt;= n; i++) { dp[i][0] = dp[i-1][3]; dp[i][1] = (dp[i-1][0] + dp[i-1][2])%MOD; dp[i][2] = (dp[i-1][0] + dp[i-1][1])%MOD; dp[i][3] = (dp[i-1][0] + dp[i-1][1] + dp[i-1][2] + dp[i-1][3])%MOD; } return dp[n][3]; }}; å¿«é€Ÿå¹‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#define MOD 1000000007class Solution {public: int numTilings(int n) { vector&lt;vector&lt;long long&gt;&gt; pow = { {0,0,0,1}, {1,0,1,0}, {1,1,0,0}, {1,1,1,1} }, base = { {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {1,0,0,0} }; pow = matPow(pow, n, 4); base = matMul(pow, base, 4, 4, 4); return base[3][0]; } vector&lt;vector&lt;long long&gt;&gt; matPow(vector&lt;vector&lt;long long&gt;&gt;&amp; a, int pow, int m) { vector&lt;vector&lt;long long&gt;&gt; res(m, vector&lt;long long&gt;(m)); for(int i = 0; i &lt; m; i++) { res[i][i] = 1; } while(pow) { if(pow&amp;1) { res = matMul(a, res,m,m,m); } a = matMul(a, a,m,m,m); pow = pow &gt;&gt; 1; } return res; } vector&lt;vector&lt;long long&gt;&gt; matMul(vector&lt;vector&lt;long long&gt;&gt;&amp; a, vector&lt;vector&lt;long long&gt;&gt;&amp; b, int m, int n, int k) { vector&lt;vector&lt;long long&gt;&gt; c(m, vector&lt;long long&gt;(k)); for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; k; j++) { int sum = 0; for(int l = 0; l &lt; n; l++) { sum = (sum + (a[i][l]*b[l][j])%MOD)%MOD; } c[i][j] = sum; } } return c; }}; 791. è‡ªå®šä¹‰å­—ç¬¦ä¸²æ’åº1234567891011121314class Solution {public: string customSortString(string order, string s) { int lenO = order.size(); int argOrder[26] = {0}; for(int i = 0; i &lt; lenO; i++) { argOrder[order[i]-'a'] = i+1; } sort(s.begin(), s.end(), [&amp;](char x, char y) -&gt; bool{ return argOrder[x-'a'] &lt; argOrder[y-'a']; }); return s; }};","link":"/home/2022/11/07/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9318/"},{"title":"LeetCode-17","text":"1662. æ£€æŸ¥ä¸¤ä¸ªå­—ç¬¦ä¸²æ•°ç»„æ˜¯å¦ç›¸ç­‰12345678910111213141516class Solution {public: bool arrayStringsAreEqual(vector&lt;string&gt;&amp; word1, vector&lt;string&gt;&amp; word2) { return join(move(word1)) == join(move(word2)); } string join(vector&lt;string&gt;&amp;&amp; word) { string s; int len = word.size(); if(len &lt;= 0) return s; for(int i = 0; i &lt; len-1; i++) { s += word[i]; } s+=word[len-1]; return s; }}; å®ç°ä¸€ä¸ªjoinå‡½æ•°å°±å¥½äº† 481. ç¥å¥‡å­—ç¬¦ä¸²1234567891011121314151617181920212223class Solution {public: int magicalString(int n) { int bit = 3; int count = 1; bool q[100005] = {false}; int queue_front = 0; int queue_rear = 0; bool cur=1; bool gen=0; while(bit &lt; n) { bit += cur+1; q[queue_front++] = gen; if(cur) { q[queue_front++] = gen; } gen=1-gen; count+=gen?cur+gen:0; cur = q[queue_rear++]; } return count -(bit&gt;n &amp;&amp; gen); }}; å…³é”®åœ¨äºæƒ³æ¸…æ¥šå¦‚ä½•ç”Ÿæˆè¿™ä¸ªç¥å¥‡å­—ç¬¦ä¸²ï¼Œé¢˜ç›®ä¸­è¯´ï¼Œsçš„å‰å‡ ä¸ªå­—ç¬¦æ˜¯122111ç”Ÿæˆ1,s=12ç”Ÿæˆ22ï¼Œå› ä¸ºå‰ä¸€ä¸ª1ç”Ÿæˆäº†1ï¼Œè¿™ä¸ª2ä¸èƒ½ä¹Ÿç”Ÿæˆ1,s=1222ç”Ÿæˆ11ï¼Œå› ä¸ºå‰ä¸€ä¸ª2ç”Ÿæˆäº†2ï¼Œè¿™ä¸ª2ä¸èƒ½ä¹Ÿç”Ÿæˆ2,s=122111ç”Ÿæˆ2ï¼Œå‰ä¸€ä¸ª2ç”Ÿæˆäº†1ï¼Œè¿™ä¸ª1å°±åªèƒ½ç”Ÿæˆ2äº†,s=1221121ç”Ÿæˆ1,s=12211212ç”Ÿæˆ22,s=122112122 åªè¦æœ‰å‰ä¸‰ä¸ªå­—ç¬¦122ï¼Œå³å¯ç”Ÿæˆå…¨éƒ¨å­—ç¬¦ 784. å­—æ¯å¤§å°å†™å…¨æ’åˆ—123456789101112131415161718192021222324252627class Solution {public:vector&lt;string&gt; res;int len; vector&lt;string&gt; letterCasePermutation(string s) { len = s.size(); search(s, 0); return res; } void search(string s, int index) { if(index&gt;=len) { res.emplace_back(s); return; } if(isalpha(s[index])) { search(s,index+1); if(isupper(s[index])) { s[index] = s[index]-'A'+'a'; } else { s[index] = s[index]-'a'+'A'; } search(s, index+1); } else { search(s, index+1); } }}; æœ! æœå°±å®Œäº† ä¼˜åŒ– å¯ä»¥æœç´¢ä¸‹ä¸€ä¸ªalphaçš„ä½ç½®ï¼Œä¸å¿…æ¯ä¸ªå­—ç¬¦éƒ½é€’å½’ï¼ŒèŠ‚çœé€’å½’æ·±åº¦ 12345678910111213141516171819202122232425262728class Solution {public:vector&lt;string&gt; res;int len; vector&lt;string&gt; letterCasePermutation(string s) { len = s.size(); search(s, nextAlpha(s, 0)); return res; } void search(string&amp; s, int index) { if(index&gt;=len) { res.emplace_back(s); return; } int next=nextAlpha(s, index+1); search(s,next); if(isupper(s[index])) { s[index] = s[index]-'A'+'a'; } else { s[index] = s[index]-'a'+'A'; } search(s, next); } int nextAlpha(string&amp; s, int index){ while(index&lt;len &amp;&amp; !isalpha(s[index])) index++; return index; }}; 1773. ç»Ÿè®¡åŒ¹é…æ£€ç´¢è§„åˆ™çš„ç‰©å“æ•°é‡123456789101112131415161718class Solution {public: int countMatches(vector&lt;vector&lt;string&gt;&gt;&amp; items, string ruleKey, string ruleValue) { int index=0; if(ruleKey[0]=='c') { index=1; } else if(ruleKey[0]=='n') { index=2; } int count = 0; for(auto &amp;&amp;item : items) { if(!item[index].compare(ruleValue)) { count++; } } return count; } }; æ„Ÿè§‰ç›´æ¥æ¯”è¾ƒç¬¬0ä¸ªå­—ç¬¦åº”è¯¥ä¹Ÿå¾ˆå¿«å§ï¼Ÿ 907. å­æ•°ç»„çš„æœ€å°å€¼ä¹‹å’Œ123456789101112131415161718192021222324252627282930313233class Solution {public: int sumSubarrayMins(vector&lt;int&gt;&amp; arr) { int n = arr.size(); vector&lt;int&gt; monoStack; vector&lt;int&gt; left(n), right(n); for (int i = 0; i &lt; n; i++) { while (!monoStack.empty() &amp;&amp; arr[i] &lt;= arr[monoStack.back()]) { monoStack.pop_back(); } // å°äºæ ˆå†…å…ƒç´ ï¼Œåˆ™ left[i] = i - (monoStack.empty() ? -1 : monoStack.back()); // è‹¥ç©ºï¼Œåˆ™æ”¾å…¥ä¸‹ä¸€ä¸ªåºå·ï¼Œå¦åˆ™æ˜¯ä¸å‰ä¸€ä¸ªæ•°çš„è·ç¦» monoStack.emplace_back(i); } // å¾—åˆ°ä¸€ä¸ªå•å¢çš„æ ˆ //åªéœ€è¦æ‰¾åˆ°æ¯ä¸ªå…ƒç´  arr[i] ä»¥è¯¥å…ƒç´ ä¸ºæœ€å³ä¸”æœ€å°çš„å­åºåˆ—çš„æ•°ç›® left[i]ï¼Œä»¥åŠä»¥è¯¥å…ƒç´ ä¸ºæœ€å·¦ä¸”æœ€å°çš„å­åºåˆ—çš„æ•°ç›® right[i]ï¼Œåˆ™ä»¥ arr[i] ä¸ºæœ€å°å…ƒç´ çš„å­åºåˆ—çš„æ•°ç›®åˆè®¡ä¸º left[i]Ã—right[i] monoStack.clear(); for (int i = n - 1; i &gt;= 0; i--) { while (!monoStack.empty() &amp;&amp; arr[i] &lt; arr[monoStack.back()]) { monoStack.pop_back(); } right[i] = (monoStack.empty() ? n : monoStack.back()) - i; monoStack.emplace_back(i); } long long ans = 0; long long mod = 1e9 + 7; for (int i = 0; i &lt; n; i++) { ans = (ans + (long long)left[i] * right[i] * arr[i]) % mod; } return ans; }}; çœ‹äº†ç­”æ¡ˆæ‰ä¼šï¼Œæƒ³åˆ°æ˜¯ç”¨å•è°ƒæ ˆï¼Œä½†æ˜¯æ²¡æœ‰æ€è·¯$ left \\times right $ çš„åŸå› æ˜¯ï¼Œnä¸ªå…ƒç´ çš„è¿ç»­å­æ•°ç»„çš„ä¸ªæ•°ä¸º $ n \\times (n-1) $ 1620. ç½‘ç»œä¿¡å·æœ€å¥½çš„åæ ‡123456789101112131415161718192021222324252627282930313233343536class Solution {public: int len; int Power(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; towers, int radius) { int power = 0; for(int j = 0; j &lt; len; j++) { double d = sqrt((towers[j][0]-x)*(towers[j][0]-x) + (towers[j][1]-y)*(towers[j][1]-y)); if(d &lt;= radius) { power += towers[j][2]/(1+d); } } return power; } vector&lt;int&gt; bestCoordinate(vector&lt;vector&lt;int&gt;&gt;&amp; towers, int radius) { int resx = 0, resy = 0; len = towers.size(); int maxPower = 0; for(int x = 0; x &lt;= 100; x++) { for(int y = 0; y &lt;= 100; y++) { int power = Power(x, y, towers, radius); if(power &gt; maxPower) { maxPower = power; resx = x; resy = y; } else if(power == maxPower) { bool smaller = (x &lt; resx) || (x == resx &amp;&amp; y &lt; resy); if(smaller) { resx = x; resy = y; } } } } return {resx, resy}; }}; æš´åŠ›ï¼ï¼å°±æš´åŠ›ï¼Œçœ‹è§é¢˜å¹²å°±å®Œäº†ï¼Œæœç´¢ç©ºé—´æœ‰å¤šå¤§æˆ‘å°±æœå¤šå¤§å“ˆå“ˆå“ˆå“ˆæˆ–æˆ– ä¼˜åŒ–123456789101112131415161718192021222324252627282930class Solution {public: int len; int Power(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; towers, int radius) { int power = 0; for(int j = 0; j &lt; len; j++) { double d = sqrt((towers[j][0]-x)*(towers[j][0]-x) + (towers[j][1]-y)*(towers[j][1]-y)); if(d &lt;= radius) { power += towers[j][2]/(1+d); } } return power; } vector&lt;int&gt; bestCoordinate(vector&lt;vector&lt;int&gt;&gt;&amp; towers, int radius) { int resx = 0, resy = 0; len = towers.size(); int maxPower = 0; for(int x = 0; x &lt;= 50; x++) { for(int y = 0; y &lt;= 50; y++) { int power = Power(x, y, towers, radius); if(power &gt; maxPower) { maxPower = power; resx = x; resy = y; } } } return {resx, resy}; }}; å¤§äº50çš„å°±æ²¡å¿…è¦äº†ï¼Œåªä¼šè¡°å‡","link":"/home/2022/11/01/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9317/"},{"title":"LeetCode-20","text":"1758. ç”Ÿæˆäº¤æ›¿äºŒè¿›åˆ¶å­—ç¬¦ä¸²çš„æœ€å°‘æ“ä½œæ•°1234567891011121314151617class Solution {public: int minOperations(string s) { int len = s.size(); return min(cal(s, len, true), cal(s, len, false)); } int cal(const string&amp; s, int len, bool flag) { int count = 0; for(int i = 0; i &lt; len; i++) { if(flag &amp;&amp; s[i] == '0' || !flag &amp;&amp; s[i] == '1') { count++; } flag = !flag; } return count; }}; 813. æœ€å¤§å¹³å‡å€¼å’Œçš„åˆ†ç»„è¶…æ—¶æš´æœ1234567891011121314151617181920212223class Solution {public: int len = 0; vector&lt;int&gt; sum; double largestSumOfAverages(vector&lt;int&gt;&amp; nums, int k) { len = nums.size(); sum = vector&lt;int&gt;(len+1, 0); for(int i = 1; i &lt;= len; i++) { sum[i] = nums[i-1] + sum[i-1]; } return search(nums, k, 1, 1, 0, 0); } double search(vector&lt;int&gt;&amp; nums, int k, int i, int K, double left_value, int last_j) { if(k == K || i == len) { return left_value + (sum[len] - sum[last_j] + 0.0) / (len - last_j); } return max(search(nums, k, i+1, K+1, left_value + (sum[i] - sum[last_j] + 0.0)/(i-last_j), i), search(nums, k,i+1, K, left_value, last_j)); } double max(double a, double b) { return a &gt; b ? a : b; }}; æ˜¨å¤©ç¬¬ä¸€ä¸ªæ€è·¯æ˜¯ç”¨æ’åºï¼Œæ‰¾å‡ºæœ€å¤§çš„mä¸ªæ•°ï¼Œè¿™mä¸ªæ•°æ°å¥½å°†æ•°ç»„åˆ†æˆkä¸ªéƒ¨åˆ†ï¼Œå‘ç°ä¸å¯è¡Œã€‚ç„¶åæš´åŠ›æœç´¢ï¼Œè¶…æ—¶äº†ï¼Œæš´æœæ—¶è€ƒè™‘æ·»åŠ éš”æ¿ï¼Œå…¶ä¸­left_valueè¡¨ç¤ºå½“å‰æœç´¢ä¸‹æ ‡iä¹‹å‰çš„åˆ†ç»„å¹³å‡å€¼ ç±»ä¼¼èƒŒåŒ…12345678910111213141516171819202122232425262728class Solution {public: double largestSumOfAverages(vector&lt;int&gt;&amp; nums, int k) { int len = nums.size(); vector&lt;int&gt; sum(len+1, 0); vector&lt;vector&lt;double&gt;&gt; left_avg(k-1, vector&lt;double&gt;(len, 0)); for(int i = 1; i &lt;= len; i++) { sum[i] = nums[i-1] + sum[i-1]; } double maxx = sum[len] / (len + 0.0); if(k &lt;= 1) return maxx; for(int i = 1; i &lt; len; i++) { left_avg[0][i] = double(sum[i])/i; maxx = max(maxx, left_avg[0][i] + double(sum[len] - sum[i])/(len-i)); } for(int i = 0; i &lt; k-2; i++) { //ç¬¬å‡ ä¸ªéš”æ¿ for(int j = i+1; j &lt; len; j++) { // å‰ä¸€ä¸ªéš”æ¿çš„ä½ç½® for(int p = j+1; p &lt; len; p++) { // ç°åœ¨éš”æ¿çš„ä½ç½® maxx = max(left_avg[i][j] + double(sum[p] - sum[j])/(p-j) + double(sum[len] - sum[p])/(len-p), maxx); // left_avg + å½“å‰éš”æ¿ä¸ä¸Šä¸€ä¸ªéš”æ¿çš„avgï¼Œ æœ€åä¸€ä¸ªæ•°åˆ°å½“å‰éš”æ¿çš„avg left_avg[i+1][p] = max(left_avg[i][j] + double(sum[p] - sum[j])/(p-j), left_avg[i+1][p]); // æ›´æ–°avg } } } return maxx; }}; ä»Šå¤©è€ƒè™‘ç”¨ç±»ä¼¼èƒŒåŒ…çš„æƒ³æ³•ï¼Œç»“åˆæš´åŠ›æœç´¢çš„left_avgï¼Œç”¨$ left_avg[i][j] $ ï¼Œè¡¨ç¤ºæ·»åŠ iä¸ªéš”æ¿ï¼Œåœ¨jä¹‹å‰çš„æœ€å¤§left_avgä»ç¬¬äºŒä¸ªéš”æ¿å¼€å§‹ï¼Œå‡è®¾ç¬¬iä¸ªéš”æ¿åˆ†åˆ«åœ¨ä½ç½® $j = i+1,i+2,i+3 â€¦$ æ—¶ï¼Œç¬¬ $i+1$ä¸ªéš”æ¿å¯ä»¥åœ¨ $p = j+1, j+2, â€¦$è®¡ç®—å‰åä¸¤ä¸ªéš”æ¿å„ç§æƒ…å†µçš„æœ€å¤§å€¼ï¼Œæ›´æ–°left_avgï¼Œæ›´æ–°maxx ä¼˜åŒ–1234567891011121314151617181920212223242526272829class Solution {public: double largestSumOfAverages(vector&lt;int&gt;&amp; nums, int k) { int len = nums.size(); vector&lt;int&gt; sum(len+1, 0); for(int i = 1; i &lt;= len; i++) { sum[i] = nums[i-1] + sum[i-1]; } if(k &lt;= 1) return sum[len] / (len + 0.0); vector&lt;vector&lt;double&gt;&gt; left_avg(k-1, vector&lt;double&gt;(len, 0)); for(int i = 1; i &lt; len; i++) { left_avg[0][i] = double(sum[i])/i; } for(int i = 0; i &lt; k-2; i++) { for(int j = i+1; j &lt; len-1; j++) { for(int p = j+1; p &lt; len; p++) { left_avg[i+1][p] = max(left_avg[i][j] + double(sum[p] - sum[j])/(p-j), left_avg[i+1][p]); } } } double maxx = 0; for(int i = 0; i &lt; k-1; i++) { for(int j = 0; j &lt; len; j++) { maxx = max(left_avg[i][j]+double(sum[len] - sum[j])/(len-j), maxx); } } return maxx; }}; å‡å°‘maxxè®¡ç®—æ¬¡æ•° 1752. æ£€æŸ¥æ•°ç»„æ˜¯å¦ç»æ’åºå’Œè½®è½¬å¾—åˆ°123456789101112class Solution {public: bool check(vector&lt;int&gt;&amp; nums) { int i = 1, j = 0; int len = nums.size(); while(i &lt; len &amp;&amp; nums[i-1] &lt;= nums[i]) i++; if(i == len) return true; j = i+1; while(j &lt; len &amp;&amp; nums[j-1] &lt;= nums[j]) j++; return j == len &amp;&amp; nums[len-1] &lt;= nums[0]; }}; 882. ç»†åˆ†å›¾ä¸­çš„å¯åˆ°è¾¾èŠ‚ç‚¹æš´æœè¶…æ—¶12345678910111213141516171819202122232425262728293031323334353637383940class Solution {public: vector&lt;vector&lt;int&gt;&gt; graph; vector&lt;bool&gt; global_visited; int res = 0; vector&lt;vector&lt;int&gt;&gt; copy_edges; int reachableNodes(vector&lt;vector&lt;int&gt;&gt;&amp; edges, int maxMoves, int n) { int edge_size = edges.size(); graph = vector&lt;vector&lt;int&gt;&gt;(n); global_visited = vector&lt;bool&gt;(n, false); copy_edges = vector&lt;vector&lt;int&gt;&gt;(2,vector&lt;int&gt;(edge_size, 0)); for(int i = 0; i &lt; edge_size; i++) { graph[edges[i][0]].push_back(i); graph[edges[i][1]].push_back(i); } dfs(std::move(edges), 0, maxMoves); for(int i = 0; i &lt; edge_size; i++) { res += min(edges[i][2], copy_edges[0][i] + copy_edges[1][i]); } for(int i = 0; i &lt; n; i++) { if(global_visited[i]) { res++; } } return res; } void dfs(vector&lt;vector&lt;int&gt;&gt;&amp;&amp; edges, int node, int move) { global_visited[node] = true; if(move &lt;= 0) return; for(int e : graph[node]) { int w = edges[e][2]; int next = edges[e][0] == node ? edges[e][1] : edges[e][0]; int direction = edges[e][0] == node ? 0 : 1; copy_edges[direction][e] = max(min(w, move), copy_edges[direction][e]); if(move &gt; w) { dfs(std::move(edges), next, move-w-1); } } }}; djikstra-é¢˜è§£123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: int encode(int u, int v, int n) { return u * n + v; } int reachableNodes(vector&lt;vector&lt;int&gt;&gt;&amp; edges, int maxMoves, int n) { vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adList(n); for (auto &amp;edge : edges) { int u = edge[0], v = edge[1], nodes = edge[2]; adList[u].emplace_back(v, nodes); adList[v].emplace_back(u, nodes); } unordered_map&lt;int, int&gt; used; unordered_set&lt;int&gt; visited; int reachableNodes = 0; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; pq.emplace(0, 0); while (!pq.empty() &amp;&amp; pq.top().first &lt;= maxMoves) { auto [step, u] = pq.top(); pq.pop(); if (visited.count(u)) { continue; } visited.emplace(u); reachableNodes++; for (auto [v, nodes] : adList[u]) { if (nodes + step + 1 &lt;= maxMoves &amp;&amp; !visited.count(v)) { pq.emplace(nodes + step + 1, v); } used[encode(u, v, n)] = min(nodes, maxMoves - step); } } for (auto &amp;edge : edges) { int u = edge[0], v = edge[1], nodes = edge[2]; reachableNodes += min(nodes, used[encode(u, v, n)] + used[encode(v, u, n)]); } return reachableNodes; }};","link":"/home/2022/11/28/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9320/"},{"title":"LeetCode-22","text":"2347. æœ€å¥½çš„æ‰‘å…‹æ‰‹ç‰Œ12345678910111213141516171819202122232425class Solution {public: string bestHand(vector&lt;int&gt;&amp; ranks, vector&lt;char&gt;&amp; suits) { vector&lt;int&gt; rank_count(13, 0), suits_count(4, 0); for(int i = 0; i &lt; 5; i++) { rank_count[ranks[i]-1]++; suits_count[suits[i] - 'a']++; } int count = 0; for(int i = 0; i &lt; 4; i++) { count = max(count, suits_count[i]); } if(count == 5) return &quot;Flush&quot;; count = 0; for(int i = 0; i &lt; 13; i++) { count = max(count, rank_count[i]); } if(count &gt;= 3) { return &quot;Three of a Kind&quot;; } else if (count == 2) { return &quot;Pair&quot;; } return &quot;High Card&quot;; }}; 1604. è­¦å‘Šä¸€å°æ—¶å†…ä½¿ç”¨ç›¸åŒå‘˜å·¥å¡å¤§äºç­‰äºä¸‰æ¬¡çš„äºº123456789101112131415161718192021222324252627class Solution {public: vector&lt;string&gt; alertNames(vector&lt;string&gt;&amp; keyName, vector&lt;string&gt;&amp; keyTime) { map&lt;string, vector&lt;int&gt;&gt; hour_count; int len = keyName.size(); for(int i = 0; i &lt; len; i++) { int h = (keyTime[i][0]-'0')*10 + keyTime[i][1] - '0', m = (keyTime[i][3] - '0') * 10 + keyTime[i][4] - '0'; hour_count[keyName[i]].push_back(h*60+m); } vector&lt;string&gt; warning_list; for(auto ite = hour_count.begin(); ite != hour_count.end(); ite++) { bool warn = false; sort(ite-&gt;second.begin(), ite-&gt;second.end()); int len = ite-&gt;second.size(); for(int i = 0; i &lt; len-2; i++) { if(ite-&gt;second[i+2] - ite-&gt;second[i] &lt;= 60) { warn = true; break; } } if(warn) { warning_list.push_back(ite-&gt;first); } } return warning_list; }}; 1234567891011121314151617181920212223242526272829303132333435class Solution {public: vector&lt;string&gt; alertNames(vector&lt;string&gt;&amp; keyName, vector&lt;string&gt;&amp; keyTime) { map&lt;string, priority_queue&lt;int&gt;&gt; hour_count; int len = keyName.size(); for(int i = 0; i &lt; len; i++) { int h = (keyTime[i][0]-'0')*10 + keyTime[i][1] - '0', m = (keyTime[i][3] - '0') * 10 + keyTime[i][4] - '0'; hour_count[keyName[i]].push(h*60+m); } vector&lt;string&gt; warning_list; for(auto ite = hour_count.begin(); ite != hour_count.end(); ite++) { int len = ite-&gt;second.size(); if(len &lt;= 2) continue; int a, b, c; a = ite-&gt;second.top(); ite-&gt;second.pop(); b = ite-&gt;second.top(); ite-&gt;second.pop(); c = ite-&gt;second.top(); ite-&gt;second.pop(); bool warn = a - c &lt;= 60; while(!warn &amp;&amp; !ite-&gt;second.empty()) { a = b; b = c; c = ite-&gt;second.top(); ite-&gt;second.pop(); warn = a - c &lt;= 60; } if(warn) { warning_list.push_back(ite-&gt;first); } } return warning_list; }}; 2331. è®¡ç®—å¸ƒå°”äºŒå‰æ ‘çš„å€¼123456789class Solution {public: bool evaluateTree(TreeNode* root) { if(root-&gt;val &lt;= 1) return root-&gt;val == 1 ? true : false; bool left = evaluateTree(root-&gt;left); bool right = evaluateTree(root-&gt;right); return root-&gt;val == 2 ? left||right : left&amp;&amp;right; }}; 1798. ä½ èƒ½æ„é€ å‡ºè¿ç»­å€¼çš„æœ€å¤§æ•°ç›®1234567891011121314class Solution {public: int getMaximumConsecutive(vector&lt;int&gt;&amp; coins) { int res = 1; sort(coins.begin(), coins.end()); for (auto&amp; i : coins) { if (i &gt; res) { break; } res += i; } return res; }}; ç›´æ¥æŠ„çš„ç­”æ¡ˆï¼Œè´ªå¿ƒï¼Œä»£ç çš„æ„æ€å°±æ˜¯æ’åºï¼Œä»å°åˆ°å¤§åŠ èµ·æ¥æ²¡æ³¨æ„åˆ°é¢˜ç›®æ¡ä»¶è¦æ±‚æ˜¯ä»0å¼€å§‹çš„ï¼Œè¿™ä¸€ç‚¹å¾ˆé‡è¦è‹¥æœ€å¤§åªèƒ½åˆ°1ï¼Œåˆ™æ•°ç»„ä¸º [1]è‹¥æœ€å¤§åªèƒ½åˆ°2ï¼Œåˆ™æ•°ç»„ä¸º [1 1] (ä¸èƒ½æ˜¯[2]ï¼Œå› ä¸ºè¿™æ ·æ²¡æœ‰æ— æ³•ç»„å‡º1)è‹¥æœ€å¤§åªèƒ½åˆ°3ï¼Œåˆ™æ•°ç»„ä¸º [1 1 1], [1 2]è‹¥æœ€å¤§åªèƒ½åˆ°4ï¼Œåˆ™æ•°ç»„ä¸º [1 1 1 1], [1 1 2]è‹¥æœ€å¤§åªèƒ½åˆ°5ï¼Œåˆ™æ•°ç»„ä¸º [1 1 1 1 1], [1 1 1 2], [1 1 3] è§‚å¯Ÿä¸Šé¢åˆ—è¡¨å¯çŸ¥ï¼Œè‹¥æœ€å¤§åªèƒ½åˆ°5ï¼Œåˆ™æ˜¯æœ€å¤§åˆ°4åœ¨å¤šé¢å¤–çš„1ï¼Œæˆ–è€…æœ€å¤§åˆ°2ä¸”é¢å¤–çš„ä¸€ä¸ª3ï¼Œè¿™é‡Œå°±èƒ½çœ‹åˆ°ä»¤resåˆå§‹ä¸º1ï¼Œå°†æ•°ç»„æ’åºåï¼Œç›¸åŠ ï¼Œç›´åˆ°coins[i] &gt; resä¸ºæ­¢ 1145. äºŒå‰æ ‘ç€è‰²æ¸¸æˆ è¿™é“é¢˜çš„æè®®æ˜¯ï¼Œç¬¬ä¸€æ­¥redå…ˆæ‰‹ï¼Œblueåæ‰‹é€‰æ‹©äºŒå‰æ ‘ä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹é€‰æ‹©åçš„æ¯ä¸€æ­¥ï¼Œä¸¤ä¸ªç©å®¶åªèƒ½é€‰æ‹©å½“å‰æ‰€é€‰æ‰€æœ‰èŠ‚ç‚¹çš„æœªæ¶‚è‰²çš„é‚»æ¥èŠ‚ç‚¹â€œæˆ‘â€ä½œä¸ºåæ‰‹çš„äºŒå·èŠ‚ç‚¹ï¼Œå¦‚ä½•é€‰æ‹©æˆ‘çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè®©æˆ‘èƒ½æ¶‚è‰²çš„èŠ‚ç‚¹å¤§äºå…ˆæ‰‹çš„redä¸ºäº†åˆ©ç›Šæœ€å¤§åŒ–ï¼Œåªæœ‰ä¸‰ç§é€‰æ‹©ï¼Œé€‰æ‹©xçš„çˆ¶èŠ‚ç‚¹ï¼Œå·¦å­©å­æˆ–å³å­©å­é€‰æ‹©çˆ¶èŠ‚ç‚¹ï¼Œåˆ™xåŠxæ‰€æœ‰å­èŠ‚ç‚¹éƒ½ä¼šè¢«redæ¶‚è‰²ï¼Œè‡ªå·±åªèƒ½æ¶‚è‰²n-redä¸ªé€‰æ‹©å·¦å­©å­ï¼Œè‡ªå·±åªèƒ½æ¶‚è‰²xçš„å·¦å­©å­ä»¥åŠå·¦å­©å­çš„æ‰€æœ‰å­ä»£èŠ‚ç‚¹é€‰æ‹©å³å­©å­ï¼Œä¸å·¦å­©å­åŒç†ä»¥ä¸Šä¸‰ç§æƒ…å†µï¼Œåˆ†åˆ«è®¡ç®—redå’Œblueï¼Œåªè¦æœ‰ä¸€ç§æƒ…å†µå¯ä»¥ä½¿å¾—red &lt; blueï¼Œåˆ™blueä¸€å®šå¯ä»¥èƒœåˆ©ï¼Œå¦åˆ™ä¸€å®šä¸èƒ½èƒœåˆ© 123456789101112131415161718192021222324252627282930class Solution {public: bool btreeGameWinningMove(TreeNode* root, int root_sum, int x) { TreeNode* find = search(root, x); int red = sum(find); if(red &lt; root_sum - red) return true; int blue = sum(find-&gt;left); if(root_sum - blue &lt; blue) return true; blue = sum(find-&gt;right); if(root_sum - blue &lt; blue) return true; return false; } int sum(TreeNode* node) { if(node == nullptr) return 0; return 1 + sum(node-&gt;left) + sum(node-&gt;right); } TreeNode* search(TreeNode* node, int target) { if(node-&gt;val == target) { return node; } TreeNode* find = nullptr; if(node-&gt;left != nullptr) find = search(node-&gt;left, target); if(find != nullptr) return find; if(node-&gt;right != nullptr) find = search(node-&gt;right, target); return find; }}; è®¤çœŸè¯»é¢˜å‘ç°nå°±æ˜¯æ€»èŠ‚ç‚¹æ•°ï¼Œä¸ç”¨å†ç®—ä¸€éäº† 1129. é¢œè‰²äº¤æ›¿çš„æœ€çŸ­è·¯å¾„BFS12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution {public: const bool RED = true; const bool BLUE = false; vector&lt;vector&lt;pair&lt;bool, int&gt;&gt;&gt; graph; vector&lt;int&gt; answer; vector&lt;map&lt;pair&lt;bool, int&gt;, bool&gt;&gt; visited; vector&lt;int&gt; shortestAlternatingPaths(int n, vector&lt;vector&lt;int&gt;&gt;&amp; redEdges, vector&lt;vector&lt;int&gt;&gt;&amp; blueEdges) { visited = vector&lt;map&lt;pair&lt;bool, int&gt;, bool&gt;&gt;(n); graph = vector&lt;vector&lt;pair&lt;bool, int&gt;&gt;&gt;(n); for(auto&amp; edge: redEdges) { visited[edge[0]][make_pair(RED, edge[1])] = false; graph[edge[0]].push_back(make_pair(RED, edge[1])); } for(auto&amp; edge: blueEdges) { visited[edge[0]][make_pair(BLUE, edge[1])] = false; graph[edge[0]].push_back(make_pair(BLUE, edge[1])); } answer = vector&lt;int&gt;(n, INT_MAX); search(); for(int i = 1; i &lt; n; i++) { if(answer[i] == INT_MAX) answer[i] = -1; } answer[0] = 0; return answer; } void search() { int len = 0; queue&lt;pair&lt;bool, int&gt;&gt; q; q.push(make_pair(RED, 0)); q.push(make_pair(BLUE, 0)); while(!q.empty()) { queue&lt;pair&lt;bool, int&gt;&gt; tmp; while(!q.empty()) { auto [color, node] = q.front(); q.pop(); for(auto&amp; edge:graph[node]) { if(edge.first != color &amp;&amp; !visited[node][edge]) { answer[edge.second] = min(answer[edge.second], len+1); tmp.push(edge); visited[node][edge] = true; } } } len++; q = tmp; } }}; ä¸å¿…é‡å¤éå†è¾¹ç”±äºè‡ªç¯ï¼Œå¹³è¡Œè¾¹çš„å­˜åœ¨ï¼ŒåŒä¸€ä¸ªèŠ‚ç‚¹å¯ä»¥é‡å¤éå†ï¼Œè¿™æ ·å¯ä»¥å‡‘å‡ºçº¢è“äº¤æ›¿çš„è·¯å¾„å¯¹äºè¾¹ï¼Œå®šä¹‰ä¸ºpair&lt;bool, int&gt;ï¼Œä»£è¡¨&lt;color, next&gt;bfsæ—¶ï¼Œé€‰å–ä¸ä¸Šä¸€æ¡è¾¹é¢œè‰²ç›¸åçš„è¾¹å…¥é˜Ÿ dfs1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: const bool RED = true; const bool BLUE = false; vector&lt;vector&lt;pair&lt;bool, int&gt;&gt;&gt; graph; vector&lt;map&lt;pair&lt;bool, int&gt;, bool&gt;&gt; visited; vector&lt;int&gt; shortestAlternatingPaths(int n, vector&lt;vector&lt;int&gt;&gt;&amp; redEdges, vector&lt;vector&lt;int&gt;&gt;&amp; blueEdges) { graph = vector&lt;vector&lt;pair&lt;bool, int&gt;&gt;&gt;(n); for(auto&amp; edge: redEdges) { graph[edge[0]].push_back(make_pair(RED, edge[1])); } for(auto&amp; edge: blueEdges) { graph[edge[0]].push_back(make_pair(BLUE, edge[1])); } vector&lt;int&gt; answer(n); for(int i = 1; i &lt; n; i++) { visited = vector&lt;map&lt;pair&lt;bool, int&gt;, bool&gt;&gt;(n); for(auto&amp; edge: redEdges) { visited[edge[0]][make_pair(RED, edge[1])] = false; } for(auto&amp; edge: blueEdges) { visited[edge[0]][make_pair(BLUE, edge[1])] = false; } answer[i] = min(search(0, i, 0, RED), search(0, i, 0, BLUE)); if(answer[i] == INT_MAX) answer[i] = -1; } return answer; } int search(int node, int target, int len, bool last_color) { if(node == target) return len; int find = INT_MAX; for(auto&amp; edge : graph[node]) { if(edge.first != last_color &amp;&amp; !visited[node][edge]) { visited[node][edge] = true; find = min(search(edge.second, target, len+1, edge.first), find); visited[node][edge] = false; } } return find; }}; è¶…æ—¶ï¼Œä½†åº”è¯¥æ˜¯æ­£ç¡®çš„å¤æ‚åº¦ $ O(n^2) $ 1806. è¿˜åŸæ’åˆ—çš„æœ€å°‘æ“ä½œæ­¥æ•°æ¨¡æ‹Ÿ12345678910111213141516171819202122232425262728class Solution {public: int n; int reinitializePermutation(int n) { this-&gt;n = n; vector&lt;int&gt; arr(n),tmp(n), *x, *y; for(int i = 0; i &lt; n; i++) { arr[i] = i%2 == 0 ? i/2 : n/2+(i-1)/2; } int step = 1; x = &amp;arr; y = &amp;tmp; while(!ok(x)) { for(int i = 0; i &lt; n; i++) { (*y)[i] = i%2 == 0 ? (*x)[i/2] : (*x)[n/2+(i-1)/2]; } swap(x, y); step++; } return step; } bool ok(vector&lt;int&gt;* arr) { for(int i = 0; i &lt; n; i++) { if((*arr)[i] != i) return false; } return true; }}; æ¨¡æ‹Ÿ21234567891011121314151617class Solution {public: int n; int reinitializePermutation(int n) { this-&gt;n = n; vector&lt;int&gt; arr(n); for(int i = 0; i &lt; n; i++) { arr[i] = i%2 == 0 ? i/2 : n/2+(i-1)/2; } int step = 1, p = arr[1]; while(p != 1) { p = arr[p]; step++; } return step; }}; 238. é™¤è‡ªèº«ä»¥å¤–æ•°ç»„çš„ä¹˜ç§¯123456789101112131415class Solution {public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) { int len = nums.size(); vector&lt;int&gt; l(len, 1), r(len,1); for(int i = 1; i &lt; len; i++) { l[i] = l[i-1] * nums[i-1]; r[len-i-1] = r[len-i] * nums[len-i]; } for(int i = 0; i &lt; len; i++) { nums[i] = l[i]*r[i]; } return nums; }}; ç©ºé—´O(1)12345678910111213141516class Solution {public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) { int len = nums.size(); vector&lt;int&gt; res(len, 1); for(int i = 1; i &lt; len; i++) { res[len-i-1] = res[len-i] * nums[len-i]; } int left = 1; for(int i = 0; i &lt; len; i++) { res[i] = left*res[i]; left *= nums[i]; } return res; }}; ä»–è¿™é‡Œå¯¹ $ O(1) $ çš„å®šä¹‰æ˜¯é™¤äº†è¾“å…¥è¾“å‡ºæ•°ç»„å¤–ï¼Œåªç”¨å¸¸é‡çº§çš„ç©ºé—´ï¼Œå¾ˆå®¹æ˜“æƒ³åˆ°læ•°ç»„å¯ä»¥ä¼˜åŒ– 2357. ä½¿æ•°ç»„ä¸­æ‰€æœ‰å…ƒç´ éƒ½ç­‰äºé›¶1234567891011121314class Solution {public: int minimumOperations(vector&lt;int&gt;&amp; nums) { unordered_map&lt;int, int&gt; m; for(int n:nums) { if(n &gt; 0) { m[n]++; } } int count = 0; for(auto ite=m.begin(); ite != m.end(); ite++,count++); return count; }}; 1238. å¾ªç¯ç æ’åˆ—äºŒå‰æ ‘123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;int&gt; res; vector&lt;int&gt; circularPermutation(int n, int start) { int len = 1 &lt;&lt; n; res = vector&lt;int&gt;(len); vector&lt;int&gt; rotate(len); int split = 2; for(int i = 0; i &lt; n; i++) { int a = 0; for(int j = 0; j &lt; split; j++) { cal(len/split*j, len/split*(j+1), a); if(j%2==0) a = !a; } split &lt;&lt;= 1; } int k = 0; while(k &lt; len &amp;&amp; res[k] != start) k++; for(int i = 0; i &lt; len; i++) { rotate[i] = res[(i+k)%len]; } return rotate; } void cal(int i, int j, int a) { for(; i &lt; j; i++) { res[i] &lt;&lt;= 1; res[i] += a&amp;1; } }}; æŠŠä»–æƒ³æˆä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ¯å±‚æŒ‰ç…§0110çš„é¡ºåºç”Ÿæˆ äºŒå‰æ ‘1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: vector&lt;int&gt; res; vector&lt;int&gt; circularPermutation(int n, int start) { int len = 1 &lt;&lt; n; vector&lt;int&gt; rotate(len); queue&lt;TreeNode*&gt; q; for(int i = 0; i &lt; len; i++) { q.push(new TreeNode(i)); } TreeNode* root = nullptr; while(!q.empty()) { TreeNode *n1 = q.front(), *n2 = nullptr; q.pop(); if(!q.empty()) { n2 = q.front(); q.pop(); q.push(new TreeNode(n1-&gt;val + n2-&gt;val, n1, n2)); } else { root = n1; break; } } flip(root); treavourse(root); int k = 0; while(k &lt; len &amp;&amp; res[k] != start) k++; for(int i = 0; i &lt; len; i++) { rotate[i] = res[(i+k)%len]; } return rotate; } void treavourse(TreeNode* root) { if(root-&gt;left != nullptr &amp;&amp; root-&gt;right != nullptr) { treavourse(root-&gt;left); treavourse(root-&gt;right); } else { res.push_back(root-&gt;val); } } void flip(TreeNode* root) { if(root-&gt;left == nullptr || root-&gt;right == nullptr) return; swap(root-&gt;right-&gt;left, root-&gt;right-&gt;right); flip(root-&gt;left); flip(root-&gt;right); }}; ç¿»è½¬äºŒå‰æ ‘ï¼Œå…ˆåºæŠŠå³å­©å­çš„å·¦å³å­©å­äº’æ¢ æ ¼é›·ç 123456789101112131415161718192021222324252627class Solution {public: vector&lt;int&gt; res; vector&lt;int&gt; circularPermutation(int n, int start) { int len = 1 &lt;&lt; n; res = vector&lt;int&gt;(len); int split = 2; for(int i = 0; i &lt; n; i++) { int a = 0; for(int j = 0; j &lt; split; j++) { cal(len/split*j, len/split*(j+1), a); if(j%2==0) a = !a; } split &lt;&lt;= 1; } for(int i = 0; i &lt; len; i++) { res[i] = res[i] ^ start; } return res; } void cal(int i, int j, int a) { for(; i &lt; j; i++) { res[i] &lt;&lt;= 1; res[i] += a&amp;1; } }}; æ ¼é›·ç æœ‰ä»–çš„ç”Ÿæˆå…¬å¼ 12345678910class Solution {public: vector&lt;int&gt; circularPermutation(int n, int start) { vector&lt;int&gt; ret(1 &lt;&lt; n); for (int i = 0; i &lt; ret.size(); i++) { ret[i] = (i &gt;&gt; 1) ^ i ^ start; } return ret; }}; 1326. çŒæº‰èŠ±å›­çš„æœ€å°‘æ°´é¾™å¤´æ•°ç›®dp123456789101112131415161718class Solution {public: int minTaps(int n, vector&lt;int&gt;&amp; ranges) { vector&lt;int&gt; dp(n+1, INT_MAX), index(n+1); for(int i = 0; i &lt;= n; i++) index[i] = i; sort(index.begin(), index.end(), [&amp;ranges](int i, int j)-&gt;bool{return i-ranges[i] &lt; j-ranges[j];}); dp[0] = 0; for(int i = 0; i &lt;= n; i++) { int start = max(index[i] - ranges[index[i]], 0); int end = min(index[i] + ranges[index[i]], n); if(dp[start] == INT_MAX) return -1; for(int j = start; j &lt;= end; j++) { dp[j] = min(dp[start]+1, dp[j]); } } return dp[n]; }}; $dp[i]$è¡¨ç¤ºåŒºé—´$[0, i]$è¢«çŒæº‰æ‰€éœ€çš„æœ€å°‘æ°´é¾™å¤´æ•°å°†$ranges[i]$æŒ‰ç…§$i-ranges[i]$ä»å°åˆ°å¤§æ’åºæŒ‰é¡ºåºéå†æ’åºå¥½çš„rangesï¼Œè®¡ç®—å…¶$start,end$$start$å¤„å·²ç»è®¡ç®—å‡ºå…¶æ‰€éœ€æœ€å°æ°´é¾™å¤´æ•°äº†ï¼Œæœ‰ä¸¤ç§æƒ…å†µ å½“å‰$ [0, x] $å·²çŸ¥, $ start &lt;= end &lt;= x $, åˆ™$[start, end]$ä¹‹é—´æœ€å°‘æ°´é¾™å¤´æ•°ä¿æŒä¸å˜ å½“å‰$ [0, x] $å·²çŸ¥, $ start &lt;= x &lt; end $, åˆ™$[start+1, end]$ä¹‹é—´æœ€å°‘æ°´é¾™å¤´æ•°ä¸º$dp[start]+1$ å½“å‰$ [0, x] $å·²çŸ¥, $ x &lt; start &lt;= end $, åˆ™æ— è§£ è´ªå¿ƒ12345678910111213141516171819class Solution {public: int minTaps(int n, vector&lt;int&gt;&amp; ranges) { vector&lt;int&gt; right(n+1); for(int i = 0; i &lt;= n; i++) right[max(0, i-ranges[i])] = max(min(i + ranges[i],n), right[max(0, i-ranges[i])]); int last = 0; int ret = 0; int pre = 0; for(int i = 0; i &lt; n; i++) { last = max(last, right[i]); if(i == last) return -1; if(i == pre) { ret++; pre = last; } } return ret; }}; $right[start]$è¡¨ç¤ºä»$start$ä½ç½®ï¼Œç»è¿‡æŸä¸ªæ°´é¾™å¤´çš„æµ‡çŒæœ€è¿œèƒ½åˆ°è¾¾çš„ä½ç½®$last$è¡¨ç¤ºå½“å‰æœ€è¿œåˆ°è¾¾çš„ä½ç½®ï¼Œ$pre$è¡¨ç¤ºä¸Šä¸€ä¸ªä½¿ç”¨çš„æ°´é¾™å¤´æœ€è¿œçš„ä½ç½®ä»å·¦å‘å³éå†ï¼Œä¸€è¾¹éå†ä¸€éå¯»æ‰¾æœ€è¿œèƒ½åˆ°è¾¾çš„ä½ç½®ï¼Œå¦‚æœ$i$åˆ°è¾¾äº†æœ€è¿œèƒ½åˆ°è¾¾çš„ä½ç½®ä¸”ä¸æ˜¯nï¼Œè¯´æ˜æ— æ³•è¦†ç›–ã€‚å¦‚æœié‡åˆ°äº†å‰ä¸€ä¸ªæ°´é¾™å¤´çš„è¾¹ç•Œï¼Œè¯´æ˜æ¥ä¸‹æ¥è¯¥ä½¿ç”¨ä¸‹ä¸€ä¸ªæ°´é¾™å¤´äº† 1247. äº¤æ¢å­—ç¬¦ä½¿å¾—å­—ç¬¦ä¸²ç›¸åŒ123456789101112131415161718192021class Solution {public: int minimumSwap(string s1, string s2) { int count[2][2] = {0}; int len = s1.length(); for(int i= 0; i &lt; len; i++) { if(s1[i] == 'x' &amp;&amp; s2[i] == 'y') { count[0][1]++; } else if(s1[i] == 'y' &amp;&amp; s2[i] == 'x') { count[1][0]++; } } int res = count[0][1]/2 + count[1][0]/2; if(count[0][1]%2 == 1 &amp;&amp; count[1][0]%2 == 1) { res+=2; } else if(count[0][1]%2 || count[1][0]%2) { return -1; } return res; }}; æ ¹æ®é¢˜ç›®çš„æ ·ä¾‹ â€œxxâ€+â€yyâ€å‹(â€œyyâ€+â€xxâ€å‹)ï¼Œåªéœ€è¦ä¸€æ­¥â€œxyâ€+â€yxâ€å‹(â€œyxâ€+â€xyâ€å‹)ï¼Œéœ€è¦ä¸¤æ­¥äº¤æ¢æ—¶å¯ä»¥ä¸¤ä¸ªå­—ç¬¦ä¸²ä¸Šä»»æ„ä¸¤ä¸ªä½ç½®è¿›è¡Œäº¤æ¢ã€‚ 1703. å¾—åˆ°è¿ç»­ K ä¸ª 1 çš„æœ€å°‘ç›¸é‚»äº¤æ¢æ¬¡æ•°123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: int k; int minMoves(vector&lt;int&gt;&amp; nums, int k) { int i = 0, j = 0, n = nums.size(); this-&gt;k = k; queue&lt;int&gt; index, wait; for(int i = 0; i &lt; n; i++) { if(nums[i] == 1) { index.push(i); } } for(int i = 0; i &lt; k; i++) { wait.push(index.front()); index.pop(); } int minn = cal(wait); while(!index.empty()) { wait.push(index.front()); index.pop(); wait.pop(); minn = min(cal(wait), minn); } return minn; } int cal(queue&lt;int&gt; q) { int l = 0, r = 0, count = 1, last = q.front(); for(int i = 0; i &lt; k/2; i++) { q.pop(); l += count * (q.front() - last - 1); count++; last = q.front(); } last = q.front(); for(int i = k/2; i &lt; k-1; i++) { q.pop(); r += (k - i - 1) * (q.front() - last - 1); last = q.front(); } return l + r; }}; ä¸¤ä¸ªé˜Ÿåˆ— index å’Œ queindexå­˜æ”¾å€¼ä¸º1çš„ä¸‹è¡¨ä»indexå–kä¸ªæ”¾å…¥queè®¡ç®—queçš„é•¿åº¦queä¸­popä¸€ä¸ªï¼Œindexä¹Ÿpopä¸€ä¸ªæ”¾å…¥indexï¼Œå†æ¬¡è®¡ç®—indexï¼Œç›´åˆ°indexä¸ºç©ºå–æ¯æ¬¡è®¡ç®—queçš„æœ€å°å€¼queè®¡ç®—é•¿åº¦æ—¶ï¼Œä»ä¸­é—´ä¸€åˆ†ä¸ºäºŒï¼Œå°†ä¸¤è¾¹çš„1å‘æœ€ä¸­é—´çš„1é æ‹¢ç§»åŠ¨ã€‚ ä¼˜åŒ–1123456789101112131415161718192021222324252627282930313233343536class Solution {public: int k; int minMoves(vector&lt;int&gt;&amp; nums, int k) { int i = 0, j = 0, count = 0, n = nums.size(); this-&gt;k = k; vector&lt;int&gt; index(n); int minn = INT_MAX; for(int i = 0; i &lt; n; i++) { if(nums[i] == 1) { index[j] = i; j++; if(j &gt;= k) { minn = min(cal(move(index), count), minn); count++; } } } return minn; } int cal(vector&lt;int&gt;&amp;&amp; v, int start) { int l = 0, r = 0; int li = 0; for(int i = k/2; i &gt; 0; i--) { li += (v[i+start] - v[i+start-1] - 1); l += li; } int ri = 0; for(int i = k/2; i &lt; k-1; i++) { ri += (v[i+start+1] - v[i+start] - 1); r += ri; } return l + r; }}; é¢˜è§£12345678910111213141516171819202122232425262728293031323334class Solution {public: int minMoves(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); int minn = 0, cost = 0; vector&lt;int&gt; left{0}, zero; int leftSum = 0; int i = 0; for(; i &lt; n &amp;&amp; nums[i] == 0; i++); for(; i &lt; n;) { i++; int count; for(count = 0; i &lt; n &amp;&amp; nums[i] == 0; i++, count++); leftSum += count; if(i &lt; n) { zero.push_back(count); left.push_back(leftSum); } } int l = 0, r = k-2; for(int i = l; i &lt;= r; i++) { cost += zero[i] * min(1+i, 1+r-i); } minn=cost; int nn = zero.size(); for(int i = 1, j = k-1; j &lt; nn; i++, j++) { int mid = (i+j)/2; cost -= left[mid] - left[i-1]; cost += left[j+1] - left[mid+k%2]; minn = min(minn, cost); } return minn; }}; å‚è€ƒé¢˜è§£ï¼Œ å°±æ˜¯æ‰¾åˆ°çª—å£æ»‘åŠ¨æ—¶ï¼Œcostçš„O(1)çš„æ›´æ–°æ–¹æ³• 1255. å¾—åˆ†æœ€é«˜çš„å•è¯é›†åˆ12345678910111213141516171819202122232425262728class Solution {public: int wn; int maxScoreWords(vector&lt;string&gt;&amp; words, vector&lt;char&gt;&amp; letters, vector&lt;int&gt;&amp; score) { wn = words.size(); int ln = letters.size(); vector&lt;int&gt; letterCount = vector&lt;int&gt;(26); for(int i = 0; i &lt; ln; i++) { letterCount[letters[i] - 'a']++; } return dfs(0, words, score, letterCount); } int dfs(int index, vector&lt;string&gt;&amp; words, vector&lt;int&gt;&amp; score, vector&lt;int&gt; state) { if(index &gt;= wn) return 0; int scoreNext = dfs(index+1, words, score, state); int wlen = words[index].length(); int scorei = 0; for(int i = 0; i &lt; wlen; i++) { if(state[words[index][i] - 'a'] &gt; 0) { state[words[index][i] - 'a']--; scorei += score[words[index][i] - 'a']; } else { return scoreNext; } } return max(scoreNext, scorei + dfs(index+1, words, score, state)); }}; è‰ºæœ¯ï¼Œå°±æ˜¯æš´æœï¼ï¼ï¼ç„¶åå†è®°å½•ä¸€ä¸‹å½“å‰çŠ¶æ€ä¸‹ï¼Œ26ä¸ªå­—æ¯å½“å‰å‰©ä½™ä¸ªæ•° çŠ¶æ€å‹ç¼©ï¼Œä½†æ˜¯è´Ÿä¼˜åŒ–123456789101112131415161718192021222324252627282930313233class Solution {public: int maxScoreWords(vector&lt;string&gt;&amp; words, vector&lt;char&gt;&amp; letters, vector&lt;int&gt;&amp; score) { int wn = words.size(); int ln = letters.size(); vector&lt;int&gt; letterCount = vector&lt;int&gt;(26); for(int i = 0; i &lt; ln; i++) { letterCount[letters[i] - 'a']++; } int res = 0; for(int s = 1; s &lt; (1 &lt;&lt; wn); s++) { vector&lt;int&gt; wordCount = letterCount; int scoreState = 0; for(int i = 0; i &lt; wn; i++) { if(s &amp; (1 &lt;&lt; i)) { int wlen = words[i].length(); for(int j = 0; j &lt; wlen; j++) { if(wordCount[words[i][j] - 'a'] &gt; 0) { wordCount[words[i][j] - 'a']--; scoreState += score[words[i][j] - 'a']; } else { s = ((s &gt;&gt; (wn -i)) + 1) &lt;&lt; (wn - i); goto NextState; } } } } res = max(res, scoreState); NextState:; } return res; }}; sçš„æ¯ä¸€ä½è¡¨ç¤ºå¯¹åº”wordiæ˜¯å¦é€‰æ‹©ï¼Œå¤åˆ¶æœ€åˆçš„çŠ¶æ€ï¼Œç»Ÿè®¡åˆ†æ•°ï¼Œå¦‚æœé‡åˆ°ä¸å¯ä»¥çš„ï¼Œç›´æ¥åˆ°ä¸‹ä¸€ä¸ªçŠ¶æ€ å‰ªæ1234567891011121314151617181920212223242526272829303132333435class Solution {public: int maxScoreWords(vector&lt;string&gt;&amp; words, vector&lt;char&gt;&amp; letters, vector&lt;int&gt;&amp; score) { int wn = words.size(); int ln = letters.size(); vector&lt;int&gt; letterCount = vector&lt;int&gt;(26); for(int i = 0; i &lt; ln; i++) { letterCount[letters[i] - 'a']++; } int res = 0; for(int s = 1; s &lt; (1 &lt;&lt; wn);) { vector&lt;int&gt; wordCount = letterCount; int scoreState = 0; for(int i = 0; i &lt; wn; i++) { if(s &amp; (1 &lt;&lt; (wn - i - 1))) { int wlen = words[i].length(); for(int j = 0; j &lt; wlen; j++) { if(wordCount[words[i][j] - 'a'] &gt; 0) { wordCount[words[i][j] - 'a']--; scoreState += score[words[i][j] - 'a']; } else { s = ((s &gt;&gt; (wn - i - 1)) + 1) &lt;&lt; (wn - i - 1); // s += 1 &lt;&lt; (wn - i - 1); goto NextState; } } } } res = max(res, scoreState); s++; NextState:; } return res; }}; é¢˜è§£ä¸­çš„çŠ¶æ€ $ s $çš„ç¬¬ $ i $ ä½(ä» $ 0 $ å¼€å§‹ï¼Œä»å·¦å¾€å³)å¯¹åº”çš„æ˜¯ $ words $ æ•°ç»„ä¸­ç¬¬ $ n-1-i $ ä¸ªå­—ç¬¦ä¸²ï¼Œæˆ‘è¿™é‡Œæ”¹æˆå¯¹åº”ç¬¬ $ i $ ä¸ªå­—ç¬¦ä¸² å¯¹äºçŠ¶æ€ $ s $ï¼Œå½“å‘ç°ç¬¬ $ k $ ä½çš„å­—ç¬¦ä¸ªæ•°æ¡ä»¶æ»¡è¶³ä¸äº†ä»¥åï¼Œç¬¬ $ k+1 $ ä½è‡³ç¬¬ $ n-1 $ ä½çš„æƒ…å†µéƒ½ä¸éœ€è¦è€ƒè™‘äº†ï¼Œåˆ™çŠ¶æ€ç›´æ¥è·³è½¬åˆ° $ ((s &gt;&gt; (n - k - 1)) + 1) &lt;&lt; (n - k - 1) $ ,ç”±äºå½“å‰çŠ¶æ€ç¬¬ $ k $ ä½åå…¨ä¸º $ 0 $ ï¼Œä¹Ÿå°±æ˜¯å½“å‰çŠ¶æ€så†åŠ ä¸Š $ 1 &lt;&lt; (n - k - 1) $ æˆ–è€…çŠ¶æ€ $ s $ ä» $ -1 $ åˆ° $ -(1 &lt;&lt; wn) $ 12345678910111213141516171819202122232425262728293031323334class Solution {public: int maxScoreWords(vector&lt;string&gt;&amp; words, vector&lt;char&gt;&amp; letters, vector&lt;int&gt;&amp; score) { int wn = words.size(); int ln = letters.size(); vector&lt;int&gt; letterCount = vector&lt;int&gt;(26); for(int i = 0; i &lt; ln; i++) { letterCount[letters[i] - 'a']++; } int res = 0; for(int s = -1; s &gt; -(1 &lt;&lt; wn);) { vector&lt;int&gt; wordCount = letterCount; int scoreState = 0; for(int i = 0; i &lt; wn; i++) { if(s &amp; (1 &lt;&lt; (wn - i - 1))) { int wlen = words[i].length(); for(int j = 0; j &lt; wlen; j++) { if(wordCount[words[i][j] - 'a'] &gt; 0) { wordCount[words[i][j] - 'a']--; scoreState += score[words[i][j] - 'a']; } else { s -= (1 &lt;&lt; (wn - i - 1)); goto NextState; } } } } res = max(res, scoreState); s--; NextState:; } return res; }};","link":"/home/2023/02/20/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9322/"},{"title":"LeetCode-21","text":"1234. æ›¿æ¢å­ä¸²å¾—åˆ°å¹³è¡¡å­—ç¬¦ä¸²12345678910111213141516171819202122232425262728293031class Solution {public: bool isBalance(int* count, int avg) { return count['Q'] &lt;= avg &amp;&amp; count['R'] &lt;= avg &amp;&amp; count['E'] &lt;= avg &amp;&amp; count['W'] &lt;= avg; } int balancedString(string s) { int count[128] = {0}; for (char c : s) { count[c]++; } int len = s.length(); int avg = len / 4; if (isBalance(count, avg)) { return 0; } int res = len; for (int l = 0, r = 0; l &lt; len; l++) { while (r &lt; len &amp;&amp; !isBalance(count, avg)) { count[s[r]]--; r++; } if (!isBalance(count, avg)) { break; } res = min(res, r - l); count[s[l]]++; } return res; }}; 1138. å­—æ¯æ¿ä¸Šçš„è·¯å¾„123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: string alphabetBoardPath(string target) { int x = 0, y = 0; string res = &quot;&quot;; for(char c : target) { int next_x = getX(c), next_y = getY(c); char step_x = 'L', step_y = 'U'; int diff_x = x - next_x, diff_y = y - next_y; if(next_x &gt; x) { step_x = 'R'; diff_x = -diff_x; } if(next_y &gt; y) { step_y = 'D'; diff_y = - diff_y; } if(next_y == 5) { for(int i = 0; i &lt; diff_x; i++) { res += step_x; } for(int i = 0; i &lt; diff_y; i++) { res += step_y; } } else { for(int i = 0; i &lt; diff_y; i++) { res += step_y; } for(int i = 0; i &lt; diff_x; i++) { res += step_x; } } res += &quot;!&quot;; x = next_x; y = next_y; } return res; } int getX(char c) { return (c - 'a') % 5; } int getY(char c) { return (c - 'a') / 5; }}; å¦‚æœé»˜è®¤å…ˆçºµå‘èµ°ï¼Œå†æ¨ªå‘èµ°ï¼Œé‚£ä¹ˆå½“ä»å¤–éƒ¨åˆ°zæ—¶ï¼Œéœ€è¦å…ˆæ¨ªå‘èµ°å†çºµå‘èµ°å¦‚æœé»˜è®¤å…ˆæ¨ªå‘èµ°ï¼Œå†çºµå‘èµ°ï¼Œé‚£ä¹ˆå½“ä»zåˆ°å¤–éƒ¨æ—¶ï¼Œéœ€è¦å…ˆçºµå‘èµ°å†æ¨ªå‘èµ° 2335. è£…æ»¡æ¯å­éœ€è¦çš„æœ€çŸ­æ€»æ—¶é•¿12345678910111213141516171819202122232425262728293031323334353637class Solution {public: int fillCups(vector&lt;int&gt;&amp; amount) { int res = 0; int x,y; int minn = 0; if(amount[0] == 0 || amount[1] == 0 || amount[2] == 0) { if(amount[0] == 0) minn = 0; if(amount[1] == 0) minn = 1; if(amount[2] == 0) minn = 2; } else { if(amount[1] &lt; amount[minn]) { minn = 1; } if(amount[2] &lt; amount[minn]) { minn = 2; } int a,b; if(amount[(minn+1)%3] &gt; amount[(minn + 3 - 1) % 3]) { a = (minn+1)%3; b = (minn + 3 - 1) % 3; } else { b = (minn+1)%3; a = (minn + 3 - 1) % 3; } res += amount[minn]; int diff = min(amount[a] - amount[b], amount[minn]); amount[minn] -= diff; amount[a] -= diff; amount[a] -= amount[minn]/2; amount[b] -= amount[minn] - amount[minn]/2; amount[minn] = 0; } res += max(amount[(minn + 3 - 1) % 3], amount[(minn+1)%3]); return res; }}; å‡è®¾åˆå§‹çŠ¶æ€ï¼Œä¸‰æ¯æ°´çš„éœ€æ±‚é‡éƒ½å¤§äº0ã€‚é€‰æœ€å°‘çš„ä¸€ç§ï¼Œè®©ä»–å’Œå¦å¤–ä¸¤ç§æ°´ä¸€èµ·æ¥ï¼Œå¹¶ä¸”å°½é‡è®©å¦å¤–ä¸¤æ¯æ°´çš„éœ€æ±‚é‡ç›¸è¿‘ï¼Œå¤„ç†å¥½æœ€å°‘çš„ä¸€ç§åï¼Œæœ€å°‘çš„ä¸€ç§å°±å˜æˆäº†0å¯¹äºå‰©ä¸‹çš„ä¸¤ä¸­æ¸©åº¦ï¼Œæ“ä½œæ•°å°±æ˜¯æœ€å¤§çš„é‚£ä¸ªæ¸©åº¦å¦‚æœåˆå§‹æœ‰ä¸€ä¸ªä¸º0ï¼Œåˆ™å°†minnåˆå§‹åŒ–ä¸ºå¯¹åº”ä¸‹æ ‡ç”±äºåªæœ‰3ä¸ªï¼Œå¯ä»¥å–ä½™å‡å°‘é‡å¤ä»£ç  1797. è®¾è®¡ä¸€ä¸ªéªŒè¯ç³»ç»Ÿ1234567891011121314151617181920212223242526class AuthenticationManager {public: unordered_map&lt;string, int&gt; live; int timeToLive; AuthenticationManager(int timeToLive) { this-&gt;timeToLive = timeToLive; } void generate(string tokenId, int currentTime) { live[tokenId] = currentTime + timeToLive; } void renew(string tokenId, int currentTime) { if(!live.count(tokenId) || live[tokenId] &lt;= currentTime) return; live[tokenId] = currentTime + timeToLive; } int countUnexpiredTokens(int currentTime) { int count = 0; for(auto ite = live.begin(); ite != live.end(); ite++) { if(ite-&gt;second &gt; currentTime) count++; } return count; }}; 1250. æ£€æŸ¥ã€Œå¥½æ•°ç»„ã€123456789101112131415161718class Solution {public: bool isGoodArray(vector&lt;int&gt;&amp; nums) { int gcd_ = nums[0]; int n = nums.size(); for(int i = 0; i &lt; n; i++) { gcd_ = gcd(nums[i], gcd_); if(gcd_ == 1) return true; } return false; } int gcd(int a, int b) { if(a &lt; b) return gcd(b, a); if(b == 0) return a; return gcd(b, a%b); }}; æ ¹æ®æç¤º $ Eq. ax+by=1 has solution x, y if gcd(a,b) = 1. $åªè¦æ•´ä¸ªæ•°ç»„çš„æœ€å¤§å…¬çº¦æ•°ä¸º1ï¼Œåˆ™å¯æ»¡è¶³é¢˜æ„ 1233. åˆ é™¤å­æ–‡ä»¶å¤¹12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364struct MTreeNode { unordered_map&lt;string, MTreeNode*&gt; childList;};class Solution {public: vector&lt;string&gt; res; vector&lt;string&gt; removeSubfolders(vector&lt;string&gt;&amp; folder) { MTreeNode * root = new MTreeNode(); for(string&amp; dir : folder) { vector&lt;string&gt; dirs = splitPath(dir); MTreeNode* move = root; int dir_len = dirs.size(); for(int i = 0; i &lt; dir_len; i++) { if(!move-&gt;childList.count(dirs[i])) { move-&gt;childList[dirs[i]] = new MTreeNode(); } move = move-&gt;childList[dirs[i]]; } } for(string&amp; dir : folder) { vector&lt;string&gt; dirs = splitPath(dir); MTreeNode* move = root; int dir_len = dirs.size(); for(int i = 0; i &lt; dir_len; i++) { if(!move-&gt;childList.count(dirs[i])) { break; } move = move-&gt;childList[dirs[i]]; } move-&gt;childList.clear(); } dfs(root, &quot;&quot;); return res; } void dfs(MTreeNode* root, string path) { if(root-&gt;childList.size() == 0) { res.push_back(path); return; } for(auto ite = root-&gt;childList.begin(); ite != root-&gt;childList.end(); ite++) { dfs(ite-&gt;second, path+&quot;/&quot;+ite-&gt;first); } } vector&lt;string&gt; splitPath(string s) { vector&lt;string&gt; path; int i = 0; int n = s.size(); while(i &lt; n) { string dir; while(i &lt; n &amp;&amp; s[i] == '/') i++; if(i &lt; n) { while(i &lt; n &amp;&amp; s[i] != '/') { dir.push_back(s[i]); i++; } path.push_back(dir); } } return path; }}; æ¨¡æ‹Ÿï¼Œæ„é€ é‚£æ£µæ ‘ï¼Œåˆ é™¤ï¼Œç„¶åè¿˜åŸ 12æ‰§è¡Œç”¨æ—¶ï¼š620 ms, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†5.15%çš„ç”¨æˆ·å†…å­˜æ¶ˆè€—ï¼š213.6 MB, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†4.99%çš„ç”¨æˆ· æˆ‘ä¸ç®¡ï¼Œè¿™æ˜¯O(n)ï¼Œå°±æ˜¯æœ€å¿«çš„ 123456789101112131415161718192021class Solution {public: vector&lt;string&gt; res; vector&lt;string&gt; removeSubfolders(vector&lt;string&gt;&amp; folder) { sort(folder.begin(), folder.end()); int cmp = 0; int i = 1, n = folder.size(), cmp_len = folder[cmp].length(); res.push_back(folder[cmp]); for(; i &lt; n; i++) { int j; for(j = 0; j &lt; cmp_len &amp;&amp; folder[cmp][j] == folder[i][j]; j++); if(j == cmp_len &amp;&amp; folder[i][j] == '/') { } else { cmp = i; cmp_len = folder[cmp].length(); res.push_back(folder[cmp]); } } return res; }}; æ’åºï¼Œæ¯”è¾ƒ 1210. ç©¿è¿‡è¿·å®«çš„æœ€å°‘ç§»åŠ¨æ¬¡æ•°123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution {public: int minimumMoves(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n; n = grid.size(); queue&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt; que; if(n &lt;= 0) return 0; vector&lt;vector&lt;vector&lt;bool&gt;&gt;&gt; visited(n, vector&lt;vector&lt;bool&gt;&gt;(n, vector&lt;bool&gt;(2, false))); que.push(make_pair(make_pair(0,0),0)); int step = 0; while(!que.empty()) { queue&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt; que_temp; while(!que.empty()) { auto [pos, ver] = que.front(); auto [x, y] = pos; visited[x][y][ver] = true; que.pop(); if(x == n-1 &amp;&amp; y == n-2 &amp;&amp; !ver) {return step;} if(ver) { if(x+2 &lt; n &amp;&amp; !grid[x+2][y]) { if(!visited[x+1][y][1]) { que_temp.push(make_pair(make_pair(x+1,y),1)); visited[x+1][y][1] = true; } } if(y+1 &lt; n &amp;&amp; x+1 &lt; n &amp;&amp; !grid[x][y+1] &amp;&amp; !grid[x+1][y+1]) { if(!visited[x][y][0]) { que_temp.push(make_pair(make_pair(x,y),0)); visited[x][y][0] = true; } if(!visited[x][y+1][1]) { que_temp.push(make_pair(make_pair(x,y+1),1)); visited[x][y+1][1] = true; } } } else { if(y+2 &lt; n &amp;&amp; !grid[x][y+2]) { if(!visited[x][y+1][0]) { que_temp.push(make_pair(make_pair(x,y+1),0)); visited[x][y+1][0] = true; } } if(y+1 &lt; n &amp;&amp; x+1 &lt; n &amp;&amp; !grid[x+1][y] &amp;&amp; !grid[x+1][y+1]) { if(!visited[x][y][1]) { que_temp.push(make_pair(make_pair(x,y),1)); visited[x][y][1] = true; } if(!visited[x+1][y][0]) { que_temp.push(make_pair(make_pair(x+1,y),0)); visited[x+1][y][0] = true; } } } } step++; que = que_temp; } return -1; }}; ç»å…¸çš„BFS 2341. æ•°ç»„èƒ½å½¢æˆå¤šå°‘æ•°å¯¹123456789101112131415161718192021class Solution {public: vector&lt;int&gt; numberOfPairs(vector&lt;int&gt;&amp; nums) { unordered_map&lt;int, bool&gt; m; int len = nums.size(); for(int n:nums) { if(m.count(n)) { m[n] = !m[n]; } else { m[n] = true; } } int res = 0; for(auto ite = m.begin(); ite != m.end(); ite++) { if(ite-&gt;second) { res++; } } return {(len - res) &gt;&gt; 1, res}; }}; 1139. æœ€å¤§çš„ä»¥ 1 ä¸ºè¾¹ç•Œçš„æ­£æ–¹å½¢1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: int largest1BorderedSquare(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = grid.size(), n = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; up(m, vector&lt;int&gt;(n, 0)), down(m, vector&lt;int&gt;(n, 0)), left(m, vector&lt;int&gt;(n, 0)), right(m, vector&lt;int&gt;(n, 0)); for(int i = 0; i &lt; m; i++) { left[i][0] = grid[i][0]; right[i][n-1] = grid[i][n-1]; for(int j = 1; j &lt; n; j++) { if(grid[i][j]) left[i][j] = left[i][j-1] + 1; else left[i][j] = 0; if(grid[i][n-1-j]) right[i][n-1-j] = right[i][n-j] + 1; else right[i][n-1-j] = 0; } } for(int i = 0; i &lt; n; i++) { up[0][i] = grid[0][i]; down[m-1][i] = grid[m-1][i]; for(int j = 1; j &lt; m; j++) { if(grid[j][i]) up[j][i] = up[j-1][i] + 1; else up[j][i] = 0; if(grid[m-1-j][i]) down[m-1-j][i] = down[m-j][i] + 1; else down[m-1-j][i] = 0; } } int maxx = 0; for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; n; j++) { if(grid[i][j]) { int diff = min(down[i][j], right[i][j]); for(int l = 0; l &lt; diff; l++) { if(l-up[i+l][j+l]+1 &lt;= 0 &amp;&amp; l-left[i+l][j+l]+1 &lt;= 0) { maxx = max(maxx, l+1); } } } } } return maxx*maxx; }}; è®°å½•ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘ä»ä½ç½®(i, j)å¼€å§‹è¿ç»­çš„1çš„ä¸ªæ•°å¯¹äºä¸€ä¸ªä¸º1çš„ç‚¹ï¼Œåœ¨å…¶ä¸‹æ–¹å’Œå³æ–¹æœ‰è¿ç»­1çš„èŒƒå›´å†…çš„æ–œå¯¹è§’ä¸Šçš„å„ç‚¹ï¼Œå¦‚æœæ–œå¯¹è§’çº¿ä¸Šå„ç‚¹çš„ä¸Šæ–¹å’Œå·¦æ–¹èƒ½å’Œ(i,j)çš„ä¸‹æ–¹å’Œå³æ–¹å›´æˆæ­£æ–¹å½¢ï¼Œåˆ™æ›´æ–°æœ€å¤§å€¼ã€‚ 1663. å…·æœ‰ç»™å®šæ•°å€¼çš„æœ€å°å­—ç¬¦ä¸²1234567891011class Solution {public: string getSmallestString(int n, int k) { string res(n, 'a'-1); for(int i = n-1; i &gt;= 0; i--) { res[i] += min(26, k-i); k -= min(26, k-i); } return res; }}; 1234567891011121314class Solution {public: string getSmallestString(int n, int k) { string res(n, 'a'); int i = n-1; k-=n; for( ; k &gt;= 26; i--) { res[i] += 25; k -= 25; } res[i] += k; return res; }}; 1237. æ‰¾å‡ºç»™å®šæ–¹ç¨‹çš„æ­£æ•´æ•°è§£æš´åŠ›æœç´¢1234567891011121314class Solution {public: vector&lt;vector&lt;int&gt;&gt; findSolution(CustomFunction&amp; customfunction, int z) { vector&lt;vector&lt;int&gt;&gt; res; int x, y; for(x = 1; x &lt;= 1000; x++) { for(y = 1000; y &gt; 1 &amp;&amp; customfunction.f(x,y) &gt; z; y--); if(customfunction.f(x,y) == z) { res.push_back({x, y}); } } return res; }}; äºŒåˆ†æŸ¥æ‰¾1234567891011121314151617181920class Solution {public: vector&lt;vector&lt;int&gt;&gt; findSolution(CustomFunction&amp; customfunction, int z) { vector&lt;vector&lt;int&gt;&gt; res; int x, y; for(x = 1; x &lt;= 1000; x++) { int l = 1, r = 1001; while(l &lt;= r) { y = (r - l) / 2 + l; if(customfunction.f(x, y) == z) break; if(customfunction.f(x,y) &gt; z) r = y-1; else l = y+1; } if(customfunction.f(x,y) == z) { res.push_back({x, y}); } } return res; }}; ç”±äºæ˜¯å¢å‡½æ•°ï¼Œåˆ™ç¡®å®šxï¼Œyå¯ä»¥äºŒåˆ† åŒæŒ‡é’ˆ123456789101112131415class Solution {public: vector&lt;vector&lt;int&gt;&gt; findSolution(CustomFunction&amp; customfunction, int z) { vector&lt;vector&lt;int&gt;&gt; res; int x = 1, y = 1000; for(x = 1; x &lt;= 1000; x++) { int l = 1, r = 1001; for(; y &gt; 1 &amp;&amp; customfunction.f(x, y) &gt; z; y--); if(customfunction.f(x,y) == z) { res.push_back({x, y}); } } return res; }}; ç”±äºæ˜¯é€’å¢çš„ï¼Œxå¢å¤§yå¿…ç„¶è¦å‡å°‘ 1792. æœ€å¤§å¹³å‡é€šè¿‡ç‡è¶…æ—¶12345678910111213141516171819202122232425class Solution {public: double maxAverageRatio(vector&lt;vector&lt;int&gt;&gt;&amp; classes, int extraStudents) { double res = 0; int len = classes.size(); for(int i = 0; i &lt; extraStudents; i++) { double max_res = 0; int p = 0; for(int j = 0; j &lt; len; j++) { double diff = (classes[j][0]+1.0) / (classes[j][1] + 1) - 1.0*classes[j][0]/classes[j][1]; if(diff &gt; max_res) { max_res = diff; p = j; } } classes[p][0]++; classes[p][1]++; // cout &lt;&lt; p &lt;&lt; endl; } for(int j = 0; j &lt; len; j++) { res += 1.0*classes[j][0]/classes[j][1]; } return res / len; }}; è™½ç„¶é”™äº†ï¼Œä½†æ˜¯è¿™é‡Œçš„æ€è·¯æ˜¯æ­£ç¡®çš„æ ¹æ®ç³–æ°´ä¸ç­‰å¼ï¼Œ $ (a+c)/(b+c) &gt; b / a $ç›®æ ‡æ‰€æœ‰ç­çº§çš„ç³–æ°´æµ“åº¦ä¹‹å’Œçš„å¹³å‡å€¼æœ€å¤§ï¼Œä¹Ÿå°±æ˜¯æµ“åº¦æ€»å’Œæœ€å¤§æ¯ä»½ç³–åº”è¯¥åŠ åœ¨èƒ½ä½¿å¾— $ diff = (a+c)/(b+c) - b / a $ æœ€å¤§åŒ–çš„ä½ç½®ä¸Š ä¼˜å…ˆé˜Ÿåˆ—1234567891011121314151617181920212223242526272829struct cmp { bool operator()(pair&lt;int, int&gt; &amp;a, pair&lt;int, int&gt;&amp; b) { double diff_a = (a.first + 1.0) / (a.second + 1.0) - 1.0 * a.first / a.second; double diff_b = (b.first + 1.0) / (b.second + 1.0) - 1.0 * b.first / b.second; return diff_a &lt; diff_b; }};class Solution {public: double maxAverageRatio(vector&lt;vector&lt;int&gt;&gt;&amp; classes, int extraStudents) { double res = 0; int len = classes.size(); priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, cmp&gt; queue; for(int j = 0; j &lt; len; j++) { queue.push(make_pair(classes[j][0], classes[j][1])); } for(int i = 0; i &lt; extraStudents; i++) { auto [x, y] = queue.top(); queue.pop(); queue.push(make_pair(x+1, y+1)); } while(!queue.empty()) { auto [x, y] = queue.top(); queue.pop(); res += 1.0*x/y; } return res / len; }}; ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—è¿›è¡Œæ’åº ç”¨lambda1234567891011121314151617181920212223242526class Solution {public: double maxAverageRatio(vector&lt;vector&lt;int&gt;&gt;&amp; classes, int extraStudents) { double res = 0; int len = classes.size(); auto diff = [&amp;](int i) -&gt; double {return (1.0+classes[i][0])/(1+classes[i][1]) - 1.0*classes[i][0]/classes[i][1];}; auto cmp = [&amp;](int i, int j) -&gt; bool {return diff(i) &lt; diff(j);}; priority_queue&lt;int, vector&lt;int&gt;, decltype(cmp)&gt; queue(cmp); for(int j = 0; j &lt; len; j++) { queue.push(j); } for(int i = 0; i &lt; extraStudents; i++) { int j = queue.top(); queue.pop(); classes[j][0]++; classes[j][1]++; queue.push(j); } while(!queue.empty()) { int j = queue.top(); queue.pop(); res += 1.0*classes[j][0]/classes[j][1]; } return res / len; }}; ç”¨lambdaåè€Œæ›´æ…¢äº†ï¼Œä¸è¿‡çŸ¥é“äº†decltypeçš„ä¸€ä¸ªç”¨æ³• 1824. æœ€å°‘ä¾§è·³æ¬¡æ•°è´ªå¿ƒ123456789101112131415161718192021222324252627282930class Solution {public: int minSideJumps(vector&lt;int&gt;&amp; obstacles) { int n = obstacles.size() - 1; vector&lt;vector&lt;int&gt;&gt; obstacles_lane(n+1, vector&lt;int&gt;(3, 0)); for(int i = 0; i &lt; 3; i++) { obstacles_lane[n][i] = n+1; } for(int i = n-1; i &gt;= 0; i--) { obstacles_lane[i][0] = obstacles_lane[i+1][0]; obstacles_lane[i][1] = obstacles_lane[i+1][1]; obstacles_lane[i][2] = obstacles_lane[i+1][2]; if(obstacles[i] != 0) { obstacles_lane[i][obstacles[i]-1] = i; } } int jump = 0; for(int i = obstacles_lane[0][1]-1; i &lt; n; ) { int max_lane = 0; for(int j = 1; j &lt; 3; j++) { if(obstacles_lane[i][j] &gt; obstacles_lane[i][max_lane]) { max_lane = j; } } jump++; i = obstacles_lane[i][max_lane]-1; } return jump; }}; è´ªå¿ƒï¼Œå…ˆç®—å‡ºå³ä¾§æœ€è¿œçš„ä¸€ä¸ªéšœç¢çš„ä½ç½®ï¼Œç›´æ¥è·³åˆ°é‚£ä¸€ä¸ªè·‘é“ä¸Šï¼Œå†å‘å‰ç§»åŠ¨åœ¨åˆå§‹çš„2å·è·‘é“ä¸Šè¦å…ˆå‘å‰ç§»åŠ¨ dp123456789101112131415161718192021222324252627class Solution {public: int minSideJumps(vector&lt;int&gt;&amp; obstacles) { int n = obstacles.size() - 1; vector&lt;int&gt; dp = {1, 0 ,1}; for(int i = 1; i &lt;= n; i++) { int minCount = INT_MAX; //ä¸è·³ for(int j = 0; j &lt; 3; j++) { if(j == obstacles[i]-1) { dp[j] = INT_MAX; } else { minCount = min(minCount, dp[j]); } } //è·³ for(int j = 0; j &lt; 3; j++) { if(j == obstacles[i]-1) { continue; } else { dp[j] = min(dp[j], minCount+1); } } } return min(dp[0], min(dp[1], dp[2])); }}; å¯¹äºå½“å‰ä½ç½®içš„è·‘é“jå¦‚æœè€ƒè™‘ä¸ä»i-1ä½ç½®è·³ï¼Œå½“å‰åˆ°è¾¾å½“å‰è·‘åˆ°æ‰€ç”¨è·³æ•°ä¸å˜ï¼Œå¦‚æœæœ‰éšœç¢åˆ™æ˜¯æ— ç©·å¦‚æœè€ƒè™‘å¦‚æœè·³åˆ°å½“å‰ä½ç½®ï¼Œå‰ææ˜¯å½“å‰ä½ç½®æ²¡æœ‰éšœç¢ï¼Œåˆ™æ˜¯å¦å¤–ä¸¤ä¸ªè·‘åˆ°è·³æ•°+1å’Œè‡ªå·±æœ¬èº«è·³æ•°çš„æœ€å°å€¼ 1817. æŸ¥æ‰¾ç”¨æˆ·æ´»è·ƒåˆ†é’Ÿæ•°1234567891011121314class Solution {public: vector&lt;int&gt; findingUsersActiveMinutes(vector&lt;vector&lt;int&gt;&gt;&amp; logs, int k) { unordered_map&lt;int, set&lt;int&gt;&gt; UAM; vector&lt;int&gt; answer(k, 0); for(auto&amp; op:logs) { UAM[op[0]].insert(op[1]); } for(auto ite = UAM.begin(); ite!=UAM.end(); ite++) { answer[ite-&gt;second.size()-1]++; } return answer; }}; 1813. å¥å­ç›¸ä¼¼æ€§ III12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution {public: bool areSentencesSimilar(string sentence1, string sentence2) { vector&lt;string&gt; splitSentence1 = split(sentence1), splitSentence2 = split(sentence2); int wordCount1 = splitSentence1.size(), wordCount2 = splitSentence2.size(); if(wordCount1 &lt; wordCount2) { vector&lt;string&gt; t = splitSentence1; splitSentence1 = splitSentence2; splitSentence2 = t; } wordCount1 = splitSentence1.size();wordCount2 = splitSentence2.size(); int i = 0, j = 0; while(i &lt; wordCount1 &amp;&amp; splitSentence1[i] != splitSentence2[j]) i++; int count = i-j &gt; 0 ? 1 : 0; while(i &lt; wordCount1 &amp;&amp; j &lt; wordCount2) { while(i &lt; wordCount1 &amp;&amp; j &lt; wordCount2 &amp;&amp; splitSentence1[i] == splitSentence2[j]) { i++;j++; } if(j &lt; wordCount2) { while(i &lt; wordCount1 &amp;&amp; splitSentence1[i] != splitSentence2[j]) { i++; } count++; } else if(i &lt; wordCount1) { count++; } } if(count &lt;= 1 &amp;&amp; j == wordCount2) return true; i = wordCount1-1;j = wordCount2-1; while(i &gt;= wordCount1 &amp;&amp; splitSentence1[i] != splitSentence2[j]) i--; int count1 = j-i &gt; 0 ? 1 : 0; while(i &gt;= 0 &amp;&amp; j &gt;= 0) { while(i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; splitSentence1[i] == splitSentence2[j]) { i--;j--; } if(j &gt;= 0) { while(i &gt;= 0 &amp;&amp; splitSentence1[i] != splitSentence2[j]) { i--; } count1++; } else if(i &gt;= 0) { count1++; } } return (count1 &lt;=1 &amp;&amp; j == -1); } vector&lt;string&gt; split(const string&amp; str) { int i = 0, len = str.size(); vector&lt;string&gt; res; while(i &lt; len) { string subStr = &quot;&quot;; while(i &lt; len &amp;&amp; str[i] != ' ') { subStr += str[i]; i++; } res.push_back(subStr); while(i &lt; len &amp;&amp; str[i] == ' ' ) i++; } return res; }}; å…ˆsplitï¼Œå†åŒæŒ‡é’ˆæ•°è¾ƒçŸ­çš„å­—ç¬¦ä¸²å°†è¾ƒé•¿çš„å­—ç¬¦ä¸²åˆ†æˆäº†å‡ ä»½ï¼Œå¦‚æœå°äº2ï¼Œåˆ™okéœ€è¦æ­£ç€åç€å„å°è¯•ä¸€é é¢˜è§£æ–¹æ³•12345678910111213141516171819202122232425class Solution {public: bool areSentencesSimilar(string sentence1, string sentence2) { vector&lt;string&gt; splitSentence1 = split(sentence1), splitSentence2 = split(sentence2); int wordCount1 = splitSentence1.size(), wordCount2 = splitSentence2.size(); int i = 0, j = 0; while(i &lt; wordCount1 &amp;&amp; i &lt; wordCount2 &amp;&amp; splitSentence1[i] == splitSentence2[i]) i++; while(j &lt; wordCount1-i &amp;&amp; j &lt; wordCount2-i &amp;&amp; splitSentence1[wordCount1-j-1] == splitSentence2[wordCount2-j-1]) j++; return i+j == min(wordCount1, wordCount2); } vector&lt;string&gt; split(const string&amp; str) { int i = 0, len = str.size(); vector&lt;string&gt; res; while(i &lt; len) { string subStr = &quot;&quot;; while(i &lt; len &amp;&amp; str[i] != ' ') { subStr += str[i]; i++; } res.push_back(subStr); while(i &lt; len &amp;&amp; str[i] == ' ' ) i++; } return res; }}; ç”±äºåªèƒ½æ·»åŠ ä¸€æ®µï¼Œå…ˆæ­£å‘æ‰¾ç›¸åŒçš„å•è¯æ•°ï¼Œå†åå‘æ‰¾â€œä¸ä¸æ­£å‘é‡å çš„â€ç›¸åŒçš„å•è¯æ•°ï¼Œå¦‚æœä¸¤è€…å•è¯æ•°ç›¸åŠ åˆšå¥½ç­‰åŒäºè¾ƒçŸ­çš„å­—ç¬¦ä¸²çš„å•è¯æ•°ï¼Œè¯´æ˜å¯ä»¥é€šè¿‡æ’å…¥ä¸€å¥è¯æ¥ä½¿ä¸¤ä¸ªå¥å­ç›¸åŒ","link":"/home/2023/02/13/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9321/"},{"title":"LeetCode-24","text":"1616. åˆ†å‰²ä¸¤ä¸ªå­—ç¬¦ä¸²å¾—åˆ°å›æ–‡ä¸²acä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: bool checkPalindromeFormation(string a, string b) { int len = a.length(); if(len == 1) return true; bool flaga = true, flagb = true; int i = 0; for(; i &lt; len; i++) { if(a[i] == b[len-1-i]) { } else { break; } } for(int j = i; j &lt; len-1-i; j++) { if(b[j] != b[len-1-j]) { flagb = false; break; } } for(int j = i; j &lt; len-1-i; j++) { if(a[j] != a[len-1-j]) { flaga = false; break; } } if(flaga || flagb) return true; flaga = flagb = true; for(i = 0; i &lt; len; i++) { if(a[len-1-i] == b[i]) { } else { break; } } for(int j = i; j &lt; len-1-i; j++) { if(a[j] != a[len-1-j]) { flaga = false; break; } } for(int j = i; j &lt; len-1-i; j++) { if(b[j] != b[len-1-j]) { flagb = false; break; } } return flaga || flagb; }}; abä¸¤ä¸ªå­—ç¬¦ä¸²åœ¨åŒä¸€ä¸ªä½ç½®åˆ†éš”å¼€ï¼Œè‹¥ $ pre_a + suf_b $ æˆ– $ pre_b + suf_a $ æ˜¯å›æ–‡ä¸²ï¼Œåˆ™è¿”å›trueï¼Œå¦åˆ™è¿”å›falseè¿™ä¸ªè§„åˆ™ç›¸å½“äºabæˆªå–ç›¸åŒä¸”ä»»æ„é•¿çš„å‰ç¼€å¹¶äº¤æ¢ï¼Œçœ‹äº¤æ¢åæ˜¯å¦å­˜åœ¨å›æ–‡æˆ‘çš„æ€è·¯æ˜¯å…ˆæ¯”è¾ƒaçš„ç¬¬iä½ä¸bçš„å€’æ•°ç¬¬iä½æ˜¯å¦æƒ³ç­‰ï¼Œæ‰¾åˆ°ç¬¬ä¸€æ¬¡ä¸ç›¸ç­‰çš„ä½ç½®iï¼Œæ­¤æ—¶å¯ä»¥ä»ç¬¬iä½åˆ†å‰²ï¼Œåˆ¤æ–­bçš„å‰©ä½™éƒ¨åˆ†æ˜¯å¦æ˜¯å›æ–‡ï¼Œæˆ–è€…ä»len-i-1å¤„åˆ†å‰²ï¼Œåˆ¤æ–­açš„å‰©ä½™éƒ¨åˆ†æ˜¯å¦æ˜¯å›æ–‡è‹¥éƒ½ä¸æ˜¯ï¼Œå†æ¯”è¾ƒbçš„ç¬¬iä½ä¸açš„å€’æ•°iä½ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸æ»¡è¶³çš„iï¼Œå†æ¯”è¾ƒaï¼Œbçš„å‰©ä½™éƒ¨åˆ† ä¼˜åŒ–è¡Œæ•°12345678910111213141516171819202122class Solution {public: bool checkPalindromeFormation(string a, string b) { int len = a.length(); int paliA = len/2-1, paliB = len/2; while(paliA &gt; 0 &amp;&amp; a[paliA] == a[len-1-paliA]) paliA--; while(paliB &gt; 0 &amp;&amp; b[paliB] == b[len-1-paliB]) paliB--; int i, j; for(i = 0; i &lt; len/2; i++) { if(a[i] != b[len-1-i]) { break; } } for(j = 0; j &lt; len/2; j++) { if(b[j] != a[len-1-j]) { break; } } return min(paliA, paliB) &lt; max(i, j); }}; æœ€å¤§çš„æƒ…å†µä¸‹æ‰§è¡Œ$2*len$æ¬¡ 2389. å’Œæœ‰é™çš„æœ€é•¿å­åºåˆ—è‰ºæœ¯å°±æ˜¯æ´¾å¤§æ˜Ÿ12345678910111213141516171819class Solution {public: vector&lt;int&gt; answerQueries(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; queries) { vector&lt;int&gt; answer; int n = nums.size(), m = queries.size(); sort(nums.begin(), nums.end()); for(int i = 0; i &lt; m; i++) { int sum = 0; int count = 0; for(int j = 0; j &lt; n; j++) { if(sum + nums[j] &lt;= queries[i]) { count ++; sum += nums[j]; } } answer.push_back(count); } return answer; }}; äºŒåˆ†æŸ¥æ‰¾12345678910111213141516class Solution {public: vector&lt;int&gt; answerQueries(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; queries) { vector&lt;int&gt; answer; int n = nums.size(), m = queries.size(); sort(nums.begin(), nums.end()); for(int j = 1; j &lt; n; j++) { nums[j] += nums[j-1]; } for(int i = 0; i &lt; m; i++) { int count = upper_bound(nums.begin(), nums.end(), queries[i]) - nums.begin(); answer.push_back(count); } return answer; }}; æ‰‹å†™upper_bound()123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; answerQueries(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; queries) { vector&lt;int&gt; answer; int n = nums.size(), m = queries.size(); sort(nums.begin(), nums.end()); for(int j = 1; j &lt; n; j++) { nums[j] += nums[j-1]; } for(int i = 0; i &lt; m; i++) { int l = 0, r = n; while(l &lt; r) { int mid = l + (r - l) / 2; if(nums[mid] &gt; queries[i]) { r = mid; } else { l = mid+1; } } answer.push_back(l); } return answer; }}; 1615. æœ€å¤§ç½‘ç»œç§©æš´åŠ›12345678910111213141516171819202122232425262728293031323334353637class Solution {public: int maximalNetworkRank(int n, vector&lt;vector&lt;int&gt;&gt;&amp; roads) { vector&lt;vector&lt;bool&gt;&gt; mat(n, vector&lt;bool&gt;(n, false)); vector&lt;int&gt; count(n); for(auto&amp; r : roads) { mat[r[0]][r[1]] = true; mat[r[1]][r[0]] = true; } int max_a = 0, max_b = 0; int max_i = 0, max_j = 0; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(mat[i][j]) { count[i]++; } } if(count[i] &gt;= max_a) { max_b = max_a; max_a = count[i]; max_j = max_i; max_i = i; } else if(count[i] &gt; max_b){ max_b = count[i]; max_j = i; } } for(int i = 0; i &lt; n; i++) { for(int j = i+1; j &lt; n; j++) { if(((max_a == count[i] &amp;&amp; max_b == count[j])||(max_b == count[i] &amp;&amp; max_a == count[j])) &amp;&amp; !mat[i][j]) { return max_a + max_b; } } } return max_a + max_b - 1; }}; å…ˆç»Ÿè®¡æ¯ä¸ªåŸå¸‚çš„é“è·¯æ•°ï¼Œæ‰¾åˆ°æœ€å¤§çš„ä¸¤ä¸ªï¼Œç„¶åæŸ¥æ‰¾åœ¨æ‰€æœ‰ç­‰äºæœ€å¤§ä¸¤ä¸ªé“è·¯æ•°çš„åŸå¸‚ç»„åˆä¸­ï¼Œæœ‰æ— æ²¡æœ‰è¾¹çš„ç»„åˆï¼Œå¦åˆ™å°±å‡ä¸€ ä¼˜åŒ–åç»­æŸ¥æ‰¾123456789101112131415161718192021222324252627282930313233class Solution {public: int maximalNetworkRank(int n, vector&lt;vector&lt;int&gt;&gt;&amp; roads) { vector&lt;vector&lt;bool&gt;&gt; mat(n, vector&lt;bool&gt;(n, false)); vector&lt;int&gt; count(n), index(n); for(auto&amp; r : roads) { mat[r[0]][r[1]] = true; mat[r[1]][r[0]] = true; } for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(mat[i][j]) { count[i]++; } } index[i] = i; mat[i][i] = true; } sort(index.begin(), index.end(), [&amp;](int a, int b)-&gt;bool{return count[a] &lt; count[b];}); int x = n-1,y = n-2; while(x &gt;= 0 &amp;&amp; count[index[x]] == count[index[n-1]]) { y = x-1; while(y &gt;= 0 &amp;&amp; count[index[y]] == count[index[n-2]]) { if(!mat[index[x]][index[y]]) { return count[index[n-1]] + count[index[n-2]]; } y--; } x--; } return count[index[n-1]] + count[index[n-2]] - 1; }}; 1605. ç»™å®šè¡Œå’Œåˆ—çš„å’Œæ±‚å¯è¡ŒçŸ©é˜µ12345678910111213141516class Solution {public: vector&lt;vector&lt;int&gt;&gt; restoreMatrix(vector&lt;int&gt;&amp; rowSum, vector&lt;int&gt;&amp; colSum) { int m = rowSum.size(),n = colSum.size(); vector&lt;vector&lt;int&gt;&gt; res = vector&lt;vector&lt;int&gt;&gt;(m, vector&lt;int&gt;(n)); for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; n; j++) { int x = min(rowSum[i], colSum[j]); res[i][j] = x; rowSum[i] -= x; colSum[j] -= x; } } return res; }}; æ ¹æ®è¡Œåˆ—å’Œçš„è¦æ±‚ï¼Œå½“å‰æ–¹æ ¼ä¸­å¯ä»¥å¡«å…¥çš„æœ€å¤§å€¼æ˜¯ä¸¤ä¸ªè¦æ±‚çš„æœ€å°å€¼ï¼Œç›´æ¥å¡«å…¥è¯¥å€¼ï¼Œå¹¶æ›´æ–°å¯¹åº”ä½ç½®çš„è¦æ±‚ 2383. èµ¢å¾—æ¯”èµ›éœ€è¦çš„æœ€å°‘è®­ç»ƒæ—¶é•¿12345678910111213class Solution {public: int minNumberOfHours(int initialEnergy, int initialExperience, vector&lt;int&gt;&amp; energy, vector&lt;int&gt;&amp; experience) { int eng = 1, expLeft = 0, len = energy.size(); int exp = 0; for(int i = 0; i &lt; len; i++) { eng += energy[i]; exp = max(exp, experience[i] - expLeft+1); expLeft += experience[i]; } return (eng &gt; initialEnergy ? eng - initialEnergy : 0) + (exp &gt; initialExperience ? exp - initialExperience : 0); }}; èƒ½é‡æ˜¯ä»å·¦åˆ°å³æ¶ˆè€—çš„ï¼Œæ‰€ä»¥åˆå§‹èƒ½é‡å¤§äºèƒ½é‡æ€»å’Œå°±å¯ä»¥ç»éªŒæ˜¯å¯ä»¥ä»å·¦åˆ°å³ç´¯ç§¯çš„ï¼Œæ‰€ä»¥åˆå§‹ç»éªŒå¤§äºå½“å‰å¯¹æ‰‹çš„ç»éªŒå‡å»ç´¯ç§¯çš„ç»éªŒå°±å¯ä»¥äº† 1625. æ‰§è¡Œæ“ä½œåå­—å…¸åºæœ€å°çš„å­—ç¬¦ä¸²è¿‡äºæš´åŠ›1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: map&lt;string, bool&gt; visited; int len, a, b; void add(string&amp; s) { for(int i = 1; i &lt; len; i+=2) { s[i] = (s[i] + a)%10; } } string rotate(string s) { string ret; for(int i = 0; i &lt; len; i++) { ret.push_back(s[(i+b)%len]); } return ret; } void search(string s) { if(visited.count(s) != 0) { return; } visited[s] = true; search(rotate(s)); add(s); search(s); } string findLexSmallestString(string s, int a, int b) { this-&gt;len = s.size(); this-&gt;a = a; this-&gt;b = b; for(int i = 0; i &lt; len; i++) { s[i] -= '0'; } search(s); string ret = visited.begin()-&gt;first; for(int i = 0; i &lt; len; i++) { ret[i] += '0'; } return ret; }}; æš´åŠ›ï¼Œç¡¬æœï¼ŒæŠŠæ‰€æœ‰å¯èƒ½æƒ…å†µéƒ½ç®—å‡ºæ¥ é¢è¯•é¢˜ 17.05. å­—æ¯ä¸æ•°å­—12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;string&gt; findLongestSubarray(vector&lt;string&gt;&amp; array) { int len = array.size(); vector&lt;int&gt; sum(len); sum[0] = isalpha(array[0][0]) ? 1 : -1; for(int i = 1; i &lt; len; i++) { sum[i] = sum[i-1] + (isalpha(array[i][0]) ? 1 : -1); } unordered_map&lt;int, int&gt; m; int left = 0, right = -1; for(int i = 0; i &lt; len; i++) { if(sum[i] == 0) { if(i &gt; right - left) { left = 0; right = i; } } else { if(!m.count(sum[i])) { m[sum[i]] = i + 1; } else { if(i - m[sum[i]] &gt; right - left) { right = i; left = m[sum[i]]; } } } } return {array.begin() + left, array.begin() + right + 1}; }}; ä½¿ç”¨å‰ç¼€å’Œï¼Œsumè¡¨ç¤ºå­—æ¯æ¯”æ•°å­—å¤šå¤šå°‘ï¼Œå¦‚æœæ˜¯0ï¼Œåˆ™è¯´æ˜åŒºé—´[0,i]ä¸Šæ˜¯å­—æ¯æ•°å­—å¹³è¡¡çš„å¯¹äºä¸æ˜¯0çš„æƒ…å†µï¼Œè‹¥[0,a]å­—æ¯æ¯”æ•°å­—å¤šnä¸ªï¼Œ[0,b]å­—æ¯æ¯”æ•°å­—ä¹Ÿå¤šnä¸ªï¼Œåˆ™[a+1,b]ä¸­ï¼Œæ•°å­—å­—æ¯ä¸€æ ·å¤šç”±äºæ±‚æœ€é•¿å­ä¸²ï¼Œåˆ™å­˜æ¯ä¸ªnç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®å³å¯","link":"/home/2023/03/18/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9324/"},{"title":"LeetCode-25","text":"Your browser does not support the audio element. [hard] 1377. T ç§’åé’è›™çš„ä½ç½®é¢˜ç›®åˆ†æé¢˜ç›®å¼ºè°ƒä¸ºä¸€é¢—æ— å‘æ ‘ï¼Œæ¯æ¬¡è®¿é—®æœªè®¿é—®è¿‡çš„èŠ‚ç‚¹ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ¯ç§’è‹¥æœ‰å­èŠ‚ç‚¹ï¼Œåˆ™è·³åˆ°å­èŠ‚ç‚¹ï¼Œå¦åˆ™å‘†åœ¨åŸåœ°ä¸åŠ¨ã€‚ ä¹Ÿå°±æ˜¯æ ¹æ®é¢˜ç›®æ„é€ ä¸€æ£µæ ¹èŠ‚ç‚¹ä¸º1çš„æ ‘ï¼Œå¹¶æŒ‰ç…§å±‚æ¬¡éå†è¯¥æ ‘å³å¯ã€‚ä½†æ˜¯é¢˜ç›®è¾“å…¥çš„è¾¹å¹¶ä¸ä¸€å®šä»¥1ä¸ºæ ¹èŠ‚ç‚¹ã€‚ ä»£ç  å®é™…æ„é€ ä¸ºå›¾ 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution {public: vector&lt;bool&gt; visited; int n; double frogPosition(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int t, int target) { vector&lt;vector&lt;int&gt;&gt; tree(n+1, vector&lt;int&gt;(n+1, 0)); visited = vector&lt;bool&gt;(n+1, false); this-&gt;n = n; for(auto&amp; e : edges) { if(!tree[e[0]][e[1]]) { tree[e[0]][0]++; } if(!tree[e[1]][e[0]]) { tree[e[1]][0]++; } tree[e[0]][e[1]] = 1; tree[e[1]][e[0]] = 1; } return level(tree, t, 1, target, 1); } double level(vector&lt;vector&lt;int&gt;&gt;&amp; tree, int t, int root, int target, double prob) { int len = tree[root][0]; for(int i = 1; i &lt;= n; i++) { if(visited[i] &amp;&amp; tree[root][i]) len--; } // printf(&quot;root = %d, len = %d\\n&quot;, root, len); if(root == target) { if((t &gt; 0 &amp;&amp; len == 0) || t == 0) { return prob; } else if (t &lt; 0){ return 0.0; } } visited[root] = true; for(int e = 1; e &lt;= n; e++) { if(!tree[root][e] || visited[e])continue; double ret; if((ret = level(tree, t-1, e, target, prob * 1.0 / len)) != 0) { return ret; } } return 0; }}; æ—¶é—´ 28ms å‡»è´¥25.75%ç©ºé—´ 20MB å‡»è´¥ 5.30% ä¼˜åŒ–visitedæ•°ç»„è€ƒè™‘åˆ°è¾“å…¥æ˜¯ä¸¥æ ¼çš„æ ‘ï¼Œåœ¨å±‚æ¬¡éå†æ—¶ï¼Œä¸å¸Œæœ›è®¿é—®å·²ç»è®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼Œè¿™ç§èŠ‚ç‚¹åªæœ‰åŒäº²èŠ‚ç‚¹ä¸€ç§å¯èƒ½ã€‚ æ‰€ä»¥å¯¹äºéæ ¹èŠ‚ç‚¹ï¼Œå­èŠ‚ç‚¹æ•°ï¼Œå°±æ˜¯ $ N_{ä¸ä¹‹ç›¸é‚»çš„è¾¹}-1 $ï¼Œå±‚æ¬¡éå†æ—¶åªè¦çŸ¥é“å…¶çˆ¶èŠ‚ç‚¹ï¼Œä¸å»è®¿é—®çˆ¶èŠ‚ç‚¹å³å¯ å¯¹äºæ ¹èŠ‚ç‚¹ï¼Œæ·»åŠ ä¸€æ¡è¾¹$ &lt;0, 1&gt; $å³å¯ 1234567891011121314151617181920212223242526272829303132333435class Solution {public: int n; double frogPosition(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int t, int target) { vector&lt;vector&lt;int&gt;&gt; tree(n+1, vector&lt;int&gt;(1, 0)); this-&gt;n = n; edges.push_back({0, 1}); for(auto&amp; e : edges) { tree[e[0]][0]++; tree[e[1]][0]++; tree[e[0]].push_back(e[1]); tree[e[1]].push_back(e[0]); } return level(tree, t, 1, target, 1, 0); } double level(vector&lt;vector&lt;int&gt;&gt;&amp; tree, int t, int root, int target, double prob, int parent) { int len = tree[root][0] - 1; if(root == target) { if((t &gt; 0 &amp;&amp; len == 0) || t == 0) { return prob; } else if (t &lt; 0){ return 0.0; } } for(int i = 1; i &lt;= len+1; i++) { int e = tree[root][i]; if(e == parent)continue; double ret; if((ret = level(tree, t-1, e, target, prob * 1.0 / len, root)) != 0) { return ret; } } return 0; }}; æ—¶é—´ 12 ms å‡»è´¥ 97.73%å†…å­˜ 15.1 MB å‡»è´¥ 31.82% [Medium] 1090. å—æ ‡ç­¾å½±å“çš„æœ€å¤§å€¼åˆ†æé‡é‡éƒ½ä¸º1çš„èƒŒåŒ…é—®é¢˜ï¼Œå¦‚æœæŠŠlabelsçœ‹ä½œç‰©å“çš„åˆ†ç±»ï¼Œå¯¹æ¯ç±»ç‰©å“çš„é™åˆ¶éƒ½ç›¸åŒï¼Œéƒ½è‡³å¤šæœ‰useLimitä¸ªï¼Œæ¯ç±»ç‰©å“ä¸­å…¶valueä¹Ÿä¸å°½ç›¸åŒ ä¼˜å…ˆé˜Ÿåˆ—å¯¹äºæ¯ä¸ªlabelï¼Œç»´æŠ¤ä¸€ä¸ªvalueç”±å¤§åˆ°å°çš„ä¼˜å…ˆé˜Ÿåˆ—ï¼Œæ¯æ¬¡ä»æ‰€æœ‰é˜Ÿåˆ—ä¸­å–æœ€å¤§çš„ä¸€ä¸ªæ•°ï¼Œè‹¥é˜Ÿåˆ—ç©ºæˆ–æ­¤ç±»labelå·²ç»è¶…è¿‡useLimité™åˆ¶ï¼Œåˆ™ä¸å†è€ƒè™‘è¯¥label æ’åºä¼˜åŒ–ï¼Œæ ¹æ®labelæ’åºï¼Œç›¸åŒla ä»£ç 12345678910111213141516171819202122232425262728293031323334353637class Solution {public: int largestValsFromLabels(vector&lt;int&gt;&amp; values, vector&lt;int&gt;&amp; labels, int numWanted, int useLimit) { int n = values.size(); vector&lt;int&gt; index = vector&lt;int&gt;(n); map&lt;int, int&gt; limit; iota(index.begin(), index.end(), 0); sort(index.begin(), index.end(), [&amp;](int a, int b){ if(labels[a] != labels[b]) { return labels[a] &gt; labels[b]; } else { return values[a] &gt; values[b]; } }); auto cmp = [&amp;](int a, int b){return values[index[a]] &lt; values[index[b]];}; priority_queue&lt;int, vector&lt;int&gt;, decltype(cmp)&gt; q(cmp); q.push(0); limit[labels[index[0]]] = useLimit; for(int i = 1; i &lt; n; i++) { if(labels[index[i]] != labels[index[i-1]]) { q.push(i); } limit[labels[index[i]]] = useLimit; } int sum = 0; for(int K = 0; K &lt; numWanted &amp;&amp; !q.empty(); K++) { int i = q.top(); q.pop(); sum += values[index[i]]; limit[labels[index[i]]]--; if(i + 1 &lt; n &amp;&amp; labels[index[i+1]] == labels[index[i]] &amp;&amp; limit[labels[index[i]]]) { q.push(i + 1); } } return sum; }}; æ—¶é—´ 52 ms å‡»è´¥ 7.94%å†…å­˜ 19.3 MB å‡»è´¥ 61.22% ä¼˜åŒ–æƒ³å¤æ‚äº†ï¼Œåªè¦æŒ‰ç…§å€¼æ’åºåï¼Œä»å¤§åˆ°å°æŒ‰ç…§é™åˆ¶é€‰æ‹©å³å¯ï¼Œå¹¶è®°å½•æ¯ä¸ªæ ‡ç­¾æ‰€é€‰æ¬¡æ•°å°±å¥½äº† 123456789101112131415161718192021class Solution {public: int largestValsFromLabels(vector&lt;int&gt;&amp; values, vector&lt;int&gt;&amp; labels, int numWanted, int useLimit) { int n = values.size(); vector&lt;int&gt; index = vector&lt;int&gt;(n); map&lt;int, int&gt; limit; iota(index.begin(), index.end(), 0); sort(index.begin(), index.end(), [&amp;](int a, int b){ return values[a] &gt; values[b]; }); int sum = 0; for(int K = 0, i = 0; K &lt; numWanted &amp;&amp; i &lt; n; i++) { if(limit[labels[index[i]]] &lt; useLimit) { sum += values[index[i]]; limit[labels[index[i]]]++; K++; } } return sum; }}; [Medium] 1080. æ ¹åˆ°å¶è·¯å¾„ä¸Šçš„ä¸è¶³èŠ‚ç‚¹åˆ†ææŒ‰ç…§é¢˜æ„ï¼Œé¦–å…ˆå¯¹äºŒå‰æ ‘éå† å½“åˆ°è¾¾å¶èŠ‚ç‚¹æ—¶ï¼Œè®¡ç®—æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹çš„æ€»å’Œ å¦‚æœå¤§äºç­‰äºlimitï¼Œåˆ™è¯¥èŠ‚ç‚¹åŠå…¶æ‰€æœ‰ç¥–å…ˆèŠ‚ç‚¹éƒ½ä¸éœ€è¦åˆ é™¤ï¼Œæ­¤æ—¶è¿”å›true å¦åˆ™è¿”å›falseã€‚ å¯¹äºéå¶å­èŠ‚ç‚¹ å¦‚æœå·¦å³å­æ ‘è¿”å›äº†trueï¼Œè¯¥èŠ‚ç‚¹ä¸éœ€è¦è¢«åˆ é™¤ï¼Œå‘å…¶çˆ¶èŠ‚ç‚¹è¿”å›true åˆ™è¿”å›trueçš„å­æ ‘ä¸éœ€è¦è¢«åˆ é™¤ è¿”å›falseçš„å­èŠ‚ç‚¹ç½®ä¸ºnullptrï¼Œéœ€è¦è¢«åˆ é™¤ å¦‚æœéƒ½è¿”å›äº†falseï¼Œåˆ™è¯¥èŠ‚ç‚¹éœ€è¦è¢«åˆ é™¤ã€‚å‘å…¶çˆ¶èŠ‚ç‚¹è¿”å›false ä»£ç 123456789101112131415161718192021222324252627282930class Solution {public: int limit; TreeNode* sufficientSubset(TreeNode* root, int limit) { this-&gt;limit = limit; if(root &amp;&amp; cal(root, 0)) { return root; } return nullptr; } bool cal(TreeNode *root, int n) { bool ret = false; if(!root-&gt;left &amp;&amp; !root-&gt;right) { n += root-&gt;val; ret = n &gt;= limit; } else { if(root-&gt;left &amp;&amp; cal(root-&gt;left, root-&gt;val + n)) { ret = true; } else { root-&gt;left = nullptr; } if(root-&gt;right &amp;&amp; cal(root-&gt;right, root-&gt;val + n)) { ret = true; } else { root-&gt;right = nullptr; } } return ret; }}; æ—¶é—´ 40 ms å‡»è´¥ 66.87%å†…å­˜ 32.2 MB å‡»è´¥ 48.64% [Easy] 2451. å·®å€¼æ•°ç»„ä¸åŒçš„å­—ç¬¦ä¸²åˆ†æä¾æ¬¡å¯¹æ‰€æœ‰å­—ç¬¦ä¸²è®¡ç®—ç›¸é‚»ä¸¤ä¸ªå­—ç¬¦ä¹‹é—´çš„å·®å€¼ï¼Œæ‰¾åˆ°å·®å€¼ä¸åŒçš„é‚£ä¸€ä¸ª è®¡ç®—ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²çš„å·®å€¼ï¼Œå¯»æ‰¾ç¬¬ä¸€ä¸ªä¸å…¶ä¸åŒçš„å­—ç¬¦ä¸² è‹¥ç¬¬ä¸€ä¸ªä¸å…¶ä¸ä¸€æ ·çš„å­—ç¬¦ä¸²ä¸‹æ ‡å¤§äº1ï¼Œåˆ™[0, j-1]æ˜¯ç›¸åŒçš„ï¼Œjä¸ºä¸å…¶ä»–ä¸åŒçš„å­—ç¬¦ä¸² è‹¥ç­‰äº1 wordsæ€»é•¿åº¦ä¸º2ï¼Œåˆ™0ï¼Œ1ä¸¤ä¸²ä¸åŒï¼Œè¿”å›ä»»æ„ä¸€ä¸ªå³å¯ æ€»é•¿åº¦å¤§äº2ï¼ŒæŸ¥çœ‹å­—ç¬¦ä¸²2çš„å·®å€¼ï¼Œè‹¥ä¸1ç›¸åŒåˆ™è¿”å›0ï¼Œå¦åˆ™è¿”å›1 ä»£ç 123456789101112131415161718192021222324252627class Solution {public: string oddString(vector&lt;string&gt;&amp; words) { int len = words[0].size(); int n = words.size(); for(int i = 1; i &lt; len; i++) { int diff = words[0][i] - words[0][i-1]; int j = 1; while(j &lt; n &amp;&amp; words[j][i] - words[j][i-1] == diff) { j++; } if(j == n) { continue; } if(j &gt; 1 || n == 2) { return words[j]; } else { if(words[2][i] - words[2][i-1] == diff) { return words[1]; } else { return words[0]; } } } return words[0]; }}; [Easy] LCP 33. è“„æ°´åˆ†æå®é™…éš¾åº¦åº”è¯¥æ˜¯hardå§ï¼Œå¥½éš¾ ç›´æ¥æŠ„ç­”æ¡ˆ ä»£ç 1234567891011121314151617181920class Solution {public: int storeWater(vector&lt;int&gt;&amp; bucket, vector&lt;int&gt;&amp; vat) { int n = bucket.size(); int maxx = 0; for(int i = 0; i &lt; n; i++) { maxx = max(maxx, vat[i]); } if(maxx == 0) return 0; int res = INT_MAX; for(int k = 1; k &lt;= maxx &amp;&amp; k &lt; res; k++) { int t = 0; for(int i = 0; i &lt; n; i++) { t += max(0, (vat[i] + k - 1) / k - bucket[i]); } res = min(res, t+k); } return res; }}; [Hard] 1373. äºŒå‰æœç´¢å­æ ‘çš„æœ€å¤§é”®å€¼å’Œåˆ†æå¯¹äºæ¯ä¸ªèŠ‚ç‚¹ $ node $ï¼Œ é¦–å…ˆè¦åˆ¤æ–­å…¶æ˜¯å¦ä¸ºbstï¼Œå¦‚æœæ˜¯bstè®¡ç®—ä»¥nodeä¸ºæ ¹çš„å­æ ‘ä¹‹å’Œ ç”¨bstå‡½æ•°çš„è¿”å›å€¼è¿”å›æ˜¯å¦ä¸ºbstï¼Œä¸‰ä¸ªå‚æ•°åˆ†åˆ«è¿”å›å­æ ‘ä¹‹å’Œï¼Œå­æ ‘çš„æœ€å¤§å€¼ï¼Œå­æ ‘çš„æœ€å°å€¼ å­æ ‘çš„æœ€å¤§å€¼å³ï¼Œå·¦å­æ ‘çš„å­æ ‘æœ€å¤§å€¼ï¼Œå³å­æ ‘å­æ ‘æœ€å¤§å€¼ï¼Œæ ¹èŠ‚ç‚¹çš„å€¼ä¸‰è€…æœ€å¤§å€¼ å­æ ‘æœ€å°å€¼å³ï¼Œå·¦å­æ ‘çš„å­æ ‘æœ€å°å€¼ï¼Œå³å­æ ‘å­æ ‘æœ€å°å€¼ï¼Œæ ¹èŠ‚ç‚¹çš„å€¼ä¸‰è€…æœ€å°å€¼ é¢˜ç›®ä¸­çš„ä¸åˆç†ï¼š 123è¾“å…¥ï¼šroot = [-4,-2,-5]è¾“å‡ºï¼š0è§£é‡Šï¼šæ‰€æœ‰èŠ‚ç‚¹é”®å€¼éƒ½ä¸ºè´Ÿæ•°ï¼Œå’Œæœ€å¤§çš„äºŒå‰æœç´¢æ ‘ä¸ºç©ºã€‚ è¿™ä¸ªè¾“å…¥çš„è¾“å‡ºåº”è¯¥æ˜¯-2ï¼Œè€Œé0ã€‚å®šä¹‰ä¸­åªè¦æ±‚å·¦å­æ ‘å°äºæ ¹ï¼Œå³å­æ ‘å¤§äºæ ¹ï¼Œå¹¶æœªè¦æ±‚æ­£è´Ÿã€‚ 123è¾“å…¥ï¼šroot = [4,3,null,1,2]è¾“å‡ºï¼š2è§£é‡Šï¼šé”®å€¼ä¸º 2 çš„å•èŠ‚ç‚¹å­æ ‘æ˜¯å’Œæœ€å¤§çš„äºŒå‰æœç´¢æ ‘ã€‚ æ ¹æ®è¿™ä¸ªè¾“å…¥çŸ¥é“ï¼Œå•èŠ‚ç‚¹ä¹Ÿç®—æ˜¯äºŒå‰æœç´¢æ ‘ï¼Œé‚£2ç®—æœ€å¤§å­æ ‘ï¼Œ-2ä¹Ÿåº”è¯¥ç®—æœ€å¤§å­æ ‘ ä»£ç 12345678910111213141516171819202122232425262728293031class Solution {public: int maxx = INT_MIN; int maxSumBST(TreeNode* root) { int sum = 0, lmax, rmin; bool ok = bst(root, sum, lmax, rmin); if(ok) { maxx = max(maxx, sum); } return max(0, maxx); } bool bst(TreeNode *root, int&amp; sum, int&amp; leftMax, int&amp; rightMin) { if(root == nullptr) return true; int lsum = 0, rsum = 0; int llMax = INT_MIN, lrMin = INT_MAX; int rlMax = INT_MIN, rrMin = INT_MAX; bool lok = bst(root-&gt;left, lsum, llMax, lrMin); bool rok = bst(root-&gt;right, rsum, rlMax, rrMin); leftMax = max(root-&gt;val, max(llMax, rlMax)); rightMin = min(root-&gt;val, min(lrMin, rrMin)); if(lok &amp;&amp; rok) { bool ok = (!root-&gt;left || llMax &lt; root-&gt;val) &amp;&amp; (!root-&gt;right || rrMin &gt; root-&gt;val); if(ok) { sum += root-&gt;val + lsum + rsum; maxx = max(maxx, sum); } return ok; } return false; }}; [Medium] 1079. æ´»å­—å°åˆ·åˆ†æçŠ¶æ€å‹ç¼©+bfsæ€»é•¿åº¦æœ€å¤§åªæœ‰7ï¼Œæœ€å¤š7ä¸ªä¸åŒå­—ç¬¦ï¼Œç›´æ¥æš´åŠ›æšä¸¾æ‰€æœ‰æƒ…å†µ éœ€è¦è®°å½•å½“å‰æœ‰å“ªäº›ä½ä½¿ç”¨äº†ï¼Œå“ªäº›æ²¡æœ‰ä½¿ç”¨ï¼Œç”¨intçš„æœ€å7ä½è¡¨ç¤º ä¸éœ€è¦çœŸçš„ç”Ÿæˆå­—ç¬¦ä¸²ï¼Œåªè¦å¯¹æ¯ä¸ªå­—ç¬¦ç¼–ç ï¼Œè®¡ç®—ä¸€ä¸ª8è¿›åˆ¶æ•°å°±å¥½äº† code12345678910111213141516171819202122232425262728293031323334class Solution {public: set&lt;int&gt; strset; vector&lt;int&gt; tiles_int; int n; int numTilePossibilities(string tiles) { this-&gt;n = tiles.length(); tiles_int = vector&lt;int&gt;(n, 0); int tile_count = 1; tiles_int[0] = 1; sort(tiles.begin(), tiles.end()); for(int i = 1; i &lt; n; i++) { if(tiles[i] == tiles[i-1]) { tiles_int[i] = tile_count; } else { tiles_int[i] = ++tile_count; } } dfs(0, 0); return strset.size(); } void dfs(int state, int s) { int mask = 1; for(int i = 0; i &lt; n; i++) { if(!(mask &amp; state)) { int next_str = (s &lt;&lt; 3) + tiles_int[i]; strset.insert(next_str); dfs(state | mask, next_str); } mask &lt;&lt;= 1; } }}; æ—¶é—´ 40 ms å‡»è´¥ 27.67%å†…å­˜ 12.1 MB å‡»è´¥ 32.56% ä¼˜åŒ–æ—¢ç„¶æ’åºäº†ï¼Œé‚£ç›¸åŒå­—ç¬¦å°±ä¸ç”¨é‡å¤è€ƒè™‘äº† 1234567891011121314151617181920212223242526272829303132333435class Solution {public: set&lt;int&gt; strset; vector&lt;int&gt; tiles_int; int n; int numTilePossibilities(string tiles) { int len = tiles.length(); int tile_count = 1; n = 1; sort(tiles.begin(), tiles.end()); for(int i = 1; i &lt; len; i++) { if(tiles[i] != tiles[i-1]) { tiles_int.push_back(tile_count); tile_count = 1; n++; } else { ++tile_count; } } tiles_int.push_back(tile_count); dfs(0); return strset.size(); } void dfs(int s) { for(int i = 0; i &lt; n; i++) { if(tiles_int[i]) { int next_str = (s &lt;&lt; 3) + i + 1; strset.insert(next_str); tiles_int[i]--; dfs(next_str); tiles_int[i]++; } } }}; ç»§ç»­ä¼˜åŒ–å‚è€ƒé¢˜è§£ï¼ŒåŒæ—¶ç»“åˆä¸Šé¢çš„åˆ†æï¼Œæ—¢ç„¶æ’åºåä¸å­˜åœ¨é‡å¤äº†ï¼Œé‚£å¯ä»¥ç›´æ¥è®¡æ•°ï¼Œä¸éœ€è¦setäº† 12345678910111213141516171819202122232425262728293031323334class Solution {public: vector&lt;int&gt; tiles_int; int n; int numTilePossibilities(string tiles) { int len = tiles.length(); int tile_count = 1; n = 1; sort(tiles.begin(), tiles.end()); for(int i = 1; i &lt; len; i++) { if(tiles[i] != tiles[i-1]) { tiles_int.push_back(tile_count); tile_count = 1; n++; } else { ++tile_count; } } tiles_int.push_back(tile_count); return dfs(0); } int dfs(int s) { int ret = 0; for(int i = 0; i &lt; n; i++) { if(tiles_int[i]) { int next_str = (s &lt;&lt; 3) + i + 1; tiles_int[i]--; ret += dfs(next_str) + 1; tiles_int[i]++; } } return ret; }}; [Medium] 1091. äºŒè¿›åˆ¶çŸ©é˜µä¸­çš„æœ€çŸ­è·¯å¾„åˆ†æä¸€çœ¼BFSï¼Œä½†æ˜¯ä¸€ç›´è¶…æ—¶ è¶…æ—¶12345678910111213141516171819202122232425262728293031323334class Solution {public: int shortestPathBinaryMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); queue&lt;pair&lt;int, int&gt;&gt; q; if(!grid[0][0] &amp;&amp; !grid[n-1][n-1]) q.push(make_pair(0, 1)); vector&lt;bool&gt; visited = vector&lt;bool&gt;(n * n, false); while(!q.empty()) { auto [pos, len] = q.front(); q.pop(); if(len &gt; n*n) continue; visited[pos] = true; int x = pos / n, y = pos % n; if(x == n-1 &amp; y == n-1) { return len; } for(int dx = -1; dx &lt;= 1; dx++) { for(int dy = -1; dy &lt;= 1; dy++) { pos = pos2int(x + dx, y + dy, n); if(!checkpos(x+dx, y+dy, n) || grid[x+dx][y+dy] || visited[pos]) continue; q.push({pos, len+1}); } } } return -1; } inline bool checkpos(int x, int y, int n) { return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &lt; n; } inline int pos2int(int x, int y, int n) { return x*n + y; }}; åœ¨å…¥é˜Ÿæ—¶å°±åº”è¯¥å§visitedç½®ä¸ºtrue ä»£ç 1234567891011121314151617181920212223242526272829303132333435class Solution {public: int shortestPathBinaryMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); vector&lt;bool&gt; visited = vector&lt;bool&gt;(n * n, false); queue&lt;pair&lt;int, int&gt;&gt; q; if(!grid[0][0] &amp;&amp; !grid[n-1][n-1]){ q.push(make_pair(0, 1)); visited[0] = true; } while(!q.empty()) { auto [pos, len] = q.front(); q.pop(); int x = pos / n, y = pos % n; if(x == n-1 &amp; y == n-1) { return len; } for(int dx = -1; dx &lt;= 1; dx++) { for(int dy = -1; dy &lt;= 1; dy++) { pos = pos2int(x + dx, y + dy, n); if(!checkpos(x+dx, y+dy, n) || grid[x+dx][y+dy] || visited[pos]) continue; q.push({pos, len+1}); visited[pos] = true; } } } return -1; } inline bool checkpos(int x, int y, int n) { return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &lt; n; } inline int pos2int(int x, int y, int n) { return x*n + y; }}; æ—¶é—´ 44 ms å‡»è´¥ 91.20%å†…å­˜ 18.8 MB å‡»è´¥ 68.63% [Medium] 1073. è´ŸäºŒè¿›åˆ¶æ•°ç›¸åŠ åˆ†ææ‰¾è§„å¾‹é¦–å…ˆåˆ†æå…¶ç›¸åŠ çš„è§„å¾‹ 123456789101112131415161718// 1 + 1 = 110// 00 + 00 = 00,00// 10 + 10 = 11,00// 11 + 11 = 00,10// 10 + 00 = 00,10// 00 + 10 = 00,10// 11 + 00 = 00,11// 11 + 10 = 11,01// 10 + 11 = 11,01// 01 + 11 = 00,00// 100 + 100 = 11000// 101 + 101 = 11000 + 110 = 11110// 110 + 110 = 100// 111 + 111 = 11010// 1111 + 1111 = 1010 å‘ç°ï¼Œ1ä½ï¼Œ3ä½çš„ç»“æœç›¸å½“äºå‰é¢è¡¥0åå¶æ•°ä½çš„ç»“æœ æ€»ç»“è½¬æ¢çŸ©é˜µä»¥ç›¸é‚»ä¸¤ä½ä¸ºå•ä½ï¼Œæœ‰å¦‚ä¸‹è½¬æ¢å…³ç³» 123456vector&lt;vector&lt;int&gt;&gt; transform = { {0b0000, 0b0001, 0b0010, 0b0011}, // 00 + xx {0b0001, 0b0110, 0b0011, 0b0000}, // 01 + xx {0b0010, 0b0011, 0b1100, 0b1101}, // 10 + xx {0b0011, 0b0000, 0b1101, 0b0010} // 11 + xx}; å°†å¤šå‡ºæ¥çš„é«˜ä¸¤ä½è§†ä¸ºè¿›ä½ï¼Œä½ä¸¤ä½è§†ä¸ºç›¸åŠ ç»“æœ è¿›ä½è€ƒè™‘åˆ°è¿›ä½ï¼Œä»¥åŠè¿›ä½çš„è¿›ä½ï¼Œéœ€è¦æ¯”æœ€é•¿æ•°å­—å¤šå››ä½ $$\\begin{equation*}\\begin{aligned}&amp;&amp;&amp;&amp;&amp;&amp;x_1&amp;x_0&amp;\\+&amp;&amp;&amp;&amp;&amp;&amp;y_1&amp;y_0&amp;\\=&amp;&amp;&amp;&amp;t_{13}&amp;t_{12}&amp;t_{11}&amp;t_{10}&amp;\\+&amp;&amp;&amp;&amp;&amp;&amp;c_{1}&amp;c_{0}&amp;\\=&amp;&amp;&amp;&amp;t_{23}&amp;t_{22}&amp;t_{21}&amp;t_{20}&amp;\\+&amp;&amp;&amp;&amp;t_{13}&amp;t_{12}&amp;&amp;&amp;&amp;\\=&amp;&amp;t_{33}&amp;t_{32}&amp;t_{31}&amp;t_{30}&amp;t_{21}&amp;t_{20}&amp;\\\\end{aligned}\\end{equation*}$$ cä»£è¡¨è¿›ä½ï¼Œtä»£è¡¨ç›¸åŠ åçš„ç»“æœ ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution {public: vector&lt;vector&lt;int&gt;&gt; transform = { {0b0000, 0b0001, 0b0010, 0b0011}, // 00 + xx {0b0001, 0b0110, 0b0011, 0b0000}, // 01 + xx {0b0010, 0b0011, 0b1100, 0b1101}, // 10 + xx {0b0011, 0b0000, 0b1101, 0b0010} // 11 + xx }; vector&lt;int&gt; addNegabinary(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2) { int len1 = arr1.size() - 1, len2 = arr2.size() - 1; if(len1 % 2 == 0) { arr1.insert(arr1.begin(), 0); len1++; } if(len2% 2 == 0) { arr2.insert(arr2.begin(), 0); len2++; } // è¡¥æˆå¶æ•° vector&lt;int&gt; summ = vector&lt;int&gt;(max(len1, len2) + 5, 0); //å¤šåˆ†é…å››ä½ int len_res = max(len1, len2) + 5 - 1; for(int i = 0; len1 &gt; 0 || len2 &gt; 0; len1-=2, len2-=2, i+=2) { int x = len1 &gt; 0 ? (arr1[len1-1]&lt;&lt;1) + (arr1[len1]) : 0; int y = len2 &gt; 0 ? (arr2[len2-1]&lt;&lt;1) + (arr2[len2]) : 0; int carry = (summ[i+1]&lt;&lt;1) + (summ[i]); int trans1 = transform[x][y]; // x + y int trans2 = transform[trans1&amp;0b0011][carry]; // ä½äºŒä½(x + y) + carry int trans3 = transform[(trans1&amp;0b1100) &gt;&gt; 2][(trans2&amp;0b1100) &gt;&gt; 2]; // é«˜äºŒä½ summ[i] = trans2&amp;0b0001; summ[i+1] = (trans2&amp;0b0010) &gt;&gt; 1; summ[i+2] = (trans3&amp;0b0001); summ[i+3] = (trans3&amp;0b0010) &gt;&gt; 1; summ[i+4] = (trans3&amp;0b0100) &gt;&gt; 2; summ[i+5] = (trans3&amp;0b1000) &gt;&gt; 3; } //è®¡ç®— while(!summ.empty() &amp;&amp; summ.back() == 0) summ.pop_back(); if(summ.size() == 0) summ = {0}; // åˆ é™¤å‰å¯¼0 reverse(summ.begin(), summ.end()); return summ; }}; æ—¶é—´ 4 ms å‡»è´¥ 90.75%å†…å­˜ 19.3 MBn å‡»è´¥ 5.2% [Medium] 1093. å¤§æ ·æœ¬ç»Ÿè®¡åˆ†æçœ‹èµ·æ¥å¾ˆç®€å•çš„é¢˜ç›®ï¼Œè¿˜æ˜¯é”™äº†ä¸¤æ¬¡ è®¡ç®—æ€»æ•°å¶æ•°ä¸ªä¸­ä½æ•°ï¼Œä¸”ä¸­ä½æ•°ä¸¤ä¸ªæ•°ä¸ç›¸ç­‰æ—¶ï¼Œæ²¡æœ‰è€ƒè™‘åˆ°ä¸¤ä¸ªæ•°ç›´æ¥ç›¸å·®å¯èƒ½å¤§äº1ï¼Œæ—¢ç¬¬ $ summ/2 $ ä¸ $ summ/2 + 1 $ ä¹‹é—´æœ‰å¾ˆå¤šæ•°ä¸º0çš„æƒ…å†µ å¯¹0-255åŠ æƒæ±‚å’Œæ—¶ï¼Œå³è¾¹åº”è¯¥å…ˆè½¬doubleå†è®¡ç®—ï¼Œé˜²æ­¢intæº¢å‡º ä»£ç class Solution { public: vector&lt;double&gt; sampleStats(vector&lt;int&gt;&amp; count) { int minmum = 255; int maximum = 0; double mean = 0; double mode = 0; double medium = 0; int summ = 0; for(int i = 0; i &lt; 256; i++) { if(count[i] &gt; 0) { minmum = min(minmum, i); maximum = max(maximum, i); summ += count[i]; mean += 1.0*i*count[i]; } if(count[i] &gt; count[mode]) { mode = i; } } mean /= summ; { int i = 0, c = count[0]; for(; c&lt;summ/2; c+=count[++i])continue; if(summ%2 == 0) medium = i; for(; c&lt;=summ/2; c+=count[++i])continue; medium += i; if(summ%2 == 0) { medium /= 2; } } return {(double)minmum, (double)maximum, mean, medium, mode}; } };","link":"/home/2023/05/24/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9325/"},{"title":"LeetCode-26","text":"[Medium] 1110. åˆ ç‚¹æˆæ—åˆ†æ ä½¿ç”¨ä»€ä¹ˆæ ·çš„æ•°æ®ç»“æ„ ç›´æ¥ç”¨æ•°ç»„ ç”¨å­©å­å…„å¼Ÿè¡¨ç¤ºæ³• ä½¿ç”¨ä»€ä¹ˆæ ·çš„éå†æ–¹æ³•ï¼Ÿ ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: vector&lt;TreeNode*&gt; forest; vector&lt;TreeNode*&gt; delNodes(TreeNode* root, vector&lt;int&gt;&amp; to_delete) { if(root){ if(del(root, to_delete)) { push_forest(root); } else { forest.push_back(root); } } return forest; } bool del(TreeNode* root, vector&lt;int&gt;&amp; to_delete) { if(root-&gt;left &amp;&amp; del(root-&gt;left, to_delete)) { push_forest(root-&gt;left); root-&gt;left = nullptr; } if(root-&gt;right &amp;&amp; del(root-&gt;right, to_delete)) { push_forest(root-&gt;right); root-&gt;right = nullptr; } for(int d : to_delete) { if(d == root-&gt;val) { return true; } } return false; } void push_forest(TreeNode *root) { if(root-&gt;left) { forest.push_back(root-&gt;left); } if(root-&gt;right) { forest.push_back(root-&gt;right); } }}; ç»“æœ è‹¥ä½¿ç”¨å­©å­å…„å¼Ÿè¡¨ç¤ºæ³•ï¼Œéœ€è¦å°†äºŒå‰æ ‘è½¬æ¢ä¸ºå­©å­å…„å¼Ÿï¼Œå¤„ç†å¥½ååœ¨è½¬æ¢å›æ¥ï¼ŒåŒæ—¶å°†æ ¹èŠ‚ç‚¹åŠå…¶å…„å¼Ÿå˜æˆæ•°ç»„ï¼Œä¸å¦‚ç›´æ¥ç”¨æ•°ç»„ è‹¥ä½¿ç”¨å…ˆåºï¼Œè‹¥ä¸çŸ¥é“å­©å­æ˜¯å¦åº”è¯¥è¢«åˆ é™¤ï¼Œè€Œç›´æ¥æ”¾å…¥æœ€ç»ˆç»“æœä¸­ï¼Œè‹¥å­èŠ‚ç‚¹ä¹Ÿéœ€è¦è¢«åˆ é™¤ï¼Œé‚£ä¹ˆå¤„ç†å°†ä¼šå˜å¾—å¤æ‚ æ—¶é—´ 16 ms å‡»è´¥ 92.74%å†…å­˜ 24.6 MB å‡»è´¥ 85.48% [Hard] 1439. æœ‰åºçŸ©é˜µä¸­çš„ç¬¬ k ä¸ªæœ€å°æ•°ç»„å’Œåˆ†ææ€»ä½“æ€è·¯å°é¡¶å †+næŒ‡é’ˆ æˆ‘ä»¬å·²çŸ¥matçš„æ¯ä¸€è¡Œéƒ½æ˜¯éé€’å‡çš„ï¼Œé‚£ä¹ˆæœ€å°çš„å…ƒç´ ä¸€å®šæ˜¯å…¨éƒ¨å–æ¯è¡Œç¬¬ä¸€ä¸ªå…ƒç´ çš„æƒ…å†µã€‚æˆ‘ä»¬è®°å½•ä¸ºçŠ¶æ€[0,0,0,0,...] å‚è€ƒbfsçš„æ€æƒ³ï¼Œåœ¨åˆå§‹çŠ¶æ€çš„åŸºç¡€ä¸Šç§»åŠ¨ä¸€ä¸ªæŒ‡é’ˆï¼Œä¸€å®šæ¯”ç¬¬åˆå§‹çŠ¶æ€å¤§ æ­¤å¤„è´ªå¿ƒï¼Œæ¯æ¬¡é€‰å–æœ€å°çš„çŠ¶æ€ï¼ˆå³nä¸ªæŒ‡é’ˆå¯¹åº”å…ƒç´ ä¹‹å’Œæœ€å°çš„ï¼‰ï¼Œå°†å…¶ä¸‹ä¸€æ­¥çŠ¶æ€ç”Ÿæˆå‡ºæ¥ï¼Œç”Ÿæˆkæ¬¡åï¼Œå³ä¸ºç¬¬kå°çš„çŠ¶æ€ çŠ¶æ€è½¬æ¢æ˜“çŸ¥åˆå§‹çŠ¶æ€S=[0,0,0,...,0]çš„ä¸‹ä¸€æ­¥ä¸º S1=[1,0,0,...,0] S2=[0,1,0,...,0] S3=[0,0,1,...,0] ... Sn=[0,0,0,...,1] ç„¶è€Œå¯¹äºçŠ¶æ€Siçš„ç¬¬jä¸ªå­çŠ¶æ€ä¸Sjçš„ç¬¬iä¸ªå­çŠ¶æ€éƒ½æ˜¯Sij=Sji=[0,0,0,...,1,...,1,...,0]ã€‚ä¸ºäº†é˜²æ­¢é‡å¤ï¼Œè§„å®šï¼ŒSiåªèƒ½ä»ç¬¬iä¸ªæŒ‡é’ˆåŠå…¶åé¢çš„æŒ‡é’ˆå‘åç§»åŠ¨ä¸€ä½è¡¨ç¤ºä¸º pair&lt;int, vector&lt;int&gt;&gt;(i, {0,0,0,...,1,...,0})æ­¤å¤„iä¸ºè¯¥çŠ¶æ€å…è®¸å‘åç§»åŠ¨çš„æŒ‡é’ˆç¬¬ä¸€ä¸ªæŒ‡é’ˆ æ³¨æ„12è¾“å…¥ï¼šmat = [[1,10,10],[1,4,5],[2,3,6]], k = 7è¾“å‡ºï¼š9 çŠ¶æ€[0,2,0]å°äº[1,0,0]ã€‚ä¹Ÿå°±æ˜¯ç§»åŠ¨æŒ‡é’ˆæ¬¡æ•°å¤šçš„ï¼Œå…¶å€¼å¯èƒ½åè€Œæ¯”ç§»åŠ¨æ¬¡æ•°å°‘çš„æ›´å°ï¼Œè¿™ä¹Ÿæ˜¯ä½¿ç”¨å †çš„åŸå›  ä»£ç 12345678910111213141516171819202122232425262728293031323334353637class Solution {public: int m, n; int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int k) { m = mat.size(), n = mat[0].size(); auto cmp = [&amp;](pair&lt;int, vector&lt;int&gt;&gt;&amp; a, pair&lt;int, vector&lt;int&gt;&gt;&amp; b) { int suma = 0, sumb = 0; for(int i = 0; i &lt; m; i++) { suma += mat[i][a.second[i]]; sumb += mat[i][b.second[i]]; } return suma &gt; sumb; }; priority_queue&lt;pair&lt;int, vector&lt;int&gt;&gt;, vector&lt;pair&lt;int, vector&lt;int&gt;&gt;&gt;, decltype(cmp)&gt; q(cmp); vector&lt;int&gt; state = vector&lt;int&gt;(m, 0); q.push(make_pair(0, state)); while(k--) { auto tmp = q.top(); q.pop(); state = tmp.second; for(int i = tmp.first; i &lt; m; i++) { if(state[i] + 1 &gt;= n) continue; state[i]++; q.push(make_pair(i, state)); state[i]--; } } return value(state, mat); } int value(const vector&lt;int&gt;&amp; v, vector&lt;vector&lt;int&gt;&gt;&amp; mat) { int sum = 0; for(int i = 0; i &lt; m; i++) { sum += mat[i][v[i]]; } return sum; }}; ä¼˜åŒ–ä»£ç  ä½¿ç”¨æ•°ç»„å‰ä¸¤ä½ä»£è¡¨åŸæ¥çš„iå’Œvalueï¼Œå‡å°‘é‡å¤è®¡ç®—value ä½¿ç”¨å‰ä¸€æ­¥çŠ¶æ€çš„valueè®¡ç®—æ–°valueï¼Œå‡å°‘éå†æ¬¡æ•° ä½¿ç”¨--kè€Œä¸æ˜¯k--ï¼Œç¬¬kä¸ªæ— éœ€è®¡ç®—å…¶åä»£ï¼Œåä»£ä¸€å®šä¸æ¯”ä»–å°12345678910111213141516171819202122232425262728293031class Solution {public: int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int k) { int m = mat.size(), n = mat[0].size(); auto cmp = [&amp;](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) { return a[1] &gt; b[1]; }; priority_queue&lt;vector&lt;int&gt;, vector&lt;vector&lt;int&gt;&gt;, decltype(cmp)&gt; q(cmp); vector&lt;int&gt; state = vector&lt;int&gt;(m+2, 0); for(int i = 0; i &lt; m; i++) { state[1] += mat[i][0]; } q.push(state); while(--k) { state = q.top(); q.pop(); int oldvalue = state[1]; for(int i = state[0]; i &lt; m; i++) { if(state[i+2] + 1 &gt;= n) continue; state[1] -= mat[i][state[i+2]]; state[i+2]++; state[0] = i; state[1] += mat[i][state[i+2]]; q.push(state); state[i+2]--; state[1] = oldvalue; } } return q.top()[1]; }}; æ—¶é—´ 16 ms å‡»è´¥ 93.5%å†…å­˜ 14.4 MB å‡»è´¥ 38.35% [Medium] 1130. å¶å€¼çš„æœ€å°ä»£ä»·ç”Ÿæˆæ ‘åˆ†æè§‚å¯Ÿæµ‹è¯•ç”¨ä¾‹123è¾“å…¥ï¼šarr = [6,2,4]è¾“å‡ºï¼š32è§£é‡Šï¼šæœ‰ä¸¤ç§å¯èƒ½çš„æ ‘ï¼Œç¬¬ä¸€ç§çš„éå¶èŠ‚ç‚¹çš„æ€»å’Œä¸º 36 ï¼Œç¬¬äºŒç§éå¶èŠ‚ç‚¹çš„æ€»å’Œä¸º 32 ã€‚ è¿™é‡Œä¸€å…±ä¸¤ç§æ–¹æ³• å…ˆé€‰æ‹©arr[0]å’Œarr[1] å…ˆé€‰æ‹©arr[1]å’Œarr[2] ç¬¬äºŒç§æœ€åä»£ä»·æœ€å° è¿™é‡Œå°±è”æƒ³åˆ°æ•°æ®ç»“æ„ä¸­å“ˆå¤«æ›¼æ ‘çš„ç®—æ³•ã€‚ç•¥æœ‰ä¸åŒï¼š ä¸èƒ½å¯¹æ•°ç»„æ’åºï¼Œå› ä¸ºä»–å¯¹åº”ç€ä¸­åºéå† ç”Ÿæˆçˆ¶èŠ‚ç‚¹æ—¶ï¼Œè¦æ‰¾åˆ°ä¸¤ä¸ªèŠ‚ç‚¹å­æ ‘ä¸­å¶èŠ‚ç‚¹çš„æœ€å¤§å€¼ æ„é€ ç®—æ³•æ ¹æ®å“ˆå¤«æ›¼æ ‘ç®—æ³•ï¼Œæ¯æ¬¡é€‰å–ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œç”Ÿæˆä¸€ä¸ªçˆ¶èŠ‚ç‚¹ï¼Œå­˜å…¥æ•°ç»„ä¸­ï¼Œæ­¤æ—¶æ•°ç»„å¤šäº†ä¸€ä¸ªç©ºé—²èŠ‚ç‚¹ï¼Œè¿™ä¸ªèŠ‚ç‚¹å°±ç”¨æ¥å­˜æ”¾è¯¥çˆ¶èŠ‚ç‚¹ä¸‹çš„æœ€å¤§å¶å­ã€‚ åˆå§‹æƒ…å†µä¸‹ï¼Œç›´æ¥é€‰æ‹©ä¹˜ç§¯æœ€å°çš„ä¸¤ä¸ªç›¸é‚»èŠ‚ç‚¹node1, node2ç”Ÿæˆçˆ¶èŠ‚ç‚¹nodeï¼Œæ­¤æ—¶å°†çˆ¶èŠ‚ç‚¹æ’å…¥åŸæ¥node1çš„ä½ç½®ï¼Œnode2çš„ä½ç½®ç”¨æ¥ä¿å­˜max(node1, node2)ã€‚ æ­¤æ—¶éœ€è¦ä¸€ä¸ªè¾…åŠ©æ•°ç»„æ ‡è®°æ¯ä¸ªä½ç½®æ˜¯èŠ‚ç‚¹è¿˜æ˜¯ä¿¡æ¯ï¼Œç”¨trueä»£è¡¨å…¶æ˜¯èŠ‚ç‚¹ åç»­ä¸­ï¼Œæ¯æ¬¡é€‰æ‹©ä¸¤ä¸ªç›¸é‚»çš„èŠ‚ç‚¹ï¼ˆä¸¤ä¸ªç›¸é‚»çš„trueæˆ–è€…ä¸¤ä¸ªtrueä¹‹é—´åªæœ‰falseï¼‰ï¼Œé€‰æ‹©ä¹˜ç§¯æœ€å°çš„ä¸¤å¯¹ï¼Œæ­¤æ—¶æœ‰ä»¥ä¸‹å‡ ç§æƒ…å†µ 110â€¦ //ä¸¤ä¸ªè¿ç»­1ä¸”ç¬¬äºŒä¸ª1åé¢æœ‰0ï¼ˆç¬¬äºŒä¸ªèŠ‚ç‚¹ä¸ºéå¶ï¼‰ 111â€¦ // ä¸¤ä¸ªéƒ½å¶ 10..11.. // ç¬¬ä¸€ä¸ªèŠ‚ç‚¹éå¶ï¼Œç¬¬äºŒä¸ªä¸ºå¶å­ 10..10..0 // ä¸¤ä¸ªéƒ½éå¶ï¼Œä¸”æ²¡æœ‰ä¸‹ä¸€å¯¹èŠ‚ç‚¹äº† 10..10..1 // ä¸¤ä¸ªéƒ½éå¶ï¼Œä¸”æœ‰ä¸‹ä¸€å¯¹èŠ‚ç‚¹äº† 11 // ä¸¤ä¸ªéƒ½å¶ä¸”æ²¡æœ‰ä¸‹ä¸€å¯¹èŠ‚ç‚¹äº† 10â€¦1 // ç¬¬ä¸€ä¸ªèŠ‚ç‚¹éå¶ï¼Œç¬¬äºŒä¸ªä¸ºå¶å­ä¸”æ²¡æœ‰ä¸‹ä¸€å¯¹èŠ‚ç‚¹äº† ä¹Ÿå°±æ˜¯éœ€è¦è€ƒè™‘ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯å¦æ˜¯å¶å­çš„æƒ…å†µï¼Œè¿˜æœ‰æ²¡æœ‰ä¸‹ä¸€å¯¹èŠ‚ç‚¹çš„æƒ…å†µï¼Œä¸è®ºä½•ç§æƒ…å†µï¼Œéƒ½å°†node1ä½ç½®å­˜æ”¾ç”Ÿæˆçš„çˆ¶èŠ‚ç‚¹nodeï¼Œnode1ä½ç½®+1å­˜æ”¾æœ€å¤§å¶å­ã€‚è¿™æ ·å¦‚æœä¸€ä¸ªèŠ‚ç‚¹ä¸ºåé¢ä½ç½®ä¸ºfalseï¼Œåˆ™åé¢è¿™ä¸ªæ•°å°±æ˜¯å­æ ‘ä¸­çš„æœ€å¤§å¶å­ æŒ‰ç…§å“ˆå¤«æ›¼æ ‘ç®—æ³•ï¼Œé‡å¤n-1æ¬¡ä¸Šé¢æ“ä½œ ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution {public: int mctFromLeafValues(vector&lt;int&gt;&amp; arr) { int n = arr.size(); int ret = 0; vector&lt;bool&gt; available = vector&lt;bool&gt;(n, true); for(int cnt = 0; cnt &lt; n - 1; cnt++) { int i = 0, j = 0; int mini = 0, minj = 0; int minn = INT_MAX, minn1, minn2; while(i &lt; n &amp;&amp; !available[i]) i++; j = i+1; while(j &lt; n) { while(j &lt; n &amp;&amp; !available[j]) j++; if(j &gt;= n) break; int node = 0, node1, node2; if(available[i+1]) { node1 = arr[i]; } else { node1 = arr[i+1]; } if(j + 1 &lt; n &amp;&amp; !available[j+1]) { node2 = arr[j+1]; } else { node2 = arr[j]; } node = node1 * node2; if(node &lt; minn) { mini = i; minj = j; minn = node; minn1 = node1; minn2 = node2; } i = j; j++; } ret += minn; arr[mini+1] = max(minn1, minn2); arr[mini] = minn; available[mini+1] = false; available[minj] = false; } return ret; }}; æ—¶é—´ 4 ms å‡»è´¥ 77.21%å†…å­˜ 8.2 MB å‡»è´¥ 61.86% ä¼˜åŒ–ç”±äºæœ€å¤§åªæœ‰40ä¸ªèŠ‚ç‚¹ï¼ŒçŠ¶æ€ä¹Ÿåªæœ‰true, falseï¼Œåªéœ€è¦ä¸€ä¸ªlong longå°±å¯ä»¥ä»£æ›¿availableæ•°ç»„ æ—¶é—´ $ O(n^2) $ ç©ºé—´ $ O(1) $ å‚è€ƒè¿™ä¸ªé¢˜è§£ï¼Œæˆ‘çš„æ€è·¯å…¶å®ä¸ä»–å®Œå…¨ç›¸ä¼¼ï¼Œä¸”æ²¡å¿…è¦å­˜å‚¨çˆ¶èŠ‚ç‚¹çš„å€¼ï¼ˆæ¯æ¬¡çˆ¶èŠ‚ç‚¹çš„å€¼ä¿å­˜èµ·æ¥ï¼Œä½†æ˜¯è®¡ç®—æ—¶éƒ½ç”¨ä¸åˆ°ï¼‰ï¼Œåªè¦æŠŠè¾ƒå°çš„å€¼åˆ é™¤å°±å¥½ 123456789101112131415161718class Solution {public: int mctFromLeafValues(vector&lt;int&gt;&amp; arr) { int n = arr.size(), ret = 0; for(int cnt = n - 1; cnt &gt; 0; cnt--) { // cntæ°å¥½å°±æ˜¯æ•°ç»„çš„size int min_index = 0, minn = INT_MAX; for(int i = 0; i &lt; cnt; i++) { if(arr[i] * arr[i+1] &lt; minn) { minn = arr[i] * arr[i+1]; min_index = arr[i] &lt; arr[i+1] ? i : i + 1; } } ret += minn; arr.erase(arr.begin() + min_index); } return ret; }}; [Medium] 1156. å•å­—ç¬¦é‡å¤å­ä¸²çš„æœ€å¤§é•¿åº¦åˆ†æè§‚å¯Ÿæ ·ä¾‹12è¾“å…¥ï¼štext = &quot;ababa&quot;è¾“å‡ºï¼š3 æŠŠè¿™ä¸€ç±»æ‹“å±•ï¼Œå½’ç±»ä¸ºå•å±‚æ±‰å ¡ç±»å‹ä¹Ÿå°±æ˜¯$ XXâ€¦XyXXâ€¦X $ ç”¨cnt[alpha]è¡¨ç¤ºå­—ç¬¦alphaåœ¨æ•´ä¸ªå­—ç¬¦ä¸²ä¸­å‡ºç°çš„æ¬¡æ•° è¿™ç±»æƒ…å†µä¼šæœ‰ä¸¤ç§è§£å†³æ–¹æ³• è‹¥yå·¦è¾¹æœ‰è¿ç»­a1ä¸ªXï¼Œå³è¾¹æœ‰a2ä¸ªX è‹¥a1 + a2 &lt; cnt[X]ï¼Œåˆ™å°†yä¸a1,a2ä¹‹å¤–çš„å¦ä¸€ä¸ªXäº¤æ¢ï¼ŒXæ€»é•¿åº¦ä¸ºa1 + a2 + 1 è‹¥a1 + a2 == cnt[X]ï¼Œåˆ™å°†yä¸a1ä¸­ç¬¬ä¸€ä¸ªXäº¤æ¢ï¼ŒXæ€»é•¿åº¦ä¸ºa1 + a2 = cnt[X] æŠŠè¿™åœ¨å•å±‚æ±‰å ¡çš„æƒ…å†µä¸‹ç»§ç»­æ‹“å±•ï¼Œè‹¥é‡åˆ°å¤šå±‚æ±‰å ¡ï¼Œå³å¤¹å¿ƒy(å¯èƒ½ä¸ºï¼šç”Ÿèœ* $ n_1 $ï¼Œç‰›è‚‰é¥¼*$n_2$ï¼Œç•ªèŒ„é…±*$n_3$ï¼Œé…¸é»„ç“œ*$n_4 $ç­‰å¤šç§ç±»å‹çš„)çš„ä¸ªæ•°å¤§äº1$ XXâ€¦Xy_1y_2â€¦y_nXXâ€¦X $ è¿™ç±»æƒ…å†µä¼šæœ‰ä¸¤ç§è§£å†³æ–¹æ³• è‹¥yå·¦è¾¹æœ‰è¿ç»­a1ä¸ªXï¼Œå³è¾¹æœ‰a2ä¸ªX è‹¥a1 &gt;= a2ï¼Œåˆ™å°†$ y_1 $ä¸a2ä¹‹ä¸­çš„ä¸€ä¸ªXäº¤æ¢ï¼ŒXæ€»é•¿åº¦ä¸ºa1 + 1 è‹¥a1 &lt;= a2ï¼Œåˆ™å°†$ y_n $äºa1ä¸­çš„ä¸€ä¸ªXäº¤æ¢ï¼ŒXæ€»é•¿åº¦ä¸ºa2 + 1 ä¸Šé¢ä¸¤ç§æƒ…å†µç»Ÿç§°æ±‰å ¡ç±»å‹ï¼Œå³è‡³å°‘ä¸‰å±‚ å¯¹äºä¸¤å±‚çš„æŠ«è¨æ¨¡å‹ä»¥åŠä¸€å±‚çš„é¥¼å¹²æ¨¡å‹ åªè¦ç»Ÿè®¡æ¯ç§å­—ç¬¦çš„ä¸ªæ•°å³å¯å–æœ€å¤§å€¼å³å¯ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: int maxRepOpt1(string text) { int cnt[26] = {0}; int n = text.length(); for(int i = 0; i &lt; n; i++) { text[i] -= 'a'; cnt[text[i]]++; } int i = 0; int last_end[26] = {-1}, last_cnt[26] = {0}; int ret = 0; while(i &lt; n) { int counti = 0; int j = i; while(j &lt; n &amp;&amp; text[i] == text[j]) { j++; counti++; } if(last_cnt[text[i]] != 0) { if(i - last_end[text[i]] == 2) { if(cnt[text[i]] == counti + last_cnt[text[i]]) { ret = max(ret, counti + last_cnt[text[i]]); } else { ret = max(ret, 1 + counti + last_cnt[text[i]]); } } else { ret = max(ret, 1 + max(counti, last_cnt[text[i]])); } } else { ret = max(ret, counti); } last_end[text[i]] = j-1; last_cnt[text[i]] = counti; i = j; } return ret; }}; [Medium] 2352. ç›¸ç­‰è¡Œåˆ—å¯¹æš´åŠ›12345678910111213141516171819202122class Solution {public: int equalPairs(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); int cnt = 0; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { bool flag = true; for(int k = 0; k &lt; n; k++) { if(grid[i][k] != grid[k][j]) { flag = false; break; } } if(flag) { cnt++; } } } return cnt; }}; ä¼˜åŒ–æ’åº+äºŒåˆ† 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: int equalPairs(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); int cnt = 0; vector&lt;vector&lt;int&gt;&gt; grid1(n, vector&lt;int&gt;(n, 0)); for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { grid1[i][j] = grid[j][i]; } } int l = 0; sort(grid1.begin(), grid1.end()); sort(grid.begin(), grid.end()); for(int i = 0; i &lt; n; i++) { int r = n-1; while(l &lt;= r) { int mid = (r - l) / 2 + l; if(grid1[mid] == grid[i]) { cnt++; for(int k = mid-1; k &gt;= 0; k--) { if(grid1[k] == grid[i]) { cnt++; } else { break; } } for(int k = mid + 1; k &lt; n; k++) { if(grid1[k] == grid[i]) { cnt++; } else { break; } } l = mid; break; } else if(grid1[mid] &gt; grid[i]) { r = mid - 1; } else { l = mid + 1; } } } return cnt; }}; å†ä¼˜åŒ–æ’åº+äºŒåˆ†+è®¡æ•° 12345678910111213141516171819202122232425262728293031323334class Solution {public: int equalPairs(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); int cnt = 0; vector&lt;vector&lt;int&gt;&gt; grid1(n, vector&lt;int&gt;(n, 0)); map&lt;vector&lt;int&gt;, int&gt; vec2cnt; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { grid1[i][j] = grid[j][i]; } vec2cnt[grid1[i]]++; } int l = 0; sort(grid1.begin(), grid1.end()); sort(grid.begin(), grid.end()); for(int i = 0; i &lt; n; i++) { int r = n-1; while(l &lt;= r) { int mid = (r - l) / 2 + l; if(grid1[mid] == grid[i]) { cnt += vec2cnt[grid1[mid]]; l = mid; break; } else if(grid1[mid] &gt; grid[i]) { r = mid - 1; } else { l = mid + 1; } } } return cnt; }}; å†å†ä¼˜åŒ–ç”¨vectorè®¡æ•° 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {public: int equalPairs(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); int cnt = 0; vector&lt;vector&lt;int&gt;&gt; grid1(n, vector&lt;int&gt;(n, 0)); vector&lt;int&gt; index_cnt(n, 1); for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { grid1[i][j] = grid[j][i]; } } int l = 0; sort(grid1.begin(), grid1.end()); sort(grid.begin(), grid.end()); for(int i = 1; i &lt; n; i++) { if(grid1[i] == grid1[i-1]) { index_cnt[i] = index_cnt[i-1] + 1; } } for(int i = n-1; i &gt; 0; i--) { if(grid1[i] == grid1[i-1]) { index_cnt[i-1] = index_cnt[i]; } } for(int i = 0; i &lt; n; i++) { int r = n-1; while(l &lt;= r) { int mid = (r - l) / 2 + l; if(grid1[mid] == grid[i]) { cnt += index_cnt[mid]; l = mid; break; } else if(grid1[mid] &gt; grid[i]) { r = mid - 1; } else { l = mid + 1; } } } return cnt; }}; hash123456789101112131415161718192021class Solution {public: int equalPairs(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); int cnt = 0; vector&lt;vector&lt;int&gt;&gt; grid1(n, vector&lt;int&gt;(n, 0)); map&lt;vector&lt;int&gt;, int&gt; vec2cnt; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { grid1[i][j] = grid[j][i]; } vec2cnt[grid1[i]]++; } for(int i = 0; i &lt; n; i++) { if(vec2cnt.count(grid[i]) &gt; 0) { cnt += vec2cnt[grid[i]]; } } return cnt; }}; [Medium] 2611. è€é¼ å’Œå¥¶é…ªåˆ†æå¦‚æœè¦æ‰¾å…¨å±€æœ€ä¼˜ï¼Œå³æ²¡æœ‰ç¬¬ä¸€åªè€é¼ åƒkåªçš„é™åˆ¶ï¼Œé‚£ä¹ˆåªè¦è®©rewardæ›´å¤§çš„è€é¼ åƒæ‰ç¬¬iå—å¥¶é…ªå³å¯ ç°åœ¨å¸Œæœ›å¯¹è€é¼ åƒæ‰çš„æ•°ç›®è¿›è¡Œé™åˆ¶ï¼Œå¯¹ä¸¤ä¸ªrewardå·®å€¼ç”±å¤§åˆ°å°è¿›è¡Œæ’åº ç”±å°é¼ 1åƒæ‰å‰kä¸ªï¼Œè¿™æ · å‡å¦‚reward1 &gt; reward2 çš„å¥¶é…ªæ•°ç›®ç­‰äºkï¼Œåˆ™åˆšå¥½æ˜¯å…¨å±€æœ€ä¼˜ å‡å¦‚reward1 &gt; reward2 çš„å¥¶é…ªæ•°ç›®å¤§äºkï¼Œåˆ™è€é¼ 2åƒæ‰äº†åŸå±äºå°é¼ 1çš„å¥¶é…ªï¼Œä½†å‰kä¸ªå·®å€¼æœ€å¤§ï¼Œèƒ½è·å¾—æœ€å¤§å¾—åˆ† å‡å¦‚reward1 &gt; reward2 çš„å¥¶é…ªæ•°ç›®å°äºkï¼Œåˆ™è€é¼ 1åƒæ‰äº†åŸå±äºå°é¼ 2çš„å¥¶é…ªï¼Œä½†ån-kä¸ªå·®å€¼æœ€å¤§ï¼Œèƒ½è·å¾—æœ€å¤§å¾—åˆ† ä»£ç 12345678910111213141516171819class Solution {public: int miceAndCheese(vector&lt;int&gt;&amp; reward1, vector&lt;int&gt;&amp; reward2, int k) { int n = reward1.size(), rwd = 0; vector&lt;int&gt; index(n); iota(index.begin(), index.end(), 0); sort(index.begin(), index.end(), [&amp;](int a, int b){ return reward1[a] - reward2[a] &gt; reward1[b] - reward2[b]; }); int i = 0; for(;i &lt; k; i++) { rwd += reward1[index[i]]; } for(;i &lt; n; i++) { rwd += reward2[index[i]]; } return rwd; }}; å°±æ˜¯æ‰¾å‰kå¤§å¿«æ’123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: int miceAndCheese(vector&lt;int&gt;&amp; reward1, vector&lt;int&gt;&amp; reward2, int k) { if(k == 0) return accumulate(reward2.begin(), reward2.end(), 0); int n = reward1.size(); int l = 0, r = n - 1, pivx; while((pivx = partition(reward1, reward2, l, r)) != k-1) { if(pivx &gt; k-1) { r = pivx - 1; } else { l = pivx + 1; } } int rwd = 0; for(l = 0;l &lt; k; l++) { rwd += reward1[l]; } for(;l &lt; n; l++) { rwd += reward2[l]; } return rwd; } int partition(vector&lt;int&gt;&amp; reward1, vector&lt;int&gt;&amp; reward2, int l, int r) { int pivx1 = reward1[l]; int pivx2 = reward2[l]; while(l &lt; r) { while(l &lt; r &amp;&amp; reward1[r] - reward2[r] &lt;= pivx1 - pivx2) { r--; } reward1[l] = reward1[r]; reward2[l] = reward2[r]; while(l &lt; r &amp;&amp; reward1[l] - reward2[l] &gt;= pivx1 - pivx2) { l++; } reward1[r] = reward1[l]; reward2[r] = reward2[l]; } reward1[l] = pivx1; reward2[l] = pivx2; return l; }}; è¶…æ—¶ï¼Œå› ä¸ºå·²ç»æœ‰åºçš„æƒ…å†µä¼šå¯¼è‡´å…¶ä¸‹é™ä¸ºO(n^2) ä¼˜å…ˆé˜Ÿåˆ—12345678910111213141516171819202122class Solution {public: int miceAndCheese(vector&lt;int&gt;&amp; reward1, vector&lt;int&gt;&amp; reward2, int k) { int rwd = 0; int n = reward1.size(), q_size = 0; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; for (int i = 0; i &lt; n; i++) { rwd += reward2[i]; q.emplace(reward1[i] - reward2[i]); if (q_size == k) { q.pop(); } else { q_size++; } } while (k--) { rwd += q.top(); q.pop(); } return rwd; }};","link":"/home/2023/05/30/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9326/"},{"title":"LeetCode-29","text":"2661. æ‰¾å‡ºå æ¶‚å…ƒç´ 123456789101112131415161718192021class Solution {public: int firstCompleteIndex(vector&lt;int&gt;&amp; arr, vector&lt;vector&lt;int&gt;&gt;&amp; mat) { int m = mat.size(), n = mat[0].size(); vector&lt;int&gt; cnt_row(m, 0), cnt_col(n, 0); vector&lt;int&gt; index(m*n+1); for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; n; j++) { index[mat[i][j]] = i*n+j; } } int len = arr.size(); for(int i = 0; i &lt; len; i++) { int x = index[arr[i]]/n, y = index[arr[i]]%n; cnt_row[x]++; cnt_col[y]++; if(cnt_row[x] == n || cnt_col[y] == m) return i; } return -1; }}; 1657. ç¡®å®šä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦æ¥è¿‘123456789101112131415161718192021222324class Solution {public: inline bool logicXor(bool a, bool b) { return (a &amp;&amp; !b) || (b &amp;&amp; !a); } bool closeStrings(string word1, string word2) { vector&lt;int&gt; word1_cnt(26, 0), word2_cnt(26, 0); for(char c : word1) { word1_cnt[c - 'a']++; } for(char c : word2) { word2_cnt[c - 'a']++; } for(int i = 0; i &lt; 26; i++) { if(logicXor(word1_cnt[i] == 0, word2_cnt[i] == 0)) return false; } sort(word1_cnt.begin(), word1_cnt.end()); sort(word2_cnt.begin(), word2_cnt.end()); for(int i = 0; i &lt; 26; i++) { if(word1_cnt[i] != word2_cnt[i]) return false; } return true; }}; 2336. æ— é™é›†ä¸­çš„æœ€å°æ•°å­—123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class SmallestInfiniteSet { vector&lt;pair&lt;unsigned, unsigned&gt;&gt; s;public: SmallestInfiniteSet() { s.emplace_back(1, -1); } int popSmallest() { int smallest = s[0].first++; if(s[0].first == s[0].second) { s.erase(s.begin()); } return smallest; } void addBack(int num) { // cout &lt;&lt; &quot;add\\n&quot;; int n = s.size(); int i = 0; while(i &lt; n &amp;&amp; s[i].second &lt;= num) i++; if(i &gt;= n) { s.emplace_back(num, num + 1); return; } if(s[i].first &lt;= num) { return; } else { if(s[i].first-1 == num) { s[i].first--; // æ£€æŸ¥å‰é¢çš„ï¼Œæ‹¼æ¥ if(i-1 &gt;= 0 &amp;&amp; s[i-1].second == s[i].first) { s[i-1].second = s[i].second; s.erase(s.begin() + i); } } else { if(i - 1 &gt;= 0 &amp;&amp; s[i-1].second == num) { s[i-1].second++; } else { s.insert(s.begin() + i, make_pair(num, num+1)); } } } }};/** * Your SmallestInfiniteSet object will be instantiated and called as such: * SmallestInfiniteSet* obj = new SmallestInfiniteSet(); * int param_1 = obj-&gt;popSmallest(); * obj-&gt;addBack(num); */ 1670. è®¾è®¡å‰ä¸­åé˜Ÿåˆ—123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112class FrontMiddleBackQueue { deque&lt;int&gt; leftHalf, rightHalf; int leftHalfLen = 0, rightHalfLen = 0;public: FrontMiddleBackQueue() { } void pushFront(int val) { leftHalf.push_front(val); if(leftHalfLen - rightHalfLen &gt; 0) { rightHalf.push_front(leftHalf.back()); leftHalf.pop_back(); rightHalfLen++; } else { leftHalfLen++; } } void pushMiddle(int val) { if(leftHalfLen &gt; rightHalfLen) { rightHalf.push_front(leftHalf.back()); leftHalf.pop_back(); leftHalf.push_back(val); rightHalfLen++; } else { leftHalf.push_back(val); leftHalfLen++; } } void pushBack(int val) { rightHalf.push_back(val); if(rightHalfLen &gt;= leftHalfLen) { leftHalf.push_back(rightHalf.front()); rightHalf.pop_front(); leftHalfLen++; } else { rightHalfLen++; } } int popFront() { int ret = -1; if(leftHalfLen &lt;= 0) { if(rightHalfLen &gt; 0) { ret = rightHalf.front(); rightHalf.pop_front(); rightHalfLen--; } } else { ret = leftHalf.front(); leftHalf.pop_front(); if(leftHalfLen &lt;= rightHalfLen) { leftHalf.push_back(rightHalf.front()); rightHalf.pop_front(); rightHalfLen--; } else { leftHalfLen--; } } return ret; } int popMiddle() { int ret = -1; if(leftHalfLen &gt;= rightHalfLen) { if(leftHalfLen == 0) return -1; ret = leftHalf.back(); leftHalf.pop_back(); leftHalfLen--; } else { ret = rightHalf.front(); rightHalf.pop_front(); rightHalfLen--; } return ret; } int popBack() { int ret = -1; if(rightHalfLen &lt;= 0) { if(leftHalfLen &gt; 0) { ret = leftHalf.back(); leftHalf.pop_back(); leftHalfLen--; } } else { ret = rightHalf.back(); rightHalf.pop_back(); if(leftHalfLen &gt; rightHalfLen) { rightHalf.push_front(leftHalf.back()); leftHalf.pop_back(); leftHalfLen--; } else { rightHalfLen--; } } return ret; }};/** * Your FrontMiddleBackQueue object will be instantiated and called as such: * FrontMiddleBackQueue* obj = new FrontMiddleBackQueue(); * obj-&gt;pushFront(val); * obj-&gt;pushMiddle(val); * obj-&gt;pushBack(val); * int param_4 = obj-&gt;popFront(); * int param_5 = obj-&gt;popMiddle(); * int param_6 = obj-&gt;popBack(); */ 1094. æ‹¼è½¦123456789101112131415161718192021class Solution {public: bool carPooling(vector&lt;vector&lt;int&gt;&gt;&amp; trips, int capacity) { vector&lt;int&gt; max_capacity(1002, 0); int max_end = 0; int min_start = 1002; int len = trips.size(); for(int i = 0; i &lt; len; i++) { max_capacity[trips[i][1]] += trips[i][0]; max_capacity[trips[i][2]] -= trips[i][0]; max_end = max(trips[i][2], max_end); min_start = min(trips[i][1], min_start); } int cur_capacity = 0; for(int i = min_start; i &lt;= max_end; i++) { cur_capacity += max_capacity[i]; if(cur_capacity &gt; capacity) return false; } return true; }}; 1423. å¯è·å¾—çš„æœ€å¤§ç‚¹æ•°123456789101112131415161718class Solution {public: int maxScore(vector&lt;int&gt;&amp; cardPoints, int k) { int maxSum = 0; int sum = 0; int len = cardPoints.size(); for(int i = 0; i &lt; k; i++) { sum += cardPoints[i]; } maxSum = sum; for(int i = 0; i &lt; k; i++) { sum -= cardPoints[k - 1 - i]; sum += cardPoints[len - 1 - i]; maxSum = max(maxSum, sum); } return maxSum; }}; 1234567891011121314class Solution {public: int maxScore(vector&lt;int&gt; &amp;cardPoints, int k) { int n = cardPoints.size(); int m = n - k; int s = accumulate(cardPoints.begin(), cardPoints.begin() + m, 0); int min_s = s; for (int i = m; i &lt; n; i++) { s += cardPoints[i] - cardPoints[i - m]; min_s = min(min_s, s); } return accumulate(cardPoints.begin(), cardPoints.end(), 0) - min_s; }}; 1038. ä»äºŒå‰æœç´¢æ ‘åˆ°æ›´å¤§å’Œæ ‘1234567891011121314151617181920212223242526class Solution { vector&lt;int&gt; arr;public: TreeNode* bstToGst(TreeNode* root) { _bstToGst(root); int len = arr.size(); for(int i = len - 2; i &gt;= 0; i--) { arr[i] += arr[i+1]; } int index = 0; setGst(root, index); return root; } void _bstToGst(TreeNode* root) { if(!root) return; _bstToGst(root-&gt;left); arr.push_back(root-&gt;val); _bstToGst(root-&gt;right); } void setGst(TreeNode* root, int&amp; index) { if(!root) return; setGst(root-&gt;left, index); root-&gt;val = arr[index++]; setGst(root-&gt;right, index); }}; 123456789101112class Solution { int sum = 0;public: TreeNode* bstToGst(TreeNode* root) { if(!root) return root; bstToGst(root-&gt;right); sum += root-&gt;val; root-&gt;val = sum; bstToGst(root-&gt;left); return root; }}; 828. ç»Ÿè®¡å­ä¸²ä¸­çš„å”¯ä¸€å­—ç¬¦12345678910111213141516171819class Solution {public: int uniqueLetterString(string s) { vector&lt;vector&lt;int&gt;&gt; vec(26, vector&lt;int&gt;(1, -1)); int len = s.length(), ret = 0; for(int i = 0; i &lt; len; i++) { vec[s[i] - 'A'].push_back(i); } for(int i = 0; i &lt; 26; i++) { vector&lt;int&gt; &amp;arr = vec[i]; arr.push_back(len); int arr_len = arr.size(); for(int j = 1; j &lt; arr_len - 1; j++) { ret += (arr[j] - arr[j-1]) * (arr[j + 1] - arr[j]); } } return ret; }}; 1457. äºŒå‰æ ‘ä¸­çš„ä¼ªå›æ–‡è·¯å¾„123456789101112131415161718192021222324class Solution { vector&lt;int&gt; m; int odd_cnt = 0;public: Solution():m(10) {} int pseudoPalindromicPaths (TreeNode* root) { if(!root) { return 0; } int ret = 0; m[root-&gt;val]++; if(m[root-&gt;val] % 2 == 1) odd_cnt++; else odd_cnt--; if(!root-&gt;left &amp;&amp; !root-&gt;right) { if(odd_cnt &lt;= 1)ret = 1; } if(root-&gt;left) ret += pseudoPalindromicPaths(root-&gt;left); if(root-&gt;right) ret += pseudoPalindromicPaths(root-&gt;right); m[root-&gt;val]--; if(m[root-&gt;val] % 2 == 1) odd_cnt++; else odd_cnt--; return ret; }}; 2824. ç»Ÿè®¡å’Œå°äºç›®æ ‡çš„ä¸‹æ ‡å¯¹æ•°ç›®123456789101112131415class Solution {public: int countPairs(vector&lt;int&gt;&amp; nums, int target) { sort(nums.begin(), nums.end()); int n = nums.size(); int ret = 0, pos = n - 1; int i = 0; while(i &lt; pos) { while(pos &gt; i &amp;&amp; nums[pos] + nums[i] &gt;= target) pos--; ret += pos - i; i++; } return ret; }}; 1234567891011121314class Solution {public: int countPairs(vector&lt;int&gt;&amp; nums, int target) { sort(nums.begin(), nums.end()); int n = nums.size(); int ret = 0; for(int i = 0; i &lt; n - 1; i++) { if(nums[i+1] &gt;= target - nums[i]) break; int pos = upper_bound(nums.begin() + i + 1, nums.end(), target - nums[i] - 1) - nums.begin(); ret += pos - i - 1; } return ret; }}; 1410. HTML å®ä½“è§£æå™¨123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: bool strneq(const string&amp; str, int index, int strlen, const char *cmp, int len) { if(strlen - index &lt; len) return false; for(int i = 0; i &lt; len; i++) { if(str[index + i] != cmp[i]) return false; } return true; } string entityParser(string text) { string res; int len = text.length(), i = 0; while(i &lt; len) { if(text[i] != '&amp;') res.push_back(text[i]); else { if(strneq(text, i, len, &quot;&amp;quot;&quot;, 6)) { i += 6; res.push_back('&quot;'); continue; } else if(strneq(text, i, len, &quot;&amp;apos;&quot;, 6)) { i += 6; res.push_back('\\''); continue; } else if(strneq(text, i, len, &quot;&amp;amp;&quot;, 5)) { i += 5; res.push_back('&amp;'); continue; } else if(strneq(text, i, len, &quot;&amp;gt;&quot;, 4)) { i += 4; res.push_back('&gt;'); continue; } else if(strneq(text, i, len, &quot;&amp;lt;&quot;, 4)) { i += 4; res.push_back('&lt;'); continue; } else if(strneq(text, i, len, &quot;&amp;frasl;&quot;, 7)) { i += 7; res.push_back('/'); continue; } else { res.push_back(text[i]); } } i++; } return res; }}; 2304. ç½‘æ ¼ä¸­çš„æœ€å°è·¯å¾„ä»£ä»·12345678910111213141516171819202122class Solution {public: int minPathCost(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;int&gt;&gt;&amp; moveCost) { int m = grid.size(), n = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; g(m, vector&lt;int&gt;(n, INT_MAX / 2)); for(int j = 0; j &lt; n; j++) { g[0][j] = 0; } for(int i = 0; i &lt; m - 1; i++) { for(int j = 0; j &lt; n; j++) { for(int k = 0; k &lt; n; k++) { g[i+1][k] = min(g[i+1][k], g[i][j] + grid[i][j] + moveCost[grid[i][j]][k]); } } } int minCost = INT_MAX; for(int k = 0; k &lt; n; k++) { minCost = min(minCost, g[m-1][k] + grid[m-1][k]); } return minCost; }}; 2216. ç¾åŒ–æ•°ç»„çš„æœ€å°‘åˆ é™¤æ•°1234567891011121314151617181920class Solution {public: int minDeletion(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int i = 0; bool odd = false; int deleteCnt = 0; while(i &lt; len) { int j = i + 1; while(!odd &amp;&amp; j &lt; len &amp;&amp; nums[j] == nums[i]) j++; deleteCnt += j - i - 1; i = j; odd = !odd; } if((len - deleteCnt) % 2 == 1) { deleteCnt++; } return deleteCnt; }}; 53. æœ€å¤§å­æ•°ç»„å’Œå†™è¿‡ï¼Œè®°ä½ç­”æ¡ˆäº†ï¼Œè¿˜æ˜¯ä¸å¤ªæ‡‚ 123456789101112class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int subSum = 0, maxSubSum = INT_MIN; for(int n : nums) { if(subSum &lt;= 0) subSum = n; else subSum += n; maxSubSum = max(maxSubSum, subSum); } return maxSubSum; }}; æ€è€ƒå¯ä»¥æŠŠå‰ç¼€å’Œçš„æŠ˜çº¿å›¾ç”»å‡ºæ¥ï¼Œå‘ç°ï¼Œå¦‚æœé‡åˆ°è´Ÿæ•°ï¼Œæ›²çº¿ä¼šä»æœ€é«˜å€¼é™ä½ï¼Œå¦‚æœåœ¨å˜æˆ0ä¹‹å‰é‡åˆ°æ­£æ•°ï¼Œåˆ™æ­¤æ—¶åœ¨åŸæ¥çš„åŸºç¡€ä¸ŠåŠ ä¸Šè¯¥æ­£æ•°ï¼Œå°±å¯ä»¥å¾—åˆ°ç›®å‰ä¸ºæ­¢ï¼Œå±€éƒ¨çš„æœ€å¤§å€¼å¦‚æœåœ¨å˜æˆ0ä¹‹åé‡åˆ°æ­£æ•°ï¼Œåˆ™æ­¤æ—¶ä¸åœ¨åŸæ¥çš„åŸºç¡€ä¸ŠåŠ ä¸Šè¯¥æ­£æ•°ï¼Œè¿™æ ·æ­£æ•°å°±ä¸ä¼šè¢«å‰é¢çš„è´Ÿæ•°å’Œå„¿æŠµæ¶ˆï¼Œä»è€Œè·å¾—å½“å‰çš„å±€éƒ¨æœ€å¤§å€¼ 2477. åˆ°è¾¾é¦–éƒ½çš„æœ€å°‘æ²¹è€— åªè¦æ€»è·¯ç¨‹æœ€å°å°±å¥½äº†ï¼Œéœ€è¦å¯¹è½¦è¾†åº§ä½çš„æœ€å¤§åŒ–åˆ©ç”¨ å¦‚æœä¸€æ¡çº¿è·¯çš„é•¿åº¦ä¸è¶³ä»¥åæ»¡ä¸€è¾†è½¦ï¼Œå¯ä»¥æŠŠå¤šä¸ªçº¿è·¯çš„ä¹˜å®¢å…ˆèšé›†åœ¨æœ€è¿‘çš„å…¬å…±ç¥–å…ˆä¸Šï¼Œç„¶åç»Ÿä¸€å‘è½¦ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution {public: long long minimumFuelCost(vector&lt;vector&lt;int&gt;&gt;&amp; roads, int seats) { int n = roads.size() + 1; vector&lt;vector&lt;int&gt;&gt; g(n); vector&lt;int&gt; parent(n, 0); vector&lt;int&gt; len(n, 0); vector&lt;int&gt; deg(n, 0); vector&lt;bool&gt; visited(n, false); for(vector&lt;int&gt; &amp; vec : roads) { g[vec[1]].push_back(vec[0]); g[vec[0]].push_back(vec[1]); } queue&lt;int&gt; q; q.push(0); int depth = 0; while(!q.empty()) { int node = q.front(); q.pop(); depth++; visited[node] = true; for(int child : g[node]) { if(visited[child]) continue; parent[child] = node; deg[node]++; q.push(child); } } visited = vector&lt;bool&gt;(n, false); for(int i = 1; i &lt; n; i++) { if(deg[i] == 0) { q.push(i); } } long long ret = 0; while(!q.empty()) { int city = q.front(); q.pop(); len[parent[city]] += len[city] + 1; ret += (len[city] + 1) / seats + ((len[city] + 1)%seats ? 1 : 0); deg[parent[city]]--; city = parent[city]; if(deg[city] == 0 &amp;&amp; city != 0) { q.push(city); } } return ret; }}; 2342. æ•°ä½å’Œç›¸ç­‰æ•°å¯¹çš„æœ€å¤§å’Œ123456789101112131415161718192021222324252627282930313233class Solution {public: int maximumSum(vector&lt;int&gt;&amp; nums) { int n = nums.size(); unordered_map&lt;int, int&gt; bitSumMapMax; unordered_map&lt;int, int&gt; bitSumMapSecondMax; int maxSum = -1; for(int i = 0; i &lt; n; i++) { int num = nums[i]; int sum = 0; while(num) { sum += num % 10; num /= 10; } if(!bitSumMapMax.count(sum)) { bitSumMapMax[sum] = nums[i]; } else { if(nums[i] &gt;= bitSumMapMax[sum]) { bitSumMapSecondMax[sum] = bitSumMapMax[sum]; bitSumMapMax[sum] = nums[i]; maxSum = max(maxSum, bitSumMapSecondMax[sum] + bitSumMapMax[sum]); } else if(!bitSumMapSecondMax.count(nums[i])) { bitSumMapSecondMax[sum] = nums[i]; maxSum = max(maxSum, bitSumMapSecondMax[sum] + bitSumMapMax[sum]); } else if(nums[i] &gt; bitSumMapSecondMax[sum]) { bitSumMapMax[sum] = nums[i]; maxSum = max(maxSum, bitSumMapSecondMax[sum] + bitSumMapMax[sum]); } } } return maxSum; }}; 12345678910111213141516171819202122232425class Solution {public: int maximumSum(vector&lt;int&gt;&amp; nums) { int n = nums.size(); unordered_map&lt;int, int&gt; bitSumMapMax; int maxSum = -1; for(int i = 0; i &lt; n; i++) { int num = nums[i]; int sum = 0; while(num) { sum += num % 10; num /= 10; } if(!bitSumMapMax.count(sum)) { bitSumMapMax[sum] = nums[i]; } else { maxSum = max(maxSum, nums[i] + bitSumMapMax[sum]); if(nums[i] &gt;= bitSumMapMax[sum]) { bitSumMapMax[sum] = nums[i]; } } } return maxSum; }}; 1466. é‡æ–°è§„åˆ’è·¯çº¿12345678910111213141516171819202122232425262728class Solution {public: int minReorder(int n, vector&lt;vector&lt;int&gt;&gt;&amp; connections) { vector&lt;vector&lt;int&gt;&gt; g(n), parent(n); vector&lt;bool&gt; visited(n, false); int ret = 0; for(int i = 0; i &lt; n - 1; i++) { g[connections[i][0]].push_back(connections[i][1]); g[connections[i][1]].push_back(connections[i][0]); parent[connections[i][0]].push_back(connections[i][1]); } stack&lt;int&gt; q; q.push(0); while(!q.empty()) { int node = q.top(); q.pop(); visited[node] = true; for(int child : g[node]) { if(visited[child]) continue; if(find(parent[node].begin(), parent[node].end(), child) != parent[node].end()) { ret++; } q.push(child); } } return ret; }}; 123456789101112131415161718192021222324class Solution {public: int minReorder(int n, vector&lt;vector&lt;int&gt;&gt;&amp; connections) { vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; g(n); int ret = 0; for(int i = 0; i &lt; n - 1; i++) { g[connections[i][0]].push_back(make_pair(connections[i][1], 1)); g[connections[i][1]].push_back(make_pair(connections[i][0], 0)); } stack&lt;int&gt; q; q.push(0); while(!q.empty()) { int node = q.top(); q.pop(); visited[node] = true; for(auto&amp; child : g[node]) { if(visited[child.first]) continue; ret += child.second; q.push(child.first); } } return ret; }};","link":"/home/2023/12/01/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9329/"},{"title":"LeetCode-1","text":"1.ä¸¤æ•°ä¹‹å’ŒACä»£ç æ€è·¯ åˆšå¼€å§‹å°±æ˜¯ç”¨åŒå±‚forå¾ªç¯å†™ï¼Œç„¶åç§‰æ‰¿ç€è°¦è™šçš„æ€åº¦çœ‹äº†é¢˜è§£ï¼Œå‘ç°çœŸçš„æœ‰O(N)çš„ç®—æ³•ä¸€éå“ˆå¸Œè¡¨ã€‚ ä¸»è¦å°±æ˜¯åˆ©ç”¨mapå»ºç«‹ä»æ•°åˆ°æ•°ç»„ä¸‹æ ‡çš„mapï¼Œç„¶åæ¯æ¬¡è®¡ç®—å‡ºtarget-nums[i]çš„å€¼ï¼Œç„¶åçœ‹mapé‡Œé¢æœ‰å¯¹åº”çš„ä¸‹æ ‡ï¼Œæœ‰çš„è¯å°±è¾“å‡ºï¼Œæ²¡æœ‰å°±ç»§ç»­ã€‚ mapçš„å€¼ä¸º0æ—¶ï¼Œå¦‚ä½•åŒºåˆ†stlçš„mapçŸ¥è¯†æœ‰é™ï¼Œå¦‚ä½•åˆ¤æ–­0æ˜¯æ•°ç»„é‡Œé¢æ²¡æœ‰è¿™ä¸ªæ•°è¿˜æ˜¯æŸ¥è¯¢çš„å¼•ç´¢ä¸º0å‘¢ï¼Ÿåªè¦å‚¨å­˜çš„æ—¶å€™ä¸‹æ ‡+1ï¼Œç”¨çš„æ—¶å€™å‡ä¸€å°±è¡Œäº†ï¼Œè¿™æ ·mapå€¼ä¸º0ï¼Œä¸€å®šæ˜¯æ²¡æœ‰è¿™ä¸ªæ•°ã€‚ 12345678910111213141516171819class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;int&gt; ans; map&lt;int, int&gt; m; for (int i = 0; i &lt; nums.size(); i++) { int pos = target - nums[i]; if (m[pos] != 0 &amp;&amp; m[pos] != i + 1) { pos = m[pos] - 1; ans.push_back(pos &gt; i ? i : pos); ans.push_back(pos &lt; i ? i : pos); break; } m[nums[i]] = i + 1; } return ans; }}; 2. ä¸¤æ•°ç›¸åŠ æ²¡æƒ³åˆ°ç¬¬äºŒé¢˜å°±æ˜¯é“¾è¡¨äº†ï¼ŒLeetCodeç»™å‡ºçš„è¿™ç§å¸¦æ„é€ å‡½æ•°çš„ç»“æ„ä½“æŒºå¥½çš„ï¼Œç”¨èµ·æ¥æ–¹ä¾¿äº†å¾ˆå¤šï¼Œå¼€å§‹åˆ›å»ºä¸€ä¸ªheadï¼Œåé¢ç›´æ¥è¿”å›head-&gt;nextå°±å¥½ã€‚ nextè‡ªåŠ¨èµ‹å€¼ä¸ºNULLï¼ˆæˆ‘è§‰å¾—å¯ä»¥ææˆnexté»˜è®¤å‚æ•°ä¸ºNULLï¼Œè‡ªç”±åº¦æ›´å¤§ä¸€ç‚¹ï¼‰ å¿…é¡»ä¼ é€’å‚æ•°ï¼Œé™åˆ¶ä½¿ç”¨ï¼Œæ›´å®‰å…¨ ACä»£ç 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode* temp, *ans; int carry = 0, n; ans = temp = new ListNode(0); while (l1 != NULL || l2 != NULL) { //ç”¨é€»è¾‘æˆ–é“¾æ¥ï¼ŒæŠŠä¸¤ä¸ªé“¾è¡¨éƒ½éå†å®Œ n = (l1 == NULL ? 0 : l1-&gt;val) + (l2 == NULL ? 0 : l2-&gt;val) + carry; //æ³¨æ„æŸä¸ªé“¾è¡¨æ­¤æ—¶å¯èƒ½éå†å®Œçš„å¯èƒ½ temp-&gt;next = new ListNode(n%10); carry = n / 10; //è®¡ç®— if (l1 != NULL)l1 = l1-&gt;next; if (l2 != NULL)l2 = l2-&gt;next; //æ³¨æ„åˆ°é“¾è¡¨ä¸ºç©ºæˆ–å·²ç»éå†å®Œ temp = temp-&gt;next; //é›†ä½“æŒ‡å‘next } if (carry) temp-&gt;next = new ListNode(carry); //å¦‚æœè¿˜æœ‰å‰©ä½™çš„è¿›ä½ï¼Œå†newä¸€ä¸ª return ans-&gt;next; //è¿”å›å¤´ç»“ç‚¹çš„nextï¼ˆå¤´ç»“ç‚¹æ²¡æ„ä¹‰ï¼‰ }}; 7. æ•´æ•°åè½¬ç¬¬ä¸€æ¬¡ACçš„ï¼Œ28msæ€è·¯ å…ˆå¹²æ‰è´Ÿå·ï¼Œsprintfå˜å­—ç¬¦ä¸²ï¼Œè°ƒç”¨stdçš„reverseå‡½æ•°ï¼Œåè½¬ï¼Œå†å˜å›æ•°å­—ï¼Œç„¶åæŠŠç¬¦å·è¿˜åŸ ç”±äºè¦è€ƒå¯Ÿå¯¹æº¢å‡ºçš„å¤„ç†ï¼Œå°±å·æ¢æ¢æŸ±ç”¨äº†long longï¼Œè¶…è¿‡intèŒƒå›´çš„å°±è¿”å›0 1234567891011121314class Solution {public: int reverse(int y) { long long x = y; bool negative = (x &lt; 0); if (negative) x *= -1; char n[1024]; sprintf(n, &quot;%lld&quot;, x); std::reverse(n, n + strlen(n)); sscanf (n, &quot;%lld&quot;, &amp;x); if (negative) x *= -1; return x &gt;= 2147483647 || x &lt;= -2147483648 ? 0 : x; }}; çœ‹äº†çš„é«˜åˆ†åŒå­¦çš„ä»£ç ç¬¬äºŒæ¬¡ACçš„20msæ‰‹åŠ¨å¤§å“­ï¼Œå‡­ä»€ä¹ˆä¸€æ ·çš„ç®—æ³•ï¼Œäººå®¶å°±æ˜¯æœ€é«˜åˆ†ï¼Œæˆ‘å°±æ˜¯ä¸­ä½æ•°ï¼Ÿï¼Ÿè¿™ä½åŒå­¦ä»£ç å—çš„åŸå› ä¸»è¦æ˜¯è§£é™¤äº†ä¸stdioçš„åŒæ­¥ï¼Œcin.tie(nullptr)å¯¹cinï¼Œcoutè¿›è¡ŒåŠ é€Ÿäº†ï¼ŒæŠŠå–æ¶ˆåŒæ­¥çš„ä»£ç åˆ é™¤åï¼Œåè€Œæ¯”æˆ‘ç¬¬ä¸€æ¬¡ACçš„ä»£ç æ…¢äº†ã€‚ä¹Ÿä¸çŸ¥é“æ˜¯ä»€ä¹ˆåŸå› ã€‚ 1234567891011121314static int x = [](){ios::sync_with_stdio(false); cin.tie(nullptr); return 0; }();class Solution {public: int reverse(int y) { long long x = y; long long ans = 0; while (x) { ans *= 10; ans += x % 10; x /= 10; } return ans &gt;= 2147483647 || ans &lt;= -2147483648 ? 0 : ans; }}; 9. å›æ–‡æ•°ç¬¬ä¸€æ¬¡ACä»£ç æ€è·¯è½¬å­—ç¬¦ä¸²ï¼Œç›´æ¥å¾ªç¯æ¯” 1234567891011121314class Solution {public: bool isPalindrome(int x) { char n[16] = {0}; sprintf(n, &quot;%d&quot;, x); int len = strlen(n); for (int i = 0; i &lt; len/2; i++) { if (n[i] != n[len - 1 - i]) { return false; } } return true; }}; çœ‹äº†é«˜åˆ†åŒå­¦ä»£ç åçš„ç¬¬äºŒæ¬¡ACçš„ä»£ç æ€è·¯æŠŠæ•°å­—å½“åè¿›åˆ¶è½¬åè¿›åˆ¶ï¼Œç®—ä¸€æ¬¡çš„ç»“æœåˆšå¥½å’ŒåŸæ¥çš„æ•°åè½¬è¿‡æ¥ï¼Œå¦‚æœå¤§äº0ï¼Œæ¯”è¾ƒä¸¤ä¸ªæ•°æ˜¯å¦ç›¸ç­‰ï¼Œå¦åˆ™åè½¬ä¸€å®šä¸åˆæ¡ä»¶ï¼Œè¿”å›false 12345678910class Solution {public: bool isPalindrome(int x) { long long y = 0; for (int z = x; z; z /= 10) { y = y*10 + z % 10; } return x &gt;= 0 ? y == x : false; }}; 13. ç½—é©¬æ•°å­—è½¬æ•´æ•°åˆšå¼€å§‹æ¯«æ— æ€è·¯ï¼Œåæ¥çœ‹äº†è¯„è®ºé‡Œå¤§ä½¬çš„æ€è·¯æ‰å†™å‡ºæ¥ã€‚ ç¬¬ä¸€æ¬¡ACä»£ç æ€è·¯ æŠŠå‡ ä¸ªç¬¦å·çš„ASCIIå€¼å½“ä¸‹æ ‡ï¼Œå‚¨å­˜ç¬¦å·çš„å¯¹åº”çš„å€¼ éå†å­—ç¬¦ä¸²ï¼Œå¯¹äºæ¯ä¸€ä¸ªå­—ç¬¦ï¼Œå¦‚æœåä¸€ä¸ªå­—ç¬¦çš„å€¼å¤§äºè‡ªèº«ï¼Œä»æ€»æ•°ä¸­å‡å»è‡ªå·±çš„å€¼ï¼Œå¦‚æœåé¢çš„å€¼å°äºç­‰äºè‡ªèº«ï¼ˆIIIï¼ŒMMIIï¼‰ï¼Œåˆ™åœ¨æ€»æ•°ä¸­åŠ ä¸Šè‡ªå·± 123456789101112131415161718192021222324252627static const auto io_sync_off=[](){ std::ios::sync_with_stdio(false); std::cin.tie(NULL); return 0;}();class Solution {public: int romanToInt(string s) { int m[100] = {0}; m['M'] = 1000; m['D'] = 500; m['C'] = 100; m['L'] = 50; m['X'] = 10; m['V'] = 5; m['I'] = 1; int ans = 0; for (int i = 0; i &lt; s.length() - 1; i++) { //é˜²æ­¢è¶Šç•Œï¼Œä¸ç®¡æœ€åä¸€ä¸ªå­—ç¬¦ï¼Œå¾ªç¯ç»“æŸåå•ç‹¬è€ƒè™‘ if (m[s[i]] &gt;= m[s[i+1]]) ans += m[s[i]]; else ans -= m[s[i]]; } ans += m[s[s.length() - 1]]; //æœ€åä¸€ä¸ªå­—ç¬¦æ²¡æœ‰åé¢ä¸€ä¸ªï¼Œä¸è®ºå¦‚ä½•ï¼Œéƒ½åŠ ä¸Šå®ƒçš„å€¼ return ans; }}; 14. æœ€é•¿å…¬å…±å‰ç¼€ç¬¬ä¸€æ¬¡ACä»£ç æ€è·¯ æ‰¾åˆ°æœ€çŸ­çš„å­—ç¬¦ä¸² ä»1å¼€å§‹æˆªå–å­—ç¬¦ä¸²ï¼Œè·Ÿå…¶ä»–å­—ç¬¦ä¸²çš„å‰ç¼€æ¯”è¾ƒï¼Œç›´åˆ°å‡ºç°å‰ç¼€ä¸åŒ 1234567891011121314151617181920212223242526272829303132static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { string ans; for (int i = 0; i &lt; minlen(strs); i++) { bool find = false; char cmp = strs[0][i]; for (int j = 0; j &lt; strs.size(); j++) { if (cmp != strs[j][i]) { find = true; break; } } if (!find) ans.append(1, cmp); else break; } return ans; } int minlen(vector&lt;string&gt;&amp; strs) { if (strs.size() == 0) return 0; int min = strs[0].length(); for (int i = 1; i &lt; strs.size(); i++) { if (strs[i].length() &lt; min) min = strs[i].length(); } return min; }}; çœ‹äº†é¢˜è§£ååˆ©ç”¨äºŒåˆ†æŸ¥æ‰¾æ³•çš„ACä»£ç ï¼ˆEdition 1ï¼‰æ€è·¯ æ‰¾åˆ°æœ€çŸ­çš„å­—ç¬¦ä¸²çš„ä¸‹æ ‡ æŠŠæœ€çŸ­çš„å­—ç¬¦ä¸²ä¸€åˆ†ä¸ºäºŒï¼Œè‡ªå·±å˜æˆå‰åŠæ®µï¼ŒååŠæ®µå­˜åœ¨å¦ä¸€ä¸ªstringé‡Œé¢ æ¯”è¾ƒä¸€æ¬¡ï¼Œå¦‚æœå‰ç¼€éƒ½ç›¸åŒï¼ŒæŠŠå³åŠè¾¹ä¸€åˆ†ä¸ºäºŒï¼Œæ‹¼æ¥åˆ°å·¦åŠåŠï¼Œå³åŠåŠå˜æˆè‡ªå·±çš„å³åŠåŠã€‚ ä¸€æ¬¡æ¯”è¾ƒå®Œæˆå å¦‚æœå‰ç¼€éƒ½ç›¸åŒï¼Œä¸”ååŠåŠåªå‰©ä¸€ä¸ªå­—ç¬¦äº†ï¼ŒæŠŠè¿™ä¸ªå­—ç¬¦æ‹¼è¿‡å»å†æŸ¥ä¸€æ¬¡ï¼Œæœ‰é—®é¢˜å°±æ¢å¤ï¼Œæ²¡é—®é¢˜ä¿ç•™ï¼Œè¿”å›æ­¤æ—¶çš„å·¦åŠåŠï¼›å¦‚æœå‰ç¼€ å¦‚æœå‰ç¼€ä¸åŒï¼Œå·¦åŠåŠåªå‰©ä¸‹ä¸€ä¸ªå­—ç¬¦äº†ï¼Œåœ¨æ¯”è¾ƒä¸€æ¬¡ï¼Œçœ‹çœ‹è¿™ä¸ªå­—ç¬¦æ˜¯ä¸æ˜¯å…¬å…±å‰ç¼€ï¼Œæ˜¯å°±è¿”å›ï¼Œå¦åˆ™è¿”å›ç©ºä¸²ï¼ˆæ²¡æœ‰å…¬å…±å‰ç¼€ï¼‰ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { if (strs.size() == 1) return strs[0]; if (!strs.size()) return &quot;&quot;; int min = IndexOfMinLen(strs); if (!strs[min].length()) return &quot;&quot;; string sub = strs[min].substr(0, strs[min].length() / 2); string right = strs[min].substr(strs[min].length() / 2, strs[min].length() - strs[min].length() / 2); while (1){ bool find = false; for (int i = 0; i &lt; strs.size(); i++) { if (strs[i].substr(0, sub.length()) != sub) { find = true; } } if (find) { if (sub.length() == 1) { for (int i = 0; i &lt; strs.size(); i++) { if (strs[i].substr(0, sub.length()) != sub) { find = true; } } if (find) { sub = &quot;&quot;; } break; } right = sub.substr(sub.length() / 2, sub.length() - sub.length()/2); sub = sub.substr(0, sub.length()/2); } else { if (right.length() == 1) { for (int i = 0; i &lt; strs.size(); i++) { if (strs[i].substr(0, sub.length()+1) != sub + right) { find = true; } } if (!find) { sub += right; } break; } sub.append(right.substr(0, right.length()/2)); right = right.substr(right.length() / 2, right.length() - right.length()/2); } } return sub; } int IndexOfMinLen(vector&lt;string&gt;&amp; strs) { int min = strs[0].length(); int pos = 0; for (int i = 1; i &lt; strs.size(); i++) { if (strs[i].length() &lt; min) { min = strs[i].length(); pos = i; } } return pos; }}; æ ¹æ®é¢˜è§£å†™çš„ç®€åŒ–ç‰ˆäºŒåˆ†æŸ¥æ‰¾ï¼ˆEdition 2ï¼‰æ€è·¯ æ¯æ¬¡æˆªå–ä¸€åŠï¼Œéå†æ¯”è¾ƒ å¦‚æœå‰ç¼€ç›¸åŒï¼ŒæŠŠè¾¹ç•Œå³ç§»ä¸€åŠ å¦‚æœå‰ç¼€ä¸åŒï¼ŒæŠŠè¾¹ç•Œå‰ç§»ä¸€åŠ 123456789101112131415161718192021222324252627282930313233343536373839404142434445static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { if (strs.size() == 1) return strs[0]; if (!strs.size()) return &quot;&quot;; int min = IndexOfMinLen(strs); if (!strs[min].length()) return &quot;&quot;; int len = strs[min].length(); int left = 1, right = strs[min].length(); string sub; while (left &lt;= right){ int mid = (left + right) / 2; sub = strs[min].substr(0, mid); bool find = false; for (int i = 0; i &lt; strs.size(); i++) { if (strs[i].substr(0, sub.length()) != sub) { find = true; } } if (find) { right = mid - 1; } else { left = mid + 1; } } sub = strs[min].substr(0, (left + right) / 2); return sub; } int IndexOfMinLen(vector&lt;string&gt;&amp; strs) { int min = strs[0].length(); int pos = 0; for (int i = 1; i &lt; strs.size(); i++) { if (strs[i].length() &lt; min) { min = strs[i].length(); pos = i; } } return pos; }};","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%931/"},{"title":"LeetCode-23","text":"1144. é€’å‡å…ƒç´ ä½¿æ•°ç»„å‘ˆé”¯é½¿çŠ¶1234567891011121314151617181920212223242526272829303132class Solution {public: int movesToMakeZigzag(vector&lt;int&gt;&amp; nums) { int odd2less, even2less; odd2less = even2less = 0; int n = nums.size(); if(n &lt;= 1) return 0; for(int i = 1; i &lt; n - 1; i++) { if(i%2 == 0) { if(nums[i] &gt;= min(nums[i-1], nums[i+1])) { even2less += nums[i] - min(nums[i-1], nums[i+1]) + 1; } } else { if(nums[i] &gt;= min(nums[i-1], nums[i+1])) { odd2less += nums[i] - min(nums[i-1], nums[i+1]) + 1; } } } if(nums[0] &gt;= nums[1]) { even2less += nums[0] - nums[1] + 1; } if(nums[n-1] &gt;= nums[n-2]) { if((n-1)%2 == 0) { even2less += nums[n-1] - nums[n-2] + 1; } else { odd2less += nums[n-1] - nums[n-2] + 1; } } return min(even2less, odd2less); }}; éå†æ‰€æœ‰å¥‡æ•°ï¼Œä½¿å…¶å°äºä¸¤ç«¯ï¼Œè®°å½•æ“ä½œæ•°1éå†æ‰€æœ‰å¶æ•°ï¼Œä½¿å…¶å°äºä¸¤ç«¯ï¼Œè®°å½•æ“ä½œæ•°2è¿”å›æœ€å°å€¼ ä¼˜åŒ–ä»£ç è¡Œæ•°123456789101112131415161718class Solution {public: int movesToMakeZigzag(vector&lt;int&gt;&amp; nums) { int op[2] = {0}, n = nums.size(); if(n &lt;= 1) return 0; for(int i = 1; i &lt; n - 1; i++) { if(nums[i] &gt;= min(nums[i-1], nums[i+1])) op[i&amp;1] += nums[i] - min(nums[i-1], nums[i+1]) + 1; } if(nums[0] &gt;= nums[1]) { op[0] += nums[0] - nums[1] + 1; } if(nums[n-1] &gt;= nums[n-2]) { op[(n-1)&amp;1] += nums[n-1] - nums[n-2] + 1; } return min(op[0], op[1]); }}; 2325. è§£å¯†æ¶ˆæ¯1234567891011121314151617class Solution {public: string decodeMessage(string key, string message) { vector&lt;int&gt; alphabet = vector&lt;int&gt;(26, -1); int klen = key.length(), slen = message.length(), index = 0; for(int i = 0; i &lt; klen &amp;&amp; index &lt; 26; i++) { if(isalpha(key[i]) &amp;&amp; alphabet[key[i] - 'a'] == -1) { alphabet[key[i] - 'a'] = 'a' + index++; } } for(int i = 0; i &lt; slen; i++) { if(isalpha(message[i])) message[i] = alphabet[message[i] - 'a']; } return message; }}; 2319. åˆ¤æ–­çŸ©é˜µæ˜¯å¦æ˜¯ä¸€ä¸ª X çŸ©é˜µ12345678910111213141516class Solution {public: bool checkXMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if((i - j == 0 || i + j == n - 1)) { if(grid[i][j] == 0) return false; } else { if(grid[i][j] != 0) return false; } } } return true; }}; ä¸»å¯¹è§’çº¿ï¼Œå‰¯å¯¹è§’çº¿ä¸Šçš„å…ƒç´ ä¸èƒ½æ˜¯0ï¼Œå…¶ä»–å¿…é¡»æ˜¯0ä¸»å¯¹è§’çº¿ä¸Šçš„ç‚¹æ»¡è¶³ $ i - j == 0 $ï¼Œ å‰¯å¯¹è§’çº¿ä¸Šæ»¡è¶³ $ i + j == n-1 $ 1669. åˆå¹¶ä¸¤ä¸ªé“¾è¡¨1234567891011121314151617181920class Solution {public: ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) { int i = 0; ListNode *dummy = new ListNode(0, list1), *x, *y, *move; for(move = dummy; i &lt;= b; move = move-&gt;next, i++) { if(i == a) { x = move; } if(i == b) { y = move-&gt;next; } } x-&gt;next = list2; move = list2; while(move-&gt;next != nullptr) move = move-&gt;next; move-&gt;next = y-&gt;next; return dummy-&gt;next; }}; ä¼˜åŒ–12345678910111213class Solution {public: ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) { int i = 0; ListNode *x, *y; for(x = list1; i &lt; a-1; x = x-&gt;next, i++); for(y = x; i &lt; b; y = y-&gt;next, i++); x-&gt;next = list2; while(list2-&gt;next != nullptr) list2 = list2-&gt;next; list2-&gt;next = y-&gt;next; return list1; }}; é¢˜ç›®ä¸­ a, bçš„èŒƒå›´æ˜¯ $ 1 &lt;= a &lt;= b &lt; list1.length - 1 $ï¼Œç¬¬ä¸€ä¸ªèŠ‚ç‚¹ä¸éœ€è¦è¢«åˆ é™¤ï¼Œæ‰€ä»¥dummyèŠ‚ç‚¹æ˜¯å¤šä½™çš„å°†å¯»æ‰¾aï¼Œbçš„forå¾ªç¯æ‹†æˆä¸¤å—ï¼Œå‡å°‘ifè·³è½¬æŒ‡ä»¤çš„æ‰§è¡Œæ¬¡æ•°moveèŠ‚ç‚¹ä¹Ÿæ˜¯å¤šä½™çš„ 2315. ç»Ÿè®¡æ˜Ÿå·1234567891011121314class Solution {public: int countAsterisks(string s) { int len = s.length(); int count = 0; for(int i = 0; i &lt; len; i++) { for(;i &lt; len &amp;&amp; s[i] != '|'; i++) { if(s[i] == '*') count++; } for(i++; i &lt; len &amp;&amp; s[i] != '|'; i++); } return count; }}; 1664. ç”Ÿæˆå¹³è¡¡æ•°ç»„çš„æ–¹æ¡ˆæ•°123456789101112131415161718192021222324252627282930class Solution {public: int waysToMakeFair(vector&lt;int&gt;&amp; nums) { int n = nums.size(), ret = 0; if(n &lt;= 1) return n; int len = n; if(n % 2 == 1) { nums.push_back(0); n++; } vector&lt;int&gt; preSum(n + 2); for(int i = 0; i &lt; n; i++) { preSum[i+2] = preSum[i] + nums[i]; } for(int i = 0; i &lt; len; i++) { int odd = 0, even = 0; if(i%2 == 0) { even = preSum[n-1 + 2] - preSum[i+2-1] + preSum[i + 2 -2]; odd = preSum[n-2 + 2] - preSum[i + 2] + preSum[i+2 - 1]; } else { even = preSum[n-1+2] - preSum[i+2] + preSum[i+2 -1]; odd = preSum[n-2+2] - preSum[i+2+1-2] + preSum[i+2-2]; } if(even == odd) { ret++; } } return ret; }}; åˆ†å¥‡æ•°ä¸‹æ ‡å’Œå¶æ•°ä¸‹æ ‡è®¡ç®—å‰ç¼€å’Œå½“æŸä¸ªå€¼è¢«åˆ é™¤æ—¶ï¼Œå…¶åæ–¹å¥‡æ•°ä¸‹æ ‡è¾¹å¶æ•°ä¸‹æ ‡ï¼Œå¶æ•°ä¸‹æ ‡è¾¹å¥‡æ•°ä¸‹æ ‡ï¼Œå‰æ–¹åˆ™ä¸å˜ã€‚å‡è®¾åˆ é™¤æŸä¸ªæ•°ï¼Œè®¡ç®—å˜åŒ–åçš„å¥‡å¶ä¸‹æ ‡ä¹‹å’Œï¼Œå¦‚æœç›¸ç­‰ï¼Œåˆ™æ–¹æ¡ˆæ•°+1ä¸ºäº†æ–¹ä¾¿ä»£ç ç¼–å†™ï¼Œå¦‚æœnæ˜¯å¥‡æ•°ï¼Œåˆ™æ·»åŠ ä¸€ä¸ª0ä¿è¯å…¶ä¸ºå¶æ•°ï¼Œä½†æ³¨æ„åˆ é™¤æ·»åŠ çš„è¿™ä¸ªæ•°ä½¿å¾—å¹³è¡¡å¹¶ä¸ç®—æœ‰æ•ˆæ–¹æ¡ˆ ç©ºé—´ä¼˜åŒ–123456789101112131415161718192021222324252627282930class Solution {public: int waysToMakeFair(vector&lt;int&gt;&amp; nums) { int n = nums.size(), ret = 0; if(n &lt;= 1) return n; int odd1, even1, odd2, even2; odd1 = even1 = odd2 = even2 = 0; for(int i = 0; i &lt; n; i++) { if(i&amp;1) { odd2+=nums[i]; } else { even2+=nums[i]; } } for(int i = 0; i &lt; n; i++) { if(i&amp;1) { odd2-=nums[i]; } else { even2-=nums[i]; } if(odd2 + even1 == odd1 + even2) ret++; if(i&amp;1) { odd1+=nums[i]; } else { even1+=nums[i]; } } return ret; }}; odd2,even2è¡¨ç¤ºä½ç½®iè¢«åˆ é™¤åï¼Œè¢«åˆ é™¤å…ƒç´ åæ–¹çš„å¥‡æ•°ä¸‹æ ‡å’Œå’Œå¶æ•°ä¸‹æ ‡å’Œï¼ˆç›¸å¯¹äºæœªæ”¹å˜å‰çš„ï¼‰odd1,even1è¡¨ç¤ºä½ç½®iè¢«åˆ é™¤åï¼Œè¢«åˆ é™¤å…ƒç´ å‰æ–¹çš„å¥‡æ•°ä¸‹æ ‡å’Œå’Œå¶æ•°ä¸‹æ ‡å’Œå‡è®¾åˆ é™¤iï¼Œå°±ä»odd2æˆ–even2ä¸­åˆ é™¤ç”±äºå˜åŒ–åå¥‡æ•°ä¸‹æ ‡å˜å¶æ•°ï¼Œå¶æ•°å˜å¥‡æ•°ï¼Œåˆ™æ¯”è¾ƒ $(odd2 + even1 == odd1 + even2)$æ˜¯å¦æˆç«‹æ¯”è¾ƒåï¼Œå°†iåŠ å›odd1æˆ–even1 2309. å…¼å…·å¤§å°å†™çš„æœ€å¥½è‹±æ–‡å­—æ¯12345678910111213141516171819202122class Solution {public: string greatestLetter(string s) { vector&lt;bool&gt; upper(26, false),lower(26, false); char maxx = -1; for(char c : s) { if(c &gt;= 'A' &amp;&amp; c &lt;= 'Z') { upper[c - 'A'] = true; if(lower[c-'A'] &amp;&amp; c-'A' &gt; maxx) { maxx = c - 'A'; } } if(c &gt;= 'a' &amp;&amp; c &lt;= 'z') { lower[c - 'a'] = true; if(upper[c-'a'] &amp;&amp; c-'a' &gt; maxx) { maxx = c-'a'; } } } return maxx &gt;= 0 ? string(1, maxx + 'A') : &quot;&quot;; }}; 2363. åˆå¹¶ç›¸ä¼¼çš„ç‰©å“123456789101112131415161718class Solution {public: vector&lt;vector&lt;int&gt;&gt; mergeSimilarItems(vector&lt;vector&lt;int&gt;&gt;&amp; items1, vector&lt;vector&lt;int&gt;&gt;&amp; items2) { map&lt;int, int&gt; m; for(auto&amp; v : items1) { m[v[0]] += v[1]; } for(auto&amp; v : items2) { m[v[0]] += v[1]; } vector&lt;vector&lt;int&gt;&gt; ret; for(auto ite = m.begin(); ite != m.end(); ite++) { auto&amp; [x, y] = *ite; ret.push_back({x, y}); } return ret; }}; 1234567891011121314151617181920212223242526272829303132333435class Solution {public: vector&lt;vector&lt;int&gt;&gt; mergeSimilarItems(vector&lt;vector&lt;int&gt;&gt;&amp; items1, vector&lt;vector&lt;int&gt;&gt;&amp; items2) { sort(items1.begin(), items1.end(), [](vector&lt;int&gt;&amp; x, vector&lt;int&gt;&amp; y)-&gt;bool{return x[0] &lt; y[0];}); sort(items2.begin(), items2.end(), [](vector&lt;int&gt;&amp; x, vector&lt;int&gt;&amp; y)-&gt;bool{return x[0] &lt; y[0];}); int i = 0, j = 0, value = min(items1[0][0], items2[0][0]); int n1 = items1.size(), n2 = items2.size(); vector&lt;vector&lt;int&gt;&gt; ret{{value, 0}}; int retSize = 0; while(i &lt; n1 &amp;&amp; j &lt; n2) { while(i &lt; n1 &amp;&amp; items1[i][0] == value) { ret[retSize][1] += items1[i][1]; i++; } while(j &lt; n2 &amp;&amp; items2[j][0] == value) { ret[retSize][1] += items2[j][1]; j++; } if(i &lt; n1 &amp;&amp; j &lt; n2) { value = min(items1[i][0], items2[j][0]); ret.push_back({value, 0}); retSize++; } } while(i &lt; n1) { ret.push_back({items1[i][0], items1[i][1]}); i++; } while(j &lt; n2) { ret.push_back({items2[j][0], items2[j][1]}); j++; } return ret; }}; 2373. çŸ©é˜µä¸­çš„å±€éƒ¨æœ€å¤§å€¼12345678910111213class Solution {public: vector&lt;vector&lt;int&gt;&gt; largestLocal(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); vector&lt;vector&lt;int&gt;&gt; ret = vector&lt;vector&lt;int&gt;&gt;(n-2, vector&lt;int&gt;(n-2, 0)); for(int i = 1; i &lt; n-1; i++) { for(int j = 1; j &lt; n-1; j++) { ret[i-1][j-1] = max(grid[i][j], max(max(max(grid[i-1][j], grid[i+1][j]),max(grid[i][j-1], grid[i][j+1])),max(max(grid[i+1][j+1], grid[i-1][j-1]),max(grid[i-1][j+1], grid[i+1][j-1])))); } } return ret; }}; 1828. ç»Ÿè®¡ä¸€ä¸ªåœ†ä¸­ç‚¹çš„æ•°ç›®æš´åŠ›123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; countPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, vector&lt;vector&lt;int&gt;&gt;&amp; queries) { vector&lt;vector&lt;int&gt;&gt; xy = vector&lt;vector&lt;int&gt;&gt;(501, vector&lt;int&gt;(501, 0)); for(auto&amp; p: points) { xy[p[0]][p[1]]++; } int n = queries.size(); vector&lt;int&gt; ret(n, 0); for(int i = 0; i &lt;= 500; i++) { for(int j = 0; j &lt;= 500; j++) { if(xy[i][j] &gt; 0) { for(int k = 0; k &lt; n; k++) { int x = queries[k][0], y = queries[k][1], r = queries[k][2]; if((i - x)*(i - x) + (j - y)*(j - y) &lt;= r*r) { ret[k] += xy[i][j]; } } } } } return ret; }}; æ³¨æ„ä¸åŒç‚¹å¯èƒ½æœ‰ç›¸åŒçš„åæ ‡ æ›´æš´åŠ›123456789101112131415class Solution {public: vector&lt;int&gt; countPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, vector&lt;vector&lt;int&gt;&gt;&amp; queries) { int m = points.size(), n = queries.size(); vector&lt;int&gt; ret = vector&lt;int&gt;(n, 0); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { if ((queries[i][0] - points[j][0]) * (queries[i][0] - points[j][0]) + (queries[i][1] - points[j][1]) * (queries[i][1] - points[j][1]) &lt;= queries[i][2] * queries[i][2]) { ret[i]++; } } } return ret; }}; é¢è¯•é¢˜ 05.02. äºŒè¿›åˆ¶æ•°è½¬å­—ç¬¦ä¸²ä¹˜2æ³•1234567891011121314class Solution {public: string printBin(double num) { int count = 0; string res = &quot;0.&quot;; for(; count &lt; 30 &amp;&amp; num &gt; 0; count++) { num *= 2; int bit = num; res.push_back(bit+'0'); num -= bit; } return count &lt; 30 ? res : &quot;ERROR&quot;; }}; ieee 754123456789101112131415161718192021class Solution {public: string printBin(double num) { long long int *bit = (long long int *)&amp;num; string res = string(64, '\\0'); int i = 63; for(; ((*bit)&amp;1)==0; i--, (*bit) &gt;&gt;= 1); int last = i; for(; i &gt; 11; i--) { res[i - 12] += ((*bit)&amp;1) + '0'; (*bit) &gt;&gt;= 1; } int e = ((*bit) &amp; 0x7ff) - 1023; string pre = &quot;0.&quot;; if(e &lt; -1) { pre += string(-e-1,'0'); } pre += &quot;1&quot;; return last-12 &lt; 32-3-(-e-1) ? pre+res : &quot;ERROR&quot;; }}; åˆ†åˆ«è®¡ç®—æµ®ç‚¹æ•°çš„å°¾æ•°ï¼Œé˜¶ç ï¼Œåœ¨åˆ¤æ–­èƒ½å¦ç”¨32ä½ä¿å­˜ä¸‹æ¥","link":"/home/2023/02/27/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9323/"},{"title":"LeetCode-27","text":"[Medium] 29. ä¸¤æ•°ç›¸é™¤åˆ†æ åªèƒ½ç”¨åŠ å‡æ³•ï¼Œæœ€æœ´ç´ çš„æ–¹æ³•æ˜¯å¾ªç¯ç›¸å‡/åŠ ï¼Œç›´åˆ°å°äº0/å¤§äº0ï¼Œè®¡ç®—åŠ /å‡çš„æ¬¡æ•° è¿™æ ·ç®—æ³•æ˜¯o(n)ï¼Œè€ƒè™‘åˆ°i+=iæˆ–è€…i&lt;&lt;=1ç›¸å½“äºi*=2,i&gt;&gt;=1ç›¸å½“äºi/=2 åªè€ƒè™‘divisor, dividentéƒ½å¤§äº0çš„æƒ…å†µï¼Œå…ˆæ‰¾åˆ°æ•´æ•°pï¼Œä½¿å¾— $divisor2^p &lt;= divident$ï¼Œ$divident-=divisor2^p, ratio+=2^p$è‹¥dividentä¸º0ï¼Œåˆ™å•†ä¸ºratioï¼Œå¦åˆ™é‡å¤ä¸Šé¢çš„è¿‡ç¨‹ï¼Œç›´åˆ°dividentä¸º0ã€‚ è€ƒè™‘divisor, dividentåˆ°å¯èƒ½æ­£ï¼Œå¯èƒ½è´Ÿï¼Œè€Œè´Ÿæ•°çš„èŒƒå›´å¤§äºæ­£æ•°ï¼Œç›´æ¥å°†æ‰€æœ‰æ•´æ•°å˜æˆè´Ÿæ•°ï¼Œå¹¶è®°å½•ç¬¦å· æ³¨æ„å–ç›¸åæ•°çš„æ—¶å€™è¦ç”¨ä½è¿ç®—~x+1 ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940class Solution {public: int divide(int dividend, int divisor) { if(dividend &lt; divisor &amp;&amp; dividend &gt; 0) return 0; if(dividend &gt; divisor &amp;&amp; dividend &lt; 0) return 0; if((dividend == INT_MIN) &amp;&amp; (divisor == -1)) return INT_MAX; if((dividend == INT_MIN) &amp;&amp; (divisor == 1)) return INT_MIN; if(dividend == divisor) return 1; if(dividend &lt; 0 &amp;&amp; divisor &gt; 0 &amp;&amp; dividend == ~divisor+1) return -1; if(dividend &gt; 0 &amp;&amp; divisor &lt; 0 &amp;&amp; ~dividend+1 == divisor) return -1; bool sign = false; if(dividend &lt; 0) { sign = !sign; } else { dividend = ~dividend+1; } if(divisor &lt; 0) { sign = !sign; } else { divisor = ~divisor+1; } int res = 0; int i = -1; while(dividend &lt; divisor &amp;&amp; divisor &gt;= (INT_MIN &gt;&gt; 1)) { divisor += divisor; i+=i; } while(true) { while(dividend &gt; divisor) { if(i == -1) { return sign ? (res) : (~res+1); } divisor &gt;&gt;= 1; i&gt;&gt;=1; } dividend -= divisor; res+=i; } }}; 275. H æŒ‡æ•° IIä»£ç 12345678910111213141516171819class Solution {public: int hIndex(vector&lt;int&gt;&amp; citations) { int n = citations.size(); int l = 0, r = n-1; int res = 0; while(l &lt; r) { int mid = (r - l) / 2 + l; if(n - mid &lt;= citations[mid]) { res = max(res, n-mid); r=mid-1; } else { res = max(res, citations[mid]); l = mid+1; } } return max(res, min(citations[l], n-l)); }}; ä¼˜åŒ–1234567891011121314151617class Solution {public: int hIndex(vector&lt;int&gt;&amp; citations) { int n = citations.size(); int l = 0, r = n-1; int res = 0; while(l &lt;= r) { int mid = (r - l) / 2 + l; if(n - mid &lt;= citations[mid]) { r=mid - 1; } else { l = mid+1; } } return n-l; }}; 274. H æŒ‡æ•°ä»£ç 12345678910111213141516171819class Solution {public: int hIndex(vector&lt;int&gt;&amp; citations) { int arr[1001] = {0}; int max_cite = 0; int min_cite = INT_MAX; for(int n : citations) { arr[n]++; max_cite = max(max_cite, n); min_cite = min(min_cite, n); } int sum = 0, res = 0; for(int i = max_cite; i &gt;= min_cite; i--) { sum += arr[i]; res = max(res, min(sum, i)); } return res; }}; 2558. ä»æ•°é‡æœ€å¤šçš„å †å–èµ°ç¤¼ç‰©12345678910111213141516171819class Solution {public: long long pickGifts(vector&lt;int&gt;&amp; gifts, int k) { priority_queue&lt;int&gt; gift_heap; for(int n : gifts) { gift_heap.push(n); } long long res = 0; while(k--) { gift_heap.push(sqrt(gift_heap.top())); gift_heap.pop(); } while(!gift_heap.empty()) { res += gift_heap.top(); gift_heap.pop(); } return res; }}; 1465. åˆ‡å‰²åé¢ç§¯æœ€å¤§çš„è›‹ç³•123456789101112131415161718class Solution {public: int maxArea(int h, int w, vector&lt;int&gt;&amp; horizontalCuts, vector&lt;int&gt;&amp; verticalCuts) { int h_len = horizontalCuts.size(); int v_len = verticalCuts.size(); sort(verticalCuts.begin(), verticalCuts.end()); sort(horizontalCuts.begin(), horizontalCuts.end()); int max_h = max(h - horizontalCuts.back(), horizontalCuts.front()); int max_v = max(w - verticalCuts.back(), verticalCuts.front()); for(int i = 1; i &lt; h_len; i++) { max_h = max(max_h, horizontalCuts[i] - horizontalCuts[i-1]); } for(int i = 1; i &lt; v_len; i++) { max_v = max(max_v, verticalCuts[i] - verticalCuts[i-1]); } return ((long long)(max_h)%1000000007 * (max_v)%1000000007) % 1000000007; }}; 2520. ç»Ÿè®¡èƒ½æ•´é™¤æ•°å­—çš„ä½æ•°1234567891011121314class Solution {public: int countDigits(int num) { int n = num; int ret = 0; while(n) { if(num % (n % 10) == 0) { ret++; } n /= 10; } return ret; }}; 2698. æ±‚ä¸€ä¸ªæ•´æ•°çš„æƒ©ç½šæ•°æ€è·¯ é¦–å…ˆè¦è®¡ç®—å‡ºæ‰€æœ‰æ»¡è¶³sum(split(i*i)) == içš„å…ƒç´  å‘ç°å¾ˆå°‘ï¼Œç›´æ¥æ”¾åˆ°æ•°ç»„é‡Œå»æŸ¥è¡¨ å¯¹äºä¸€ä¸ªæ•°iï¼Œå¸Œæœ›å®ƒæ‹†åˆ†åå’Œç­‰äºtarget å…ˆåˆ†æˆaï¼Œbä¸¤ä»½ï¼Œåˆ¤æ–­æ˜¯å¦ç­‰äºï¼Œç­‰äºreturn trueï¼Œä¸ç­‰äºå°±æŠŠaåˆ†å¼€ï¼ˆé€’å½’ï¼‰ ä»£ç 123456789101112131415161718192021222324252627282930313233343536class Solution {public: int punishmentNumber(int n) { int res = 0; // for(int i = 1; i &lt;= 1000; i++) { // int n = i*i; // if(search(i*i, i)) { // cout &lt;&lt; i &lt;&lt; &quot;, &quot;; // } // } int punish_arr[] = {1, 9, 10, 36, 45, 55, 82, 91, 99, 100, 235, 297, 369, 370, 379, 414, 657, 675, 703, 756, 792, 909, 918, 945, 964, 990, 991, 999, 1000}; int len = sizeof(punish_arr)/sizeof(int); for(int i = 0; i &lt; len; i++) { if(n &gt;= punish_arr[i]) res += punish_arr[i]*punish_arr[i]; } return res; } bool search(int i, int target) { int n = i; int base = 1; int r = 0; while(n) { r += base*(n%10); if(r+n/10 == target) { return true; } else { if(search(n/10, target - r)){ return true; } } n /= 10; base *= 10; } return false; }}; 1155. æ·éª°å­ç­‰äºç›®æ ‡å’Œçš„æ–¹æ³•æ•°æ€è·¯ å…ˆæš´åŠ›é€’å½’ï¼Œç„¶åå‘ç°å¯ä»¥æ€»ç»“å‡ºdpå…¬å¼ï¼Œç„¶åæŠŠé€’å½’æ”¹æˆdpå°è¯•ï¼ŒæˆåŠŸäº† ä»£ç 123456789101112131415161718192021222324252627class Solution {public: vector&lt;vector&lt;int&gt;&gt; dp; int numRollsToTarget(int n, int k, int target) { dp = vector&lt;vector&lt;int&gt;&gt;(30+1, vector&lt;int&gt;(1000+1, 0)); dp[0][0] = 1; for(int i = 1; i &lt;= n; i++) { for(int t = 1; t &lt;= target; t++) for(int K = 1;K &lt;= k; K++) if(t &gt;= K) dp[i][t] = (dp[i][t] + dp[i-1][t-K]) % 1000000007; } return dp[n][target]; } int search(int n, int k, int target) { if(target == 0 &amp;&amp; n == 0) { return 1; } else if(n == 0) return 0; int res = 0; for(int i = 1; i &lt;= k; i++) { if(target &gt;= i) { res += numRollsToTarget(n-1, k, target-i); } } return res; }}; ä¼˜åŒ–è§‚å¯Ÿä»£ç å¯çŸ¥ï¼Œdp[i][t]å°±æ˜¯dp[i-1][t-1]+â€¦dp[i-1][t-k]ï¼Œå¯ä»¥ç”¨å‰ç¼€å’Œä¼˜åŒ– 1234567891011121314151617class Solution {public: vector&lt;vector&lt;int&gt;&gt; dp; int numRollsToTarget(int n, int k, int target) { dp = vector&lt;vector&lt;int&gt;&gt;(30+1, vector&lt;int&gt;(1000+1,0)); dp[0][0] = 1; for(int i = 1; i &lt;= n; i++) { for(int t = 1; t &lt;= target; t++) { dp[i][t] = (dp[i][t-1] + dp[i-1][t-1]) % 1000000007; } for(int t = target; t &gt;= k; t--) { dp[i][t] = (dp[i][t] - dp[i][t-k] + 1000000007) % 1000000007; } } return dp[n][target]; }}; 1402. åšèœé¡ºåº ä¸€çœ¼dpï¼Œé‰´å®šä¸ºï¼Œçº¯çº¯çš„ç®€å•é¢˜ ä¸€éå°±åšå¯¹å•¦å“ˆå“ˆå“ˆ1234567891011121314151617181920212223class Solution {public: int maxSatisfaction(vector&lt;int&gt;&amp; satisfaction) { int n = satisfaction.size(); vector&lt;int&gt; dp(n+1, 0); vector&lt;int&gt; sums(n+1, 0); sums[0] = accumulate(satisfaction.begin(), satisfaction.end(), 0); sort(satisfaction.begin(), satisfaction.end(), less&lt;int&gt;()); for(int i = 0; i &lt; n; i++) { dp[0] += (i+1) * satisfaction[i]; } for(int i = 1; i &lt;= n; i++) { if(dp[i-1] &lt; dp[i-1] - sums[i-1]) { dp[i] = dp[i-1] - sums[i-1]; sums[i] = sums[i-1] - satisfaction[i-1]; } else { dp[i] = dp[i-1]; sums[i] = sums[i-1]; } } return dp[n]; }}; ä¼˜åŒ–dpæ•°ç»„å’Œsumæ•°ç»„å¯ä»¥ä¼˜åŒ–æ‰ 1234567891011121314151617181920class Solution {public: int maxSatisfaction(vector&lt;int&gt;&amp; satisfaction) { int n = satisfaction.size(); int dp = 0; int sums = 0; sort(satisfaction.begin(), satisfaction.end()); for(int i = 0; i &lt; n; i++) { dp += (i+1) * satisfaction[i]; sums += satisfaction[i]; } for(int i = 1; i &lt;= n; i++) { if(dp &lt; dp - sums) { dp = dp - sums; sums = sums - satisfaction[i-1]; } } return dp; }}; 2678. è€äººçš„æ•°ç›®12345678910class Solution {public: int countSeniors(vector&lt;string&gt;&amp; details) { int res = 0; for(const string &amp;laodeng : details) { if((laodeng[11] == '6' &amp;&amp; laodeng[12] &gt; '0') || (laodeng[11] &gt; '6' &amp;&amp; laodeng[12] &gt;= '0')) res++; } return res; }}; 2316. ç»Ÿè®¡æ— å‘å›¾ä¸­æ— æ³•äº’ç›¸åˆ°è¾¾ç‚¹å¯¹æ•°123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;vector&lt;int&gt;&gt; g; vector&lt;bool&gt; visited; long long countPairs(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) { g = move(vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;())); visited = move(vector&lt;bool&gt;(n, false)); for(const vector&lt;int&gt;&amp; edge : edges) { g[edge[0]].push_back(edge[1]); g[edge[1]].push_back(edge[0]); } long long res = 0; for(int i = 0; i &lt; n; i++) { if(!visited[i]) { long long node_num = count_nodes(i); res += (n - node_num) * node_num; } } return res &gt;&gt; 1; } int count_nodes(int root) { visited[root] = true; int res = 1; for(int child : g[root]) { if(!visited[child]) res += count_nodes(child); } return res; }}; å¹¶æŸ¥é›† è¿™é‡Œä¸€ç›´å†™ä¸å‡ºæ¥ï¼Œå‘ç°å¹¶æŸ¥é›†æ— æ³•æŠŠæ‰€æœ‰ç›¸è¿çš„ç‚¹å½’åˆ°ä¸€ä¸ªé›†åˆä¸­ï¼Œå› ä¸ºåœ¨éå†çš„æ—¶å€™æ²¡æœ‰ç”¨unionæ“ä½œ123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; s; int find(int x) { return x == s[x] ? x : (s[x] = find(s[x])); } long long countPairs(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) { s = move(vector&lt;int&gt;(n, 0)); vector&lt;int&gt; cnt = move(vector&lt;int&gt;(n, 0)); iota(s.begin(), s.end(), 0); size_t elen = edges.size(); for(int j = 0; j &lt; elen; j++) { s[find(edges[j][1])] = find(edges[j][0]); } for(int i = 0; i &lt; n; i++) { cnt[find(i)]++; } long long res = 0; for(int i = 0; i &lt; n; i++) { res += (n - (long long)cnt[i])*cnt[i]; } return res &gt;&gt; 1; }}; ç»§ç»­ä¼˜åŒ– æ¢ä¸ªå…¬å¼å‡å°‘ä¸€æ¬¡å¾ªç¯123456789101112131415161718192021class Solution {public: vector&lt;int&gt; s; int find(int x) { return x == s[x] ? x : (s[x] = find(s[x])); } long long countPairs(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) { s = move(vector&lt;int&gt;(n, 0)); vector&lt;int&gt; cnt = move(vector&lt;int&gt;(n, 0)); iota(s.begin(), s.end(), 0); size_t elen = edges.size(); for(int j = 0; j &lt; elen; j++) { s[find(edges[j][1])] = find(edges[j][0]); } long long res = 0; for(int i = 0; i &lt; n; i++) { res += cnt[find(i)]++; } return (long long)n*(n-1)/2 - res; }}; 2525. æ ¹æ®è§„åˆ™å°†ç®±å­åˆ†ç±»1234567891011class Solution {public: string categorizeBox(int length, int width, int height, int mass) { bool bulky = length &gt;= 10000 || height &gt;= 10000 || width &gt;= 10000 || (long long)length*width*height &gt;= 1000000000; bool heavy = mass &gt;= 100; if(bulky &amp;&amp; heavy) return &quot;Both&quot;; else if(!bulky &amp;&amp; !heavy) return &quot;Neither&quot;; else if(bulky &amp;&amp; !heavy) return &quot;Bulky&quot;; else return &quot;Heavy&quot;; }}; 117. å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ IIæ€è·¯ é¦–å…ˆæƒ³åˆ°çš„å°±æ˜¯å±‚æ¬¡éå†ï¼Œéå¸¸ç®€å• å¯¹äºè¿›é˜¶ä½¿ç”¨O(1)ç©ºé—´çš„ç®—æ³•ï¼Œä¸€ç›´æ²¡æƒ³åˆ°åˆ©ç”¨å·²æœ‰çš„nextæŒ‡é’ˆ æ ‘æ¯å±‚æœ€å·¦ä¾§èŠ‚ç‚¹æ‰¾parentï¼ŒæŠŠåŒå±‚éƒ½è¿èµ·æ¥å°±å¥½123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution {public: Node* levelConnect(Node* root) { queue&lt;Node *&gt; q; if(root) q.push(root); while(!q.empty()) { Node *node = nullptr; int n = q.size(); while(n--) { if(node) node-&gt;next = q.front(); node = q.front(); if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); q.pop(); } } return root; } Node* connect(Node* root) { // return levelConnect(root); if(root) recursiveConnect(root, new Node(0, root, nullptr, nullptr), true); return root; } void recursiveConnect(Node* root, Node *parent, bool isLeft) { Node *move = root; while(move &amp;&amp; !move-&gt;next) { Node *to = nullptr; if(isLeft &amp;&amp; parent-&gt;right) { to = parent-&gt;right; isLeft = false; } else { Node *pMove = parent-&gt;next; while(pMove &amp;&amp; !pMove-&gt;left &amp;&amp; !pMove-&gt;right) pMove = pMove-&gt;next; if(pMove) { if(pMove-&gt;left) { isLeft = true; to = pMove-&gt;left; } else if(pMove-&gt;right) { isLeft = false; to = pMove-&gt;right; } parent = pMove; } } move-&gt;next = to; move = to; } if(root-&gt;right) recursiveConnect(root-&gt;right, root, false); if(root-&gt;left) recursiveConnect(root-&gt;left, root, true); }}; æ•´ç†ä¸‹ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {public: Node* levelConnect(Node* root) { queue&lt;Node *&gt; q; if(root) q.push(root); while(!q.empty()) { Node *node = nullptr; int n = q.size(); while(n--) { if(node) node-&gt;next = q.front(); node = q.front(); if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); q.pop(); } } return root; } Node* connect(Node* root) { // return levelConnect(root); if(root) recursiveConnect(root, new Node(0, root, nullptr, nullptr)); return root; } void recursiveConnect(Node* root, Node *parent) { Node *move = root; while(move &amp;&amp; !move-&gt;next) { Node *to = nullptr; if(move != parent-&gt;left || !parent-&gt;right) { parent = parent-&gt;next; } Node *pMove = parent; while(pMove &amp;&amp; !pMove-&gt;left &amp;&amp; !pMove-&gt;right) pMove = pMove-&gt;next; to = pMove ? (pMove-&gt;left == move ? pMove-&gt;right : pMove-&gt;left ? pMove-&gt;left : pMove-&gt;right) : nullptr; // ä½ å°±çŒœå§ï¼Œä¸€çŒœä¸€ä¸ªä¸å±å£° parent = pMove; move-&gt;next = to; move = to; } if(root-&gt;right) recursiveConnect(root-&gt;right, root); if(root-&gt;left) recursiveConnect(root-&gt;left, root); }}; 2127. å‚åŠ ä¼šè®®çš„æœ€å¤šå‘˜å·¥æ•°å¹¶æŸ¥é›† ä¸€ä¸ªé‡è¦ç»“è®ºï¼Œå›¾ä¸­ä¸€å®šæœ‰ç¯ï¼ˆnä¸ªèŠ‚ç‚¹ï¼Œå¤§äºn-1æ¡è¾¹ï¼‰ å¦‚æœç¯çš„å¤§å°å¤§äº2ï¼Œåˆ™åªèƒ½å°†ç¯ä¸Šçš„èŠ‚ç‚¹ä¸Šæ¡Œï¼Œæ”¯é“¾ä¸Šçš„ç‚¹æ— æ³•ä¸Šæ¡Œ å¦‚æœç¯çš„å¤§å°ä¸å¤§äº2ï¼Œåˆ™ç¯ä¸ŠèŠ‚ç‚¹çš„æœ€é•¿æ”¯é“¾ä¹Ÿå¯ä»¥è·Ÿç€ä¸Šæ¡Œ å¤šä¸ªç¯é•¿ä¸º2çš„å­å›¾ï¼ˆä¸è®ºæ˜¯å¦æœ‰æ”¯é“¾ï¼‰ï¼Œéƒ½å¯ä»¥å…¨éƒ¨ä¸Šæ¡Œ æ•…ï¼Œç»Ÿè®¡æ‰€æœ‰ç¯é•¿å¤§äº2çš„æœ€å¤§ç¯é•¿ï¼Œä¸ºmaxRingç»Ÿè®¡æ‰€æœ‰ç¯é•¿ä¸å¤§äº2çš„ç¯é•¿ä¹‹å’Œï¼Œä»¥åŠç¯ä¸Šå„èŠ‚ç‚¹çš„æœ€å¤§ä¹‹é“¾é•¿åº¦ä¹‹å’Œï¼Œä¸ºmaxNumberè¿”å›max(maxRing, maxNumber) æ­¥éª¤ å¹¶æŸ¥é›†å°†èŠ‚ç‚¹åˆ†ç±» degreeç»Ÿè®¡æ¯ä¸ªèŠ‚ç‚¹çš„å…¥åº¦ dSetSizeç»Ÿè®¡æ¯ä¸ªé›†åˆçš„å¤§å° æŒ‰ç…§æ˜¯å¦å­˜åœ¨å…¥åº¦ä¸º0çš„ç‚¹ï¼Œå°†å­å›¾åˆ’åˆ†ä¸¤ç±» å­˜åœ¨ï¼Œåˆ™å›¾å«æœ‰æ”¯é“¾ï¼Œè®¡ç®—ç¯çš„é•¿åº¦(findMaxRing) å¤§äº2ï¼Œç»Ÿè®¡æœ€å¤§ç¯é•¿ï¼ˆmaxRingï¼‰ ä¸å¤§äº2ï¼Œä»ä»»æ„åº¦ä¸º0çš„èŠ‚ç‚¹å¼€å§‹éå†ï¼Œå°†ç¯ä¸ŠèŠ‚ç‚¹çš„visitedå˜æˆé0ï¼Œå¹¶æ ‡è®°è¯¥å­å›¾ä¸ºis2ï¼Œç´¯åŠ maxNumberï¼ˆç¯é•¿ä¸º2ï¼Œéƒ½å¯ä»¥ä¸Šæ¡Œï¼‰ ä¸å­˜åœ¨ï¼Œåˆ™å›¾ä¸å«æœ‰æ”¯é“¾ï¼Œè®¡ç®—ç¯çš„é•¿åº¦(findMaxRing) å¤§äº2ï¼Œç»Ÿè®¡æœ€å¤§ç¯é•¿ï¼ˆmaxRingï¼‰ ä¸å¤§äº2ï¼Œç´¯åŠ å¦‚maxNumberï¼ˆç¯é•¿ä¸º2ï¼Œéƒ½å¯ä»¥ä¸Šæ¡Œï¼‰ å¯¹æ‰€æœ‰å…¥åº¦ä¸º0ï¼Œä¸”æ‰€åœ¨å­å›¾æ˜¯is2çš„èŠ‚ç‚¹ï¼Œè®¡ç®—è¯¥ç‚¹åˆ°ç¯ä¸Šç‚¹çš„è·ç¦»ä¸ºæ”¯é“¾é•¿åº¦ï¼Œè®°å½•æœ€å¤§æ”¯é“¾é•¿åº¦ æ‰€æœ‰æœ€å¤§æ”¯é“¾é•¿åº¦ç´¯åŠ maxNumber è¿”å›max(maxNumber, maxRing) æ—¶é—´ 1848 ms å‡»è´¥ 5.2%å†…å­˜ 98.4 MB å‡»è´¥ 35.8% 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697class Solution {public: int maxRing = 0; vector&lt;int&gt; visited; vector&lt;int&gt; addtional_len; vector&lt;int&gt; dSet; vector&lt;bool&gt; dSetVisited; vector&lt;int&gt; dSetSize; vector&lt;bool&gt; isRing; vector&lt;bool&gt; is2; vector&lt;int&gt; degree; int find(int i) { return i == dSet[i] ? i : (dSet[i] = find(dSet[i])); } int maximumInvitations(vector&lt;int&gt;&amp; favorite) { int n = favorite.size(); visited = move(vector&lt;int&gt;(n, 0)); dSetVisited = move(vector&lt;bool&gt;(n, false)); isRing = move(vector&lt;bool&gt;(n, true)); is2 = move(vector&lt;bool&gt;(n, false)); addtional_len = move(vector&lt;int&gt;(n, 0)); degree = move(vector&lt;int&gt;(n, 0)); dSet = move(vector&lt;int&gt;(n, 0)); iota(dSet.begin(), dSet.end(), 0); dSetSize = move(vector&lt;int&gt;(n, 0)); for(int i = 0; i &lt; n; i++) { degree[favorite[i]]++; dSet[find(i)] = find(favorite[i]); } for(int i = 0; i &lt; n; i++) { dSetSize[find(i)]++; if(degree[i] == 0) isRing[dSet[i]] = false; } int maxNumber = 0; for(int i = 0; i &lt; n; i++) { int len = 1; int ringNode = -1; if(isRing[dSet[i]]) { if(!dSetVisited[dSet[i]]) { dSetVisited[dSet[i]] = true; int ring = dSetSize[dSet[i]]++; if(ring &gt; 2) { maxRing = max(maxRing, ring); } else { maxNumber += ring; } } } else { if(!dSetVisited[dSet[i]] &amp;&amp; degree[i] == 0) { dSetVisited[dSet[i]] = true; int ring = findMaxRing(favorite, i, len, ringNode); if(ring &gt; 2) { maxRing = max(maxRing, ring); } else { // addtional_len[ringNode] = max(len - ring, addtional_len[ringNode]); int move = i; while(move != ringNode) { visited[move] = false; move = favorite[move]; } is2[dSet[i]] = true; maxNumber += ring; } } } } for(int i = 0; i &lt; n; i++) { if(is2[dSet[i]] &amp;&amp; degree[i] == 0) { int move = i; int len = 0; while(!visited[move]) { len++; move = favorite[move]; } addtional_len[move] = max(addtional_len[move], len); } } for(int i = 0; i &lt; n; i++) { // cout &lt;&lt; i &lt;&lt; &quot;, &quot; &lt;&lt; addtional_len[i] &lt;&lt; endl; if(addtional_len[i] &gt; 0) { maxNumber += addtional_len[i]; } } return max(maxNumber, maxRing); } int findMaxRing(const vector&lt;int&gt;&amp; favorite, int node, int &amp;len, int &amp;ringNode) { visited[node] = len; int child = favorite[node]; if(visited[child]) { ringNode = child; return len - visited[child] + 1; } len++; return findMaxRing(favorite, child, len, ringNode); }}; ä¼˜åŒ– ä¸Šé¢çš„ä»£ç åœ¨é‡åˆ°æœ‰å…¬å…±éƒ¨åˆ†çš„æ”¯é“¾ï¼Œï¼ˆä¼šåˆ†å‰çš„æ”¯é“¾æ—¶ï¼‰ï¼Œä¼šå¯¼è‡´é‡å éƒ¨åˆ†åå¤è¢«è®¿é—® ä½¿ç”¨arcFavç»Ÿè®¡è¢«å–œæ¬¢å›¾ï¼Œæ ¹æ®è¢«å–œæ¬¢å›¾ä»ç¯ä¸Šå¼€å§‹å¯»æ‰¾æœ€å¤§æ”¯é“¾ï¼Œå¯ä»¥é¿å…ï¼Œé€Ÿåº¦ä¹Ÿå¾—åˆ°äº†æå¤§çš„ä¼˜åŒ– æ—¶é—´ 284ms å‡»è´¥ 12.78% ä½¿ç”¨ C++ çš„ç”¨æˆ·å†…å­˜ 166.84MB å‡»è´¥ 25.57% ä½¿ç”¨ C++ çš„ç”¨æˆ· 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899class Solution {public: int maxRing = 0; vector&lt;int&gt; visited; vector&lt;int&gt; addtional_len; vector&lt;vector&lt;int&gt;&gt; arcFav; vector&lt;int&gt; dSet; vector&lt;bool&gt; dSetVisited; vector&lt;int&gt; dSetSize; vector&lt;bool&gt; isRing; vector&lt;int&gt; degree; int find(int i) { return i == dSet[i] ? i : (dSet[i] = find(dSet[i])); } int maximumInvitations(vector&lt;int&gt;&amp; favorite) { int n = favorite.size(); visited = move(vector&lt;int&gt;(n, 0)); arcFav = move(vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;())); dSetVisited = move(vector&lt;bool&gt;(n, false)); isRing = move(vector&lt;bool&gt;(n, true)); addtional_len = move(vector&lt;int&gt;(n, 0)); degree = move(vector&lt;int&gt;(n, 0)); dSet = move(vector&lt;int&gt;(n, 0)); iota(dSet.begin(), dSet.end(), 0); dSetSize = move(vector&lt;int&gt;(n, 0)); for(int i = 0; i &lt; n; i++) { degree[favorite[i]]++; dSet[find(i)] = find(favorite[i]); arcFav[favorite[i]].push_back(i); } for(int i = 0; i &lt; n; i++) { dSetSize[find(i)]++; if(degree[i] == 0) isRing[dSet[i]] = false; } int maxNumber = 0; for(int i = 0; i &lt; n; i++) { int len = 1; int ringNode = -1; if(isRing[dSet[i]]) { if(!dSetVisited[dSet[i]]) { dSetVisited[dSet[i]] = true; int ring = dSetSize[dSet[i]]++; if(ring &gt; 2) { maxRing = max(maxRing, ring); } else { maxNumber += ring; } } } else { if(!dSetVisited[dSet[i]] &amp;&amp; degree[i] == 0) { dSetVisited[dSet[i]] = true; int ring = findMaxRing(favorite, i, len, ringNode); if(ring &gt; 2) { maxRing = max(maxRing, ring); } else { int move = i; while(move != ringNode) { visited[move] = 0; move = favorite[move]; } addtional_len[ringNode] = searchArcFav(ringNode); move = favorite[ringNode]; while(move != ringNode) { addtional_len[move] = searchArcFav(move); move = favorite[move]; } maxNumber += ring; } } } } for(int i = 0; i &lt; n; i++) { if(addtional_len[i] &gt; 0) { maxNumber += addtional_len[i]; } } return max(maxNumber, maxRing); } int searchArcFav(int move) { visited[move] = 1; int ret = 0; for(int child : arcFav[move]) { if(!visited[child]) { ret = max(searchArcFav(child)+1, ret); } } return ret; } int findMaxRing(const vector&lt;int&gt;&amp; favorite, int node, int &amp;len, int &amp;ringNode) { visited[node] = len; int child = favorite[node]; if(visited[child]) { ringNode = child; return len - visited[child] + 1; } len++; return findMaxRing(favorite, child, len, ringNode); }}; å¹¶æŸ¥é›†+æ‹“æ‰‘æ’åº123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Solution {public: int maxRing = 0; vector&lt;int&gt; visited; vector&lt;int&gt; addtional_len; vector&lt;vector&lt;int&gt;&gt; arcFav; vector&lt;int&gt; dSet; vector&lt;int&gt; degree; int find(int i) { return i == dSet[i] ? i : (dSet[i] = find(dSet[i])); } int maximumInvitations(vector&lt;int&gt;&amp; favorite) { int n = favorite.size(); visited = move(vector&lt;int&gt;(n, 0)); arcFav = move(vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;())); addtional_len = move(vector&lt;int&gt;(n, 0)); degree = move(vector&lt;int&gt;(n, 0)); dSet = move(vector&lt;int&gt;(n, 0)); iota(dSet.begin(), dSet.end(), 0); vector&lt;int&gt; ringNodes; unordered_map&lt;int, int&gt; ringSize; for(int i = 0; i &lt; n; i++) { degree[favorite[i]]++; dSet[find(i)] = find(favorite[i]); arcFav[favorite[i]].push_back(i); } queue&lt;int&gt; topologyQueue; for(int i = 0; i &lt; n; i++) { if(degree[i] == 0) { topologyQueue.push(i); } } while(!topologyQueue.empty()) { int front = topologyQueue.front(); topologyQueue.pop(); if((--degree[favorite[front]]) == 0) { topologyQueue.push(favorite[front]); } } unordered_set&lt;int&gt; ring2set; for(int i = 0; i &lt; n; i++) { if(degree[i] &gt; 0) { ringNodes.push_back(i); ringSize[find(i)]++; } } for(int i = 0; i &lt; n; i++) { if(ringSize[find(i)] &lt;= 2) { ring2set.insert(find(i)); } } int maxNumber = 0; for(int ringNode : ringNodes) { int ring = ringSize[dSet[ringNode]]; if(ring &gt; 2) { maxRing = max(maxRing, ring); } else { addtional_len[ringNode] = searchArcFav(ringNode); } } for(int i = 0; i &lt; n; i++) { if(addtional_len[i] &gt; 0) { maxNumber += addtional_len[i]; // add ring number } } return max(maxNumber + (ring2set.size() &lt;&lt; 1), (size_t)maxRing); } int searchArcFav(int move) { visited[move] = 1; // åˆ¤æ–­ï¼Œ not in ring int ret = 0; for(int child : arcFav[move]) { if(!visited[child] &amp;&amp; degree[child] == 0) { ret = max(searchArcFav(child)+1, ret); } } return ret; }}; æ›´æ…¢äº†ï¼ŒåŸå› æ˜¯ä¸èƒ½åœ¨æ‹“æ‰‘æ’åºçš„åŒæ—¶è®¡ç®—æœ€å¤§æ”¯é“¾é•¿åº¦ ä¼˜åŒ–æ‰å¹¶æŸ¥é›† åœ¨æ‹“æ‰‘æ’åºä¸­å¯»æ‰¾æœ€é•¿æ”¯é“¾ï¼Œä¸ºæ¯ä¸ªèŠ‚ç‚¹å®šä¹‰f(x) $ f(x) = max_{i=0}^j(f(aFav(x)_i) + 1) $ æ¯ä¸ªèŠ‚ç‚¹åˆå§‹ä¸º0ï¼Œæ‹“æ‰‘æ’åºæ—¶ï¼Œæ¯æ¬¡iå°†jçš„degreeè¢«å‡å°ï¼Œå…¶å€¼ä¸ºmax(f(i)+1, f(j))1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution {public: int maxRing = 0; vector&lt;bool&gt; visited; vector&lt;int&gt; degree; vector&lt;int&gt; f; int maximumInvitations(vector&lt;int&gt;&amp; favorite) { int n = favorite.size(); visited = move(vector&lt;bool&gt;(n, false)); degree = move(vector&lt;int&gt;(n, 0)); f = move(vector&lt;int&gt;(n, 0)); vector&lt;int&gt; ringNodes; unordered_map&lt;int, int&gt; ringSize; for(int i = 0; i &lt; n; i++) { degree[favorite[i]]++; } queue&lt;int&gt; topologyQueue; for(int i = 0; i &lt; n; i++) { if(degree[i] == 0) { topologyQueue.push(i); } } while(!topologyQueue.empty()) { int front = topologyQueue.front(); topologyQueue.pop(); f[favorite[front]] = max(f[favorite[front]], f[front] + 1); visited[front] = true; if((--degree[favorite[front]]) == 0) { topologyQueue.push(favorite[front]); } } int maxNumber = 0; for(int i = 0; i &lt; n; i++) { if(!visited[i]) if(favorite[favorite[i]] == i) { maxNumber += f[i] + 1; } else { int ring = 1; int move = favorite[i]; while(!visited[move] &amp;&amp; move != i) { visited[move] = true; move = favorite[move]; ring++; } maxRing = max(maxRing, ring); } } return max(maxNumber, maxRing); }};","link":"/home/2023/10/28/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9327/"},{"title":"LeetCode-3","text":"58. æœ€åä¸€ä¸ªå•è¯çš„é•¿åº¦ACä»£ç 1234567891011class Solution {public: int lengthOfLastWord(string s) { reverse(s.begin(), s.end()); stringstream ss(s); string buf; ss &gt;&gt; buf; reverse(buf.begin(), buf.end()); return buf.length(); }}; 1234567891011class Solution {public: int lengthOfLastWord(string s) { int count = 0; for (int i = s.length() -1 ; i &gt;= 0; i--) { if (s[i] != ' ')count++; else if (count &gt; 0) break; } return count; }}; 66. åŠ ä¸€æ€è·¯å†™ä¸€ä¸ªæ¨¡æ‹ŸåŠ æ³•çš„ç®—æ³•å°±å¯ä»¥ã€‚å‡è®¾åŠ 0ï¼Œç¬¬ä¸€æ¬¡carryï¼ˆè¿›ä½ï¼‰ä¸º1 ACä»£ç 1234567891011121314151617181920static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) { int carry = 1; int i = digits.size(); while (i &amp;&amp; carry) { int t = digits[i-1] + carry; digits[i-1] = t%10; carry = t/10; i--; } if (carry) digits.insert(digits.begin(), carry); return digits; }}; 67. äºŒè¿›åˆ¶æ±‚å’ŒACä»£ç 123456789101112131415161718class Solution {public: string addBinary(string a, string b) { if (a.length() &gt; b.length()) { b.insert(0, a.length() - b.length(), '0'); } else if (a.length() &lt; b.length()){ a.insert(0, b.length() - a.length(), '0'); } int carry = 0; for (int i = a.length() - 1; i &gt;= 0; i--) { int n = a[i] + b[i] + carry - '0'*2; a[i] = n % 2 + '0'; carry = n/2; } if (carry) a.insert(0, 1, carry + '0'); return a; }}; 69. x çš„å¹³æ–¹æ ¹ACä»£ç 123456class Solution {public: int mySqrt(int x) { return sqrt(x); }}; æ€è·¯æš´åŠ›æ±‚è§£ 12345678910111213141516171819class Solution {public: int mySqrt(int x) { if (x &lt;= 0) return 0; long long cmp = 0; long long i = 0; while (cmp &lt;= x) { i++; cmp = i*i; if (i &gt; INT_MAX) { i = INT_MIN; } if (i &lt; INT_MIN) { i = INT_MAX; } } return i - 1; }}; æ€è·¯ç‰›é¡¿è¿­ä»£æ³•xn+1 = xn - f(xn) / fâ€™(xn); ACä»£ç 12345678910111213141516171819class Solution {public: double fx(double x,double n) { return x*x - n; } double dfxdx(double x) { return 2*x; } int mySqrt(int n) { double x = 0.01; double exp = 0.01; double temp = 1; while (fabs(x - temp) &gt; exp) { temp = x; x = x - fx(x, n)/dfxdx(x); } return x; }}; 88. åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„æ€è·¯éå†nums2ï¼Œå¯¹äºæ¯ä¸€ä¸ªå…ƒç´ ï¼ŒæŸ¥æ‰¾æ¯”å®ƒå¤§çš„å…ƒç´ ï¼Œæ’å…¥ ACä»£ç 12345678910111213class Solution {public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { int count = 0; for (int i = 0, j = 0; i &lt; nums2.size(); i++) { while (j &lt; m &amp;&amp; nums2[i] &gt; nums1[j])j++; nums1.insert(nums1.begin() + j, nums2[i]); count++; m++; } nums1.erase(nums1.end() - count, nums1.end()); }}; æ€è·¯ä¸‰ä¸ªæŒ‡é’ˆaï¼Œbï¼Œcï¼Œåˆ†åˆ«æŒ‡å‘m+n-1,m-1,n-1 aå¼€å§‹å‘å‰éå†ï¼Œæ¯”è¾ƒå¦å¤–ä¸¤ä¸ªæŒ‡é’ˆçš„å€¼ï¼ŒæŠŠè¾ƒå¤§çš„é‚£ä¸ªèµ‹å€¼ç»™aï¼Œç„¶åè¾ƒå¤§çš„æŒ‡é’ˆå‰ç§» ACä»£ç 12345678910111213141516171819202122232425262728class Solution {public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { if (!m) { for (int i = 0; i &lt; n; i++) { nums1[i] = nums2[i]; } return; } if (!n) return; int i = n + m - 1, j = m - 1, k = n - 1; while (j &gt;= 0 &amp;&amp; k &gt;= 0) { nums1[i--] = nums1[j] &gt; nums2[k] ? nums1[j--] : nums2[k--]; } if (j != - 1) { while (j &gt;= 0) { nums1[i--] = nums1[j--]; } } if (k != - 1) { while (k &gt;= 0) { nums1[i--] = nums2[k--]; } } }}; 100. ç›¸åŒçš„æ ‘çœŸæ²¡æƒ³åˆ°ä»æ¥æ²¡æ¥è§¦è¿‡æ ‘çš„æˆ‘å±…ç„¶ä¸€éè¿‡äº† æ€è·¯æ·±åº¦ä¼˜å…ˆéå†ï¼Œå…ˆé€’å½’è°ƒç”¨ï¼Œè®¿é—®æ‰€æœ‰èŠ‚ç‚¹ é‡åˆ°ç»“æŸæ—¶ï¼Œä¸ºnullï¼Œåˆ™æ¯”è¾ƒä¸¤ä¸ªæ˜¯ä¸æ˜¯éƒ½æ˜¯nullï¼Œå¦‚æœä¸æ˜¯ï¼Œè¯´æ˜æ ‘çš„å½¢çŠ¶ä¸ä¸€æ · å¶å­èŠ‚ç‚¹è¿”å›åï¼Œæ¯”è¾ƒä¸Šä¸€èŠ‚ç‚¹çš„å€¼ï¼Œç›¸åŒè¿”å›trueï¼Œæœ€åè¾¾åˆ°å‡½æ•°ç»“å°¾çš„ä¸€å¾‹è¿”å›falseï¼ˆå€¼ä¸ä¸€æ ·æˆ–è€…å½¢çŠ¶ä¸ä¸€æ ·ï¼‰ ACä»£ç 123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool isSameTree(TreeNode* p, TreeNode* q) { if (p == NULL || q == NULL) return q == p; if (isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right)) { if (p-&gt;val == q-&gt;val) { return true; } } return false; }}; 21. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨æ€è·¯è·Ÿ88. åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„çš„æ€è·¯æ˜¯ä¸€æ ·æ ·çš„ï¼Œä¸è¿‡ç”±äºç”¨æŒ‡é’ˆï¼Œæ‰€ä»¥æœ€åå¤„ç†æœ«å°¾æ•°æ®çš„æ—¶å€™ï¼Œå¯ä»¥ç›´æ¥æŠŠå¤šå‡ºæ¥çš„ä¸€æˆªèµ‹å€¼ç»™ä¸Šä¸€ä¸ªèŠ‚ç‚¹çš„next ACä»£ç 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode *head, *temp, *temp1; if (l1 == NULL) return l2; if (l2 == NULL) return l1; temp = head = new ListNode(0); while (l2 != NULL &amp;&amp; l1 != NULL) { if (l1-&gt;val &gt; l2-&gt;val) { temp-&gt;next = l2; l2 = l2-&gt;next; } else { temp-&gt;next = l1; l1 = l1-&gt;next; } temp = temp-&gt;next; } if (l1 != NULL) { temp-&gt;next = l1; } if (l2 != NULL) { temp-&gt;next = l2; } return head-&gt;next; }}; 118. æ¨è¾‰ä¸‰è§’å¤§ä¸€å¿…ä¼šé¢˜ï¼Œä½†æ˜¯é¢˜è§£é‡Œè¯´è¿™ä¸ªä¹Ÿå±äºåŠ¨æ€è§„åˆ’ ACä»£ç 12345678910111213141516171819class Solution {public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) { vector&lt;vector&lt;int&gt;&gt; ans; for (int i = 0; i &lt; numRows; i++) { vector&lt;int&gt; line; for (int j = 0; j &lt; i + 1; j++) { if (j == 0 || j == i) { line.push_back(1); } else { line.push_back(ans[i-1][j] + ans[i-1][j-1]); } } ans.push_back(line); line.clear(); } return ans; }}; 119. æ¨è¾‰ä¸‰è§’ IIæ€è·¯ï¼ˆç©ºé—´å¤æ‚åº¦ä¸ºO(K)ï¼‰çš„ç®—æ³•åˆ©ç”¨ç»„åˆæ•°çš„å¯¹ç§°æ€§ 12345678910111213141516171819class Solution {public: vector&lt;int&gt; getRow(int rowIndex) { vector&lt;int&gt; ans(rowIndex + 1); for (int i = 0; i &lt; rowIndex+1; i++) { for (int j = 0; j &lt; i / 2 + 1; j++) { if (j == 0) { ans[j] = 1; } else { ans[j] = ans[j] + ans[i - j]; } } for (int j = i / 2 + 1; j &lt; i + 1; j++) { ans[i - (j - (i/2+1))] = ans[j - (i/2+1)]; } } return ans; }}; 121. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºæ€è·¯ç”»å‡ºå”®ä»·çš„æ—¶é—´ - ä»·æ ¼å›¾ï¼Œå…³æ³¨æ³¢å³°å’Œæ³¢è°·å¦‚æœç°åœ¨çš„å€¼å°äºå½“å‰çš„æœ€å°å€¼ï¼Œåˆ™æŠŠå½“å‰å€¼ä½œä¸ºæœ€å°å€¼ï¼Œå¦‚æœå¤§äºæœ€å°å€¼ï¼Œé‚£ä¹ˆè®¡ç®—å½“å‰å€¼ä¸æœ€å°å€¼çš„å·®ï¼Œå¦‚æœå¤§äºå½“å‰åˆ©æ¶¦ï¼Œåˆ™ä½œä¸ºæœ€æ–°åˆ©æ¶¦ã€‚ ACä»£ç 1234567891011121314class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int min = INT_MAX; int profit = 0; for (int i = 0; i &lt; prices.size(); i++) { if (prices[i] &lt; min) min = prices[i]; else if (profit &lt; prices[i] - min) profit = prices[i] - min; } return profit; }}; 122. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº IIæ€è·¯æ‰¾ç›¸é‚»æ³¢å³°å’Œæ³¢è°·ï¼Œæ³¢è°·ä¹°å…¥ï¼Œæ³¢å³°å”®å‡ºå¤§å¾ªç¯éå†æ•°ç»„ï¼Œå†…å±‚ç¬¬ä¸€ä¸ªå¾ªç¯æ‰¾æ³¢è°·ï¼Œä¸‹ä¸€ä¸ªå¾ªç¯æ‰¾æ³¢å³°ç„¶åæ³¢å³°æ³¢è°·ç›¸å‡ï¼ŒåŠ åˆ°profitä¸Š 1234567891011121314151617class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { if (!prices.size()) return 0; int i = 0, peak, valley, profit = 0; for (; i &lt; prices.size() - 1; ) { while (i &lt; prices.size() - 1 &amp;&amp; prices[i] &gt;= prices[i + 1]) i++; valley = prices[i]; while (i &lt; prices.size() - 1 &amp;&amp; prices[i] &lt;= prices[i + 1]) i++; peak = prices[i]; profit += peak - valley; } return profit; }}; 136. åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—æ€è·¯åˆ©ç”¨å¼‚æˆ–è¿ç®—çš„æ€§è´¨ï¼ˆåŒä¸º0ï¼Œä¸åŒä¸º1ï¼‰ ACä»£ç 12345678910class Solution {public: int singleNumber(vector&lt;int&gt;&amp; nums) { int n = 0; for (auto num : nums) { n ^= num; } return n; }}; 125. éªŒè¯å›æ–‡ä¸²æ€è·¯æŠŠæ˜¯å­—ç¬¦çš„å­˜èµ·æ¥ï¼Œç„¶åå¤åˆ¶åè½¬ä¸€ä»½ï¼Œç„¶åæ¯”è¾ƒ ACä»£ç 1234567891011121314class Solution {public: bool isPalindrome(string s) { string temp, cmp; for(int i = 0; i &lt; s.length(); i++) { if(isalpha(s[i]) || isdigit(s[i])) { temp += tolower(s[i]); cmp += tolower(s[i]); } } reverse(cmp.begin(), cmp.end()); return cmp == temp; }}; 141. ç¯å½¢é“¾è¡¨å“ˆå¸Œè¡¨12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: bool hasCycle(ListNode *head) { map&lt;ListNode*, int&gt; m; ListNode* temp = head; while (temp != NULL) { if (m[temp] &gt;= 2) { return true; } m[temp]++; temp = temp-&gt;next; } return false;}; æ€è·¯åŒæŒ‡é’ˆä¸€ä¸ªæŒ‡é’ˆä¸€æ¬¡åç§»ä¸€ä¸ªï¼Œä¸€ä¸ªæŒ‡é’ˆåç§»ä¸¤æ¬¡ï¼Œå¦‚æœå¿«çš„é‚£ä¸ªå…ˆåˆ°ç»ˆç‚¹ï¼Œè¯´æ˜æ²¡æœ‰ç¯ï¼Œå¦‚æœå¿«çš„è¿½ä¸Šï¼Œæ…¢çš„ï¼Œè¯´æ˜ä¸€å®šæœ‰ç¯ 1234567891011121314151617class Solution {public: bool hasCycle(ListNode *head) { ListNode *slow, *fast; slow = fast = head; while (slow != NULL) { slow = slow-&gt;next; if (fast != NULL &amp;&amp; fast-&gt;next != NULL) fast = fast-&gt;next-&gt;next; else break; if (slow == fast) { return true; } } return false; }}; 155. æœ€å°æ ˆACä»£ç 12345678910111213141516171819202122232425262728293031323334353637class MinStack {public: /** initialize your data structure here. */ vector&lt;int&gt; data; multiset&lt;int&gt; min; MinStack() { } void push(int x) { data.push_back(x); min.insert(x); } void pop() { min.erase(find(min.begin(), min.end(), *(data.end() - 1))); data.erase(data.end() - 1); } int top() { return *(data.end() - 1); return 0; } int getMin() { return *(min.begin()); return 0; }};/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ ACä»£ç 12345678910111213141516171819202122232425262728293031class MinStack {public: stack&lt;int&gt; data; stack&lt;int&gt; min; MinStack() { } void push(int x) { data.push(x); if (min.empty() || x &lt;= min.top()) {//è¦ç­‰å· min.push(x); } } void pop() { int p = data.top(); data.pop(); if (p == min.top()) { min.pop(); } } int top() { return data.top(); } int getMin() { return min.top(); }}; 160. ç›¸äº¤é“¾è¡¨æ€è·¯åŒæŒ‡é’ˆ ä¸¤ä¸ªæŒ‡é’ˆï¼Œåˆå§‹åŒ–åˆ†åˆ«æŒ‡å‘é“¾è¡¨Aã€B å¦‚æœä¸¤ä¸ªæŒ‡é’ˆä¸ç›¸ç­‰ï¼Œä¸€ç›´å¾ªç¯ä»¥ä¸‹åŠ¨ä½œ ABæŒ‡é’ˆå„è‡ªå‘åç§»åŠ¨ä¸€æ ¼ å½“æŸä¸€ä¸ªæŒ‡é’ˆåˆ°å¤§æœ«å°¾æ—¶ï¼ŒæŒ‡å‘å¯¹æ–¹é“¾è¡¨çš„å¤´ æœ€åå¾ªç¯é€€å‡ºï¼Œå¦‚æœç»“æœæ˜¯NULLè¡¨ç¤ºæ²¡æœ‰ç›¸äº¤ ACä»£ç 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *l1 = headA, *l2 = headB; while (l1 != l2) { if (l1 != NULL) { l1 = l1-&gt;next; } else { l1 = headB; } if (l2 != NULL) { l2 = l2-&gt;next; } else { l2 = headA; } } return l1; }}; 167. ä¸¤æ•°ä¹‹å’Œ II - è¾“å…¥æœ‰åºæ•°ç»„æ€è·¯åŒæŒ‡é’ˆä¸€ä¸ªæŒ‡å‘å¼€å¤´ï¼Œä¸€ä¸ªæŒ‡å‘ç»“æŸç›¸åŠ å¤§äºtargetï¼Œåé¢çš„å‰ç§»ç›¸åŠ å°äºtargetï¼Œå‰é¢çš„åç§»ç­‰äºï¼Œè¿”å›ä¸‹æ ‡ ACä»£ç 12345678910111213class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) { int i = 0, j = numbers.size() - 1; vector&lt;int&gt; &amp;v = numbers; while (i &lt; j) { if (v[i] + v[j] &gt; target) j--; else if (v[i] + v[j] &lt; target) i++; else return {i + 1, j + 1}; } return {}; }}; 168. Excelè¡¨åˆ—åç§°æ€è·¯é€’å½’ é¦–å…ˆn-- å¦‚æœnåœ¨0 - 25ï¼Œè¿”å›å¯¹åº”å­—æ¯ å¦åˆ™å…ˆè¿”å›n%26çš„å¯¹åº”çš„å­—æ¯ï¼Œå†è¿”å›n/26+1å¯¹åº”çš„å­—æ¯ psï¼šå†™å®Œçœ‹äº†è¯„è®ºæ‰ååº”è¿‡æ¥ï¼Œæ˜¯è½¬æ¢26è¿›åˆ¶çš„é—®é¢˜ï¼Œæ‰‹åŠ¨ç¬‘å“­ ACä»£ç 1234567891011121314class Solution {public: string convertToTitle(int n) { string ans; n--; if (n / 26 &gt; 0) { ans += convertToTitle(n/26); ans += convertToTitle(n%26 + 1); } else { return string(1 ,(char)('A' + n)); } return ans; }};","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%933/"},{"title":"LeetCode-28","text":"[Hard] 715. Range æ¨¡å—æ€è·¯ äºŒåˆ†æŸ¥æ‰¾ ä¸€å¼€å§‹æƒ³çš„æ˜¯ç”¨[left, right)å’Œå…¨éƒ¨åŒºé—´è¿›è¡Œæ¯”è¾ƒæŸ¥æ‰¾ï¼Œä½†æ˜¯è¿™æ ·æ¯”è¾ƒå›°éš¾ï¼Œåœ¨å¤„ç†è¾¹ç•Œåˆå¹¶æƒ…å†µæ—¶ä¼šå˜æˆO(N) ç”¨leftå’Œrightåˆ†åˆ«åœ¨æ‰€æœ‰rangesä¸­æŸ¥æ‰¾ å¯¹äºqueryï¼Œå¦‚æœä¸¤ä¸ªä¸‹æ ‡ç›¸åŒï¼Œåˆ™trueï¼Œå¦åˆ™false å¯¹äºaddï¼ŒæŸ¥æ‰¾left-1å’Œrightçš„ä¸‹æ ‡ï¼Œç„¶åå…¶é—´çš„æ‰€æœ‰rangesåˆ é™¤ï¼Œæ’å…¥æ–°range å¯¹äºremoveï¼ŒæŸ¥æ‰¾leftå’Œright-1çš„ä¸‹æ ‡ï¼Œç„¶åæ ¹æ®ä¸‹æ ‡æŠŠä¹‹é—´çš„åˆ é™¤ï¼Œæ’å…¥å‰©ä½™çš„åŒºé—´ acä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138class RangeModule { vector&lt;pair&lt;int, int&gt;&gt; ranges; int len = 0; int ops = 0; static constexpr bool debug = false; void printRanges() { int size = ranges.size(); cout &lt;&lt; &quot;len = &quot; &lt;&lt; len &lt;&lt; &quot;, size = &quot; &lt;&lt; size &lt;&lt; &quot;\\n&quot;; for(int i = 0; i &lt; size; i++) { cout &lt;&lt; &quot;[&quot; &lt;&lt; ranges[i].first &lt;&lt; &quot;, &quot; &lt;&lt; ranges[i].second &lt;&lt; &quot;]\\n&quot;; } } bool inRange(int n, int index) { return ranges[index].first &lt;= n &amp;&amp; n &lt; ranges[index].second; } bool bigger(int n, int index) { return n &gt;= ranges[index].second; } bool smaller(int n, int index) { return ranges[index].first &gt; n; } int searchRanges(int n) { int l = 0, r = len; while(l &lt; r) { int mid = (r - l) / 2 + l; if(inRange(n, mid)) return mid; else if(bigger(n, mid)) { l = mid + 1; } else { r = mid; } } return l; }public: RangeModule() { } void addRange(int left, int right) { // if(debug) { // ops++; // cout &lt;&lt; &quot;[&quot; &lt;&lt; ops &lt;&lt; &quot;], &quot; &lt;&lt; &quot;addRange&quot; &lt;&lt; &quot;[&quot; &lt;&lt; left &lt;&lt; &quot;, &quot; &lt;&lt; right &lt;&lt; &quot;]&quot; &lt;&lt; &quot;\\n&quot;; // } _addRange(left, right); // if(debug) printRanges(); } void _addRange(int left, int right) { int leftIndex = searchRanges(left-1); int rightIndex = searchRanges(right); // addæ—¶è€ƒè™‘åˆå¹¶ç›¸é‚»çš„é›†åˆï¼Œæ‰€ä»¥æŠŠè¾¹ç•Œæ”¾å®½ // if(leftIndex &gt; 0 &amp;&amp; ranges[leftIndex - 1].second == left) { // leftIndex--; // } // if(rightIndex &lt; len - 1 &amp;&amp; ranges[rightIndex + 1].first == ) // if(debug) cout &lt;&lt; &quot;leftIndex = &quot; &lt;&lt; leftIndex &lt;&lt; &quot;, rightIndex = &quot; &lt;&lt; rightIndex &lt;&lt; &quot;\\n&quot;; if(leftIndex == rightIndex &amp;&amp; leftIndex == len) { } else { left = min(left, ranges[leftIndex].first); if(rightIndex &lt; len) { if(inRange(right, rightIndex)) { right = max(right, ranges[rightIndex].second); rightIndex++; } } ranges.erase(ranges.begin() + leftIndex, ranges.begin() + rightIndex); len -= rightIndex - leftIndex; } ranges.insert(ranges.begin() + leftIndex, make_pair(left, right)); len++; } bool queryRange(int left, int right) { // if(debug) { // ops++; // cout &lt;&lt; &quot;[&quot; &lt;&lt; ops &lt;&lt; &quot;], &quot; &lt;&lt; &quot;queryRange&quot; &lt;&lt; &quot;[&quot; &lt;&lt; left &lt;&lt; &quot;, &quot; &lt;&lt; right &lt;&lt; &quot;]&quot; &lt;&lt; &quot;\\n&quot;; // } bool ret = _queryRange(left, right); // if(debug) cout &lt;&lt; (ret ? &quot;ok&quot; : &quot;not found&quot;) &lt;&lt; &quot;\\n&quot;; // if(debug) printRanges(); return ret; } bool _queryRange(int left, int right) { int leftIndex = searchRanges(left); int rightIndex = searchRanges(right-1); if(leftIndex &gt;= len || rightIndex &gt;= len) return false; return leftIndex == rightIndex &amp;&amp; inRange(left, leftIndex) &amp;&amp; inRange(right-1, rightIndex); } void removeRange(int left, int right) { // if(debug) { // ops++; // cout &lt;&lt; &quot;[&quot; &lt;&lt; ops &lt;&lt; &quot;], &quot; &lt;&lt; &quot;removeRange&quot; &lt;&lt; &quot;[&quot; &lt;&lt; left &lt;&lt; &quot;, &quot; &lt;&lt; right &lt;&lt; &quot;]&quot; &lt;&lt; &quot;\\n&quot;; // } _removeRange(left, right); // if(debug) printRanges(); } void _removeRange(int left, int right) { int leftIndex = searchRanges(left); int rightIndex = searchRanges(right-1); // if(debug) cout &lt;&lt; &quot;leftIndex = &quot; &lt;&lt; leftIndex &lt;&lt; &quot;, rightIndex = &quot; &lt;&lt; rightIndex &lt;&lt; &quot;\\n&quot;; if(leftIndex == rightIndex &amp;&amp; leftIndex == len) { return; } else { int leftLeft = left, rightRight = right; if(inRange(left, leftIndex)) { leftLeft = ranges[leftIndex].first; } if(rightIndex &lt; len) { if(inRange(right-1, rightIndex)) { rightRight = ranges[rightIndex].second; rightIndex++; } } // if(debug) cout &lt;&lt; &quot;leftIndex = &quot; &lt;&lt; leftIndex &lt;&lt; &quot;, rightIndex = &quot; &lt;&lt; rightIndex &lt;&lt; &quot;\\n&quot;; // if(debug) cout &lt;&lt; &quot;leftLeft = &quot; &lt;&lt; leftLeft &lt;&lt; &quot;, rightRight = &quot; &lt;&lt; rightRight &lt;&lt; &quot;\\n&quot;; ranges.erase(ranges.begin() + leftIndex, ranges.begin() + rightIndex); len -= rightIndex - leftIndex; // if(debug) cout &lt;&lt; &quot;len = &quot; &lt;&lt; len &lt;&lt; &quot;\\n&quot;; if(rightRight &gt; right) { len++; ranges.insert(ranges.begin() + leftIndex, make_pair(right, rightRight)); // if(debug) cout &lt;&lt; &quot;add right len = &quot; &lt;&lt; len &lt;&lt; &quot;\\n&quot;; } if(leftLeft &lt; left) { len++; ranges.insert(ranges.begin() + leftIndex, make_pair(leftLeft, left)); // if(debug) cout &lt;&lt; &quot;add left len = &quot; &lt;&lt; len &lt;&lt; &quot;\\n&quot;; } } }};/** * Your RangeModule object will be instantiated and called as such: * RangeModule* obj = new RangeModule(); * obj-&gt;addRange(left,right); * bool param_2 = obj-&gt;queryRange(left,right); * obj-&gt;removeRange(left,right); */ ä¼˜åŒ–ä¸€äº›æƒ…å†µå¯ä»¥åˆ©ç”¨åŸæœ‰çš„rangesï¼Œè€Œæ— éœ€åˆ é™¤ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150class RangeModule { vector&lt;pair&lt;int, int&gt;&gt; ranges; int len = 0; int ops = 0; static constexpr bool debug = false; void printRanges() { int size = ranges.size(); cout &lt;&lt; &quot;len = &quot; &lt;&lt; len &lt;&lt; &quot;, size = &quot; &lt;&lt; size &lt;&lt; &quot;\\n&quot;; for(int i = 0; i &lt; size; i++) { cout &lt;&lt; &quot;[&quot; &lt;&lt; ranges[i].first &lt;&lt; &quot;, &quot; &lt;&lt; ranges[i].second &lt;&lt; &quot;]\\n&quot;; } } bool inRange(int n, int index) { return ranges[index].first &lt;= n &amp;&amp; n &lt; ranges[index].second; } bool bigger(int n, int index) { return n &gt;= ranges[index].second; } bool smaller(int n, int index) { return ranges[index].first &gt; n; } int searchRanges(int n) { int l = 0, r = len; while(l &lt; r) { int mid = (r - l) / 2 + l; if(inRange(n, mid)) return mid; else if(bigger(n, mid)) { l = mid + 1; } else { r = mid; } } return l; }public: RangeModule() { } void addRange(int left, int right) { if(debug) { ops++; cout &lt;&lt; &quot;[&quot; &lt;&lt; ops &lt;&lt; &quot;], &quot; &lt;&lt; &quot;addRange&quot; &lt;&lt; &quot;[&quot; &lt;&lt; left &lt;&lt; &quot;, &quot; &lt;&lt; right &lt;&lt; &quot;]&quot; &lt;&lt; &quot;\\n&quot;; } _addRange(left, right); if(debug) printRanges(); } void _addRange(int left, int right) { int leftIndex = searchRanges(left-1); int rightIndex = searchRanges(right); // addæ—¶è€ƒè™‘åˆå¹¶ç›¸é‚»çš„é›†åˆï¼Œæ‰€ä»¥æŠŠè¾¹ç•Œæ”¾å®½ if(debug) cout &lt;&lt; &quot;leftIndex = &quot; &lt;&lt; leftIndex &lt;&lt; &quot;, rightIndex = &quot; &lt;&lt; rightIndex &lt;&lt; &quot;\\n&quot;; if(leftIndex == rightIndex &amp;&amp; leftIndex == len) { ranges.insert(ranges.begin() + leftIndex, make_pair(left, right)); len++; } else { left = min(left, ranges[leftIndex].first); if(rightIndex &lt; len) { if(inRange(right, rightIndex)) { right = max(right, ranges[rightIndex].second); rightIndex++; } } if(leftIndex == rightIndex &amp;&amp; !inRange(left-1, leftIndex) &amp;&amp; !inRange(right, rightIndex)) { ranges.insert(ranges.begin() + leftIndex, make_pair(left, right)); len++; } else { ranges[leftIndex].first = left; ranges[leftIndex].second = right; leftIndex++; if(rightIndex &gt; leftIndex) ranges.erase(ranges.begin() + leftIndex, ranges.begin() + rightIndex); if(rightIndex &gt; leftIndex) len -= rightIndex - leftIndex; } } } bool queryRange(int left, int right) { if(debug) { ops++; cout &lt;&lt; &quot;[&quot; &lt;&lt; ops &lt;&lt; &quot;], &quot; &lt;&lt; &quot;queryRange&quot; &lt;&lt; &quot;[&quot; &lt;&lt; left &lt;&lt; &quot;, &quot; &lt;&lt; right &lt;&lt; &quot;]&quot; &lt;&lt; &quot;\\n&quot;; } bool ret = _queryRange(left, right); if(debug) cout &lt;&lt; (ret ? &quot;ok&quot; : &quot;not found&quot;) &lt;&lt; &quot;\\n&quot;; if(debug) printRanges(); return ret; } bool _queryRange(int left, int right) { int leftIndex = searchRanges(left); int rightIndex = searchRanges(right-1); if(leftIndex &gt;= len || rightIndex &gt;= len) return false; return leftIndex == rightIndex &amp;&amp; inRange(left, leftIndex) &amp;&amp; inRange(right-1, rightIndex); } void removeRange(int left, int right) { if(debug) { ops++; cout &lt;&lt; &quot;[&quot; &lt;&lt; ops &lt;&lt; &quot;], &quot; &lt;&lt; &quot;removeRange&quot; &lt;&lt; &quot;[&quot; &lt;&lt; left &lt;&lt; &quot;, &quot; &lt;&lt; right &lt;&lt; &quot;]&quot; &lt;&lt; &quot;\\n&quot;; } _removeRange(left, right); if(debug) printRanges(); } void _removeRange(int left, int right) { int leftIndex = searchRanges(left); int rightIndex = searchRanges(right-1); if(debug) cout &lt;&lt; &quot;leftIndex = &quot; &lt;&lt; leftIndex &lt;&lt; &quot;, rightIndex = &quot; &lt;&lt; rightIndex &lt;&lt; &quot;\\n&quot;; if(leftIndex == rightIndex &amp;&amp; leftIndex == len) { return; } else { int leftLeft = left, rightRight = right; if(inRange(left, leftIndex)) { leftLeft = ranges[leftIndex].first; } if(rightIndex &lt; len) { if(inRange(right-1, rightIndex)) { rightRight = ranges[rightIndex].second; rightIndex++; } } if(debug) cout &lt;&lt; &quot;leftIndex = &quot; &lt;&lt; leftIndex &lt;&lt; &quot;, rightIndex = &quot; &lt;&lt; rightIndex &lt;&lt; &quot;\\n&quot;; if(debug) cout &lt;&lt; &quot;leftLeft = &quot; &lt;&lt; leftLeft &lt;&lt; &quot;, rightRight = &quot; &lt;&lt; rightRight &lt;&lt; &quot;\\n&quot;; if(rightRight &gt; right) { rightIndex--; ranges[rightIndex].first = right; ranges[rightIndex].second = rightRight; if(debug) cout &lt;&lt; &quot;add right len = &quot; &lt;&lt; len &lt;&lt; &quot;\\n&quot;; } if(leftLeft &lt; left) { if(leftIndex == rightIndex) { ranges.insert(ranges.begin() + leftIndex, make_pair(leftLeft, left)); len++; } else { ranges[leftIndex].first = leftLeft; ranges[leftIndex].second = left; leftIndex++; } if(debug) cout &lt;&lt; &quot;add left len = &quot; &lt;&lt; len &lt;&lt; &quot;\\n&quot;; } ranges.erase(ranges.begin() + leftIndex, ranges.begin() + rightIndex); len -= rightIndex - leftIndex; if(debug) cout &lt;&lt; &quot;len = &quot; &lt;&lt; len &lt;&lt; &quot;\\n&quot;; } }};/** * Your RangeModule object will be instantiated and called as such: * RangeModule* obj = new RangeModule(); * obj-&gt;addRange(left,right); * bool param_2 = obj-&gt;queryRange(left,right); * obj-&gt;removeRange(left,right); */ 1334. é˜ˆå€¼è·ç¦»å†…é‚»å±…æœ€å°‘çš„åŸå¸‚Floyd1234567891011121314151617181920212223242526272829303132333435class Solution {public: int findTheCity(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int distanceThreshold) { vector&lt;vector&lt;int&gt;&gt; g(n, vector&lt;int&gt;(n, INT_MAX)); vector&lt;int&gt; cnt(n, 0); for(vector&lt;int&gt;&amp; edge : edges) { g[edge[0]][edge[1]] = edge[2]; g[edge[1]][edge[0]] = edge[2]; } for(int w = 0; w &lt; n; w++) { for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(g[i][w] != INT_MAX &amp;&amp; g[w][j] != INT_MAX &amp;&amp; g[i][w] + g[w][j] &lt; g[i][j]) g[i][j] = g[i][w] + g[w][j]; } } } for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(i != j &amp;&amp; g[i][j] &lt;= distanceThreshold) { cnt[i]++; } } } int ret = 0; int min_num = INT_MAX; for(int i = n-1; i &gt;= 0; i--) { if(cnt[i] &lt; min_num) { min_num = cnt[i]; ret = i; } } return ret; }}; ä¸­é—´èŠ‚ç‚¹wè¦æ”¾åœ¨æœ€å¤–å±‚å¾ªç¯ ä¼˜åŒ–ä¸€ä¸‹ä¸‹1234567891011121314151617181920212223242526272829303132333435class Solution {public: int findTheCity(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int distanceThreshold) { vector&lt;vector&lt;int&gt;&gt; g(n, vector&lt;int&gt;(n, INT_MAX / 2)); for(vector&lt;int&gt;&amp; edge : edges) { g[edge[0]][edge[1]] = edge[2]; g[edge[1]][edge[0]] = edge[2]; } for(int w = 0; w &lt; n; w++) { g[w][w] = 0; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(g[i][w] + g[w][j] &lt; g[i][j]) g[i][j] = g[i][w] + g[w][j]; } } } int ret = 0; int min_num = INT_MAX; for(int i = n-1; i &gt;= 0; i--) { int cnt = 0; for(int j = 0; j &lt; n; j++) { if(g[i][j] &lt;= distanceThreshold) { cnt++; } } if(cnt &lt; min_num) { // cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;, cnt[i] = &quot; &lt;&lt; cnt[i] &lt;&lt; &quot;\\n&quot;; min_num = cnt; ret = i; } } return ret; }}; BFSå†™äº†åŠå¤©ï¼Œå‘ç°å¸¦æƒå›¾ä¸èƒ½bfsæ±‚æœ€çŸ­è·¯å¾„ dijkstra1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution { int min_index(int len, const vector&lt;int&gt;&amp; v, const vector&lt;bool&gt;&amp; visited) { pair&lt;int, int&gt; ret(INT_MAX, -1); for(int i = 0; i &lt; len; i++) { if(!visited[i] &amp;&amp; v[i] &lt; ret.first) { ret = {v[i], i}; } } return ret.second; }public: int findTheCity(int n, vector&lt;vector&lt;int&gt;&gt; &amp;edges, int distanceThreshold) { vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; g(n); for(auto&amp; edge : edges) { g[edge[0]].push_back(make_pair(edge[1], edge[2])); g[edge[1]].push_back(make_pair(edge[0], edge[2])); } int ret = -1; int min_cnt = INT_MAX; for(int node = 0; node &lt; n; node++) { int cnt = 0; vector&lt;int&gt; min_dis(n, INT_MAX &gt;&gt; 2); vector&lt;bool&gt; visited(n, false); min_dis[node] = 0; int next = node; do { visited[next] = true; for(auto&amp; [child, weight] : g[next]) { min_dis[child] = min(min_dis[child], min_dis[next] + weight); } } while((next = min_index(n, min_dis, visited)) != -1); for(int i = 0; i &lt; n; i++) { if(min_dis[i] &lt;= distanceThreshold) { cnt++; } } if(cnt &lt;= min_cnt) { min_cnt = cnt; ret = node; } } return ret; }}; 307. åŒºåŸŸå’Œæ£€ç´¢ - æ•°ç»„å¯ä¿®æ”¹åˆ†å—æ€è·¯æŠŠæ•°ç»„åˆ†æˆsqrt(n)ä»½ï¼Œå­˜å‚¨æ¯ä»½çš„å’Œæ›´æ–°æ—¶ï¼Œæ‰¾åˆ°å¯¹åº”åŒºé—´æŠŠå€¼æ›´æ–°ï¼ŒO(1)æ±‚å€¼æ—¶ï¼ŒæŠŠleftåˆ°rightå¯¹åº”åŒºé—´çš„å’ŒåŠ èµ·æ¥ï¼ŒåŠ ä¸Šrightå³è¾¹çš„ä¸è¶³ä¸€ä¸ªåŒºé—´çš„ï¼Œå‡å»å·¦ä¾§è¶…è¿‡ä¸€ä¸ªåŒºé—´çš„ï¼Œä¸‰ä¸ªè¿ç®—éƒ½åœ¨sqrt(n)å†…å®Œæˆ, O(sqrt(n)) ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344class NumArray { vector&lt;int&gt; data; vector&lt;int&gt; preSum; int size; int len;public: NumArray(vector&lt;int&gt;&amp; nums) { data = nums; len = nums.size(); if(len == 0) return; size = sqrt(len); preSum = vector&lt;int&gt;(size + 20, 0); for(int i = 0; i &lt; len; i++) { preSum[i / size] += nums[i]; } } void update(int index, int val) { int prev = data[index]; data[index] = val; preSum[index / size] += val - prev; } int sumRange(int left, int right) { int sum = 0; for(int i = left/size; i &lt; right/size; i++) { sum += preSum[i]; } for(int i = right / size * size; i &lt;= right; i++) { sum += data[i]; } for(int i = left / size * size; i &lt; left; i++) { sum -= data[i]; } return sum; }};/** * Your NumArray object will be instantiated and called as such: * NumArray* obj = new NumArray(nums); * obj-&gt;update(index,val); * int param_2 = obj-&gt;sumRange(left,right); */ çº¿æ®µæ ‘ æ„é€ ä¸€æ£µæ ‘ æ ¹èŠ‚ç‚¹ä»£è¡¨[0, n-1]çš„å’Œ ä¸¤ä¸ªå­èŠ‚ç‚¹åˆ†åˆ«ä»£è¡¨[0,(n-1)/2]å’Œ[(n-1)/2+1, n-1]çš„å’Œ å¦‚æœåŒºé—´ä¸º0ï¼Œåˆ™ä¸ç»§ç»­ç»†åˆ† æ›´æ–° æ ¹æ®indexåœ¨æ ‘ä¸­æŸ¥æ‰¾ï¼ŒåŒæ—¶æ›´æ–°æ‰€æœ‰çˆ¶èŠ‚ç‚¹çš„å€¼ æŸ¥è¯¢ å¯¹äºä¸€ä¸ªæŸ¥è¯¢ï¼Œ å¦‚æœæŸ¥è¯¢èŒƒå›´åˆšå¥½ç­‰äºèŠ‚ç‚¹ä»£è¡¨çš„èŒƒå›´ï¼Œåˆ™è¿”å›è¯¥èŠ‚ç‚¹çš„å€¼ å¦‚æœä¸åŒï¼Œåˆ™å°†æŸ¥è¯¢ä¸€åˆ†ä¸ºä¸¤ä¸ªå­æŸ¥è¯¢ï¼Œåˆ†åˆ«äº¤ç»™å­èŠ‚ç‚¹å¤„ç†ï¼Œç›´åˆ°é‡åˆ°å­æŸ¥è¯¢ä¸å­èŠ‚ç‚¹ä»£è¡¨çš„èŒƒå›´ç›¸åŒï¼Œå°†æ‰€æœ‰å­æŸ¥è¯¢ç›¸åŠ  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class NumArray {private: vector&lt;int&gt; tree; int n; int build(int node, int l, int r, const vector&lt;int&gt;&amp; nums) { if(l == r) tree[node] = nums[l]; else { int mid = (r - l) / 2 + l; tree[node] = build(2*node+1, l, mid, nums) + build(2*node+2, mid+1, r, nums); } return tree[node]; } void updateTree(int node, int index, int l, int r, int val) { if(l == r) tree[node] = val; else { int mid = (r - l) / 2 + l; if(index &lt;= mid) { updateTree(node*2+1, index, l, mid, val); } else { updateTree(node*2+2, index, mid+1, r, val); } tree[node] = tree[2*node+1] + tree[2*node+2]; } } int sumTree(int node, int left, int right, int l, int r) { if(left == l &amp;&amp; right == r) { return tree[node]; } int mid = (r - l) / 2 + l; if(left &gt; mid) { return sumTree(node*2+2, left, right, mid+1, r); } else if(right &lt;= mid) { return sumTree(node*2+1, left, right, l, mid); } else { return sumTree(node*2+1, left, mid, l, mid) + sumTree(2*node+2, mid+1, right, mid+1, r); } }public: NumArray(vector&lt;int&gt;&amp; nums) { n = nums.size(); tree = vector&lt;int&gt;(n * 4); build(0, 0, n-1, nums); } void update(int index, int val) { updateTree(0, index, 0, n-1, val); } int sumRange(int left, int right) { return sumTree(0, left, right, 0, n-1); }};/** * Your NumArray object will be instantiated and called as such: * NumArray* obj = new NumArray(nums); * obj-&gt;update(index,val); * int param_2 = obj-&gt;sumRange(left,right); */ 765. æƒ…ä¾£ç‰µæ‰‹æ€è·¯çœ‹äº†ä¸‹é¢çš„æç¤ºï¼š Say there are N two-seat couches. For each couple, draw an edge from the couch of one partner to the couch of the other partner. è®©æˆ‘ç”»å‡ºåº§ä½ä¸Šçš„äººåˆ°å…¶ä¼´ä¾£çš„ç®­å¤´ å¦‚æœç®­å¤´åœ¨åŒä¸€ä¸ªæ²™å‘ä¸Šï¼Œå°±æ— éœ€äº¤æ¢ å¦‚æœä¸åœ¨åŒä¸€ä¸ªæ²™å‘ä¸Šï¼Œå°±è®©å¦ä¸€ä¸ªäººä¸å…¶äº¤æ¢ å¯¹æ¯ä¸ªæ²™å‘æ‰§è¡Œç›¸åŒçš„ä»»åŠ¡ ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution { int n; int min_swap_cnt = INT_MAX; unordered_map&lt;int, int&gt; pos;public: int minSwapsCouples(vector&lt;int&gt;&amp; row) { n = row.size(); for(int i = 0; i &lt; n; i++) { pos[row[i]] = i; } search(0, 0, row); return min_swap_cnt; } void print(const vector&lt;int&gt;&amp; nums) { cout &lt;&lt; nums[0]; for(int i = 1; i &lt; n; i++) cout &lt;&lt; &quot;, &quot; &lt;&lt; nums[i]; cout &lt;&lt; &quot;\\n&quot;; } bool check(const vector&lt;int&gt;&amp; nums) { for(int i = 0; i &lt; n; i+=2) { if(abs(nums[i] - nums[i+1]) != 1) return false; } return true; } void search(int s, int cnt, vector&lt;int&gt; &amp;nums) { // print(nums); if(check(nums)) { min_swap_cnt = min(min_swap_cnt, cnt); return; } if(s &gt;= n) return; int i = s; for(int i = s; i &lt; n; i++) { int target = nums[i] + ((nums[i] &amp; 1) ? -1 : 1); int j = pos[target]; if(i/2 != j/2) { int x = (i&amp;1) ? -1 : 1; pos[target] = i + x; pos[nums[i + x]] = j; swap(nums[i + x], nums[j]); search(i + 2, cnt+1, nums); // swap(nums[i + x], nums[j]); // pos[target] = j; // pos[nums[i + x]] = i + x; // search(i + 2, cnt, nums); break; } } }}; emm,ä¸€ç‚¹ç‚¹è’™å¯¹çš„ï¼Œå±…ç„¶å¯¹äº† ç®€åŒ–ä»£ç 123456789101112131415161718192021class Solution {public: int minSwapsCouples(vector&lt;int&gt;&amp; row) { int swap_cnt = 0; int n = row.size(); vector&lt;int&gt; pos(n); for(int i = 0; i &lt; n; i++) { pos[row[i]] = i; } for(int i = 0; i &lt; n; i+=2) { int target = row[i] + ((row[i] &amp; 1) ? -1 : 1); int j = pos[target]; if(i/2 != j/2) { swap(pos[target], pos[row[i + 1]]); swap(row[i + 1], row[j]); swap_cnt++; } } return swap_cnt; }};","link":"/home/2023/11/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9328/"},{"title":"LeetCode-30","text":"162. å¯»æ‰¾å³°å€¼123456789class Solution {public: int findPeakElement(vector&lt;int&gt;&amp; nums) { int index = 0; int n = nums.size(); while(index &lt; n-1 &amp;&amp; nums[index] &lt; nums[index+1]) index++; return index; }}; 1901. å¯»æ‰¾å³°å€¼ II1234567891011121314151617181920212223242526class Solution {public: vector&lt;int&gt; findPeakGrid(vector&lt;vector&lt;int&gt;&gt;&amp; mat) { int x = 0, y = 0; int m = mat.size(), n = mat[0].size(); bool findPoint = true; while(findPoint) { findPoint = false; if(x + 1 &lt; m &amp;&amp; mat[x+1][y] &gt; mat[x][y]) { findPoint = true; x++; } else if(x - 1 &gt;= 0 &amp;&amp; mat[x-1][y] &gt; mat[x][y]) { findPoint = true; x--; } else if(y + 1 &lt; n &amp;&amp; mat[x][y+1] &gt; mat[x][y]) { findPoint = true; y++; } else if(y - 1 &gt;= 0 &amp;&amp; mat[x][y-1] &gt; mat[x][y]) { findPoint = true; y--; } } return {x, y}; }}; è´ªå¿ƒï¼Œä»æŸä¸€ç‚¹å¼€å§‹ï¼Œå¦‚æœä¸Šä¸‹å·¦å³å­˜åœ¨æ¯”å½“å‰ç‚¹å¤§çš„æ•°ï¼Œç§»åŠ¨è¿‡å»ï¼Œç›´åˆ°æ— æ³•ç§»åŠ¨ 746. ä½¿ç”¨æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯1234567891011121314class Solution {public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) { int n = cost.size(); vector&lt;int&gt; vecc(n+1, INT_MAX); vecc[0] = vecc[1] = 0; for(int i = 0; i &lt; n-1; i++) { vecc[i+1] = min(vecc[i+1], vecc[i] + cost[i]); vecc[i+2] = min(vecc[i+2], vecc[i] + cost[i]); } vecc[n] = min(vecc[n], vecc[n-1] + cost[n-1]); return vecc[n]; }}; 12345678910111213class Solution {public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) { int n = cost.size(); int a = cost[0], b = cost[1]; for(int i = 2; i &lt; n; i++) { int t = cost[i] + min(a, b); a = b; b = t; } return min(a, b); }}; 2415. åè½¬äºŒå‰æ ‘çš„å¥‡æ•°å±‚123456789101112131415161718192021222324252627282930class Solution {public: TreeNode* reverseOddLevels(TreeNode* root) { queue&lt;TreeNode *&gt; q; if(root) q.push(root); int n = 1; bool rev = false; while(!q.empty()) { int cnt = n; vector&lt;TreeNode *&gt; tmp; while(n--) { TreeNode *node = q.front(); q.pop(); if(rev) tmp.push_back(node); if(node-&gt;left &amp;&amp; node-&gt;right) { q.push(node-&gt;left); q.push(node-&gt;right); } } if(rev) { for(int i = 0; i &lt; cnt / 2; i++) { swap(tmp[i]-&gt;val, tmp[cnt - 1 - i]-&gt;val); } } rev = !rev; n = cnt &lt;&lt; 1; } return root; }}; 1631. æœ€å°ä½“åŠ›æ¶ˆè€—è·¯å¾„è¶…æ—¶123456789101112131415161718192021222324252627class Solution {public: int minimumEffortPath(vector&lt;vector&lt;int&gt;&gt;&amp; heights) { int row = heights.size(), col = heights[0].size(); if(row &lt;= 1 &amp;&amp; col &lt;= 1) return 0; vector&lt;int&gt; len(row*col, INT_MAX / 2); vector&lt;bool&gt; visited(row*col, false); len[0] = 0; for(int i = 0; i &lt; row*col - 1; i++) { int min_dis = 0; int node = -1; for(int j = 0; j &lt; row*col; j++) { if(!visited[j] &amp;&amp; (node == -1 || len[j] &lt; len[node])) { node = j; } } int x = node / col, y = node % col; if(x &lt; row - 1 &amp;&amp; !visited[node+col]) len[node+col] = min(len[node+col], max(len[node], abs(heights[x][y] - heights[x+1][y]))); if(y &lt; col - 1 &amp;&amp; !visited[node+1]) len[node+1] = min(len[node+1], max(len[node], abs(heights[x][y] - heights[x][y+1]))); if(x &gt; 0 &amp;&amp; !visited[node-col]) len[node-col] = min(len[node-col], max(len[node], abs(heights[x][y] - heights[x-1][y]))); if(y &gt; 0 &amp;&amp; !visited[node-1]) len[node-1] = min(len[node-1], max(len[node], abs(heights[x][y] - heights[x][y-1]))); visited[node] = true; } return len[row*col-1]; }}; ä¼˜åŒ–dijkstraéœ€è¦ç”¨ä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ–ä¸€ä¸‹ 1234567891011121314151617181920212223242526272829303132333435class Solution { static constexpr int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};public: int minimumEffortPath(vector&lt;vector&lt;int&gt;&gt;&amp; heights) { int row = heights.size(), col = heights[0].size(); if(row &lt;= 1 &amp;&amp; col &lt;= 1) return 0; vector&lt;int&gt; len(row*col, INT_MAX / 2); vector&lt;bool&gt; visited(row*col, false); len[0] = 0; int min_dis = 0; int node = -1; auto tupleCmp = [](const auto&amp; e1, const auto&amp; e2) { auto&amp;&amp; [x1, d1] = e1; auto&amp;&amp; [x2, d2] = e2; return d1 &gt; d2; }; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(tupleCmp)&gt; q(tupleCmp); q.emplace(0, 0); while(!q.empty()) { auto [node, dis] = q.top(); q.pop(); int x = node / col, y = node % col; for(int i = 0; i &lt; 4; i++) { int nx = x + dirs[i][0]; int ny = y + dirs[i][1]; if(nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; row &amp;&amp; ny &lt; col &amp;&amp; max(dis, abs(heights[x][y] - heights[nx][ny])) &lt; len[node + col * dirs[i][0] + dirs[i][1]]) { len[node + col * dirs[i][0] + dirs[i][1]] = max(dis, abs(heights[x][y] - heights[nx][ny])); q.emplace(node + col * dirs[i][0] + dirs[i][1], len[node + col * dirs[i][0] + dirs[i][1]]); } } visited[node] = true; } return len[row*col-1]; }}; LCR 078. åˆå¹¶ K ä¸ªå‡åºé“¾è¡¨ æ–¹æ³•å’Œå’Œå¹¶ä¸¤ä¸ªå‡åºé“¾è¡¨ç›¸åŒï¼Œkä¸ªé“¾è¡¨æ¯æ¬¡ä»kä¸ªæŒ‡é’ˆä¸­é€‰æ‹©å‡ºå€¼æœ€å°çš„ä¸€ä¸ªæ’å…¥åˆ°æ€»é“¾è¡¨ä¸­ ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—å¯ä»¥æŠŠç®—æ³•ä¼˜åŒ–åˆ°O(k*log(k)) 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { auto cmp = [](ListNode *a, ListNode *b) { return a-&gt;val &gt; b-&gt;val; }; priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, decltype(cmp)&gt; q(cmp); ListNode dummyNode; ListNode *dummyPtr = &amp;dummyNode; int k = lists.size(); for(int i = 0; i &lt; k; i++) { if(lists[i]) q.push(lists[i]); } while(!q.empty()) { ListNode *node = q.top(); q.pop(); dummyPtr-&gt;next = node; dummyPtr = node; node = node-&gt;next; if(node) { q.push(node); } } return dummyNode.next; }}; 2866. ç¾ä¸½å¡” IIæšä¸¾å±±å³°1234567891011121314151617181920212223242526272829303132333435class Solution {private: int len; void toHill(const vector&lt;int&gt;&amp; arr, int&amp; index, int endIndex) const { while(index + 1 &lt; endIndex &amp;&amp; arr[index] &lt;= arr[index+1]) index++; } void toValley(const vector&lt;int&gt;&amp; arr, int&amp; index, int endIndex) const { while(index + 1 &lt; endIndex &amp;&amp; arr[index] &gt;= arr[index+1]) index++; }public: long long maximumSumOfHeights(vector&lt;int&gt;&amp; maxHeights) { len = maxHeights.size(); int index = 0; toHill(maxHeights, index, len); long long res = 0; while(index &lt; len) { int val = maxHeights[index]; long long sum = 0; for(int i = index; i &gt;= 0; i--) { val = min(val, maxHeights[i]); sum += val; } val = maxHeights[index]; for(int i = index + 1; i &lt; len; i++) { val = min(val, maxHeights[i]); sum += val; } res = max(sum, res); index++; toValley(maxHeights, index, len); toHill(maxHeights, index, len); } return res; }}; å•è°ƒæ ˆ è¿˜æ˜¯ä¸ä¼šå•è°ƒæ ˆï¼Œæ˜å¤©å¼€å­¦å•è°ƒæ ˆï¼ 2048. ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ•°å€¼å¹³è¡¡æ•°æ’åˆ—ç»„åˆ è‹¥å¹³è¡¡æ•°ä¸ºdä½æ•°ï¼Œå°†dæ‹†æˆè‹¥å¹²ä¸ªä¸ç›¸ç­‰çš„æ•° å¦‚ï¼š6å¯ä»¥æ‹†æˆï¼Œ6, 2+4, 1+5, 1+2+3 ä»–ä»¬åˆ†åˆ«å¯¹åº”ï¼Œ666666, 224444, 155555, 122333ä»¥åŠä»–ä»¬çš„æ’åˆ—ç»„åˆ æ±‚å‡ºæ‰€æœ‰æ’åˆ—ç»„åˆï¼Œæ‰¾åˆ°å¤§äºnçš„æœ€å°æ’åˆ— ç”±äºä¸€ä¸ªæ•°çš„ä¸‹ä¸€ä¸ªå¹³è¡¡æ•°çš„ä½æ•°å¯èƒ½å¤§äºä»–ï¼Œéœ€è¦è€ƒè™‘ç›¸é‚»ä¸¤ä½çš„æƒ…å†µ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution { vector&lt;vector&lt;string&gt;&gt; origin = { {&quot;1&quot;}, {&quot;22&quot;}, {&quot;122&quot;, &quot;333&quot;}, {&quot;1333&quot;, &quot;4444&quot;}, {&quot;22333&quot;, &quot;14444&quot;, &quot;55555&quot;}, {&quot;122333&quot;, &quot;155555&quot;, &quot;224444&quot;, &quot;666666&quot;}, {&quot;1224444&quot;/*, &quot;1666666&quot;, &quot;7777777&quot;*/}, {&quot;88888888&quot;} // dummy for 1000000 }; int n; int ret = INT_MAX; int len;public: int nextBeautifulNumber(int n) { if(n == 0) return 1; this-&gt;n = n; len = digitCnt(n); for(string s : origin[len-1]) { permutaion(s, 0); } len++; for(string s : origin[len-1]) { permutaion(s, 0); } return ret; } void permutaion(string &amp;arr, int start) { if(start == len) { int number = 0; for(int i = 0; i &lt; len; i++) { number *= 10; number += arr[i] - '0'; } if(number &gt; n) ret = min(ret, number); } for(int i = start; i &lt; len; i++) { bool flag = false; for (int j = start; j &lt; i; j++) { if (arr[i] == arr[j]) { flag = true; break; } } if(!flag) { swap(arr[i], arr[start]); permutaion(arr, start+1); swap(arr[i], arr[start]); } } } int digitCnt(int n) { int digit = 0; while(n) { n /= 10; digit++; } return digit; }}; æ‰“è¡¨ ç”Ÿæˆæ‰€æœ‰æ»¡è¶³æ¡ä»¶çš„æ•°123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;limits.h&gt;#include &lt;stdbool.h&gt;bool check(int i) { int cnt[10] = {0}; char digits[128] = {0}; sprintf(digits, &quot;%d&quot;, i); char *ptr = digits; while(*ptr) { cnt[*ptr - '0']++; ptr++; } bool flag = cnt[0] == 0; for(int i = 1; i &lt; 10; i++) { if(cnt[i] &amp;&amp; cnt[i] != i) { flag = false; break; } } return flag;}int main() { printf(&quot;{&quot;); for(int i = 0; i &lt; 1000000; i++) { if(check(i)) printf(&quot;%d,&quot;, i); } for(int i = 1000000 + 1; i &lt; INT_MAX; i++) { if(check(i)) { printf(&quot;%d}\\n&quot;, i); break; } } return 0;} 123456789class Solution { vector&lt;int&gt; origin = { 1,22,122,212,221,333,1333,3133,3313,3331,4444,14444,22333,23233,23323,23332,32233,32323,32332,33223,33232,33322,41444,44144,44414,44441,55555,122333,123233,123323,123332,132233,132323,132332,133223,133232,133322,155555,212333,213233,213323,213332,221333,223133,223313,223331,224444,231233,231323,231332,232133,232313,232331,233123,233132,233213,233231,233312,233321,242444,244244,244424,244442,312233,312323,312332,313223,313232,313322,321233,321323,321332,322133,322313,322331,323123,323132,323213,323231,323312,323321,331223,331232,331322,332123,332132,332213,332231,332312,332321,333122,333212,333221,422444,424244,424424,424442,442244,442424,442442,444224,444242,444422,515555,551555,555155,555515,555551,666666,1224444 };public: int nextBeautifulNumber(int n) { return *upper_bound(origin.begin(), origin.end(), n); }}; 1671. å¾—åˆ°å±±å½¢æ•°ç»„çš„æœ€å°‘åˆ é™¤æ¬¡æ•°dp ä¸ä¼šï¼ŒæŠ„ç­”æ¡ˆ arr1[i]è¡¨ç¤º0..(i-1)ä¸­å°äºnums[i]çš„å…ƒç´ ä¸ªæ•° arr2[i]è¡¨ç¤º(i+1)..(len)ä¸­å°äºnums[i]çš„å…ƒç´ ä¸ªæ•° arr1[i] + arr2[i] + 1è¡¨ç¤ºä»¥iä¸ºå±±å³°çš„å±±çŠ¶æ•°ç»„é•¿åº¦ 1234567891011121314151617181920212223242526272829class Solution { int n = 0; vector&lt;int&gt; getLISArray(const vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; dp(n, 1); for (int i = 0; i &lt; n; ++i) { for (int j = 0; j &lt; i; ++j) { if (nums[j] &lt; nums[i]) { dp[i] = max(dp[i], dp[j] + 1); } } } return dp; }public: int minimumMountainRemovals(vector&lt;int&gt;&amp; nums) { n = nums.size(); vector&lt;int&gt; pre = getLISArray(nums); vector&lt;int&gt; suf = getLISArray({nums.rbegin(), nums.rend()}); reverse(suf.begin(), suf.end()); int ans = 0; for (int i = 0; i &lt; n; ++i) { if (pre[i] &gt; 1 &amp;&amp; suf[i] &gt; 1) { ans = max(ans, pre[i] + suf[i] - 1); } } return n - ans; }}; 1962. ç§»é™¤çŸ³å­ä½¿æ€»æ•°æœ€å°æ¨¡æ‹Ÿacä»£ç 123456789101112131415161718192021class Solution {public: int minStoneSum(vector&lt;int&gt;&amp; piles, int k) { priority_queue&lt;int&gt; q; int ret = 0; for(int rock : piles) { if(rock) q.push(rock); } while(!q.empty() &amp;&amp; k--) { int rock = q.top(); q.pop(); if(rock - rock / 2) q.push(rock - rock / 2); } while(!q.empty()) { int rock = q.top(); q.pop(); ret += rock; } return ret; }}; ä¼˜åŒ–æ¨¡æ‹Ÿ ä¸€è¾¹å‡å°‘ä¸€è¾¹ç®—æœ€ç»ˆç»“æœ 1234567891011121314class Solution {public: int minStoneSum(vector&lt;int&gt;&amp; piles, int k) { priority_queue&lt;int&gt; q(piles.begin(), piles.end()); int ret = accumulate(piles.begin(), piles.end(), 0); while(k--) { int rock = q.top(); q.pop(); if(rock - rock / 2) q.push(rock - rock / 2); ret -= rock / 2; } return ret; }}; æ—¶é—´100% çœ‹äº†æ—¶é—´100%çš„æ–¹æ³•ï¼Œç”±äºæ•°å­—æœ€å¤§æ˜¯10000ï¼Œå¯ä»¥åˆ›å»ºä¸€ä¸ªé•¿åº¦ä¸º10000+1çš„boolæ•°ç»„ ä»ä¸‹æ ‡æœ€å¤§åˆ°æœ€å°ï¼Œé€‰æ‹©å­˜åœ¨äºåŸæ•°ç»„çš„ä¸‹æ ‡ï¼ˆboolæ•°ç»„ç½®ä¸ºtrueï¼‰ï¼Œé™¤äºŒï¼Œå¹¶æŠŠå‰©ä½™éƒ¨åˆ†è®¾ç½®ä¸ºtrue è¿™æ ·å°±å¯ä»¥èµ·åˆ°å’Œä¼˜å…ˆé˜Ÿåˆ—ä¸€æ ·çš„æ•ˆç‡ ä»£ç 1234567891011121314151617181920212223class Solution {public: int minStoneSum(vector&lt;int&gt;&amp; piles, int k) { bool buck[10000] = {false}; int ret = 0, max_rock = INT_MIN; for(int rock : piles) { max_rock = max(max_rock, rock); buck[rock-1] = true; ret += rock; } while(max_rock--) { if(!buck[max_rock]) continue; if(k--) { int diff = (max_rock + 1) / 2; buck[max_rock - diff] = true; ret -= diff; } else { break; } } return ret; }}; è¿™ä¸ªä»£ç è·‘æ˜¯é”™çš„ï¼Œå› ä¸ºæ²¡æœ‰è€ƒè™‘åŒä¸€ä¸ªæ•°å‡ºç°å¤šæ¬¡çš„æƒ…å†µï¼Œæ‰€ä»¥ä¸èƒ½ä½¿ç”¨boolæ•°ç»„ 1234567891011121314151617181920class Solution {public: int minStoneSum(vector&lt;int&gt;&amp; piles, int k) { int buck[10000+1] = {false}; int ret = 0, max_rock = INT_MIN; for(int rock : piles) { max_rock = max(max_rock, rock); buck[rock]++; ret += rock; } for(;max_rock &amp;&amp; k; max_rock--) { int width = min(buck[max_rock], k); int diff = (max_rock) / 2; ret -= diff * width; buck[max_rock - diff] += width; k -= width; } return ret; }}; 1954. æ”¶é›†è¶³å¤Ÿè‹¹æœçš„æœ€å°èŠ±å›­å‘¨é•¿æšä¸¾ åˆšå¼€å§‹çœ‹é”™é¢˜äº†ï¼Œè®¤ä¸ºåªè®¡ç®—æ­£æ–¹å½¢çš„è¾¹ä¸Šçš„è‹¹æœæ•° æ¨å¯¼å‡ºå½“è¾¹é•¿ä¸º2*radiusæ—¶ï¼Œè¾¹ä¸Šçš„è‹¹æœæ•°ç›®ä¸º 4*radius + 8*radius + 4*3*radius*(radius-1) æšä¸¾è¾¹é•¿å¹¶å°†è¾¹ä¸Šçš„è‹¹æœåŠ èµ·æ¥ï¼Œç›´åˆ°è¶…è¿‡éœ€è¦çš„è‹¹æœå³å¯ å…¬å¼æ¨å¯¼ bfsçš„æ€æƒ³ è¾¹é•¿ä¸º0çš„æ‰€æœ‰ç‚¹(0,0) çš„å­èŠ‚ç‚¹ï¼Œåˆ†ä¸ºä¸¤ç±»æ˜¯ |x| + |y| = 1 (1, 0), (0, 1), (-1, 0), (0, -1) |x| + |y| = 2 (1, 1), (1, -1), (-1, 1), (-1, -1) ç‚¹å¯èƒ½å­˜åœ¨ä¸¤ç§å­èŠ‚ç‚¹ï¼Œä¸€ç§èŠ‚ç‚¹ä¼šè®©|x| + |y|å¢å¤§1ï¼Œå¦ä¸€ç§ä¼šå¢å¤§2 å››ä¸ªè§’ä¸Šçš„å­èŠ‚ç‚¹ä¼šå¢å¤§äºŒï¼Œå››ä¸ªè§’ä¸Šçš„å­èŠ‚ç‚¹æœ‰å¢å¤§2å’Œå¢å¤§1çš„ éå››ä¸ªè§’ä¸Šçš„å­èŠ‚ç‚¹åªä¼šå¢å¤§1 å››ä¸ªè§’ä¸Šçš„èŠ‚ç‚¹çš„|x| + |y| = 2*radiuså­µåŒ–å­ä»£ äº§ç”Ÿ4ä¸ªå¢å¤§2çš„ï¼Œä¹Ÿå°±æ˜¯å…¬å·®ä¸º2çš„ï¼Œä¹Ÿå°±æ˜¯4*2*radius äº§ç”Ÿ8ä¸ªå¢å¤§1çš„ å‰©ä½™èŠ‚ç‚¹å­µåŒ–å­ä»£ åªä¼šäº§ç”Ÿä¸€ä¸ªå…¬å·®ä¸º1çš„ å†ç»Ÿè®¡è¾¹é•¿ä¸º1çš„æ‰€æœ‰ç‚¹çš„å­èŠ‚ç‚¹ï¼Œå¯ä»¥å‘ç°ï¼Œå½“åŠå¾„ä¸ºradiusæ—¶ï¼š |x| + |y| = radius çš„æœ‰ 4 ä¸ª |x| + |y| = radius + i, i = 1, 2, ..., radius-1çš„å„æœ‰8ä¸ª |x| + |y| = 2*radiusçš„æœ‰4ä¸ª æ€»å’Œä¸ºï¼š 4*radius $ 8 \\times \\sum_{i=radius+1}^{2*radius-1}{i} = \\frac{(3 \\times radius)\\times(radius-1)}{2} \\times 8$ 4*2*radius å°†ä»¥ä¸Šä¸‰éƒ¨åˆ†æ±‚å’Œï¼Œå¾—åˆ° $ 4radius + 8radius + 12radius(radius - 1)$ ä»£ç 1234567891011class Solution {public: long long minimumPerimeter(long long neededApples) { long long radius = 0, apple = 0; while(apple &lt; neededApples) { radius++; apple += 4*radius + 8*radius + 4*3*radius*(radius-1); } return 8 * radius; }}; äºŒåˆ† å°†ä¸Šé¢çš„å…¬å¼å†æ¬¡æ¨å¯¼ï¼Œå³å¯å¾—åˆ°å¯¹äºåŠå¾„ä¸ºradiusçš„æ­£æ–¹å½¢ä¸Šä»¥åŠå…¶å†…éƒ¨ï¼Œå…±æœ‰è‹¹æœ $ 2radius(radius+1)(2radius+1) $ ç„¶åå°±èƒ½æ„‰å¿«çš„äºŒåˆ†å•¦ 12345678910111213141516171819202122232425class Solution {public: long long minimumPerimeter(long long neededApples) { long long mid = 0, apple = 0; int l = 0, r = 500000; while(l &lt; r) { // [l, r] // f(l) &lt; target // f(r) &gt;= target mid = (r - l) / 2 + l; apple = 2*mid*(mid+1)*(2*mid+1); if(apple &lt; neededApples) { l = mid + 1; } else { r = mid; } } // [r, l) return 8 * l; }};// l = mid + 1, r = mid - 1, é—­åŒºé—´// r = mid, l = mid, å¼€åŒºé—´// l &lt;= r // åŒé—­åŒºé—´(å¯¹åº”åŒºé—´æ²¡æœ‰æ•°)","link":"/home/2023/12/19/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9330/"},{"title":"LeetCode-31","text":"1276. ä¸æµªè´¹åŸæ–™çš„æ±‰å ¡åˆ¶ä½œæ–¹æ¡ˆ è§£æ–¹ç¨‹ï¼Œåˆ¤æ–­æ˜¯éè´Ÿæ•´æ•°è§£å°±è¡Œ ç”¨ä½è¿ç®—ï¼Œèƒ½å¿«ä¸€ç‚¹ 12345678910111213class Solution {public: vector&lt;int&gt; numOfBurgers(int tomatoSlices, int cheeseSlices) { int jumbo = 0, small = 0; // jumbo + small == cheeseSlices; // 4*jumbo + 2*small == tomatoSlices; small = ((cheeseSlices &lt;&lt; 2) - tomatoSlices); jumbo = (tomatoSlices - (cheeseSlices &lt;&lt; 1)); if(jumbo &gt;= 0 &amp;&amp; small &gt;= 0 &amp;&amp; (small &amp; 1) == 0 &amp;&amp; (jumbo &amp; 1) == 0) return {jumbo &gt;&gt; 1, small &gt;&gt; 1}; return {}; }}; 1185. ä¸€å‘¨ä¸­çš„ç¬¬å‡ å¤© æ¢¦å›å¤§ä¸€ 1234567891011121314151617181920212223242526class Solution {public: string dayOfTheWeek(int day, int month, int year) { int week = 0; for(int i = 1971; i &lt; year; i++) { week = (week + 31 * 7 + 30 * 4 + 28) % 7; if((i % 100 != 0 &amp;&amp; i % 4 == 0) || i % 400 == 0) { week = (week + 1) % 7; } } for(int i = 1; i &lt; month; i++) { if(i == 2) { week = (week + 28) % 7; if((year % 100 != 0 &amp;&amp; year % 4 == 0) || year % 400 == 0) { week = (week + 1) % 7; } } else if(i == 1 || i == 3 || i == 5 || i == 7 || i == 8 || i == 10 || i == 12) { week = (week + 31) % 7; } else { week = (week + 30) % 7; } } week = (week + day + 4) % 7; return vector&lt;string&gt;{&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;}[week]; }}; 2706. è´­ä¹°ä¸¤å—å·§å…‹åŠ›123456789101112131415class Solution {public: int buyChoco(vector&lt;int&gt;&amp; prices, int money) { int minPrice = INT_MAX / 2, secondMinPrice = INT_MAX / 2; for(int price : prices) { if(price &lt; minPrice) { secondMinPrice = minPrice; minPrice = price; } else if(price &lt; secondMinPrice) { secondMinPrice = price; } } return (minPrice + secondMinPrice &lt;= money) ? (money - minPrice - secondMinPrice) : money; }}; 2735. æ”¶é›†å·§å…‹åŠ›123456789101112131415class Solution {public: long long minCost(vector&lt;int&gt;&amp; nums, int x) { int n = nums.size(); vector&lt;int&gt; f(nums); long long ans = accumulate(f.begin(), f.end(), 0LL); for (int k = 1; k &lt; n; ++k) { for (int i = 0; i &lt; n; ++i) { f[i] = min(f[i], nums[(i + k) % n]); } ans = min(ans, (long long)(k) * x + accumulate(f.begin(), f.end(), 0LL)); } return ans; }}; 1599. ç»è¥æ‘©å¤©è½®çš„æœ€å¤§åˆ©æ¶¦æ¨¡æ‹Ÿ æ¨¡æ‹Ÿç»è¥ 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: int minOperationsMaxProfit(vector&lt;int&gt;&amp; customers, int boardingCost, int runningCost) { int wating = 0; int porfit = 0; int maxProfit = 0; int maxProfitI = -2; int len = customers.size(); int i = 0; for(; i &lt; len; i++) { if(customers[i] + wating &gt; 4) { wating += customers[i] - 4; customers[i] = 4; } else { customers[i] = customers[i] + wating; wating = 0; } porfit += boardingCost * customers[i] - runningCost; if(porfit &gt; maxProfit) { maxProfit = porfit; maxProfitI = i; } } while(wating &gt; 0) { int onboard = 0; if(wating &gt; 4) { onboard = 4; wating -= 4; } else { onboard = wating; wating = 0; } porfit += boardingCost * onboard - runningCost; if(porfit &gt; maxProfit) { maxProfit = porfit; maxProfitI = i; } i++; } return maxProfitI+1; }}; ä¼˜åŒ– æ•°ç»„éå†ç»“æŸåï¼Œå‰©ä¸‹çš„ä¹˜å®¢å¯ä»¥ä¸ç”¨æ¨¡æ‹Ÿï¼Œç›´æ¥/4çœ‹æœ‰å‡ æ¬¡å°±å¥½ å¦‚æœboardingCost runningCostçš„å€¼æ°å¥½æ— è®ºå¦‚ä½•éƒ½æ— æ³•ç›ˆåˆ©ï¼Œå¯ä»¥ä¸ç®—åé¢çš„ 12345678910111213141516171819202122232425262728293031323334353637383940class Solution {public: int minOperationsMaxProfit(vector&lt;int&gt;&amp; customers, int boardingCost, int runningCost) { int wating = 0; int porfit = 0; int maxProfit = 0; int maxProfitI = -1; int len = customers.size(); int i = 1; for(; i &lt;= len; i++) { wating += customers[i-1]; int onboard = min(4, wating); wating -= onboard; porfit += boardingCost * onboard - runningCost; if(porfit &gt; maxProfit) { maxProfit = porfit; maxProfitI = i; } } int fullCost = (boardingCost &lt;&lt; 2) - runningCost; if(fullCost &lt;= 0) return maxProfitI; if(wating &gt; 0) { int ramain = wating % 4; int roll = wating &gt;&gt; 2; wating = ramain; porfit += roll * fullCost; i += roll; if(porfit &gt; maxProfit) { maxProfit = porfit; maxProfitI = i - 1; } porfit += boardingCost * wating - runningCost; if(porfit &gt; maxProfit) { maxProfit = porfit; maxProfitI = i; } } return maxProfitI; }}; 889. æ ¹æ®å‰åºå’Œååºéå†æ„é€ äºŒå‰æ ‘ å¯¹äºæ ¹èŠ‚ç‚¹ï¼Œå…ˆåºåºåˆ—çš„å³ä¾§æ˜¯å·¦èŠ‚ç‚¹ï¼Œååºåºåˆ—çš„å³æµ‹æ˜¯å³èŠ‚ç‚¹ å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹ä¸åŒï¼Œåˆ™èŠ‚ç‚¹æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼Œå¦‚æœç›¸åŒï¼Œåˆ™è¯¥èŠ‚ç‚¹å¯èƒ½æ˜¯å·¦èŠ‚ç‚¹ï¼Œä¹Ÿå¯èƒ½æ˜¯å³èŠ‚ç‚¹ å¯¹äºå…¶ä»–èŠ‚ç‚¹ï¼Œç»´æŠ¤å¥½è¯¥èŠ‚ç‚¹å¯åœ¨å…ˆåºåºåˆ—ä¸­å¯æŸ¥è¯¢å­ä»£çš„èŒƒå›´ï¼Œå¦‚æœèŒƒå›´æ˜¯1ï¼Œåˆ™æ— å­ä»£ï¼Œå¦åˆ™ç»§ç»­æ’å…¥å­ä»£ éé€’å½’ç®—æ³• ä¸¤ä¸ªæ•°ç»„ï¼Œåˆ†åˆ«è®°å½•èŠ‚ç‚¹åœ¨å…ˆåºã€ååºåºåˆ—ä¸­çš„ä½ç½® queueä¿å­˜å½“å‰èŠ‚ç‚¹ä½ç½®ï¼Œä»¥åŠåœ¨å…ˆåºåºåˆ—ä¸­åä»£çš„èŒƒå›´ 1234567891011121314151617181920212223242526272829303132class Solution {public: TreeNode* constructFromPrePost(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; postorder) { int len = preorder.size(); TreeNode *root = new TreeNode(preorder[0]); queue&lt;tuple&lt;TreeNode*, int, int&gt;&gt; q; q.push(make_tuple(root, 0, len)); vector&lt;int&gt; pre_index(len+1), post_index(len+1); for(int i = 0; i &lt; len; i++) { pre_index[preorder[i]] = i; post_index[postorder[i]] = i; } while(!q.empty()) { auto [node, l, r] = q.front(); q.pop(); if(l+1 &gt;= r) continue; int left = pre_index[node-&gt;val] + 1, right = post_index[node-&gt;val] - 1; if(left &lt; len &amp;&amp; right &gt;= 0) { if(preorder[left] != postorder[right]) { node-&gt;left = new TreeNode(preorder[left]); node-&gt;right = new TreeNode(postorder[right]); q.emplace(node-&gt;left, left, pre_index[postorder[right]]); q.emplace(node-&gt;right, pre_index[postorder[right]], r); } else { node-&gt;left = new TreeNode(preorder[left]); q.emplace(node-&gt;left, left, r); } } } return root; }}; é€’å½’ç®—æ³•123456789101112131415161718192021222324252627282930class Solution { int len; void insertNode(TreeNode* node, int l, int r, vector&lt;int&gt; &amp;pre_index, vector&lt;int&gt; &amp;post_index, vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; postorder) { if(l+1 &gt;= r) return; int left = pre_index[node-&gt;val] + 1, right = post_index[node-&gt;val] - 1; if(left &lt; len &amp;&amp; right &gt;= 0) { if(preorder[left] != postorder[right]) { node-&gt;left = new TreeNode(preorder[left]); node-&gt;right = new TreeNode(postorder[right]); insertNode(node-&gt;left, left, pre_index[postorder[right]], pre_index, post_index, preorder, postorder); insertNode(node-&gt;right, pre_index[postorder[right]], r, pre_index, post_index, preorder, postorder); } else { node-&gt;left = new TreeNode(preorder[left]); insertNode(node-&gt;left, left, r, pre_index, post_index, preorder, postorder); } } }public: TreeNode* constructFromPrePost(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; postorder) { len = preorder.size(); TreeNode *root = new TreeNode(preorder[0]); vector&lt;int&gt; pre_index(len+1), post_index(len+1); for(int i = 0; i &lt; len; i++) { pre_index[preorder[i]] = i; post_index[postorder[i]] = i; } insertNode(root, 0, len, pre_index, post_index, preorder, postorder); return root; }}; é€’å½’åè€Œæ›´å¿«äº† 106. ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘123456789101112131415161718192021class Solution { TreeNode* addNode(int left, int right, vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int &amp;index, unordered_map&lt;int, int&gt;&amp; in_index) { if(left &gt;= right || index &lt; 0) return nullptr; int val = postorder[index]; TreeNode *node = new TreeNode(val); index--; node-&gt;right = addNode(in_index[val]+1, right, inorder, postorder, index, in_index); node-&gt;left = addNode(left, in_index[val], inorder, postorder, index, in_index); return node; }public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) { int len = inorder.size(); unordered_map&lt;int, int&gt; in_index; for(int i = 0; i &lt; len; i++) { in_index[inorder[i]] = i; } int index = len - 1; return addNode(0, len, inorder, postorder, index, in_index); }}; 105. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘12345678910111213141516171819202122class Solution { int len; TreeNode* addNode(int left, int right, vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int &amp;index, unordered_map&lt;int, int&gt;&amp; in_index) { if(left &gt;= right || index &gt;= len) return nullptr; int val = preorder[index]; TreeNode *node = new TreeNode(val); index++; node-&gt;left = addNode(left, in_index[val], preorder, inorder, index, in_index); node-&gt;right = addNode(in_index[val]+1, right, preorder, inorder, index, in_index); return node; }public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) { len = inorder.size(); unordered_map&lt;int, int&gt; in_index; for(int i = 0; i &lt; len; i++) { in_index[inorder[i]] = i; } int index = 0; return addNode(0, len, preorder, inorder, index, in_index); }}; 590. N å‰æ ‘çš„ååºéå†12345678910111213141516171819202122232425262728293031323334/*// Definition for a Node.class Node {public: int val; vector&lt;Node*&gt; children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector&lt;Node*&gt; _children) { val = _val; children = _children; }};*/class Solution { vector&lt;int&gt; res; void run_postorder(Node *root) { for(Node *child : root-&gt;children) { run_postorder(child); } res.push_back(root-&gt;val); }public: vector&lt;int&gt; postorder(Node* root) { if(root) run_postorder(root); return res; }}; 589. N å‰æ ‘çš„å‰åºéå†1234567891011121314class Solution { vector&lt;int&gt; res; void run_preorder(Node *root) { res.push_back(root-&gt;val); for(Node *child : root-&gt;children) { run_preorder(child); } }public: vector&lt;int&gt; preorder(Node* root) { if(root) run_preorder(root); return res; }}; 429. N å‰æ ‘çš„å±‚åºéå†123456789101112131415161718192021222324252627282930313233343536373839404142/*// Definition for a Node.class Node {public: int val; vector&lt;Node*&gt; children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector&lt;Node*&gt; _children) { val = _val; children = _children; }};*/class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) { vector&lt;vector&lt;int&gt;&gt; res; queue&lt;Node*&gt; q; if(root) q.push(root); while(!q.empty()) { vector&lt;int&gt; level; int q_size = q.size(); while(q_size--) { Node *node = q.front(); q.pop(); level.push_back(node-&gt;val); for(Node *child : node-&gt;children) { q.push(child); } } res.push_back(level); } return res; }}; 103. äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå†12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) { bool rev = false; vector&lt;vector&lt;int&gt;&gt; res; queue&lt;TreeNode*&gt; q; if(root) q.push(root); while(!q.empty()) { vector&lt;int&gt; level; int q_size = q.size(); while(q_size--) { TreeNode *node = q.front(); q.pop(); level.push_back(node-&gt;val); if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); } if(rev) { reverse(level.begin(), level.end()); } res.push_back(level); rev = !rev; } return res; }}; 123456789101112131415161718192021222324class Solution {public: vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) { bool rev = false; vector&lt;vector&lt;int&gt;&gt; res; queue&lt;TreeNode*&gt; q; if(root) q.push(root); while(!q.empty()) { int q_size = q.size(); int index = q_size; vector&lt;int&gt; level(q_size); while(index--) { TreeNode *node = q.front(); q.pop(); level[(rev ? index : q_size - index - 1)] = node-&gt;val; if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); } res.push_back(level); rev = !rev; } return res; }}; 107. äºŒå‰æ ‘çš„å±‚åºéå† II123456789101112131415161718192021222324252627282930class Solution { int depth(TreeNode *root) { return ( root == nullptr ? 0 : 1 + max(depth(root-&gt;left), depth(root-&gt;right)) ); }public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) { int dep = depth(root); vector&lt;vector&lt;int&gt;&gt; res(dep); queue&lt;TreeNode*&gt; q; if(root) q.push(root); while(!q.empty()) { int q_size = q.size(); int index = q_size; vector&lt;int&gt; level(q_size); while(index--) { TreeNode *node = q.front(); q.pop(); level[q_size - index - 1] = node-&gt;val; if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); } res[--dep] = level; } return res; }}; 102. äºŒå‰æ ‘çš„å±‚åºéå†12345678910111213141516171819202122class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; res; queue&lt;TreeNode*&gt; q; if(root) q.push(root); while(!q.empty()) { int q_size = q.size(); int index = q_size; res.push_back(vector&lt;int&gt;(q_size)); vector&lt;int&gt; &amp;level = res.back(); while(index--) { TreeNode *node = q.front(); q.pop(); level[q_size - index - 1] = node-&gt;val; if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); } } return res; }}; 987. äºŒå‰æ ‘çš„å‚åºéå† é¢˜ç›®çš„è¦æ±‚å¾ˆç¹çï¼Œéœ€è¦è¾“å‡ºäºŒç»´æ•°ç»„ï¼Œyåæ ‡ç›¸åŒçš„èŠ‚ç‚¹æ”¾åœ¨åŒä¸€æ•°ç»„å†… ä¸”éœ€è¦é«˜å±‚çš„æ”¾åœ¨åº•å±‚çš„åé¢ï¼ŒåŒå±‚çš„å°å€¼ä½äºå¤§å€¼å‰é¢ 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution { int cnt_range(TreeNode *root, int cur, int&amp; left_min, int&amp; right_max) { if(!root) return 0; int ldep = 0, rdep = 0; if(root-&gt;left) { left_min = min(left_min, cur - 1); ldep = cnt_range(root-&gt;left, cur-1, left_min, right_max); } if(root-&gt;right) { right_max = max(right_max, cur + 1); rdep = cnt_range(root-&gt;right, cur+1, left_min, right_max); } return 1 + max(ldep, rdep); }public: vector&lt;vector&lt;int&gt;&gt; verticalTraversal(TreeNode* root) { int left_min = 0, right_max = 0; int depth = cnt_range(root, 0, left_min, right_max); vector&lt;vector&lt;int&gt;&gt; ans(right_max - left_min + 1); vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; level_ans(right_max - left_min + 1, vector&lt;vector&lt;int&gt;&gt;(depth)); queue&lt;pair&lt;TreeNode*, int&gt;&gt; q; if(root) q.emplace(root, 0); int dep = 0; while(!q.empty()) { int q_size = q.size(); while(q_size--) { auto [node, y] = q.front(); q.pop(); level_ans[y-left_min][dep].push_back(node-&gt;val); if(node-&gt;left) q.emplace(node-&gt;left, y-1); if(node-&gt;right) q.emplace(node-&gt;right, y+1); } dep++; } for(int i = 0; i &lt; right_max - left_min + 1; i++) { for(int j = 0; j &lt; depth; j++) { sort(level_ans[i][j].begin(), level_ans[i][j].end()); for(int node : level_ans[i][j]) { ans[i].push_back(node); } } } return ans; }}; 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { int cnt_range(TreeNode *root, int cur, int&amp; left_min, int&amp; right_max) { if(!root) return 0; int ldep = 0, rdep = 0; if(root-&gt;left) { left_min = min(left_min, cur - 1); ldep = cnt_range(root-&gt;left, cur-1, left_min, right_max); } if(root-&gt;right) { right_max = max(right_max, cur + 1); rdep = cnt_range(root-&gt;right, cur+1, left_min, right_max); } return 1 + max(ldep, rdep); }public: vector&lt;vector&lt;int&gt;&gt; verticalTraversal(TreeNode* root) { int left_min = 0, right_max = 0; int depth = cnt_range(root, 0, left_min, right_max); vector&lt;vector&lt;int&gt;&gt; ans(right_max - left_min + 1); vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; level_ans(right_max - left_min + 1); queue&lt;pair&lt;TreeNode*, int&gt;&gt; q; if(root) q.emplace(root, 0); int dep = 0; while(!q.empty()) { int q_size = q.size(); while(q_size--) { auto [node, y] = q.front(); q.pop(); level_ans[y-left_min].emplace_back(dep, node-&gt;val); if(node-&gt;left) q.emplace(node-&gt;left, y-1); if(node-&gt;right) q.emplace(node-&gt;right, y+1); } dep++; } for(int i = 0; i &lt; right_max - left_min + 1; i++) { sort(level_ans[i].begin(), level_ans[i].end()); for(auto [_, node] : level_ans[i]) { ans[i].push_back(node); } } return ans; }}; 145. äºŒå‰æ ‘çš„ååºéå†é€’å½’1234567891011121314class Solution { void postorder(TreeNode *root, vector&lt;int&gt; &amp;vec) { if(!root) return; postorder(root-&gt;left, vec); postorder(root-&gt;right, vec); vec.push_back(root-&gt;val); }public: vector&lt;int&gt; postorderTraversal(TreeNode* root) { vector&lt;int&gt; res; postorder(root, res); return res; }}; éé€’å½’ åœ¨ä¸­åºéå†çš„åŸºç¡€ä¸Šæ”¹é€  å¯¹äºå½“å‰èŠ‚ç‚¹ï¼ŒæŒç»­å‘å·¦èµ°å‹æ ˆï¼Œç›´åˆ°æ— æ³•å¾€å·¦èµ° æ­¤æ—¶æ ˆé¡¶èŠ‚ç‚¹çš„å·¦å­æ ‘è®¿é—®ç»“æŸï¼Œè¾“å‡ºæ ˆé¡¶å…ƒç´  è‹¥å³å­æ ‘ä¸ºç©ºï¼Œåˆ™æ ˆé¡¶å…ƒç´ çš„å³å­æ ‘è®¿é—®å®Œæˆï¼Œå¯ä»¥å°†è¯¥å…ƒç´ å¼¹å‡ºæ ˆ è‹¥å³å­æ ‘ä¸ä¸ºç©ºï¼Œè€ƒè™‘è¯¥å³å­æ ‘æ˜¯å¦æ˜¯åˆšæ‰è®¿é—®è¿‡çš„ï¼Œé€šè¿‡prevè®°å½•ä¸Šä¸€ä¸ªè¾“å‡ºçš„èŠ‚ç‚¹ è‹¥preväºå½“å‰å…ƒç´ çš„rightç›¸åŒï¼Œåˆ™å½“å‰èŠ‚ç‚¹å·²ç»è®¿é—®è¿‡å³å­æ ‘ï¼Œè¾“å‡ºå½“å‰èŠ‚ç‚¹ è‹¥preväºå½“å‰å…ƒç´ çš„rightä¸åŒï¼Œåˆ™å½“å‰èŠ‚ç‚¹å˜æˆå³å­æ ‘ æ­¤æ—¶æ ˆé¡¶å…ƒç´ çš„å·¦å­æ ‘èŠ‚ç‚¹è®¿é—®ç»“æŸï¼Œå³é‡å¤ç¬¬äºŒæ­¥123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; postorderTraversal(TreeNode* root) { vector&lt;int&gt; res; stack&lt;TreeNode *&gt; s; TreeNode *cur = root, *prev = nullptr; while(!s.empty() || cur) { while(cur) { s.push(cur); cur = cur-&gt;left; } cur = s.top(); if(cur-&gt;right &amp;&amp; cur-&gt;right != prev) { cur = cur-&gt;right; } else { prev = cur; s.pop(); res.push_back(cur-&gt;val); cur = nullptr; } } return res; }}; 144. äºŒå‰æ ‘çš„å‰åºéå†é€’å½’1234567891011121314class Solution { void preorder(TreeNode *root, vector&lt;int&gt;&amp; ans) { if(!root) return; ans.push_back(root-&gt;val); preorder(root-&gt;left, ans); preorder(root-&gt;right, ans); }public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; ans; preorder(root, ans); return ans; }}; éé€’å½’12345678910111213141516class Solution {public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; ans; stack&lt;TreeNode*&gt; s; if(root) s.push(root); while(!s.empty()) { TreeNode *node = s.top(); s.pop(); ans.push_back(node-&gt;val); if(node-&gt;right) s.push(node-&gt;right); if(node-&gt;left) s.push(node-&gt;left); } return ans; }}; 94. äºŒå‰æ ‘çš„ä¸­åºéå†é€’å½’1234567891011121314class Solution { void inorder(TreeNode *root, vector&lt;int&gt;&amp; ans) { if(!root) return; inorder(root-&gt;left, ans); ans.push_back(root-&gt;val); inorder(root-&gt;right, ans); }public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; ans; inorder(root, ans); return ans; }}; éé€’å½’ å¯¹äºå½“å‰èŠ‚ç‚¹ï¼ŒæŒç»­å‘å·¦èµ°å‹æ ˆï¼Œç›´åˆ°æ— æ³•å¾€å·¦èµ° æ­¤æ—¶æ ˆé¡¶èŠ‚ç‚¹çš„å·¦å­æ ‘è®¿é—®ç»“æŸ å°†å³å­æ ‘å˜æˆå½“å‰å…ƒç´ ï¼Œè‹¥å³å­æ ‘ä¸ºç©ºï¼Œåˆ™æ ˆé¡¶å…ƒç´ çš„å³å­æ ‘è®¿é—®å®Œæˆï¼Œå¯ä»¥å°†è¯¥å…ƒç´ å¼¹å‡ºæ ˆ æ­¤æ—¶æ ˆé¡¶å…ƒç´ çš„å·¦å­æ ‘èŠ‚ç‚¹è®¿é—®ç»“æŸï¼Œå³é‡å¤ç¬¬äºŒæ­¥ 12345678910111213141516171819class Solution {public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; ans; stack&lt;TreeNode *&gt; s; TreeNode *cur = root; while(!s.empty() || cur) { while(cur) { s.push(cur); cur = cur-&gt;left; } cur = s.top(); s.pop(); ans.push_back(cur-&gt;val); cur = cur-&gt;right; } return ans; }}; 236. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆac12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { stack&lt;TreeNode*&gt; findTreeNode(TreeNode *root, TreeNode *target) { stack&lt;TreeNode *&gt; s; TreeNode *cur = root, *prev = nullptr; while(!s.empty() || cur) { while(cur) { s.push(cur); cur = cur-&gt;left; } cur = s.top(); if(cur-&gt;right &amp;&amp; prev != cur-&gt;right) { cur = cur-&gt;right; } else { prev = cur; if(cur == target) break; s.pop(); cur = nullptr; } } stack&lt;TreeNode *&gt; ans; while(!s.empty()) { ans.push(s.top()); s.pop(); } return ans; }public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { stack&lt;TreeNode *&gt; pstack = findTreeNode(root, p); stack&lt;TreeNode *&gt; qstack = findTreeNode(root, q); TreeNode *ans = nullptr; while(!pstack.empty() &amp;&amp; !qstack.empty()) { if(pstack.top() == qstack.top()) { ans = pstack.top(); pstack.pop(); qstack.pop(); } else { break; } } return ans; }}; ååºéå†æ—¶ï¼Œå¦‚æœæ‰¾åˆ°ç›®æ ‡èŠ‚ç‚¹ï¼Œé‚£ä¹ˆå½“å‰æ ˆå°±æ˜¯æ‰€æœ‰ç¥–å…ˆ å¯¹æ¯”ä¸¤ä¸ªæ ˆï¼Œæ‰¾åˆ°æœ€è¿‘çš„ç¥–å…ˆ ä¼˜åŒ– å‡å°‘ä¸€æ¬¡éå†123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution { stack&lt;TreeNode*&gt; rev(stack&lt;TreeNode*&gt; s) { stack&lt;TreeNode*&gt; ans; while(!s.empty()) { ans.push(s.top()); s.pop(); } return ans; } void findTreeNode(TreeNode *root, TreeNode *p, TreeNode *q, stack&lt;TreeNode*&gt;&amp; pstack, stack&lt;TreeNode*&gt;&amp; qstack) { stack&lt;TreeNode *&gt; s; TreeNode *cur = root, *prev = nullptr; bool findp = false, findq = false; while(!s.empty() || cur) { while(cur) { s.push(cur); cur = cur-&gt;left; } cur = s.top(); if(cur-&gt;right &amp;&amp; prev != cur-&gt;right) { cur = cur-&gt;right; } else { prev = cur; if(cur == p) { pstack = rev(s); findp = true; } if(cur == q) { qstack = rev(s); findq = true; } if(findp &amp;&amp; findq) break; s.pop(); cur = nullptr; } } }public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { stack&lt;TreeNode *&gt; pstack, qstack; findTreeNode(root, p, q, pstack, qstack); TreeNode *ans = nullptr; while(!pstack.empty() &amp;&amp; !qstack.empty()) { if(pstack.top() == qstack.top()) { ans = pstack.top(); pstack.pop(); qstack.pop(); } else { break; } } return ans; }}; ç»§ç»­ä¼˜åŒ–éé€’å½’ å‚è€ƒçš„ä»£ç æ˜¯é€’å½’çš„ï¼Œæˆ‘æ”¹æˆéé€’å½’çš„ 123456789101112131415161718192021222324252627282930313233343536373839class Solution { TreeNode *ans = nullptr;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { stack&lt;tuple&lt;TreeNode *, bool, bool&gt;&gt; s; TreeNode *cur = root, *prev = nullptr; while(!s.empty() || cur) { while(cur) { s.emplace(cur, false, false); cur = cur-&gt;left; } auto [node, findp, findq] = s.top(); cur = node; // è¿™é‡Œå¤šåˆ›å»ºä¸€ä¸ªnode if(cur-&gt;right &amp;&amp; prev != cur-&gt;right) { cur = cur-&gt;right; } else { if(cur == p) { findp = true; } if(cur == q) { findq = true; } if(findp &amp;&amp; findq &amp;&amp; ans == nullptr) { ans = cur; break; } s.pop(); if(!s.empty() &amp;&amp; (findp || findq)) { auto &amp;[_, last_findp, last_findq] = s.top(); last_findp = last_findp || findp; last_findq = last_findq || findq; } prev = cur; cur = nullptr; } } return ans; }}; ä¸ç”¨å¼•ç”¨ä¼šå¿«ä¸€ç‚¹ 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution { TreeNode *ans = nullptr;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { stack&lt;tuple&lt;TreeNode *, bool, bool&gt;&gt; s; TreeNode *cur = root, *prev = nullptr; while(!s.empty() || cur) { while(cur) { s.emplace(cur, false, false); cur = cur-&gt;left; } auto [node, findp, findq] = s.top(); cur = node; if(cur-&gt;right &amp;&amp; prev != cur-&gt;right) { cur = cur-&gt;right; } else { if(cur == p) { findp = true; } if(cur == q) { findq = true; } if(findp &amp;&amp; findq &amp;&amp; ans == nullptr) { ans = cur; break; } s.pop(); if(!s.empty() &amp;&amp; (findp || findq)) { auto [last, last_findp, last_findq] = s.top(); s.pop(); last_findp = last_findp || findp; last_findq = last_findq || findq; s.emplace(last, last_findp, last_findq); } prev = cur; cur = nullptr; } } return ans; }}; é€’å½’123456789101112131415161718192021222324252627282930313233class Solution { TreeNode *ans = nullptr; void dfs(TreeNode *cur, TreeNode *p, TreeNode *q, bool&amp; last_findp, bool &amp;last_findq) { bool findp = false, findq = false; if(cur == p) { findp = true; } if(cur == q) { findq = true; } if(cur-&gt;left) { dfs(cur-&gt;left, p, q, last_findp, last_findq); findp = last_findp || findp; findq = last_findq || findq; } if(cur-&gt;right) { dfs(cur-&gt;right, p, q, last_findp, last_findq); findp = last_findp || findp; findq = last_findq || findq; } last_findp = findp; last_findq = findq; if(findp &amp;&amp; findq &amp;&amp; ans == nullptr) { ans = cur; } }public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { bool findp = false, findq = false; dfs(root, p, q, findp, findq); return ans; }}; é¿å…stlä¼šå¿« 993. äºŒå‰æ ‘çš„å ‚å…„å¼ŸèŠ‚ç‚¹éé€’å½’12345678910111213141516171819202122232425262728293031323334353637class Solution {public: bool isCousins(TreeNode* root, int x, int y) { TreeNode *xFather = nullptr, *yFather = nullptr; int xDepth = 0, yDepth = 0; bool findX = false, findY = false; TreeNode* s[101] = {nullptr}; int stack_ptr = 0; TreeNode *cur = root, *prev = nullptr; while(!(stack_ptr==0) || cur) { while(cur) { s[stack_ptr++] = cur; cur = cur-&gt;left; } cur = s[stack_ptr-1]; if(cur-&gt;right &amp;&amp; cur-&gt;right != prev) { cur = cur-&gt;right; } else { if(cur-&gt;val == x) { xFather = stack_ptr-2 &gt;= 0 ? s[stack_ptr-2] : nullptr;; xDepth = stack_ptr; findX = true; } if(cur-&gt;val == y) { yFather = stack_ptr-2 &gt;= 0 ? s[stack_ptr-2] : nullptr;; yDepth = stack_ptr; findY = true; } if(findX &amp;&amp; findY) break; stack_ptr--; prev = cur; cur = nullptr; } } return xFather &amp;&amp; yFather &amp;&amp; xFather != yFather &amp;&amp; xDepth == yDepth; }}; é€’å½’12345678910111213141516171819202122class Solution { int xDepth = 0, yDepth = 0; TreeNode *xFather = nullptr, *yFather = nullptr; void postorder(TreeNode *root, TreeNode *parent, int x, int y, int dep) { if(!root) return; postorder(root-&gt;left, root, x, y, dep+1); postorder(root-&gt;right, root, x, y, dep+1); if(root-&gt;val == x) { xDepth = dep; xFather = parent; } if(root-&gt;val == y) { yDepth = dep; yFather = parent; } }public: bool isCousins(TreeNode* root, int x, int y) { postorder(root, nullptr, x, y, 0); return xFather &amp;&amp; yFather &amp;&amp; xFather != yFather &amp;&amp; xDepth == yDepth; }}; leetcodeçœŸå¥‡æ€ªï¼Œé€’å½’ç®—æ³•åè€Œä¼šæ›´å¿« 2641. äºŒå‰æ ‘çš„å ‚å…„å¼ŸèŠ‚ç‚¹ IIac12345678910111213141516171819202122232425262728293031class Solution {public: TreeNode* replaceValueInTree(TreeNode* root) { if(!root) return nullptr; queue&lt;pair&lt;TreeNode*, TreeNode*&gt;&gt; q; q.emplace(root, nullptr); while(!q.empty()) { vector&lt;pair&lt;TreeNode *, TreeNode *&gt;&gt; level; int q_size = q.size(), level_sum = 0; int q_size_cnt = q_size; while(q_size_cnt--) { auto [node, p] = q.front(); q.pop(); level_sum += node-&gt;val; level.emplace_back(node, p); if(node-&gt;left) q.emplace(node-&gt;left, node); if(node-&gt;right) q.emplace(node-&gt;right, node); } for(int i = 0; i &lt; q_size;) { if(i + 1 &lt; q_size &amp;&amp; level[i].second == level[i+1].second) { level[i].first-&gt;val = level[i+1].first-&gt;val = level_sum - level[i].first-&gt;val - level[i+1].first-&gt;val; i += 2; } else { level[i].first-&gt;val = level_sum - level[i].first-&gt;val; i += 1; } } } return root; }}; ä¼˜åŒ– å±‚æ¬¡éå† è®¡ç®—å­èŠ‚ç‚¹ï¼ˆä¸‹ä¸€å±‚èŠ‚ç‚¹ï¼‰çš„å’Œ çˆ¶èŠ‚ç‚¹å¯¹å­èŠ‚ç‚¹ä¿®æ”¹ï¼Œæ”¹ä¸ºä¸¤å…„å¼Ÿä¹‹å’Œ è·å¾—å½“å‰å±‚çš„å’Œï¼ˆprev_level_sumï¼‰ï¼Œå°†å½“å‰èŠ‚ç‚¹å€¼(node-&gt;val)æ”¹ä¸ºprev_level_sum - node-&gt;val 1234567891011121314151617181920212223242526272829303132class Solution {public: TreeNode* replaceValueInTree(TreeNode* root) { if(!root) return nullptr; queue&lt;TreeNode*&gt; q; q.push(root); int prev_level_sum = root-&gt;val; int q_size = 1; while(q_size &gt; 0) { int level_sum = 0; while(q_size--) { auto node = q.front(); q.pop(); if(node-&gt;left) { q.push(node-&gt;left); level_sum += node-&gt;left-&gt;val; } if(node-&gt;right) { q.push(node-&gt;right); level_sum += node-&gt;right-&gt;val; } if(node-&gt;left &amp;&amp; node-&gt;right) { node-&gt;left-&gt;val = node-&gt;right-&gt;val = node-&gt;left-&gt;val + node-&gt;right-&gt;val; } node-&gt;val = prev_level_sum - node-&gt;val; } prev_level_sum = level_sum; q_size = q.size(); } return root; }};","link":"/home/2023/12/25/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9331/"},{"title":"LeetCode-35","text":"518. é›¶é’±å…‘æ¢ II1234567891011121314class Solution {public: int change(int amount, vector&lt;int&gt;&amp; coins) { int n = coins.size(); vector&lt;int&gt; dp(amount+1); dp[0] = 1; for(int i = 1; i &lt;= n; i++) { for(int j = coins[i-1]; j &lt;= amount; j++) { dp[j] += dp[j-coins[i-1]]; } } return dp[amount]; }}; 322. é›¶é’±å…‘æ¢123456789101112131415class Solution {public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { int n = coins.size(); vector&lt;int&gt; dp(amount + 1, INT_MAX); dp[0] = 0; for(int i = 1; i &lt;= n; i++) { for(int j = coins[i-1]; j &lt;= amount; j++) { if(dp[j - coins[i-1]] != INT_MAX) dp[j] = min(dp[j], dp[j - coins[i-1]] + 1); } } return dp[amount] == INT_MAX ? -1 : dp[amount]; }}; 25. K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨ å•Šï¼ŸçœŸçš„æ˜¯å›°éš¾å— 12345678910111213141516171819202122232425262728293031class Solution { int listLen(ListNode *head) { int n = 0; while(head) { n++; head = head-&gt;next; } return n; }public: ListNode* reverseKGroup(ListNode* head, int k) { ListNode dummy, *move = &amp;dummy, *next = head; int n = listLen(head); for(int j = 0; j + k &lt;= n; j+=k) { next = head; for(int i = 0; i &lt; k; i++) { ListNode *tmp = head; head = head-&gt;next; tmp-&gt;next = move-&gt;next; move-&gt;next = tmp; } move = next; } while(head) { move-&gt;next = head; move = head; head = head-&gt;next; } return dummy.next; }}; 2642. è®¾è®¡å¯ä»¥æ±‚æœ€çŸ­è·¯å¾„çš„å›¾ç±»1234567891011121314151617181920212223242526272829303132333435363738class Graph { int n; vector&lt;vector&lt;int&gt;&gt; dist;public: Graph(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) : n(n), dist(n, vector&lt;int&gt;(n, INT_MAX &gt;&gt; 1)) { for(auto&amp; edge : edges) { dist[edge[0]][edge[1]] = edge[2]; } for(int w = 0; w &lt; n; w++) { dist[w][w] = 0; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { dist[i][j] = min(dist[i][j], dist[i][w] + dist[w][j]); } } } } void addEdge(vector&lt;int&gt; edge) { if(dist[edge[0]][edge[1]] &lt;= edge[2]) return; dist[edge[0]][edge[1]] = edge[2]; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { dist[i][j] = min(dist[i][j], dist[i][edge[0]] + dist[edge[0]][j]); } } for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { dist[i][j] = min(dist[i][j], dist[i][edge[1]] + dist[edge[1]][j]); } } } int shortestPath(int node1, int node2) { return dist[node1][node2] == (INT_MAX &gt;&gt; 1) ? -1 : dist[node1][node2]; }}; ç”¨è¾¹æ›´æ–° 12345678910111213141516171819202122232425262728293031323334353637383940class Graph { int n; vector&lt;vector&lt;int&gt;&gt; dist;public: Graph(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) : n(n), dist(n, vector&lt;int&gt;(n, INT_MAX &gt;&gt; 2)) { for(auto&amp; edge : edges) { dist[edge[0]][edge[1]] = edge[2]; } for(int w = 0; w &lt; n; w++) { dist[w][w] = 0; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { dist[i][j] = min(dist[i][j], dist[i][w] + dist[w][j]); } } } } void addEdge(vector&lt;int&gt; edge) { if(dist[edge[0]][edge[1]] &lt;= edge[2]) return; dist[edge[0]][edge[1]] = edge[2]; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { dist[i][j] = min(dist[i][j], dist[i][edge[0]] + dist[edge[1]][j] + edge[2]); } } } int shortestPath(int node1, int node2) { return dist[node1][node2] == (INT_MAX &gt;&gt; 2) ? -1 : dist[node1][node2]; }};/** * Your Graph object will be instantiated and called as such: * Graph* obj = new Graph(n, edges); * obj-&gt;addEdge(edge); * int param_2 = obj-&gt;shortestPath(node1,node2); */ æœ€å¿«çš„è¿˜æ˜¯æ¯æ¬¡æ±‚æœ€çŸ­è·¯æ—¶dijkstraç°ç®— 93. å¤åŸ IP åœ°å€ ç”¨dotsæ•°ç»„è¡¨ç¤ºåœ¨å­—ç¬¦ä¸²ä½ç½®iåé¢åŠ ç‚¹.ï¼ŒåŠ å…¥å››ä¸ªç‚¹åï¼Œä¸”ç¬¬å››ä¸ªç‚¹åœ¨æœ€å¥½ä¸€ä¸ªå­—ç¬¦åé¢ï¼Œå°±æ˜¯åˆæ³•çš„ å¦‚æœé‡åˆ°0ï¼Œåªèƒ½åœ¨å…¶ååŠ ä¸€ä¸ªç‚¹ï¼Œä¸è€ƒè™‘æœ‰å‰å¯¼0 1234567891011121314151617181920212223242526272829303132333435class Solution {public: vector&lt;string&gt; restoreIpAddresses(string s) { vector&lt;string&gt; ans; int dots[4] = {-1}; int len = s.length(); function&lt;void(int, int)&gt; dfs = [&amp;](int i, int n) { if(n == 4) { if(dots[3] == len - 1) ans.push_back( s.substr(0, dots[0] + 1) + &quot;.&quot; + s.substr(dots[0] + 1, dots[1] - dots[0]) + &quot;.&quot; + s.substr(dots[1] + 1, dots[2] - dots[1]) + &quot;.&quot; + s.substr(dots[2] + 1, len - dots[2] - 1)); return; } if(s[i] == '0') { dots[n] = i; dfs(i+1, n+1); return; } int x = 0; for(int j = i; j &lt; len; j++) { x *= 10; x += s[j] - '0'; if(s[j] &gt; '9' || s[j] &lt; '0') break; if(x &gt; 255 || x &lt; 0) break; dots[n] = j; dfs(j+1, n+1); } }; dfs(0, 0); return ans; }}; 96. ä¸åŒçš„äºŒå‰æœç´¢æ ‘ å‡è®¾iä¸ºå½“å‰æ ¹èŠ‚ç‚¹ï¼Œå°†æ•°ç»„åˆ†æˆä¸¤éƒ¨åˆ†ï¼Œä¸€éƒ¨åˆ†æ˜¯å·¦å­æ ‘ï¼Œä¸€éƒ¨åˆ†æ˜¯å³å­æ ‘å­æ ‘é‡å¤ä¸Šé¢çš„æ“ä½œå†åŠ ä¸Šè®°å¿†ä¼˜åŒ– 123456789101112131415161718class Solution { vector&lt;vector&lt;int&gt;&gt; mem; int numTrees(int l, int r) { if(mem[l][r] != -1) return mem[l][r]; if(l &gt;= r) return 1; int ans = 0; for(int i = l; i &lt; r; i++) { ans += numTrees(l, i) * numTrees(i+1, r); } mem[l][r] = ans; return ans; }public: int numTrees(int n) { mem = vector&lt;vector&lt;int&gt;&gt;(n+1, vector&lt;int&gt;(n+1, -1)); return numTrees(0, n); }}; 95. ä¸åŒçš„äºŒå‰æœç´¢æ ‘ II è¿”å›å€¼è¿”å›æ‰€æœ‰å¯èƒ½çš„æ ‘çš„æƒ…å†µ 1234567891011121314151617181920class Solution { vector&lt;TreeNode*&gt; findAllBST(int l, int r) { if(l &gt;= r) return { nullptr }; vector&lt;TreeNode*&gt; trees; for(int i = l; i &lt; r; i++) { vector&lt;TreeNode*&gt; leftTree = findAllBST(l, i); vector&lt;TreeNode*&gt; rightTree = findAllBST(i+1, r); for(TreeNode *left : leftTree) { for(TreeNode *right : rightTree) { trees.push_back(new TreeNode(i, left, right)); } } } return trees; }public: vector&lt;TreeNode*&gt; generateTrees(int n) { return findAllBST(1, n + 1); }}; 97. äº¤é”™å­—ç¬¦ä¸² dp123456789101112131415161718192021class Solution {public: bool isInterleave(string s1, string s2, string s3) { int n1 = s1.length(), n2 = s2.length(); if(s3.length() != n1 + n2) return false; vector&lt;vector&lt;bool&gt;&gt; dp(n1+1, vector&lt;bool&gt;(n2+1, false)); dp[0][0] = true; for(int i = 1; i &lt;= n1; i++) { dp[i][0] = dp[i-1][0] &amp;&amp; s1[i-1] == s3[i-1]; } for(int i = 1; i &lt;= n2; i++) { dp[0][i] = dp[0][i-1] &amp;&amp; s2[i-1] == s3[i-1]; } for(int i = 1; i &lt;= n1; i++) { for(int j = 1; j &lt;= n2; j++) { dp[i][j] = dp[i][j] || (s1[i-1] == s3[i + j - 1] &amp;&amp; dp[i-1][j]) || (s2[j-1] == s3[i + j - 1] &amp;&amp; dp[i][j-1]); } } return dp[n1][n2]; }}; 98. éªŒè¯äºŒå‰æœç´¢æ ‘1234567891011class Solution { bool isValidBST(TreeNode* root, long long l, long long r) { if(!root) return true; if(root-&gt;val &lt;= l || root-&gt;val &gt;= r) return false; return isValidBST(root-&gt;left, l, root-&gt;val) &amp;&amp; isValidBST(root-&gt;right, root-&gt;val, r); }public: bool isValidBST(TreeNode* root) { return isValidBST(root, LLONG_MIN, LLONG_MAX); }}; 99. æ¢å¤äºŒå‰æœç´¢æ ‘123456789101112131415161718192021222324252627class Solution { vector&lt;TreeNode*&gt; arr; void midOrder(TreeNode *root) { if(!root) return; midOrder(root-&gt;left); arr.push_back(root); midOrder(root-&gt;right); }public: void recoverTree(TreeNode* root) { midOrder(root); int n = arr.size(); int x = 0; for(int i = 0; i &lt; n - 1; i++) { if(arr[i]-&gt;val &gt; arr[i+1]-&gt;val) { x = i; break; } } for(int i = n-1; i &gt; 0; i--) { if(arr[i]-&gt;val &lt; arr[i-1]-&gt;val) { swap(arr[i]-&gt;val, arr[x]-&gt;val); break; } } }}; O(1)ç©ºé—´ 12345678910111213141516171819202122232425class Solution { TreeNode* prev = nullptr; TreeNode* node1 = nullptr; TreeNode* node2 = nullptr; void midOrder(TreeNode *root) { if(!root) return; midOrder(root-&gt;left); if(prev &amp;&amp; root-&gt;val &lt; prev-&gt;val) { if(node1 == nullptr &amp;&amp; node2 == nullptr) { node1 = prev; node2 = root; } else { node2 = root; return; } } prev = root; midOrder(root-&gt;right); }public: void recoverTree(TreeNode* root) { midOrder(root); swap(node1-&gt;val, node2-&gt;val); }}; 51. N çš‡å é€’å½’ï¼Œç”¨å››ä¸ªæ•°ç»„è¡¨ç¤ºå½“å‰è¡Œåˆ—ä¸»å¯¹è§’çº¿ä¸Šæ˜¯å¦æœ‰çš‡å æŒ‘é€‰å››ä¸ªæ–¹å‘éƒ½æ²¡æœ‰çš‡åçš„æ ¼å­æ”¾ç½®çš‡å 12345678910111213141516171819202122232425class Solution {public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) { vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; cur(n, string(n, '.')); vector&lt;bool&gt; col(n, false), row(n, false), main_diag((n &lt;&lt; 1) - 1, false), sub_diag((n &lt;&lt; 1) - 1, false); function&lt;void(int)&gt; dfs = [&amp;](int i) { if(i == n) { res.push_back(cur); return; } for(int j = 0; j &lt; n; j++) { if(!row[i] &amp;&amp; !col[j] &amp;&amp; !main_diag[i - j + n - 1] &amp;&amp; !sub_diag[i + j]) { cur[i][j] = 'Q'; row[i] = col[j] = main_diag[i - j + n - 1] = sub_diag[i + j] = true; dfs(i+1); row[i] = col[j] = main_diag[i - j + n - 1] = sub_diag[i + j] = false; cur[i][j] = '.'; } } }; dfs(0); return res; }}; 52. N çš‡å II123456789101112131415161718192021222324class Solution { int const static constexpr MAX_N = 10; int const static constexpr MAX_DIAG = (MAX_N &lt;&lt; 1) - 1;public: int totalNQueens(int n) { int res = 0; bool col[MAX_N] = {false}, row[MAX_N] = {false}, main_diag[MAX_DIAG] = {false}, sub_diag[MAX_DIAG] = {false}; function&lt;void(int)&gt; dfs = [&amp;](int i) { if(i == n) { res++; return; } for(int j = 0; j &lt; n; j++) { if(!row[i] &amp;&amp; !col[j] &amp;&amp; !main_diag[i - j + n - 1] &amp;&amp; !sub_diag[i + j]) { row[i] = col[j] = main_diag[i - j + n - 1] = sub_diag[i + j] = true; dfs(i+1); row[i] = col[j] = main_diag[i - j + n - 1] = sub_diag[i + j] = false; } } }; dfs(0); return res; }}; 2580. ç»Ÿè®¡å°†é‡å åŒºé—´åˆå¹¶æˆç»„çš„æ–¹æ¡ˆæ•° è¦æ±‚å°†åŒºé—´åˆ†æˆä¸¤ç»„ï¼Œä¸”ç›¸äº’é‡å çš„åŒºé—´åœ¨åŒä¸€ç»„ æ•°ä¸€ä¸‹æŒ‰ç…§æ˜¯å¦é‡å åŒºåˆ†ï¼Œä¸€å…±èƒ½åˆ†æˆå¤šå°‘ç»„ ç„¶åå°±æ˜¯å¯¹è¿™äº›ç»„æ’åˆ—ç»„åˆ å¯¹åŒºé—´æ’åºï¼Œè‹¥é‡å åˆ™ä¸æ–­æ‰©å¤§å½“å‰åˆ†ç»„èŒƒå›´ï¼Œå¦åˆ™é‡åˆ°æ–°çš„ä¸ä¸ä¹‹å‰é‡å çš„åŒºé—´ 12345678910111213141516171819202122232425262728293031323334353637class Solution { const static int MOD = 1000000000 + 7; int fastPow2(int n) { long long base = 2; long long ans = 1; while(n) { if(n &amp; 1) ans = (ans * base) % MOD; base = (base * base) % MOD; n &gt;&gt;= 1; } return ans; }public: int countWays(vector&lt;vector&lt;int&gt;&gt;&amp; ranges) { sort(ranges.begin(), ranges.end(), [](const vector&lt;int&gt;&amp; x, const vector&lt;int&gt;&amp; y) { if(x[0] != y[0]) return x[0] &lt; y[0]; return x[1] &lt; y[1]; }); int rangesCnt = 0; pair&lt;int, int&gt; curRange = make_pair(ranges[0][0], ranges[0][1]); for(const vector&lt;int&gt;&amp; v : ranges) { if(v[0] &gt;= curRange.first &amp;&amp; v[0] &lt;= curRange.second) { curRange.second = max(v[1], curRange.second); } else if(v[1] &gt;= curRange.first &amp;&amp; v[1] &lt;= curRange.second) { curRange.first = max(v[0], curRange.first); } else if(v[0] &gt;= curRange.first &amp;&amp; v[1] &lt;= curRange.second) { } else if (v[0] &lt;= curRange.first &amp;&amp; v[1] &gt;= curRange.second) { curRange.first = v[0]; curRange.second = v[1]; } else { rangesCnt++; curRange = make_pair(v[0], v[1]); } } return fastPow2(++rangesCnt); }}; 40. ç»„åˆæ€»å’Œ II39. ç»„åˆæ€»å’Œæ˜¯æ¯ä¸ªæ•°ä¸é™åˆ¶ä½¿ç”¨æ¬¡æ•°ï¼Œæ•°å­—ä¸é‡å¤ï¼Œè¿™é“é¢˜æ˜¯æ•°å­—å¯èƒ½é‡å¤ä½†æ˜¯æ¯ä¸ªæ•°åªèƒ½ç”¨ä¸€æ¬¡ ç”¨ç›¸åŒçš„æ–¹æ³•æš´æœï¼Œä½†æ˜¯è¦åŠ ä¸Šä¸ªæ•°ä¸Šé™ 12345678910111213141516171819202122232425262728293031323334353637class Solution {public: int n; int target; vector&lt;vector&lt;int&gt;&gt; res; unordered_map&lt;int, int&gt; cnt; vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) { this-&gt;target = target; n = 0; for(int candidate : candidates) { cnt[candidate]++; } candidates = vector&lt;int&gt;(); for(auto ite : cnt) { candidates.push_back(ite.first); n++; } vector&lt;int&gt; vec; search(0, 0, vec, candidates); return res; } void search(int index, int sum, vector&lt;int&gt; &amp; vec, const vector&lt;int&gt;&amp; candidates) { if(sum == target) { res.push_back(vec); return; } if(index &gt;= n || sum &gt; target) return; vec.push_back(candidates[index]); cnt[candidates[index]]--; if(cnt[candidates[index]] &gt;= 0) search(index, sum+candidates[index], vec, candidates); cnt[candidates[index]]++; vec.pop_back(); if(index + 1 &lt; n) { search(index+1, sum, vec, candidates); } }};","link":"/home/2024/03/25/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9335/"},{"title":"LeetCode-34","text":"2789. åˆå¹¶åæ•°ç»„ä¸­çš„æœ€å¤§å…ƒç´ 1234567891011121314151617class Solution {public: long long maxArrayValue(vector&lt;int&gt;&amp; nums) { int n = nums.size(); long long ans = nums[n-1]; long long curSum = nums[n-1]; for(int i = n - 2; i &gt;= 0; i--) { if(nums[i] &lt;= curSum) { curSum += nums[i]; } else { curSum = nums[i]; } ans = max(ans, curSum); } return ans; }}; 2864. æœ€å¤§äºŒè¿›åˆ¶å¥‡æ•° ä¸€æ¬¡éå†åŸåœ°ç®—æ³• 12345678910111213141516class Solution {public: string maximumOddBinaryNumber(string&amp; s) { int len = s.length(); int index = 0; for(int i = 0; i &lt; len; i++) { if(s[i] == '1') { s[i] = '0'; s[index++] = '1'; } } s[index-1] = '0'; s[len-1] = '1'; return s; }}; 1261. åœ¨å—æ±¡æŸ“çš„äºŒå‰æ ‘ä¸­æŸ¥æ‰¾å…ƒç´ ä¸è¦é¢å¤–å­˜å‚¨ï¼Œä¸ç”¨æ¢å¤èŠ‚ç‚¹å€¼ ç”¨å¯¹åº”æ»¡äºŒå‰æ ‘çš„æ ‡å·æ ‡è®°index åˆ¤æ–­è¦æŸ¥çš„æ ‘åœ¨ç¬¬å‡ å±‚ï¼Œå°†æ ‡å·è½¬ä¸º0,1,2,3,â€¦ äºŒè¿›åˆ¶ä½å°±æ˜¯æœç´¢æ–¹å‘ï¼Œæ‰¾åˆ°nullå°±æ˜¯ä¸å­˜åœ¨ï¼Œæ‰¾åˆ°èŠ‚ç‚¹å°±æ˜¯å­˜åœ¨ 1234567891011121314151617181920212223242526272829303132333435363738394041424344class FindElements { TreeNode* root; // set&lt;int&gt; s; // void dfs(TreeNode * root) { // s.insert(root-&gt;val); // if(root-&gt;left) { // root-&gt;left-&gt;val = (root-&gt;val &lt;&lt; 1) + 1; // dfs(root-&gt;left); // } // if(root-&gt;right) { // root-&gt;right-&gt;val = (root-&gt;val &lt;&lt; 1) + 2; // dfs(root-&gt;right); // } // }public: FindElements(TreeNode* root) : root(root) { // if(!root) return; // root-&gt;val = 0; // dfs(root); } bool find(int target) { // return s.count(target) != 0; int mask = 1, x = target + 1; while(x) { x &gt;&gt;= 1; mask &lt;&lt;= 1; } mask &gt;&gt;= 1; TreeNode *node = root; int n = target - mask + 1; mask &gt;&gt;= 1; while(mask &amp;&amp; node) { if((mask &amp; n) != 0) { node = node-&gt;right; } else { node = node-&gt;left; } mask &gt;&gt;= 1; } if(node) cout &lt;&lt; node-&gt;val &lt;&lt; endl; return node != nullptr; }}; 2129. å°†æ ‡é¢˜é¦–å­—æ¯å¤§å†™123456789101112131415161718192021222324252627282930313233class Solution { bool isLowercase(char c) { return c &gt;= 'a' &amp;&amp; c &lt;= 'z'; } bool isUppercase(char c) { return c &gt;= 'A' &amp;&amp; c &lt;= 'Z'; } char toLowercase(char c) { return isUppercase(c) ? c - 'A' + 'a' : c; } char toUppercase(char c) { return isLowercase(c) ? c - 'a' + 'A' : c; }public: string capitalizeTitle(string title) { int len = title.length(); int i = 0; while(i &lt; len) { int start = i; while(i &lt; len &amp;&amp; title[i] != ' ') { title[i] = toLowercase(title[i]); i++; } if(i - start &gt; 2) { title[start] = toUppercase(title[start]); } while(i &lt; len &amp;&amp; title[i] == ' ') { i++; } } return title; }}; 310. æœ€å°é«˜åº¦æ ‘123456789101112131415161718192021222324252627282930313233class Solution {public: vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) { if(n == 1) return {0}; vector&lt;int&gt; ans, deg(n); vector&lt;vector&lt;int&gt;&gt; g(n); for(auto &amp; edge : edges) { g[edge[0]].push_back(edge[1]); g[edge[1]].push_back(edge[0]); deg[edge[0]]++; deg[edge[1]]++; } queue&lt;int&gt; q; for(int i = 0; i &lt; n; i++) { if(deg[i] == 1) q.push(i); } while(!q.empty()) { int q_size = q.size(); ans.clear(); while(q_size--) { int node = q.front(); q.pop(); deg[node]--; for(int child : g[node]) { deg[child]--; if(deg[child] == 1) q.push(child); } ans.push_back(node); } } return ans; }}; çœ‹äº†ç­”æ¡ˆï¼Œæ‹“æ‰‘æ’åºï¼Œæœ€åä¸€æ‰¹å°±æ˜¯æ ¹ 2684. çŸ©é˜µä¸­ç§»åŠ¨çš„æœ€å¤§æ¬¡æ•° æš´åŠ›ï¼æš´åŠ›ï¼ è®°å¿†ä¼˜åŒ–æœç´¢ 1234567891011121314151617181920212223242526272829class Solution { int ans = 0; int m, n; bool checkBounds(int i, int j) { return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; } vector&lt;vector&lt;int&gt;&gt; mem; int dfs(int i, int j, int len, vector&lt;vector&lt;int&gt;&gt;&amp; grid) { if(checkBounds(i-1, j+1) &amp;&amp; grid[i][j] &lt; grid[i-1][j+1]) { mem[i][j] = max(mem[i][j], 1 + (mem[i-1][j+1] == 0 ? (mem[i-1][j+1] = dfs(i-1, j+1, len+1, grid)) : mem[i-1][j+1])); } if(checkBounds(i+1, j+1) &amp;&amp; grid[i][j] &lt; grid[i+1][j+1]) { mem[i][j] = max(mem[i][j], 1 + (mem[i+1][j+1] == 0 ? (mem[i+1][j+1] = dfs(i+1, j+1, len+1, grid)) : mem[i+1][j+1])); } if(checkBounds(i, j+1) &amp;&amp; grid[i][j] &lt; grid[i][j+1]) { mem[i][j] = max(mem[i][j], 1 + (mem[i][j+1] == 0 ? (mem[i][j+1] = dfs(i, j+1, len+1, grid)) : mem[i][j+1])); } return mem[i][j]; }public: int maxMoves(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { m = grid.size(), n = grid[0].size(); mem = vector&lt;vector&lt;int&gt;&gt;(m, vector&lt;int&gt;(n)); for(int i = 0; i &lt; m; i++) { ans = max(ans, dfs(i, 0, 0, grid)); } return ans; }}; 303. åŒºåŸŸå’Œæ£€ç´¢ - æ•°ç»„ä¸å¯å˜1234567891011121314class NumArray { vector&lt;int&gt; prevSum;public: NumArray(vector&lt;int&gt;&amp; nums) : prevSum(nums) { int len = prevSum.size(); for(int i = 1; i &lt; len; i++) { prevSum[i] += prevSum[i-1]; } } int sumRange(int left, int right) { return left == 0 ? prevSum[right] : prevSum[right] - prevSum[left-1]; }}; å‰å‰å‰å‰å‰å æ²³ï¼ˆç¼€å’Œï¼‰ 2671. é¢‘ç‡è·Ÿè¸ªå™¨ ä¸¤ä¸ªhashè¡¨ 12345678910111213141516171819202122232425262728293031class FrequencyTracker { unordered_map&lt;int, int&gt; freq2num; unordered_map&lt;int, int&gt; num2freq;public: FrequencyTracker() { } void add(int number) { int oldFred = num2freq[number]; num2freq[number]++; if(oldFred &gt; 0) { freq2num[oldFred]--; } freq2num[oldFred+1]++; } void deleteOne(int number) { int oldFred = num2freq[number]; if(oldFred &gt; 0) { num2freq[number]--; freq2num[oldFred]--; if(oldFred &gt; 1) freq2num[oldFred-1]++; } } bool hasFrequency(int frequency) { return freq2num[frequency] != 0; }}; 1969. æ•°ç»„å…ƒç´ çš„æœ€å°éé›¶ä¹˜ç§¯ æ ¹æ®å°å­¦çŸ¥è¯†ï¼Œè‹¥a+b=Constantï¼Œåˆ™abs(a-b)è¶Šå¤§ï¼Œa*bè¶Šå° å¯¹äºä¸¤ä¸ªäº’è¡¥çš„æ•°ï¼Œå¦‚10101å’Œ01010å¯ä»¥å˜æˆ00001å’Œ11110ï¼Œè¿™æ ·ä»–ä»¬å·®è·æœ€å¤§ï¼Œä¹˜ç§¯æœ€å° 00000å’Œ11111äº’è¡¥ä½†æ˜¯00000ä¸è€ƒè™‘ï¼Œæœ€åè¿˜è¦æˆå‘˜å®ƒ åªè¦è®¡ç®—æœ‰å¤šå°‘å¯¹äº’è¡¥æ•°Nï¼Œäº’è¡¥æ•°çš„æœ€å°ä¹˜ç§¯Aï¼Œç­”æ¡ˆç­‰äºA^N*(å…¨1) 12345678910111213141516class Solution { const long long MOD = 1e9 + 7; long long pow(long long base, long long index) { long long ans = 1; while(index) { if(index &amp; 1) ans = (ans * base) % MOD; base = (base * base) % MOD; index &gt;&gt;= 1; } return ans; }public: int minNonZeroProduct(int p) { return (pow(((1LL &lt;&lt; p) - 2) % MOD, ((1LL &lt;&lt; (p - 1)) - 1)) * (((1LL &lt;&lt; p) - 1) % MOD)) % MOD; }}; å–æ¨¡çš„æ—¶å€™è¦æ³¨æ„ä¼˜å…ˆçº§*/%æ˜¯åŒçº§çš„ï¼Œè¦åŠ æ‹¬å· 1793. å¥½å­æ•°ç»„çš„æœ€å¤§åˆ†æ•° ä¸€çœ¼å•è°ƒæ ˆ1234567891011121314151617181920212223242526272829303132class Solution {public: int maximumScore(vector&lt;int&gt;&amp; nums, int k) { int len = nums.size(); vector&lt;int&gt; leftPos(len), rightPos(len); stack&lt;int&gt; monoStack; for(int i = 0; i &lt; len; i++) { leftPos[i] = i; int top = -1; while(!monoStack.empty() &amp;&amp; nums[monoStack.top()] &gt;= nums[i]) { top = monoStack.top(); monoStack.pop(); } if(top != -1) leftPos[i] = leftPos[top]; monoStack.push(i); } monoStack = stack&lt;int&gt;(); int ans = 0; for(int i = len - 1; i &gt;= 0; i--) { int top = -1; rightPos[i] = i; while(!monoStack.empty() &amp;&amp; nums[monoStack.top()] &gt;= nums[i]) { top = monoStack.top(); monoStack.pop(); } if(top != -1) rightPos[i] = rightPos[top]; if(rightPos[i] &gt;= k &amp;&amp; k &gt;= leftPos[i]) ans = max(ans, (rightPos[i] - leftPos[i] + 1) * nums[i]); monoStack.push(i); } return ans; }}; èš‚èš2024å¹´3æœˆ23æ—¥æµ‹è¯„ç¬¬äºŒé¢˜ ç»™ä¸€ä¸ªæ•°ç»„ï¼Œå¯¹å…¶ä¸­ä¸€ä¸ªæ•°è‡ªå¢0-1æ¬¡ï¼Œæ•°ç»„ä¹˜ç§¯æœ€æœ€å¤šæœ‰å‡ ä¸ª012345678910111213141516171819202122232425262728293031323334//// Created by jingtian on 2024/3/23.//#include &lt;bits/stdc++.h&gt;using namespace std;int cntOf(int n, int divisor) { int cnt = 0; while(n % divisor == 0) { cnt++; n /= divisor; } return cnt;}int main() { int n; while(cin &gt;&gt; n) { vector&lt;int&gt; arr(n); int cntOf2 = 0, cntOf5 = 0; for(int i = 0; i &lt; n; i++) { cin &gt;&gt; arr[i]; cntOf2 += cntOf(arr[i], 2); cntOf5 += cntOf(arr[i], 5); } int ans = min(cntOf2, cntOf5); for(int i = 0; i &lt; n; i++) { ans = max(ans, min(cntOf2 - cntOf(arr[i], 2) + cntOf(arr[i]+1, 2), cntOf5 - cntOf(arr[i], 5) + cntOf(arr[i]+1, 5))); } cout &lt;&lt; ans &lt;&lt; endl; } return 0;} ç¬¬ä¸‰é¢˜ ä¸çŸ¥é“ACæ²¡ ç»™ä¸€é¢—æ•°ï¼Œæ¯æ¬¡å°†æœ‰å…¬å…±ç‚¹çš„ä¸¤æ¡è¾¹æ¶‚è‰²ï¼Œæœ€å¤šèƒ½æ¶‚è‰²å¤šå°‘æ¬¡ï¼Œè¾“å‡ºæ¯æ¬¡æ¶‚è‰²çš„ä¸‰ä¸ªèŠ‚ç‚¹ è´ªå¿ƒï¼Œå¯¹äºå€’æ•°ç¬¬äºŒå±‚çš„èŠ‚ç‚¹ï¼Œä¸¤ç§æƒ…å†µ å¶æ•°ä¸ªå­èŠ‚ç‚¹ ä¸¤ä¸¤é…å¯¹æ¶‚è‰² å¥‡æ•°ä¸ªå­èŠ‚ç‚¹ å‰©ä¸‹ä¸€ä¸ªå’Œçˆ¶èŠ‚ç‚¹æ¶‚è‰² å…¶ä»–å±‚ç±»ä¼¼ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import java.io.ByteArrayOutputStream;import java.io.PrintStream;import java.util.*;public class Main { private final ByteArrayOutputStream bos = new ByteArrayOutputStream(); private final PrintStream output = new PrintStream(bos); private static class TreeNode { public List&lt;TreeNode&gt; child; private int tag; private final int val; public TreeNode(int val) { child = new ArrayList&lt;&gt;(); tag = 0; this.val = val; } public void addChild(TreeNode node) { child.add(node); } } private int ans = 0; private void postOrder(TreeNode node) { for(int i = 0; i &lt; node.child.size(); i++) { postOrder(node.child.get(i)); } int cntOK = 0; int last = -1; for(int i = 0; i &lt; node.child.size(); i++) { if(node.child.get(i).tag == 1) { cntOK++; output.printf(&quot;%d %d %d\\n&quot;, node.val+1, node.child.get(i).val+1, node.child.get(i).child.get(node.child.get(i).child.size()-1).val+1); ans++; } else { if(last == -1) { last = i; } else { output.printf(&quot;%d %d %d\\n&quot;, node.child.get(last).val + 1, node.val+1, node.child.get(i).val+1); last = -1; ans++; } } } int remain = node.child.size() - cntOK; node.tag = remain &amp; 1; } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while(scanner.hasNext()) { Main main = new Main(); int n = scanner.nextInt(); TreeNode[] treeNodes = new TreeNode[n]; boolean[] visited = new boolean[n]; Arrays.fill(visited, false); Map&lt;Integer, List&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; i++) { treeNodes[i] = new TreeNode(i); } for(int i = 0; i &lt; n - 1; i++) { int x, y; x = scanner.nextInt() - 1; y = scanner.nextInt() - 1; if(!graph.containsKey(x)) { graph.put(x, new ArrayList&lt;&gt;()); } if(!graph.containsKey(y)) { graph.put(y, new ArrayList&lt;&gt;()); } graph.get(x).add(y); graph.get(y).add(x); } Deque&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;(); queue.add(0); while (!queue.isEmpty()) { int node = queue.getFirst(); visited[node] = true; queue.removeFirst(); for(int child : graph.get(node)) { if(visited[child]) continue; treeNodes[node].addChild(treeNodes[child]); queue.addLast(child); } } main.postOrder(treeNodes[0]); System.out.println(main.ans); System.out.print(main.bos); } }} 2549. ç»Ÿè®¡æ¡Œé¢ä¸Šçš„ä¸åŒæ•°å­— è®°å¿†ä¼˜åŒ–æœç´¢ 123456789101112131415161718class Solution { vector&lt;bool&gt; visited = vector&lt;bool&gt;(100+1); int ans = 1;public: int distinctIntegers(int n) { if(visited[n]) { return ans; } visited[n] = true; for(int i = n - 1; i &gt; 1; i--) { if(!visited[i] &amp;&amp; n % i == 1) { distinctIntegers(i); ans++; } } return ans; }};","link":"/home/2024/03/14/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9334/"},{"title":"LeetCode-33","text":"232. ç”¨æ ˆå®ç°é˜Ÿåˆ— ä¸¤ä¸ªæ ˆå€’è…¾ä¸€ä¸‹å¯ä»¥å¾—åˆ°é˜Ÿåˆ— ä¸€ä¸ªæ ˆç”¨æ¥å…¥é˜Ÿ ä¸€ä¸ªæ ˆç”¨æ¥å‡ºé˜Ÿï¼Œå¦‚æœå‡ºé˜Ÿæ ˆç©ºï¼Œå°†å¦ä¸€ä¸ªæ ˆå…¨å€’è…¾è¿‡æ¥ï¼Œå¦‚æœä¸ç©ºï¼Œå°±å‡ºæ ˆä¸€ä¸ªå…ƒç´  1234567891011121314151617181920212223242526272829303132333435363738class MyQueue { stack&lt;int&gt; inStk, outStk;public: MyQueue() { } void push(int x) { inStk.push(x); } int pop() { if(outStk.empty()) { while(!inStk.empty()) { outStk.push(inStk.top()); inStk.pop(); } } int top = outStk.top(); outStk.pop(); return top; } int peek() { if(outStk.empty()) { while(!inStk.empty()) { outStk.push(inStk.top()); inStk.pop(); } } int top = outStk.top(); return top; } bool empty() { return inStk.empty() &amp;&amp; outStk.empty(); }}; 1976. åˆ°è¾¾ç›®çš„åœ°çš„æ–¹æ¡ˆæ•°dijkstra æ•°æ®èŒƒå›´å¾ˆå¤§ï¼Œæšä¸¾æ‰€æœ‰è·¯å¾„æ˜¯ä¸ç°å®çš„ ç”±äºæˆ‘ä»¬åªè¦æ±‚ä¸¤ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯ï¼Œæ‰€ä»¥ç”¨dijkstraå°±å¥½ åº”è¯¥æ˜¯dpå§ï¼Œæ¯æ¬¡é€‰å–æœ€å°è·¯å¾„çš„ç‚¹æ›´æ–°é‚»æ¥èŠ‚ç‚¹ è‹¥ä½¿å…¶è·¯å¾„å˜å°äº†ï¼Œåˆ™åˆ°è¾¾è¯¥èŠ‚ç‚¹æœ€çŸ­è·¯å¾„æ•°ç­‰äºæ ¹èŠ‚ç‚¹åˆ°è¾¾å½“å‰èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„æ•° è‹¥è·¯å¾„é•¿åº¦ç­‰äºè¯¥èŠ‚ç‚¹ï¼Œåˆ™åˆ°è¾¾è¯¥èŠ‚ç‚¹æœ€çŸ­è·¯å¾„æ•°åœ¨åŸæ¥æ•°é‡ä¸ŠåŠ ä¸Šæ ¹èŠ‚ç‚¹åˆ°è¾¾å½“å‰èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„æ•° 1234567891011121314151617181920212223242526272829303132333435class Solution {public: int countPaths(int n, vector&lt;vector&lt;int&gt;&gt;&amp; roads) { vector&lt;bool&gt; visited(n, false); int ans = 0; vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; g(n); for(auto&amp; road : roads) { g[road[0]].emplace_back(road[1], road[2]); g[road[1]].emplace_back(road[0], road[2]); } vector&lt;long long&gt; minCostArr(n, 0x7fffffffffffffff); vector&lt;int&gt; costCnt(n, 0); minCostArr[0] = 0; costCnt[0] = 1; for(int i = 0; i &lt; n; i++) { int node = -1; for(int j = 0; j &lt; n; j++) { if(!visited[j] &amp;&amp; (node == -1 || minCostArr[j] &lt; minCostArr[node])) { node = j; } } if(node == -1) break; visited[node] = true; for(auto [child, childCost] : g[node]) { if(minCostArr[child] &gt; minCostArr[node] + childCost) { costCnt[child] = costCnt[node]; minCostArr[child] = minCostArr[node] + childCost; } else if (minCostArr[child] == minCostArr[node] + childCost) { costCnt[child] = (costCnt[node] + costCnt[child]) % 1000000007; } } } return costCnt[n-1]; }}; 2917. æ‰¾å‡ºæ•°ç»„ä¸­çš„ K-or å€¼12345678910111213class Solution { public int findKOr(int[] nums, int k) { int[] bitCnt = new int[32]; int ans = 0; for(int i = 0, mask = 1; i &lt; 32; i++, mask &lt;&lt;= 1) { for(int n : nums) { if((mask &amp; n) != 0)bitCnt[i]++; } if(bitCnt[i] &gt;= k) ans |= mask; } return ans; }} 2575. æ‰¾å‡ºå­—ç¬¦ä¸²çš„å¯æ•´é™¤æ•°ç»„ é¢˜è§£ 123456789101112131415class Solution {public: vector&lt;int&gt; divisibilityArray(string word, int m) { int len = word.length(); vector&lt;int&gt; res(len, 0); long long number = 0; for(int i = 0; i &lt; len; i++) { number = (number * 10 + word[i] - '0') % m; if(number == 0) { res[i] = 1; } } return res; }}; 299. çŒœæ•°å­—æ¸¸æˆ123456789101112131415161718char* getHint(char* secret, char* guess) { int ACnt = 0, ABCnt = 0; int cntSecret[10] = {0}, cntGuess[10] = {0}; while(*secret) { if(*secret == *guess) ACnt++; cntSecret[*secret - '0']++; cntGuess[*guess - '0']++; secret++; guess++; } for(int i = 0; i &lt; 10; i++) { ABCnt += (cntSecret[i] &gt; cntGuess[i] ? cntGuess[i] : cntSecret[i]); } int len = snprintf(NULL, 0, &quot;%dA%dB&quot;, ACnt, ABCnt - ACnt) + 1; char *ret = malloc(sizeof(char) * (len)); snprintf(ret, len, &quot;%dA%dB&quot;, ACnt, ABCnt - ACnt); return ret;}","link":"/home/2024/03/04/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9333/"},{"title":"LeetCode-2","text":"20. æœ‰æ•ˆçš„æ‹¬å·æ€è·¯ åˆ›å»ºä¸€ä¸ªæ ˆ éå†å­—ç¬¦ä¸² å¦‚æœæ˜¯å·¦åŠéƒ¨åˆ†ï¼ŒæŠŠè¿™ä¸ªå­—ç¬¦å‹æ ˆ å¦‚æœæ˜¯å³åŠéƒ¨åˆ†ï¼Œå…ˆçœ‹ä¸€ä¸‹æ ˆé¡¶å…ƒç´ å’Œå®ƒæ˜¯å¦é…å¯¹ï¼Œå¦‚æœé…å¯¹ï¼Œå¼¹æ ˆï¼Œä¸é…å¯¹ï¼Œç»“æŸï¼Œè¿”å›false å­—ç¬¦ä¸²éå†ç»“æŸåï¼Œçœ‹æ ˆæ˜¯å¦å·²ç»ç©ºäº†ï¼Œå¦‚æœæ²¡ç©ºï¼Œè¯´æ˜å·¦å³æ‹¬å·æ•°é‡ä¸å¯¹åº”false ACä»£ç 123456789101112131415161718192021222324static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: bool isValid(string s) { int p[128] = {0}; p['('] = ')'; p[')'] = 0; p['['] = ']'; p[']'] = 0; p['{'] = '}'; p['}'] = 0; stack&lt;char&gt; sta; for (int i = 0; i &lt; s.length(); i++) { if (p[s[i]]) { sta.push(s[i]); } else { if (sta.empty() || p[sta.top()] != s[i]) return false; sta.pop(); } } return sta.empty(); }}; 26. åˆ é™¤æ’åºæ•°ç»„ä¸­çš„é‡å¤é¡¹ç¬¬ä¸€æ¬¡ACä»£ç 1234567class Solution {public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { nums.erase(unique(nums.begin(), nums.end()), nums.end()); return nums.size(); }}; æˆ‘çŸ¥é“è¿™æ ·å¾ˆä¸é“å¾·ï¼Œæ‰€ä»¥ æ€è·¯ åŒæŒ‡é’ˆæ³• ä¸€ä¸ªæ•°ç”¨æ¥éå†ä¸€éæ•°ç»„ï¼Œä¸€ä¸ªç”¨æ¥è®°å½•å½“å‰ä¸é‡å¤çš„æ•°çš„ä½ç½® æ¯æ¬¡å¾ªç¯æŠŠjæŒ‡å‘çš„æ•°èµ‹å€¼ç»™i å½“jæŒ‡å‘çš„æ•°ä¸å½“å‰æ•°ä¸ç­‰çš„æ—¶å€™ï¼Œi++ï¼Œè¿™æ ·ä¸‹ä¸€ä¸ªä¸é‡å¤çš„æ•°æ”¾åˆ°äº†å®ƒçš„åé¢ ç¬¬äºŒæ¬¡ACä»£ç 12345678910111213class Solution {public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { if (!nums.size()) return 0; int i = 0; for (int j = 1; j &lt; nums.size(); j++) { if (nums[i] != nums[j]) i++; nums[i] = nums[j]; } return i + 1; }}; 27. ç§»é™¤å…ƒç´ æ€è·¯1ç±»ä¼¼ä¸Šä¸€é¢˜çš„åŒæŒ‡é’ˆæ³•iç”¨äºå¾ªç¯å˜é‡å½“iæŒ‡å‘çš„å€¼ä¸æ˜¯è¦åˆ é™¤çš„å…ƒç´ æ—¶ï¼ŒæŠŠiçš„å€¼èµ‹å€¼ç»™å½“å‰çš„jï¼Œjå†è‡ªå¢æ¯æ¬¡å¾ªç¯ï¼Œiè‡ªå¢ æ€è·¯2æŠŠè¦åˆ é™¤çš„å€¼ç§»åŠ¨åˆ°æ•°ç»„çš„æœ«å°¾ ä¸€ä¸ªnï¼Œè®°å½•æ•°ç»„çš„é•¿åº¦ éå†æ•°ç»„ï¼Œæ¯æ‰¾åˆ°ä¸€ä¸ªè¦åˆ é™¤çš„å€¼ï¼ŒæŠŠå®ƒå’Œn-1æŒ‡å‘çš„å…ƒç´ èµ‹å€¼ç»™å®ƒï¼Œæ•°ç»„é•¿åº¦nè‡ªå‡ï¼Œè¿™ä¸ªæ—¶å€™æŒ‡é’ˆä¸è¦ç§»åŠ¨ï¼Œå› ä¸ºè¦åˆ¤æ–­åˆšæ‰æœ«å°¾çš„é‚£ä¸ªæ•°æ˜¯ä¸æ˜¯ä¹Ÿæ˜¯è¦åˆ é™¤çš„ æ€è·¯3iteratoréå†ï¼Œè°ƒç”¨vectorçš„eraseç›´æ¥åˆ  ACä»£ç ï¼ˆä»ä¸Šåˆ°ä¸‹ä¾æ¬¡æ˜¯ä¸‰ä¸ªæ€è·¯ï¼‰1234567891011121314class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int j = 0; for (int i = 0; i &lt; nums.size(); i++) { if (nums[i] != val) { nums[j] = nums[i]; j++; } } return j; }}; 12345678910111213141516class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int n = nums.size(); int i = 0; while (i &lt; n) { if (nums[i] == val) { nums[i] = nums[n-1]; n--; } else { i++; } } return n; }}; 123456789101112class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { for (vector&lt;int&gt;::iterator i = nums.begin(); i != nums.end(); i++) { if (*i == val) { nums.erase(i); i--; } } return nums.size(); }}; 28. å®ç°strStr()ACä»£ç 1234567891011121314class Solution {public: int strStr(string haystack, string needle) { if (!needle.length()) return 0; if (haystack.length() &lt; needle.length()) return -1; int n = needle.length(); for (int i = 0; i &lt; haystack.length() - n + 1; i++) { if (haystack.substr(i, n) == needle) { return i; } } return -1; }}; 35. æœç´¢æ’å…¥ä½ç½®æ€è·¯å°±æ˜¯éå†æœç´¢+æ’å…¥æ’åºï¼Œä¸¤ä¸ªç®—æ³•æ··åˆèµ·æ¥å°±å®Œäº† ACä»£ç 123456789101112131415161718class Solution {public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) { if (target &gt; *(nums.end() - 1)) { nums.insert(nums.end(), target); return nums.size() - 1; } for (int i = 0; i &lt; nums.size(); i++) { if (nums[i] &gt;= target) { if (nums[i] &gt; target) { nums.insert(nums.begin() + i, target); } return i; } } return nums.size(); }}; 38. æŠ¥æ•°æ€è·¯å’Œä¹‹å‰çš„1084 å¤–è§‚æ•°åˆ—(PAT (Basic Level) Practice)æ˜¯ä¸€æ ·çš„ï¼Œä¸åŒç‚¹æ˜¯å¤–è§‚æ•°åˆ—æ˜¯aæœ‰xä¸ªï¼Œè¿™é“é¢˜æ˜¯xä¸ªa ACä»£ç 1234567891011121314151617181920212223242526272829303132static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: string countAndSay(int n) { return ItWasPAT(n); } void add(string&amp; str, char c, int&amp; n) { char toNum[1024] = {0}; sprintf(toNum, &quot;%d&quot;, n); str.append(toNum); str.append(&amp;c, 1); n = 0; } string ItWasPAT (int n) { string d = &quot;1&quot;; string&amp; temp = d; for (int i = 0, count = 1; i &lt; n - 1; i++, count = 1) { string next = &quot;&quot;; for (int j = 1; j &lt; temp.length(); j++, count++) if (temp[j - 1] != temp[j]) add(next, temp[j - 1], count); add(next, temp[temp.length() - 1], count); temp = next; } return temp; }}; 53. æœ€å¤§å­åºå’Œæ€è·¯è¿™é“é¢˜ä¸ä¼šï¼Œç›´æ¥æŠ„çš„è¯„è®ºåŒºä»£ç ã€‚å¤§ä¸€ä¸Šï¼Œè¿˜æ²¡å­¦åŠ¨æ€è§„åˆ’ ACä»£ç 1234567891011121314class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { if (!nums.size()) return 0; int ans = nums[0]; int sum = nums[0]; for (int i = 1; i &lt; nums.size(); i++) { if (sum &gt; 0) sum += nums[i]; else sum = nums[i]; ans = ans &lt; sum ? sum : ans; } return ans; }}; 83. åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´ æ€è·¯ é“¾è¡¨æ˜¯æœ‰åºçš„ ä¸¤ä¸ªæŒ‡é’ˆï¼Œä¸€ä¸ªæŒ‡é’ˆiæŒ‡å‘ä¸é‡å¤çš„ä½ç½®ï¼Œä¸€ä¸ªjç”¨æ¥éå† å½“jçš„å€¼å’Œiä¸ä¸€æ ·æ—¶ï¼Œè®©içš„nextæŒ‡å‘jçš„nextï¼Œjå†å¾€åç§»ï¼Œç”±äºè¿™æ—¶å€™è¦è®¿é—®j-&gt;nextï¼Œè¦åˆ¤æ–­æ˜¯å¦ä¸ºNULLï¼Œå¦‚æœæ˜¯çš„è¯ï¼Œè¯´æ˜ç»“æŸäº†ï¼Œè®©i-&gt;nextä¸ºNULL è¿™æ—¶ä¸è¦ç§»åŠ¨iï¼Œæœ€åå‡ ä¸ªå…ƒç´ é‡å¤çš„è¯ï¼Œè¿™æ ·ä¼šéæ³•è®¿é—® è¿™ä¸ªç®—æ³•æ”¾åœ¨javaä¸Šæ›´å¥½ï¼Œå› ä¸ºè¿™æ ·åšæ²¡æœ‰deleteï¼Œå†…å­˜æ³„æ¼å¯æ˜¯é‡ç½ª ACä»£ç 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: ListNode* deleteDuplicates(ListNode* head) { if (head == NULL) return NULL; ListNode *i = head, *j = head-&gt;next; int n = 0; while (j != NULL) { if (i-&gt;val == j-&gt;val) { if (j-&gt;next != NULL) { i-&gt;next = j-&gt;next; j = j-&gt;next; } else { i-&gt;next = NULL; break; } } else { i = j; j = j-&gt;next; } } return head; }}; ACä»£ç ï¼ˆå†…å­˜ä¸æ³„æ¼ç‰ˆæœ¬ï¼‰123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: ListNode* deleteDuplicates(ListNode* head) { ListNode *i = head, *de; if (i == NULL || i-&gt;next == NULL) return head; while (i-&gt;next != NULL) { if (i-&gt;val == i-&gt;next-&gt;val) { de = i-&gt;next; i-&gt;next = i-&gt;next-&gt;next; delete de; } else { i = i-&gt;next; } } return head; }};","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932/"},{"title":"LeetCode-37","text":"698. åˆ’åˆ†ä¸ºkä¸ªç›¸ç­‰çš„å­é›†1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution { class Solve { vector&lt;int&gt;&amp; nums; int k; int n; vector&lt;int&gt; bucket; int target; int sum; bool canPartition; bool dfs(int index) { if(index &gt;= n) { // æ‰€æœ‰æ•°éƒ½æ”¾è¿›æ¥äº†ï¼Œä¸”æ²¡æœ‰è¶…è¿‡target // è¯´æ˜ä¸€å®šå…¨ç­‰äºtarget // å¦‚æœæœ‰æ¡¶&lt;target, åˆ™ä¸€å®šæœ‰æ¡¶&gt;targetï¼Œæ‰€ä»¥æ‰€æœ‰æ¡¶ä¸€å®š&gt;=target // å¦‚æœæœ‰æ¡¶&gt;target, åˆ™ä¸€å®šæœ‰æ¡¶&lt;targetï¼Œæ‰€ä»¥æ‰€æœ‰æ¡¶ä¸€å®š&lt;=target // æ‰€ä»¥æ‰€æœ‰æ¡¶ä¸€å®š==target return true; } for(int i = 0; i &lt; k; i++) { if(i&gt;0 &amp;&amp; bucket[i] == bucket[i-1]) continue; if(bucket[i] + nums[index] &lt;= target) { bucket[i] += nums[index]; if(dfs(index+1)) { return true; } bucket[i] -= nums[index]; } } return false; } public: Solve(vector&lt;int&gt;&amp; nums, int k):nums(nums), k(k), bucket(k) { n = nums.size(); sum = accumulate(nums.begin(), nums.end(), 0); target = sum / k; sort(nums.begin(), nums.end(), greater&lt;int&gt;()); if(sum % k != 0) { canPartition = false; return; } canPartition = dfs(0); } bool solve() { return canPartition; } };public: bool canPartitionKSubsets(vector&lt;int&gt;&amp; nums, int k) { return Solve(nums, k).solve(); }}; ç¡¬æœ 690. å‘˜å·¥çš„é‡è¦æ€§12345678910111213141516171819class Solution {public: int getImportance(vector&lt;Employee*&gt; employees, int id) { int len = employees.size(); unordered_map&lt;int, Employee*&gt; id2Node; for(Employee *employee : employees) { id2Node[employee-&gt;id] = employee; } function&lt;int(int)&gt; dfs = [&amp;](int currentId) { Employee *node = id2Node[currentId]; int ans = node-&gt;importance; for(int child : node-&gt;subordinates) { ans += dfs(child); } return ans; }; return dfs(id); }}; 699. æ‰è½çš„æ–¹å—12345678910111213141516171819202122232425262728class Solution {public: vector&lt;int&gt; fallingSquares(vector&lt;vector&lt;int&gt;&gt;&amp; positions) { int len = positions.size(); vector&lt;int&gt; height(len); vector&lt;int&gt; right(len); for(int i = 0; i &lt; len; i++) { right[i] = positions[i][0] + positions[i][1]; } for(int i = 0; i &lt; len; i++) { int maxHeight = 0; int lefti = positions[i][0]; int righti = right[i]; for(int j = 0; j &lt; i; j++) { int leftj = positions[j][0]; int rightj = right[j]; if(lefti &gt;= rightj) continue; if(righti &lt;= leftj) continue; maxHeight = max(maxHeight, height[j]); } height[i] = maxHeight + positions[i][1]; } for(int i = 1; i &lt; len; i++) { height[i] = max(height[i-1], height[i]); } return height; }}; æ•°æ®è§„æ¨¡ç•¥å°ï¼Œç›´æ¥æš´åŠ› 1186. åˆ é™¤ä¸€æ¬¡å¾—åˆ°å­æ•°ç»„æœ€å¤§å’Œå…ˆäº†è§£Maximum Subarray Sum - Kadaneâ€™s Algorithm 123456789101112131415class Solution {public: int maximumSum(vector&lt;int&gt;&amp; arr) { int n = arr.size(); int dp0 = arr[0], dp1 = 0; int maxx = arr[0]; for(int i = 1; i &lt; n; i++) { dp1 = max(dp1 + arr[i], dp0); dp0 = max(dp0, 0) + arr[i]; maxx = max(maxx, dp0); maxx = max(maxx, dp1); } return maxx; }}; 3144. åˆ†å‰²å­—ç¬¦é¢‘ç‡ç›¸ç­‰çš„æœ€å°‘å­å­—ç¬¦ä¸²123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution { bool allEqualsExceptZero(int *arr, int len) { if(len &lt;= 0) return true; int i = 0; while(i &lt; len &amp;&amp; arr[i] == 0) i++; if(i == len) return true; const int val = arr[i]; for(; i &lt; len; i++) { if(0 != arr[i] &amp;&amp; val != arr[i]) return false; } return true; } int bfs(const vector&lt;vector&lt;bool&gt;&gt;&amp; balance, int n) { queue&lt;int&gt; q; q.push(0); int level = 0; vector&lt;bool&gt; visited(n, false); while(!q.empty()) { level++; int len = q.size(); while(len--) { int node = q.front(); q.pop(); for(int i = node; i &lt; n; i++) { if(balance[node][i]) { if(i + 1 == n) { return level; } else if(!visited[i+1]) { q.push(i + 1); visited[i + 1] = true; } } } } } return level; }public: int minimumSubstringsInPartition(string s) { int len = s.length(); vector&lt;vector&lt;bool&gt;&gt; balance(len, vector&lt;bool&gt;(len, false)); for(int i = 0; i &lt; len; i++) { int charCnt[26] = {0}; for(int j = i; j &lt; len; j++) { charCnt[s[j] - 'a']++; balance[i][j] = allEqualsExceptZero(charCnt, 26); } } return bfs(balance, len); } void test() { // cout &lt;&lt; minimumSubstringsInPartition(&quot;ababcc&quot;) &lt;&lt; &quot; == 1&quot;&lt;&lt; endl; // cout &lt;&lt; minimumSubstringsInPartition(&quot;fabccddg&quot;) &lt;&lt; &quot; == 3&quot; &lt;&lt; endl; // cout &lt;&lt; minimumSubstringsInPartition(&quot;abababaccddb&quot;) &lt;&lt; &quot; == 2&quot; &lt;&lt; endl; cout &lt;&lt; minimumSubstringsInPartition(&quot;fabccddg&quot;) &lt;&lt; &quot; == 3&quot; &lt;&lt; endl; }}; æ‰¾å‡ºä»»æ„åŒºé—´(i...j)æ˜¯å¦ä¸ºå¹³è¡¡å­—ç¬¦ä¸²ï¼Œä»0å¼€å§‹bfsæœç´¢ï¼Œç›´åˆ°ç¬¬ä¸€ä¸ªè¾¾åˆ°nçš„èŠ‚ç‚¹ 3142. åˆ¤æ–­çŸ©é˜µæ˜¯å¦æ»¡è¶³æ¡ä»¶12345678910111213141516171819202122232425class Solution {public: bool satisfiesConditions(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = grid.size(); int n = grid[0].size(); for(int i = 0; i &lt; m - 1; i++) { for(int j = 0; j &lt; n - 1; j++) { if(grid[i][j] != grid[i+1][j] || grid[i][j] == grid[i][j+1]) { return false; } } } for(int i = 0; i &lt; m - 1; i++) { if(grid[i][n-1] != grid[i+1][n-1]) { return false; } } for(int j = 0; j &lt; n - 1; j++) { if(grid[m-1][j] == grid[m-1][j+1]) { return false; } } return true; }}; è¿™ç§é¢˜è¯·ä¸€æ¬¡æ€§ç»™è®©æˆ‘ç­”10å¼  3144. åˆ†å‰²å­—ç¬¦é¢‘ç‡ç›¸ç­‰çš„æœ€å°‘å­å­—ç¬¦ä¸²è¿™æ¬¡ç”¨dpå“¦ 123456789101112131415161718192021222324252627282930313233343536class Solution { bool allEqualsExceptZero(int *arr, int len) { if(len &lt;= 0) return true; int i = 0; while(i &lt; len &amp;&amp; arr[i] == 0) i++; if(i == len) return true; const int val = arr[i]; for(; i &lt; len; i++) { if(0 != arr[i] &amp;&amp; val != arr[i]) return false; } return true; }public: int minimumSubstringsInPartition(string s) { int n = s.length(); vector&lt;vector&lt;bool&gt;&gt; isBalance(n, vector&lt;bool&gt;(n)); for(int i = 0; i &lt; n; i++) { int charCnt[26] = {0}; for(int j = i; j &lt; n; j++) { charCnt[s[j] - 'a']++; isBalance[i][j] = allEqualsExceptZero(charCnt, 26); } } vector&lt;int&gt; dp(n, INT_MAX); dp[0] = 1; for(int i = 1; i &lt; n; i++) { if(isBalance[0][i]) dp[i] = min(dp[i], 1); for(int j = 1; j &lt;= i; j++) { if(isBalance[j][i]) dp[i] = min(dp[i], dp[j-1] + 1); } } return dp[n-1]; }}; 3127. æ„é€ ç›¸åŒé¢œè‰²çš„æ­£æ–¹å½¢123456789101112class Solution {public: bool canMakeSquare(vector&lt;vector&lt;char&gt;&gt;&amp; grid) { function&lt;int(int, int)&gt; gridValue = [&amp;](int i, int j) { return grid[i][j] == 'W' ? 1 : 0; }; function&lt;bool(int, int)&gt; judge = [&amp;](int i, int j) { return 2 != gridValue(i, j) + gridValue(i + 1, j) + gridValue(i, j + 1) + gridValue(i + 1, j + 1); }; return judge(0, 0) || judge(0, 1) || judge(1, 0) || judge(1, 1); }}; 3153. æ‰€æœ‰æ•°å¯¹ä¸­æ•°ä½å·®ä¹‹å’Œ123456789101112131415161718192021222324252627class Solution {public: long long sumDigitDifferences(vector&lt;int&gt;&amp; nums) { int len = nums.size(); vector&lt;vector&lt;int&gt;&gt; digitCnt(10, vector&lt;int&gt;(10)); // digitCnt[i][j], numsä¸­ç¬¬iä½ä¸ºjçš„æ•°çš„ä¸ªæ•° auto cntDigitNumPerPos = [&amp;]() { for(int index = 0; index &lt; len; index++) { int n = nums[index]; for(int i = 0; n; i++, n /= 10) { digitCnt[i][n % 10]++; } } }; cntDigitNumPerPos(); auto cntDiffsAndAdd = [&amp;]() { long long diffCnt = 0; for(int index = 0; index &lt; len; index++) { int n = nums[index]; for(int i = 0; n; i++, n /= 10) { diffCnt += len - digitCnt[i][n % 10]; // æ•°å‡ºæœ‰å¤šå°‘æ•°å’Œå½“å‰æ•°çš„ç¬¬iä½ä¸åŒ } } return diffCnt; }; return cntDiffsAndAdd() / 2; }}; 89. æ ¼é›·ç¼–ç 1234567891011class Solution {public: vector&lt;int&gt; grayCode(int n) { int len = 1 &lt;&lt; n; vector&lt;int&gt; ans(len); for(int i = 1; i &lt; len; i++) { ans[i] = (i &gt;&gt; 1) ^ i; } return ans; }}; è¯æ˜æ¨å¯¼ä¸€ä¸‹å…¬å¼ä¸ºä»€ä¹ˆæ—¶æ­£ç¡®çš„ è¦è¯æ˜å…¬å¼ $ a_i = (i &gt;&gt; 1) \\oplus i $ æ˜¯æ ¼é›·ç ï¼Œå°±è¦è¯æ˜ $ a_{i+1} \\oplus a_{i} = 2^{k_i} $ , å…¶ä¸­ $ k_i $ æ˜¯æ•´æ•° è®¾ $ i $çš„äºŒè¿›åˆ¶ä»ä½ä½åˆ°é«˜ä½ç¬¬ä¸€ä¸ª$ 0 $çš„ä½ç½®æ˜¯$ n $, åˆ™ $ i \\oplus (i + 1) = 2^{n+1} - 1$ï¼ŒåŸå› å‚è€ƒäºŒè¿›åˆ¶è‡ªå¢è®¡æ•°å™¨çš„åŸç† $ a_{i+1} \\oplus a_{i} $$ = (i &gt;&gt; 1) \\oplus i \\oplus ((i + 1) &gt;&gt; 1) \\oplus (i + 1) $$ = (i \\oplus (i + 1)) \\oplus ((i \\oplus (i + 1)) &gt;&gt; 1)$$ = (2^{n+1} - 1) \\oplus (2^{n} - 1) $$ = 2^{n+1} $ 2708. ä¸€ä¸ªå°ç»„çš„æœ€å¤§å®åŠ›å€¼12345678910111213141516171819202122232425262728293031323334class Solution {public: long long maxStrength(vector&lt;int&gt;&amp; nums) { long long ans = 1; bool has2Neg = false; bool hasPositive = false; bool hasZero = false; long long negProduct = 1; int len = nums.size(); sort(nums.begin(), nums.end()); int i = 0; while(i &lt; len &amp;&amp; nums[i] &lt; 0) { negProduct *= nums[i]; if(negProduct &gt; 0) { ans *= negProduct; negProduct = 1; has2Neg = true; } i++; } while(i &lt; len &amp;&amp; nums[i] &lt;= 0) { hasZero = true; i++; } while(i &lt; len){ ans *= nums[i]; i++; hasPositive = true; } return (has2Neg || hasPositive) ? ans : (hasZero) ? 0 : nums[0]; }}; é™¤äº†0ï¼Œå…¨ä¹˜èµ·æ¥ï¼Œå¦‚æœè´Ÿæ•°æœ‰å¥‡æ•°ä¸ªï¼Œå»æ‰æœ€å¤§çš„è´Ÿæ•° å¦‚æœæ²¡æœ‰æ­£æ•°ä¹Ÿæ²¡æœ‰æˆå¯¹çš„è´Ÿæ•°ï¼Œä½†æ˜¯æœ‰0ï¼Œè¿”å›0 å¦‚æœæ²¡æœ‰æ­£æ•°ä¹Ÿæ²¡æœ‰æˆå¯¹çš„è´Ÿæ•°ï¼Œæ²¡æœ‰0ï¼Œè¿”å›å”¯ä¸€çš„è´Ÿæ•° æ•°æ®è§„æ¨¡å¥½å°ï¼Œç»™äººä¸€ç§å¾ˆéš¾çš„æ„Ÿè§‰ 2024. è€ƒè¯•çš„æœ€å¤§å›°æ‰°åº¦123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution { int _maxConsecutiveAnswers(const string&amp; answerKey, int k) { int ans = 0; int len = answerKey.size(); int i = 0; while(i &lt; len &amp;&amp; k &gt; 0) { while(i &lt; len &amp;&amp; answerKey[i] == 'T') { i++; ans++; } while(i &lt; len &amp;&amp; k &gt; 0 &amp;&amp; answerKey[i] == 'F') { i++; k--; ans++; } } int j = 0; int cur = ans; while(i &lt; len) { while(i &lt; len &amp;&amp; answerKey[i] == 'T') { i++; cur++; } // cout &lt;&lt; i &lt;&lt; &quot;, &quot; &lt;&lt; ans &lt;&lt; &quot;, &quot; &lt;&lt; cur &lt;&lt; endl; ans = max(ans, cur); if(i &lt; len &amp;&amp; answerKey[i] == 'F') { int k = j; while(k &lt; i &amp;&amp; answerKey[k] == 'T') { k++; } cur = cur - (k - j + 1) + 1; // cout &lt;&lt; ans &lt;&lt; &quot;, &quot; &lt;&lt; cur &lt;&lt; endl; ans = max(ans, cur); j = k + 1; i++; } } return ans; }public: int maxConsecutiveAnswers(string&amp; answerKey, int k) { int res = _maxConsecutiveAnswers(answerKey, k); for(auto&amp; x : answerKey) { x = 'T' + 'F' - x; } return max(res, _maxConsecutiveAnswers(answerKey, k)); }}; è¦ä¹ˆæŠŠkæ­¥å…¨éƒ½ç”¨åœ¨Tå˜Fä¸Šï¼Œè¦ä¹ˆkæ­¥å…¨éƒ¨æ˜¯Få˜T å¯¹äºâ€TTFTTFTTFTTâ€ï¼Œå¯ä»¥ç¿»è¯‘æˆ[2T, 1F, 2T, 1F, 2T, 1F, 2T], å‡è®¾k=2ï¼Œæˆ‘ä»¬åªéœ€è¦è€ƒè™‘é€‰å‰ä¸¤ä¸ª1Fæˆ–åä¸¤ä¸ª1Fçš„æƒ…å†µï¼Œå…¶ä»–ä¸è¿ç»­çš„Fçš„ç»„åˆä¸éœ€è¦è€ƒè™‘ ç»è¿‡ä¸Šé¢çš„åˆ†æï¼Œå¯ä»¥ä½¿ç”¨åŒæŒ‡é’ˆçª—å£ å…ˆæŠŠkæ¶ˆè€—å…‰ æŒ‡é’ˆiæ¯é‡åˆ°ä¸€ä¸ªFï¼Œå‰é¢çš„æŒ‡é’ˆjå°±è¦å‘å‰ç§»åŠ¨ï¼Œæ‰¾åˆ°ä¸€ä¸ªFæŠŠè¿™ä¸ªFå˜æˆTï¼Œç§»åŠ¨å‡ æ­¥ï¼Œå°±å‡å°‘äº†å¤šå°‘ä¸ªTï¼ˆåŒ…æ‹¬jå½“å‰æŒ‡å‘çš„Fï¼Œå·²ç»åœ¨å‰é¢è¢«å˜æˆTäº†ï¼‰","link":"/home/2024/08/26/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9337/"},{"title":"LeetCode-6","text":"3. æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²æ€è·¯åŒæŒ‡é’ˆ å¦‚æœå­—ç¬¦ä¸²é•¿åº¦ä¸º1çš„è¯ï¼Œç›´æ¥è¿”å›1 å»ºç«‹å“ˆå¸Œè¡¨ï¼Œå‚¨å­˜å­—ç¬¦æ‰€åœ¨çš„ä½ç½®ï¼ˆä»1å¼€å§‹æ•°ï¼‰ iï¼Œjä¸¤ä¸ªæŒ‡é’ˆï¼Œiç”¨æ¥éå†å­—ç¬¦ä¸²ï¼ˆä½ç½®é å‰ï¼‰ï¼Œjç”¨æ¥è®°å½•å½“å‰ä¸é‡å¤çš„å­—ç¬¦çš„ä½ç½® æ¯æ¬¡å¾ªç¯ï¼Œå…ˆæŸ¥è¯¢mapä¸­s[i]çš„ä½ç½®ï¼Œå¦‚æœåœ¨jçš„å­—ç¬¦ä¹‹å‰ï¼Œè¯´æ˜ä»iåˆ°jæ²¡æœ‰é‡å¤å­—ç¬¦ å¦‚æœä½ç½®åœ¨jæˆ–jä¹‹åï¼Œè¯´æ˜å‡ºç°é‡å¤å­—ç¬¦ï¼Œé‚£ä¹ˆå…ˆä¸ç§»åŠ¨jï¼Œi-jçš„å€¼å°±æ˜¯ä¸€ä¸ªéé‡å¤å­ä¸²çš„é•¿åº¦ ç„¶åè®©jæŒ‡å‘s[i]çš„ä¸‹ä¸€ä¸ªä½ç½®ï¼Œè¿™æ ·å°±åˆå˜æˆäº†ä¸€ä¸ªä¸é‡å¤çš„å­ä¸² å¾ªç¯ç»“æŸï¼Œä½†æ˜¯æœ€åä¸€æ¬¡çš„ç»Ÿè®¡æ²¡æœ‰è®°å½•ï¼Œå†è®°å½•ä¸€æ¬¡ã€‚ ACä»£ç 123456789101112131415161718192021222324class Solution {public: int lengthOfLongestSubstring(string s) { if (s.length() == 1) return 1; unordered_map&lt;char, int&gt; m; int len = s.length(); int count = 0; int max = 0; int i = 0, j = 0; for ( ; i &lt; len; i++) { if (m[s[i]] &lt; j + 1) { m[s[i]] = i + 1; } else { count = i - j; j = m[s[i]]; max = max &gt; count ? max : count; m[s[i]] = i + 1; } } count = i - j; max = max &gt; count ? max : count; return max; }}; 8. å­—ç¬¦ä¸²è½¬æ¢æ•´æ•° (atoi)ACä»£ç 12345678910111213141516171819202122232425class Solution {public: int myAtoi(string str) { int len = str.length(); int i = 0; while(i &lt; len &amp;&amp; str[i] == ' ')i++; int ans = 0; int nage = 1; if (i &lt; len &amp;&amp; str[i] == '-') { nage = -1; i++; } else if (i &lt; len &amp;&amp; str[i] == '+') { i++; } while (i &lt; len &amp;&amp; isdigit(str[i])) { if (ans*10ll &gt; INT_MAX) return nage == 1 ? INT_MAX : INT_MIN; ans *= 10; if (ans+(long long)(str[i] - '0') &gt; INT_MAX) return nage == 1 ? INT_MAX : INT_MIN; ans += str[i] - '0'; i++; } ans *= nage; return ans; }}; 11. ç››æœ€å¤šæ°´çš„å®¹å™¨æ€è·¯åŒæŒ‡é’ˆ ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«æŒ‡å‘é¦–å°¾ æ¯”è¾ƒä¸¤ä¸ªæŒ‡é’ˆçš„å¤§å°ï¼Œè®¡ç®—é¢ç§¯ æŠŠåˆšæ‰è¾ƒå°çš„æŒ‡é’ˆç§»åŠ¨ä¸€æ ¼ ACä»£ç 123456789101112131415161718class Solution {public: int maxArea(vector&lt;int&gt;&amp; height) { int i = 0, j = height.size() - 1; int max = 0, a; while (i &lt; j) { if (height[i] &lt; height[j]) { a = height[i]*(j - i); i++; } else { a = height[j]*(j - i); j--; } max = max &gt; a ? max : a; } return max; }}; 12. æ•´æ•°è½¬ç½—é©¬æ•°å­—æ€è·¯æŠŠæ‰€æœ‰çš„ç¬¦å·å’Œå¯¹åº”çš„æ•°å­—å­˜èµ·æ¥ï¼Œç„¶åè½¬åŒ– ACä»£ç 123456789101112131415class Solution {public: string intToRoman(int num) { vector&lt;int&gt; vals = {1000,900,500,400,100,90,50,40,10,9,5,4,1}; vector&lt;string&gt; romans = {&quot;M&quot;, &quot;CM&quot;,&quot;D&quot;,&quot;CD&quot;,&quot;C&quot;,&quot;XC&quot;,&quot;L&quot;,&quot;XL&quot;,&quot;X&quot;,&quot;IX&quot;,&quot;V&quot;,&quot;IV&quot;,&quot;I&quot;}; string ans; for (int i = 0; i &lt; 13;i++) { while (num &gt;= vals[i]) { ans += romans[i]; num -= vals[i]; } } return ans; }}; 19. åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬Nä¸ªèŠ‚ç‚¹æ€è·¯ vectorä¿å­˜ç»“ç‚¹åœ°å€ï¼Œç„¶åç”¨æ•°ç»„è®¿é—®ä¸‹æ ‡æ„‰å¿«çš„æ“ä½œ ä¸¤æ¬¡éå†ï¼Œç¬¬ä¸€æ¬¡è®¡ç®—é“¾è¡¨é•¿åº¦ï¼Œè¿™æ ·å°±å¯ä»¥è®¡ç®—å‡ºæŒ‡é’ˆç§»åŠ¨å¤šå°‘æ¬¡å¯ä»¥åˆ°è¾¾è¦åˆ é™¤çš„ä½ç½®ï¼Œè¿™æ ·å°±å¯ä»¥åˆ é™¤äº† ä¸€æ¬¡éå†ï¼Œä¸¤ä¸ªæŒ‡é’ˆï¼ˆaï¼Œ bï¼‰ã€‚åˆ›å»ºä¸€ä¸ªå“‘ç»“ç‚¹æŒ‡å‘å¤´ç»“ç‚¹ï¼ŒaæŒ‡å‘å“‘ç»“ç‚¹ï¼Œbå…ˆå‘åç§»åŠ¨næ¬¡ï¼Œç„¶åaï¼Œbä¸€èµ·ç§»åŠ¨ï¼Œç›´åˆ°bç§»åŠ¨åˆ°ç»“å°¾ã€‚è¿™æ ·aå°±ç§»åŠ¨åˆ°äº†è¦åˆ é™¤çš„ç»“ç‚¹çš„å‰é¢ã€‚ç„¶ååˆ é™¤ã€‚ç„¶åè¿”å›å“‘ç»“ç‚¹çš„nextã€‚ ACä»£ç 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { vector&lt;ListNode*&gt; v; ListNode* temp = head; while (temp != NULL) { v.push_back(temp); temp = temp-&gt;next; } int len = v.size(); if (len == n) { temp = head; head = head-&gt;next; delete temp; return head; } temp = v[len - n]; ListNode* x = v[len - n - 1]; x-&gt;next = temp-&gt;next; delete temp; return head; }}; ACä»£ç 12345678910111213141516171819202122232425class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* temp = head; int len = 0; while (temp != NULL) { temp = temp-&gt;next; len++; } int pos = len - n; temp = head; if (pos) { for (int i = 0; i &lt; pos - 1; i++) { temp = temp-&gt;next; } ListNode* del = temp-&gt;next; temp-&gt;next = temp-&gt;next-&gt;next; delete del; } else { head = head-&gt;next; delete temp; } return head; }}; ACä»£ç 1234567891011121314151617181920class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode *a, *b = head; a = new ListNode(0);//å“‘ç»“ç‚¹ a-&gt;next = head; head = a;//è®©headæŒ‡å‘å“‘ç»“ç‚¹ï¼Œæœ€åreturnçš„æ¥å£ç»Ÿä¸€ for (int i = 0; i &lt; n; i++) { b = b-&gt;next;//bæŒ‡é’ˆå…ˆèµ° } while (b != NULL) { a = a-&gt;next; b = b-&gt;next; } ListNode* del = a-&gt;next; a-&gt;next = a-&gt;next-&gt;next; delete del; return head-&gt;next; }}; 31. ä¸‹ä¸€ä¸ªæ’åˆ—æ€è·¯ æ²¡æ€è·¯ï¼Œä¸è¿‡ä»¥å‰ç”¨è¿‡çš„ä»£ç æ‰¾å‡ºæ¥äº† ä¸çŸ¥é“ä¸ºå•¥è‡ªå·±å†™çš„reverseå‡½æ•°æ•ˆç‡æ¯”stlçš„reverseæ…¢ ACä»£ç 12345678910111213141516171819202122232425262728293031class Solution {public: void nextPermutation(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int i = len - 1; int j = i - 1; while (j &gt;= 0 &amp;&amp; nums[j] &gt;= nums[j+1]) { j--; } if (j &lt; 0) { std::reverse(nums.begin(), nums.end()); return; } i = len - 1; while (i &gt;= 0 &amp;&amp; nums[i] &lt;= nums[j]) { i--; } swap(nums[i], nums[j]); std::reverse(nums.begin()+j+1, nums.end()); } void swap(int&amp; a, int&amp; b) { int t = a; a = b; b = t; } void reverse(vector&lt;int&gt;&amp; nums, int beg, int end) { for (int i = beg, j = end - 1; i &lt; j; i++, j--) { swap(nums[i], nums[j]); } }}; 123456class Solution {public: void nextPermutation(vector&lt;int&gt;&amp; nums) { next_permutation(nums.begin(), nums.end()); }}; 50. Pow(x, n)æ€è·¯ ç›´æ¥ç®—è‚¯å®šä¸è¡Œçš„ å¦‚æœç®—$x^4$ï¼Œå¯ä»¥çœ‹åšæ˜¯$(x^2)^2$ åŒæ ·çš„$x^y = (x^2)^\\frac{y}{2}$ï¼Œä»¥æ­¤ç±»æ¨$x^y = (x^{2m})^{\\frac{y}{2m}}$ ACä»£ç 12345678910111213class Solution {public: double myPow(double x, int n) { double ans = 1; for (int i = n; i != 0; i /= 2) { if (i % 2 != 0) { ans *= x; } x *= x; } return n &lt; 0 ? 1/ans : ans; }}; 46. å…¨æ’åˆ—æ€è·¯æŠŠä¸Šæ¬¡31. ä¸‹ä¸€ä¸ªæ’åˆ—çš„ä»£ç å¤åˆ¶è¿‡æ¥ï¼Œæ”¹ä¸€æ”¹æˆ–è€…ç›´æ¥è°ƒç”¨next_permutation ACä»£ç 123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; ans; do { ans.push_back(nums); } while (nextPermutation(nums)); return ans; } bool nextPermutation(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int i = len - 1; int j = i - 1; while (j &gt;= 0 &amp;&amp; nums[j] &gt;= nums[j+1]) { j--; } if (j &lt; 0) { std::reverse(nums.begin(), nums.end()); return false; } i = len - 1; while (i &gt;= 0 &amp;&amp; nums[i] &lt;= nums[j]) { i--; } swap(nums[i], nums[j]); std::reverse(nums.begin()+j+1, nums.end()); return true; }};","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%936/"},{"title":"LeetCode-5","text":"350. ä¸¤ä¸ªæ•°ç»„çš„äº¤é›† IIæ€è·¯ ä¸¤ä¸ªmapåˆ†åˆ«ç»Ÿè®¡åœ¨ä¸¤ä¸ªæ•°ç»„ä¸­ä¸€ä¸ªå…ƒç´ çš„å‡ºç°æ¬¡æ•° æŠŠå…¶ä¸­ä¸€ä¸ªæ•°ç»„æ’åºå»é‡ï¼Œç„¶åæŸ¥è¯¢ä¸¤ä¸ªmap å–è¿™ä¸ªå…ƒç´ åœ¨ä¸¤ä¸ªæ•°ç»„é‡Œå‡ºç°æ¬¡æ•°çš„æœ€å°å€¼nï¼Œå¾€ansé‡Œé¢pushè¯¥å…ƒç´ næ¬¡ ACä»£ç 1234567891011121314151617181920212223class Solution {public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { map&lt;int, int&gt; v,n; vector&lt;int&gt; ans; for (int x : nums1) { v[x]++; } for (int x : nums2) { n[x]++; } sort(nums1.begin(), nums1.end()); nums1.erase(unique(nums1.begin(), nums1.end()), nums1.end()); for (int x : nums1) { if (v[x] &amp;&amp; n[x]) { int l = v[x] &gt; n[x] ? n[x] : v[x]; for (int i = 0; i &lt; l; i++) ans.push_back(x); } } return ans; }}; å¤§ä½¬æ€è·¯åŒæŒ‡é’ˆæ³• ä¸¤ä¸ªæ•°ç»„æ’åº ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘ç¬¬0ä¸ªå…ƒç´  å¾ªç¯æ¯”è¾ƒï¼Œå¦‚æœæŸä¸€ä¸ªæŒ‡é’ˆçš„å…ƒç´ å°ï¼ŒæŒ‡é’ˆåç§»ï¼ŒçŸ¥é“å€¼ç›¸ç­‰æ—¶ï¼Œpushä¸€æ¬¡ å¤§ä½¬ä»£ç 1234567891011121314151617181920212223242526class Solution {public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { sort(nums1.begin(), nums1.end()); sort(nums2.begin(), nums2.end()); int n1Size = nums1.size(); int n2Size = nums2.size(); int i = 0; int j = 0; vector&lt;int&gt; intersect; while((i &lt; n1Size) &amp;&amp; (j &lt; n2Size)) { if (nums1[i] &lt; nums2[j]) ++i; else if (nums1[i] &gt; nums2[j]) ++j; else { intersect.push_back(nums1[i]); ++i; ++j; } } return intersect; }}; 367. æœ‰æ•ˆçš„å®Œå…¨å¹³æ–¹æ•°æ€è·¯è‡ªå·±æ²¡å¥½å¥½ç ”ç©¶è¿™é¢˜çš„ç®—æ³• ACä»£ç 123456class Solution {public: bool isPerfectSquare(int num) { return (int)sqrt(num) == sqrt(num); }}; å¤§ä½¬æ€è·¯ è‡ªå·±å†™ä¸€ä¸ªæç¬‘çš„mySqrtå‡½æ•°ï¼Œç”¨ç±»ä¼¼äºŒåˆ†æŸ¥æ‰¾æ³•å®ç°ï¼Œæ¯•ç«Ÿè¿™é“é¢˜çš„è¾“å…¥åªæœ‰æ•´æ•° æš´åŠ›æœç´¢ å¤§ä½¬ä»£ç 123456789101112131415161718192021222324class Solution {public: bool isPerfectSquare(int num) { int sqrt = mySqrt(num); return sqrt*sqrt == num; } int mySqrt(int x) { int lo,hi; long mid; lo = 0; hi = x; while(lo&lt;=hi){ mid = lo + (hi-lo)/2; if(mid*mid&gt;x){ hi = mid-1; } else if ((mid+1)*(mid+1)&gt;x) { return mid; } else{ lo = mid+1; } } return lo;} 371. ä¸¤æ•´æ•°ä¹‹å’Œæ€è·¯ ç”¨ä½è¿ç®— ä¸ä¼š ACä»£ç 123456789101112class Solution {public: int getSum(int a, int b) { int temp = 0; while(a &amp; b){ temp = a; a ^= b; b = (temp &amp; b) &lt;&lt; 1; } return a|b; }}; 374. çŒœæ•°å­—å¤§å°æ€è·¯ æš´åŠ›æœç´¢ä¸å¯å–ï¼ŒäºŒåˆ†æŸ¥æ‰¾ä¿å¹³å®‰ ä¸è¦mid = (high + low) / 2ï¼Œä¼šæº¢å‡º12345678910111213141516171819202122232425// Forward declaration of guess API.// @param num, your guess// @return -1 if my number is lower, 1 if my number is higher, otherwise return 0int guess(int num);class Solution {public: int guessNumber(int n) { int left = 1, right = n, mid = (n + 1)/2; while (left &lt;= right) { mid = (left - right)/2 + right; switch (guess(mid)) { case -1 : right = mid - 1; break; case 1 : left = mid + 1; break; case 0 : return mid; } } return -1; }}; 383. èµé‡‘ä¿¡æ€è·¯ ä¸¤ä¸ªè¡¨ï¼Œåˆ†åˆ«è®°å½•æ¯ä¸ªå­—æ¯å‡ºç°æ¬¡æ•° éå†26ä¸ªå­—æ¯ï¼Œmagazineä¸­å­—æ¯å‡ºç°æ¬¡æ•°å¤§äºç­‰äºransomå°±å¯ä»¥ ACä»£ç 1234567891011121314151617class Solution {public: bool canConstruct(string ransomNote, string magazine) { int m[26] = {0}, n[26] = {0}; for (char x : ransomNote) { m[x-'a']++; } for (char x : magazine) { n[x-'a']++; } for (char x : ransomNote) { if (m[x-'a'] &gt; n[x-'a']) return false; } return true; }}; 387. å­—ç¬¦ä¸²ä¸­çš„ç¬¬ä¸€ä¸ªå”¯ä¸€å­—ç¬¦æ€è·¯è®°å½•æ¯ä¸ªå­—æ¯å‡ºç°æ¬¡æ•°ï¼Œéå†å­—ç¬¦ä¸²ï¼Œçœ‹è°ç¬¬ä¸€ä¸ªå‡ºç°æ¬¡æ•°æ˜¯0 ACä»£ç 1234567891011121314class Solution {public: int firstUniqChar(string s) { int n[26] = {0}; for (char x : s) { n[x - 'a']++; } int len = s.length(); for (int i = 0; i &lt; len; i++) { if (n[s[i] - 'a'] == 1) return i; } return -1; }}; 389. æ‰¾ä¸åŒæ€è·¯ è®°å½•æ¬¡æ•°ï¼Œéå†ä¸€étï¼Œçœ‹è°å‡ºç°æ¬¡æ•°å¤šä¸€æ¬¡ å¼‚æˆ–è¿ç®—ï¼ŒæŠµæ¶ˆç›¸åŒçš„ ACä»£ç 12345678910111213141516class Solution {public: char findTheDifference(string s, string t) { int m[26] = {0}, n[26] = {0}; for (char x : s) { m[x - 'a']++; } for (char x : t) { n[x - 'a']++; } for (char x : t) { if (m[x - 'a'] &lt; n[x - 'a']) return x; } return -1; }}; ACä»£ç 123456789101112class Solution {public: char findTheDifference(string s, string t) { int len = s.length(); char c = t[0]; for (int i = 0; i &lt; len; i++) { c ^= s[i]; c ^= t[i + 1];//tåªæ¯”så¤šä¸€ä¸ª } return c; }}; 400. ç¬¬Nä¸ªæ•°å­—æ€è·¯ æŠŠ $10^1$,$10^2$, $10^3$â€¦ä¹‹å‰çš„æ•°ç®—å‡ºæ¥ï¼Œå­˜åˆ°æ•°ç»„é‡Œ æŸ¥è¯¢æ•°ç»„ï¼Œå¾—åˆ°è¿™ä¸ªæ•°å¯¹åº”çš„æ•°é‡çº§ä¹‹å‰æœ‰å¤šå°‘æ•°ï¼Œç„¶åç®—å‡ºè¿™ä¸ªæ•°å…·ä½“æ˜¯å‡  ACä»£ç 1234567891011121314151617class Solution {public: int findNthDigit(int n) { unsigned long long m[10] = {0, 9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889}; //10^iä¹‹å‰çš„æ•°å­—ä¸ªæ•°ã€‚10ä¹‹å‰æœ‰9ä¸ªæ•°ï¼Œ100ä¹‹å‰æœ‰189ä¸ªæ•° int index = 0; for (; index &lt; 10; index++) { if (m[index] &gt;= n) { break; } }//æ‰¾åˆ°næ‰€åœ¨çš„èŒƒå›´ï¼Œindexæ˜¯å®ƒçš„ä½æ•°len n -= m[index - 1];//ä»ä¾‹å¦‚189å¯¹åº”çš„100åçš„ç¬¬å‡ ä¸ªæ•°å­— long long ans = pow(10, index - 1) + (n - 1) / (index);//å¯¹åº”çš„æ•° string t = to_string(ans); return t[(n - 1) % (index)] - '0'; }}; 405. æ•°å­—è½¬æ¢ä¸ºåå…­è¿›åˆ¶æ•°æ€è·¯ ç”¨ä¸€ä¸ªunsigned charæŒ‡é’ˆæŒ‡å‘intï¼Œå¾ªç¯4æ¬¡ï¼Œæ¯æ¬¡å–å€¼æ˜¯ä¸¤ä¸ª16è¿›åˆ¶æ•°ï¼Œç„¶åå­˜èµ·æ¥ æ³¨æ„å±€éƒ¨å˜é‡å­˜åœ¨æ ˆé‡Œï¼Œå€’ç€è¾“å‡º å¿½ç•¥å‰å¯¼0 ACä»£ç 12345678910111213141516171819202122class Solution {public: string toHex(int num) { if (!num) return &quot;0&quot;; char m[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'}; unsigned char *c = (unsigned char *)&amp;num; unsigned int n[8] = {0}; for (int i = 0; i &lt; 8; i+=2) { n[i] = (*c) % 16; n[i + 1] = (*c/16) % 16; c++; } string ans; int i = 7; while (i &gt;= 0 &amp;&amp; n[i] == 0) i--; for (; i &gt;= 0; i--) { ans += m[n[i]]; } return ans; }}; 412. Fizz Buzzæ€è·¯é¢ï¼Œï¼Œç®—å°±æ˜¯äº† ACä»£ç 123456789101112131415161718192021class Solution { public: vector&lt;string&gt; fizzBuzz(int n) { vector&lt;string&gt; v; for (int i = 1; i &lt;= n; i++) { if (i % 15 == 0) { v.push_back(&quot;FizzBuzz&quot;); } else if (i % 3 == 0) { v.push_back(&quot;Fizz&quot;); } else if (i % 5 == 0) { v.push_back(&quot;Buzz&quot;); } else { v.push_back(to_string(i)); } } return v; }}; 414. ç¬¬ä¸‰å¤§çš„æ•°æ€è·¯ æœç´¢ä¸‰æ¬¡ ç¬¬ä¸€æ¬¡æœ€å¤§å€¼ ç¬¬äºŒæ¬¡ä¸ç­‰äºç¬¬ä¸€æ¬¡çš„æœ€å¤§å€¼ ç¬¬ä¸‰æ¬¡ä¸ç­‰äºå‰ä¸¤æ¬¡çš„æœ€å¤§å€¼ ACä»£ç 1234567891011121314151617181920212223class Solution {public: int thirdMax(vector&lt;int&gt;&amp; nums) { long i = LONG_MIN, j = LONG_MIN, k = LONG_MIN; for (int x : nums) { if (x &gt; i) { i = x; } } for (int x : nums) { if (x &gt; j &amp;&amp; x != i) { j = x; } } for (int x : nums) { if (x &gt; k &amp;&amp; x != i &amp;&amp; x != j) { k = x; } } if (k == LONG_MIN) return i; else return k; }}; å¤§ä½¬æ€è·¯ æœç´¢ä¸€æ¬¡æ‰¾æœ€å¤§å€¼ å¦‚æœæœ‰æœ€å¤§å€¼ä¸”å¤§äºæœ€å¤§çš„æœ€å¤§å€¼ï¼Œå°±æŠŠå½“å‰å€¼å…ˆç»™äº†ç¬¬äºŒå¤§å€¼ï¼Œç¬¬äºŒå¤§å€¼ç»™äº†ç¬¬ä¸‰å¤§å€¼ å¦‚æœæœ‰æœ€å¤§å€¼ä¸”å°äºæœ€å¤§çš„æœ€å¤§å€¼å¤§äºç¬¬äºŒå¤§ï¼Œå¾€åé¡ºå»¶ å¦‚æœæœ‰æœ€å¤§å€¼ä¸”å°äºç¬¬äºŒå¤§çš„æœ€å¤§å€¼å¤§äºç¬¬ä¸‰å¤§ï¼Œå¾€åé¡ºå»¶ å¤§ä½¬ä»£ç 12345678910111213141516171819class Solution {public: int thirdMax(vector&lt;int&gt;&amp; nums) { long first = LONG_MIN, second = LONG_MIN, third = LONG_MIN; for (int num : nums) { if (num &gt; first) { third = second; second = first; first = num; } else if (num &gt; second &amp;&amp; num &lt; first) { third = second; second = num; } else if (num &gt; third &amp;&amp; num &lt; second) { third = num; } } return (third == LONG_MIN || third == second) ? first : third; }}; 415. å­—ç¬¦ä¸²ç›¸åŠ æ€è·¯ æ‰¾åˆ°æœ€é•¿å­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œç”¨è¿™ä¸ªé•¿åº¦åˆ†åˆ«ç»™ä¸¤ä¸ªå­—ç¬¦ä¸²æ·»åŠ å‰å¯¼0 å€’ç€éå†å­—ç¬¦ä¸²ï¼Œå¯¹åº”ç›¸åŠ æ¨¡æ‹Ÿå°±è¡Œäº† åˆ«ç½‘ç«™æœ€åä¸€ä½çš„è¿›ä½ ACä»£ç 1234567891011121314151617181920212223242526class Solution {public: string addStrings(string num1, string num2) { int carry = 0; int len1 = num1.length(); int len2 = num2.length(); int len = len1 &gt; len2 ? len1 : len2; string zero; for (int i = 0; i &lt; len - len1; i++) { zero += '0'; } num1.insert(0, zero); zero.clear(); for (int i = 0; i &lt; len - len2; i++) { zero += '0'; } num2.insert(0, zero); for (int i = len - 1; i &gt;= 0; i--) { int n = carry + num1[i] + num2[i] - 2*'0'; num1[i] = n % 10 + '0'; carry = n / 10; } if (carry) num1.insert(0, 1, carry + '0'); return num1; }}; 434. å­—ç¬¦ä¸²ä¸­çš„å•è¯æ•°æ€è·¯stlå¤§æ³•å¥½ ACä»£ç 123456789101112class Solution {public: int countSegments(string s) { stringstream ss(s); string buf; int count = 0; while (ss &gt;&gt; buf) { count++; } return count; }}; 447. å›æ—‹é•–çš„æ•°é‡æ€è·¯ æŠŠæ‰€æœ‰ç‚¹ä¸¤ä¸¤é…å¯¹ï¼Œè®¡ç®—è·ç¦» ç´¯åŠ n(n-1)æ’åˆ—æ•°$2A_n^2$ ACä»£ç 1234567891011121314151617181920class Solution {public: int numberOfBoomerangs(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) { unordered_map&lt;int ,int&gt; m; int ans = 0; int len = points.size(); for (int i = 0; i &lt; len; i++) { for (int j = 0; j &lt; len; j++) { int dx = points[i].first - points[j].first; int dy = points[i].second - points[j].second; m[dx*dx + dy*dy]++; } for (auto c : m) { ans += c.second*(c.second-1); } m.clear(); } return ans; }}; 441. æ’åˆ—ç¡¬å¸æ€è·¯ ç›´æ¥è§£æ–¹ç¨‹ ACä»£ç 123456class Solution {public: int arrangeCoins(int n) { return (sqrt(1 + 8ll * n) - 1) / 2; }}; å¤§ä½¬æ€è·¯ç±»ä¼¼äºŒåˆ†æŸ¥æ‰¾ è®¡ç®—å½“å‰midå¯¹åº”çš„æ¥¼æ¢¯æ•°q å¦‚æœq&lt;=æ€»æ•°ï¼ŒæŸ¥æ‰¾å³è¾¹ å¦åˆ™æŸ¥æ‰¾å·¦è¾¹ å¤§ä½¬ä»£ç 1234567891011121314151617class Solution {public: int arrangeCoins(int n) { if (n &lt;= 0) return 0; unsigned long long i = 1, j = n + 1; while (j - i&gt;= 1) { long long mid = i + (j - i) / 2; long long q = mid*(mid + 1) / 2; if (q &lt;= n) { i = mid + 1; } else { j = mid; } } return i - 1; }}; 443. å‹ç¼©å­—ç¬¦ä¸²æ€è·¯éå†æ•°æ¬¡æ•°ï¼Œç„¶åæŠŠæ¬¡æ•°ç¼–ç¨‹stringå­˜èµ·æ¥ï¼Œæœ€åä¸€ä¸ªå­—ç¬¦ä¸€ä¸ªå­—ç¬¦çš„å­˜åˆ°vectoræ•°ç»„é‡Œï¼Œè¿”å› ACä»£ç 12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;char&gt; ans; int compress(vector&lt;char&gt;&amp; chars) { int len = chars.size(); vector&lt;string&gt; s; int j = 0; int count = 0; for (int i = 1; i &lt; len; i++) { if (chars[j] != chars[i]) { j++; chars[j] = chars[i]; s.push_back(to_string(count + 1)); count = 0; } else { count++; } } s.push_back(to_string(count + 1)); for (int i = 0; i &lt; j + 1; i++) { ans.push_back(chars[i]); if (s[i] == &quot;1&quot;) continue; int num = s[i].length(); for (int k = 0; k &lt; num; k++) { ans.push_back(s[i][k]); } } chars = ans; return chars.size(); }}; å¤§ä½¬æ€è·¯éå†ä¸€éï¼Œæ•°ä¸ªæ•°ï¼Œç„¶åéƒ½å­˜åˆ°ä¸€ä¸ªstringé‡Œé¢ï¼ˆå……åˆ†åˆ©ç”¨stringé‡è½½çš„operator+ï¼‰ï¼Œæœ€ååˆ†è§£æˆcharæ•°ç»„ï¼Œè¿”å› å¤§ä½¬ä»£ç 123456789101112131415161718192021222324252627282930313233343536class Solution { public: int compress(vector&lt;char&gt; &amp;chars) { int count = 1; string str = &quot;&quot;; for (int i = 1; i &lt; chars.size(); i++) { if (chars[i] == chars[i - 1]) { count++; } else { if (count != 1) { str += chars[i - 1] + to_string(count); } else { str += chars[i - 1]; } count = 1; } } if (count != 1) { str += chars[chars.size() - 1] + to_string(count); } else { str += chars[chars.size() - 1]; } for (int i = 0; i &lt; str.size(); i++) { if (i &lt; chars.size()) { chars[i] = str[i]; } else { chars.push_back(str[i]); } } return str.size(); }}; 448. æ‰¾åˆ°æ‰€æœ‰æ•°ç»„ä¸­æ¶ˆå¤±çš„æ•°å­—æ€è·¯è®°å½•æ¯ä¸ªæ•°çš„å‡ºç°æ¬¡æ•°ï¼Œæœ€åè¿”å›å‡ºç°æ¬¡æ•°ä¸º0çš„é‚£äº›æ•° ACä»£ç 1234567891011121314151617class Solution {public: vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) { unordered_map&lt;int, int&gt; m; vector&lt;int&gt; ans; int len = nums.size(); for (int x : nums) { m[x]++; } for (int i = 1; i &lt;= len; i++) { if (m[i] == 0) { ans.push_back(i); } } return ans; }}; å¤§ä½¬æ€è·¯ iä»0å¼€å§‹éå†æ•°ç»„ï¼Œå–nums[i]çš„ç»å¯¹å€¼Qï¼ˆåæœŸæ­£æ•°å¯èƒ½å˜è´Ÿæ•°ï¼‰ æŠŠQ-1ä½œä¸ºä¸‹æ ‡ï¼ŒæŠŠnums[Q-1]è¿™ä¸ªæ•°ç¼–ç¨‹è´Ÿçš„ï¼ˆè‡ªå·±çš„ç»å¯¹å€¼çš„ç›¸åæ•°ï¼‰ æœ€åæ­£æ•°å‡ºç°çš„ä½ç½®å°±æ˜¯1~næ²¡å‡ºç°è¿‡çš„æ•° å¤§ä½¬ä»£ç 12345678910111213141516class Solution {public: vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; ans; int len = nums.size(); for (int i = 0; i &lt; len; i++) { nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1]); } for (int i = 0; i &lt; len; i++) { if (nums[i] &gt; 0) { ans.push_back(i + 1); } } return ans; }}; 455. åˆ†å‘é¥¼å¹²æ€è·¯è´ªå¿ƒç®—æ³• + åŒæŒ‡é’ˆæ³• æŠŠæ‰€æœ‰å°å­©çš„èƒƒå£çš„å‡ºç°æ¬¡æ•°ç»Ÿè®¡å‡ºæ¥ï¼Œæ”¾åˆ°å“ˆå¸Œè¡¨é‡Œé¢ æŠŠæ‰€æœ‰é¥¼å¹²èƒ½æ»¡è¶³çš„æœ€å¤§èƒƒå£çš„å‡ºç°æ¬¡æ•°ç»Ÿè®¡å‡ºæ¥ï¼Œæ”¾åˆ°å¦ä¸€ä¸ªå“ˆå¸Œè¡¨é‡Œé¢ ä¸ç”¨unordered_mapï¼Œè¦æ’åºçš„ éå†ä¸€éå­©å­ï¼Œå¦‚æœå½“å‰é¥¼å¹²èƒ½æ»¡è¶³èƒƒå£ï¼Œå°±å°½é‡å¤šçš„å–‚ ç›´åˆ°è¿™ä¸ªå­©å­çš„èƒƒå£è¢«æ»¡è¶³åï¼Œi++ï¼Œä¸è¦j++ï¼Œä¹Ÿè®¸å½“å‰é¥¼å¹²è¿˜æ²¡æœ‰ç”¨å®Œï¼Œè€Œä¸”è¶³å¤Ÿä¸‹ä¸€ä¸ªå­©å­çš„èƒƒå£ å¦‚æœä¸èƒ½æ»¡è¶³èƒƒå£ï¼Œç”±äºmapæ˜¯æ’åºè¿‡çš„ï¼Œæ‰€ä»¥ä¹Ÿä¸€å®šä¸èƒ½æ»¡è¶³åé¢çš„å­©å­çš„è¦æ±‚ï¼Œå°±j++çœ‹ä¸‹ä¸€å—é¥¼å¹²çš„æƒ…å†µ ACä»£ç 1234567891011121314151617181920212223242526272829class Solution {public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) { map&lt;int, int&gt; bit, chi; for (int x : g) { chi[x]++; } for (int x : s) { bit[x]++; } int ans = 0; auto i = chi.begin(), j = bit.begin(); for (; i != chi.end() &amp;&amp; j != bit.end(); ) { if (i-&gt;first &lt;= j-&gt;first &amp;&amp; j-&gt;second &gt; 0) { int a = i-&gt;second; int b = j-&gt;second; int min = a &gt; b ? b : a; i-&gt;second -= min; j-&gt;second -= min; ans += min; if (i-&gt;second == 0) i++; } else { j++; } } return ans; }}; å¤§ä½¬æ€è·¯è´ªå¿ƒ + åŒæŒ‡é’ˆ æ’åºä¸¤ä¸ªæ•°ç»„ å…¶ä»–æ€è·¯å’Œæˆ‘çš„åŸºæœ¬ä¸€æ ·ï¼Œä½†æ˜¯äººå®¶çš„ä»£ç åˆç®€æ´æ•ˆç‡åˆé«˜ å¤§ä½¬ä»£ç 12345678910111213141516class Solution {public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) { sort(g.begin(), g.end()); sort(s.begin(), s.end()); int ans = 0; int i = 0, j = 0; int len1 = g.size(), len2 = s.size(); for (; i &lt; len1 &amp;&amp; j &lt; len2;j++) { if (g[i] &lt;= s[j]) { i++; } } return i; }}; 461. æ±‰æ˜è·ç¦»æ€è·¯ä½è¿ç®— å¼‚æˆ–ï¼Œç›¸åŒä¸º1ï¼Œä¸åŒä¸º0 ä¸¤ä¸ªæ•°å¼‚æˆ–ï¼Œè½¬äºŒè¿›åˆ¶ï¼ŒæŠŠäºŒè¿›åˆ¶ä½ç›´æ¥åŠ èµ·æ¥å°±è¡Œ ACä»£ç 123456789101112class Solution {public: int hammingDistance(int x, int y) { int ans = x ^ y; int num = 0; while (ans) { num += ans % 2; ans /= 2; } return num; }}; 463. å²›å±¿çš„å‘¨é•¿æ€è·¯ åªèƒ½æš´æœäº†ï¼Œå¦‚æœä¸€ä¸ªæ ¼å­ä¸Šæœ‰é¢œè‰²ï¼Œæ€»è¾¹æ•°+=4 å¦‚æœä¸‹æ–¹æœ‰æ ¼å­ï¼Œæ€»è¾¹æ•°-=2ï¼ˆä¸ç®¡ä¸Šé¢ï¼Œé˜²æ­¢ä¸¤æ¡è¾¹é‡å¤è®¡æ•°ï¼‰ å¦‚æœå³è¾¹æœ‰æ ¼å­ï¼Œæ€»è¾¹æ•°-=2ï¼ˆåŒç†ï¼Œä¸ç®¡å·¦è¾¹ï¼‰ ACä»£ç 12345678910111213141516171819202122class Solution {public: int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int ans = 0; int len = grid.size(); int wide = grid[0].size(); for(int i = 0; i &lt; len; i++) { for (int j = 0; j &lt; wide; j++) { if (grid[i][j]) { ans += 4; if (i + 1 &lt; len &amp;&amp; grid[i + 1][j]) { ans -= 2; } if (j + 1 &lt; wide &amp;&amp; grid[i][j + 1]) { ans -= 2; } } } } return ans; }}; 476. æ•°å­—çš„è¡¥æ•°æ€è·¯ è½¬äºŒè¿›åˆ¶æ•° (num%2+1)%2èƒ½è®©1å˜0ï¼Œ0å˜1 ACä»£ç 12345678910111213class Solution {public: int findComplement(int num) { int n = 0; long long i = 1; while (num) { n += i * ((num % 2 + 1) % 2); i *= 2; num /= 2; } return n; }}; å¤§ä½¬æ€è·¯ä½è¿ç®—ï¼Œä¸æ‡‚ å¤§ä½¬ä»£ç 123456789101112class Solution {public: int findComplement(int num) { int temp = num; int c = 0; while ( temp &gt; 0 ) { temp &gt;&gt;= 1; c = ( c &lt;&lt; 1 ) + 1; } return num ^ c; }}; 482. å¯†é’¥æ ¼å¼åŒ–æ€è·¯ æŠŠ'-'å…¨éƒ½å˜æˆ' ' stringstreamæŠŠå­—ç¬¦ä¸²æ‹¼èµ·æ¥ å€’ç€éå†æ¯Kä¸ªåŠ ä¸€ä¸ª'-'ï¼Œå¹¶ä¸”æ³¨æ„å‰é¢æ˜¯ä¸æ˜¯å¤´ ACä»£ç 1234567891011121314151617181920212223class Solution {public: string licenseKeyFormatting(string S, int K) { string ans, buf; for (int i = 0; i &lt; S.length(); i++) { if (S[i] == '-') { S[i] = ' '; } else { S[i] = toupper(S[i]); } } stringstream ss(S); while (ss &gt;&gt; buf) { ans += buf; } for (int i = ans.length() - 1, count = 1; i &gt; 0; i--, count++) { if (count % K == 0 &amp;&amp; i != 0) { ans.insert(i, 1, '-'); } } return ans; }}; æ€è·¯ éå†ï¼Œåˆ¤æ–­æ˜¯ä¸æ˜¯å­—æ¯ï¼Œæ˜¯å­—æ¯ï¼Œå˜å¤§å†™ï¼Œç„¶åpushåˆ°æ–°çš„stringé‡Œé¢ åŒæ—¶è®°å½•å­—ç¬¦æ•°ï¼Œæ¯Kä¸ªåŠ ä¸€ä¸ªè´Ÿå· æ¸…é™¤å‰åçš„è´Ÿå· åè½¬ ACä»£ç 123456789101112131415161718192021222324class Solution {public: string licenseKeyFormatting(string S, int K) { string ans; int count = 0; int len = S.length(); for (int i = len; i &gt;= 0; i--) { char t = S[i]; t = toupper(t); if (t != '-') { ans.push_back(t); if (count == K /*&amp;&amp; i != 0 &amp;&amp; i != len*/) { ans.push_back('-'); count = 0; } count++; } } if (ans.back() == '-') ans.pop_back(); reverse(ans.begin(), ans.end()); if (ans.back() == '-') ans.pop_back(); return ans; }}; 485. æœ€å¤§è¿ç»­1çš„ä¸ªæ•°ACä»£ç 123456789101112131415161718class Solution {public: int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int count = 0, max = 0; for (int x : nums) { if (x) { count++; } else { //max = max &gt; count ? max : count; if (max &lt; count) max = count; count = 0; } } if (max &lt; count) max = count; return max; }}; 500. é”®ç›˜è¡Œæ€è·¯ å»ºç«‹å“ˆå¸Œè¡¨ï¼ŒæŠŠæ¯ä¸ªå­—æ¯å¯¹åº”çš„é”®ç›˜è¡Œæ•°æ ‡å· éå†æ‰€æœ‰å­—ç¬¦ä¸²ï¼Œçœ‹æ˜¯ä¸æ˜¯åŒä¸€è¡Œï¼Œç»Ÿè®¡ï¼Œè®°å½• æŒ‰ç…§è¦æ±‚è¾“å‡º ACä»£ç 12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;string&gt; findWords(vector&lt;string&gt;&amp; words) { string keyBoard[3] = {&quot;QWERTYUIOP&quot;, &quot;ASDFGHJKL&quot;, &quot;ZXCVBNM&quot;}; unordered_map&lt;char, char&gt; m; for (int i = 0; i &lt; 3; i++) { int len = keyBoard[i].length(); for (int j = 0; j &lt; len; j++) { m[keyBoard[i][j]] = i; m[keyBoard[i][j] - 'A' + 'a'] = i; } } int n = words.size(); vector&lt;string&gt; ans; for (int i = 0; i &lt; n; i++) { int len = words[i].length(); int cmp = m[words[i][0]]; bool find = true; for (int j = 0; j &lt; len; j++) { if (cmp != m[words[i][j]]) { find = false; break; } } if (find) { ans.push_back(words[i]); } } return ans; }}; 504. ä¸ƒè¿›åˆ¶æ•°æ€è·¯å°±æ˜¯æ™®é€šè¿›åˆ¶è½¬æ¢é—®é¢˜ ACä»£ç 123456789101112131415161718class Solution {public: string convertToBase7(int num) { string ans; bool nagetive = num &lt; 0; if (nagetive) { num *= -1; } do { ans = (char)(num % 7 + '0') + ans; num /= 7; } while (num); if (nagetive){ ans = &quot;-&quot; + ans; } return ans; }}; 506. ç›¸å¯¹åæ¬¡æ€è·¯ æ‹·è´ä¸€ä»½ï¼Œæ’åºï¼Œmapè®°å½•æ’å éå†åŸæ¥çš„æ•°ç»„ï¼Œè¾“å‡º ACä»£ç 12345678910111213141516171819202122class Solution {public: vector&lt;string&gt; findRelativeRanks(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; copy = nums; string rank[3] = {&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;}; map&lt;int, int&gt; m; sort(copy.begin(), copy.end(), greater&lt;int&gt;()); int len = nums.size(); for (int i = 0; i &lt; len; i++) { m[copy[i]] = i; } vector&lt;string&gt; ans; for (auto x : nums) { if (m[x] &gt;= 0 &amp;&amp; m[x] &lt; 3) { ans.push_back(rank[m[x]]); } else { ans.push_back(to_string(m[x] + 1)); } } return ans; }}; 507. å®Œç¾æ•°æ€è·¯ACä»£ç 12345678910111213class Solution {public: bool checkPerfectNumber(int num) { if (num &lt;= 1) return false; int ans = 1; for (int i = 2; i &lt; sqrt(num); i++) { if (num % i == 0) { ans += i + num/i; } } return ans == num; }}; æ€è·¯$1*10^8$çš„å®Œç¾æ•°åªæœ‰6,28,496,8128,33550336 ACä»£ç 12345678910111213class Solution { public boolean checkPerfectNumber(int num) { switch(num) { case 6: case 28: case 496: case 8128: case 33550336: return true; } return false; }} 509. æ–æ³¢é‚£å¥‘æ•°æ€è·¯å±…ç„¶çœŸçš„åªæ˜¯æ±‚æ–æ³¢é‚£å¥‘æ•°åˆ—ï¼Œè¿˜åªè¦å‰30ä½ ACä»£ç 123456789101112class Solution {public: int fib(int N) { int a = 0, b = 1; for (int i = 0; i &lt; N; i++) { int c = a + b; b = a; a = c; } return a; }}; 520. æ£€æµ‹å¤§å†™å­—æ¯æ€è·¯ å…ˆæŠŠå‰å¯¼çš„å¤§å†™å­—æ¯è·³è¿‡ å¦‚æœå½“å‰æŒ‡é’ˆæ­£å¥½æŒ‡åœ¨0æˆ–1ï¼Œé‚£ä¹ˆåªè¦åé¢æœ‰å¤§å†™å­—æ¯ï¼Œå°±ç®—é”™ï¼ˆé™¤éé•¿åº¦åªæœ‰1ï¼‰ å¦‚æœæŒ‡åœ¨1åé¢ï¼Œé‚£ä¹ˆåé¢æœ‰å°å†™å­—æ¯å°±ç®—é”™ ACä»£ç class Solution { public: bool detectCapitalUse(string word) { int len = word.length(); int i = 0; while (i &lt; len &amp;&amp; word[i] &gt;= 'A' &amp;&amp; word[i] &lt;= 'Z') i++; if (i &gt; 1) { for ( ; i &lt; len; i++) { if (word[i] &gt;= 'a' &amp;&amp; word[i] &lt;= 'z') { return false; } } } else { if (len &lt;= 1) { return true; } else { for ( ; i &lt; len; i++) { if (word[i] &gt;= 'A' &amp;&amp; word[i] &lt;= 'Z') { return false; } } } } return true; } };","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%935/"},{"title":"LeetCode-4","text":"172. é˜¶ä¹˜åçš„é›¶æ€è·¯æŠŠ2ï¼Œ5çš„å€æ•°æ‹†æˆ2ï¼Œ5ï¼Œæ•°5çš„ä¸ªæ•°ï¼ˆ2ä¸€å®šæ¯”5å¤šï¼‰ï¼Œè¿™æ ·5ä¸€å®šå’Œ2é…å¯¹ï¼Œæ‰€ä»¥5çš„ä¸ªæ•°å°±æ˜¯æœ«å°¾0çš„ä¸ªæ•° ACä»£ç 1234567891011class Solution {public: int trailingZeroes(int n) { int ans = 0; while (n) { n /= 5; ans += n; } return ans; }}; 123456class Solution {public: int trailingZeroes(int n) { return n == 0 ? 0 : n/5 + trailingZeroes(n / 5); }}; 189. æ—‹è½¬æ•°ç»„æ€è·¯ï¼ˆé€’å½’ï¼‰ k %= nums.size();å–ä½™æ•°ï¼Œä¸è¦å¾ªç¯å¥½å¤šåœˆ æŠŠå‰kä¸ªæ•°å’Œåkä¸ªæ•°äº¤æ¢ æŠŠä»ä¸‹æ ‡kåˆ°ç»“æŸçš„æ•°ä½œä¸ºæºæ•°æ®è°ƒç”¨æœ¬å‡½æ•° ACä»£ç 1234567891011121314151617181920212223class Solution {public: void rotate(vector&lt;int&gt;&amp; nums, int k) { go(0, k, nums); /* æ—¶é—´å¤æ‚åº¦O(n^2/k) ç©ºé—´å¤æ‚åº¦O(1) */ } void go(int beg, int k, vector&lt;int&gt;&amp; nums) { k %= nums.size() - beg; if (k == 0) return; for (int i = beg; i &lt; beg + k; i++) { swap(nums[i], nums[nums.size() - k + i - beg]); } go(beg + k, k, nums); } void swap(int&amp; a, int&amp; b) { int t = a; a = b; b = t; }}; æ€è·¯ æŠŠæ•´ä¸ªæ•°ç»„åè½¬ä¸€æ¬¡ å‰0åˆ°k-1åè½¬ä¸€æ¬¡ åkåˆ°ç»“æŸåè½¬ä¸€æ¬¡ ACä»£ç 12345678910111213141516171819202122class Solution {public: void rotate(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); k %= n; reverse(nums, 0, n - 1); reverse(nums, 0, k - 1); reverse(nums, k, n - 1); /* æ—¶é—´å¤æ‚åº¦O(n) ç©ºé—´å¤æ‚åº¦O(1) */ /*------------------------------*/ } void reverse(vector&lt;int&gt;&amp; nums, int begin, int end) { while (begin &lt; end) { int n = nums[begin]; nums[begin++] = nums[end]; nums[end--] = n; } }}; 190. é¢ å€’äºŒè¿›åˆ¶ä½æ€è·¯ å¾ªç¯æ¨¡2ï¼Œ2è¿›åˆ¶è½¬2è¿›åˆ¶ æ³¨æ„åŸæ¥çš„æ•°çš„å‰å¯¼0ä¹Ÿè¦æ·»åŠ åˆ°åé¢ï¼Œæ‰€ä»¥å¾ªç¯æ¡ä»¶æ˜¯å¾ªç¯æ¬¡æ•°32æ¬¡ï¼ˆå› ä¸ºç»™çš„æ˜¯32ä½æ— ç¬¦å·æ•°ï¼‰ ACä»£ç 1234567891011121314class Solution {public: uint32_t reverseBits(uint32_t n) { uint32_t ans = 0; int i = 32; while (i--) { ans *= 2; ans += n % 2; n /= 2; } return ans; }}; 191. ä½1çš„ä¸ªæ•°ACä»£ç 1234567891011class Solution {public: int hammingWeight(uint32_t n) { int c = 0; while (n) { if (n % 2 == 1)c++; n/=2; } return c; }}; 202. å¿«ä¹æ•°æ€è·¯ è®¡ç®—ï¼Œçœ‹æœ‰æ²¡æœ‰é‡å¤ï¼Œæœ‰é‡å¤å°±è¯´æ˜ä¸æ˜¯å¿«ä¹æ•° è®¡ç®—ï¼Œå‡ºç°4å°±ä¸æ˜¯å¿«ä¹æ•°ï¼ˆä¸æ˜¯å¿«ä¹æ•°çš„æ•°ç§°ä¸ºä¸å¿«ä¹æ•°ï¼ˆunhappy numberï¼‰ï¼Œæ‰€æœ‰ä¸å¿«ä¹æ•°çš„æ•°ä½å¹³æ–¹å’Œè®¡ç®—ï¼Œæœ€å¾Œéƒ½ä¼šè¿›å…¥ 4 â†’ 16 â†’ 37 â†’ 58 â†’ 89 â†’ 145 â†’ 42 â†’ 20 â†’ 4 çš„å¾ªç¯ä¸­ã€‚ï¼‰ ACä»£ç 1234567891011121314151617181920class Solution {public: bool isHappy(int n) { map&lt;int, int&gt; m; while (n != 1) { m[n]++; if (m[n] &gt; 1) break; n = get(n); } return n == 1; } int get(int n) { int ans = 0; while (n) { ans += (n % 10) * (n % 10); n /= 10; } return ans; }}; ACä»£ç 1234567891011121314151617181920class Solution {public: bool isHappy(int n) { while (n != 1) { if (n == 4) { return false; } n = get(n); } return true; } int get(int n) { int ans = 0; while (n) { ans += (n % 10) * (n % 10); n /= 10; } return ans; }}; 203. ç§»é™¤é“¾è¡¨å…ƒç´ æ€è·¯å¦‚æœå¤´ç»“ç‚¹æ˜¯è¦åˆ çš„å…ƒç´ ï¼Œè¿›è¡Œçš„æ“ä½œä¸å¤ªä¸€æ ·ï¼Œè¦å•ç‹¬è€ƒè™‘ï¼Œç„¶åè¿›è¡Œåé¢çš„åˆ é™¤ã€‚è¯„è®ºåŒºå¥½å¤šç”¨c++çš„éƒ½ä¸ç®¡å†…å­˜æ³„æ¼ã€‚ä¸æ˜¯å¥½ä¹ æƒ¯ï¼Œåšå†³æœç»ï¼ ACä»£ç 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* removeElements(ListNode* head, int val) { ListNode* move = head, *last = head; while (head != NULL &amp;&amp; head-&gt;val == val) { head = head-&gt;next; delete last; last = head; } move = head; while (move != NULL) { if (move-&gt;val == val){ last-&gt;next = move-&gt;next; delete move; } else { last = move; } move = last-&gt;next; } return head; }}; 204. è®¡æ•°è´¨æ•°æ€è·¯ç”¨ç­›æ³•ä¸¤ä¸ªforå¾ªç¯æŠŠä¸æ˜¯ç´ æ•°çš„éƒ½ç­›å‡ºæ¥ä½†æ˜¯è¦æå‡æ€§èƒ½: å¿½ç•¥å¶æ•° å¦‚æœå½“å‰æ•°å·²ç»ç®—è¿‡äº†ï¼Œå°±ä¸è¦ç®— ç”¨boolçš„vectorï¼Œboolä¸€å­—èŠ‚ï¼Œæ¯”intçŸ­ï¼Œä¹Ÿå¯ä»¥åŠ é€Ÿ ACä»£ç 1234567891011121314151617181920212223242526272829303132333435class Solution{ public: int countPrimes(int n) { if (n &lt;= 2) return 0; int count = 1; vector&lt;bool&gt; notPrime(n,0); for (int i = 3; i &lt; sqrt(n); i += 2) { if (notPrime[i] == 1)continue; for (int j = 3; j * i &lt;= n; j += 2) { notPrime[i * j] = 1; } } notPrime[0] = 1; notPrime[1] = 1; notPrime[3] = 0; notPrime[4] = 1; notPrime[5] = 0; notPrime[6] = 1; notPrime[7] = 0; notPrime[8] = 1; notPrime[9] = 1; for (int i = 1; i &lt; n; i += 2) { if (notPrime[i] == 0) count++; } return count; }}; æœ€å¿«å¤§ä½¬çš„ä»£ç æ€è·¯çœ‹ä¸æ‡‚123456789101112131415161718192021222324252627282930313233class Solution {public: int countPrimes(int n) { if (n &lt; 3) return 0; size_t len = (n-2) &gt;&gt; 1; //cout &lt;&lt; len &lt;&lt; endl; vector&lt;char&gt; v(len, 0); int count = 1; uint i = 0; auto m = min(len, 0x7FFEuL); while (i &lt; m) { if (!v[i]) { ++count; uint p = (i &lt;&lt; 1) + 3; //if (p &lt; 0x10000) { uint pp = p * p; uint j = (pp - 3) &gt;&gt; 1; while(j &lt; len) { v[j] = true; j += p; } } ++i; } while (i &lt; len) { if (!v[i]) ++count; ++i; } return count; }}; 205. åŒæ„å­—ç¬¦ä¸²æ€è·¯ä¸å¤ªä¼šï¼ŒæŠ„çš„è¯„è®ºåŒºä»£ç ï¼Œä½†æ˜¯è¦æ³¨æ„ï¼Œä¸€ä¸ªå­—æ¯aå¦‚æœæ›¿æ¢æˆbï¼Œå°±ä¸èƒ½æ›¿æ¢ä¸ºc ACä»£ç 1234567891011121314151617181920212223static const int boost = [](){ ios::sync_with_stdio(false); cin.tie(nullptr); return 0;}();class Solution {public: bool isIsomorphic(string s, string t) { int alphabetS[256], alphabetT[256], num = 0; memset(alphabetS, 0, sizeof(alphabetS)); memset(alphabetT, 0, sizeof(alphabetT)); int len = s.length(); for (int pos = 0; pos &lt; len; pos++) { if(alphabetS[s[pos]] != alphabetT[t[pos]]) return false; else if (alphabetS[s[pos]] == 0) alphabetS[s[pos]] = alphabetT[t[pos]] = ++num; } return true; }}; 206. åè½¬é“¾è¡¨æ€è·¯ æŠŠç»“ç‚¹å…¨éƒ½å­˜åˆ°æ•°ç»„é‡Œ é€’å½’ï¼Œè°ƒç”¨è‡ªå·±ï¼Œå†æŠŠå¤´ç»“ç‚¹å˜æˆå°¾å·´ç»“ç‚¹ ACä»£ç 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseList(ListNode* head) { vector&lt;ListNode*&gt; v; ListNode *temp = head; while (temp != NULL) { v.push_back(temp); temp = temp-&gt;next; } int len = v.size(); for (int i = 0; i &lt; len / 2; i++) { int swap = v[i]-&gt;val; v[i]-&gt;val = v[len - 1 - i]-&gt;val; v[len - 1 - i]-&gt;val = swap; } return head; }}; 12345678910class Solution {public: ListNode* reverseList(ListNode* head) { if (head == NULL || head-&gt;next == NULL) return head; ListNode *temp = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return temp; }}; 217. å­˜åœ¨é‡å¤å…ƒç´ æ€è·¯ è°ƒç”¨apiï¼Œå…ˆsortï¼Œå†è°ƒç”¨uniqueï¼Œåˆ¤æ–­è¿”å›å€¼æ˜¯ä¸æ˜¯end()è¿­ä»£å™¨ï¼Œæ˜¯åˆ™æ²¡æœ‰é‡å¤ ACä»£ç 12345678class Solution {public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); return unique(nums.begin(), nums.end()) != nums.end(); }}; 123456789101112class Solution {public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); int len = nums.size(); for (int i = 1; i &lt; len; i++) { if (nums[i - 1] == nums[i]) return true; } return false; }}; 225. ç”¨é˜Ÿåˆ—å®ç°æ ˆæ€è·¯queueæ˜¯å…ˆè¿›å…ˆå‡ºï¼Œstackæ˜¯åè¿›å…ˆå‡ºã€‚ ç”¨dequeå®ç° æ¯æ¬¡pushçš„å…ƒç´ åï¼Œè®©é˜Ÿåˆ—å¾ªç¯popå‡ºæ¥å†pushå›å»ï¼Œä½¿å¾—åˆšåˆšpushçš„å…ƒç´ å˜æˆç¬¬ä¸€ä¸ª ACä»£ç 1234567891011121314151617181920212223242526class MyStack {public: queue&lt;int&gt; data; MyStack() { } void push(int x) { data.push(x); int len = data.size() - 1; while (len--) { data.push(data.front()); data.pop(); } } int pop() { int x = data.front(); data.pop(); return x; } int top() { return data.front(); } bool empty() { return data.empty(); }}; 1234567891011121314151617181920class MyStack {public: deque&lt;int&gt; data; MyStack() { } void push(int x) { data.push_front(x); } int pop() { int x = data.front(); data.pop_front(); return x; } int top() { return data.front(); } bool empty() { return data.empty(); }}; 226. ç¿»è½¬äºŒå‰æ ‘æ€è·¯ é€’å½’ æ·±åº¦ä¼˜å…ˆ å¹¿åº¦ä¼˜å…ˆ ACä»£ç 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* invertTree(TreeNode* root) { go(root); return root; } void go(TreeNode* root) { if (root == NULL) return; TreeNode* temp = root-&gt;left; root-&gt;left = root-&gt;right; root-&gt;right = temp;//å¹¿åº¦ä¼˜å…ˆ go(root-&gt;left); go(root-&gt;right); }}; 123456789101112class Solution {public: TreeNode* invertTree(TreeNode* root) { if (root == NULL) return root; TreeNode*left = invertTree(root-&gt;right);//æ·±åº¦ä¼˜å…ˆ TreeNode*right = invertTree(root-&gt;left); root-&gt;right = right; root-&gt;left = left; return root; }}; 231. 2çš„å¹‚æ€è·¯ å–2å¯¹æ•°çœ‹æ˜¯ä¸æ˜¯æ•´æ•° åˆ©ç”¨äºŒè¿›åˆ¶ä½è¿ç®— å‡è®¾ä¸€ä¸ªæ— ç¬¦å·æ•°æ˜¯å…¨1çš„ï¼Œé‚£ä¹ˆå®ƒæ˜¯2^k-1 å‡è®¾2^k = nï¼Œé‚£ä¹ˆåªè¦ä¸€ä¸ªæ•°æ»¡è¶³(n)&amp;(n-1) == 0ï¼ŒæŒ‰ä½ç›¸ä¸ ACä»£ç 123456class Solution {public: bool isPowerOfTwo(int n) { return (int)log2(n) == log2(n); }}; 1234567class Solution {public: bool isPowerOfTwo(int n) { if (n &gt; 0 &amp;&amp; ((n)&amp;(n-1)) == 0) return true; return false; }}; 232. ç”¨æ ˆå®ç°é˜Ÿåˆ—æ€è·¯ åˆ›å»ºä¸¤ä¸ªæ ˆsã€mï¼Œæ¯æ¬¡pushå­˜åˆ°sé‡Œé¢ï¼Œç„¶åå†é€ä¸ªå¼¹å‡ºsä¸­çš„å…ƒç´ å‹åˆ°mä¸­ï¼ˆè¿™ä¸ªè¿‡ç¨‹ä¸­sè¦å…ˆæ‹·è´ä¸€ä»½ï¼‰ æ¯æ¬¡popçš„æ—¶å€™ï¼Œä»mä¸­popï¼Œç„¶åå†é€ä¸ªå¼¹å‡ºmä¸­çš„å…ƒç´ å‹åˆ°sä¸­ï¼ˆè¿™ä¸ªè¿‡ç¨‹ä¸­sè¦å…ˆæ‹·è´ä¸€ä»½ï¼‰ mç”¨æ¥å¯¹é¡¶éƒ¨å…ƒç´ æ“ä½œï¼Œsæ¥ä¿æŒé˜Ÿå½¢ ACä»£ç 123456789101112131415161718192021222324252627282930313233class MyQueue {public: stack&lt;int&gt; s; stack&lt;int&gt; m; MyQueue() { } void push(int x) { s.push(x); update(s,m); } void update(stack&lt;int&gt; a, stack&lt;int&gt;&amp; b) { int len = a.size(); while (!b.empty()){ b.pop(); } while (len--) { b.push(a.top()); a.pop(); } } int pop() { int x = m.top(); m.pop(); update(m,s); return x; } int peek() { return m.top(); } bool empty() { return m.empty(); }}; 234. å›æ–‡é“¾è¡¨æ€è·¯ï¼ˆæš‚æ—¶æ²¡æœ‰è¾¾åˆ°ç©ºé—´O(1)ï¼‰vectorå­˜ç»“ç‚¹åœ°å€ACä»£ç 123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: bool isPalindrome(ListNode* head) { /*ListNode* temp = head; vector&lt;ListNode*&gt; v; while (temp != NULL) { v.push_back(temp); temp = temp-&gt;next; } int len = v.size(); for (int i = 0; i &lt; len / 2; i++) { if (v[i]-&gt;val != v[len - 1 - i]-&gt;val) return false; } return true;*/ }}; 292. Nimæ¸¸æˆæ€è·¯å·´ä»€åšå¥•ï¼Œn%(m+1)!=0æ—¶ï¼Œå…ˆæ‰‹æ€»æ˜¯ä¼šèµ¢çš„mä¸ºæ¯æ¬¡æŠ½æ’çš„æœ€å¤§å¼ æ•° ACä»£ç 123456class Solution {public: bool canWinNim(int n) { return n%4 != 0; }}; 242. æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯æ€è·¯å°±æ˜¯çœ‹æ¯ä¸ªå­—æ¯çš„ä½¿ç”¨æ¬¡æ•°ä¸€ä¸ä¸€æ ·ä¸€ä¸ªæ•°ç»„ï¼Œè®°å½•å­—æ¯çš„ä½¿ç”¨æ¬¡æ•°ï¼Œæœ€åæ¬¡æ•°ä¸€æ ·å°±è¡Œã€‚ ACä»£ç 1234567891011121314class Solution {public: bool isAnagram(string s, string t) { int a[26] = {0}, b[26] = {0}; for (int i = 0; i &lt; s.length(); i++) a[s[i] - 'a']++; for (int i = 0; i &lt; t.length(); i++) b[t[i] - 'a']++; for (int i = 0; i &lt; 26; i++) { if (a[i] != b[i]) return false; } return true; }}; 258. å„ä½ç›¸åŠ ###ACä»£ç  123456789101112131415class Solution {public: int addDigits(int num) { while (num/10 != 0) { int ans = 0; while (num) { ans += num%10; num /= 10; } num = ans; } return num; return num == 0 ? 0 : num - 9 * ((num - 1) / 9) ; }}; 263. ä¸‘æ•°æ€è·¯å¦‚æœn % m == 0,è¯´æ˜nä¸­è‡³å°‘æœ‰ä¸€ä¸ªmçš„å› æ•°ï¼Œå¾ªç¯n%m == 0æ—¶é‡å¤n /= mï¼Œå¯ä»¥å»é™¤æ‰€æœ‰çš„mçš„å› æ•°ï¼Œæ ¹æ®è¿™ä¸ªæ€è·¯ï¼Œå¦‚æœæ˜¯ä¸‘æ•°ï¼ŒæŠŠæ‰€æœ‰2ï¼Œ3ï¼Œ5çš„å› æ•°å»é™¤ä»¥åï¼Œå°±æ˜¯1äº† ACä»£ç 12345678910class Solution {public: bool isUgly(int num) { if (num &lt;= 0) return false; while (num%2 == 0) num /= 2; while (num%3 == 0) num /= 3; while (num%5 == 0) num /= 5; return num == 1; }}; 268. ç¼ºå¤±æ•°å­—æ€è·¯ 0-n 11 ä¸ªæ•°ä¸­ç¼ºäº†ä¸€ä¸ªï¼Œå¯ä»¥å…ˆç®—å‡ºç­‰å·®æ•°åˆ—çš„sum(0,n)ï¼Œç„¶åå˜é‡æ•°ç»„å‡å»æ‰€æœ‰å…ƒç´ ï¼Œæœ€åçš„å·®å°±æ˜¯ç¼ºå°‘çš„å…ƒç´  çœ‹ä¸æ‡‚çš„ä½è¿ç®—ï¼Œå¼‚æˆ–æŠµæ¶ˆ ACä»£ç 1234567891011class Solution {public: int missingNumber(vector&lt;int&gt;&amp; nums) { int ans = nums.size(); ans = ans*(ans+1)/2; for (int x : nums) { ans -= x; } return ans; }}; 123456789101112class Solution {public: int missingNumber(vector&lt;int&gt;&amp; nums) { int sum = nums.size(); int len = sum; for (int i = 0; i &lt; len; i++) { sum ^= nums[i]; sum ^= i; } return sum; }}; 278. ç¬¬ä¸€ä¸ªé”™è¯¯çš„ç‰ˆæœ¬æ€è·¯æš´åŠ›æœç´¢ä¸å¯å–ï¼ŒäºŒåˆ†æŸ¥æ‰¾ä¿å¹³å®‰ ACä»£ç 12345678910111213141516171819202122// Forward declaration of isBadVersion API.bool isBadVersion(int version);class Solution {public: int firstBadVersion(int n) { long long mid , a = 1, b = n; if (isBadVersion(1)) return 1; while (a &lt;= b) { mid=a+(b-a)/2; bool bad, left, right; bad = isBadVersion(mid); left = isBadVersion(mid - 1); right = isBadVersion (mid + 1); if (bad &amp;&amp; !left) return mid; else if (bad &amp;&amp; right) b = mid - 1; else a = mid + 1; } if (isBadVersion(n)) return n; return -1; }}; 283. ç§»åŠ¨é›¶æ€è·¯ å†’æ³¡æ’åºçš„æ€æƒ³ï¼Œä¸è¿‡æ¡ä»¶æ¢æˆå·¦è¾¹çš„æ•°æ˜¯0ï¼Œåˆ™äº¤æ¢ä¸€æ¬¡ åŒæŒ‡é’ˆï¼Œä»å·¦å¾€å³éå† ACä»£ç 123456789101112131415class Solution {public: void moveZeroes(vector&lt;int&gt;&amp; nums) { int len = nums.size(); for (int i = len - 1; i &gt;= 0; i--) { for (int j = len - 2; j &gt;= 0; j--) { if (nums[j] == 0) { int temp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = temp; } } } }}; 123456789101112131415class Solution {public: void moveZeroes(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int pos = 0; for (int i = 0; i &lt; len; i++) { if (nums[i] != 0) { nums[pos++] = nums[i]; } } for (int i = pos; i &lt; len; i++) { nums[i] = 0; } }}; 290. å•è¯æ¨¡å¼æ€è·¯ å»ºç«‹ä¸¤ä¸ªmapï¼ŒéªŒè¯æ˜ å°„æ˜¯ä¸€ä¸€æ˜ å°„ å¦‚æœå½“å‰å€¼åœ¨a-&gt;bä¸”b-&gt;açš„æ˜ å°„éƒ½æ˜¯ç©ºï¼Œé‚£ä¹ˆæ·»åŠ è¿™ä¸¤ä¸ªæ˜ å°„ å¦‚æœæœ‰ä¸€ä¸ªæ˜¯å­˜åœ¨çš„ï¼Œçœ‹ä¸¤ä¸ªæ˜ å°„çš„ç»“æœä¸å½“å‰å€¼æ˜¯å¦ç›¸ç­‰ï¼Œä¸ç›¸ç­‰è¿”å›false å¾ªç¯å®‰å…¨ç»“æŸï¼Œè¿”å›true ACä»£ç 1234567891011121314151617181920212223242526class Solution {public: bool wordPattern(string pattern, string str) { unordered_map&lt;char, string&gt; m; unordered_map&lt;string, char&gt; n; vector&lt;string&gt; strs; stringstream ss(str); string buf; while (ss &gt;&gt; buf) { strs.push_back(buf); } if (strs.size() != pattern.length()) return false; int len = pattern.length(); for (int i = 0; i &lt; len; i++) { if (m[pattern[i]] == &quot;&quot; &amp;&amp; n[strs[i]] == 0) { m[pattern[i]] = strs[i]; n[strs[i]] = pattern[i]; } else { if (m[pattern[i]] != strs[i] || n[strs[i]] != pattern[i]) { return false; } } } return true; }}; 303. åŒºåŸŸå’Œæ£€ç´¢ - æ•°ç»„ä¸å¯å˜æ€è·¯é¢˜ç›®ä¿è¯æ•°ç»„ä¸ä¼šæ”¹å˜ï¼Œä¸”è¦å¤šæ¬¡è°ƒç”¨sumRange()ï¼Œé‡‡ç”¨ä»¥ä¸‹æ–¹æ³•æé«˜æ•ˆç‡ ç±»æ¯”æ•°åˆ—çš„çŸ¥è¯†ï¼Œåˆ›å»ºä¸€ä¸ªvectorï¼Œå­˜æ”¾å‰ié¡¹å’Œ åœ¨æ„é€ å¯¹è±¡æ—¶ï¼Œå˜é‡ä¸€éæ•°ç»„O(N)ï¼Œå¾—åˆ°æ‰€æœ‰çš„å‰né¡¹å’Œ æ¯æ¬¡è°ƒç”¨å‡½æ•°æ—¶ï¼Œç›´æ¥è¿”å›ä¸¤ä¸ªsjå’Œsi-1çš„å·®å³å¯ ä¸ºäº†å‡å°‘if-elseçš„æ‰§è¡Œï¼Œæ•°æ®çš„ç¬¬ä¸€ä¸ªåœ°æ–¹å­˜ä¸€ä¸ª0ï¼Œè¿™æ ·è¿”å›sj+1 - siå³å¯ ACä»£ç 1234567891011121314151617class NumArray {public: vector&lt;int&gt; s; NumArray(vector&lt;int&gt; nums) { int sum = 0; int len = nums.size(); s.push_back(0); for (int i = 0; i &lt; nums.size(); i++) { sum += nums[i]; s.push_back(sum); } } int sumRange(int i, int j) { return s[j + 1] - s[i]; }}; 326. 3çš„å¹‚æ€è·¯ çœ‹3^log3(n)å–æ•´ æ˜¯å¦ç­‰äºnæœ¬èº« ç”¨åˆ°äº†æ•°è®ºçš„çŸ¥è¯†ï¼Œ3çš„å¹‚æ¬¡çš„è´¨å› å­åªæœ‰3ï¼Œè€Œæ‰€ç»™å‡ºçš„nå¦‚æœä¹Ÿæ˜¯3çš„å¹‚æ¬¡ï¼Œæ•…è€Œé¢˜ç›®ä¸­æ‰€ç»™æ•´æ•°èŒƒå›´å†…æœ€å¤§çš„3çš„å¹‚æ¬¡çš„å› å­åªèƒ½æ˜¯3çš„å¹‚æ¬¡ï¼Œ1162261467æ˜¯3çš„19æ¬¡å¹‚ï¼Œæ˜¯æ•´æ•°èŒƒå›´å†…æœ€å¤§çš„3çš„å¹‚æ¬¡ ACä»£ç 1234567class Solution {public: bool isPowerOfThree(int n) { if (n &lt;= 0) return false; return (int)pow(3, round((log(n) / log(3)))) == n; }}; 123456class Solution {public: bool isPowerOfThree(int n) { return n &gt; 0 &amp;&amp; 1162261467%n == 0; }}; 342. 4çš„å¹‚æ€è·¯ çœ‹ä»¥log2(num)æ˜¯å¦ä¸ºå¶æ•° æŸ¥çœ‹äºŒè¿›åˆ¶çš„æ‰€æœ‰å¥‡æ•°ä½ï¼Œå…¨æ˜¯0å³å¯ï¼ˆå‚è§äºŒè¿›åˆ¶è½¬10è¿›åˆ¶å…¬å¼ï¼Œå¥‡æ•°ä¸ºä¸Šçš„2çš„æŒ‡æ•°éƒ½æ˜¯å¥‡æ•°ï¼‰ ACä»£ç 1234567class Solution { public: bool isPowerOfFour(long long num) { double n = log2(num); return (int)n == n ? (int)n % 2 == 0 : false; }}; 123456789class Solution { public: bool isPowerOfFour(long long num) { if (num &lt; 0 || num &amp; (num-1)){//check(is or not) a power of 2. return false; } return num &amp; 0x55555555;//check 1 on odd bits }}; 344. åè½¬å­—ç¬¦ä¸²ACä»£ç 123456class Solution {public: void reverseString(vector&lt;char&gt;&amp; s) { reverse(s.begin(), s.end()); }}; 345. åè½¬å­—ç¬¦ä¸²ä¸­çš„å…ƒéŸ³å­—æ¯ACä»£ç 1234567891011121314151617181920212223242526272829class Solution {public://åŒæŒ‡é’ˆæ³• string reverseVowels(string s) { int left = 0; int right = s.length() - 1; char m[128] = {0}; m['a'] = 1; m['e'] = 1; m['i'] = 1; m['o'] = 1; m['u'] = 1; m['A'] = 1; m['E'] = 1; m['O'] = 1; m['I'] = 1; m['U'] = 1; while (left &lt; right) { while (left &lt; right &amp;&amp; !m[s[left]]) left++; while (left &lt; right &amp;&amp; !m[s[right]]) right--; //åŠ ä¸Šleft&lt;rightçš„åˆ¤æ–­ æ¡ä»¶ï¼Œé˜²æ­¢æŠŠæ¢è¿‡æ¥çš„å­—æ¯æ¢å›å» char m = s[left]; s[left] = s[right]; s[right] = m; left++; right--; } return s; }}; 349. ä¸¤ä¸ªæ•°ç»„çš„äº¤é›†æ€è·¯ å…ˆæŠŠä¸¤ä¸ªæ•°ç»„æ’åºå»é‡ï¼Œç„¶åmapè®°å½•å‡ºç°æ¬¡æ•°ï¼Œç„¶åæŠŠå‡ºç°æ¬¡æ•°å¤§äº1çš„æŒ‘å‡ºæ¥ä½œä¸ºè¿”å›å€¼è¿”å› ACä»£ç 12345678910111213141516171819202122class Solution {public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { unordered_map&lt;int, int&gt; m; vector&lt;int&gt; v; sort(nums1.begin(), nums1.end()); nums1.erase(unique(nums1.begin(), nums1.end()), nums1.end()); sort(nums2.begin(), nums2.end()); nums2.erase(unique(nums2.begin(), nums2.end()), nums2.end()); for (int x : nums1) { m[x]++; } for (int x : nums2) { m[x]++; } for (auto x : m) { if (x.second &gt; 1) v.push_back(x.first); } return v; }};","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%934/"},{"title":"LeetCode-32","text":"1185. ä¸€å‘¨ä¸­çš„ç¬¬å‡ å¤© Tomohiko Sakamotoç®—æ³• è™½ç„¶æ˜¯ç®€å•é¢˜ä¹Ÿæœ‰å¾ˆå¤šçŸ¥è¯†ç‚¹å‘¢ è§£é‡Š 1234567891011121314class Solution {public: string dayOfTheWeek(int day, int month, int year) { // array with leading number of days values static int t[] = { 0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4 }; // if month is less than 3 reduce year by 1 if (month &lt; 3) year -= 1; return vector&lt;string&gt;{&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;} [((year + year / 4 - year / 100 + year / 400 + t[month - 1] + day) % 7)]; }}; 2583. äºŒå‰æ ‘ä¸­çš„ç¬¬ K å¤§å±‚å’Œ12345678910111213141516171819202122232425class Solution {public: long long kthLargestLevelSum(TreeNode* root, int k) { if(!root) return -1; priority_queue&lt;long long&gt; level_sum_q; queue&lt;TreeNode *&gt; q; q.push(root); while(!q.empty()) { int q_size = q.size(); long long level_sum = 0; while(q_size--) { TreeNode *node = q.front(); q.pop(); level_sum += node-&gt;val; if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); } level_sum_q.push(level_sum); } while(--k &amp;&amp; !level_sum_q.empty()) { level_sum_q.pop(); } return !level_sum_q.empty() ? level_sum_q.top() : -1; }}; ç”¨rangesè·å–ç¬¬kå¤§çš„æ•° 1234567891011121314151617181920212223242526class Solution {public: long long kthLargestLevelSum(TreeNode* root, int k) { if(!root) return -1; vector&lt;long long&gt; level_sums; queue&lt;TreeNode *&gt; q; q.push(root); int level_cnt = 0; while(!q.empty()) { int q_size = q.size(); long long level_sum = 0; while(q_size--) { TreeNode *node = q.front(); q.pop(); level_sum += node-&gt;val; if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); } level_sums.push_back(level_sum); level_cnt++; } if(level_cnt &lt; k) return -1; ranges::nth_element(level_sums, level_sums.end() - k); return level_sums[level_sums.size() - k]; }}; LCP 30. é­”å¡”æ¸¸æˆ å½“é‡åˆ°HPä¸å¤Ÿçš„æ—¶å€™ï¼Œè€ƒè™‘è´ªå¿ƒï¼Œä¾æ¬¡å°†å·²ç»é‡åˆ°è¿‡çš„æˆ¿é—´ä¸­æœ€å°çš„æˆ¿é—´å‘åç§»åŠ¨ ç§»åŠ¨åæ”¾å…¥delayä¸­ï¼Œæœ€ååŠ ä¸Šdelayçœ‹HPå¤Ÿä¸å¤Ÿå°±å¥½äº† 12345678910111213141516171819202122232425262728class Solution {public: int magicTower(vector&lt;int&gt;&amp; nums) { int n = nums.size(); long long HP = 1; int swapCnt = 0; auto cmp = [&amp;nums](int i, int j){ return nums[i] &gt; nums[j]; }; long long delay = 0; priority_queue&lt;int, vector&lt;int&gt;, decltype(cmp)&gt; q(cmp); for(int i = 0; i &lt; n; i++) { int room = nums[i]; if(room &lt; 0)q.push(i); int chance = n - i - 1; while(HP + room &lt;= 0 &amp;&amp; !q.empty() &amp;&amp; chance--) { int minIndex = q.top(); q.pop(); int room_min = nums[minIndex]; HP -= nums[minIndex]; delay += nums[minIndex]; swapCnt++; } HP += room; if(HP &lt;= 0) break; } HP += delay; return HP &gt; 0 ? swapCnt : -1; }}; 1696. è·³è·ƒæ¸¸æˆ VI çœ‹æç¤ºå°±ä¼šäº†12345678910111213141516171819class Solution {public: int maxResult(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); vector&lt;int&gt; dp(n, INT_MIN); auto cmp = [&amp;dp](int i, int j) {return dp[i] &lt; dp[j];}; priority_queue&lt;int, vector&lt;int&gt;, decltype(cmp)&gt; q(cmp); dp[0] = nums[0]; q.push(0); for(int i = 1; i &lt; n; i++) { while(q.top() &lt; i - k) q.pop(); int maxDp = dp[q.top()]; dp[i] = max(dp[i], maxDp + nums[i]); q.push(i); } return dp.back(); }}; 292. Nim æ¸¸æˆ ç”¨dp[i]è¡¨ç¤ºiä¸ªçŸ³å¤´æ˜¯å¦å­˜åœ¨å¿…èƒœç­–ç•¥ï¼Œå·²çŸ¥i = 1, 2, 3æ—¶ï¼Œä¸€å®šæœ‰å¿…èƒœç­–ç•¥ é‚£ä¹ˆå¯¹äº4ï¼Œæ— è®ºæˆ‘æ‹¿å¤šå°‘ï¼Œå¯¹æ‰‹éƒ½æœ‰å¿…èƒœç­–ç•¥ï¼Œé‚£ä¹ˆæˆ‘å¿…è¾“ å¯¹äº5ï¼Œ6ï¼Œ7ï¼Œæˆ‘åˆ†åˆ«æ‹¿1ï¼Œ2ï¼Œ3å°±ä¼šå¾—åˆ°4ï¼Œå¯¹æ‰‹é™·å…¥å¿…è¾“ï¼Œé‚£ä¹ˆæˆ‘å¿…èƒœ ä¹Ÿå°±æ˜¯å‰ä¸‰ä¸ªæ•°å…¨trueï¼Œæˆ‘å°±æ˜¯falseï¼Œå‰ä¸‰ä¸ªæ•°æœ‰falseï¼Œæˆ‘å°±æ˜¯true å¯ä»¥è¯æ˜ï¼Œ4çš„å€æ•°ä¸€å®šè¾“ è¿ç»­ä¸‰ä¸ªtrueåå¿…è·Ÿä¸€ä¸ªfalse æ¯ä¸ªfalseåé¢ä¸€å®šæœ‰3ä¸ªtrue 1234567891011121314151617class Solution {public: bool canWinNim(int n) { return n % 4 != 0; // ä¸‹é¢æ˜¯æ¨ç†è¿‡ç¨‹ vector&lt;bool&gt; dp(n+1); dp[0] = dp[1] = dp[2] = dp[3] = true; bool last1 = true, last2 = true, last3 = true; for(int i = 4; i &lt;= n; i++) { dp[i] = !(last1 &amp;&amp; last2 &amp;&amp; last3); last1 = last2; last2 = last3; last3 = dp[i]; if(!dp[i]) cout &lt;&lt; i &lt;&lt; &quot;,&quot;; } return dp[n]; }}; 2476. äºŒå‰æœç´¢æ ‘æœ€è¿‘èŠ‚ç‚¹æŸ¥è¯¢ä¸­åº+äºŒåˆ†12345678910111213141516171819202122class Solution { void inorder(TreeNode *root, vector&lt;int&gt;&amp; ans) { if(!root) return; inorder(root-&gt;left, ans); ans.push_back(root-&gt;val); inorder(root-&gt;right, ans); }public: vector&lt;vector&lt;int&gt;&gt; closestNodes(TreeNode* root, vector&lt;int&gt;&amp; queries) { vector&lt;int&gt; v; vector&lt;vector&lt;int&gt;&gt; ans; auto miniCmp = [](int x, int y) { return x &gt;= y;}; auto maxiCmp = [](int x, int y) { return x &lt;= y;}; inorder(root, v); for(int query : queries) { auto mini = upper_bound(v.rbegin(), v.rend(), query, miniCmp); auto maxi = upper_bound(v.begin(), v.end(), query, maxiCmp); ans.push_back({mini == v.rend() ? -1 : *mini, maxi == v.end() ? -1 : *maxi}); } return ans; }}; 235. äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ è¿™é“é¢˜ä¸236. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆä¸åŒï¼Œè¿™é“é¢˜æ˜¯åœ¨äºŒå‰æœç´¢æ ‘ä¸Šå¯»æ‰¾ å¯¹äºæ ¹èŠ‚ç‚¹ï¼Œå¦‚æœä¸¤ä¸ªæ•°åˆ†åˆ«å¤§äºç­‰äºå’Œå°äºç­‰äºè¿™ä¸ªèŠ‚ç‚¹ï¼Œè¯´æ˜å½“å‰æ ¹èŠ‚ç‚¹å°±æ˜¯å…¬å…±ç¥–å…ˆ å¦‚æœéƒ½å¤§äºæˆ–å°äºå½“å‰æ ¹èŠ‚ç‚¹ï¼Œè¯´æ˜è¦å‘å·¦å­æ ‘æˆ–å³å­æ ‘ç§»åŠ¨ï¼Œç»§ç»­å¯»æ‰¾123456789101112131415class Solution { TreeNode* _lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root-&gt;val &gt;= p-&gt;val &amp;&amp; root-&gt;val &lt;= q-&gt;val) return root; else if(root-&gt;val &gt; p-&gt;val) { return lowestCommonAncestor(root-&gt;left, p, q); } else { return lowestCommonAncestor(root-&gt;right, p, q); } }public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { // p qä¸€å®šåœ¨rootä¸­ï¼Œrootä¸€å®šä¸ç©º if(p-&gt;val &gt; q-&gt;val) swap(p, q); //ä¿è¯p &lt; q; return _lowestCommonAncestor(root, p, q); }}; 938. äºŒå‰æœç´¢æ ‘çš„èŒƒå›´å’Œ å¦‚æœå½“å‰èŠ‚ç‚¹å¤§äºhighï¼Œåˆ™ä¸è€ƒè™‘å³å­æ ‘å’Œå½“å‰èŠ‚ç‚¹ï¼Œç›´æ¥è½¬ç§»åˆ°å·¦å­æ ‘ï¼Œå°äºlowåŒç† å¦‚æœå½“å‰èŠ‚ç‚¹åœ¨highå’Œlowä¹‹é—´ï¼Œåˆ™è¿”å›å½“å‰èŠ‚ç‚¹å€¼åŠ ä¸Šå·¦å³ä¸¤æ£µå­æ ‘çš„å’Œ 12345678910111213class Solution {public: int rangeSumBST(TreeNode* root, int low, int high) { if(!root) return 0; if(root-&gt;val &gt; high) { return rangeSumBST(root-&gt;left, low, high); } else if(root-&gt;val &lt; low) { return rangeSumBST(root-&gt;right, low, high); } else { return root-&gt;val + rangeSumBST(root-&gt;left, low, high) + rangeSumBST(root-&gt;right, low, high); } }}; 2867. ç»Ÿè®¡æ ‘ä¸­çš„åˆæ³•è·¯å¾„æ•°ç›®æ€è·¯ é¦–å…ˆé¢˜ç›®è¯´æ˜¯æ ‘ï¼Œæ‰€ä»¥è¦è€ƒè™‘æœ€å¹¿æ³›çš„nå‰æ ‘çš„æƒ…å†µ æ¶‰åŠåˆ°ç´ æ•°ï¼Œæ‰€ä»¥å¯ä»¥å…ˆç´ æ•°ç­›æŠŠéœ€è¦ç”¨åˆ°çš„ç´ æ•°ç¼“å­˜èµ·æ¥ æœ€ç¬¨çš„æ–¹æ³•æ˜¯ï¼Œä¾æ¬¡ä»æ‰€æœ‰ç´ æ•°å‡ºå‘ï¼Œdfsç›´åˆ°é‡åˆ°ä¸‹ä¸€ä¸ªç´ æ•°æˆ–è€…é‡åˆ°æ²¡æœ‰æœªè®¿é—®èŠ‚ç‚¹ä½ç½®ï¼Œç»Ÿè®¡æ€»å…±çš„è·¯çº¿æ•° ä¸€ä¸ªç´ æ•°çš„æ‰€æœ‰å­©å­å¯ä»¥çœ‹æˆä¸€ä¸ªå­æ ‘ï¼Œåˆ°è¾¾æ¯ä¸ªèŠ‚ç‚¹çš„è·¯å¾„æ•°å°±æ˜¯èŠ‚ç‚¹æ•° æ€»è·¯çº¿æ•°å°±æ˜¯ Nä¸ªå­æ ‘æŒ‰ç…§ä¸Šé¢çš„è¦æ±‚dfsæ—¶æ‰€é‡åˆ°çš„èŠ‚ç‚¹æ•°ä¹‹å’Œ($\\sum_{i=1}^N(A_i)$) è€ƒè™‘åˆ°dfsè¿‡ç¨‹ä¸­é‡åˆ°çš„éƒ½æ˜¯éç´ æ•°ï¼Œé‚£ä¹ˆä»»æ„ä¸¤ä¸ªå­æ ‘ä¹‹é—´çš„ä»»æ„ä¸¤ç‚¹ä¹‹é—´çš„è·¯å¾„ä¹Ÿæ˜¯é¢˜ç›®æ‰€æ±‚è·¯å¾„ï¼Œæ€»æ•°ä¸ºNä¸ªå­æ ‘èŠ‚ç‚¹æ•°ä¸¤ä¸¤ç›¸ä¹˜å†ç›¸åŠ ($\\sum_{i=1}^N\\sum_{j=i+1}^N(A_i \\times A_j)$) ä¸ºäº†å‡å°‘é‡å¤çš„ç»Ÿè®¡ï¼Œä½¿ç”¨å¹¶æŸ¥é›†ï¼Œå°†ç´ æ•°èŠ‚ç‚¹å»é™¤å¾—åˆ°Xä¸ªå­æ ‘ï¼Œè®¡ç®—Xä¸ªå­æ ‘çš„èŠ‚ç‚¹ä¸ªæ•° æ ¹æ®å…¬å¼$(\\sum_{i=1}^N(A_i))^2 - \\sum_{i=1}^N(A_i^2) = 2 \\times \\sum_{i=1}^N\\sum_{j=i+1}^N(A_i \\times A_j)$ï¼Œå¯ä»¥å°†äºŒé‡å¾ªç¯ç®€åŒ–ä¸ºä¸€é‡å¾ªç¯ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution { int find(int x, vector&lt;int&gt;&amp; arr) { return arr[x] != x ? (arr[x] = find(arr[x], arr)) : x; } void Union(int x, int y, vector&lt;int&gt;&amp; arr) { arr[find(x, arr)] = find(y, arr); } unordered_set&lt;int&gt; primeSet{2}; bool is_prime(int val) { return primeSet.count(val) != 0; } long long ans = 0;public: long long countPaths(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) { if(n &lt;= 1) return 0; for(int i = 3; i &lt;= n; i+=2) { bool flag = true; for(int j = 3; j*j&lt;=i; j+=2) { if(i % j == 0) { flag = false; break; } } if(flag) { primeSet.insert(i); } } vector&lt;int&gt; disjointSet(n+1), cnt(n+1); iota(disjointSet.begin(), disjointSet.end(), 0); vector&lt;vector&lt;int&gt;&gt; g(n+1); for(auto&amp; edge:edges) { bool is_prime0 = is_prime(edge[0]), is_prime1 = is_prime(edge[1]); if(!is_prime0 &amp;&amp; !is_prime1) { // ä¸¤ä¸ªèŠ‚ç‚¹éƒ½ä¸æ˜¯ç´ æ•°ï¼Œåˆå¹¶åˆ°åŒä¸€ä¸ªé›†åˆ Union(edge[0], edge[1], disjointSet); } if(is_prime0 ^ is_prime1) { // ä¸¤ä¸ªèŠ‚ç‚¹ä¸­ä¸€ä¸ªç´ æ•°ï¼Œä¸€ä¸ªéç´ æ•°ï¼Œè®°å½•éç´ æ•°å­æ ‘ g[edge[0]].push_back(edge[1]); g[edge[1]].push_back(edge[0]); } } for(int i = 1; i &lt;= n; i++) { cnt[find(i, disjointSet)]++; } for(auto ite = primeSet.begin(); ite != primeSet.end(); ite++) { long long cntSum = 0, cntSquareSum = 0; for(int child : g[*ite]) { cntSum += (long long)cnt[disjointSet[child]]; cntSquareSum += (long long)cnt[disjointSet[child]] * cnt[disjointSet[child]]; // é˜²æ­¢æº¢å‡º } ans += (cntSum * cntSum - cntSquareSum) / 2 + cntSum; } return ans; }}; 2673. ä½¿äºŒå‰æ ‘æ‰€æœ‰è·¯å¾„å€¼ç›¸ç­‰çš„æœ€å°ä»£ä»·æ€è·¯ è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹ä»æ ¹åˆ°å½“å‰èŠ‚ç‚¹çš„è·¯å¾„å’Œ è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹çš„å­è·¯å¾„çš„æœ€å¤§å€¼ å¯¹æ¯ä¸ªèŠ‚ç‚¹ï¼Œè®¡ç®—ä¸¤ä¸ªå­èŠ‚ç‚¹çš„å­è·¯å¾„æœ€å¤§å€¼ä¹‹å·®ï¼Œç»™è¾ƒå°çš„èŠ‚ç‚¹å¢åŠ è¿™ä¸ªå·®å€¼ ä»£ç 1234567891011121314151617181920212223242526272829class Solution { int ans = 0; void solve(int n, int node, int extra, vector&lt;int&gt;&amp; childMax) { int parentMax = childMax[(node+1)/2-1]; ans += parentMax - childMax[node]; extra += parentMax - childMax[node]; if(2*(node+1)-1 &lt; n) solve(n, 2*(node+1)-1, extra, childMax); if(2*(node+1) &lt; n) solve(n, 2*(node+1), extra, childMax); }public: int minIncrements(int n, vector&lt;int&gt;&amp; cost) { vector&lt;int&gt; pathSum(n), childMax(n); pathSum[0] = cost[0]; for(int i = 1; i &lt; n; i++) { pathSum[i] = cost[i] + pathSum[(i+1)/2-1]; } for(int i = n-1; i &gt;= n/2; i--) { childMax[i] = pathSum[i]; } for(int i = n/2 - 1; i &gt;= 0; i--) { childMax[i] = max( (i+1)*2-1 &lt; n ? childMax[(i+1)*2-1] : 0, (i+1)*2 &lt; n ? childMax[(i+1)*2] : 0); } solve(n, 1, 0, childMax); solve(n, 2, 0, childMax); return ans; }}; å»æ‰ä¸å¿…è¦çš„åˆ¤æ–­ 123456789101112131415161718192021222324252627inline int leftChildOf(int node) { return ((node + 1) &lt;&lt; 1) - 1; }inline int rightChildOf(int node) { return ((node + 1) &lt;&lt; 1); }inline int parentOf(int node) { return ((node + 1) &gt;&gt; 1) - 1; }class Solution { int solve(int n, int node, vector&lt;int&gt;&amp; childMax) { int ans = childMax[parentOf(node)] - childMax[node]; if(leftChildOf(node) &lt; n /*&amp;&amp; rightChildOf(node) &lt; n*/) { ans += solve(n, leftChildOf(node), childMax) + solve(n, rightChildOf(node), childMax); } return ans; }public: int minIncrements(int n, vector&lt;int&gt;&amp; cost) { vector&lt;int&gt; pathSum(n), childMax(n); pathSum[0] = cost[0]; for(int i = 1; i &lt; n; i++) { pathSum[i] = cost[i] + pathSum[parentOf(i)]; } for(int i = n-1; i &gt;= n/2; i--) { childMax[i] = pathSum[i]; } for(int i = n/2 - 1; i &gt;= 0; i--) { childMax[i] = max(childMax[leftChildOf(i)], childMax[rightChildOf(i)]); } return solve(n, 1, childMax) + solve(n, 2, childMax); }}; ä¸€è¡Œæµ1inline int leftChildOf(int node) { return ((node + 1) &lt;&lt; 1) - 1; } inline int rightChildOf(int node) { return ((node + 1) &lt;&lt; 1); } inline int parentOf(int node) { return ((node + 1) &gt;&gt; 1) - 1; } class Solution { int solve(int n, int node, vector&lt;int&gt;&amp; childMax) { return childMax[parentOf(node)] - childMax[node] + (leftChildOf(node) &lt; n ? solve(n, leftChildOf(node), childMax) + solve(n, rightChildOf(node), childMax) : 0);} public: int minIncrements(int n, vector&lt;int&gt;&amp; cost) { vector&lt;int&gt; pathSum(n), childMax(n); pathSum[0] = cost[0]; for(int i = 1; i &lt; n; i++) pathSum[i] = cost[i] + pathSum[parentOf(i)]; for(int i = n-1; i &gt;= n/2; i--) childMax[i] = pathSum[i]; for(int i = n/2 - 1; i &gt;= 0; i--) childMax[i] = max(childMax[leftChildOf(i)], childMax[rightChildOf(i)]); return solve(n, 1, childMax) + solve(n, 2, childMax); }}; 2487. ä»é“¾è¡¨ä¸­ç§»é™¤èŠ‚ç‚¹å•è°ƒæ ˆ12345678910111213141516171819202122class Solution {public: ListNode* removeNodes(ListNode* head) { ListNode dummy, *move = head; stack&lt;ListNode*&gt; monoStack; monoStack.push(&amp;dummy); while(move) { while(!monoStack.empty() &amp;&amp; monoStack.top()-&gt;val &lt; move-&gt;val) { monoStack.pop(); } monoStack.push(move); move = move-&gt;next; } while(!monoStack.empty()) { ListNode *node = monoStack.top(); monoStack.pop(); node-&gt;next = dummy.next; dummy.next = node; } return dummy.next; }}; ä¸ç”¨stack123456789101112131415161718192021222324252627class Solution {public: ListNode* removeNodes(ListNode* head) { ListNode dummy, *move = head; int len = 0; while(move) { while(dummy.next != nullptr &amp;&amp; dummy.next-&gt;val &lt; move-&gt;val) { dummy.next = dummy.next-&gt;next; len--; } ListNode *tmp = move-&gt;next; move-&gt;next = dummy.next; dummy.next = move; move = tmp; len++; } move = dummy.next; dummy.next = nullptr; while(len--) { ListNode *node = move-&gt;next; move-&gt;next = dummy.next; dummy.next = move; move = node; } return dummy.next; }}; 2397. è¢«åˆ—è¦†ç›–çš„æœ€å¤šè¡Œæ•°çŠ¶æ€å‹ç¼©1234567891011121314151617181920212223242526272829303132333435class Solution { int m, n, ans = 0; vector&lt;int&gt; row; void checker(int x) { int cnt = 0; for(int i = 0; i &lt; m; i++) { if((row[i] &amp; ~x) == 0) cnt++; } ans = max(ans, cnt); } int toInt(vector&lt;int&gt;&amp; vec, int len) { int x = 0; for(int i = 0; i &lt; len; i++) { x &lt;&lt;= 1; x += vec[i]; } return x; }public: int maximumRows(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int numSelect) { m = matrix.size(), n = matrix[0].size(); vector&lt;int&gt; vec(n); fill(vec.rbegin(), vec.rbegin() + numSelect, 1); for(int i = 0; i &lt; m; i++) { row.push_back(toInt(matrix[i], n)); } for(int x = 0; x &lt; (1 &lt;&lt; n); x++) { if (__builtin_popcount(x) != numSelect) { continue; } checker(x); } return ans; }}; å…¨æ’åˆ—123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution { int toInt(vector&lt;int&gt;&amp; vec, int len) { int x = 0; for(int i = 0; i &lt; len; i++) { x &lt;&lt;= 1; x += vec[i]; } return x; } int setZero(int x, int i) { return x &amp; (~(1 &lt;&lt; i)); } int setOne(int x, int i) { return x | (1 &lt;&lt; i); } int swap(int x, int i, int j) { int a = (x &gt;&gt; i) &amp; 1; int b = (x &gt;&gt; j) &amp; 1; x = a ? setOne(x, j) : setZero(x, j); x = b ? setOne(x, i) : setZero(x, i); return x; } bool swapOK(int x, int i, int n) { int lastBit = (x &amp; (1 &lt;&lt; (n-1))) &gt;&gt; (n-1); for(int j = i; j &lt; n-1; j++) { if(((x &amp; (1 &lt;&lt; j)) &gt;&gt; j) == lastBit) return false; } return true; } void permutation(int x, int j, int n, function&lt;void(int)&gt; checker) { if(j == n-1) { checker(x); return; } for(int i = j; i &lt; n; i++) { if(!swapOK(x, j, i+1)) continue; x = swap(x, i, j); permutation(x, j + 1, n, checker); x = swap(x, i, j); } }public: int maximumRows(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int numSelect) { int m = matrix.size(), n = matrix[0].size(), ans = 0; vector&lt;int&gt; row(m), vec(n); fill(vec.rbegin(), vec.rbegin() + numSelect, 1); for(int i = 0; i &lt; m; i++) { row[i] = toInt(matrix[i], n); } auto checker = [&amp;row, &amp;m, &amp;ans](int x) { int cnt = 0; for(int i = 0; i &lt; m; i++) { if((row[i] &amp; ~x) == 0) cnt++; } ans = max(ans, cnt); }; permutation(toInt(vec, n), 0, n, checker); return ans; }}; 2581. ç»Ÿè®¡å¯èƒ½çš„æ ‘æ ¹æ•°ç›® çœ‹é¢˜è§£çš„æ€è·¯ æ ‘å½¢dp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution { vector&lt;vector&lt;int&gt;&gt; g; vector&lt;unordered_set&lt;int&gt;&gt; guessesGraph; vector&lt;bool&gt; visited; int k, ans = 0; void dfs(int root, int cnt) { if(cnt &gt;= k) ans++; visited[root] = true; for(int child : g[root]) { if(visited[child]) continue; int newCnt = cnt; if(guessesGraph[root].count(child)) { newCnt--; } if(guessesGraph[child].count(root)) { newCnt++; } dfs(child, newCnt); } }public: int rootCount(vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;vector&lt;int&gt;&gt;&amp; guesses, int k) { int n = edges.size() + 1; this-&gt;k = k; g = vector&lt;vector&lt;int&gt;&gt;(n); guessesGraph = vector&lt;unordered_set&lt;int&gt;&gt;(n); for(auto&amp; edge : edges) { g[edge[0]].push_back(edge[1]); g[edge[1]].push_back(edge[0]); } visited = vector&lt;bool&gt;(n, false); vector&lt;int&gt; parent(n, -1); queue&lt;int&gt; q; q.push(0); while(!q.empty()) { int node = q.front(); q.pop(); visited[node] = true; for(int child : g[node]) { if(visited[child]) continue; parent[child] = node; q.push(child); } } int cnt = 0; for(auto&amp; guesse:guesses) { if(guesse[0] == parent[guesse[1]]) cnt++; guessesGraph[guesse[0]].insert(guesse[1]); } fill(visited.begin(), visited.end(), false); dfs(0, cnt); return ans; }}; 1944. é˜Ÿåˆ—ä¸­å¯ä»¥çœ‹åˆ°çš„äººæ•° è¿˜å¥½ï¼Œå°±æ˜¯å•è°ƒæ ˆçš„ç®€å•åº”ç”¨1234567891011121314151617181920class Solution {public: vector&lt;int&gt; canSeePersonsCount(vector&lt;int&gt;&amp; heights) { int n = heights.size(); vector&lt;int&gt; ans(n); stack&lt;int&gt; monoStack; for(int i = 0; i &lt; n; i++) { while(!monoStack.empty() &amp;&amp; heights[monoStack.top()] &lt; heights[i]) { int top = monoStack.top(); monoStack.pop(); ans[top]++; } if(!monoStack.empty()) { ans[monoStack.top()]++; } monoStack.push(i); } return ans; }}; 2807. åœ¨é“¾è¡¨ä¸­æ’å…¥æœ€å¤§å…¬çº¦æ•°1234567891011class Solution {public: ListNode* insertGreatestCommonDivisors(ListNode* head) { ListNode* move = head; while(move-&gt;next) { move-&gt;next = new ListNode(gcd(move-&gt;val, move-&gt;next-&gt;val), move-&gt;next); move = move-&gt;next-&gt;next; } return head; }}; 383. èµé‡‘ä¿¡12345678910111213class Solution {public: bool canConstruct(string ransomNote, string magazine) { int cnt[26] = {0}; for(char c : magazine) { cnt[c - 'a']++; } for(char c : ransomNote) { if(cnt[c - 'a']-- == 0) return false; } return true; }}; 447. å›æ—‹é•–çš„æ•°é‡123456789101112131415161718192021222324class Solution {public: int numberOfBoomerangs(vector&lt;vector&lt;int&gt;&gt;&amp; points) { int n = points.size(); vector&lt;unordered_map&lt;int, int&gt;&gt; data(n); for(int i = 0; i &lt; n; i++) { for(int j = i + 1; j &lt; n; j++) { int distance = (points[i][0] - points[j][0])*(points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]); data[i][distance]++; data[j][distance]++; } } int ans = 0; for(int i = 0; i &lt; n; i++) { for(auto ite = data[i].begin(); ite != data[i].end(); ite++) { ans += ite-&gt;second * (ite-&gt;second - 1); } } return ans; }}; 2707. å­—ç¬¦ä¸²ä¸­çš„é¢å¤–å­—ç¬¦ å¾ˆå¸¸è§„çš„dp123456789101112131415161718class Solution {public: int minExtraChar(string s, vector&lt;string&gt;&amp; dictionary) { int len = s.length(); unordered_set&lt;string&gt; dict; for(auto&amp; d : dictionary) { dict.insert(d); } vector&lt;int&gt; dp(len + 1, INT_MAX); dp[0] = 0; for(int i = 1; i &lt;= len; i++) { for(int j = 0; j &lt; i; j++) { dp[i] = min(dp[j] + (dict.count(s.substr(j, i - j)) ? 0 : i-j), dp[i]); } } return dp[len]; }}; 2696. åˆ é™¤å­ä¸²åçš„å­—ç¬¦ä¸²æœ€å°é•¿åº¦ æ‹¬å·åŒ¹é…çš„æ€è·¯ 123456789101112131415161718class Solution {public: int minLength(string s) { int length = s.length(); stack&lt;char&gt; stk; for(int i = 0; i &lt; length; i++) { if(!stk.empty()) { char top = stk.top(); if((top == 'A' &amp;&amp; s[i] == 'B') || (top == 'C' &amp;&amp; s[i] == 'D')) { stk.pop(); continue; } } stk.push(s[i]); } return stk.size(); }}; 2645. æ„é€ æœ‰æ•ˆå­—ç¬¦ä¸²çš„æœ€å°‘æ’å…¥æ•°1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: int addMinimum(string word) { int len = word.length(); int ans = 0; for(int i = 0; i &lt; len; i++) { switch(word[i]) { case 'a' : { if(!(i + 1 &lt; len &amp;&amp; word[i+1] == 'b')) { ans++; } else { i++; } if(!(i + 1 &lt; len &amp;&amp; word[i+1] == 'c')) { ans++; } else { i++; } } break; case 'b' : { ans++; if(!(i + 1 &lt; len &amp;&amp; word[i+1] == 'c')) { ans++; } else { i++; } } break; case 'c' : { ans += 2; } break; } } return ans; }}; 2085. ç»Ÿè®¡å‡ºç°è¿‡ä¸€æ¬¡çš„å…¬å…±å­—ç¬¦ä¸²1234567891011121314151617class Solution {public: int countWords(vector&lt;string&gt;&amp; words1, vector&lt;string&gt;&amp; words2) { unordered_map&lt;string, int&gt; cnt1, cnt2; int ans = 0; for(auto&amp; s : words1) { cnt1[s]++; } for(auto&amp; s : words2) { cnt2[s]++; } for(auto ite = cnt1.begin(); ite != cnt1.end(); ite++) { if(ite-&gt;second == 1 &amp;&amp; cnt2[ite-&gt;first] == 1) ans++; } return ans; }}; 2182. æ„é€ é™åˆ¶é‡å¤çš„å­—ç¬¦ä¸²1234567891011121314151617181920212223242526class Solution {public: string repeatLimitedString(string s, int repeatLimit) { int cnt[26] = {0}; string ans; for(char c : s) { cnt[c - 'a']++; } char cur = 'z' - 'a', next; while(cur &gt;= 0) { while(cur &gt;= 0 &amp;&amp; cnt[cur] == 0) cur--; if(cur &lt; 0) break; next = cur - 1; while(next &gt;= 0 &amp;&amp; cnt[next] == 0) next--; int cost = min(cnt[cur], repeatLimit); cnt[cur] -= cost; ans += string(cost, cur + 'a'); if(cnt[cur] &gt; 0) { if(next &lt; 0) break; ans += next + 'a'; cnt[next]--; } } return ans; }}; 83. åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´ 123456789101112131415class Solution {public: ListNode* deleteDuplicates(ListNode* head) { if(!head) return nullptr; ListNode *move = head; while(move-&gt;next) { if(move-&gt;val == move-&gt;next-&gt;val) { move-&gt;next = move-&gt;next-&gt;next; } else { move = move-&gt;next; } } return head; }}; 82. åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´  II1234567891011121314151617181920class Solution {public: ListNode* deleteDuplicates(ListNode* head) { if(!head) return nullptr; ListNode dummy(0, head), *move = &amp;dummy; while(move-&gt;next &amp;&amp; move-&gt;next-&gt;next) { if(move-&gt;next-&gt;val == move-&gt;next-&gt;next-&gt;val) { ListNode *cur = move-&gt;next; while(cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val) { cur = cur-&gt;next; } cur = cur-&gt;next; move-&gt;next = cur; } else { move = move-&gt;next; } } return dummy.next; }}; 2368. å—é™æ¡ä»¶ä¸‹å¯åˆ°è¾¾èŠ‚ç‚¹çš„æ•°ç›®dfs æˆ‘çš„è¯„ä»·æ˜¯ï¼Œå¹³å¹³æ— å¥‡ 123456789101112131415161718192021222324class Solution {public: int reachableNodes(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;int&gt;&amp; restricted) { vector&lt;vector&lt;int&gt;&gt; g(n); vector&lt;bool&gt; restricted_map(n, false); int ans = 0; for(int i = 0; i &lt; n-1; i++) { g[edges[i][0]].push_back(edges[i][1]); g[edges[i][1]].push_back(edges[i][0]); } for(int rest_node : restricted) { restricted_map[rest_node] = true; } function&lt;void(int,int)&gt; visitTree = [&amp;](int grandpa, int father) { ans++; for(int child : g[father]) { if(restricted_map[child] || child == grandpa) continue; visitTree(father, child); } }; visitTree(-1, 0); return ans; }}; éé€’å½’dfs12345678910111213141516171819202122232425262728class Solution {public: int reachableNodes(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;int&gt;&amp; restricted) { vector&lt;vector&lt;int&gt;&gt; g(n); vector&lt;bool&gt; restricted_map(n, false); int ans = 0; for(int i = 0; i &lt; n-1; i++) { g[edges[i][0]].push_back(edges[i][1]); g[edges[i][1]].push_back(edges[i][0]); } for(int rest_node : restricted) { restricted_map[rest_node] = true; } queue&lt;pair&lt;int, int&gt;&gt; q; q.emplace(-1, 0); while(!q.empty()) { auto [parent, node] = q.front(); q.pop(); ans++; for(int child : g[node]) { if(restricted_map[child] || child == parent) continue; q.emplace(node, child); } } return ans; }}; å¹¶æŸ¥é›†1234567891011121314151617181920212223242526272829303132333435class Solution { class UFDSet { vector&lt;int&gt; vec; public: UFDSet(int n) : vec(n) { iota(vec.begin(), vec.end(), 0); } int find(int x) { return vec[x] == x ? x : (vec[x] = find(vec[x])); } void Union(int x, int y) { vec[find(x)] = find(y); } };public: int reachableNodes(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;int&gt;&amp; restricted) { int ans = 0; UFDSet ufdSet(n); vector&lt;bool&gt; isRestricted(n, false); for(int restricted_node : restricted) { isRestricted[restricted_node] = true; } for(int i = 0; i &lt; n-1; i++) { if(!isRestricted[edges[i][0]] &amp;&amp; !isRestricted[edges[i][1]]) ufdSet.Union(edges[i][0], edges[i][1]); } for(int i = 0; i &lt; n; i++) { if(ufdSet.find(0) == ufdSet.find(i)) { ans++; } } return ans; }}; 238. é™¤è‡ªèº«ä»¥å¤–æ•°ç»„çš„ä¹˜ç§¯ è™½ç„¶ä½†æ˜¯ï¼Œç©ºé—´O(1)ä¸æ˜¯åº”è¯¥åŸåœ°ä¿®æ”¹å—ï¼Ÿ 12345678910111213141516class Solution {public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; res(n, 1); for(int i = n-2; i &gt;= 0; i--) { res[i] = nums[i+1] * res[i+1]; } int left = 1; for(int i = 0; i &lt; n; i++) { res[i] *= left; left *= nums[i]; } return res; }}; 225. ç”¨é˜Ÿåˆ—å®ç°æ ˆ1234567891011121314151617181920212223242526272829303132class MyStack { queue&lt;int&gt; q; int len;public: MyStack() : len(0) { } void push(int x) { q.push(x); for(int i = 0; i &lt; len; i++) { q.push(q.front()); q.pop(); } len++; } int pop() { int ret = q.front(); q.pop(); len--; return ret; } int top() { return q.front(); } bool empty() { return len == 0; }};","link":"/home/2024/02/23/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9332/"},{"title":"LeetCode-å•è°ƒæ ˆ","text":"739. æ¯æ—¥æ¸©åº¦ ç®€å•ï¼Œé€šè¿‡å•è°ƒæ ˆï¼Œå¼¹å‡ºæ ˆä¸­å°äºå½“å‰å…ƒç´ çš„å…ƒç´ ï¼Œå¯ä»¥æ‰¾åˆ°å¼¹å‡ºå…ƒç´ çš„ç¬¬ä¸€ä¸ªå¤§äºå…¶çš„ä½ç½® 1234567891011121314151617class Solution {public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) { stack&lt;int&gt; monoStk; int len = temperatures.size(); vector&lt;int&gt; res(len); for(int i = 0; i &lt; len; i++) { while(!monoStk.empty() &amp;&amp; temperatures[monoStk.top()] &lt; temperatures[i]) { int top = monoStk.top(); res[top] = i - top; monoStk.pop(); } monoStk.push(i); } return res; }}; 42. æ¥é›¨æ°´AC1æ€è·¯ æ„é€ äº†ä¸€ä¸ªè¿™æ ·çš„æµ‹è¯•ç”¨ä¾‹1234vector&lt;int&gt; testcase = {3,2,1,0,1,2,1,0,1,3};// | |// | | | |// | | | _ | | | _ | | å¦‚æœæ„é€ ä¸€ä¸ªé€’å¢çš„æ ˆï¼Œé‚£ä¹ˆæ ˆé¡¶å…ƒç´ æ¯”æˆ‘å¤§æ—¶ï¼Œå°±è¦æŠŠä»–ä»¬å…¨å¼¹å‡ºï¼Œæ˜¾ç„¶ä¸åˆç† æ„é€ ä¸€ä¸ªé€’å‡çš„æ ˆï¼Œä»æ ˆé¡¶å¼¹å‡ºå°äºå½“å‰é•¿åº¦çš„å…ƒç´ ï¼Œé‚£ä¹ˆè¢«å¼¹å‡ºçš„åŒºé—´å†…èƒ½è£…æ°´çš„æœ€å¤§é‡å°±æ˜¯min(i, top) - height[j] è¿™æ ·è™½ç„¶ç”¨äº†å•è°ƒæ ˆï¼Œä½†å¤æ‚åº¦è¿˜æ˜¯é«˜ ä»£ç 12345678910111213141516171819202122232425262728293031class Solution {public: int trap(vector&lt;int&gt;&amp; height) { int len = height.size(); stack&lt;int&gt; monoStk; vector&lt;int&gt; rain(len, 0); for(int i = 0; i &lt; len; i++) { int top = len; while(!monoStk.empty() &amp;&amp; height[monoStk.top()] &lt; height[i]) { top = monoStk.top(); monoStk.pop(); } if(!monoStk.empty()) top = monoStk.top(); for(int j = top; j &lt; i; j++) { rain[j] = min(height[top], height[i]); } monoStk.push(i); } int rainSum = 0; for(int i = 0; i &lt; len; i++) { if(rain[i] &gt; height[i]) { rainSum += rain[i] - height[i]; } } return rainSum; }};// | |// | | | |// | | | _ | | | _ | | ä¼˜åŒ– å¦‚ä½•åœ¨å¼¹æ ˆè¿‡ç¨‹ä¸­è®¡ç®—æ¥æ°´é‡å‘¢ iæŠŠxå¼¹å‡ºåï¼Œæ­¤æ—¶topï¼ˆè‹¥å­˜åœ¨ï¼‰ä¸iå°±æ˜¯ä¸¤ä¸ªå¢™å£ï¼Œå–å…¶æœ€å°å€¼ï¼Œå‡å»è¢«å¼¹æ ˆå…ƒç´ çš„é«˜åº¦ï¼Œä¹˜ä»¥å®½åº¦ï¼Œå°±æ˜¯ä¸¤ä¸ªå¢™å£ä¹‹é—´çš„å‚¨æ°´é‡ å¦‚æœæœ‰æ›´é«˜çš„ä¸¤é¢å¢™å°†å…¶åŒ…å›´ï¼Œç”±äºå•è°ƒæ ˆçš„æ€§è´¨ï¼Œè®¡ç®—çš„æ˜¯å¢™ä¸è¢«å¼¹å…ƒç´ çš„å·®å€¼ï¼Œä¸ä¼šé‡å¤è®¡ç®—åº•éƒ¨çš„é›¨æ°´ 123456789101112131415161718192021222324class Solution {public: int trap(vector&lt;int&gt;&amp; height) { int len = height.size(); int rainSum = 0; stack&lt;int&gt; monoStk; for(int i = 0; i &lt; len; i++) { int top = len; while(!monoStk.empty() &amp;&amp; height[monoStk.top()] &lt; height[i]) { top = monoStk.top(); monoStk.pop(); if (monoStk.empty()) { break; } int left = monoStk.top(); int currWidth = i - left - 1; int currHeight = min(height[left], height[i]) - height[top]; rainSum += currWidth * currHeight; } monoStk.push(i); } return rainSum; }}; 456. 132 æ¨¡å¼æ€è·¯ å·²çŸ¥è¿™é“é¢˜ç”¨å•è°ƒæ ˆï¼Œä½†æ˜¯æ„é€ é€’å¢çš„æ ˆè¿˜æ˜¯é€’å‡æ ˆå‘¢ï¼Œso hard to tell é€šè¿‡å°è¯•ï¼Œæœ€åä½¿ç”¨é€’å‡æ ˆ å°†å°äºå½“å‰å…ƒç´ çš„æ‰€æœ‰æ ˆå…§å…ƒç´ å¼¹å‡ºåï¼Œå¦‚æœæ ˆå†…è¿˜å­˜åœ¨å…ƒç´ ï¼Œåˆ™æ»¡è¶³nums[k] &lt; nums[j] (å½“å‰å…ƒç´ æ˜¯nums[k]) ç°åœ¨åªè¦ä¿è¯nums[j]å·¦ä¾§å­˜åœ¨å…ƒç´ nums[i] &lt; nums[k]ï¼Œå¼€ä¸€ä¸ªæ•°ç»„ä¿å­˜å½“å‰æœ€å°å€¼å³å¯ acä»£ç 123456789101112131415161718192021222324class Solution {public: bool find132pattern(vector&lt;int&gt;&amp; nums) { int len = nums.size(); stack&lt;int&gt; monoStack; vector&lt;int&gt; minArr(len + 1, INT_MAX); for(int i = 1; i &lt;= len; i++) { minArr[i] = min(minArr[i-1], nums[i-1]); } for(int i = 0; i &lt; len; i++) { while(!monoStack.empty() &amp;&amp; nums[monoStack.top()] &lt;= nums[i]) { monoStack.pop(); } if(!monoStack.empty()) { int top = monoStack.top(); if(nums[i] &gt; minArr[top]) { return true; } } monoStack.push(i); } return false; }}; 581. æœ€çŸ­æ— åºè¿ç»­å­æ•°ç»„æ€è·¯ åˆ›å»ºä¸€ä¸ªå•è°ƒé€’å¢æ ˆï¼Œå½“æœ‰å…ƒç´ è¢«å¼¹å‡ºæ—¶ï¼Œè¯´æ˜åé¢çš„å…ƒç´ è¢«æ”¾åˆ°å‰é¢äº†ï¼Œå½“å‰å…ƒç´ ä¸‹æ ‡å’Œæ ˆé¡¶å…ƒç´ ä¸‹æ ‡éœ€è¦è¢«æ’åº ç”±äºé¢˜ç›®è¦æ±‚ä¸€ä¸ªæœ€å¤§çš„è¿ç»­å­æ•°ç»„ï¼Œæ‰€ä»¥è¦æ±‚ä¸‹æ ‡çš„æœ€å¤§èŒƒå›´ å¯¹äºç‰¹æ®Šæƒ…å†µï¼Œå³æ•°ç»„ä¸­æœ‰è¿ç»­ç›¸ç­‰çš„æ•°å­—æ—¶ï¼Œéœ€è¦åˆ¤æ–­è¿™äº›å…ƒç´ æ˜¯å¦ä¹Ÿéœ€è¦å‚ä¸æ’åºï¼Œå³å¢å¤§å­æ•°ç»„çš„èŒƒå›´ éœ€è¦è®°å½•è¢«å¼¹å‡ºå…ƒç´ çš„æœ€å¤§å€¼ï¼Œå¦‚æœå°äºå®ƒï¼Œåˆ™éœ€è¦å‚ä¸æ’åºã€‚ ä»£ç 12345678910111213141516171819202122class Solution {public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) { stack&lt;int&gt; monoStk; int len = nums.size(), l = len, r = -1; int maxPop = INT_MIN; for(int i = 0; i &lt; len; i++) { while(!monoStk.empty() &amp;&amp; nums[monoStk.top()] &gt; nums[i]) { l = min(l, monoStk.top()); r = i; maxPop = max(maxPop, nums[monoStk.top()]); monoStk.pop(); } monoStk.push(i); } while(!monoStk.empty()) { if(nums[monoStk.top()] &lt; maxPop) r = max(r, monoStk.top()); monoStk.pop(); } return max(r - l + 1, 0); }}; 654. æœ€å¤§äºŒå‰æ ‘ç¬¨è›‹åšæ³•1234567891011class Solution {public: TreeNode* constructMaximumBinaryTree(vector&lt;int&gt; nums) { if(nums.size() == 0) return nullptr; auto max_ite = max_element(nums.begin(), nums.end()); TreeNode *node = new TreeNode(*max_ite); node-&gt;left = constructMaximumBinaryTree({nums.begin(), max_ite}); node-&gt;right = constructMaximumBinaryTree({++max_ite, nums.end()}); return node; }}; ç¬¨è›‹æ–¹æ³•2123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: TreeNode* constructMaximumBinaryTree(vector&lt;int&gt; nums) { int len = nums.size(); auto cmp = [&amp;nums](int i, int j) { return nums[i] &lt; nums[j]; }; priority_queue&lt;int, vector&lt;int&gt;, decltype(cmp)&gt; q(cmp); for(int i = 0; i &lt; len; i++) { q.push(i); } map&lt;TreeNode*, int&gt; m; TreeNode *root = nullptr; if(!q.empty()) { int top = q.top(); root = new TreeNode(nums[top]); m[root] = top; q.pop(); } while(!q.empty()) { int top = q.top(); q.pop(); TreeNode *node = root, *p = nullptr; while(node) { p = node; if(m[node] &lt; top) { node = node-&gt;right; } else { node = node-&gt;left; } } if(p) { TreeNode *tmp = new TreeNode(nums[top]); m[tmp] = top; if(m[p] &lt; top) { p-&gt;right = tmp; } else { p-&gt;left = tmp; } } } return root; }}; å•è°ƒæ ˆæ€è·¯ [3,2,1,6,0,5] è§‚å¯Ÿè¿™ä¸ªæµ‹è¯•ç”¨ä¾‹ç”Ÿæˆçš„äºŒå‰æ ‘ å¦‚æœæ„é€ ä¸€ä¸ªé€’å‡çš„å•è°ƒæ ˆï¼Œåœ¨6è¿›å…¥å‰ï¼Œä»æ ˆé¡¶å¼€å§‹æ ˆå…§å…ƒç´ ä¾æ¬¡ä¸º [1,2,3] 6å…¥æ ˆæ—¶ï¼Œä¼šå°†ä»–ä»¬ä¸‰ä¸ªå¼¹å‡ºï¼Œä»–ä»¬ä¸‰ä¸ªåˆšå¥½ä¾æ¬¡ä¸ºä¸‹ä¸€ä¸ªçš„å³å­æ ‘ 6å…¥æ ˆåï¼Œè¢«å¼¹å‡ºçš„æœ€åä¸€ä¸ªå…ƒç´ ä¸º6çš„å·¦å­æ ‘ è§‚å¯Ÿ6çš„å³å­æ ‘ï¼Œå‘ç°ä¹Ÿæ»¡è¶³è¿™ä¸ªè§„å¾‹ å°è¯•åˆ©ç”¨è¿™ä¸ªè§„å¾‹ç¼–ç ï¼Œæœç„¶å¯¹äº†ï¼ï¼å“ˆå“ˆï¼Œå¼€å¿ƒ ä»£ç 1234567891011121314151617181920212223242526class Solution {public: TreeNode* constructMaximumBinaryTree(vector&lt;int&gt; nums) { nums.push_back(INT_MAX); int len = nums.size(); stack&lt;int&gt; monoStack; vector&lt;TreeNode *&gt; nodes(len); for(int i = 0; i &lt; len; i++) { nodes[i] = new TreeNode(nums[i]); } for(int i = 0; i &lt; len; i++) { int top = len; while(!monoStack.empty() &amp;&amp; nums[monoStack.top()] &lt; nums[i]) { top = monoStack.top(); monoStack.pop(); if(!monoStack.empty() &amp;&amp; nums[monoStack.top()] &lt; nums[i]) { nodes[monoStack.top()]-&gt;right = nodes[top]; } } if(top &lt; len) nodes[i]-&gt;left = nodes[top]; monoStack.push(i); } TreeNode *root = nodes.back(); return root-&gt;left; }}; 769. æœ€å¤šèƒ½å®Œæˆæ’åºçš„å— wow amazingï¼^v^ 12345678910111213141516class Solution {public: int maxChunksToSorted(vector&lt;int&gt;&amp; arr) { int len = arr.size(), ret = 0; stack&lt;int&gt; monoStack; for(int i = 0; i &lt; len; i++) { int top = !monoStack.empty() &amp;&amp; monoStack.top() &gt; arr[i] ? monoStack.top() : -1; while(!monoStack.empty() &amp;&amp; monoStack.top() &gt; arr[i]) { monoStack.pop(); } if(top != -1) monoStack.push(top); else monoStack.push(arr[i]); } return monoStack.size(); }}; 768. æœ€å¤šèƒ½å®Œæˆæ’åºçš„å— II yes, yes, yes, you no çœ‹é”™ï¼Œå’Œä¸Šä¸€é¢˜ç›¸åŒçš„ä»£ç  amazing! wow! ^v^# 12345678910111213141516class Solution {public: int maxChunksToSorted(vector&lt;int&gt;&amp; arr) { int len = arr.size(), ret = 0; stack&lt;int&gt; monoStack; for(int i = 0; i &lt; len; i++) { int top = !monoStack.empty() &amp;&amp; monoStack.top() &gt; arr[i] ? monoStack.top() : -1; while(!monoStack.empty() &amp;&amp; monoStack.top() &gt; arr[i]) { monoStack.pop(); } if(top != -1) monoStack.push(top); else monoStack.push(arr[i]); } return monoStack.size(); }}; 901. è‚¡ç¥¨ä»·æ ¼è·¨åº¦ æˆ‘å¤ªèªæ˜å•¦ï¼Œå‡ åˆ†é’Ÿå°±å†™å‡ºæ¥å•¦ åˆ›å»ºä¸€ä¸ªé€’å‡æ ˆï¼Œå°†å°äºå®ƒçš„æ•°å…¨éƒ½å¼¹å‡ºï¼Œæ­¤æ—¶ä¸æ ˆé¡¶çš„è·ç¦»å°±æ˜¯span 1234567891011121314151617181920212223242526class StockSpanner { stack&lt;pair&lt;int, int&gt;&gt; monoStack; int day = 0;public: StockSpanner() { } int next(int price) { day++; while(!monoStack.empty() &amp;&amp; monoStack.top().second &lt;= price) { monoStack.pop(); } int span = day; if(!monoStack.empty()) { span = day - monoStack.top().first; } monoStack.emplace(day, price); return span; }};/** * Your StockSpanner object will be instantiated and called as such: * StockSpanner* obj = new StockSpanner(); * int param_1 = obj-&gt;next(price); */ 907. å­æ•°ç»„çš„æœ€å°å€¼ä¹‹å’Œå•è°ƒæ ˆ æˆ‘çœŸèªæ˜ï¼ï¼ï¼ï¼ï¼ ç”¨å•è°ƒæ ˆæ‰¾åˆ°å½“å‰å…ƒç´ å·¦å³ä¸¤ä¾§ç¬¬ä¸€ä¸ªæ¯”ä»–å°çš„å…ƒç´ ä½ç½®ï¼Œåˆ†åˆ«è®°å½•åˆ°left[i], right[i] ç”±å…ƒç´ arr[i]ä¸ºæœ€å°å€¼çš„å­æ•°ç»„ä¸ªæ•°ä¸º (right[i] - i + 1l) * (i - left[i] + 1l) ç”±äºæ„é€ çš„æ˜¯é€’å‡æ ˆï¼Œä¸ºäº†é˜²æ­¢ä¸–ç•Œè¢«ç ´åæ¯”è¢«å¼¹å‡ºå…ƒç´ æ›´å¤§çš„å…ƒç´ å·²ç»è¢«å¼¹å‡ºäº†ï¼Œèµ‹å€¼æ—¶ä½¿ç”¨è¢«å¼¹å‡ºå…ƒç´ çš„left/right 1234567891011121314151617181920212223242526272829303132class Solution { static constexpr int MOD = 1000000007;public: int sumSubarrayMins(vector&lt;int&gt;&amp; arr) { stack&lt;int&gt; monoStack; int len = arr.size(); int res = 0; vector&lt;int&gt; left(len), right(len, len - 1); for(int i = 0; i &lt; len; i++) { left[i] = right[i] = i; while(!monoStack.empty() &amp;&amp; arr[monoStack.top()] &gt;= arr[i]) { int top = monoStack.top(); left[i] = left[top]; monoStack.pop(); } monoStack.push(i); } monoStack = move(stack&lt;int&gt;()); for(int i = len - 1; i &gt;= 0; i--) { while(!monoStack.empty() &amp;&amp; arr[monoStack.top()] &gt; arr[i]) { int top = monoStack.top(); right[i] = right[top]; monoStack.pop(); } monoStack.push(i); } for(int i = 0; i &lt; len; i++) { res = (res + (right[i] - i + 1l) * (i - left[i] + 1l) * arr[i]) % MOD; } return res; }}; 2865. ç¾ä¸½å¡” Iè¿™é“é¢˜ä¸2866. ç¾ä¸½å¡” IIç›¸åŒï¼Œåªæ˜¯æ•°æ®è§„æ¨¡æ›´å°ä¸€ç‚¹ï¼Œå½“æ—¶ç”¨æšä¸¾å±±å³°åšçš„ï¼Œè¿™æ¬¡ç”¨å•è°ƒæ ˆ æ€è·¯ æ ¹æ®æç¤ºï¼Œæ¯ä¸€ä¸ªä½ç½®éƒ½æœ‰å¯èƒ½æ˜¯å±±å³°ï¼ˆå…¶å®åªæœ‰å±€éƒ¨æœ€å¤§å€¼æœ‰å¯èƒ½ï¼‰ï¼Œé‚£ä¹ˆå‡è®¾iä¸ºå±±å³°æ—¶ï¼Œè¦è®¡ç®—å‡ºæ€»å’Œï¼Œéœ€è¦ä¸‰ä¸ªæ•°æ®ï¼š iå·¦ä¾§ä¸Šå‡çš„æœ€å¤§å’Œ iå³ä¾§ä¸‹é™ï¼ˆåè¿‡æ¥çœ‹ä¹Ÿæ˜¯ä¸Šå‡ï¼‰çš„æœ€å¤§å’Œ içš„æœ€å¤§å€¼ å°†ä»¥ä¸Šä¸‰ä¸ªå€¼ç›¸åŠ ï¼Œå°±æ˜¯æœ€ç»ˆç»“æœ æ‰€ä»¥éœ€è¦ä¸¤ä¸ªæ•°æ®ï¼Œå­˜æ”¾æ‰€æœ‰iå¯¹åº”çš„å·¦ä¾§å±±å¡æœ€å¤§å’Œï¼Œå³ä¾§å±±å³°æœ€å¤§å’Œ ä½¿ç”¨å•è°ƒæ ˆçš„æ€æƒ³ï¼Œåˆ›å»ºä¸€ä¸ªé€’å¢æ ˆï¼Œå½“æ ˆé¡¶å…ƒç´ å¤§äºå½“å‰å…ƒç´ æ—¶ï¼Œå¼¹å‡ºå…¶ä¸­å…ƒç´  å°†æ•°ç»„æƒ³æƒ³æˆä¸€åº§åº§å±±å³° å¦‚æœå½“å‰å…ƒç´ æ²¡æœ‰å¼¹å‡ºæ ˆä¸­å…ƒç´ ï¼Œè¯´æ˜å½“å‰å¤„äºä¸Šå‡é˜¶æ®µï¼Œé‚£ä¹ˆå…¶å·¦ä¾§/å³ä¾§çš„æœ€å¤§å’Œå°±å¯ä»¥æ˜¯å·¦ä¾§/å³ä¾§çš„å…ƒç´ çš„å€¼ å¦‚æœå¼¹å‡ºäº†å…ƒç´ ï¼Œä¸”æ ˆè¢«å¼¹ç©ºäº†ï¼Œè¯´æ˜å½“å‰å…ƒç´ æ˜¯ä»å·¦/å³å¼€å§‹åˆ°å½“å‰æœ€å°çš„å…ƒç´ ï¼Œé‚£ä¹ˆåˆ°ç›®å‰ä¸ºæ­¢çš„æ‰€æœ‰å…ƒç´ éƒ½åªèƒ½å–æœ€å°å€¼ å¦‚æœå¼¹å‡ºäº†å…ƒç´ ï¼Œä¸”æ ˆæ²¡æœ‰è¢«å¼¹ç©ºï¼Œå½“å‰æ ˆé¡¶å…ƒç´ å°±æ˜¯å½“å‰å…ƒç´ ä¸å…¶ä¹‹é—´èƒ½å»ºé€ çš„æœ€å¤§å€¼ï¼Œéƒ½å–è¯¥æ ˆé¡¶å…ƒç´ å»ºé€ å¡”ï¼Œå°±èƒ½æ»¡è¶³è¿™ä¸ªåŒºé—´å†…çš„å’Œæœ€å¤§ï¼Œè€Œä¸”ç”±äºæ˜¯é€’å¢æ ˆï¼Œå–æ ˆé¡¶å…ƒç´ ä¸ºè¿™ä¸ªåŒºé—´çš„å€¼ä¹Ÿä¸ä¼šç ´åå±±è„‰çš„é€’å¢/é€’å‡æ€§è´¨ï¼Œé‚£ä¹ˆè¿™ä¸ªåŒºé—´çš„å’ŒåŠ ä¸Šæ ˆé¡¶å…ƒç´ çš„é«˜åº¦å’Œæ ˆé¡¶å…ƒç´ ä¹‹å’Œçš„æœ€å¤§å’Œï¼Œå°±æ˜¯åˆ°å½“å‰å…ƒç´ çš„æœ€å¤§å’Œ ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution { int monoStack[1000 + 1]; int stackPtr; void initStack() { stackPtr = 0; } int pop() { return monoStack[--stackPtr]; } int top() { return monoStack[stackPtr - 1]; } void push(int val) { monoStack[stackPtr++] = val; } bool empty() { return stackPtr == 0; }public: long long maximumSumOfHeights(vector&lt;int&gt;&amp; maxHeights) { int len = maxHeights.size(); long long ans = INT_MIN; vector&lt;long long&gt; leftHill(len), rightHill(len); initStack(); for(int i = 0; i &lt; len; i++) { int topVal = len; while(!empty() &amp;&amp; maxHeights[top()] &gt; maxHeights[i]) { topVal = pop(); } if(empty()) leftHill[i] = (i + 0ll) * maxHeights[i] + leftHill[0]; else if(topVal &lt; len) leftHill[i] = (i - top() - 1ll) * maxHeights[i] + maxHeights[top()] + leftHill[top()]; else if(i &gt; 0) leftHill[i] = leftHill[i-1] + maxHeights[i-1]; push(i); } initStack(); for(int i = len - 1; i &gt;= 0; i--) { int topVal = len; while(!empty() &amp;&amp; maxHeights[top()] &gt; maxHeights[i]) { topVal = pop(); } if(empty()) rightHill[i] = (len - 1ll - i) * maxHeights[i] + rightHill[len - 1]; else if(topVal &lt; len) rightHill[i] = (top() - i - 1ll) * maxHeights[i] + maxHeights[top()] + rightHill[top()]; else if(i &lt; len - 1) rightHill[i] = rightHill[i+1] + maxHeights[i+1]; push(i); ans = max(ans, leftHill[i] + rightHill[i] + maxHeights[i]); } return ans; }}; 496. ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  I emmï¼Œå…¶å®å°±æ˜¯æ‰¾nums2ä¸­æ¯ä¸ªå…ƒç´ å³ä¾§ç¬¬ä¸€ä¸ªæ¯”å®ƒå¤§çš„å…ƒç´ ï¼Œåªæ˜¯è¦æ˜ å°„åˆ°nums1ä¸­ éœ€æ±‚çœŸçš„å¾ˆç»•ï¼Œçœ‹æ¸…è¿™ä¸€ç‚¹è¿™é¢˜å°±å¾ˆç®€å•ï¼Œç”¨ä¸€ä¸ªmapæ˜ å°„å…ƒç´ åˆ°nums1ä¸­çš„ä¸‹æ ‡å³å¯ 123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { unordered_map&lt;int, int&gt; m; int len1 = nums1.size(), len2 = nums2.size(); vector&lt;int&gt; monoStack(len2), ret(len1, -1); int stackPtr = 0; for(int i = 0; i &lt; len1; i++) { m[nums1[i]] = i; } for(int i = 0; i &lt; len2; i++) { while(stackPtr &gt; 0 &amp;&amp; nums2[monoStack[stackPtr - 1]] &lt; nums2[i]) { int top = monoStack[stackPtr - 1]; if(m.count(nums2[top])) { int index = m[nums2[top]]; ret[index] = nums2[i]; } stackPtr--; } monoStack[stackPtr++] = i; } return ret; }}; 503. ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  IIè¿™ä¸ªæ¯”ä¸Šä¸€é¢˜æ›´ç®€å•äº†ï¼Ÿåªæ˜¯å¤šä¸€ä¸ªéœ€è¦å¾ªç¯æ¯”è¾ƒè€Œå·²æ ¹æ®ä»¥å‰çš„ç»éªŒï¼Œéœ€è¦å¾ªç¯å¯»æ‰¾çš„ä¸€èˆ¬å¯ä»¥å°†æ•°ç»„æ‰©å¤§ä¸€å€ï¼Œå¹¶å¤åˆ¶ä¸€ä»½ 12345678910111213141516171819202122class Solution {public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) { int len = nums.size(); vector&lt;int&gt; monoStack(2*len), ret(len, -1); nums.resize(2*len); for(int i = 0; i &lt; len; i++) { nums[i+len] = nums[i]; } int stackPtr = 0; for(int i = 0; i &lt; 2*len; i++) { while(stackPtr &gt; 0 &amp;&amp; nums[monoStack[stackPtr - 1]] &lt; nums[i]) { int top = monoStack[stackPtr - 1]; if(top &gt;= len) top -= len; ret[top] = nums[i]; stackPtr--; } monoStack[stackPtr++] = i; } return ret; }}; 1019. é“¾è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªæ›´å¤§èŠ‚ç‚¹ æ²¡æ„æ€ï¼Œé“¾è¡¨ 12345678910111213141516171819class Solution {public: vector&lt;int&gt; nextLargerNodes(ListNode* head) { stack&lt;pair&lt;int, int&gt;&gt; monoStack; vector&lt;int&gt; res; int index = 0; while(head) { res.push_back(0); while(!monoStack.empty() &amp;&amp; monoStack.top().first &lt; head-&gt;val) { res[monoStack.top().second] = head-&gt;val; monoStack.pop(); } monoStack.emplace(head-&gt;val, index); index++; head = head-&gt;next; } return res; }}; 2454. ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  IVå•è°ƒæ ˆ+å°é¡¶å † æ„é€ å•è°ƒé€’å‡æ ˆï¼Œå½“ä¸€ä¸ªæ•°è¢«å¼¹æ ˆæ—¶ï¼Œè¯´æ˜é‡åˆ°äº†æ¯”ä»–å¤§çš„ç¬¬ä¸€ä¸ªæ•°ï¼Œæ­¤æ—¶è¢«å¼¹å‡ºå…ƒç´ æ”¾å…¥ä¸€ä¸ªå°é¡¶å †ä¸­ æ¯ä¸ªå…ƒç´ å…¥æ ˆå‰ï¼Œå…ˆæŸ¥çœ‹å°é¡¶å †ä¸­æœ‰æ²¡æœ‰æ¯”è‡ªå·±å°çš„å…ƒç´ ï¼Œå¦‚æœæœ‰ï¼Œåˆ™ç¬¬äºŒä¸ªæ¯”ä»–å¤§çš„æ•°å°±æ‰¾åˆ°äº† 123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; secondGreaterElement(vector&lt;int&gt;&amp; nums) { int len = nums.size(); vector&lt;int&gt; res(len, -1); stack&lt;int&gt; monoStack; auto cmp = [&amp;nums](int i, int j) { return nums[i] &gt; nums[j]; }; priority_queue&lt;int, vector&lt;int&gt;, decltype(cmp)&gt; monoQueue(cmp); for(int i = 0; i &lt; len; i++) { while(!monoQueue.empty() &amp;&amp; nums[monoQueue.top()] &lt; nums[i]) { int top1 = monoQueue.top(); monoQueue.pop(); res[top1] = nums[i]; } while(!monoStack.empty() &amp;&amp; nums[monoStack.top()] &lt; nums[i]) { int top = monoStack.top(); monoStack.pop(); monoQueue.push(top); } monoStack.push(i); } return res; }}; å•è°ƒæ ˆ+æ ˆ å…¶å®ä¸å¿…ç”¨å°é¡¶å †ï¼Œè¢«å¼¹å‡ºçš„å…ƒç´ ååºæ’å…¥å¦ä¸€ä¸ªæ ˆå³å¯ 1234567891011121314151617181920212223242526272829303132333435363738394041int init_io = []() { cin.tie(nullptr)-&gt;sync_with_stdio(false); return 0;}();class Solution { class Stack { // ç”¨æ•°ç»„ï¼Œå¿«ä¸€ç‚¹ int stack[100000 + 1] = {0}; int stackPtr = 0; public: Stack() { } Stack(size_t len, int val) { if(len &gt; 0) fill(stack, stack + len, val); } void clear() { stackPtr = 0; } bool empty() { return stackPtr == 0; } int top() { return stack[stackPtr - 1]; } int pop() { return stack[--stackPtr]; } void push(int val) { stack[stackPtr++] = val; } int ptr() { return stackPtr; } int get(int index) { return stack[index]; } };public: vector&lt;int&gt; secondGreaterElement(vector&lt;int&gt;&amp; nums) { int len = nums.size(); vector&lt;int&gt; res(len, -1); Stack monoStack; Stack seen; for(int i = 0; i &lt; len; i++) { while(!seen.empty() &amp;&amp; nums[seen.top()] &lt; nums[i]) res[seen.pop()] = nums[i]; int ptr = monoStack.ptr(); while(!monoStack.empty() &amp;&amp; nums[monoStack.top()] &lt; nums[i]) monoStack.pop(); for(int j = monoStack.ptr(); j &lt; ptr; j++) seen.push(monoStack.get(j)); monoStack.push(i); } return res; }}; 85. æœ€å¤§çŸ©å½¢è½¬åŒ–ä¸ºå•è°ƒæ ˆé—®é¢˜ ç›´æ¥åœ¨å›¾å†…æœç´¢çŸ©å½¢çš„å¤æ‚åº¦æ˜¯m*m*n*n å¯ä»¥è®¡ç®—æ¯ä¸ªç‚¹(i, j)çš„å³ä¾§æœ‰å‡ ä¸ªè¿ç»­çš„1 å¯¹äºæŸä¸€åˆ—ï¼Œå³ä¾§åˆ†åˆ«æœ‰[2,3,1]ä¸ªè¿ç»­çš„1ï¼Œé‚£ä¹ˆå¯èƒ½çš„çŸ©å½¢ä¸º2, 3, 1, 2+2, 1+1+1 æ„å»ºä¸€ä¸ªé€’å¢æ ˆï¼Œå¼¹å‡ºæ‰€æœ‰å¤§äºå½“å‰å…ƒç´ çš„å€¼åï¼Œä»¥å½“å‰å…ƒç´ ä¸ºé«˜åº¦çš„çŸ©å½¢å°±ç¡®å®šäº† æ¯ä¸ªç‚¹å…¥æ ˆåï¼Œæ ˆå…§å…ƒç´ æ˜¯é€’å¢çš„ï¼Œè®¡ç®—ä¸¤ä¸¤ä¹‹é—´å½¢æˆçš„çŸ©å½¢é¢ç§¯ å¤æ‚åº¦O(n*m*m) æ€è·¯112345678910111213141516171819202122232425262728293031323334353637383940class Solution {public: int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) { int m = matrix.size(), n = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; left1Cnt(m, vector&lt;int&gt;(n, 0)); for(int i = 0; i &lt; m; i++) { left1Cnt[i][n - 1] = matrix[i][n - 1] - '0'; for(int j = n - 2; j &gt;= 0; j--) { if(matrix[i][j] == '1') left1Cnt[i][j] = 1 + left1Cnt[i][j+1]; } } int ret = INT_MIN; for(int j = 0; j &lt; n; j++) { vector&lt;int&gt; monoStack(m); vector&lt;int&gt; left(m, 0); int stackPtr = 0; int minCnt = INT_MAX; for(int i = 0; i &lt; m; i++) { int top = -1; left[i] = i; minCnt = min(minCnt, left1Cnt[i][j]); ret = max(ret, (i + 1) * minCnt); while(stackPtr != 0 &amp;&amp; left1Cnt[monoStack[stackPtr - 1]][j] &gt; left1Cnt[i][j]) { top = monoStack[stackPtr - 1]; stackPtr--; } if(top != -1) { ret = max(ret, (i - left[top] + 1) * left1Cnt[i][j]); left[i] = left[top]; } monoStack[stackPtr++] = i; for(int ptr = 0; ptr &lt; stackPtr; ptr++) { ret = max(ret, (i - left[monoStack[ptr]] + 1) * left1Cnt[monoStack[ptr]][j]); } } } return ret; }}; å‚è€ƒ907. å­æ•°ç»„çš„æœ€å°å€¼ä¹‹å’Œï¼Œæ‰¾åˆ°æ¯ä¸ªèŠ‚ç‚¹ä½œä¸ºæœ€å°å€¼çš„åŒºé—´é•¿åº¦ï¼Œè®¡ç®—çŸ©å½¢é¢ç§¯ï¼Œå–æœ€å¤§å€¼ å¤æ‚åº¦,m*n æ€è·¯2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) { int m = matrix.size(), n = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; left1Cnt(m, vector&lt;int&gt;(n, 0)); for(int i = 0; i &lt; m; i++) { left1Cnt[i][n - 1] = matrix[i][n - 1] - '0'; for(int j = n - 2; j &gt;= 0; j--) { if(matrix[i][j] == '1') left1Cnt[i][j] = 1 + left1Cnt[i][j+1]; } } int ret = INT_MIN; for(int j = 0; j &lt; n; j++) { vector&lt;int&gt; monoStack(m); vector&lt;int&gt; left(m, 0), right(m, 0); int stackPtr = 0; for(int i = 0; i &lt; m; i++) { int top = -1; while(stackPtr != 0 &amp;&amp; left1Cnt[monoStack[stackPtr - 1]][j] &gt;= left1Cnt[i][j]) { top = monoStack[--stackPtr]; } if(stackPtr == 0) left[i] = i; else { top = monoStack[stackPtr - 1]; left[i] = i - top - 1; } monoStack[stackPtr++] = i; } stackPtr = 0; for(int i = m-1; i &gt;= 0; i--) { int top = -1; while(stackPtr != 0 &amp;&amp; left1Cnt[monoStack[stackPtr - 1]][j] &gt;= left1Cnt[i][j]) { top = monoStack[--stackPtr]; } if(stackPtr == 0) right[i] = m-1 - i; else { top = monoStack[stackPtr - 1]; right[i] = top - i - 1; } monoStack[stackPtr++] = i; } for(int i = 0; i &lt; m; i++) { ret = max(ret, (left[i] + right[i] + 1) * left1Cnt[i][j]); } } return ret; }}; 1504. ç»Ÿè®¡å…¨ 1 å­çŸ©å½¢ç¬¨è›‹æ ˆ(ä¸¤æ¬¡å•è°ƒæ ˆ) å‚è€ƒ907. å­æ•°ç»„çš„æœ€å°å€¼ä¹‹å’Œï¼Œæ‰¾åˆ°æ¯ä¸ªèŠ‚ç‚¹ä½œä¸ºæœ€å°å€¼çš„å·¦å³ä¸¤ä¾§åŒºé—´é•¿åº¦ ä»¥å½“å‰å…ƒç´ iä¸ºæœ€å°å€¼åŒºé—´èŒƒå›´ä¸º[l, r]ï¼Œåˆ™æ­£æ–¹å½¢ä¸ªæ•°æ˜¯ (r - i + 1) * (i - l + 1) * mat[i][j] 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {public: int numSubmat(vector&lt;vector&lt;int&gt;&gt;&amp; mat) { int m = mat.size(), n = mat[0].size(); int ret = 0; for(int i = 0; i &lt; m; i++) { for(int j = n - 2; j &gt;= 0; j--) { if(mat[i][j]) mat[i][j] = mat[i][j+1] + mat[i][j]; } } vector&lt;int&gt; monoStack(m); vector&lt;int&gt; left(m), right(m); int stackTop = 0; for(int j = 0; j &lt; n; j++) { stackTop = 0; for(int i = 0; i &lt; m; i++) { int top = m; while(stackTop != 0 &amp;&amp; mat[monoStack[stackTop - 1]][j] &gt;= mat[i][j]) { top = monoStack[--stackTop]; } if(top &lt; m) left[i] = left[top]; else if(stackTop != 0) left[i] = i; else left[i] = 0; monoStack[stackTop++] = i; } stackTop = 0; for(int i = m - 1; i &gt;= 0; i--) { int top = m; while(stackTop != 0 &amp;&amp; mat[monoStack[stackTop - 1]][j] &gt; mat[i][j]) { top = monoStack[--stackTop]; } if(top &lt; m) right[i] = right[top]; else if(stackTop != 0) right[i] = i; else right[i] = m-1; monoStack[stackTop++] = i; ret += ((right[i] - i + 1) * (i - left[i] + 1)) * mat[i][j]; } } return ret; }}; èªæ˜æ ˆ(ä¸€æ¬¡å•è°ƒæ ˆ) é¢˜è§£ï¼Œçœ‹ä¸æ‡‚","link":"/home/2023/12/22/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%E4%BD%8D%E5%8D%95%E8%B0%83%E6%A0%88/"},{"title":"LeetCode-8","text":"581. æœ€çŸ­æ— åºè¿ç»­å­æ•°ç»„æ€è·¯ æ‹·è´æŠŠå¤‡ä»½æ’åºï¼Œç„¶åä¸¤ä¸ªæŒ‡é’ˆï¼Œä¾æ¬¡ä»å¤´åˆ°å°¾ï¼ˆiï¼‰ï¼Œä»å°¾åˆ°å¤´ï¼ˆjï¼‰æ¯”è¾ƒæ’åºå‰åä¸¤ä¸ªæ•°ç»„ç›¸åŒä¸‹æ ‡çš„å€¼ï¼ŒæŠŠç¬¬ä¸€æ¬¡ä¸åŒçš„ä¸‹æ ‡å€¼è®°å½•ï¼Œæœ€åè¿”å›j - i + 1ï¼Œå¦‚æœä¸ºè´Ÿæ•°è¿”å›0ã€‚ ACä»£ç 123456789101112131415161718192021class Solution {public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; cpy(nums.begin(), nums.end()); sort(cpy.begin(), cpy.end()); int len = nums.size(); int j = len - 1, i = 0; for ( ; j &gt;= 0; j--) { if (nums[j] != cpy[j]) { break; } } for (; i &lt; len; i++) { if (nums[i] != cpy[i]) { break; } } int ans = j - i + 1; return ans &gt; 0 ? ans : 0; }}; æ€è·¯ ä»å‰åˆ°åéå†ï¼Œä¸€è¾¹æ‰¾æœ€å¤§å€¼ï¼Œä¸€è¾¹æ‰¾å½“å‰å€¼æ˜¯ä¸æ˜¯æœ€å¤§å€¼ï¼Œå¦‚æœä¸æ˜¯ï¼Œè®°å½•å½“å‰ä¸‹æ ‡ ä»åå‘å‰éå†ï¼Œä¸€è¾¹æ‰¾æœ€å°å€¼ï¼Œä¸€è¾¹æ‰¾å½“å‰å€¼æ˜¯ä¸æ˜¯æœ€å°å€¼ï¼Œå¦‚æœä¸æ˜¯ï¼Œè®°å½•å½“å‰ä¸‹æ ‡ è¿”å›ä¸‹æ ‡ä¹‹é—´çš„å…ƒç´ æ•°ï¼Œæ³¨æ„å·®å€¼ä¸º0è¿”å›1 ACä»£ç 1234567891011121314151617181920212223242526static int pr = []() { std::ios::sync_with_stdio(false); cin.tie(NULL); return 0; }();class Solution {public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int j = len - 1, i = 0; int max = INT_MIN, min = INT_MAX; int pre = 0, back = len - 1; for (;i &lt; len;i++, j--) { max = max &gt; nums[i] ? max : nums[i]; if (max != nums[i]) { pre = i; } min = min &lt; nums[j] ? min : nums[j]; if (min != nums[j]) { back = j; } } int ans = pre - back + 1; return ans &gt; 1 ? ans : 0; }}; å¤§ä½¬æ€è·¯æ²¡çœ‹æ‡‚,ä¸ºæ¯›éå†è¿™ä¹ˆå¤šæ¬¡å¯ä»¥è¿™ä¹ˆå¿«ï¼Ÿ å¤§ä½¬ä»£ç 12345678910111213141516171819202122232425262728293031static int pr = []() { std::ios::sync_with_stdio(false); cin.tie(NULL); return 0; }();class Solution {public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int left = 0; int right = n - 1; while (left &lt; n - 1 &amp;&amp; nums[left] &lt;= nums[left + 1]) left += 1; if (left == n - 1) return 0; while (right &gt; 0 &amp;&amp; nums[right] &gt;= nums[right - 1]) right -= 1; int min_value = INT32_MAX; int max_value = INT32_MIN; for (int i = left; i &lt; right + 1; i++) { min_value = min(nums[i], min_value); max_value = max(nums[i], max_value); } while (left &gt; -1 &amp;&amp; nums[left] &gt; min_value) left -= 1; while (right &lt; n &amp;&amp; nums[right] &lt; max_value) right += 1; return right - left - 1; }}; 541. åè½¬å­—ç¬¦ä¸² IIæ€è·¯æ¯æ¬¡åè½¬kæˆ–è€…å°äºkä¸ªå­—ç¬¦ï¼Œç„¶åæŒ‡é’ˆ+=2*k ACä»£ç 12345678910111213class Solution {public: string reverseStr(string s, int k) { int i = 0; int len = s.length(); while (i &lt; len) { int l = len - i &gt; k ? k : len - i;//æ¯æ¬¡ç®—é•¿åº¦ reverse(s.begin() + i, s.begin() + i + l); i += 2*k; } return s; }}; 589. Nå‰æ ‘çš„å‰åºéå†æ€è·¯ é€’å½’ ACä»£ç 123456789101112131415161718192021222324252627282930/*// Definition for a Node.class Node {public: int val; vector&lt;Node*&gt; children; Node() {} Node(int _val, vector&lt;Node*&gt; _children) { val = _val; children = _children; }};*/class Solution {public: vector&lt;int&gt; preorder(Node* root) { vector&lt;int&gt; ans; go(root, ans); return ans; } void go(Node* root, vector&lt;int&gt;&amp; v) { if (root == NULL) return; v.push_back(root-&gt;val); for (auto x : root-&gt;children) { go(x, v); } }}; å¤§ä½¬æ€è·¯å¤§ä½¬ä»£ç 123456789101112131415161718192021222324252627282930313233class Solution {public: vector&lt;int&gt; preorder(Node* root) { if (!root) { return vector&lt;int&gt;(); } stack&lt;Node*&gt; s; s.push(root); vector&lt;int&gt; ret; while (!s.empty()) { Node* p = s.top(); s.pop(); ret.push_back(p-&gt;val); int n = (p-&gt;children).size(); for (int i = n - 1; i &gt;= 0; --i) { if (p-&gt;children[i]) { s.push((p-&gt;children)[i]); } } } return ret; }};static auto _ = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); return 0;}(); 590. Nå‰æ ‘çš„ååºéå†ACä»£ç 123456789101112131415class Solution {public: vector&lt;int&gt; postorder(Node* root) { vector&lt;int&gt; ans; go(root, ans); return ans; } void go(Node* root, vector&lt;int&gt;&amp; v) { if (root == NULL) return; for (auto x : root-&gt;children) { go(x, v); } v.push_back(root-&gt;val); }}; 598. èŒƒå›´æ±‚å’Œ IIæ€è·¯æ¯æ¬¡æ“ä½œï¼Œå·¦ä¸Šè§’ä¸€å®šæ˜¯é‡å æœ€å¤§çš„ï¼Œç›´æ¥æ‰¾æœ€å°çš„xï¼Œyå°±å¯ä»¥äº† ACä»£ç 1234567891011class Solution {public: int maxCount(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; ops) { int minFirst = m, minSecond = n; for (auto x : ops) { minSecond = minSecond &gt; x[1] ? x[1] : minSecond; minFirst = minFirst &gt; x[0] ? x[0] : minFirst; } return minFirst*minSecond; }}; 599. ä¸¤ä¸ªåˆ—è¡¨çš„æœ€å°ç´¢å¼•æ€»å’Œæ€è·¯ ä¸€ä¸ªmapè®°å½•ç¬¬ä¸€ä¸ªæ•°ç»„çš„ä¸‹æ ‡+1ï¼Œç„¶åéå†ç¬¬äºŒä¸ªæ•°ç»„ï¼Œæä¸€ä¸ªmapï¼Œè®°å½•ä¸‹æ ‡å’Œå¯¹åº”çš„é¤å…æ•°ç»„ ä¼˜åŒ–ï¼Œéå†ç¬¬äºŒä¸ªæ•°ç»„çš„æ—¶å€™ï¼ŒæŸ¥è¯¢ï¼Œè®¡ç®—ä¸‹æ ‡å’Œï¼Œå¦‚æœä¸‹æ ‡å’Œå°äºå½“å‰çš„æœ€å°å€¼ï¼Œé‚£ä¹ˆå°±clearå½“å‰æ•°ç»„ï¼Œé‡æ–°æŠŠå½“å‰è¿™ä¸ªé¤å…pushè¿›å»ï¼Œå¦‚æœç­‰äºï¼Œç›´æ¥pushé¤å…ï¼Œå¤§äºåˆ™ä¸ç®¡ ACä»£ç 12345678910111213141516171819class Solution {public: vector&lt;string&gt; findRestaurant(vector&lt;string&gt;&amp; list1, vector&lt;string&gt;&amp; list2) { unordered_map&lt;string, int&gt; m; map&lt;int, vector&lt;string&gt;&gt; ans; int len1 = list1.size(); int len2 = list2.size(); for (int i = 0; i &lt; len1; i++) { m[list1[i]] = i + 1; } for (int i = 0; i &lt; len2 ; i++) { int pos = m[list2[i]]; if (pos) { ans[pos - 1 + i].push_back(list2[i]); } } return ans.begin()-&gt;second; }}; ACä»£ç ï¼ˆä¼˜åŒ–ï¼‰123456789101112131415161718192021222324252627class Solution {public: vector&lt;string&gt; findRestaurant(vector&lt;string&gt;&amp; list1, vector&lt;string&gt;&amp; list2) { unordered_map&lt;string, int&gt; m; vector&lt;string&gt; ans; int len1 = list1.size(); int len2 = list2.size(); int min = INT_MAX; for (int i = 0; i &lt; len1; i++) { m[list1[i]] = i + 1; } for (int i = 0; i &lt; len2 ; i++) { int pos = m[list2[i]]; if (pos) { int sum = pos - 1 + i; if (sum &lt; min) { ans.clear(); min = sum; ans.push_back(list2[i]); } else if (sum == min) { ans.push_back(list2[i]); } } } return ans; }}; 605. ç§èŠ±é—®é¢˜æ€è·¯ éå†æ¯ä¸€ä¸ªèŠ±ç›†ï¼Œçœ‹å®ƒå‰åæœ‰æ²¡æœ‰èŠ±ç›†ï¼Œæšä¸¾åˆ¤æ–­ï¼Œæ³¨æ„å¦‚æœn == 0æ—¶è¦é€€å‡ºå¾ªç¯ ä¼˜åŒ–ï¼šæŠŠç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªå•ç‹¬æ‹¿å‡ºæ¥ï¼Œç®€åŒ–å¾ªç¯æ—¶çš„åˆ¤æ–­æ•°ç›® ACä»£ç 1234567891011121314151617181920212223242526272829class Solution {public: bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) { int len = flowerbed.size(); for (int i = 0; i &lt; len &amp;&amp; n &gt; 0; i++) { if (flowerbed[i]) { } else { if (i == 0) { if (len == 1 || (i + 1 &lt; len &amp;&amp; !flowerbed[i + 1])) { n--; flowerbed[i] = 1; } } else if (i == len - 1) { if (i - 1 &gt;= 0 &amp;&amp; !flowerbed[i - 1]) { n--; flowerbed[i] = 1; } } else { if (!flowerbed[i - 1] &amp;&amp; !flowerbed[i + 1]) { n--; flowerbed[i] = 1; } } } } return n == 0; }}; ACä»£ç ï¼ˆä¼˜åŒ–ï¼‰12345678910111213141516171819202122232425class Solution {public: bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) { if (n &lt;= 0) return true; int len = flowerbed.size(); if (len &lt;= 0) return false; if (len == 1) return n &lt;= 1 &amp;&amp; !flowerbed[0]; int sum = 0; if (!flowerbed[0] &amp;&amp; !flowerbed[1]) { sum++; flowerbed[0] = 1; } for (int i = 1; i &lt; len - 2; i++) { if (!flowerbed[i] &amp;&amp; !flowerbed[i - 1] &amp;&amp; !flowerbed[i + 1]) { flowerbed[i] = 1; sum++; } } if (!flowerbed[len - 2] &amp;&amp; !flowerbed[len - 1]) { sum++; flowerbed[len - 1] = 1; } return n &lt;= sum; }}; 628. ä¸‰ä¸ªæ•°çš„æœ€å¤§ä¹˜ç§¯æ€è·¯ å‚è€ƒ414. ç¬¬ä¸‰å¤§çš„æ•°çš„æ€è·¯ï¼Œç”¨ä¸€æ¬¡éå†ï¼Œå¾—åˆ°ç¬¬ä¸€ï¼Œç¬¬äºŒç¬¬ä¸‰å¤§çš„æ•°ï¼ˆaã€bã€cï¼‰ï¼Œå’Œç¬¬ä¸€ï¼Œç¬¬äºŒå°çš„æ•°ï¼ˆm1ï¼Œm2ï¼‰ åˆ†åˆ«è®¡ç®—$abc$å’Œ$am1m2$ï¼Œè¿”å›è¾ƒå¤§çš„ä¸€ä¸ª ACä»£ç 123456789101112131415161718192021222324252627class Solution {public: int maximumProduct(vector&lt;int&gt;&amp; nums) { int first = INT_MIN, second = INT_MIN, third = INT_MIN; int min1 = INT_MAX, min2 = INT_MAX; for (auto x : nums) { if (x &gt;= first) { third = second; second = first; first = x; } else if (x &lt; first &amp;&amp; x &gt;= second) { third = second; second = x; } else if (x &lt; second &amp;&amp; x &gt;= third) { third = x; } if (x &lt; min1) { min2 = min1; min1 = x; } else if (x &gt;= min1 &amp;&amp; x &lt; min2) { min2 = x; } } int ans1 = first*second*third, ans2 = first*min1*min2; return ans1 &gt; ans2 ? ans1 : ans2; }}; 633. å¹³æ–¹æ•°ä¹‹å’Œæ€è·¯ è„‘è¢‹é‡Œæƒ³ä¸€ä¸ªåªæœ‰æ•´æ•°ç‚¹çš„åæ ‡ç³»ï¼Œå–ç¬¬ä¸€è±¡é™ï¼Œç”¨$y = x$åˆ†æˆä¸¤åŠï¼Œçœ‹ä¸€åŠï¼ŒåŒ…æ‹¬$y = x$å’Œå¦ä¸€ä¸ªåæ ‡è½´ï¼Œåœ¨è¿™ä¸ªä¸‰è§’åŒºåŸŸé‡Œé€‰å–çš„çš„ä¸ä¼šé‡å¤ é€‰å–ç‚¹ï¼Œä»0~$\\sqrt{\\frac{c}{2}}$ä¸­é€‰æ•´æ•°ï¼Œå¦‚æœæ»¡è¶³$\\sqrt{c - i^2}$ä¸ºæ•´æ•°ï¼Œé‚£ä¹ˆå°±å¯ä»¥ ä¼˜åŒ–ï¼Œç±»ä¼¼äºŒåˆ†æŸ¥æ‰¾ ACä»£ç 12345678910111213class Solution {public: bool judgeSquareSum(int c) { double n = sqrt(c/2.0); for (int i = 0; i &lt;= n; i++) { double x = sqrt(c - i*i); if (int(x) == x) { return true; } } return false; }}; ACä»£ç ï¼ˆä¼˜åŒ–ï¼‰1234567891011121314151617class Solution {public: bool judgeSquareSum(int c) { int a = 0, b = sqrt(c); while (a &lt;= b) { double sum = (double)a*a + b*b; if (sum == c) { return true; } else if (sum &gt; c) { b--; } else { a++; } } return false; }}; 637. äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼æ€è·¯æ”¹é€ äºŒå‰æ ‘çš„å±‚æ¬¡éå†çš„ä»£ç å®Œäº‹å„¿ ACä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;double&gt; averageOfLevels(TreeNode* root) { if (!root) return {}; vector&lt;double&gt; ans; TreeNode *root1 = new TreeNode(0), *root2 = new TreeNode(0); root2-&gt;left = root; root1-&gt;left = root2; TreeNode* temp = root1; vector&lt;TreeNode*&gt; m = {root1}; vector&lt;TreeNode*&gt;&amp; father = m; vector&lt;TreeNode*&gt; fatherTemp; while (father.size()) { fatherTemp.clear(); double sum = 0, count = 0; for (TreeNode* x : father) { if (x-&gt;left != NULL) { fatherTemp.push_back(x-&gt;left); if (x-&gt;left-&gt;left != NULL) { count++; sum += x-&gt;left-&gt;left-&gt;val; } if (x-&gt;left-&gt;right != NULL) { sum += x-&gt;left-&gt;right-&gt;val; count++; } } if (x-&gt;right != NULL) { fatherTemp.push_back(x-&gt;right); if (x-&gt;right-&gt;left != NULL) { sum += x-&gt;right-&gt;left-&gt;val; count++; } if (x-&gt;right-&gt;right != NULL) { sum += x-&gt;right-&gt;right-&gt;val; count++; } } } if (count) ans.push_back(sum/count); father = fatherTemp; } return ans; }}; 643. å­æ•°ç»„æœ€å¤§å¹³å‡æ•° Iæ€è·¯å…ˆç®—å‰kä¸ªæ•°çš„å’Œï¼Œç„¶åiä»k+1ä¸ªæ•°å¼€å§‹ï¼ŒæŠŠå°¾å·´ä¸Šçš„æ•°å‡æ‰ï¼Œä¸ŠiæŒ‡å‘çš„æ•°ï¼Œè·Ÿå½“å‰å€¼æ¯”å¤§å°ï¼Œå‚¨å­˜æœ€å¤§å’Œã€‚ ACä»£ç 123456789101112131415161718192021222324class Solution {public: double findMaxAverage(vector&lt;int&gt;&amp; nums, int k) { int len = nums.size(); int sum = 0; double maxSum = 0; for (int i = 0; i &lt; k; i++) { sum += nums[i]; } maxSum = sum; for (int i = k; i &lt; len; i++) { sum -= nums[i - k]; sum += nums[i]; maxSum = maxSum &gt; sum ? maxSum : sum; } return maxSum*1.0/k; }};static const int _ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0;}(); 645. é”™è¯¯çš„é›†åˆæ€è·¯ä¸€ä¸ªvectorï¼Œåˆå§‹åŒ–ä¸ºfalseï¼Œä¸€æ¬¡å¾ªç¯ï¼Œæ¯å‡ºç°ä¸€ä¸ªå…ƒç´ ï¼ŒæŠŠfalseå˜æˆtrueï¼Œå¦‚æœå·²ç»æ˜¯trueï¼Œè¯´æ˜å®ƒæ˜¯é‡å¤çš„å…ƒç´ ï¼ŒåŒæ—¶è®¡ç®—æ‰€æœ‰å…ƒç´ çš„å’Œï¼Œæœ€åæ ¹æ®ç­‰å·®æ•°åˆ—æ±‚å’Œå…¬å¼ç­‰ä¸€ç³»åˆ—è®¡ç®—è®¡ç®—å‡ºä¸¤ä¸ªæ•° ACä»£ç 123456789101112131415161718192021class Solution {public: vector&lt;int&gt; findErrorNums(vector&lt;int&gt;&amp; nums) { int n = 0; int sum = 0, len = nums.size(); vector&lt;bool&gt; m(len, false); for (auto x : nums) { if (!m[x])m[x] = true; else n = x; sum += x; } int add = len*(len + 1) / 2 - sum;//ç›¸æ¯”æ­£å¸¸ç¼ºå°‘çš„éƒ¨åˆ† return {n, n + add}; }};static const int _ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0;}(); 657. æœºå™¨äººèƒ½å¦è¿”å›åŸç‚¹ACä»£ç 123456789101112131415161718192021222324class Solution {public: bool judgeCircle(string moves) { int u = 0 ,d = 0 ,r = 0 ,l = 0; for (auto x : moves) { switch(x) { case 'U': u++; break; case 'D' : d++; break; case 'R' : r++; break; case 'L' : l++; break; } } return u == d &amp;&amp; l == r; }};static int desyncio = []() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }(); ACä»£ç ï¼ˆä¼˜åŒ–ï¼‰1234567891011121314151617class Solution {public: bool judgeCircle(string moves) { int movex[26] = {0}, movey[26] = {0}; movey['U' - 'A'] = 1; movey['D' - 'A'] = -1; movex['L' - 'A'] = -1; movex['R' - 'A'] = 1; int x = 0, y = 0; for (auto c : moves) { y += movey[c - 'A']; x += movex[c - 'A']; } return x == 0 &amp;&amp; y == 0; }};static int desyncio = []() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }(); 661. å›¾ç‰‡å¹³æ»‘å™¨æ€è·¯æš´åŠ›å¹²æ­»è¿™ç ´é¢˜ ACä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution {public: vector&lt;vector&lt;int&gt;&gt; imageSmoother(vector&lt;vector&lt;int&gt;&gt;&amp; M) { int r = M.size(); int c = M[0].size(); if (r &lt;= 1 &amp;&amp; c &lt;= 1) return M; vector&lt;vector&lt;int&gt;&gt; ans(r, vector&lt;int&gt;(c)); if (c == 1 || r == 1) { if (c == 1) { ans[0][0] = (M[0][0] + M[1][0])/2; ans[r - 1][0] = (M[r - 1][0] + M[r - 2][0])/2; for (int i = 1; i &lt; r - 1; i++) { ans[i][0] = (M[i][0] + M[i - 1][0] + M[i + 1][0])/3; } } else { ans[0][0] = (M[0][0] + M[0][1])/2; ans[0][c - 1] = (M[0][c - 1] + M[0][c - 2])/2; for (int i = 1; i &lt; c - 1; i++) { ans[0][i] = (M[0][i] + M[0][i - 1] + M[0][i + 1])/3; } } return ans; } ans[0][0] = (M[0][0] + M[1][1] + M[1][0] + M[0][1])/4; ans[0][c - 1] = (M[0][c - 1] + M[0][c - 2] + M[1][c - 1] + M[1][c - 2])/4; ans[r - 1][0] = (M[r - 1][0] + M[r-1][1] + M[r - 2][0] + M[r - 2][1])/4; ans[r - 1][c - 1] = (M[r - 1][c - 1] + M[r - 1][c - 2] + M[r - 2][c - 1] + M[r - 2][c - 2])/4; for (int i = 1; i &lt; r - 1; i++) { ans[i][0] = (M[i][0] + M[i - 1][0] + M[i + 1][0] + M[i][1] + M[i - 1][1] + M[i + 1][1])/6; ans[i][c - 1] = (M[i][c - 1] + M[i + 1][c - 1] + M[i - 1][c - 1] + M[i][c - 2] + M[i + 1][c - 2] + M[i - 1][c - 2])/6; } for (int i = 1; i &lt; c - 1; i++) { ans[0][i] = (M[0][i] + M[0][i + 1] + M[0][i - 1] + M[1][i] + M[1][i + 1] + M[1][i - 1]) / 6; ans[r - 1][i] = (M[r - 1][i] + M[r - 1][i + 1] + M[r - 1][i - 1] + M[r - 2][i] + M[r - 2][i + 1] + M[r - 2][i - 1]) / 6; } for (int i = 1; i &lt; r - 1; i++) { for (int j = 1; j &lt; c - 1; j++) { ans[i][j] = (M[i][j] + M[i + 1][j] + M[i - 1][j] + M[i][j + 1] + M[i + 1][j + 1] + M[i - 1][j + 1] + M[i][j - 1] + M[i + 1][j - 1] + M[i - 1][j - 1])/9; } } return ans; }};static const int _ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0;}();","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%938/"},{"title":"LeetCode-38","text":"2181. åˆå¹¶é›¶ä¹‹é—´çš„èŠ‚ç‚¹12345678910111213141516171819202122class Solution {public: ListNode* mergeNodes(ListNode* head) { int sum = 0; ListNode dummy; ListNode *move_dummy = &amp;dummy; ListNode *move = head; while(move-&gt;next) { sum = 0; while(move-&gt;next &amp;&amp; move-&gt;next-&gt;val != 0) { sum += move-&gt;next-&gt;val; move = move-&gt;next; } move-&gt;val = sum; move_dummy-&gt;next = move; move_dummy = move_dummy-&gt;next; move = move-&gt;next; move_dummy-&gt;next = nullptr; } return dummy.next; }}; 977. æœ‰åºæ•°ç»„çš„å¹³æ–¹123456789101112131415161718class Solution {public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) { int len = nums.size(); vector&lt;int&gt; merged_array(len); int i = 0, j = len - 1; for(int k = len - 1; k &gt;= 0; k--) { if(abs(nums[i]) &gt; abs(nums[j])) { merged_array[k] = nums[i] * nums[i]; i++; } else { merged_array[k] = nums[j] * nums[j]; j--; } } return merged_array; }}; æŒ‰ç…§ç»å¯¹å€¼å½’å¹¶ åŒæŒ‡é’ˆï¼Œä»å·¦å³ä¸¤ç«¯å¼€å§‹ç§»åŠ¨ï¼Œ 3174. æ¸…é™¤æ•°å­—1234567891011121314class Solution {public: string clearDigits(string s) { string res; for(char c : s) { if(!(c &gt;= '0' &amp;&amp; c &lt;= '9')) { res.push_back(c); } else { res.pop_back(); } } return res; }}; æ¨¡æ‹Ÿ 2860. è®©æ‰€æœ‰å­¦ç”Ÿä¿æŒå¼€å¿ƒçš„åˆ†ç»„æ–¹æ³•æ•°1234567891011121314151617181920212223242526class Solution {public: int countWays(vector&lt;int&gt;&amp; nums) { map&lt;int, int&gt; cnt; for(int n : nums) { cnt[n]++; } vector&lt;int&gt; arr; int len = 0; for(auto [num, total] : cnt) { arr.push_back(num); len++; } int i = 0; int ans = 0; int preSum = 0; while(i &lt; len - 1) { preSum += cnt[arr[i]]; if(preSum &lt; arr[i+1] &amp;&amp; preSum &gt; arr[i]) { ans++; } i++; } return ans + 1 + (arr[0] == 0 ? 0 : 1); }}; æ€è·¯ å‡è®¾é€‰æ‹©äº†ç¬¬iä¸ªå­¦ç”Ÿï¼Œä»–çš„å¼€å¿ƒæ¡ä»¶æ˜¯cnt &gt; nums[i]ï¼Œé‚£ä¹ˆ æ‰€æœ‰æ»¡è¶³nums[j] &lt;= nums[i]çš„å­¦ç”Ÿéƒ½å¿…é¡»è¢«é€‰æ‹© å¦‚æœå­˜åœ¨å­¦ç”Ÿjï¼Œnums[j] == nums[i] + 1ï¼Œnums[k] == nums[j]é‚£ä¹ˆæ»¡è¶³çš„å­¦ç”Ÿkéƒ½å¿…é¡»è¢«é€‰æ‹© å…¶ä»–æƒ…å†µéƒ½ä¸éœ€è¦è€ƒè™‘ï¼Œæ˜¯ä¸€å®šæ— æ³•æ»¡è¶³æ¡ä»¶çš„ åªè¦ç»Ÿè®¡æ¯ä¸ªnumå¯¹åº”å¤šå°‘å­¦ç”Ÿï¼ŒæŒ‰ç…§numæ’åºï¼Œ å¯¹äºç¬¬iä¸ªnumï¼Œå¦‚æœé€‰æ‹©ä»–ï¼Œä»–ä¹‹å‰çš„å­¦ç”Ÿå¿…é¡»é€‰æ‹© å¦‚æœnum[i+1] == num[i] + 1ï¼Œé‚£ä¹ˆæ— æ³•æ»¡è¶³ï¼Œæ˜¯ç©ºé›† å¦‚æœnum[i+1] &gt; num[i] + 1ï¼Œé‚£ä¹ˆåªè¦ç´¯è®¡å­¦ç”Ÿè¶³å¤Ÿæ¡ä»¶ï¼Œå°±èƒ½æ»¡è¶³ï¼Œæ»¡è¶³çš„æƒ…æ™¯+1 åˆ©ç”¨å‰ç¼€å’Œï¼Œè®°å½•numä»¥åŠå°äºnumçš„å­¦ç”Ÿæ•°ï¼Œå­¦ç”Ÿæ•°å¤§äºnum 3176. æ±‚å‡ºæœ€é•¿å¥½å­åºåˆ— IäºŒç»´dp123456789101112131415161718192021222324252627282930class Solution {public: int maximumLength(vector&lt;int&gt;&amp; nums, int k) { int len = nums.size(); vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(k + 1)); int maxLen = 0; for(int i = 0; i &lt; len; i++) { dp[i][0] = 1; for(int j = 0; j &lt; i; j++) { if(nums[i] == nums[j]) { dp[i][0] = max(dp[i][0], dp[j][0] + 1); } } maxLen = max(maxLen, dp[i][0]); } for(int i = 0; i &lt; len; i++) { for(int j = 1; j &lt;= k; j++) { for(int m = 0; m &lt; i; m++) { if(nums[i] == nums[m]) { dp[i][j] = max(dp[i][j], dp[m][j] + 1); } else { dp[i][j] = max(dp[i][j], dp[m][j - 1] + 1); } } maxLen = max(maxLen, dp[i][j]); } } return maxLen; }}; dp[i][j]ä»£è¡¨åˆ°ç¬¬iä¸ªæ•°ä¸ºæ­¢ï¼Œæ°å¥½æœ‰jä¸ªä¸åŒçš„æ•°çš„é•¿åº¦ è½¬ç§»æ–¹ç¨‹ å¦‚æœnums[i] == nums[m]ï¼Œä¸åŒçš„æ•°ç›¸åŒï¼Œjç›¸åŒ, dp[i][j] = max(dp[i][j], dp[m]p[j]) å¦‚æœnums[i] != nums[m]ï¼Œä¸åŒçš„æ•°ç›¸åŒï¼Œjä¸åŒï¼Œç›¸å·®1, dp[i][j] = max(dp[i][j], dp[m][j-1]) 2552. ç»Ÿè®¡ä¸Šå‡å››å…ƒç»„123456789101112131415161718192021222324252627282930class Solution {public: long long countQuadruplets(vector&lt;int&gt;&amp; nums) { long long ans = 0; int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; numsCnt(n, vector&lt;int&gt;(n+1, 0)); for(int i = n - 1; i &gt;= 0; i--) { for(int j = n - 1; j &gt; i; j--) { numsCnt[i][nums[j]]++; } } for(int i = 0; i &lt; n; i++) { for(int j = 1; j &lt;= n; j++) { numsCnt[i][j] += numsCnt[i][j-1]; } } for(int i = 0; i &lt; n; i++) { int smallerThanMe = 0; int cntOfBiggerAfterMe = 0; for(int j = i - 1; j &gt;= 0; j--) { if(nums[j] &gt; nums[i]) { cntOfBiggerAfterMe += (n - i - 1) - numsCnt[i][nums[j]]; } else if(nums[j] &lt; nums[i]) { ans += cntOfBiggerAfterMe; } } } return ans; }}; æƒ³ç”¨å•è°ƒé€’å¢æ ˆï¼Œè¿™æ ·æ ˆå†…ä¸¤ä¸ªç›¸é‚»å…ƒç´ ä¹‹é—´éƒ½æ˜¯æ¯”ä¸¤ä¸ªæ•°å¤§çš„ï¼Œåœ¨æ‰¾åˆ°ç¬¬ä¸‰ä¸ªå…ƒç´ åé¢æœ‰å¤šå°‘æ¯”ç¬¬äºŒä¸ªå…ƒç´ å¤§çš„æ•°ï¼Œå°±å¯ä»¥äº† è¿™æ ·åªæ¯”æ ˆé¡¶ä¸¤ä¸ªå…ƒç´ ä¼šå¯¼è‡´é—æ¼ï¼Œç›´æ¥æ‰¾nums[i]å‰æ¯”nums[i]å°çš„æ•°nums[j1]ï¼Œå’Œä»–ä»¬ä¹‹é—´æ¯”nums[i]å¤§çš„æ•°nums[j]ï¼Œå†æ‰¾å‡ºæ¯ä¸ªæ•°åœ¨iåæœ‰å¤šå°‘æ¯”nums[j]å¤§çš„æ•°ï¼Œå¯ä»¥ç»Ÿè®¡åˆ°åˆ°æ¯”nums[j1]è¿˜å°çš„æ•°çš„ç»„åˆæƒ…å†µ numsCnt[i][j]è¡¨ç¤ºåœ¨å¼€åŒºé—´(i, n)ä¸­ï¼Œæœ‰å¤šå°‘æ¯”nums[j]å¤§çš„æ•° 2555. ä¸¤ä¸ªçº¿æ®µè·å¾—çš„æœ€å¤šå¥–å“123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution {public: int maximizeWin(vector&lt;int&gt;&amp; prizePositions, int k) { int i = 0, j = 0; int n = prizePositions.size(); vector&lt;int&gt; windowSum; vector&lt;int&gt; windowStart; int prizeCnt = 0; while(i &lt; n) { int start = prizePositions[i]; int end = prizePositions[i] + k; while(j &lt; n &amp;&amp; prizePositions[j] &lt;= end) { j++; prizeCnt++; } windowSum.push_back(prizeCnt); windowStart.push_back(start); while(i &lt; n &amp;&amp; prizePositions[i] == start) { i++; prizeCnt--; } } int windowSize = windowSum.size(); int curMaxTail = windowSum[windowSize - 1]; int curMaxStart = windowStart[windowSize - 1]; vector&lt;int&gt; maxTail(windowSize); for(int i = windowSize - 2; i &gt;= 0; i--) { maxTail[i] = curMaxTail; if(windowSum[i] &gt; curMaxTail) { curMaxTail = windowSum[i]; curMaxStart = windowStart[i]; } } int ans = 0; j = 0; for(int i = 0; i &lt; windowSize; i++) { while(j &lt; windowSize &amp;&amp; windowStart[i] + k &gt;= windowStart[j]) { j++; } j--; if(j &lt; n) ans = max(ans, windowSum[i] + maxTail[j]); } return ans; }}; è™½ç„¶ä¸¤ä¸ªçº¿æ®µå¯ä»¥é‡å ï¼Œä½†æ˜¯é‡å éƒ¨åˆ†çš„å¥–å“ä¸èƒ½é‡å¤æ‹¿ï¼Œæ‰€ä»¥é—®é¢˜å°±å˜æˆäº†é•¿åº¦æœ€é•¿ä¸ºkçš„æƒ…å†µä¸‹ï¼Œä¸æƒ³äº¤çš„ä¸¤ä¸ªçº¿æ®µå†…ç¤¼ç‰©æ€»æ•°å’Œæœ€å¤§çš„æƒ…å†µ æ‰¾å‡ºæ‰€æœ‰é•¿åº¦ä¸ºkçš„çº¿æ®µçš„ç¤¼ç‰©æ•°ï¼ˆstartç›¸åŒçš„ä¸é‡å¤è®°å½•ï¼‰ï¼Œè®°å½•åœ¨windowSumä¸­ï¼Œç”¨windowStartè®°å½•åŒºé—´çš„èµ·ç‚¹ ç”¨maxTail[i]è®°å½•èµ·å§‹ç‚¹ä¸ºwindowStart[i]çš„çº¿æ®µåæ–¹ï¼Œç¤¼ç‰©å¤šçš„çº¿æ®µçš„ç¤¼ç‰©ä¸ªæ•° æœ€åå¯¹äºæ¯ä¸€ä¸ªçº¿æ®µï¼ŒåŒæŒ‡é’ˆæ‰¾åˆ°ä¸é‡å çš„ä¸‹ä¸€ä¸ªçº¿æ®µåŠå…¶åé¢çš„æœ€å¤§ç¤¼ç‰©æ•°ï¼ŒåŠ èµ·æ¥ï¼Œæ±‚æœ€å¤§å€¼ 2332. åä¸Šå…¬äº¤çš„æœ€æ™šæ—¶é—´äºŒåˆ†123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: int latestTimeCatchTheBus(vector&lt;int&gt;&amp; buses, vector&lt;int&gt;&amp; passengers, int capacity) { sort(buses.begin(), buses.end()); sort(passengers.begin(), passengers.end()); int busNum = buses.size(); int passengersNum = passengers.size(); vector&lt;int&gt; insertPoints(passengersNum); insertPoints[0] = 0; for(int i = 1; i &lt; passengersNum; i++) { if(passengers[i] - passengers[i - 1] &gt; 1) { insertPoints[i] = i; // ä¸å’Œå‰ä¸€ä¸ªè¿å·ï¼Œæ›´æ–°æœ€æ™šä¸Šè½¦ä½ç½® } else { insertPoints[i] = insertPoints[i - 1]; // ä¸Šè½¦æ—¶é—´ä¸èƒ½å’Œåˆ«äººé‡å¤ï¼Œå¦‚æœè¿å·ï¼Œæ‰¾åˆ°å‰é¢ç¬¬ä¸€ä¸ªä¸è¿å·çš„ä½ç½® } } int lastestTime = 0; int j = 0; int i = 0; for(; i &lt; busNum &amp;&amp; j &lt; passengersNum; i++) { // éå†å…¬äº¤è½¦ int firstCantGetOn = upper_bound(passengers.begin() + j, passengers.end(), buses[i]) - passengers.begin(); // äºŒåˆ†æ‰¾åˆ°ç¬¬ä¸€ä¸ªï¼Œæ—¶é—´ä¸Šæ— æ³•ä¸Šè½¦çš„äºº int getOnCnt = min(firstCantGetOn - j, capacity); if(getOnCnt == 0 &amp;&amp; capacity &gt; 0) { // å¦‚æœæ²¡æœ‰äººèƒ½ä¸Šï¼Œä¸”è½¦å®¹é‡å¤§äº0 lastestTime = buses[i]; // æœ€æ™šå°±æ˜¯å…¬äº¤è½¦åˆ°ç«™æ—¶é—´ } else if(getOnCnt &lt; capacity &amp;&amp; buses[i] - passengers[j + getOnCnt - 1] &gt; 0) { // å¦‚æœä¸Šè½¦æ•°é‡å°äºå®¹é‡ï¼Œæœ€æ™šå¯ä»¥åœ¨å‘è½¦å‰åˆ°è¾¾ï¼Œä¸”æœ€åä¸€ä¸ªäººä¸æ˜¯åœ¨å‘è½¦æ—¶åˆ°è¾¾ lastestTime = buses[i]; } else if(insertPoints[j + getOnCnt - 1] &gt;= j) { // å¦‚æœå‰ä¸€ä¸ªå¯æ’å…¥ç‚¹åœ¨jæˆ–å…¶ä¹‹åï¼Œä¹Ÿå°±æ˜¯è¿™æ‰¹äººä¸­æœ‰æ’å…¥ç‚¹ lastestTime = passengers[insertPoints[j + getOnCnt - 1]] - 1; } // else: æ²¡æœ‰æ’å…¥ç‚¹ï¼Œæ— æ³•ä¸Šè½¦ï¼Œä»€ä¹ˆéƒ½ä¸åš j += getOnCnt; } if(i &lt; busNum) { return buses.back(); } return lastestTime; }}; 1184. å…¬äº¤ç«™é—´çš„è·ç¦»dijkstra1234567891011121314151617181920212223class Solution {public: int distanceBetweenBusStops(vector&lt;int&gt;&amp; distance, int start, int destination) { int n = distance.size(); vector&lt;int&gt; dis(n, INT_MAX / 2); dis[start] = 0; vector&lt;bool&gt; visited(n, false); for(int i = 0; i &lt; n; i++) { int firstClosestAndNotVisited = -1; for(int j = 0; j &lt; n; j++) { if(!visited[j] &amp;&amp; (firstClosestAndNotVisited == -1 || dis[j] &lt; dis[firstClosestAndNotVisited])) { firstClosestAndNotVisited = j; } } int next = firstClosestAndNotVisited; visited[next] = true; dis[(next + 1) % n] = min(dis[(next + 1) % n], distance[next] + dis[next]); dis[(next - 1 + n) % n] = min(dis[(next - 1 + n) % n], distance[(next - 1 + n) % n] + dis[next]); } return dis[destination]; }}; ä¸€æ¬¡éå†123456789101112131415161718192021class Solution {public: int distanceBetweenBusStops(vector&lt;int&gt;&amp; distance, int start, int destination) { int n = distance.size(); int counterClockWiseSum = 0; int clockWiseSum = 0; if(start &gt; destination) { swap(start, destination); } for(int i = 0; i &lt; start; i++) { counterClockWiseSum += distance[i]; } for(int i = start; i &lt; destination; i++) { clockWiseSum += distance[i]; } for(int i = destination; i &lt; n; i++) { counterClockWiseSum += distance[i]; } return min(clockWiseSum, counterClockWiseSum); }}; ç”±äºåªæœ‰ä¸¤ä¸ªè·¯å¾„åˆ°è¾¾destinationï¼Œåªè¦è®¡ç®—é¡ºæ—¶é’ˆå’Œé€†æ—¶é’ˆçš„æ€»å’Œï¼Œå–æœ€å°å€¼å°±å¥½ 2848. ä¸è½¦ç›¸äº¤çš„ç‚¹å·®åˆ†æ•°ç»„1234567891011121314151617181920class Solution {public: int numberOfPoints(vector&lt;vector&lt;int&gt;&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; diff(102); for(int i = 0; i &lt; n; i++) { diff[nums[i][0]]++; diff[nums[i][1] + 1]--; } int curVal = 0; int cnt = 0; for(int i = 1; i &lt;= 100; i++) { curVal += diff[i]; if(curVal &gt; 0) { cnt++; } } return cnt; }}; æ’åºè´ªå¿ƒ1234567891011121314151617181920class Solution {public: int numberOfPoints(vector&lt;vector&lt;int&gt;&gt;&amp; nums) { int n = nums.size(); sort(nums.begin(), nums.end(), [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b){ return a[0] &lt; b[0]; }); int curStart = nums[0][0], curEnd = nums[0][1]; int i = 0; int cnt = 0; for(; i &lt; n; i++) { if(nums[i][0] &gt; curEnd) { cnt += curEnd - curStart + 1; curStart = nums[i][0]; curEnd = nums[i][1]; } else { curEnd = max(curEnd, nums[i][1]); } } return cnt + (curEnd - curStart + 1); }};","link":"/home/2024/09/09/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9338/"},{"title":"LeetCode-36","text":"551. å­¦ç”Ÿå‡ºå‹¤è®°å½• I1234567891011121314151617181920class Solution {public: bool checkRecord(string s) { int count = 0; int max_seq_late = 0; int seq_late = 0; for(char c : s) { if(c == 'A') count++; if(c == 'L') { seq_late++; } else { max_seq_late = max(max_seq_late, seq_late); seq_late = 0; } } max_seq_late = max(max_seq_late, seq_late); return count &lt; 2 &amp;&amp; max_seq_late &lt; 3; }}; è¿ç»­ç›¸åŒçš„å€¼çš„ä¸ªæ•° ç»Ÿè®¡å…ƒç´ å‡ºç°çš„æ¬¡æ•° 3137. K å‘¨æœŸå­—ç¬¦ä¸²éœ€è¦çš„æœ€å°‘æ“ä½œæ¬¡æ•°123456789101112131415class Solution {public: int minimumOperationsToMakeKPeriodic(string word, int k) { unordered_map&lt;string, int&gt; subStrCount; int len = word.length(); for(int i = 0; i &lt; len; i += k) { subStrCount[word.substr(i, k)]++; } int minOpCnt = len / k; for(auto&amp; ite : subStrCount) { minOpCnt = min(minOpCnt, len / k - ite.second); } return minOpCnt; }}; ç¿»è¯‘ä¸€ä¸‹è§„åˆ™ï¼Œå°±æ˜¯æŠŠé•¿åº¦ä¸ºnkçš„å­—ç¬¦ä¸²åˆ‡å‰²æˆnä¸ªé•¿åº¦ä¸ºkçš„å­ä¸²ï¼Œä¸€æ¬¡æ“ä½œå¯ä»¥æŠŠä¸€ä¸ªå­ä¸²æ›¿æ¢æˆå¦ä¸€ä¸ªå­—ä¸²ï¼Œæ±‚å¦‚ä½•æ›¿æ¢ï¼Œå°†æ‰€æœ‰å­—ä¸²éƒ½ç›¸åŒã€‚ ç¿»è¯‘å¥½éœ€æ±‚ï¼Œå°±å¾ˆæ¸…æ¥šäº†ï¼Œç›´æ¥ç»Ÿè®¡æ¯ä¸ªå­—ä¸²å‡ºç°çš„æ¬¡æ•°ï¼Œå–å‡ºç°æ¬¡æ•°æœ€å¤§çš„ï¼Œæ›¿æ¢æ¬¡æ•°æœ€å°‘ï¼Œä¸ºn - cnt[i] 3117. åˆ’åˆ†æ•°ç»„å¾—åˆ°æœ€å°çš„å€¼ä¹‹å’Œè¶…æ—¶æš´æœ123456789101112131415161718192021222324252627282930313233class Solution { int n; int m; unsigned int minSum = -1;public: int minimumValueSum(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; andValues) { n = nums.size(); m = andValues.size(); vector&lt;vector&lt;unsigned int&gt;&gt; andMat(n, vector&lt;unsigned int&gt;(n, INT_MAX)); for(int i = 0; i &lt; n; i++) { andMat[i][i] = nums[i]; for(int j = i + 1; j &lt; n; j++) { andMat[i][j] = andMat[i][j-1] &amp; nums[j]; } } search(andMat, andValues, 0, 0, 0); return minSum; } void search(const vector&lt;vector&lt;unsigned int&gt;&gt;&amp; andMat, const vector&lt;int&gt;&amp; andValues, int depth, int start, unsigned int sum) { if(depth + 1 == m) { if(andMat[start][n-1] == andValues[m-1]) { minSum = min(minSum, sum + andMat[n-1][n-1]); } return; } for(int i = start + 1; i &lt; n - m + depth + 2; i++) { if(andMat[start][i-1] == andValues[depth]) { search(andMat, andValues, depth + 1, i, sum + andMat[i-1][i-1]); } } }}; 3148. çŸ©é˜µä¸­çš„æœ€å¤§å¾—åˆ†1234567891011121314151617class Solution {public: int maxScore(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = grid.size(), n = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; mat(m, vector&lt;int&gt;(n, INT_MIN)); int maxScore = INT_MIN; mat[0][0] = 0; for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; n; j++) { if(i &gt; 0) mat[i][j] = max(max(mat[i][j], grid[i][j] - grid[i-1][j]), mat[i-1][j] + grid[i][j] - grid[i-1][j]); if(j &gt; 0) mat[i][j] = max(max(mat[i][j], grid[i][j] - grid[i][j-1]), mat[i][j-1] + grid[i][j] - grid[i][j-1]); if(i &gt; 0 || j &gt; 0) maxScore = max(maxScore, mat[i][j]); } } return maxScore; }}; åªèƒ½å‘ä¸‹æˆ–å‘å³èµ°ï¼Œæ‰€ä»¥å³ä¸‹æ–¹çš„æ ¼å­ä¸ä¼šå½±å“å·¦ä¸Šæ–¹æ ¼å­çš„æœ€ç»ˆç»“æœï¼Œç›´æ¥æ‹¿ä¸Šæ–¹æ ¼å­å’Œå·¦æ–¹æ ¼å­çš„å€¼è®¡ç®—ï¼Œå¹¶å­˜å‚¨åˆ°è¾¾æ¯ä¸ªæ ¼å­çš„æœ€å°å€¼å°±å¥½ã€‚ 3152. ç‰¹æ®Šæ•°ç»„ IIäºŒåˆ†123456789101112131415161718192021222324class Solution {public: vector&lt;bool&gt; isArraySpecial(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; queries) { int n = nums.size(); vector&lt;int&gt; startIndex, endIndex; vector&lt;bool&gt; ans; int s = 0; for(int i = 1; i &lt; n; i++) { if(((nums[i] &amp; 1) ^ (nums[i-1] &amp; 1)) == 0) { startIndex.push_back(s); endIndex.push_back(i - 1); s = i; } } startIndex.push_back(s); endIndex.push_back(n - 1); for(auto &amp;query : queries) { int start = query[0], end = query[1]; int findIndex = upper_bound(startIndex.begin(), startIndex.end(), start) - startIndex.begin() - 1; ans.push_back(endIndex[findIndex] &gt;= end); } return ans; }}; lower_bound: ç›´è¯‘æ˜¯ä¸‹ç•Œï¼Œå®é™…ä¸Šæ˜¯ä¸Šç¡®ç•Œï¼Œä¹Ÿå°±æ˜¯å¯ä»¥ç­‰äºè¢«æŸ¥æ‰¾çš„å…ƒç´  upper_bound: ç›´è¯‘æ˜¯ä¸Šç•Œï¼Œä¹Ÿå°±æ˜¯ä¸å¯ä»¥ç­‰äºè¢«æŸ¥æ‰¾çš„å…ƒç´  æ¨¡ä»¿çº¿æ®µæ ‘1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Solution { class SegTree { vector&lt;int&gt;&amp; nums; vector&lt;bool&gt; segTree; int n; int alignedSize; unsigned int alignment(unsigned int n) { unsigned int mask = 0x80000000; while(mask &amp;&amp; !(mask &amp; n)) mask &gt;&gt;= 1; return (n &amp; (n-1)) != 0 ? (mask &lt;&lt; 1) : mask; // å¾—åˆ°å¤§äºç­‰äºnçš„2çš„å¹‚ } void initSegTreeLeaf() { if(n &lt;= 1) return; for(int i = 0; i &lt; n - (n &amp; 1); i+=2) { int leftIndex = alignedSize + i - 1; int rightIndex = alignedSize + i; leftIndex = (leftIndex - 1) &gt;&gt; 1; segTree[leftIndex] = ((nums[i] &amp; 1) ^ (nums[i+1] &amp; 1)); } } bool initSegTree(int start, int end, int index) { int mid = (end - start) / 2 + start; if(start &gt;= end) return true; if(index &gt;= alignedSize / 2) return segTree[index]; if(mid &gt;= 0 &amp;&amp; mid + 1 &lt; n) { segTree[index] = (nums[mid] &amp; 1) ^ (nums[mid+1] &amp; 1); } segTree[index] = segTree[index] &amp; initSegTree(start, mid, 2 * index + 1) &amp; initSegTree(mid+1, end, 2 * index + 2); return segTree[index]; } bool query(int i , int j, int start, int end, int index) { int mid = (end - start) / 2 + start; if(start == end) return true; if(i &lt;= start &amp;&amp; end &lt;= j) { return segTree[index]; } if(mid &gt;= i &amp;&amp; mid + 1 &lt;= j &amp;&amp; !((nums[mid] &amp; 1) ^ (nums[mid+1] &amp; 1))) return false; if(mid &gt;= i &amp;&amp; !query(i, j, start, mid, 2 * index + 1)) { return false; } if(mid + 1 &lt;= j &amp;&amp; !query(i, j, mid+1, end, 2 * index + 2)) { return false; } return true; } public: SegTree(vector&lt;int&gt;&amp; nums): \\ nums(nums), n(nums.size()), \\ alignedSize(alignment(n)) { segTree = vector&lt;bool&gt;(alignedSize, true); // ä¸ç”¨ä¹˜2ï¼Œå› ä¸ºå¶å­èŠ‚ç‚¹å…¨æ˜¯true initSegTreeLeaf(); initSegTree(0, alignedSize - 1, 0); } bool query(int i , int j) { return query(i, j, 0, alignedSize - 1, 0); } };public: vector&lt;bool&gt; isArraySpecial(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; queries) { vector&lt;bool&gt; ans; SegTree segTree(nums); for(auto&amp; q : queries) { bool result = segTree.query(q[0], q[1]); ans.push_back(result); } return ans; }}; å“ï¼Œé€Ÿåº¦ä¸æ˜¯å¾ˆå¿«279ms å‡»è´¥13.48% dp3151. ç‰¹æ®Šæ•°ç»„ I1234567891011121314class Solution {public: bool isArraySpecial(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int odd = nums[0] &amp; 1; for(int i = 1; i &lt; len; i++) { if((nums[i] &amp; 1) == odd) { return false; } odd = !odd; } return true; }}; 676. å®ç°ä¸€ä¸ªé­”æ³•å­—å…¸1234567891011121314151617181920212223242526272829class MagicDictionary { vector&lt;string&gt; dictionary;public: MagicDictionary() { } void buildDict(vector&lt;string&gt; dictionary) { this-&gt;dictionary = dictionary; } bool search(string searchWord) { for(auto&amp; word : dictionary) { if(word.size() != searchWord.size()) { continue; } int diff = 0; for(int i = 0; i &lt; word.size(); i++) { if(word[i] != searchWord[i]) { diff++; } } if(diff == 1) { return true; } } return false; }}; 1035. ä¸ç›¸äº¤çš„çº¿1 3132. æ‰¾å‡ºä¸æ•°ç»„ç›¸åŠ çš„æ•´æ•° II123456789101112131415161718192021222324252627282930class Solution {public: int minimumAddedInteger(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { sort(nums1.begin(), nums1.end()); sort(nums2.begin(), nums2.end()); int len2 = nums2.size(); int x = INT_MAX; for(int start = 0; start &lt; 3; start++) { int skip = 2 - start; int diff = nums2[0] - nums1[start]; bool flag = true; for(int i = 1, j = 1; i &lt; len2; j++) { if(nums2[i] - nums1[start+j] != diff) { if(skip &gt; 0) { skip--; } else { flag = false; break; } } else { i++; } } if(flag) { x = min(x, diff); } } return x; }}; å…ˆæ’åºï¼Œè®¡ç®—å·®å€¼ï¼Œçœ‹æ˜¯å¦æ‰€æœ‰å·®å€¼éƒ½ç›¸åŒ ç”±äºæ•°ç»„1çš„é•¿åº¦æ¯”æ•°ç»„2é•¿2ï¼Œæ‰€ä»¥æ¯”æ—¶ç»™æ•°ç»„1ä¸€ä¸ªåç§» ç”±äºéœ€è¦åˆ é™¤ä¸¤ä¸ªï¼Œä¸”åˆ é™¤çš„ä½ç½®ä¸åŒï¼Œæ¯”è¾ƒæ—¶å¦‚æœé‡åˆ°ä¸ç›¸ç­‰çš„æƒ…å†µï¼Œåˆ™æ ¹æ®æƒ…å†µè·³è¿‡ä¸€ä¸ª 3131. æ‰¾å‡ºä¸æ•°ç»„ç›¸åŠ çš„æ•´æ•° I123456class Solution {public: int addedInteger(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { return *max_element(nums2.begin(), nums2.end()) - *max_element(nums1.begin(), nums1.end()); }}; 3129. æ‰¾å‡ºæ‰€æœ‰ç¨³å®šçš„äºŒè¿›åˆ¶æ•°ç»„ I12345678910111213141516171819202122232425262728293031323334class Solution { const long long MOD = 1e9 + 7;public: int numberOfStableArrays(int zero, int one, int limit) { // è¿ç»­çš„0å’Œ1çš„ä¸ªæ•°ä¸è¶…è¿‡limit vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp0 = vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;(zero + 1, vector&lt;vector&lt;int&gt;&gt;(one + 1, vector&lt;int&gt;(limit+1, 0))); vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp1 = vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;(zero + 1, vector&lt;vector&lt;int&gt;&gt;(one + 1, vector&lt;int&gt;(limit+1, 0))); for(int z = 1; z &lt;= min(zero, limit); z++) { dp0[z][0][z] = 1; } for(int o = 1; o &lt;= min(one, limit); o++) { dp1[0][o][o] = 1; } for(int z = 1; z &lt;= zero; z++) { for(int o = 1; o &lt;= one; o++) { int dp01 = 0; int dp11 = 0; for(int l = 1; l &lt;= limit; l++) { dp01 = (dp01 + dp1[z-1][o][l]) % MOD; // å«æœ‰z-1ä¸ª0ï¼Œoä¸ª1ï¼Œæœ«å°¾è¿ç»­1çš„ä¸ªæ•°ä¸ºlï¼Œçš„æ•°åé¢åŠ ä¸€ä¸ª0ï¼Œå˜æˆz+1ä¸ª0ï¼Œoä¸ª1ï¼Œæœ«å°¾è¿ç»­0çš„ä¸ªæ•°ä¸º1çš„æ•° dp11 = (dp11 + dp0[z][o-1][l]) % MOD; // å«æœ‰zä¸ª0ï¼Œo-1ä¸ª1ï¼Œæœ«å°¾è¿ç»­0çš„ä¸ªæ•°ä¸ºlï¼Œçš„æ•°åé¢åŠ ä¸€ä¸ª1ï¼Œå˜æˆzä¸ª0ï¼Œo+1ä¸ª1ï¼Œæœ«å°¾è¿ç»­1çš„ä¸ªæ•°ä¸º1çš„æ•° dp0[z][o][l] += dp0[z-1][o][l-1]; // å«æœ‰z-1ä¸ª0ï¼Œoä¸ª1ï¼Œæœ«å°¾è¿ç»­0çš„ä¸ªæ•°ä¸ºl-1ï¼Œçš„æ•°åé¢å†åŠ ä¸€ä¸ª0ï¼Œå˜æˆz+1ä¸ª0ï¼Œoä¸ª1ï¼Œæœ«å°¾è¿ç»­0çš„ä¸ªæ•°ä¸ºlçš„æ•° dp1[z][o][l] += dp1[z][o-1][l-1]; // å«æœ‰z-1ä¸ª0ï¼Œoä¸ª1ï¼Œæœ«å°¾è¿ç»­0çš„ä¸ªæ•°ä¸ºl-1ï¼Œçš„æ•°åé¢å†åŠ ä¸€ä¸ª1ï¼Œå˜æˆzä¸ª0ï¼Œo+1ä¸ª1ï¼Œæœ«å°¾è¿ç»­1çš„ä¸ªæ•°ä¸ºlçš„æ•° } dp0[z][o][1] += dp01; dp1[z][o][1] += dp11; } } int ans = 0; for(int l = limit; l &gt;= 1; l--) { ans = (ans + (dp0[zero][one][l] + dp1[zero][one][l]) % MOD) % MOD; } return ans; }}; ç­”æ¡ˆè¿˜å¯ä»¥é™ç»´ 600. ä¸å«è¿ç»­1çš„éè´Ÿæ•´æ•°123456789101112131415161718class Solution { int cnt = 0; void search(int i, int n) { if(i &gt; n) { return; } cnt++; if(!(i &amp; 1)) { search((i &lt;&lt; 1) | 1, n); } search((i &lt;&lt; 1) | 0, n); }public: int findIntegers(int n) { search(1, n); return cnt + 1; }}; 572. å¦ä¸€æ£µæ ‘çš„å­æ ‘12345678910111213141516171819202122232425262728293031class Solution { void findNode(TreeNode* root, int val, vector&lt;TreeNode*&gt;&amp; result) { if(root == nullptr) { return; } if(root-&gt;val == val) { result.push_back(root); } findNode(root-&gt;left, val, result); findNode(root-&gt;right, val, result); } bool _isSubTree(TreeNode *root, TreeNode* subRoot) { if(root == nullptr || subRoot == nullptr) { return root == subRoot; } if(root-&gt;val != subRoot-&gt;val) { return false; } return _isSubTree(root-&gt;left, subRoot-&gt;left) &amp;&amp; _isSubTree(root-&gt;right, subRoot-&gt;right); }public: bool isSubtree(TreeNode* root, TreeNode* subRoot) { vector&lt;TreeNode*&gt; nodes; findNode(root, subRoot-&gt;val, nodes); for(TreeNode* node : nodes) { if(_isSubTree(node, subRoot)) return true; } return false; }}; 3143. æ­£æ–¹å½¢ä¸­çš„æœ€å¤šç‚¹æ•°123456789101112131415161718192021222324252627282930313233343536373839class Solution {public:public: int maxPointsInsideSquare(vector&lt;vector&lt;int&gt;&gt;&amp; points, string s) { auto getLineLen = [](const vector&lt;int&gt;&amp; point) { // ç‚¹æ‰€åœ¨æ­£æ–¹å½¢çš„è¾¹é•¿/2ï¼Œç”¨æ¥ä»£è¡¨ä¸€ä¸ªæ­£æ–¹å½¢ return max(abs(point[0]), abs(point[1])); }; int len = points.size(); vector&lt;int&gt; sortedIndex(len); iota(sortedIndex.begin(), sortedIndex.end(), 0); sort(sortedIndex.begin(), sortedIndex.end(), [&amp;points, &amp;getLineLen](int a, int b){ return getLineLen(points[a]) &lt; getLineLen(points[b]); }); // æŒ‰ç…§ç‚¹æ‰€åœ¨æ­£æ–¹å½¢çš„è¾¹é•¿æ’åº unordered_set&lt;char&gt; labelSet; // è®°å½•å‡ºç°è¿‡çš„labelï¼Œä¸å…è®¸å‡ºç°ç›¸åŒçš„label int cnt = 0; int maxcnt = 0; int i = 0; bool valid = true; while(i &lt; len &amp;&amp; valid) { int index = sortedIndex[i]; int lineLen = getLineLen(points[index]); while(i &lt; len &amp;&amp; lineLen == getLineLen(points[index = sortedIndex[i]])) { // éå†æ‰€æœ‰ç›¸åŒè¾¹é•¿çš„ç‚¹ char label = s[index]; if(labelSet.count(label)) { valid = false; // è¿™ä¸ªæ­£æ–¹å½¢çš„è¾¹ä¸Šé‡åˆ°äº†å‡ºç°è¿‡çš„labelï¼Œè¿™ä¸ªæ­£æ–¹å½¢å¤±æ•ˆï¼Œæ›´å¤§çš„æ­£æ–¹å½¢ä¹Ÿå¤±æ•ˆ break; } else { cnt++; } labelSet.insert(label); i++; } if(valid) { // å¯¹äºåˆæ³•æ­£æ–¹å½¢ï¼Œæ›´æ–°ç‚¹æ•° maxcnt = cnt; } } return maxcnt; }}; 3128. ç›´è§’ä¸‰è§’å½¢å››æ¬¡å‰ç¼€å’Œ12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution {public: long long numberOfRightTriangles(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { long long number = 0; int m = grid.size(), n = grid[0].size(); vector&lt;int&gt; verticalSum; verticalSum = vector&lt;int&gt;(n); for(int i = 0; i &lt; m; i++) { int horSum = 0; for(int j = 0; j &lt; n; j++) { if(!grid[i][j]) continue; verticalSum[j] += grid[i][j]; horSum += grid[i][j]; number += (horSum - 1) * (verticalSum[j] - 1); } } verticalSum = vector&lt;int&gt;(n); for(int i = m - 1; i &gt;= 0; i--) { int horSum = 0; for(int j = 0; j &lt; n; j++) { if(!grid[i][j]) continue; verticalSum[j] += grid[i][j]; horSum += grid[i][j]; number += (horSum - 1) * (verticalSum[j] - 1); } } verticalSum = vector&lt;int&gt;(n); for(int i = m - 1; i &gt;= 0; i--) { int horSum = 0; for(int j = n - 1; j &gt;= 0; j--) { if(!grid[i][j]) continue; verticalSum[j] += grid[i][j]; horSum += grid[i][j]; number += (horSum - 1) * (verticalSum[j] - 1); } } verticalSum = vector&lt;int&gt;(n); for(int i = 0; i &lt; m; i++) { int horSum = 0; for(int j = n - 1; j &gt;= 0; j--) { if(!grid[i][j]) continue; verticalSum[j] += grid[i][j]; horSum += grid[i][j]; number += (horSum - 1) * (verticalSum[j] - 1); } } return number; }}; LCP 40. å¿ƒç®—æŒ‘æˆ˜è´ªå¿ƒ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution {public: int maximumScore(vector&lt;int&gt;&amp; cards, int cnt) { vector&lt;int&gt; odd, even; sort(cards.begin(), cards.end()); for(int card : cards) { ((card &amp; 1) ? odd : even).push_back(card); // ä¸‰ç›®è¿ç®—ç¬¦çš„è¿™ç§ç”¨æ³•ç»ˆäºè¢«æˆ‘ç”¨ä¸Šäº† } int score = 0; int odd_index = odd.size() - 1; int even_index = even.size() - 1; while(cnt) { bool has2_odd = odd_index &gt;= 1; bool has2_even = even_index &gt;= 1; bool cnt_at_least_2 = cnt &gt;= 2; if(has2_odd &amp;&amp; has2_even &amp;&amp; cnt_at_least_2) { if(even[even_index] &gt;= odd[odd_index] + odd[odd_index - 1]) { goto do_even; } else if(odd[odd_index] + odd[odd_index - 1] &gt;= even[even_index] + even[even_index - 1]) { goto do_odd; } else { goto do2_even; } } else { if((cnt == 1 || odd_index == 0) &amp;&amp; even_index &gt;= 0) { // oddæˆ–cntä¸º1ï¼Œevenå¤§äº0, å–even goto do_even; } else if(odd_index &lt; 0 &amp;&amp; even_index &gt;= 0 &amp;&amp; cnt &gt; 1) { // oddä¸º0ï¼Œevenä¸ä¸º0ï¼Œcntå¤§äº1ï¼Œå–even goto do_even; } else if(even_index == 0 &amp;&amp; odd_index &gt;= 1 &amp;&amp; cnt &gt;= 2) { if(cnt == 2) { goto do_odd; } else if(even[even_index] &gt; odd[odd_index] + odd[odd_index - 1]) { goto do_even; } else { goto do_odd; } } else if(even_index &lt; 0 &amp;&amp; odd_index &gt;= 1 &amp;&amp; cnt &gt;= 2) { goto do_odd; } break; } do_odd: score += odd[odd_index] + odd[odd_index - 1]; cnt -= 2; odd_index -= 2; goto next; do2_even: score += even[even_index] + even[even_index - 1]; cnt -= 2; even_index -= 2; goto next; do_even: score += even[even_index]; cnt -= 1; even_index -= 1; next: } return cnt == 0 ? score : 0; }}; å…ˆæ’åºï¼Œç„¶åæŒ‰ç…§å¥‡å¶æ€§åˆ†æˆä¸¤ä¸ªæ•°ç»„ è´ªå¿ƒï¼Œæ¯æ¬¡ä»å¥‡æ•°æ•°ç»„ä¸­å–å‡ºä¸¤ä¸ªå¥‡æ•°ï¼Œæˆ–è€…ä»å¶æ•°æ•°ç»„ä¸­å–æ•°ï¼Œç›´åˆ°å–å®Œæ•°ç»„ï¼Œæˆ–è€…å¥‡æ•°æ•°ç»„å‰©ä¸€ä¸ªï¼Œæˆ–è€…å–å¤Ÿäº†cntä¸ªæ•° å¦‚ä½•é€‰å–ï¼š ç”±äºå¥‡æ•°æ•°ç»„æ¯æ¬¡å–ä¸¤ä¸ªï¼Œå ç”¨ä¸¤ä¸ªcntèµ„æºï¼Œè€Œå¶æ•°æ•°ç»„å¯ä»¥å–ä¸€ä¸ªä¹Ÿå¯ä»¥å–ä¸¤ä¸ªï¼Œå¯¼è‡´å‰é¢çš„å–æ³•ä¼šå½±å“åç»­cntèƒ½å¦åˆšå¥½å–å¤Ÿã€‚ æ˜¯è¿ç»­å–ä¸¤ä¸ªå¶æ•°ï¼Œè¿˜æ˜¯å–ä¸¤ä¸ªå¥‡æ•°ï¼Œè¿˜æ˜¯åªå–ä¸€ä¸ªå¶æ•°ï¼Ÿ odd=[...,3,7], even=[...,12],ç”±äºå¶æ•°æ•°ç»„ä¸­12å¤§äºå¥‡æ•°æ•°ç»„çš„3+7ï¼Œæ‰€ä»¥å–12,(ä¸€ä¸ªå¶æ•°å®Œèƒœ) odd=[...,3,7], even=[...,6,6],è¿™æ¬¡6å°äº3+7,å¯æ˜¯è¿ç»­å–ä¸¤ä¸ª6çš„å¾—åˆ†å¤§äº3+7ï¼Œæ‰€ä»¥å–6+6ã€‚(ä¸¤ä¸ªå¥‡æ•°æ‹‰ä½äº†å¹³å‡å€¼) odd=[...,3,7], even=[...,2,6],è¿™æ¬¡6å°äº3+7ï¼Œè¿ç»­ä¸¤æ¬¡éƒ½é€‰æ‹©å¶æ•°2+6ä¹Ÿæ¯”é€‰æ‹©3+7ä¸¤ä¸ªå¥‡æ•°å°ï¼Œæ‰€ä»¥é€‰ä¸¤ä¸ªå¥‡æ•° ä»¥ä¸Šé€‰å–ç­–ç•¥éœ€è¦len(odd) &gt;= 2 and len(even) &gt;= 2 and ret &gt;= 2 ä¸‹é¢è®¨è®ºä¸æ»¡è¶³ä»¥ä¸Šæƒ…å†µï¼Œä¹Ÿå°±æ˜¯len(odd),len(even),retä¸ä¼šåŒæ—¶å¤§äºç­‰äº2çš„æƒ…å†µ ç”±äºå¯èƒ½çš„æƒ…å†µå¤ªå¤šå¤ªå¤æ‚ï¼Œåˆ—è¡¨è®¨è®º 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*odd even cnt do// oddæˆ–cntä¸º1ï¼Œevenå¤§äº0,åªèƒ½å–even2+ 2+ 1 even2 2+ 1 even1 2+ 2+ even1 2+ 2 even1 2+ 1 even0 2+ 1 even2+ 2 1 even2 2 1 even1 2 2+ even1 2 2 even1 2 1 even0 2 1 even2+ 1 1 even2 1 1 even1 1 2+ even1 1 2 even1 1 1 even0 1 1 even// oddä¸º0ï¼Œevenä¸ä¸º0ï¼Œcntå¤§äº1ï¼Œå–even0 2+ 2+ even0 2+ 2 even0 2 2+ even0 2 2 even0 1 2+ even0 1 2 even// evenåªå‰©ä¸€ä¸ª, cntå‰©ä¸¤ä¸ªï¼Œä¸èƒ½å–evenï¼Œoddå¤§äºç­‰äº2ä¸ªï¼Œå–odd2+ 1 2 odd2 1 2 odd// evenåªå‰©ä¸€ä¸ª, cntå¤§äºä¸¤ä¸ªï¼Œå¯ä»¥å–evenï¼Œä½†éœ€è¦å’Œoddæ¯”è¾ƒ2+ 1 2+ even, odd1+odd2æ¯”è¾ƒ2 1 2+ even, odd1+odd2æ¯”è¾ƒ// evenç”¨å®Œäº†, oddè¿˜æœ‰ä¸¤ä¸ªä»¥ä¸Š, å–odd2+ 0 2+ odd2+ 0 2 odd2 0 2+ odd2 0 2 odd// even,oddéƒ½å–å®Œäº†ï¼Œæ— æ³•å–å¤Ÿcntï¼Œbreak0 0 2+ break0 0 2 break// cntæˆ–oddä¸º1ï¼Œæ²¡æœ‰evenå¯å–ï¼Œæ— æ³•æ»¡è¶³æ¡ä»¶ï¼Œbreak2+ 0 1 break2 0 1 break1 0 2+ break1 0 2 break1 0 1 break0 0 1 break*/ 2+ä»£è¡¨ä¸ªæ•°å¤§äº2 æ’åº1234567891011121314151617181920212223242526272829303132class Solution {public: int maximumScore(vector&lt;int&gt;&amp; cards, int cnt) { int odd = -1, even = -1; int tmp = 0; int n = cards.size(); sort(cards.begin(), cards.end()); for(int i = n - 1; i &gt; n - cnt - 1; i--) { ((cards[i] &amp; 1) ? odd : even) = cards[i]; tmp += cards[i]; cout &lt;&lt; cards[i] &lt;&lt; endl; } if(!(tmp &amp; 1)) return tmp; bool flag = false; int ans = 0; for(int i = n - cnt - 1; i &gt;= 0; i--) { if(cards[i] &amp; 1) { if(even != -1) { flag = true; ans = max(ans, tmp - even + cards[i]); } } else { if(odd != -1) { ans = max(ans, tmp - odd + cards[i]); flag = true; } } } return ans; }}; æ’åºåå‰cntä¸ªæ•°åŠ èµ·æ¥ï¼Œå¦‚æœæ˜¯å¶æ•°ï¼Œåˆ™æ˜¯æ‰€æ±‚æœ€å¤§çš„æƒ…å†µï¼Œç›´æ¥è¿”å› å¦åˆ™ï¼Œå‰cntä¸ªå’ŒåŠ èµ·æ¥æ˜¯å¥‡æ•°ï¼Œç”¨åé¢çš„æ•°æ›¿æ¢å‰é¢çš„æ•°ï¼Œä½¿å’Œå˜æˆå¶æ•° å¦‚æœåé¢çš„æ•°æ˜¯å¥‡æ•°ï¼Œåˆ™å‡å»æœ€åä¸€ä¸ªå¶æ•°ï¼Œè¿™æ ·å’Œä¸ºå¶æ•° å¦‚æœåé¢çš„æ•°æ˜¯å¶æ•°ï¼Œåˆ™å‡å»æœ€åä¸€ä¸ªå¥‡æ•°ï¼Œè¿™æ ·å’Œä¸ºå¥‡æ•° å“ˆå¸Œå’Œä¸Šä¸€ä¸ªæƒ³æ³•æ€è·¯ä¸€è‡´ï¼Œ1&lt;=cards[i]&lt;=1000ï¼Œå¯ä»¥æŠŠä»–æ˜ å°„åˆ°ä¸€ä¸ªé•¿åº¦1000çš„æ•°ç»„ä¸­ï¼Œè®°å½•ä¸‹æ ‡æ—©cardsä¸­å‡ºç°çš„æ¬¡æ•°ï¼Œå¯ä»¥é¿å…æ’åºã€‚ 123456789101112131415161718192021222324252627282930313233class Solution {public: int maximumScore(vector&lt;int&gt;&amp; cards, int cnt) { int hash[1001] = {0}; int n = cards.size(); for(int i = 0; i &lt; n; i++) { hash[cards[i]]++; } int i = 1000; int tmp = 0; int odd = -1, even = -1; for(int j = 0; j &lt; cnt &amp;&amp; i &gt; 0; j++) { while(i &gt; 0 &amp;&amp; hash[i] == 0) i--; if(i == 0) break; // will never happen tmp += i; hash[i]--; ((i &amp; 1) ? odd : even) = i; } if(!(tmp &amp; 1)) return tmp; int ans = 0; while(i &gt; 0) { while(i &gt; 0 &amp;&amp; hash[i] == 0) i--; if(i == 0) break; if((i &amp; 1) == 1 &amp;&amp; even != -1) { ans = max(ans, tmp - even + i); } else if((i &amp; 1) == 0 &amp;&amp; odd != -1) { ans = max(ans, tmp - odd + i); } hash[i]--; } return ans; }}; 3111. è¦†ç›–æ‰€æœ‰ç‚¹çš„æœ€å°‘çŸ©å½¢æ•°ç›®1234567891011121314151617class Solution {public: int minRectanglesToCoverPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, int w) { sort(points.begin(), points.end(), [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b){ return a[0] &lt; b[0]; }); int len = points.size(); int i = 1; int cnt = 1; int lastx = points[0][0]; while(i &lt; len) { while(i &lt; len &amp;&amp; points[i][0] - lastx &lt;= w) i++; if(i &gt;= len) break; cnt++; lastx = points[i][0]; } return cnt; }}; å•Š?è¿™æ˜¯ä¸­ç­‰é¢˜å— 3007. ä»·å€¼å’Œå°äºç­‰äº K çš„æœ€å¤§æ•°å­—å…¬å¼æ³•1234567891011121314151617181920212223242526272829class Solution { long long accumulatedValueOf(long long k, int x) { long long value = 0; for(int mask_off = 63; mask_off &gt;= 1; mask_off--) { long long mask = 1l &lt;&lt; (mask_off - 1); if(!(mask &amp; k)) continue; k = k &amp; ~mask; if(mask_off % x == 0) { value += ((k|mask) - mask + 1); } value += mask / 2 * ((mask_off - 1) / x); } return value; }public: long long findMaximumNumber(long long k, int x) { long long l = 1, r = 1e15; while(l &lt; r) { long long mid = (r - l + 1) / 2 + l; long long accuValue = accumulatedValueOf(mid, x); if(accuValue &lt;= k) { l = mid; } else { r = mid - 1; } } return l; }}; æ€è·¯ è®°$ price_n(x) = bit_count(n, x) $ è®°$ accumulated_n(x) = \\sum_{i=1}^nprice_i(x) $ bit_count, priceæ˜¯nçš„ä»·å€¼ï¼Œä¹Ÿå°±æ˜¯ä¸‹æ ‡è¢«xæ•´é™¤çš„ä½æ•°å’Œ å¯¹äºn&gt;0, å‡½æ•°bit_count, æ˜¯æ’å¤§äºé›¶çš„ã€‚ æ‰€ä»¥æ•°åˆ—$ {accumulated_n(x)} $æ˜¯å•è°ƒé€’å¢çš„ï¼Œå¦‚æœèƒ½æ‰¾åˆ°è®¡ç®—$ {accumulated_n(x)} $çš„å…¬å¼ï¼Œåˆ©ç”¨äºŒåˆ†æŸ¥æ‰¾å³å¯å¿«é€Ÿæ‰¾åˆ°ç­”æ¡ˆ å…¬å¼æ¨å¯¼ ä»¥n = 7, x = 1ä¸ºä¾‹ 1234567800000001001000110100010101100111 å¯ä»¥è§‚å¯Ÿåˆ°0 + 7 = 1 + 6 = 2 + 5 = 3 + 4 = äºŒè¿›åˆ¶çš„111æ€»ä»·å€¼ä¸º: 3*4=12 ä¹Ÿå°±æ˜¯å¯¹äº$ n = 0 â€¦ (2^i-1) $æ—¶ï¼Œä»–ä»¬çš„æ€»ä»·å€¼ä¸º$ i * 2^{i-1} $ $ a_{2^i}(1) = i * 2^{i-1}$ ä»¥n = 10, x = 1ä¸ºä¾‹ 123456789101100000001001000110100010101100111100010011010 å…ˆè®¡ç®—n = 0...7çš„æ€»ä»·å€¼ï¼Œä¸º12$ a_{2^i-1}(1) = i * 2^{i-1}$, $i = 3$çš„æƒ…å†µ ç»„æˆéƒ¨åˆ†ä¸ºn = 0...7å’Œn = 8...10 å¯¹äºn = 8...10å…ˆæ•°å‡ºæœ€é«˜ä½çš„æƒ…å†µï¼Œä¹Ÿå°±æ˜¯$n - (2^i - 1)$ï¼Œå†å»æ‰æœ€é«˜ä½ï¼Œå˜æˆä»¥ä¸‹æƒ…å†µ 123000110 ä¹Ÿå°±æ˜¯n = 2, x = 1çš„æƒ…å†µï¼Œé‡å¤ä¸Šé¢çš„æ“ä½œä¹Ÿå°±æ˜¯ $ b_n(i) = n%2^{i+1} - (2^i - 1) $ å¯¹äºæ›´å¤æ‚çš„æƒ…å†µå¦‚: n = 1001101, x = 1æ€»ä»·å€¼ä¸º$ a_{2^6-1}(1) + b_n(6) + $$ a_{2^3-1}(1) + b_n(3) + $$ a_{2^2-1}(1) + b_n(2) + $$ a_{2^0-1}(1) + b_n{0}$ å¯¹äºx != 1çš„æƒ…å†µï¼Œä¹Ÿå°±æ˜¯$ a_{2^i}(x) = \\lfloor\\frac{i}{x}\\rfloor * 2^{i-1}$$ b_n(i, x) = n%2^{i+1} - (2^i - 1) $ $(i % x = 0)$$ b_n(i, x) = 0 $ $(i % x \\not ={0})$ 2961. åŒæ¨¡å¹‚è¿ç®—å¿«é€Ÿå¹‚ç§’äº†ï¼ 1234567891011121314151617181920212223242526class Solution { int fastPow(int a, int n, int mod) { int res = 1; while(n) { if(n&amp;1) { res = (res * a) % mod; } a = (a * a) % mod; n &gt;&gt;= 1; } return res; }public: vector&lt;int&gt; getGoodIndices(vector&lt;vector&lt;int&gt;&gt;&amp; variables, int target) { vector&lt;int&gt; goodIndices; int len = variables.size(); for(int i = 0; i &lt; len; i++) { int n = fastPow(variables[i][0], variables[i][1], 10); n = fastPow(n, variables[i][2], variables[i][3]); if(n == target) { goodIndices.push_back(i); } } return goodIndices; }}; 682. æ£’çƒæ¯”èµ›12345678910111213141516171819202122232425class Solution {public: int calPoints(vector&lt;string&gt;&amp; operations) { int n = operations.size(); vector&lt;int&gt; scores; int scoreCnt = 0; for(int i = 0; i &lt; n; i++) { int score = 0; if (operations[i] == &quot;+&quot;) { score = scores[scoreCnt - 1] + scores[scoreCnt - 2]; } else if (operations[i] == &quot;D&quot;) { score = scores[scoreCnt - 1] * 2; } else if (operations[i] == &quot;C&quot;) { scores.pop_back(); scoreCnt--; continue; } else { sscanf(operations[i].c_str(), &quot;%d&quot;, &amp;score); } scores.push_back(score); scoreCnt++; } return accumulate(scores.begin(), scores.end(), 0); }}; 3106. æ»¡è¶³è·ç¦»çº¦æŸä¸”å­—å…¸åºæœ€å°çš„å­—ç¬¦ä¸²12345678910111213141516171819202122232425class Solution { public: int charDistance(char a, char b) { int d = abs(a - b); return min(d, 26 - d); }public: string getSmallestString(string s, int k) { int n = s.length(); for(int i = 0; i &lt; n &amp;&amp; k &gt; 0; i++) { int target = 'z'; if(k &gt; 12) { target = 'a'; } else { for(int j = 0; j &lt;= k; j++) { target = min(target, (s[i] + j - 'a') % 26 + 'a'); target = min(target, (s[i] - j - 'a' + 26) % 26 + 'a'); } } k -= charDistance(s[i], target); s[i] = target; } return s; }}; å®é™…ä¸Šå°±æ˜¯26è¿›åˆ¶æ•°ï¼Œåœ¨æœ‰é™æ­¥éª¤å†…ï¼Œå°†å…¶è½¬åŒ–ä¸ºåŒä½æ•°ä¸‹å°½é‡å°çš„æ•° å°½é‡å¤šçš„å°†å½“å‰æœ€é«˜ä½å˜å°ï¼Œé«˜ä½ä½¿ç”¨1æ­¥çš„å‡å°‘é‡æ˜¯åœ°ä½ä½¿ç”¨ä¸€æ­¥çš„26å€ ç®€å•è®¡ç®—å¯çŸ¥ï¼Œä¸¤ä¸ªå­—æ¯æœ€å¤§è·ç¦»ä¸º12 å½“k &gt; 12æ—¶ï¼Œä¸€å®šå¯ä»¥å˜æˆa å½“k &lt;= 12æ—¶ï¼Œä¸€å®šå¯ä»¥å˜æˆaï¼Œå¯»æ‰¾kæ­¥å†…èƒ½å®ç°çš„æœ€å°å­—ç¬¦ 2740. æ‰¾å‡ºåˆ†åŒºå€¼123456789101112class Solution {public: int findValueOfPartition(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); int len = nums.size(); int minDiff = INT_MAX; for(int i = 1; i &lt; len; i++) { minDiff = min(minDiff, abs(nums[i] - nums[i-1])); } return minDiff; }}; 2844. ç”Ÿæˆç‰¹æ®Šæ•°å­—çš„æœ€å°‘æ“ä½œ12345678910111213141516171819202122232425262728class Solution {public: int minimumOperations(string num) { int len = num.length(); int first0 = len, first5 = len; int i = len - 1; int minOp = len; while(i &gt;= 0) { if(num[i] == '0' &amp;&amp; first0 == len) { first0 = i; } else if(num[i] == '5' &amp;&amp; first5 == len) { first5 = i; } if(num[i] == '0' &amp;&amp; first0 != len &amp;&amp; i &lt; first0) { minOp = min(minOp, len - first0 - 1 + first0 - i - 1); } else if(num[i] == '2' &amp;&amp; first5 != len &amp;&amp; i &lt; first5) { minOp = min(minOp, len - first5 - 1 + first5 - i - 1); } else if(num[i] == '5' &amp;&amp; first0 != len &amp;&amp; i &lt; first0) { minOp = min(minOp, len - first0 - 1 + first0 - i - 1); } else if(num[i] == '7' &amp;&amp; first5 != len &amp;&amp; i &lt; first5) { minOp = min(minOp, len - first5 - 1 + first5 - i - 1); } i--; } if(first0 != len) minOp = min(minOp, len - 1); return minOp; }}; å¯¹äºæ‰€æœ‰25çš„å€æ•°ï¼Œä¸¾ä¾‹å¯çŸ¥ï¼Œç»“å°¾ä¸¤ä½ä¸º00,25,50,75 ä¸€ä¸ªå­—ç¬¦ä¸²å¯èƒ½æœ‰å¤šç§æ–¹å¼åˆ°è¾¾å˜æˆ25çš„å€æ•° å¦‚æœæœ€åä»¥00ç»“å°¾ï¼Œå…ˆå€’ç€æ‰¾åˆ°ç¬¬ä¸€ä¸ª0ï¼Œåˆ å»åé¢çš„æ‰€æœ‰æ•°ï¼Œåœ¨æ‰¾ç¬¬äºŒä¸ª0ï¼Œåˆ æ‰ä¸¤ä¸ª0ä¸­é—´çš„æ•° 25,50,75åŒç† è¿”å›åˆ é™¤æ•°å­—æœ€å°‘çš„æƒ…å†µ ç‰¹æ®Šæƒ…å†µ æ²¡æœ‰æ‰¾åˆ°00,25,50,75ï¼Œå¯ä»¥æŠŠæ•´ä¸ªå­—ç¬¦ä¸²åˆ æ‰ æ²¡æœ‰æ‰¾åˆ°00,25,50,75ï¼Œåªæ‰¾åˆ°äº†ä¸€ä¸ª0ï¼Œå¯ä»¥æŠŠ0ä»¥å¤–çš„æ•°å…¨åˆ æ‰ 2766. é‡æ–°æ”¾ç½®çŸ³å—123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; relocateMarbles(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; moveFrom, vector&lt;int&gt;&amp; moveTo) { unordered_map&lt;int, bool&gt; pos2rock; for(int rockPos : nums) { pos2rock[rockPos] = true; } int opNum = moveFrom.size(); for(int i = 0; i &lt; opNum; i++) { if(moveTo[i] == moveFrom[i]) continue; pos2rock[moveTo[i]] = true; // pos2rock[moveFrom[i]] = 0; pos2rock.erase(moveFrom[i]); } vector&lt;int&gt; res; for(const auto&amp; [pos, num] : pos2rock) { // if(num) { // ä¸éœ€è¦åˆ¤æ–­ï¼Œéƒ½æ˜¯true res.push_back(pos); // } } sort(res.begin(), res.end()); return res; }}; 2101. å¼•çˆ†æœ€å¤šçš„ç‚¸å¼¹1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution { class Solve { unordered_map&lt;int, vector&lt;int&gt;&gt; graph; vector&lt;vector&lt;int&gt;&gt;&amp; bombs; int bombsNum; int isICanBoomJ(int i, int j) { return ((long long)bombs[i][0] - bombs[j][0]) * (bombs[i][0] - bombs[j][0]) + ((long long)bombs[i][1] - bombs[j][1]) * (bombs[i][1] - bombs[j][1]) &lt;= (long long)bombs[i][2] * bombs[i][2]; } int cntNodes(int start) { vector&lt;bool&gt; visited = vector&lt;bool&gt;(bombsNum, false); return cntNodes(start, visited); } int cntNodes(int start, vector&lt;bool&gt;&amp; visited) { visited[start] = true; int child = 0; for(int subNode : graph[start]) { if(!visited[subNode]) { visited[subNode] = true; child += cntNodes(subNode, visited); } } return 1+child; } public: Solve(vector&lt;vector&lt;int&gt;&gt;&amp; bombs) : bombs(bombs), bombsNum(bombs.size()) {} int solve() { for(int i = 0; i &lt; bombsNum; i++) { for(int j = 0; j &lt; bombsNum; j++) { if(i == j) continue; if(isICanBoomJ(i, j)) { graph[i].push_back(j); } } } int maxBoom = INT_MIN; for(int i = 0; i &lt; bombsNum; i++) { maxBoom = max(maxBoom, cntNodes(i)); } return maxBoom; } };public: int maximumDetonation(vector&lt;vector&lt;int&gt;&gt;&amp; bombs) { return Solve(bombs).solve(); }}; 1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: int maximumDetonation(vector&lt;vector&lt;int&gt;&gt;&amp; bombs) { int bombsNum = bombs.size(); auto isICanBoomJ = [&amp;](int i, int j) { return ((long long)bombs[i][0] - bombs[j][0]) * (bombs[i][0] - bombs[j][0]) + ((long long)bombs[i][1] - bombs[j][1]) * (bombs[i][1] - bombs[j][1]) &lt;= (long long)bombs[i][2] * bombs[i][2]; }; unordered_map&lt;int, vector&lt;int&gt;&gt; graph; function&lt;int(int, vector&lt;bool&gt;&amp;)&gt; _cntNodes = [&amp;](int start, vector&lt;bool&gt;&amp; visited) { visited[start] = true; int child = 0; for(int subNode : graph[start]) { if(!visited[subNode]) { visited[subNode] = true; child += _cntNodes(subNode, visited); } } return 1+child; }; auto cntNodes = [&amp;](int start) { vector&lt;bool&gt; visited = vector&lt;bool&gt;(bombsNum, false); return _cntNodes(start, visited); }; for(int i = 0; i &lt; bombsNum; i++) { for(int j = 0; j &lt; bombsNum; j++) { if(i == j) continue; if(isICanBoomJ(i, j)) { graph[i].push_back(j); } } } int maxBoom = INT_MIN; for(int i = 0; i &lt; bombsNum; i++) { maxBoom = max(maxBoom, cntNodes(i)); } return maxBoom; }}; æ³¨æ„è®¡ç®—è·ç¦»æ—¶intå¯èƒ½ä¼šæº¢å‡º 1186. åˆ é™¤ä¸€æ¬¡å¾—åˆ°å­æ•°ç»„æœ€å¤§å’Œ3133. æ•°ç»„æœ€åä¸€ä¸ªå…ƒç´ çš„æœ€å°å€¼123456789101112131415161718192021222324252627282930313233class Solution {public: long long minEnd(int n, int x) { long long res = 0; int mask_n = 1; int mask_x = 1; long long mask_res = 1l; n--; while(mask_n &lt; 0x8000'0000 &amp;&amp; mask_x &lt; 0x8000'0000) { if(x &amp; mask_x) { res |= mask_res; } else { if(n &amp; mask_n) res |= mask_res; mask_n &lt;&lt;= 1; } mask_res &lt;&lt;= 1; mask_x &lt;&lt;= 1; } while(mask_n &lt; 0x8000'0000) { if(n &amp; mask_n) res |= mask_res; mask_res &lt;&lt;= 1; mask_n &lt;&lt;= 1; } while(mask_x &lt; 0x8000'0000) { if(x &amp; mask_x) { res |= mask_res; } mask_res &lt;&lt;= 1; mask_x &lt;&lt;= 1; } return res; }}; æ€è·¯é¦–å…ˆæ‰€æœ‰çš„æ•°ç›¸ä¸åçš„ç»“æœéœ€è¦ä¸ºx,å…ˆéšä¾¿æ¥ä¸€ä¸ªäºŒè¿›åˆ¶æ•°ï¼Œçœ‹çœ‹æ»¡è¶³è¿™æ ·çš„æ•°æœ‰ä»€ä¹ˆè§„å¾‹ ä»¥x = 001101101001ä¸ºä¾‹ å¯¹äºæ•°ç»„ä¸­çš„äºŒè¿›åˆ¶æ•°ï¼Œå¦‚æœxçš„ç¬¬iä½ä¸º0ï¼Œåˆ™å¯¹åº”æ•°ç»„ä¸­çš„æ•°çš„ç¬¬iä½å¯ä»¥æ˜¯0ä¹Ÿå¯ä»¥æ˜¯1ï¼›å¦‚æœæœxçš„ç¬¬iä½ä¸º1ï¼Œåˆ™å¯¹åº”æ•°ç»„ä¸­çš„æ•°çš„ç¬¬iä½å¿…é¡»æ˜¯1 ä¹Ÿå°±æ˜¯æ•°ç»„ä¸­çš„æ•°æ»¡è¶³ $ a_i = ??11?11?1??1 $ ç°åœ¨å¸Œæœ›æ•°ç»„ä¸­æœ‰nä¸ªæ•° ä»¥n = 9 = 000000001001ä¸ºä¾‹ï¼Œå…ˆä¸ç®¡ç›¸ä¸ä¸ºxçš„é™åˆ¶ï¼Œæ•°ç»„ä¸­çš„æ•°å¯ä»¥æ˜¯ 123456789000100100011010001010110011110001001 å‰é¢æåˆ°æ•°ç»„ä¸­çš„æ•°å¿…é¡»æ»¡è¶³$ a_i = ??11?11?1??1 $, å¯ä»¥æŠŠè¿™äº›æ•°å®‰æ’åˆ°?å¤„ï¼Œè¿™æ ·å¯ä»¥ä¿è¯ç›¸ä¸ä¸ºxï¼Œä¹Ÿå¯ä»¥ä¿è¯æ•°ç›®é‚£ä¹ˆæ•°ç»„ä¸­æœ€å¤§æ•°9ï¼ŒæŠŠä»–å¡«å…¥?å¤„å¯å¾—:001111101011é‚£ä¹ˆæ•°ç»„ä¸­æœ€å°æ•°1ï¼ŒæŠŠä»–å¡«å…¥?å¤„å¯å¾—:001101101011 è€ƒè™‘åˆ°x&amp;x = x, æ‰€ä»¥æ•°ç»„ä¸­æœ€å°æ•°å¯ä»¥æ˜¯0ï¼Œæ‰€ä»¥å¯¹äºx = 001101101001, n = 9 = 000000001001, æ•°ç»„ä¸­æœ€å°æ•°ä¸ºxï¼Œæœ€å¤§æ•°ä¸ºå°†8å¡«å…¥?å¤„ï¼Œå¾—001111101001 2850. å°†çŸ³å¤´åˆ†æ•£åˆ°ç½‘æ ¼å›¾çš„æœ€å°‘ç§»åŠ¨æ¬¡æ•°æš´åŠ›åˆ†å­123456789101112131415161718192021222324252627282930313233343536373839class Solution { int minMove = INT_MAX; void move(vector&lt;vector&lt;int&gt;&gt; grid, int moveCnt) { bool flag = true; int minDist = INT_MAX; for(int i = 0; i &lt; 9; i++) { if(grid[i/3][i%3] &lt;= 1) continue; for(int j = 0; j &lt; 9; j++) { if(i == j) continue; if(grid[j/3][j%3] == 0) { flag = false; minDist = min(minDist, abs(i/3 - j/3) + abs(i%3 - j%3)); } } } if(flag) { minMove = min(minMove, moveCnt); return; } for(int i = 0; i &lt; 9; i++) { if(grid[i/3][i%3] &lt;= 1) continue; for(int j = 0; j &lt; 9; j++) { if(i == j) continue; if(grid[j/3][j%3] == 0 &amp;&amp; abs(i/3 - j/3) + abs(i%3 - j%3) == minDist) { grid[j/3][j%3]++; grid[i/3][i%3]--; move(grid, moveCnt + abs(i/3 - j/3) + abs(i%3 - j%3)); grid[j/3][j%3]--; grid[i/3][i%3]++; } } } }public: int minimumMoves(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { move(grid, 0); return minMove; }}; ç¡¬æœ æšä¸¾123456789101112131415161718192021222324252627282930313233343536373839404142434445464748unordered_map&lt;long long, int&gt; m; // int64è¡¨ç¤ºçš„grid to åˆ°è¾¾ åˆå§‹çŠ¶æ€çš„æœ€å°æ­¥æ•°const long long initState = 0x00'00'00'01'11'11'11'11;static const int initMap = [](){ queue&lt;long long&gt; q; q.push(initState); m[initState] = 0; while(!q.empty()) { long long state = q.front(); int step = m[state]; q.pop(); for(int i = 0; i &lt; 9; i++) { int numI = (state &gt;&gt; (i &lt;&lt; 2)) &amp; 0x0f; if(numI != 1) continue; for(int j = 0; j &lt; 9; j++) { if(i == j) continue; long long numJ = (state &gt;&gt; (j &lt;&lt; 2)) &amp; 0x0f; if(numJ == 0) continue; int newStep = step + abs(i / 3 - j / 3) + abs(i % 3 - j % 3); numJ++; long long newState = state; newState = newState &amp; ~(0x0fl &lt;&lt; (i &lt;&lt; 2)); newState = newState &amp; ~(0x0fl &lt;&lt; (j &lt;&lt; 2)); newState = newState | (numJ &lt;&lt; (j &lt;&lt; 2)); if(!m.count(newState) || m[newState] &gt; newStep) { q.push(newState); m[newState] = newStep; } } } } return 0;}();class Solution { long long grid2Int64(const vector&lt;vector&lt;int&gt;&gt;&amp; grid) { long long int64Grid = 0; for(int i = 0; i &lt; 3; i++) { for(int j = 0; j &lt; 3; j++) { int64Grid &lt;&lt;= 4; int64Grid += grid[i][j]; } } return int64Grid; }public: int minimumMoves(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { return m[grid2Int64(grid)]; }}; ç”¨longlongè¡¨ç¤ºgridï¼Œä»å…¨1çš„gridå¼€å§‹ï¼Œæ‰¾å‡ºæ‰€æœ‰gridæƒ…å†µï¼Œè®¡ç®—å‡ºä»–å˜æˆå…¨1çš„stepï¼Œç¼“å­˜èµ·æ¥ï¼Œç”¨çš„æ—¶å€™æŸ¥ å…¨æ’åˆ—1234567891011121314151617181920212223242526class Solution {public: int minimumMoves(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { vector&lt;int&gt; more, less; for(int i = 0; i &lt; 9; i++) { int num = grid[i / 3][i % 3]; if(num &gt; 1) { for(int j = 1; j &lt; num; j++) { more.push_back(i); } } else if(num == 0) { less.push_back(i); } } int len = more.size(); int minStep = INT_MAX; do { int step = 0; for(int i = 0; i &lt; len; i++) { step += abs(more[i] / 3 - less[i] / 3) + abs(more[i] % 3 - less[i] % 3); } minStep = min(minStep, step); } while(next_permutation(more.begin(), more.end())); return minStep; }}; æŠ„çš„é¢˜è§£ æ¯ä¸ªå¤§äº1çš„æ ¼å­æœ€åéƒ½ä¼šå˜æˆ1ï¼Œå¡«è¡¥åˆ°0ä¸Šï¼Œå¤§äº1çš„æ ¼å­çš„å€¼-1ä¹‹å’Œç­‰äº0çš„æ ¼å­æ•°é‡æ˜¯ç›¸ç­‰çš„ æ„é€ ä¸¤ä¸ªæ•°ç»„ï¼Œä¸€ä¸ªå­˜å…¨0çš„æ ¼å­ä¸‹æ ‡ï¼Œä¸€ä¸ªå°†å¤§äº1çš„æ ¼å­å­˜n-1æ¬¡ï¼Œä¸¤ä¸ªæ•°ç»„é•¿åº¦ä¸€è‡´ (more[i],less[i])è¡¨ç¤ºå°†iæ ¼å­ä¸Šçš„ä¸€å—çŸ³å¤´æ¬åˆ°lessä¸Šï¼Œåªè¦å¯¹moreè¿›è¡Œå…¨æ’åˆ—ï¼Œå°±å¯ä»¥æ‰¾å‡ºæ‰€æœ‰ç§»åŠ¨çš„æ–¹æ³•ï¼Œç„¶åç®—å‡ºæ‰€éœ€çš„æ€»æ­¥æ•°ï¼Œç„¶åç®—å‡ºæœ€å°æ­¥æ•° 3096. å¾—åˆ°æ›´å¤šåˆ†æ•°çš„æœ€å°‘å…³å¡æ•°ç›®åˆæ˜¯åšå¼ˆé—®é¢˜ï¼Œä¸ä¼š 3112. è®¿é—®æ¶ˆå¤±èŠ‚ç‚¹çš„æœ€å°‘æ—¶é—´123456789101112131415161718192021222324252627282930313233class Solution {public: vector&lt;int&gt; minimumTime(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;int&gt;&amp; disappear) { vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph(n); for(const auto&amp; edge : edges) { graph[edge[0]].emplace_back(edge[1], edge[2]); graph[edge[1]].emplace_back(edge[0], edge[2]); } vector&lt;int&gt; ans(n, INT_MAX / 2); auto cmp = [](const pair&lt;int, int&gt;&amp; i , const pair&lt;int, int&gt;&amp; j){ return i.second &gt; j.second; }; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(cmp)&gt; q(cmp); q.emplace(0, 0); ans[0] = 0; while(!q.empty()) { auto [min_index, len] = q.top(); q.pop(); if(len &gt; ans[min_index]) continue; for(auto [child, len] : graph[min_index]) { int newLen = ans[min_index] + len &gt;= disappear[child] ? INT_MAX / 2 : ans[min_index] + len; if(newLen &lt; ans[child] &amp;&amp; newLen &lt; INT_MAX / 2) { ans[child] = newLen; q.emplace(child, ans[child]); } } } for(int i = 0; i &lt; n; i++) { if(ans[i] &gt;= INT_MAX / 2) ans[i] = -1; } return ans; }}; å°±æ˜¯å¸¦é™åˆ¶çš„dijkstraï¼Œä½†æ˜¯å¾ˆå‘ ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´å¯èƒ½å­˜åœ¨å¤šä¸ªé•¿åº¦ä¸åŒçš„è¾¹ï¼Œæ˜¾ç„¶è¦é€‰æœ€å°çš„ï¼Œä½†ä¸èƒ½ç”¨n*nçš„vectorå­˜å›¾ï¼Œä¼šè¶…å†…å­˜ å¿…é¡»ç”¨ä¼˜å…ˆé˜Ÿåˆ—é€‰ç‚¹ï¼Œå¦åˆ™æ—¶é—´è¶… 3145. å¤§æ•°ç»„å…ƒç´ çš„ä¹˜ç§¯1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283typedef unsigned long long uint64;class Solution { uint64 fastPower(uint64 a, uint64 n, uint64 mod) { uint64 res = 1; while(n) { if(n &amp; 1) { res = (res * a) % mod; } a = (a * a) % mod; n &gt;&gt;= 1; } return res % mod; } // å¿«é€Ÿå¹‚ uint64 powerOfproduct(uint64 k) { long long value = 0; for(int mask_off = 64; mask_off &gt;= 1; mask_off--) { uint64 mask = 1l &lt;&lt; (mask_off - 1); if(!(mask &amp; k)) continue; k = k &amp; ~mask; value += ((k|mask) - mask + 1) * (mask_off - 1); value += mask / 2 * ((mask_off - 1)*(mask_off - 2)/2); } return value; } // å°äºç­‰äºkçš„æ‰€æœ‰æ•°çš„æŒ‡æ•°å’Œ uint64 totalOneOf(uint64 k) { long long value = 0; for(int mask_off = 64; mask_off &gt;= 1; mask_off--) { uint64 mask = 1l &lt;&lt; (mask_off - 1); if(!(mask &amp; k)) continue; k = k &amp; ~mask; value += ((k|mask) - mask + 1); value += mask / 2 * (mask_off - 1); } return value; } // å°äºç­‰äºkçš„æ‰€æœ‰æ•°çš„1çš„ä¸ªæ•° uint64 findLeftRange(uint64 pos) { uint64 l = 0, r = pos; while(l &lt; r) { uint64 mid = (r - l + 1) / 2 + l; uint64 totalOnOfPos = totalOneOf(mid); if(totalOnOfPos &lt; pos) { l = mid; } else { r = mid - 1; } } return l; } // äºŒåˆ†æŸ¥æ‰¾ä¸‹æ ‡åœ¨æ•°ç»„ä¸­å¯¹åº”çš„æ•°çš„å‰ä¸€ä¸ªæ•° uint64 powerSumTo(uint64 k, uint64 pos) { uint64 powerSum = 0; int cnt = 0; for(int off = 0; off &lt; 64; off++) { uint64 mask = 1l &lt;&lt; off; if(k &amp; mask) { cnt++; if(cnt &lt;= pos) { powerSum += off; } else { break; } } } return powerSum; } // è®¡ç®—kçš„å‰posä¸ª1å¯¹åº”çš„æŒ‡æ•°å’Œpublic: vector&lt;int&gt; findProductsOfElements(vector&lt;vector&lt;long long&gt;&gt;&amp; queries) { vector&lt;int&gt; anwser; for(const auto&amp; query: queries) { uint64 leftRange0 = findLeftRange(query[0]+1) + 1; uint64 leftRange1 = findLeftRange(query[1]+1) + 1; uint64 totalOneOf0 = totalOneOf(leftRange0 - 1); uint64 totalOneOf1 = totalOneOf(leftRange1 - 1); uint64 powerSum0 = powerSumTo(leftRange0, query[0] - totalOneOf0); uint64 powerSum1 = powerSumTo(leftRange1, query[1]+1 - totalOneOf1); uint64 power = (powerOfproduct(leftRange1 - 1) - powerOfproduct(leftRange0 - 1) + powerSum1 - powerSum0); anwser.push_back(fastPower(2, power, query[2])); } return anwser; }}; ä½¿ç”¨å’Œ3007. ä»·å€¼å’Œå°äºç­‰äº K çš„æœ€å¤§æ•°å­—ç›¸åŒçš„æ€è·¯ï¼Œæ‰¾åˆ°O(1)çš„è®¡ç®—å°äºç­‰äºNçš„1çš„ä¸ªæ•° é€šè¿‡äºŒåˆ†æŸ¥æ‰¾å°±å¯ä»¥æ‰¾åˆ°big_numsä¸‹æ ‡å¯¹åº”çš„æ•°ï¼Œç”±äºæ‰€æ±‚æ•°æ˜¯2çš„å¹‚çš„ç§¯ï¼Œæ‰€ä»¥å†è®¡ç®—è¿™ä¸ªæ•°ä¹‹å‰çš„æ‰€æœ‰æ•°çš„ä¹˜ç§¯çš„æŒ‡æ•°ï¼Œä¸¤ä¸ªæŒ‡æ•°ç›¸å‡ï¼Œå†æ¨¡nå¿«é€Ÿå¹‚å³å¯æ±‚å¾—æœ€ç»ˆç­”æ¡ˆ 2956. æ‰¾åˆ°ä¸¤ä¸ªæ•°ç»„ä¸­çš„å…¬å…±å…ƒç´ 12345678910111213141516171819202122class Solution {public: vector&lt;int&gt; findIntersectionValues(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { int ans1 = 0, ans2 = 0; unordered_map&lt;int, int&gt; m1, m2; for(int num1 : nums1) { m1[num1]++; } for(int num2 : nums2) { if(m1.count(num2)) { ans2++; } m2[num2]++; } for(int num1 : nums1) { if(m2.count(num1)) { ans1++; } } return {ans1, ans2}; }};","link":"/home/2024/08/18/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9336/"},{"title":"LeetCode-9","text":"92. åè½¬é“¾è¡¨ IIæ€è·¯ ä¸¤ä¸ªæŒ‡é’ˆaã€bï¼Œåˆ†åˆ«æ‰¾åˆ°è¢«åè½¬çš„ç¬¬ä¸€ä¸ªç»“ç‚¹çš„å‰ä¸€ä¸ªç»“ç‚¹ï¼Œè¢«åè½¬çš„ç»“ç‚¹çš„æœ€åä¸€ä¸ªç»“ç‚¹ï¼Œï¼ˆåœ¨å¼€å¤´è®¾ç½®ä¸€ä¸ªå“‘ç»“ç‚¹ï¼Œé˜²æ­¢è¢«åè½¬çš„ç¬¬ä¸€ä¸ªç»“ç‚¹æ˜¯å¤´ç»“ç‚¹ï¼‰ å†æ¥ä¸€ä¸ªæŒ‡é’ˆcï¼Œä¿å­˜è¢«åè½¬çš„æœ€åä¸€ä¸ªç»“ç‚¹çš„nextï¼Œç„¶åæŠŠæœ€åä¸€ä¸ªç»“ç‚¹çš„nextè®¾ä¸ºnull åè½¬é“¾è¡¨ï¼Œç„¶åæŠŠæ–°é“¾è¡¨çš„headæ¥å›å»ï¼ŒæŠŠcæ¥å›åˆ°æœ«å°¾ è¿”å›å“‘ç»“ç‚¹çš„nextï¼Œä¸èƒ½è¿”å›headï¼Œå› ä¸ºåè½¬ä»¥åï¼Œheadæœ‰å¯èƒ½ä¸æ˜¯headäº† ACä»£ç 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseBetween(ListNode* head, int m, int n) { ListNode* dummy = new ListNode(0), *a, *b, *c; dummy-&gt;next = head; a = b = c = dummy; for (int i = 0; i &lt; m - 1; i++) { a = a-&gt;next; b = b-&gt;next; } for (int i = 0; i &lt; n - m + 1; i++) { b = b-&gt;next; } c = b-&gt;next; b-&gt;next = NULL; a-&gt;next = reverseList(a-&gt;next); while (a-&gt;next != NULL) { a = a-&gt;next; } a-&gt;next = c; return dummy-&gt;next; } ListNode* reverseList(ListNode* head) { if (head == NULL || head-&gt;next == NULL) return head; ListNode *temp = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return temp; }}; 15. ä¸‰æ•°ä¹‹å’Œæ€è·¯ éå†æ•°ç»„ï¼Œå–æ¯ä¸ªå€¼çš„ç›¸åæ•°ä½œä¸ºtargetï¼Œç„¶åè½¬åŒ–ä¸ºä¸¤æ•°ä¹‹å’Œçš„é—®é¢˜ï¼Œå»é‡æ—¶è¦æ³¨æ„ ä¿è¯targetåªæŸ¥æ‰¾ä¸€æ¬¡ ä¿è¯ç¬¬äºŒä¸ªå¾ªç¯j = i + 1å¼€å§‹ ä¿è¯æŸ¥æ‰¾åˆ°çš„æ•°çš„ä¸‹æ ‡ c &gt; j ä¿è¯ç¬¬äºŒæ¬¡å¾ªç¯çš„ç›¸åŒå…ƒç´ å¯¹åº”çš„å€¼ä¸ä¼šè¢«åå¤æŸ¥æ‰¾ï¼Œå³å˜é‡find ACä»£ç 1234567891011121314151617181920212223242526272829303132class Solution {public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); int len = nums.size(); vector&lt;vector&lt;int&gt;&gt; ans; map&lt;int, int&gt; m; for (int i = 0; i &lt; len; i++) { m[nums[i]] = i + 1; } for (int i = 0; i &lt; len; ) { int target = -nums[i]; for (int j = i + 1; j &lt; len;) { int find = target - nums[j]; if (m.count(find)) { int c = m[find] - 1; //cout &lt;&lt; nums[i] &lt;&lt; nums[j] &lt;&lt; nums[c] &lt;&lt; endl; if (c &gt; j) { ans.push_back({nums[i], nums[j], nums[c]}); } } while (j &lt; len &amp;&amp; nums[j] == target - find) { j++; } } while (i &lt; len &amp;&amp; nums[i] == -target) { i++; } } return ans; }}; å¤§ä½¬æ€è·¯äºŒåˆ†æŸ¥æ‰¾å¤§ä½¬ä»£ç 123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { set&lt;vector&lt;int&gt;&gt; ans; if(nums.size()&lt;3)return vector&lt;vector&lt;int&gt;&gt;(ans.begin(),ans.end()); sort(nums.begin(),nums.end()); int left,right,target; for(int i=0;i&lt;nums.size()-2;++i){ if(nums[i] &gt; 0) { break; } if(nums[i] == nums[i - 1] &amp;&amp; i &gt; 0) continue; left=i+1,right=nums.size()-1,target=-nums[i]; while(left&lt;right){ if(nums[left]+nums[right]==target){ ans.insert({nums[i], nums[left], nums[right]}); ++left; --right; }else if(nums[left]+nums[right]&gt;target){ --right; }else { ++left; } } } return vector&lt;vector&lt;int&gt;&gt;(ans.begin(),ans.end()); }}; 43. å­—ç¬¦ä¸²ç›¸ä¹˜æ€è·¯ä¸¤å±‚forå¾ªç¯ç›¸ä¹˜ï¼ŒæŠŠç›¸ä¹˜çš„ç»“æœå…¨éƒ½åŠ èµ·æ¥ ACä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution {public: string multiply(string num1, string num2) { int len1 = num1.length(), len2 = num2.length(); int len = len1 &gt; len2 ? len1 : len2; string zero(len - len1, '0'); num1 = zero + num1; zero = string(len - len2, '0'); num2 = zero + num2; string ans = &quot;0&quot;; for (int i = len - 1; i &gt;= 0; i--) { string temp = num1; int carry = 0; zero = string(len - 1 - i, '0'); for (int j = len - 1; j &gt;= 0; j--) { temp[j] = ((num1[j] - '0')*(num2[i] - '0') + carry)%10+ '0'; carry = ((num1[j] - '0')*(num2[i] - '0') + carry)/10; } temp = string(1, carry + '0') + temp + zero; ans = addStrings(ans, temp); } int i = 0; while (ans[i] == '0') i++; len = ans.length(); return i == len ? &quot;0&quot; : ans.substr(i, len - i); } string addStrings(string&amp; num1, string&amp; num2) { int carry = 0; int len1 = num1.length(); int len2 = num2.length(); int len = len1 &gt; len2 ? len1 : len2; string zero = string(len - len1, '0'); num1 = zero + num1; zero = string(len - len2, '0'); num2 = zero + num2; for (int i = len - 1; i &gt;= 0; i--) { int n = carry + num1[i] + num2[i] - 2*'0'; num1[i] = n % 10 + '0'; carry = n / 10; } if (carry) num1.insert(0, 1, carry + '0'); return num1; }}; 73. çŸ©é˜µç½®é›¶æ€è·¯æƒ³å†™å‡ºæ¥å¾ˆç®€å•ï¼Œç›®å‰æ˜¯ç©ºé—´O(M+N)çš„ç®—æ³• ACä»£ç 12345678910111213141516171819202122232425class Solution {public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int r = matrix.size(), c = matrix[0].size(); unordered_map&lt;int, bool&gt; rows, cols; for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { if (matrix[i][j] == 0) { rows[i] = true; cols[j] = true; } } } for (auto x : rows) { for (int i = 0; i &lt; c; i++) { matrix[x.first][i] = 0; } } for (auto x : cols) { for (int i = 0; i &lt; r; i++) { matrix[i][x.first] = 0; } } }}; 60. ç¬¬kä¸ªæ’åˆ—æ€è·¯æ²¡ç ”ç©¶è¿™ä¸ªï¼Œstlç›´æ¥è°ƒç”¨ ACä»£ç 12345678910111213class Solution {public: string getPermutation(int n, int k) { string ans; for (int i = 1; i &lt;= n; i++) { ans += char(i + '0'); } for (int i = 0; i &lt; k - 1; i++) { next_permutation(ans.begin(), ans.end()); } return ans; }}; å¤§ä½¬ä»£ç 123456789101112131415161718192021222324252627282930static const auto io_sync_off = [](){ // turn off sync std::ios::sync_with_stdio(false); // untie in/out streams std::cin.tie(nullptr); return nullptr;}();class Solution {public: string recursive(int n, int k, int * order, string &amp;str) { if (n == 0) return &quot;&quot;; int num = (k - 1) / order[n - 1]; char c = str[num]; str.erase(str.begin() + num); return c + recursive(n - 1, k - num * order[n - 1], order, str); } string getPermutation(int n, int k) { int order[n + 1] = {1}; string str; for (int i = 1; i &lt; n + 1; i++) { order[i] = i * order[i - 1]; str.push_back(48 + i); } return recursive(n, k, order, str); }}; 34. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®æ€è·¯ä¸€æ¬¡äºŒåˆ†æŸ¥æ‰¾ï¼Œç„¶åå‘å‰å‘åéå†ï¼Œæ‰¾åˆ°å¼€å§‹å’Œç»“æŸï¼Œä½†æ˜¯æœ€åæƒ…å†µä¸‹ï¼Œç®—æ³•ä»$O(log_2n)$å˜æˆ$O(n)$ ACä»£ç 123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) { int len = nums.size(); if (!len) return {-1, -1}; int low = 0, high = len - 1; bool find = false; int pos = 0; while (low &lt;= high) { int mid = low + (high - low)/2; if (nums[mid] == target) { find = true; pos = mid; break; } else if (nums[mid] &gt; target) { high = mid - 1; } else { low = mid + 1; } } if (!find) { return {-1, -1}; } int beg , end; beg = end = pos; while (beg &gt;= 0 &amp;&amp; nums[pos] == nums[beg]) beg--; while (end &lt; len &amp;&amp; nums[pos] == nums[end]) end++; return {beg + 1, end - 1}; }}; 24. ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹ACä»£ç 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* swapPairs(ListNode* head) { ListNode dummy(0), *h; dummy.next = head;//å“‘ç»“ç‚¹å®šä¹‰ä¸ºå±€éƒ¨å˜é‡ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼ h = &amp;dummy; while (h-&gt;next != NULL) { if (h-&gt;next-&gt;next != NULL) { ListNode *a = h-&gt;next, *b = h-&gt;next-&gt;next; a-&gt;next = b-&gt;next; b-&gt;next = a; h-&gt;next = b; h = h-&gt;next-&gt;next; } else { break; } } return dummy.next; }}; 47. å…¨æ’åˆ— IIACä»£ç 123456789101112class Solution {public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; ans; do { ans.push_back(nums); }while (next_permutation(nums.begin(), nums.end())); ans.erase(unique(ans.begin(), ans.end()),ans.end()); return ans; }}; å¤§ä½¬ä»£ç 12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;bool&gt; b; vector&lt;int&gt; v; void dfs(int i, const vector&lt;int&gt;&amp; nums) { if(i == nums.size()){ ans.push_back(v); return; } for(int j = 0; j &lt; nums.size(); ++j){ if(j &gt; 0 &amp;&amp; nums[j - 1] == nums[j] &amp;&amp; !b[j - 1])continue; if(!b[j]){ b[j] = 1; v[i] = nums[j]; dfs(i + 1, nums); b[j] = 0; } } return; } vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); v.resize(nums.size()); b.resize(nums.size()); dfs(0, nums); return ans; }}; 49. å­—æ¯å¼‚ä½è¯åˆ†ç»„æ€è·¯ stlä½¿åŠ²å¥—ï¼Œè¦ç”¨multisetï¼Œä¸¤ä¸ªå•è¯å­—ç¬¦é›†ç›¸åŒä½†æ˜¯å­—ç¬¦ä¸ªæ•°ä¸åŒ ä¼˜åŒ–ï¼Œä¸ç”¨setï¼Œmapå˜æˆstringï¼Œå­—ç¬¦é›†çš„å­—ç¬¦ä¸²æ’åºåå¯¹åº”å”¯ä¸€çš„â€œç‰¹å¾å­—ç¬¦ä¸²â€ ACä»£ç 1234567891011121314151617181920212223class Solution {public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) { map&lt;multiset&lt;char&gt;, vector&lt;string&gt;&gt; m; int num = strs.size(); for (auto &amp;x : strs) { multiset&lt;char&gt; s(x.begin(), x.end()); m[s].push_back(x); } vector&lt;vector&lt;string&gt;&gt; ans; for (auto &amp;x : m) { ans.push_back(x.second); } return ans; }};static const auto io_sync_off = []() { // turn off sync std::ios::sync_with_stdio(false); // untie in/out streams std::cin.tie(nullptr); return nullptr;}(); ACä»£ç ï¼ˆä¼˜åŒ–ï¼‰12345678910111213141516class Solution {public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) { unordered_map&lt;string, vector&lt;string&gt;&gt; m; for (auto &amp;x : strs) { string temp = x; sort(x.begin(), x.end()); m[x].push_back(temp); } vector&lt;vector&lt;string&gt;&gt; ans; for (auto &amp;x : m) { ans.push_back(x.second); } return ans; }}; 80. åˆ é™¤æ’åºæ•°ç»„ä¸­çš„é‡å¤é¡¹ IIæ€è·¯åŒæŒ‡é’ˆéå†ä¸€éæ•°ç»„ï¼Œ ACä»£ç 123456789101112131415class Solution { public: int removeDuplicates(vector&lt;int&gt; &amp;nums) { int i = 0, j = 0; int len = nums.size(); while (i &lt; len) { if (j &lt; 2 || nums[i] &gt; nums[j - 2]) { int n = nums[i]; nums[j++] = n; } i++; } return j; }};","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%939/"},{"title":"LeetCode-7","text":"532. æ•°ç»„ä¸­çš„K-diffæ•°å¯¹æ€è·¯ mapï¼Œä¿å­˜æ¯ä¸ªæ•°å‡ºç°çš„æ¬¡æ•° éå†mapï¼Œå¦‚æœè¦æ‰¾å·®ä¸º0çš„æ•°å¯¹ï¼Œé‚£ä¹ˆå¦‚æœå‡ºç°æ¬¡æ•°å¤§äº1ï¼Œè¯´æ˜æœ‰ä¸€å¯¹å„¿ å¦‚æœå·®ä¸æ˜¯0ï¼Œç®—å‡ºå¦ä¸€ä¸ªæ•°ï¼Œåœ¨mapé‡Œé¢æŸ¥è¯¢ï¼ŒæŸ¥è¯¢åˆ°äº†å°±æ˜¯ä¸€å¯¹å„¿ ACä»£ç 12345678910111213141516171819202122class Solution {public: int findPairs(vector&lt;int&gt;&amp; nums, int k) { if (k &lt; 0) return 0; map&lt;int, int&gt; m; for (int x : nums) { m[x]++; } int ans = 0; auto ite = m.begin(); while (ite != m.end()) { if (k) { int sum = ite-&gt;first + k; if (m.count(sum)) ans++;//è¿™é‡Œè¦ç”¨countå‡½æ•°æŸ¥è¯¢æ˜¯å¦å­˜åœ¨å…ƒç´ ï¼Œç›´æ¥è®¿é—®ä¼šè¶…æ—¶ } else { if (ite-&gt;second &gt; 1) ans++; } ite++; } return ans; }}; 70. çˆ¬æ¥¼æ¢¯æ€è·¯ åœ¨çº¸ä¸Šè®¡ç®—ï¼Œå¯ä»¥å‘ç°æ˜¯æ–æ³¢é‚£å¥‘æ•°åˆ—çš„ç¬¬n+1é¡¹ ACä»£ç 123456789101112131415class Solution {public: int climbStairs(int n) { return fib(n + 1); } int fib(int N) { int a = 0, b = 1; for (int i = 0; i &lt; N; i++) { int c = a + b; b = a; a = c; } return a; }}; 429. Nå‰æ ‘çš„å±‚åºéå†æ€è·¯éå†çˆ·çˆ·è¾ˆçš„æ•°ç»„ï¼Œæ¯æ¬¡æŠŠå­™å­è¾ˆä»¬å…¨éƒ½æ”¾åœ¨ä¸€ä¸ªsubæ•°ç»„é‡Œé¢ï¼Œå¦‚æœpushå®Œä»¥åéç©ºï¼Œå°±pushåˆ°ansé‡Œé¢ï¼Œç„¶åæŠŠçˆ¶äº²è¾ˆæ”¾åˆ°fatherTempæ•°ç»„é‡Œé¢ï¼Œä½œä¸ºä¸‹ä¸€æ¬¡çš„çˆ·çˆ·è¾ˆã€‚ä¸ºäº†å¤„ç†ç¬¬1ç¬¬2è¾ˆï¼Œå»ºç«‹ä¸¤ä¸ªå“‘èŠ‚ç‚¹ï¼Œç»Ÿä¸€ç®—æ³• ACä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445/*// Definition for a Node.class Node {public: int val; vector&lt;Node*&gt; children; Node() {} Node(int _val, vector&lt;Node*&gt; _children) { val = _val; children = _children; }};*/class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) { if (!root) return {}; Node *root1 = new Node(); Node *root2 = new Node(); root2-&gt;children.push_back(root); root1-&gt;children.push_back(root2); vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; sub; vector&lt;Node*&gt; m = {root1}; vector&lt;Node*&gt;&amp; father = m; while (father.size()) { sub.clear(); vector&lt;Node*&gt; fatherTemp; for (Node* x : father) { for (Node* y : x-&gt;children) { for (Node* z : y-&gt;children) { sub.push_back(z-&gt;val); } fatherTemp.push_back(y); } } if (sub.size()) ans.push_back(sub); father = fatherTemp; } return ans; }}; å¤§ä½¬æ€è·¯å¤§ä½¬ä»£ç 1234567891011121314151617181920static auto x = []() { std::ios::sync_with_stdio(false);std::cin.tie(nullptr);return 0;}();class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) { vector&lt;vector&lt;int&gt;&gt; ans; queue&lt;Node*&gt; que; if(!root) return ans; que.push(root); while(!que.empty()){ int k=que.size(); ans.resize(ans.size()+1); for(int i=0;i&lt;k;i++){ ans[ans.size()-1].push_back(que.front()-&gt;val); for(Node* node:que.front()-&gt;children) que.push(node); que.pop(); } } return ans; }}; 102. äºŒå‰æ ‘çš„å±‚æ¬¡éå†æ€è·¯å’Œä¸Šä¸€é¢˜429. Nå‰æ ‘çš„å±‚åºéå†ä¸€ä¸ªæƒ³æ³• ACä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { if (!root) return {}; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; sub; TreeNode *root1 = new TreeNode(0), *root2 = new TreeNode(0); root2-&gt;left = root; root1-&gt;left = root2; TreeNode* temp = root1; vector&lt;TreeNode*&gt; m = {root1}; vector&lt;TreeNode*&gt;&amp; father = m; vector&lt;TreeNode*&gt; fatherTemp; while (father.size()) { fatherTemp.clear(); sub.clear(); for (TreeNode* x : father) { if (x-&gt;left != NULL) { fatherTemp.push_back(x-&gt;left); if (x-&gt;left-&gt;left != NULL) sub.push_back(x-&gt;left-&gt;left-&gt;val); if (x-&gt;left-&gt;right != NULL) sub.push_back(x-&gt;left-&gt;right-&gt;val); } if (x-&gt;right != NULL) { fatherTemp.push_back(x-&gt;right); if (x-&gt;right-&gt;left != NULL) sub.push_back(x-&gt;right-&gt;left-&gt;val); if (x-&gt;right-&gt;right != NULL) sub.push_back(x-&gt;right-&gt;right-&gt;val); } } if (sub.size()) ans.push_back(sub); father = fatherTemp; } return ans; }}; 404. å·¦å¶å­ä¹‹å’Œæ€è·¯ é€’å½’ å¦‚æœå·¦è¾¹çš„å·¦è¾¹å’Œå·¦è¾¹çš„å³è¾¹éƒ½æ˜¯ç©ºï¼Œé‚£ä¹ˆæˆ‘çš„å·¦è¾¹å°±æ˜¯ä¸ªå¶å­ æ”¹è¿›ï¼Œä¸ç”¨vectorå­˜ç»“ç‚¹çš„æŒ‡é’ˆï¼Œç›´æ¥åŠ èµ·æ¥ ACä»£ç 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int sumOfLeftLeaves(TreeNode* root) { vector&lt;TreeNode*&gt; leaves; int ans = 0; getLeaves(root, leaves); for (auto x : leaves) { ans += x-&gt;val; } return ans; } void getLeaves(TreeNode* root, vector&lt;TreeNode*&gt;&amp; leaves) { if (root == NULL) return; if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) return; if (root-&gt;left != NULL) { if (root-&gt;left-&gt;left == NULL &amp;&amp; root-&gt;left-&gt;right == NULL) { leaves.push_back(root-&gt;left); } } getLeaves(root-&gt;left, leaves); getLeaves(root-&gt;right, leaves); }}; ACä»£ç ï¼ˆæ”¹è¿›ï¼‰1234567891011121314151617181920class Solution {public: int sumOfLeftLeaves(TreeNode* root) { vector&lt;TreeNode*&gt; leaves; int ans = 0; getLeaves(root, ans); return ans; } void getLeaves(TreeNode* root, int&amp; sum) {//ä¼ å…¥å¼•ç”¨ if (root == NULL) return; if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) return; if (root-&gt;left != NULL) { if (root-&gt;left-&gt;left == NULL &amp;&amp; root-&gt;left-&gt;right == NULL) { sum += root-&gt;left-&gt;val; } } getLeaves(root-&gt;left, sum); getLeaves(root-&gt;right, sum); }}; 492. æ„é€ çŸ©å½¢æ€è·¯ ä¸¤ä¸ªå˜é‡aï¼Œb,a = sqrt(area)ï¼Œa++ä¸æ–­æœç´¢ï¼Œç›´åˆ°ç¬¬ä¸€ä¸ªä¸ºæ•´æ•°ï¼Œç„¶åa = sqrt(area)å¼€å§‹ä¸æ–­aâ€“æœç´¢ï¼Œå¾—åˆ°ä¸¤ç»„å¯èƒ½çš„ç­”æ¡ˆï¼Œæ¯”è¾ƒè°çš„å·®è·å°ï¼Œç„¶åè¾“å‡º ä¼˜åŒ–ï¼Œåªæœç´¢ä¸€åŠå°±è¡Œ ACä»£ç 12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;int&gt; constructRectangle(int area) { int a1 = sqrt(area); int b1 = 0; int a2 = a1; int b2 = 0; while (area % a1) { a1--; } b1 = area / a1; while (area % a2) { a2++; } b2 = area / a2; int ansa, ansb; if (abs(a1 - b1) &gt; abs(a2 - b2)) { ansa = a2; ansb = b2; } else { ansa = a1; ansb = b1; } if (ansa &gt; ansb) { int t = ansa; ansa = ansb; ansb = t; } return {ansb, ansa}; }}; ACä»£ç ï¼ˆä¼˜åŒ–ï¼‰1234567891011121314class Solution {public: vector&lt;int&gt; constructRectangle(int area) { int a1 = sqrt(area); int b1 = 0; int a2 = a1; int b2 = 0; while (area % a1) { a1--; } b1 = area / a1; return {b1, a1}; }}; 453. æœ€å°ç§»åŠ¨æ¬¡æ•°ä½¿æ•°ç»„å…ƒç´ ç›¸ç­‰æ€è·¯ æ²¡æ€è·¯ï¼Œè¯„è®ºè¯´å¯ä»¥æ¨å¯¼å…¬å¼ï¼Œå°±æ¨å‡ºæ¥äº† $ans = \\Sigma_{i=0}^{nums.size() - 1}[nums[i] - min(nums)]$ å…¬å¼æ¨å¯¼æ€è·¯ï¼ˆä»¥ä¸‹å­—æ¯ASCIIè¶Šå¤§ï¼Œä»£è¡¨çš„å€¼å°±è¶Šå¤§ï¼‰ {a}â€”â€”0 {b, a}â€”â€”b - a {c, b, a}â€”â€”b - a + c - a ä»aå¼€å§‹ï¼Œå…ˆè®©aç­‰äºbï¼Œç„¶åè®©ä¸¤ä¸ªbç­‰äºç¬¬ä¸‰å°çš„æ•°ï¼Œè®©ä¸‰ä¸ªç¬¬ä¸‰å°çš„æ•°ç­‰äºç¬¬å››å°çš„æ•°â€¦ ACä»£ç 12345678910111213141516class Solution {public: int minMoves(vector&lt;int&gt;&amp; nums) { int min = INT_MAX; for (int x : nums) { if (x &lt; min) { min = x; } } int ans = 0; for (int x : nums) { ans += x - min; } return ans; }}; ACä»£ç ï¼ˆä¼˜åŒ–ï¼‰1234567891011121314class Solution {public: int minMoves(vector&lt;int&gt;&amp; nums) { long long min = INT_MAX, ans = 0, len = nums.size(), sum = 0; for (int x : nums) { if (x &lt;= min) { min = x; } sum += x; } return sum - min*len; }}; 551. å­¦ç”Ÿå‡ºå‹¤è®°å½• Iæ€è·¯æŠŠç»Ÿè®¡è¿ç»­ç›¸åŒå­—ç¬¦ä¸ªæ•°å’Œç»Ÿè®¡æŸä¸€ä¸ªå­—ç¬¦å‡ºç°æ¬¡æ•°çš„ç®—æ³•ç»“åˆåœ¨ä¸€èµ·å°±è¡Œ ACä»£ç 1234567891011121314151617181920212223class Solution {public: bool checkRecord(string s) { int maxL = 0, numA = 0; int len = s.length(); for (int i = 0; i &lt; len;) { int count = 0; if (s[i] == 'A') { numA++; i++;//ç»Ÿè®¡'A'çš„ä¸ªæ•° } else if (s[i] == 'L') { while (s[i] == 'L') { i++; count++;//ç»Ÿè®¡è¿ç»­çš„'L'çš„ä¸ªæ•° } maxL = maxL &gt; count ? maxL : count; } else { i++; } } return numA &lt;= 1 &amp;&amp; maxL &lt;= 2; }}; 557. åè½¬å­—ç¬¦ä¸²ä¸­çš„å•è¯ IIIæ€è·¯ä¸€ä¸ªæŒ‡é’ˆï¼Œè¿›å»ä»¥åä¿å­˜ä¸€æ¬¡æŒ‡é’ˆä½ç½®ï¼Œç„¶åæŒ‡é’ˆåç§»ï¼Œç§»åŠ¨åˆ°ç©ºæ ¼æˆ–è€…ç»“æŸä¸ºæ­¢ï¼Œä¿å­˜ä¸€æ¬¡æŒ‡é’ˆçš„ä½ç½®ï¼Œreverseä¸¤ä¸ªæŒ‡é’ˆ ACä»£ç 123456789101112131415class Solution {public: string reverseWords(string s) { int i = 0; int len = s.length(); while (i &lt; len) { int beg = i; while (i &lt; len &amp;&amp; s[i] != ' ') i++; int end = i; reverse(s.begin() + beg, s.begin() + end); i++; } return s; }}; 559. Nå‰æ ‘çš„æœ€å¤§æ·±åº¦æ€è·¯ æŠŠä¹‹å‰429. Nå‰æ ‘çš„å±‚åºéå†çš„ä»£ç ç›´æ¥æ‹¿æ¥ç”¨ ç®€åŒ–ä»£ç  ACä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*// Definition for a Node.class Node {public: int val; vector&lt;Node*&gt; children; Node() {} Node(int _val, vector&lt;Node*&gt; _children) { val = _val; children = _children; }};*/class Solution {public: int maxDepth(Node* root) { return levelOrder(root).size(); } vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) { if (!root) return {}; Node *root1 = new Node(); Node *root2 = new Node(); root2-&gt;children.push_back(root); root1-&gt;children.push_back(root2); vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; sub; vector&lt;Node*&gt; m = {root1}; vector&lt;Node*&gt;&amp; father = m; while (father.size()) { sub.clear(); vector&lt;Node*&gt; fatherTemp; for (Node* x : father) { for (Node* y : x-&gt;children) { for (Node* z : y-&gt;children) { sub.push_back(z-&gt;val); } fatherTemp.push_back(y); } } if (sub.size()) ans.push_back(sub); father = fatherTemp; } return ans; }}; ACä»£ç ï¼ˆç®€åŒ–ï¼‰123456789101112131415161718192021222324252627class Solution {public: int maxDepth(Node* root) { if (!root) return {}; Node *root1 = new Node(); Node *root2 = new Node(); root2-&gt;children.push_back(root); root1-&gt;children.push_back(root2); vector&lt;Node*&gt; m = {root1}; vector&lt;Node*&gt;&amp; father = m; int count = 0; while (father.size()) { vector&lt;Node*&gt; fatherTemp; bool empty = true; for (Node* x : father) { for (Node* y : x-&gt;children) { if (y-&gt;children.size()) empty = false; fatherTemp.push_back(y); } } father = fatherTemp; if (!empty) count++; } return count; }}; 561. æ•°ç»„æ‹†åˆ† Iæ€è·¯ æ’ä¸ªåºï¼ŒæŠŠä¸‹æ ‡ä¸ºå¶æ•°çš„é¡¹å…¨éƒ½åŠ èµ·æ¥ ACä»£ç 1234567891011class Solution {public: int arrayPairSum(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); int len = nums.size(), ans = 0; for (int i = 0; i &lt; len; i+=2) { ans += nums[i]; } return ans; }}; 566. é‡å¡‘çŸ©é˜µæ€è·¯ å…ˆæŠŠä¸èƒ½è½¬æ¢çš„æ’é™¤ ä¸¤ä¸ªä¸‹æ ‡mï¼Œnï¼ŒæŒ‡å‘åŸæ¥æ•°ç»„çš„è¡Œå’Œåˆ—ï¼Œå½“nä¸ºåŸæ¥æ•°ç»„çš„cæ—¶ï¼Œm++ï¼Œn = 0 ACä»£ç 1234567891011121314151617181920212223class Solution {public: vector&lt;vector&lt;int&gt;&gt; matrixReshape(vector&lt;vector&lt;int&gt;&gt;&amp; nums, int r, int c) { int hight = nums.size(), width = nums[0].size(); if (r*c != hight*width) { return nums; } vector&lt;vector&lt;int&gt;&gt; ans; int m = 0,n = 0; for (int i = 0; i &lt; r; i++) { vector&lt;int&gt; temp; for (int j = 0; j &lt; c; j++) { if (n == width) { m++; n = 0; } temp.push_back(nums[m][n++]); } ans.push_back(temp); } return ans; }}; 575. åˆ†ç³–æœæ€è·¯ mapæˆ–è€…æ•°ç»„ï¼ˆå·²çŸ¥æ•°æ®èŒƒå›´ï¼‰è®°å½•æ˜¯å¦å‡ºç°ï¼Œä¸€è¾¹éå†ä¸€è¾¹æ•° ACä»£ç 123456789101112131415class Solution {public: int distributeCandies(vector&lt;int&gt;&amp; candies) { int m[200001] = {0}; int len = candies.size(); int count = 0; for (auto x : candies) { if (m[x + 100000] == 0) { m[x + 100000] = 1; count++; } } return min(count, len / 2); }};","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%937/"},{"title":"LeetCode-dp","text":"leetcode 101çš„åŠ¨æ€è§„åˆ’ä¸“é¢˜ åŸºæœ¬åŠ¨æ€è§„åˆ’ï¼šä¸€ç»´70. çˆ¬æ¥¼æ¢¯12345678910111213class Solution {public: int climbStairs(int n) { int a=1,b=2; if(n&lt;2) return 1; for(int i = 2; i &lt;n ; i++) { int c = a+b; a=b; b=c; } return b; }}; dpæ•°ç»„è¡¨ç¤ºä¸Šnå±‚æ¥¼æœ‰å‡ ç§å¯èƒ½è½¬ç§»æ–¹ç¨‹æ˜¯ $ dp[i] = dp[i-1] + dp[i-2] $ä¸Šåˆ°ç¬¬iå±‚æœ‰å¯èƒ½ä»ç¬¬i-1å±‚æˆ–i-2å±‚ä¸Šæ¥ï¼Œåˆ™ä¸Šåˆ°iå±‚çš„å¯èƒ½æ•°ç›®å°±æ˜¯ $ dp[i-1] + dp[i-2] $ç”±äºdp[i]åªéœ€è¦å‰ä¸¤ä¸ªæ•°çš„æ•°æ®ï¼Œæ‰€ä»¥å¯ä»¥ä¼˜åŒ–æ‰dpæ•°ç»„ï¼Œç”¨ä¸¤ä¸ªå˜é‡ä»£æ›¿ï¼ŒèŠ‚çœæ•°ç»„ç©ºé—´ 198. æ‰“å®¶åŠ«èˆçŠ¶æ€è®°å½•1234567891011121314151617class Solution {public: int n; vector&lt;int&gt; mem; int rob(vector&lt;int&gt;&amp; nums) { this-&gt;n = nums.size(); mem = vector&lt;int&gt;(n+2, -1); return maxRob(nums, -2); } int maxRob(const vector&lt;int&gt;&amp; nums, int i) { if(i &lt; n &amp;&amp; mem[i+2] != -1) return mem[i+2]; int a = (i+2 &lt; n ? maxRob(nums, i+2) + nums[i+2] : 0); int b = (i+3 &lt; n ? maxRob(nums, i+3) + nums[i+3] : 0); mem[i+2] = (a &gt; b? a : b); return mem[i+2]; }}; è¿™æ˜¯ä¹‹å‰å®ä¹ æ—¶å†™çš„ä»£ç æ€è·¯ä¸æ˜¯dpï¼Œè€Œæ˜¯è‡ªä¸Šè€Œä¸‹çš„å¸¦æœ‰çŠ¶æ€è®°å½•çš„ä¼˜å…ˆæœç´¢æ€è·¯ç›¸åŒï¼Œå°±æ˜¯ï¼Œè‹¥æ‰“åŠ«iï¼Œåˆ™ä¸€å®šä¸èƒ½æ‰“åŠ«i+1ï¼Œè€ƒè™‘æ˜¯æ‰“åŠ«i+2è¿˜æ˜¯i+3çŠ¶æ€è½¬ç§»æ–¹ç¨‹ $ dp[i] = nums[i] + max(dp[i+2], dp[i+3]) $ dp12345678910111213141516171819class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { int len = nums.size(); vector&lt;int&gt; dp(len); if(len == 1) { return nums[len-1]; } else if(len == 2) { return max(nums[len-1], nums[len-2]); } dp[len-1] = nums[len-1]; dp[len-2] = max(nums[len-1], nums[len-2]); dp[len-3] = max(nums[len-2], nums[len-3] + dp[len-1]); for(int i = len-4; i &gt;= 0; i--) { dp[i] = nums[i] + max(dp[i+3], dp[i+2]); } return max(dp[0], dp[1]); }}; ç”±äºç¬¬0å®¶å¯ä»¥æ‰“åŠ«ï¼Œä¹Ÿå¯ä»¥è·³è¿‡ï¼Œæ‰€ä»¥æœ€ç»ˆç»“æœæ˜¯ $ max(dp[0], dp[1]) $ åŒä¸Šï¼Œä¹Ÿå¯ä»¥ä¼˜åŒ–å­˜å‚¨ç©ºé—´ 1234567891011121314151617class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { int len = nums.size(); if(len == 1) { return nums[len-1]; } else if(len == 2) { return max(nums[len-1], nums[len-2]); } int a = nums[len-1],b = max(nums[len-1], nums[len-2]), c = max(nums[len-2], nums[len-3] + nums[len-1]); for(int i = len-4; i &gt;= 0; i--) { int d = nums[i] + max(a, b); a = b;b = c;c = d; } return max(b, c); }}; 121. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº1234567891011121314151617class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int len = prices.size(); int minPos = len-1; int maxx = prices[len-1]; int maxx1 = prices[len-1]; for(int i = len-2; i &gt;= 0; i--) { maxx1 = max(prices[i], maxx1); if(maxx1 - prices[i] &gt; maxx - prices[minPos]) { minPos = i; maxx = maxx1; } } return maxx - prices[minPos]; }}; è®°maxxæ•°ç»„ä¸­ $ maxx[i] $ è¡¨ç¤º $ max(prices[j]); j = i,i+1,â€¦,n-1 $å‡è®¾åœ¨ç¬¬iå¤©ä¹°å…¥ï¼Œåˆ™åº”è¯¥åœ¨ç¬¬iå¤©åå”®ä»·æœ€é«˜çš„ä¸€å¤©å–å‡ºï¼Œä¹Ÿå°±æ˜¯ $ maxx[i] $å†æŠŠmaxxæ•°ç»„ä¼˜åŒ–æ‰ 413. ç­‰å·®æ•°åˆ—åˆ’åˆ†1234567891011121314151617181920212223242526class Solution {public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; nums) { int len = nums.size(); if(len &lt; 3) return 0; int i = 2; int ans = 0; int count = 2; while(i &lt; len) { while(i &lt; len &amp;&amp; nums[i] - nums[i-1] == nums[i-1] - nums[i-2]) { i++; count++; } if(count &gt;= 3) { ans += (count-2)*(count-1)/2; } if(i &lt; len-1) { i += 1; count = 2; } else { break; } } return ans; }}; ç”±äºæ±‚çš„æ˜¯è¿ç»­å­æ•°ç»„ä¸­ä¸ºç­‰å·®æ•°åˆ—çš„ä¸ªæ•°ï¼Œå¯ä»¥æŠŠnumsçœ‹ä½œå¤šä¸ªå…¬å·®ä¸åŒçš„ç­‰å·®æ•°åˆ—æ‹¼æ¥åœ¨ä¸€èµ·åªéœ€è¦æ‰¾åˆ°æ¯æ®µæœ€é•¿çš„ç­‰å·®æ•°åˆ—ï¼Œè®¡ç®—å®ƒæœ‰å¤šå°‘ä¸ªå­ç­‰å·®æ•°åˆ—ä¹Ÿå°±æ˜¯ $$ \\sum_{i=3}^n(n+1-i) = (n-2) \\times (n-1)/2 $$ å…¶ä¸­næ˜¯ç­‰å·®æ•°åˆ—çš„é•¿åº¦ã€‚åº”è¯¥æ²¡æœ‰ç”¨dpçš„æ€æƒ³å§ï¼Ÿ dpç‰ˆ1234567891011int numberOfArithmeticSlices(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if (n &lt; 3) return 0; vector&lt;int&gt; dp(n, 0); for (int i = 2; i &lt; n; ++i) { if (nums[i] - nums[i-1] == nums[i-1] - nums[i-2]) { dp[i] = dp[i-1] + 1; } } return accumulate(dp.begin(), dp.end(), 0);} ä¸¾ä¸ªä¾‹å­å¯ä»¥çœ‹å‡ºè‹¥nums = [1,2,3,4,5,7,9,11]åˆ™dp = [0,0,1,2,3,0,1,2]ä¸€ä¸ªç­‰å·®æ•°åˆ—ä¸­çš„ $ \\sum(dp[i]) $ å’Œæˆ‘ä¸Šé¢åˆ†æçš„ $ \\sum(n+1-i) $ ä¸€æ ·çš„ åŸºæœ¬åŠ¨æ€è§„åˆ’ï¼šäºŒç»´64. æœ€å°è·¯å¾„å’Œ12345678910111213141516171819class Solution {public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = grid.size(); int n = grid[0].size(); for(int i = 1; i &lt; m; i++) { grid[i][0] += grid[i-1][0]; } for(int i = 1; i &lt; n; i++) { grid[0][i] += grid[0][i-1]; } for(int i = 1; i &lt; m; i++) { for(int j = 1; j &lt; n; j++) { grid[i][j] += min(grid[i-1][j], grid[i][j-1]); } } return grid[m-1][n-1]; }}; æ¯”è¾ƒå¥½æƒ³ï¼Œå› ä¸ºåªèƒ½å‘å³æˆ–å‘ä¸‹èµ°ï¼Œé‚£ä¹ˆ å¯¹äº $ grid[i][j] (i &gt; 0 , j &gt; 0) $ ï¼Œ åˆ°è¾¾å®ƒçš„æœ€çŸ­è·¯å¾„æ˜¯ $ grid[i][j] + min(grid[i-1][j], grid[i][j-1]) $ å¯¹äº $ grid[i][j] (i = 0 , j &gt; 0) $ ï¼Œ åˆ°è¾¾å®ƒçš„æœ€çŸ­è·¯å¾„æ˜¯ $ grid[i][j] + grid[i][j-1] $ å¯¹äº $ grid[i][j] (i &gt; 0 , j = 0) $ ï¼Œ åˆ°è¾¾å®ƒçš„æœ€çŸ­è·¯å¾„æ˜¯ $ grid[i][j] + grid[i-1][j] $ dpæ•°ç»„å‹ç¼©12345678910111213141516171819class Solution {public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = grid.size(); int n = grid[0].size(); vector&lt;int&gt; dp(n); dp[0] = grid[0][0]; for(int i = 1; i &lt; n; i++) { dp[i] = grid[0][i] + dp[i-1]; } for(int i = 1; i &lt; m; i++) { dp[0] += grid[i][0]; for(int j = 1; j &lt; n; j++) { dp[j] = grid[i][j] + min(dp[j], dp[j-1]); } } return dp[n-1]; }}; æ¯æ¬¡åªæ›´æ–°åŒä¸€è¡Œä¹Ÿæ˜¯å¯ä»¥çš„ï¼Œå› ä¸ºæ¯æ¬¡åªéœ€è¦å·¦è¾¹çš„å’Œä¸Šä¸€è¡Œçš„ï¼Œå…¶ä»–çš„ä¸éœ€è¦ 542. 01 çŸ©é˜µæœªacä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; mat) { int m = mat.size(), n = mat[0].size(); vector&lt;vector&lt;int&gt;&gt; ans(m, vector&lt;int&gt;(n, 20000)); for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; n; j++) { if(mat[i][j] == 0) { ans[i][j] = 0; } if(i-1 &gt;= 0) { ans[i][j] = min(ans[i-1][j]+1, ans[i][j]); } if(j-1 &gt;= 0) { ans[i][j] = min(ans[i][j-1]+1, ans[i][j]); } if(i+1 &lt; m) { ans[i][j] = min(ans[i+1][j]+1, ans[i][j]); } if(j+1 &lt; n) { ans[i][j] = min(ans[i][j+1]+1, ans[i][j]); } if(i-1 &gt;= 0) { ans[i-1][j] = min(ans[i-1][j], 1 + ans[i][j]); } if(j-1 &gt;= 0) { ans[i][j-1] = min(ans[i][j-1], 1 + ans[i][j]); } if(i+1 &lt; m) { ans[i+1][j] = min(ans[i+1][j], 1 + ans[i][j]); } if(j+1 &lt; n) { ans[i][j+1] = min(ans[i][j+1], 1 + ans[i][j]); } } } return ans; }}; è¿™ä¸ªçš„æƒ³æ³•å’Œç­”æ¡ˆå·²ç»å¾ˆæ¥è¿‘äº†ï¼Œä½†æˆ‘åªä»ä¸€ä¸ªæ–¹å‘ä¸Šè¿›è¡Œäº†æ›´æ–°ï¼Œåº”è¯¥ä»å››ä¸ªè§’å¼€å§‹åˆ†åˆ«è¿›è¡Œæ›´æ–°ä¸€æ¬¡ acä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution {public: vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int m = matrix.size(), n = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dist(m, vector&lt;int&gt;(n, INT_MAX / 2)); for (int i = 0; i &lt; m; ++i) { for (int j = 0; j &lt; n; ++j) { if (matrix[i][j] == 0) { dist[i][j] = 0; } } } for (int i = 0; i &lt; m; ++i) { for (int j = 0; j &lt; n; ++j) { if (i - 1 &gt;= 0) { dist[i][j] = min(dist[i][j], dist[i - 1][j] + 1); } if (j - 1 &gt;= 0) { dist[i][j] = min(dist[i][j], dist[i][j - 1] + 1); } } } for (int i = m - 1; i &gt;= 0; --i) { for (int j = 0; j &lt; n; ++j) { if (i + 1 &lt; m) { dist[i][j] = min(dist[i][j], dist[i + 1][j] + 1); } if (j - 1 &gt;= 0) { dist[i][j] = min(dist[i][j], dist[i][j - 1] + 1); } } } for (int i = 0; i &lt; m; ++i) { for (int j = n - 1; j &gt;= 0; --j) { if (i - 1 &gt;= 0) { dist[i][j] = min(dist[i][j], dist[i - 1][j] + 1); } if (j + 1 &lt; n) { dist[i][j] = min(dist[i][j], dist[i][j + 1] + 1); } } } for (int i = m - 1; i &gt;= 0; --i) { for (int j = n - 1; j &gt;= 0; --j) { if (i + 1 &lt; m) { dist[i][j] = min(dist[i][j], dist[i + 1][j] + 1); } if (j + 1 &lt; n) { dist[i][j] = min(dist[i][j], dist[i][j + 1] + 1); } } } return dist; }}; 101 å…¶å®ä»å·¦ä¸Šå’Œå³ä¸‹ä¸¤ä¸ªæ–¹å‘å°±å¯ä»¥äº† 1234567891011121314151617181920212223242526272829303132vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { if (matrix.empty()) return {}; int n = matrix.size(), m = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(m, INT_MAX - 1)); for (int i = 0; i &lt; n; ++i) { for (int j = 0; j &lt; m; ++j) { if (matrix[i][j] == 0) { dp[i][j] = 0; } else { if (j &gt; 0) { dp[i][j] = min(dp[i][j], dp[i][j-1] + 1); } if (i &gt; 0) { dp[i][j] = min(dp[i][j], dp[i-1][j] + 1); } } } } for (int i = n - 1; i &gt;= 0; --i) { for (int j = m - 1; j &gt;= 0; --j) { if (matrix[i][j] != 0) { if (j &lt; m - 1) { dp[i][j] = min(dp[i][j], dp[i][j+1] + 1); } if (i &lt; n - 1) { dp[i][j] = min(dp[i][j], dp[i+1][j] + 1); } } } } return dp;} 221. æœ€å¤§æ­£æ–¹å½¢1234567891011121314151617181920212223242526272829class Solution {public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) { int m = matrix.size(); if(m &lt;= 0) return 0; int n = matrix[0].size(); if(n &lt;= 0) return 0; int maxx = 0; vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); for(int i = m-1; i &gt;= 0; i--) { dp[i][n-1] = matrix[i][n-1] - '0'; maxx = max(maxx, dp[i][n-1]); } for(int i = n-1; i &gt;= 0; i--) { dp[m-1][i] = matrix[m-1][i] - '0'; maxx = max(maxx, dp[m-1][i]); } for(int i = m-2; i &gt;= 0; i--) { for(int j = n-2; j &gt;= 0; j--) { if(matrix[i][j] != '0') { int x = min(dp[i][j+1], min(dp[i+1][j], dp[i+1][j+1])); dp[i][j] = 1 + x + 2*sqrt(x); maxx = max(maxx, dp[i][j]); } } } return maxx; }}; ä»å³ä¸‹è§’åˆ°å·¦ä¸Šè§’ï¼Œdpè¡¨ç¤ºä»¥(i, j)ä¸ºå·¦ä¸Šè§’é¡¶ç‚¹çš„æœ€å¤§æ­£æ–¹å½¢å¤§å°çœ‹ç‚¹(i+1, j) (i, j+1) (i+1, j+1)ä¸‰ä¸ªç‚¹çš„æœ€å°å€¼ï¼Œåœ¨æœ€å°å€¼çš„åŸºç¡€ä¸Šå¢åŠ ä¸€åœˆä¹Ÿå°±æ˜¯è¾¹é•¿+1ï¼Œç”±äºdp[i][j]è¡¨ç¤ºçš„æ˜¯é¢ç§¯ï¼Œ $ dp[i][j] = (sqrt(min)+1)^2 = min + 2 \\times sqrt(min) + 1 $åœ¨è®¡ç®—è¿‡ç¨‹ä¸­è®°å½•max(dp[i][j]) åˆ†å‰²ç±»å‹é¢˜279. å®Œå…¨å¹³æ–¹æ•°12345678910111213141516class Solution {public: int numSquares(int n) { vector&lt;int&gt; dp(n+1, 0); for(int i = 1; i &lt;= n; i++) { int min = INT_MAX-1; for(int j = 1; i-j*j &gt;= 0; j++) { if(dp[i-j*j] &lt; min) { min = dp[i - j*j]; } } dp[i] = min+1; } return dp[n]; }}; dp[i]ä¿å­˜æ•°å­—içš„æœ€å°‘å¹³æ–¹æ•°ä¹‹å’Œï¼Œå‡è®¾ $ i $ ç”± $ j \\times j $ å’Œ $ i - j \\times j $ ç›¸åŠ è€Œå¾—ï¼Œé‚£ä¹ˆ$$ dp[i] = min_{ j=1 }^{ \\sqrt i }(dp[i-j \\times j]) + 1 $$ 91. è§£ç æ–¹æ³•123456789101112131415class Solution {public: int numDecodings(string s) { s = &quot;(&quot; + s + &quot;)&quot;; int n = s.size(); vector&lt;int&gt; dp(n, 0); dp[n-2] = 1; for(int i = n-3; i &gt;= 0; i--) { int number = s[i+1]*10 + s[i+2] - '0'*11; int number1 = s[i+1] - '0'; dp[i] = ((number &gt;= 10 &amp;&amp; number &lt;= 26) ? dp[i+2] : 0) + ((number1 &gt;= 1 &amp;&amp; number1 &lt;= 9) ? dp[i+1] : 0); } return dp[0]; }}; åœ¨ä¸¤ä¸ªæ•°ä¹‹é—´æ·»åŠ éš”æ¿ï¼Œå¹¶è®¡ç®—ä¸¤ä¸ªéš”æ¿ä¹‹é—´æ•°å­—æ˜¯å¦åˆæ³•dp[i]è¡¨ç¤ºåœ¨æ•°å­—iåæ·»åŠ ä¸€ä¸ªéš”æ¿åï¼Œs[iâ€¦n-1]å…±æœ‰å‡ ç§æ’å…¥éš”æ¿çš„æ–¹å¼å¦‚æœs[i+1]åœ¨1åˆ°9ä¹‹é—´ï¼Œåˆ™å¯ä»¥åœ¨i+1ååŠ å…¥ä¸€ä¸ªéš”æ¿å¦‚æœs[i+1â€¦i+2]åœ¨10åˆ°26ä¹‹é—´ï¼Œåˆ™å¯ä»¥åœ¨i+1åä¸æ’å…¥éš”æ¿è€Œåœ¨i+2ååŠ å…¥éš”æ¿è€ƒè™‘åˆ°éš”ä¸€ä¸ªæˆ–ä¸¤ä¸ªæ•°æ’å…¥ä¸€ä¸ªéš”æ¿ï¼Œä¸éœ€è¦è€ƒè™‘å­—ç¬¦ä¸²æ›´é•¿çš„æƒ…å†µåˆ™è½¬ç§»æ–¹ç¨‹ä¸º$ dp[i] = dp[i+1] + dp[i+2] \\quad if \\quad 1&lt;=s[i+1]&lt;=9 \\quad and \\quad 10&lt;=s[i+1â€¦i+2]&lt;=26 $$ dp[i] = dp[i+2] \\quad if \\quad not \\quad 1&lt;=s[i+1]&lt;=9 \\quad and \\quad 10&lt;=s[i+1â€¦i+2]&lt;=26 $$ dp[i] = dp[i+1] \\quad if \\quad 1&lt;=s[i+1]&lt;=9 \\quad and \\quad not \\quad 10&lt;=s[i+1â€¦i+2]&lt;=26 $$ dp[i] = 0 \\quad if \\quad not \\quad 1&lt;=s[i+1]&lt;=9 \\quad and \\quad not \\quad 10&lt;=s[i+1â€¦i+2]&lt;=26 $åœ¨så‰ååŠ å…¥æ‹¬å·æ˜¯ä¸ºäº†é¿å…åå¤å†™é‡å¤çš„é€»è¾‘ï¼Œå¦åˆ™ä»£ç å¾ˆå†—ä½™ 123456789101112131415161718192021class Solution {public: int numDecodings(string s) { int n = s.size(); vector&lt;int&gt; dp(n, 0); if(n &lt; 1) return n; if(n == 1) return s[0] == '0' ? 0 : 1; int number = (s[n-2] - '0')*10 + (s[n-1] - '0'); int number1 = (s[n-1] - '0'); dp[n-1] = 1; dp[n-2] = ((number1 &gt;= 1 &amp;&amp; number1 &lt;= 9) ? dp[n-1] : 0); for(int i = n-3; i &gt;= 0; i--) { number = (s[i+1] - '0')*10 + (s[i+2] - '0'); number1 = (s[i+1] - '0'); dp[i] = ((number &gt;= 10 &amp;&amp; number &lt;= 26) ? dp[i+2] : 0) + ((number1 &gt;= 1 &amp;&amp; number1 &lt;= 9) ? dp[i+1] : 0); } number = (s[0] - '0')*10 + (s[1] - '0'); number1 = (s[0] - '0'); return ((number &gt;= 10 &amp;&amp; number &lt;= 26) ? dp[1] : 0) + ((number1 &gt;= 1 &amp;&amp; number1 &lt;= 9) ? dp[0] : 0); }}; 139. å•è¯æ‹†åˆ†12345678910111213141516171819202122232425262728class Solution {public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) { unordered_map&lt;string, bool&gt; dict; for(string&amp; s : wordDict) { dict[s] = true; } int len = s.size(); vector&lt;int&gt; dp(len+1,0); dp[0] = 1; for(int i = 1; i &lt;= len; i++) { int j = i-1; bool flag = false; while(j &gt;= 0 &amp;&amp; !flag) { flag = dict[s.substr(dp[j]-1, i - dp[j] + 1)]; if(flag) break; while(j &gt; 0 &amp;&amp; dp[j-1] == dp[j]) j--; j--; } if(flag) { dp[i] = i+1; } else { dp[i] = dp[i-1]; } } return dp[len] == len+1; }}; è¿˜æ˜¯åˆ†å‰²é—®é¢˜æ€è·¯æ˜¯åˆ¤æ–­åœ¨ä½ç½®iä¹‹å‰æ’å…¥ä¸€ä¸ªéš”æ¿ï¼Œç”¨dp[i]è®°å½•æœ€è¿‘ä¸€æ¬¡åŒ¹é…åˆ°å­—å…¸ä¸­çš„å•è¯çš„ä½ç½®å¦‚leetcodeï¼Œ å¯¹äº l,le,lee, éƒ½æ²¡æœ‰åŒ¹é…åˆ°ï¼Œé‚£ä¹ˆdp[i] = 0leetåŒ¹é…åˆ°äº†ï¼Œdp[i] = 4ï¼Œé€šè¿‡dp[i-1]å°±å¯ä»¥çŸ¥é“è¦åŒ¹é… 0-4çš„å­—ä¸²leetc,leetco,leetcod, æ ¹æ® dp[i-1] = 4ï¼Œå‘ç°cï¼Œcoï¼Œcdéƒ½ä¸æ˜¯å­—å…¸ä¸­çš„ä¸²,dp[i] = dp[i-1];leetcodeæ ¹æ® dp[i-1] = 4ï¼Œå‘ç°codeæ˜¯å­—ä¸²ï¼Œé‚£ä¹ˆdp[i] = i+1;æœ€åæ£€æŸ¥dp[len]æ˜¯å¦ç­‰äºlen + 1 ä¸Šé¢çš„æ€è·¯çš„ä¸€ä¸ªé—®é¢˜æ˜¯ï¼Œå¯¹äºå­—å…¸ä¸­ï¼Œå­ä¸²ä¹Ÿåœ¨å­—å…¸å†…çš„ä¸²ï¼Œä¸èƒ½åªæ ¹æ®dp[i-1]å†³å®šå­ä¸²èŒƒå›´è¦çœ‹dp[0]åˆ°dp[i-1]æ‰€æœ‰å­ä¸² 1011234567891011121314151617class Solution {public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) { int len = s.size(); vector&lt;bool&gt; dp(len, false); dp[0] = true; for(int i = 0; i &lt;= len; i++) { for(string&amp; w : wordDict) { int length = w.size(); if(i &gt;= length &amp;&amp; w == s.substr(i-length, length)) { dp[i] = dp[i] || dp[i-length]; } } } return dp[len]; }}; å­åºåˆ—é—®é¢˜300. æœ€é•¿é€’å¢å­åºåˆ—123456789101112131415161718class Solution {public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; dp(n, 1); for(int i = 1; i &lt; n; i++) { int maxx = 0; for(int j = i-1; j &gt;= 0; j--) { if(nums[i] &gt; nums[j]) { dp[i] += dp[j]; break; } } dp[i] += maxx; } return *max_element(dp.begin(), dp.end()); }}; è¿™æ˜¯æœ€ç®€å•çš„æ–¹æ³•ï¼Œè¿˜å¯ä»¥ç”¨ç±»ä¼¼å•è°ƒæ ˆä¼˜åŒ– 1234567891011121314151617181920212223242526class Solution {public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if(n &lt;= 1) return n; vector&lt;int&gt; dp(n); dp[0] = nums[0]; int count = 1; for(int i = 1; i &lt; n; i++) { if(dp[count-1] &lt; nums[i]) { dp[count] = nums[i]; count++; } else { int pos = -1; for(int j = count-1; j &gt;= 0; j--) { if(dp[j] &lt; nums[i]) { pos = j; break; } } dp[pos+1] = nums[i]; } } return count; }}; 1143. æœ€é•¿å…¬å…±å­åºåˆ—1234567891011121314151617181920class Solution {public: int longestCommonSubsequence(string text1, string text2) { int m = text2.size(), n = text1.size(); vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n)); dp[0][0] = text1[0] == text2[0]; for(int i = 1; i &lt; m; i++) { dp[i][0] = max(dp[i-1][0], int(text1[0] == text2[i]) ); } for(int i = 1; i &lt; n; i++) { dp[0][i] = max(dp[0][i-1] , int(text1[i] == text2[0])); } //åˆå§‹åŒ– for(int i = 1; i &lt; m; i++) { for(int j = 1; j &lt; n; j++) { dp[i][j] = max(dp[i-1][j-1] + (text1[j] == text2[i]), max(dp[i-1][j], dp[i][j-1])); } } return dp[m-1][n-1]; }}; ç¨å¾®çœ‹äº†ä¸€ä¸‹ç­”æ¡ˆï¼Œ $ dp[i][j] $ è¡¨ç¤ºéå†åˆ° $ text1[i] $ , $ text2[j] $ ä¸ºæ­¢ï¼Œæœ€é•¿å­åºåˆ—æ˜¯å¤šå°‘ èƒŒåŒ…é—®é¢˜æ¿å­0-1èƒŒåŒ…123456789101112131415int knapsack(vector&lt;int&gt; weights, vector&lt;int&gt; values, int N, int W) { vector&lt;vector&lt;int&gt;&gt; dp(N + 1, vector&lt;int&gt;(W + 1, 0)); for (int i = 1; i &lt;= N; ++i) { int w = weights[i - 1], v = values[i - 1]; for (int j = 1; j &lt;= W; ++j) { if (j &gt;= w) { dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w] + v); } else { dp[i][j] = dp[i - 1][j]; } } } return dp[N][W];} ç”¨è‡ªå·±çš„è¯è¯´ï¼Œé—®é¢˜å°±æ˜¯æœ‰nç§ç‰©å“ï¼Œæ¯ç§ç‰©å“æœ‰1ä¸ªï¼ŒèƒŒåŒ…æœ‰æ€»å®¹é‡é™åˆ¶ï¼Œæ¯ç§ç‰©å“æœ‰ä¸€å®šä»·å€¼ã€‚æ€æ ·è£…å…¥ç‰©å“ï¼Œåœ¨å®¹é‡é™åˆ¶ä¸‹ï¼Œå°½é‡è®©èƒŒåŒ…ä»·å€¼æœ€å¤§$ dp[i][j] $ è¡¨ç¤ºå½“éå†åˆ°ç¬¬iä¸ªç‰©å“æ—¶ï¼ŒèƒŒåŒ…å®¹é‡ä¸ºjæ—¶ï¼ˆå¯ä»¥ä¸æ»¡ï¼‰ï¼ŒèƒŒåŒ…çš„æœ€å¤§ä»·å€¼æ‰€ä»¥çŠ¶æ€è½¬ç§»å‡½æ•°æ˜¯$$dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w_{i-1}] + v_{i-1}), \\quad j&gt;=w_{i-1} $$$$dp[i][j] = dp[i - 1][j], \\quad j &lt; w_{i-1}$$ 0-1èƒŒåŒ…çš„å‹ç¼© 12345678910int knapsack(vector&lt;int&gt; weights, vector&lt;int&gt; values, int N, int W) { vector&lt;int&gt; dp(W + 1, 0); for (int i = 1; i &lt;= N; ++i) { int w = weights[i - 1], v = values[i - 1]; for (int j = W; j &gt;= w; --j) { dp[j] = max(dp[j], dp[j - w] + v); } } return dp[W];} å®Œå…¨èƒŒåŒ…123456789101112131415int knapsack(vector&lt;int&gt; weights, vector&lt;int&gt; values, int N, int W) { vector&lt;vector&lt;int&gt;&gt; dp(N + 1, vector&lt;int&gt;(W + 1, 0)); for (int i = 1; i &lt;= N; ++i) { int w = weights[i - 1], v = values[i - 1]; for (int j = 1; j &lt;= W; ++j) { if (j &gt;= w) { dp[i][j] = max(dp[i - 1][j], dp[i][j - w] + v); } else { dp[i][j] = dp[i - 1][j]; } } } return dp[N][W];} å’Œ0-1èƒŒåŒ…ä¸åŒçš„æ˜¯ï¼Œæ¯ä¸ªç‰©å“æœ‰æ— é™ä¸ªï¼Œå› æ­¤ä¹Ÿéœ€è¦æ­£å‘éå†ï¼Œä¸”çŠ¶æ€è½¬ç§»å‡½æ•°ä¸­ï¼Œåº”è¯¥æ˜¯åŒåˆ—ä¸­+ç‰©å“ä»·å€¼ï¼Œè¿™æ ·æ‰èƒ½å‘èƒŒåŒ…ä¸­æ”¾å…¥å¤šä¸ªç‰©å“çŠ¶æ€è½¬ç§»å‡½æ•°æ˜¯$$dp[i][j] = max(dp[i - 1][j], dp[i][j - w_{i-1}] + v_{i-1}), \\quad j&gt;=w_{i-1} $$$$dp[i][j] = dp[i - 1][j], \\quad j &lt; w_{i-1}$$ å®Œå…¨èƒŒåŒ…çš„ç©ºé—´å‹ç¼©12345678910int knapsack(vector&lt;int&gt; weights, vector&lt;int&gt; values, int N, int W) { vector&lt;int&gt; dp(W + 1, 0); for (int i = 1; i &lt;= N; ++i) { int w = weights[i - 1], v = values[i - 1]; for (int j = w; j &lt;= W; ++j) { dp[j] = max(dp[j], dp[j - w] + v); } } return dp[W];} 101ä¹¦ä¸­è¯´ â€œ0-1 èƒŒåŒ…å¯¹ç‰©å“çš„è¿­ä»£æ”¾åœ¨å¤–å±‚ï¼Œé‡Œå±‚çš„ä½“ç§¯æˆ–ä»·å€¼é€†å‘éå†ï¼›å®Œå…¨èƒŒåŒ…å¯¹ç‰©å“çš„è¿­ä»£æ”¾åœ¨é‡Œå±‚ï¼Œå¤–å±‚çš„ä½“ç§¯æˆ–ä»·å€¼æ­£å‘éå†ã€‚â€ ä½†æˆ‘è®¤ä¸ºï¼Œå®Œå…¨èƒŒåŒ…æ­£å‘éå†ä½“ç§¯ï¼Œ0-1èƒŒåŒ…åå‘éå†ä½“ç§¯ï¼Œå†…å±‚å’Œå¤–å±‚éå†ç‰©å“è¿˜æ˜¯å®¹é‡å¹¶æ²¡æœ‰å½±å“ 416. åˆ†å‰²ç­‰å’Œå­é›†1234567891011121314151617class Solution {public: bool canPartition(vector&lt;int&gt;&amp; nums) { int sum = accumulate(nums.begin(), nums.end(), 0); if(sum &amp; 1) return false; int target = sum/2; int n = nums.size(); vector&lt;int&gt; dp(target+1, 0); for(int i = 1; i &lt;= n; i++) { int w = nums[i-1], v = nums[i-1]; for(int j = target; j&gt;=w; j--) { dp[j] = max(dp[j], dp[j-w] + v); } } return dp[target] == sum-target; }}; çœ‹äº†ä¸€çœ¼ç­”æ¡ˆçš„æ€è·¯ï¼ŒçŸ¥é“èƒŒåŒ…æ€»å®¹é‡æ˜¯ $ sum/2 $ æ‰å†™å‡ºæ¥ 101123456789101112131415161718class Solution {public: bool canPartition(vector&lt;int&gt;&amp; nums) { int sum = accumulate(nums.begin(), nums.end(), 0); if(sum &amp; 1) return false; int target = sum/2; int n = nums.size(); vector&lt;bool&gt; dp(target+1, false); dp[0] = true; for(int i = 1; i &lt;= n; i++) { int w = nums[i-1]; for(int j = target; j&gt;=w; j--) { dp[j] = dp[j] || dp[j-w]; } } return dp[target]; }}; å¦‚æœæ”¾å…¥æ•°nums[i]åï¼ŒèƒŒåŒ…å®¹é‡å˜æˆ0äº†ï¼Œé‚£ä¹ˆè¯´æ˜å¯ä»¥è£…æ»¡èƒŒåŒ… 474. ä¸€å’Œé›¶123456789101112131415161718class Solution {public: int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) { int strnum = strs.size(); vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for(int i = 1; i &lt;= strnum; i++) { int strlen = strs[i-1].size(); int count0, count1 = accumulate(strs[i-1].begin(), strs[i-1].end(), -strlen*'0'); count0 = strlen-count1; for(int j = m; j &gt;= count0; j--) { for(int k = n; k &gt;= count1; k--) { dp[j][k] = max(dp[j][k], dp[j-count0][k-count1]+1); } } } return dp[m][n]; }}; å–µäº†ä¸€çœ¼ç­”æ¡ˆè¯´è¦ç”¨äºŒç»´èƒŒåŒ…ï¼Œå°±å†™äº†ï¼Œå°±è¿‡äº†ä½†æ˜¯è¿˜æ˜¯æ™•æ™•çš„ï¼Œæ„Ÿè§‰åªæ˜¯åœ¨å¥—æ¨¡æ¿ 322. é›¶é’±å…‘æ¢123456789101112131415161718192021class Solution {public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { int coinTypes = coins.size(); vector&lt;vector&lt;int&gt;&gt; dp(coinTypes+1, vector&lt;int&gt;(amount+1, 0)), dp1(coinTypes+1, vector&lt;int&gt;(amount+1, 0)); for(int i = 1; i &lt;= coinTypes; i++) { dp[i][0] = amount; int w = coins[i-1]; for(int j = 1; j &lt;= amount; j++) { if(j &gt;= w) { dp[i][j] = max(dp[i-1][j], dp[i][j-w]-1); dp1[i][j] = max(dp1[i-1][j], dp1[i][j-w]+w); } else { dp[i][j] = dp[i-1][j]; dp1[i][j] = dp1[i-1][j]; } } } return (dp1[coinTypes][amount] == amount) ? amount - dp[coinTypes][amount] : -1; }}; å¤ªæ…¢äº†ï¼Œéå¸¸ç®€å•çš„æƒ³æ³•ï¼Œä¸€ä¸ªè®°å½•ç”¨äº†å¤šå°‘ç¡¬å¸ï¼Œä¸€ä¸ªè®°å½•å½“å‰èƒŒåŒ…å†…æ€»ä»·å€¼ ç©ºé—´å‹ç¼©12345678910111213141516class Solution {public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { int coinTypes = coins.size(); vector&lt;int&gt; dp(amount+1, 0), dp1(amount+1, 0); dp[0] = amount; for(int i = 1; i &lt;= coinTypes; i++) { int w = coins[i-1]; for(int j = w; j &lt;= amount; j++) { dp[j] = max(dp[j], dp[j-w]-1); dp1[j] = max(dp1[j], dp1[j-w]+w); } } return (dp1[amount] == amount) ? amount - dp[amount] : -1; }}; 101123456789101112131415class Solution {public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { int coinTypes = coins.size(); vector&lt;int&gt; dp(amount+1, amount+1); dp[0] = 0; for(int i = 1; i &lt;= amount; i++) { for(int j = 1; j &lt;= coinTypes; j++) { int w = coins[j-1]; if(i &gt;= w) dp[i] = min(dp[i], dp[i-w]+1); } } return (dp[amount] == amount+1) ? -1 : dp[amount]; }}; ç¡¬å¸çš„ä»·å€¼ä¸ç”¨-1è€Œç”¨1ï¼Œdpè¡¨ç¤ºç¡¬å¸æ•°ï¼Œæ‰¾minï¼Œé‚£ä¹ˆdpåˆå€¼å°±ä¸èƒ½æ˜¯0æ— é™èƒŒåŒ…ï¼Œå¤–å±‚å®¹é‡ï¼Œå†…å±‚ç‰©å“, è¿™é‡Œæ²¡æœ‰ç†è§£å¦‚æœdp[amount]æ˜¯amount+1ï¼Œè¯´æ˜æ²¡æœ‰å¡«æ»¡ï¼Œå¦‚æœå¡«æ»¡äº†ï¼Œç¡¬å¸æ•°é‡ä¸€å®šå°äºamount+1 123456789101112131415class Solution {public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { int coinTypes = coins.size(); vector&lt;int&gt; dp(amount+1, amount+1); dp[0] = 0; for(int i = 1; i &lt;= coinTypes; i++) { int w = coins[i-1]; for(int j = w; j &lt;= amount; j++) { dp[j] = min(dp[j], dp[j-w]+1); } } return (dp[amount] == amount+1) ? -1 : dp[amount]; }}; å†…å±‚å®¹é‡ï¼Œå¤–å±‚ç‰©å“ä¹Ÿèƒ½è¿‡ï¼Œè¿˜å¯ä»¥å¿«ä¸€ç‚¹ å­—ç¬¦ä¸²ç¼–è¾‘72. ç¼–è¾‘è·ç¦»1234567891011121314151617181920class Solution {public: int minDistance(string word1, string word2) { int len1 = word1.size(), len2 = word2.size(); vector&lt;vector&lt;int&gt;&gt; dp(len1+1, vector&lt;int&gt;(len2+1, 0)); for(int i = 0; i &lt;= len1; i++) { dp[i][0] = i; } for(int i = 0; i &lt;= len2; i++) { dp[0][i] = i; } for(int i = 1; i &lt;= len1; i++) { for(int j = 1; j &lt;= len2; j++) { int x = int(word1[i-1] != word2[j-1]); dp[i][j] = min(x + dp[i-1][j-1], min(dp[i-1][j]+1, dp[i][j-1]+1)); } } return dp[len1][len2]; }}; 650. åªæœ‰ä¸¤ä¸ªé”®çš„é”®ç›˜123456789101112131415class Solution {public: int minSteps(int n) { vector&lt;int&gt; dp(n+1, 0); for(int i = 2; i &lt;= n; i++) { dp[i] = i; for(int j = 2; j &lt;= i; j++) { if(i%j == 0) { dp[i] = min(dp[i], dp[j]+i/j); } } } return dp[n]; }}; å¤æ‚åº¦ä¸º $ n^2 $ 123456789101112131415class Solution {public: int minSteps(int n) { vector&lt;int&gt; dp(n+1, 0); for(int i = 2; i &lt;= n; i++) { dp[i] = i; for(int j = 2; j*j &lt;= i; j++) { if(i%j == 0) { dp[i] = dp[j] + dp[i/j]; } } } return dp[n]; }}; å¦‚æœj å¯ä»¥è¢«i æ•´é™¤ï¼Œé‚£ä¹ˆé•¿åº¦i å°±å¯ä»¥ç”±é•¿åº¦j æ“ä½œå¾—åˆ°ï¼Œå…¶æ“ä½œæ¬¡æ•°ç­‰ä»·äºæŠŠä¸€ä¸ªé•¿åº¦ä¸º1çš„A å»¶å±•åˆ°é•¿åº¦ä¸ºi/j","link":"/home/2022/11/08/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93dp/"},{"title":"LeetCode-æ•°æ®åº“-1","text":"181. è¶…è¿‡ç»ç†æ”¶å…¥çš„å‘˜å·¥æ€è·¯ Employeeè¡¨ä¸­ç»™å‡ºå‘˜å·¥idï¼Œå‘˜å·¥çš„managerçš„id æŒ‰ç…§manageridå’Œå‘˜å·¥idè‡ªè¿æ¥ä¸€ä¸‹ï¼Œä½¿ç”¨å†…è¿æ¥å»æ‰null ç­›é€‰å‘˜å·¥å·¥èµ„å¤§äºç®¡ç†å‘˜å·¥èµ„çš„ çŸ¥è¯†ç‚¹ åˆ¤æ–­ç›¸ç­‰ç”¨å•å¼•å· ä»£ç 12345SELECT E1.name AS EmployeeFROM Employee E1 INNER JOIN Employee E2 ON E1.managerId = E2.id AND E1.salary &gt; E2.salary 182. æŸ¥æ‰¾é‡å¤çš„ç”µå­é‚®ç®±çŸ¥è¯†ç‚¹ group by æ ¹æ®å…ƒç»„è¿›è¡Œåˆ†ç»„ having æ ¹æ®æ¡ä»¶å°†èšåˆåçš„åˆ†ç»„è¿›è¡Œç­›é€‰ï¼ˆå¯å¦ç†è§£ä¸ºå¯¹åˆ†ç»„æ•´ä½“çš„whereè¯­å¥ï¼Ÿï¼‰ ä»£ç 1234SELECT EmailFROM PersonGROUP BY emailHAVING count(email) &gt; 1; 183. ä»ä¸è®¢è´­çš„å®¢æˆ·æ€è·¯ ä¸€ä¸ªé¡¾å®¢è¡¨ï¼Œä¸€ä¸ªè®¢å•è¡¨ é¡¾å®¢è¡¨å’Œè®¢å•è¡¨å·¦è¿æ¥ï¼ŒæŒ‰ç…§é¡¾å®¢idè¿æ¥ æ²¡æœ‰è®¢å•çš„é¡¾å®¢é€šè¿‡å·¦è¿æ¥ä¼šäº§ç”Ÿnullï¼Œç”¨whereæ‰¾å‡ºå«æœ‰nullçš„è¡Œ çŸ¥è¯†ç‚¹ å·¦è¿æ¥ï¼Œå³è¾¹å­˜åœ¨nullä¾ç„¶ä¿ç•™å·¦è¾¹ï¼Œå·¦è¾¹æœ‰nullå°±ä¸ä¿ç•™ å³è¿æ¥ï¼Œå³è¾¹å­˜åœ¨nullä¸ä¿ç•™å·¦è¾¹ï¼Œå³è¾¹æœ‰nullå°±ä¸ä¿ç•™ å†…è¿æ¥ï¼Œä¸è®ºå·¦å³ï¼Œæœ‰nullå°±ä¸ä¿ç•™ ä»£ç 123SELECT name AS CustomersFROM Customers LEFT JOIN Orders O ON O.customerId = Customers.id WHERE O.customerId IS NULL; 196. åˆ é™¤é‡å¤çš„ç”µå­é‚®ç®±æ€è·¯ å¯¹äºæœ‰é‡å¤çš„emailï¼Œä¿ç•™idæœ€å°çš„ä¸€é¡¹ï¼Œåˆ é™¤å‰©ä½™çš„é‡å¤é¡¹ ä¾ç…§emailè¿›è¡Œgroup by ä½¿ç”¨minæ‰¾åˆ°æ¯ä¸ªemailçš„æœ€å°å€¼ å°†ä¸Šé¢çš„ç»“æœä½œä¸ºå­æŸ¥è¯¢ï¼Œè‹¥idä¸åœ¨å…¶ä¸­ï¼Œåˆ™åˆ é™¤ ä¸å…è®¸åˆ é™¤è¡¨æ—¶å¯¹è¡¨ä½œæŸ¥è¯¢ï¼Œéœ€è¦å†åµŒå¥—ä¸€å±‚å­æŸ¥è¯¢ çŸ¥è¯†ç‚¹ å­æŸ¥è¯¢å¿…é¡»æŒ‡å®šåˆ«åç´§è·Ÿåœ¨å­æŸ¥è¯¢çš„æ‹¬å·åé¢ ä¸€èˆ¬æ¥è¯´ï¼ŒDELETE FROM XXX WHERE &lt;-condition-&gt; ä»£ç 12345678DELETE FROM PersonWHERE id NOT IN (SELECT T.id FROM (SELECT MIN(id) as id FROM Person GROUP BY email) T);-- ä¸å…è®¸åˆ é™¤ä¸æŸ¥è¯¢åœ¨åŒä¸€ä¸ªè¡¨ä¸ŠDELETE FROM PersonWHERE id NOT IN (SELECT MIN(id) as id FROM Person GROUP BY email); 197. ä¸Šå‡çš„æ¸©åº¦æ€è·¯ å¦‚æœç¬¬äºŒå¤©æ¸©åº¦æ¯”ç¬¬ä¸€å¤©é«˜ï¼Œå°±è¾“å‡º åŒä¸€å¼ è¡¨è‡ªè¿æ¥ï¼Œç­›é€‰å‡ºæ—¥æœŸç›¸å·®ä¸€å¤©ä¸”æ¸©åº¦å‡é«˜çš„ çŸ¥è¯†ç‚¹1FROM A, B, C, ... WHERE &lt;-condition-&gt; ç›¸å½“äºå¯¹æ‰€æœ‰è¡¨å…¨è¿æ¥ï¼Œç„¶åæ ¹æ®WHEREç­›é€‰ 1FROM A XXX JOIN B ON &lt;-condition1-&gt; XXX JOIN C ON &lt;-condition2-&gt; ... ç›¸å½“ä¾æ¬¡è¿æ¥å„ä¸ªè¡¨ï¼Œä¸”å¯ä»¥æ§åˆ¶è¿æ¥çš„æ–¹å¼ï¼ˆå·¦ã€å³ã€å…¨ï¼‰ï¼Œå¹¶æ ¹æ®æ¡ä»¶ç­›é€‰ timestampdiff(expr, date1, date2) æ ¹æ®exprè®¡ç®—ä¸¤ä¸ªdateçš„å·®å€¼ å¦‚æœexpræ˜¯dayï¼Œå°±æ˜¯ç®—å·®è·å¤šå°‘å¤© ä»£ç 1234SELECT W2.idFROM Weather W1 JOIN Weather W2ON timestampdiff(day, W2.recordDate, W1.recordDate) = -1AND W2.temperature &gt; W1.temperature; 1234SELECT W2.idFROM Weather W1, Weather W2WHERE timestampdiff(day, W2.recordDate, W1.recordDate) = -1AND W2.temperature &gt; W1.temperature; 511. æ¸¸æˆç©æ³•åˆ†æ Iæ€è·¯ æ‰¾åˆ°æ¯ä¸ªç”¨æˆ·ç¬¬ä¸€æ¬¡ç™»å½•çš„æ—¶é—´ group byç”¨æˆ·idï¼Œç„¶åé€šè¿‡minè®¡ç®—æœ€å°æ—¥æœŸ ä»£ç 123SELECT player_id, min(event_date) AS first_loginFROM ActivityGROUP BY player_id 550. æ¸¸æˆç©æ³•åˆ†æ IVæ€è·¯ åˆ¤æ–­æœ‰å¤šå°‘ç”¨æˆ·åœ¨ç¬¬ä¸€æ¬¡ç™»å½•åçš„ç¬¬äºŒå¤©ä¹Ÿç™»å½•æ¸¸æˆäº† åˆ›å»ºå­æŸ¥è¯¢æŸ¥æ‰¾æ¯ä¸ªç”¨æˆ·çš„ç¬¬ä¸€æ¬¡ç™»å½•æ—¶é—´ å­æŸ¥è¯¢ä¸ç”¨æˆ·ç™»å½•æ—¶é—´è¡¨å·¦è¿æ¥ï¼ŒæŒ‰ç…§ç”¨æˆ·id æ‰¾åˆ°ç™»å½•æ—¥æœŸä¸ç¬¬ä¸€æ¬¡ç™»å½•æ—¶é—´ç›¸å·®1å¤©çš„è¡Œï¼Œå¦‚æœç¬¬äºŒå¤©ç™»é™†äº†ï¼Œåˆ™ç™»å½•æ—¶é—´éç©ºï¼Œå¦åˆ™ç™»å½•æ—¶é—´ä¸ºç©º ç»Ÿè®¡ç™»å½•æ—¶é—´ä¸ºç©ºçš„ä¸ªæ•°ï¼Œé™¤ä»¥æ€»ç”¨æˆ·ä¸ªæ•° çŸ¥è¯†ç‚¹ ADDDATE(date, expr) æ ¹æ®expråœ¨dateçš„åŸºç¡€ä¸Šç›¸åŠ  expr = INTERVAL 1 DAYè¡¨ç¤ºåœ¨dateçš„åŸºç¡€ä¸ŠåŠ ä¸€å¤© ROUND(number, n) numberç²¾ç¡®åˆ°å°æ•°ç‚¹ånä½ ä»£ç 12345678SELECT ROUND(count(event_date)/count(First_Login.player_id), 2) AS fractionFROM ( SELECT player_id, min(event_date) AS first_login FROM Activity GROUP BY player_id) First_Login LEFT JOIN ActivityON First_Login.player_id = Activity.player_idAND ADDDATE(First_Login.first_login, INTERVAL 1 DAY) = Activity.event_date 180. è¿ç»­å‡ºç°çš„æ•°å­—æ€è·¯ è¡¨æ ¼è‡ªè¿æ¥ä¸‰æ¬¡ï¼Œç­›é€‰å‡ºidé€’å¢ä¸”numä¸€æ ·çš„ ä»£ç 12345678910SELECT DISTINCT L3.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3WHERE L1.id = L2.id-1 AND L1.num = L2.num AND L2.id = L3.id-1 AND L2.num = L3.num 178. åˆ†æ•°æ’å å¯¹åˆ†æ•°è¿›è¡Œæ’åºï¼Œå¹¶ç»™å‡ºæ’åï¼ŒåŒåˆ†åŒæ’ æ€è·¯1+çŸ¥è¯†ç‚¹ row_number() + over(ORDER BY column_name [desc])å‡½æ•°å¯ä»¥æŒ‰ç…§åˆ—æ’åºï¼Œå¹¶ç»™å‡ºè¡Œå· ä½†è¡Œå·ä¸èƒ½å®ç°åŒåˆ†åŒæ’ æŒ‰ç…§åˆ†æ•°GROUP BYï¼Œç„¶årow_number + overè®¡ç®—å‡ºæ¯ä¸ªåˆ†æ•°å¯¹åº”çš„æ’åº å°†ä¸Šé¢çš„å†…å®¹ä½œä¸ºå­æŸ¥è¯¢ï¼Œä¸æˆç»©è¡¨ç›¸è¿æ¥ï¼Œå°±å¯ä»¥å¾—åˆ°åŒåˆ†åŒæ’åäº† ä»£ç 1234567SELECT T.score, T.rank FROM ( SELECT score, (row_number() over(ORDER BY score DESC)) AS 'rank' FROM Scores GROUP BY score ORDER BY score DESC) T INNER JOIN Scores on T.score = Scores.scoreORDER BY score DESC æ€è·¯2+çŸ¥è¯†ç‚¹ dense_rank() + over() å¯ä»¥ç»™å‡ºåŒåˆ†åŒæ’å 123SELECT score, dense_rank() over(ORDER BY score DESC) AS 'rank'FROM ScoresORDER BY score DESC 184. éƒ¨é—¨å·¥èµ„æœ€é«˜çš„å‘˜å·¥æ€è·¯1 å­æŸ¥è¯¢ï¼Œé€šè¿‡group byæ‰¾å‡ºæ¯ä¸ªéƒ¨é—¨æœ€å¤§salary ä¸å‘˜å·¥è¡¨è¿æ¥ï¼Œç­›é€‰å‡ºéƒ¨é—¨idç›¸åŒï¼Œè–ªèµ„ä¸éƒ¨é—¨æœ€é«˜è–ªèµ„ç›¸åŒçš„è¡Œ 12345678SELECT T.Department, E.name AS Employee, T.SalaryFROM Employee E INNER JOIN ( SELECT D.id as DID, D.name AS Department, E.name AS Employee, MAX(E.salary) AS Salary FROM Employee E JOIN Department D ON E.departmentId = D.id GROUP BY E.departmentId) T ON T.Salary = E.salary AND T.DID = E.departmentId; æ€è·¯2 å­æŸ¥è¯¢ï¼Œé€šè¿‡group byæ‰¾å‡ºæ¯ä¸ªéƒ¨é—¨æœ€å¤§salary å‘˜å·¥è¡¨å•Šä¸éƒ¨é—¨è¡¨åˆå¹¶ï¼Œè‹¥(å‘˜å·¥è–ªæ°´, éƒ¨é—¨id)å­˜åœ¨äºå­æŸ¥è¯¢ä¸­ï¼Œåˆ™ç­›é€‰å‡ºæ¥ 12345678910111213141516SELECT Department.name AS 'Department', Employee.name AS 'Employee', SalaryFROM Employee JOIN Department ON Employee.DepartmentId = Department.IdWHERE (Employee.DepartmentId , Salary) IN ( SELECT DepartmentId, MAX(Salary) FROM Employee GROUP BY DepartmentId ) 176. ç¬¬äºŒé«˜çš„è–ªæ°´æ€è·¯1 + çŸ¥è¯†ç‚¹ IFNULL(a, b) å¦‚æœaæ˜¯NULLåˆ™å€¼æ›¿æ¢ä¸ºb LIMIT Nï¼Œåªé€‰å‡ºå‰Nä¸ªï¼ˆæœ€å¤šNä¸ªï¼‰ LIMIT M OFFSET Mï¼Œä»ç¬¬Mä¸ªå¼€å§‹é€‰å‡ºNä¸ªï¼ˆæœ€å¤šNä¸ªï¼‰ LIMIT 1 OFFSET 1åˆ™è¡¨ç¤ºç¬¬äºŒä¸ªï¼Œå¦‚æœæ²¡æœ‰ç¬¬äºŒä¸ªï¼Œè¿”å›ç©ºåˆ—è¡¨ å­æŸ¥è¯¢æ ¹æ®salaryæ’åºï¼Œä½¿ç”¨LIMIT 1 OFFSET 1æ‰¾å‡ºç¬¬äºŒä¸ª å¦‚æœæ²¡æœ‰ç¬¬äºŒä¸ªéœ€è¦è¿”å›NULLï¼Œåˆ™æ ¹æ® é¢˜ç›®éœ€è¦è¿”å›åˆ—è¡¨ä¸ºæŒ‡å®šåç§°ï¼Œé€šè¿‡AS åˆ«åå¯ä»¥ä¸ºåˆ—å–åˆ«å 1234SELECT IFNULL( (SELECT DISTINCT salary FROM Employee ORDER BY salary DESCLIMIT 1 OFFSET 1), NULL) AS SecondHighestSalary æ€è·¯2 + çŸ¥è¯†ç‚¹ å­æŸ¥è¯¢é€šè¿‡maxæ‰¾åˆ°æœ€å¤§çš„ åŒwhereç­›é€‰æ‰€æœ‰å°äºmaxçš„ å¯¹æ‰€æœ‰å°äºmaxçš„è¡Œï¼Œå†æ¬¡ä½¿ç”¨maxï¼Œè·å¾—ç¬¬äºŒå¤§çš„12SELECT MAX(salary) AS SecondHighestSalary FROM EmployeeWHERE salary &lt; (SELECT MAX(salary) FROM Employee) 177. ç¬¬Né«˜çš„è–ªæ°´ è¿™é“é¢˜éœ€è¦æˆ‘ä»¬å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œå‚æ•°æ˜¯N ä¸ä¸Šä¸€é¢˜ä¸€æ ·ï¼Œé€šè¿‡LIMIT 1 OFFSET M OFFSETåé¢ä¸èƒ½è·Ÿè¡¨è¾¾å¼ éœ€è¦å£°æ˜ä¸€ä¸ªæ–°å˜é‡MDECLARE M INT; å¹¶ç½®å€¼ä¸ºN-1SET M = N-1; é€šè¿‡returnè¯­å¥è¿”å›12345678CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGINDECLARE M INT; SET M = N-1; RETURN ( SELECT IFNULL((SELECT DISTINCT salary FROM Employee ORDER BY salary DESC LIMIT 1 OFFSET M), NULL) );END 185. éƒ¨é—¨å·¥èµ„å‰ä¸‰é«˜çš„æ‰€æœ‰å‘˜å·¥çŸ¥è¯†ç‚¹ count(column_name): è®¡ç®—åˆ—ä¸­énullçš„ä¸ªæ•° count(distinct column_name): è®¡ç®—åˆ—ä¸­énullçš„äº’ä¸ç›¸åŒçš„ä¸ªæ•° count(*): ç»Ÿè®¡æ€»è¡Œæ•°ï¼ŒåŒ…æ‹¬NULLå’Œé‡å¤çš„ count(1), count(2), â€¦ 1,2,â€¦ è¡¨ç¤ºæ’çœŸè¡¨è¾¾å¼ è®°å½•æ€»æ•°ï¼ŒåŒ…æ‹¬é‡å¤å’ŒNULL having count(xxx) &gt; 0 ç›¸å½“äºå°†å€¼ä¸ºNULLçš„ç­›é€‰å‡ºå»ï¼Œå¦‚æœæ•´ä¸ªåˆ†ç»„ç©ºäº†ï¼Œå°±ç§»é™¤æ•´ä¸ªåˆ†ç»„ having count(xxx) &lt;= N ç›¸å½“äºå°†ç»„å†…å¤šäºNä¸ªçš„è¡Œåˆ é™¤ ?: havingç›¸å½“äºï¼Œè‹¥ç»„æ»¡è¶³æ¡ä»¶ï¼Œåˆ™æ•´ç»„ç•™ä¸‹ï¼Œè‹¥ä¸æ»¡è¶³ï¼Œåˆ™å»æ‰ä¸æ»¡è¶³çš„è¡Œï¼Œç›´åˆ°ç»„æ»¡è¶³ä¸ºæ­¢ æ€è·¯ æ‰¾å‡ºå„éƒ¨é—¨å‰ä¸‰é«˜çš„ä¸åŒå·¥èµ„ é€šè¿‡havingç­›é€‰ ä»£ç 12345SELECT D.name AS Department, E.name AS Employee, E.salary AS SalaryFROM Employee E, Department AS D, Employee E2WHERE D.id = E.departmentId AND E2.departmentId = E.departmentId AND E.salary &lt;= E2.salarygroup by D.ID,E.Name having count(distinct E2.Salary) &lt;= 3order by D.Name, E.Salary desc 262. è¡Œç¨‹å’Œç”¨æˆ·çŸ¥è¯†ç‚¹1count(CASE WHEN condition THEN A ELSE B END) æ ¹æ®æ¡ä»¶ï¼Œè‹¥æŸä¸€è¡Œæ»¡è¶³æ¡ä»¶ï¼Œåˆ™è¯¥è¡Œç»Ÿè®¡æ˜¯ï¼ŒæŒ‰ç…§å€¼Aï¼Œå¦åˆ™æŒ‰ç…§å€¼B ç»Ÿè®¡éNULLçš„ä¸ªæ•°ï¼Œæ‰€ä»¥ä¸€èˆ¬Aå’ŒBä¸­ä¸€ä¸ªä¸ºNULLä¸€ä¸ªä¸ºéNULL æ€è·¯ å…ˆå°†è·¯ç¨‹è¡¨ï¼Œç”¨æˆ·è¡¨æ ¹æ®å¸æœºidï¼Œä¹˜å®¢idå’Œç”¨æˆ·idè¿›è¡Œè¿æ¥ï¼Œæ’é™¤è¢«ç¦ç”¨æˆ·çš„è®¢å•ï¼Œæ’é™¤æ‰æ—¶é—´åœ¨2023-10-01åˆ°2013-10-03ä¹‹å¤–çš„è®¢å• ä½¿ç”¨count(status)ç­›é€‰å‡ºåˆ†æ¯ ä½¿ç”¨count(case when then else end)ç­›é€‰å‡ºåˆ†å­ ä»£ç 1234567891011SELECT T.request_at AS Day, ROUND(sum(CASE WHEN T.status = 'completed' THEN 0 ELSE 1 END) / count(T.status), 2) AS 'Cancellation Rate'FROM Trips T LEFT JOIN Users U1ON T.client_id = U1.users_idLEFT JOIN Users U2ON T.driver_id = U2.users_idWHERE U1.banned = 'No' AND U2.banned = 'No'AND T.request_at BETWEEN DATE(&quot;2013-10-01&quot;) AND DATE(&quot;2013-10-03&quot;)GROUP BY T.request_at SQLæ€§èƒ½ä¼˜åŒ– ç¥å¥‡çš„ SQL ä¹‹æ€§èƒ½ä¼˜åŒ– â†’ è®© SQL é£èµ·æ¥ ç”¨EXISTSä»£æ›¿IN ä½¿ç”¨INä¼šäº§ç”Ÿä¸€å¼ ä¸´æ—¶è¡¨ï¼ˆå†…è”è§†å›¾ï¼‰ï¼Œä¸”åœ¨åŒ¹é…æ—¶ä¼šæ‰«æå…¨è¡¨ ä½¿ç”¨EXISTSä¸ä¼šäº§ç”Ÿä¸´æ—¶è¡¨ï¼Œåœ¨åŒ¹é…æ—¶ä¸ä¼šæ‰«æå…¨è¡¨ï¼Œæ»¡è¶³æ¡ä»¶åˆ™åœæ­¢ ç”¨è¿æ¥æ›¿ä»£IN åœ¨æœ‰ç´¢å¼•æ—¶ï¼Œè¿æ¥ä¸EXISTSæ€§èƒ½ç›¸è¿‘ æ²¡æœ‰ç´¢å¼•ï¼ŒEXISTSæ›´å¥½ é¿å…æ’åº å¾ˆå¤šå…³é”®å­—éƒ½å­˜åœ¨æ’åºçš„è¿‡ç¨‹ ORDER BY GROUP BY DISTINCT èšåˆå‡½æ•°(MIN,MAX,SUM,AVG,COUNT) é›†åˆå‡½æ•°(UNION,INTERSECT,EXCEPT) ä¸ºäº†å»é‡è€Œæ’åº ä½¿ç”¨(UNION ALL,INTERSECT ALL,EXCEPT ALL)ä¸å»é‡ çª—å£å‡½æ•°(row_number, rankç­‰) ä½¿ç”¨ EXISTS ä»£æ›¿ DISTINCTèƒ½å†™åœ¨whereä¸­çš„æ¡ä»¶ä¸è¦å†™åœ¨havingé‡Œåœ¨æå€¼å‡½æ•°ä¸­ä½¿ç”¨ç´¢å¼• minï¼Œmaxä¼šå…¨è¡¨æ‰«æ+æ’åº å¯¹éœ€è¦æ±‚min,maxçš„åˆ—åˆ›å»ºç´¢å¼•ï¼ŒåŠ å¿«æŸ¥æ‰¾é€Ÿåº¦ åœ¨ GROUP BY å­å¥å’Œ ORDER BY å­å¥ä¸­ä½¿ç”¨ç´¢å¼•ä½¿ç”¨ç´¢å¼• ç¥å¥‡çš„ SQL ä¹‹æ“¦è‚©è€Œè¿‡ â†’ çœŸçš„ç”¨åˆ°ç´¢å¼•äº†å— å‡å°‘ä¸´æ—¶è¡¨ ä¸´æ—¶è¡¨ä¼šæ¶ˆè€—å†…å­˜èµ„æº ä¸´æ—¶è¡¨æœ‰æ—¶æ— æ³•ç»§æ‰¿ç´¢å¼•ï¼Œå¯¼è‡´æ•ˆç‡ä½ä¸‹ å°½é‡ä½¿ç”¨havingè€Œä¸æ˜¯ä¸´æ—¶è¡¨éœ€è¦å¯¹å¤šä¸ªå­—æ®µä½¿ç”¨INè°“è¯æ—¶ï¼Œå°†å®ƒä»¬æ±‡æ€»åˆ°ä¸€å¤„12345678910111213141516171819202122232425262728293031select Afrom tableA A1where col1 in ( select col1 from tableA A2 where A1.xxx = A2.xxx) and col2 in ( select col2 from tableA A2 where A1.xxx = A2.xxx) and col3 in ( select col2 from tableA A2 where A1.xxx = A2.xxx)-- å¯ä»¥ä¼˜åŒ–ä¸ºselect Afrom tableA A1where col1 || col2 || col3in ( select col1 || col2 || col3 from tableA A2)-- orselect Afrom tableA A1where (col1, col2, col3)in ( select col1, col2, col3 from tableA A2) å…ˆè¿›è¡Œè¿æ¥å†è¿›è¡Œèšåˆå®šä¹‰è§†å›¾æ—¶é¿å…é›†åˆå‡½æ•°å’Œèšåˆå‡½æ•°","link":"/home/2024/03/03/LeetCode/LeetCode-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%931/"},{"title":"LeetCode-å¤šçº¿ç¨‹-1","text":"1115. äº¤æ›¿æ‰“å° FooBarä¿¡å·é‡12345678910111213141516171819202122232425262728293031class FooBar { private int n; private Semaphore fooSem, barSem; public FooBar(int n) { this.n = n; fooSem = new Semaphore(1); barSem = new Semaphore(0); } public void foo(Runnable printFoo) throws InterruptedException { for (int i = 0; i &lt; n; i++) { // printFoo.run() outputs &quot;foo&quot;. Do not change or remove this line. fooSem.acquire(); printFoo.run(); barSem.release(); } } public void bar(Runnable printBar) throws InterruptedException { for (int i = 0; i &lt; n; i++) { // printBar.run() outputs &quot;bar&quot;. Do not change or remove this line. barSem.acquire(); printBar.run(); fooSem.release(); } }} æ¡ä»¶å˜é‡12345678910111213141516171819202122232425262728293031323334353637383940414243class FooBar { private int n; Lock lock; Condition condition; boolean fooOrBar = true; public FooBar(int n) { this.n = n; lock = new ReentrantLock(); condition = lock.newCondition(); } public void foo(Runnable printFoo) throws InterruptedException { for (int i = 0; i &lt; n; i++) { // printFoo.run() outputs &quot;foo&quot;. Do not change or remove this line. lock.lock(); while(!fooOrBar) { condition.await(); } printFoo.run(); fooOrBar = !fooOrBar; condition.signalAll(); lock.unlock(); } } public void bar(Runnable printBar) throws InterruptedException { for (int i = 0; i &lt; n; i++) { // printBar.run() outputs &quot;bar&quot;. Do not change or remove this line. lock.lock(); while(fooOrBar) { condition.await(); } printBar.run(); fooOrBar = !fooOrBar; condition.signalAll(); lock.unlock(); } }} 1116. æ‰“å°é›¶ä¸å¥‡å¶æ•°æ¡ä»¶å˜é‡12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class ZeroEvenOdd { private int n; private int state; private int curValue; final private Lock lock; final private Condition condition; public ZeroEvenOdd(int n) { this.n = n; lock = new ReentrantLock(); condition = lock.newCondition(); state = 0; curValue = 0; } // printNumber.accept(x) outputs &quot;x&quot;, where x is an integer. public void zero(IntConsumer printNumber) throws InterruptedException { for(int i = 0; i &lt; n; i++) { lock.lock(); while(state != 0 &amp;&amp; state != 2) { condition.await(); } printNumber.accept(0); condition.signalAll(); state = (state + 1) % 4; lock.unlock(); } } public void even(IntConsumer printNumber) throws InterruptedException { for(int i = 2; i &lt;= n; i+=2) { lock.lock(); while(state != 3) { condition.await(); } printNumber.accept(++curValue); condition.signalAll(); state = (state + 1) % 4; lock.unlock(); } } public void odd(IntConsumer printNumber) throws InterruptedException { for(int i = 1; i &lt;= n; i+=2) { lock.lock(); while(state != 1) { condition.await(); } printNumber.accept(++curValue); condition.signalAll(); state = (state + 1) % 4; lock.unlock(); } }} synchronized1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class ZeroEvenOdd { private int n; private int state; final private Lock lock; final private Condition condition; public ZeroEvenOdd(int n) { this.n = n; lock = new ReentrantLock(); condition = lock.newCondition(); state = 0; } // printNumber.accept(x) outputs &quot;x&quot;, where x is an integer. public void zero(IntConsumer printNumber) throws InterruptedException { for(int i = 0; i &lt; n; i++) { synchronized (this) { while(state != 0 &amp;&amp; state != 2) { this.wait(); } printNumber.accept(0); state = (state + 1) % 4; this.notifyAll(); } } } public void even(IntConsumer printNumber) throws InterruptedException { for(int i = 2; i &lt;= n; i+=2) { synchronized (this) { while(state != 3) { this.wait(); } printNumber.accept(i); state = (state + 1) % 4; this.notifyAll(); } } } public void odd(IntConsumer printNumber) throws InterruptedException { for(int i = 1; i &lt;= n; i+=2) { synchronized (this) { while(state != 1) { this.wait(); } printNumber.accept(i); state = (state + 1) % 4; this.notifyAll(); } } }} 1195. äº¤æ›¿æ‰“å°å­—ç¬¦ä¸²synchronized1234567891011121314151617181920212223242526272829303132333435363738394041class FizzBuzz { private int n; private int curNum; public FizzBuzz(int n) { this.n = n; curNum = 1; } private void runner(Predicate&lt;Integer&gt; test, IntConsumer consumer) throws InterruptedException { while(curNum &lt;= n) { synchronized (this) { while (!test.test(curNum) &amp;&amp; curNum &lt;= n) { this.wait(); } if(curNum &lt;= n) { consumer.accept(curNum); curNum++; this.notifyAll(); } } } } // printFizz.run() outputs &quot;fizz&quot;. public void fizz(Runnable printFizz) throws InterruptedException { runner((n)-&gt;n % 3 == 0 &amp;&amp; n % 5 != 0, (n)-&gt;printFizz.run()); } // printBuzz.run() outputs &quot;buzz&quot;. public void buzz(Runnable printBuzz) throws InterruptedException { runner((n)-&gt;n % 3 != 0 &amp;&amp; n % 5 == 0, (n)-&gt;printBuzz.run()); } // printFizzBuzz.run() outputs &quot;fizzbuzz&quot;. public void fizzbuzz(Runnable printFizzBuzz) throws InterruptedException { runner((n)-&gt;n % 3 == 0 &amp;&amp; n % 5 == 0, (n)-&gt;printFizzBuzz.run()); } // printNumber.accept(x) outputs &quot;x&quot;, where x is an integer. public void number(IntConsumer printNumber) throws InterruptedException { runner((n)-&gt;n % 3 != 0 &amp;&amp; n % 5 != 0, printNumber); }} condition123456789101112131415161718192021222324252627282930313233343536373839404142434445class FizzBuzz { private int n; final private Lock lock; final private Condition condition; private int curNum; public FizzBuzz(int n) { this.n = n; curNum = 1; lock = new ReentrantLock(); condition = lock.newCondition(); } private void runner(Predicate&lt;Integer&gt; test, IntConsumer consumer) throws InterruptedException { while(curNum &lt;= n) { lock.lock(); while (!test.test(curNum) &amp;&amp; curNum &lt;= n) { condition.await(); } if(curNum &lt;= n) { consumer.accept(curNum); curNum++; condition.signalAll(); } lock.unlock(); } } // printFizz.run() outputs &quot;fizz&quot;. public void fizz(Runnable printFizz) throws InterruptedException { runner((n)-&gt;n % 3 == 0 &amp;&amp; n % 5 != 0, (n)-&gt;printFizz.run()); } // printBuzz.run() outputs &quot;buzz&quot;. public void buzz(Runnable printBuzz) throws InterruptedException { runner((n)-&gt;n % 3 != 0 &amp;&amp; n % 5 == 0, (n)-&gt;printBuzz.run()); } // printFizzBuzz.run() outputs &quot;fizzbuzz&quot;. public void fizzbuzz(Runnable printFizzBuzz) throws InterruptedException { runner((n)-&gt;n % 3 == 0 &amp;&amp; n % 5 == 0, (n)-&gt;printFizzBuzz.run()); } // printNumber.accept(x) outputs &quot;x&quot;, where x is an integer. public void number(IntConsumer printNumber) throws InterruptedException { runner((n)-&gt;n % 3 != 0 &amp;&amp; n % 5 != 0, printNumber); }} 1117. H2O ç”Ÿæˆ1234567891011121314151617181920212223class H2O { Semaphore semH, semO; public H2O() { semH = new Semaphore(2); semO = new Semaphore(0); } public void hydrogen(Runnable releaseHydrogen) throws InterruptedException { // releaseHydrogen.run() outputs &quot;H&quot;. Do not change or remove this line. semH.acquire(); releaseHydrogen.run(); semO.release(); } public void oxygen(Runnable releaseOxygen) throws InterruptedException { // releaseOxygen.run() outputs &quot;O&quot;. Do not change or remove this line. semO.acquire(2); releaseOxygen.run(); semH.release(2); }} 1114. æŒ‰åºæ‰“å°ä¿¡å·é‡1234567891011121314151617181920212223242526272829class Foo { Semaphore a, b; public Foo() { a = new Semaphore(0); b = new Semaphore(0); } public void first(Runnable printFirst) throws InterruptedException { // printFirst.run() outputs &quot;first&quot;. Do not change or remove this line. printFirst.run(); a.release(); } public void second(Runnable printSecond) throws InterruptedException { // printSecond.run() outputs &quot;second&quot;. Do not change or remove this line. a.acquire(); printSecond.run(); b.release(); } public void third(Runnable printThird) throws InterruptedException { // printThird.run() outputs &quot;third&quot;. Do not change or remove this line. b.acquire(); printThird.run(); }} æ¡ä»¶12345678910111213141516171819202122232425262728293031323334353637383940class Foo { private int seq; public Foo() { seq = 0; } public void first(Runnable printFirst) throws InterruptedException { // printFirst.run() outputs &quot;first&quot;. Do not change or remove this line. synchronized (this) { printFirst.run(); seq++; notifyAll(); } } public void second(Runnable printSecond) throws InterruptedException { // printSecond.run() outputs &quot;second&quot;. Do not change or remove this line. synchronized (this) { while (seq != 1) { wait(); } printSecond.run(); seq++; notifyAll(); } } public void third(Runnable printThird) throws InterruptedException { // printThird.run() outputs &quot;third&quot;. Do not change or remove this line. synchronized (this) { while (seq != 2) { wait(); } printThird.run(); } }} CountDownLatchCountDownLatchçš„ç†è§£å’Œä½¿ç”¨ å½“æ¯ä¸€ä¸ªçº¿ç¨‹å®Œæˆè‡ªå·±ä»»åŠ¡åï¼Œè®¡æ•°å™¨çš„å€¼å°±ä¼šå‡ä¸€ã€‚å½“è®¡æ•°å™¨çš„å€¼ä¸º0æ—¶ï¼Œè¡¨ç¤ºæ‰€æœ‰çš„çº¿ç¨‹éƒ½å·²ç»å®Œæˆä¸€äº›ä»»åŠ¡ï¼Œç„¶ååœ¨CountDownLatchä¸Šç­‰å¾…çš„çº¿ç¨‹å°±å¯ä»¥æ¢å¤æ‰§è¡Œæ¥ä¸‹æ¥çš„ä»»åŠ¡ã€‚ 12345678910111213141516171819202122232425262728class Foo { private CountDownLatch count1; private CountDownLatch count2; public Foo() { count1 = new CountDownLatch(1); count2 = new CountDownLatch(1); } public void first(Runnable printFirst) throws InterruptedException { // printFirst.run() outputs &quot;first&quot;. Do not change or remove this line. printFirst.run(); count1.countDown(); } public void second(Runnable printSecond) throws InterruptedException { count1.await(); // printSecond.run() outputs &quot;second&quot;. Do not change or remove this line. printSecond.run(); count2.countDown(); } public void third(Runnable printThird) throws InterruptedException { count2.await(); // printThird.run() outputs &quot;third&quot;. Do not change or remove this line. printThird.run(); }} 1226. å“²å­¦å®¶è¿›é¤è°ƒæ•´æ‹¿ç­·å­çš„é¡ºåº å¥‡æ•°åºå·ï¼šå…ˆæ‹¿å·¦æ‰‹å†æ‹¿å³æ‰‹ å¶æ•°åºå·ï¼šå…ˆæ‹¿å³æ‰‹å†æ‹¿å·¦æ‰‹ 1234567891011121314151617181920212223242526272829303132333435363738class DiningPhilosophers { Lock[] lock; public DiningPhilosophers() { lock = new Lock[5]; for(int i = 0; i &lt; 5; i++) { lock[i] = new ReentrantLock(); } } // call the run() method of any runnable to execute its code public void wantsToEat(int philosopher, Runnable pickLeftFork, Runnable pickRightFork, Runnable eat, Runnable putLeftFork, Runnable putRightFork) throws InterruptedException { if(philosopher % 2 == 0) { lock[philosopher].lock(); lock[(philosopher+1)%5].lock(); } else { lock[(philosopher+1)%5].lock(); lock[philosopher].lock(); } try { pickLeftFork.run(); pickRightFork.run(); eat.run(); putLeftFork.run(); putRightFork.run(); } finally { lock[philosopher].unlock(); lock[(philosopher+1)%5].unlock(); } }} 12345678910111213141516171819202122232425262728293031323334353637class DiningPhilosophers { Object[] lock; public DiningPhilosophers() { lock = new Object[5]; for(int i = 0; i &lt; 5; i++) { lock[i] = new Object(); } } // call the run() method of any runnable to execute its code public void wantsToEat(int philosopher, Runnable pickLeftFork, Runnable pickRightFork, Runnable eat, Runnable putLeftFork, Runnable putRightFork) throws InterruptedException { Object obj1, obj2; if(philosopher % 2 == 0) { obj1 = lock[philosopher]; obj2 = lock[(philosopher+1)%5]; } else { obj1 = lock[(philosopher+1)%5]; obj2 = lock[philosopher]; } synchronized(obj1) { synchronized(obj2) { pickLeftFork.run(); pickRightFork.run(); eat.run(); putLeftFork.run(); putRightFork.run(); } } }} æ¡ä»¶ ä¸€ä¸ªæ•°ç»„ä¿å­˜æ¯ä¸ªç­·å­æ˜¯å¦ä½¿ç”¨ æ£€æŸ¥éœ€è¦çš„ä¸¤ä¸ªç­·å­ï¼Œå¦‚æœç­·å­å¯ç”¨ï¼Œæ”¹ä¸ºfalseï¼Œé‡Šæ”¾é”ï¼Œå¼€å§‹åƒ åƒå®Œåï¼Œé‡Šæ”¾ä¸¤ä¸ªç­·å­ï¼Œé€šçŸ¥å…¶ä»–çº¿ç¨‹ 1234567891011121314151617181920212223242526272829303132333435363738394041class DiningPhilosophers { Lock lock; boolean[] ready; Condition condition; public DiningPhilosophers() { lock = new ReentrantLock(); ready = new boolean[5]; Arrays.fill(ready, true); condition = lock.newCondition(); } // call the run() method of any runnable to execute its code public void wantsToEat(int philosopher, Runnable pickLeftFork, Runnable pickRightFork, Runnable eat, Runnable putLeftFork, Runnable putRightFork) throws InterruptedException { boolean leftChopstick = false; boolean rightChopstick = false; lock.lock(); while(!ready[philosopher] || !ready[(philosopher+1) % 5]) { condition.await(); } ready[philosopher] = false; ready[(philosopher+1) % 5] = false; pickLeftFork.run(); pickRightFork.run(); lock.unlock(); eat.run(); lock.lock(); putLeftFork.run(); putRightFork.run(); ready[philosopher] = true; ready[(philosopher+1) % 5] = true; condition.signalAll(); lock.unlock(); }} 5ä¸ªæ¡ä»¶ è¿™æ ·å¯ä»¥å‡å°‘å”¤é†’çš„çº¿ç¨‹ä¸ªæ•°12345678910111213141516171819202122232425262728293031323334353637383940414243class DiningPhilosophers { Lock lock; boolean[] ready; Condition[] conditions; public DiningPhilosophers() { lock = new ReentrantLock(); ready = new boolean[5]; Arrays.fill(ready, true); conditions = new Condition[5]; for (int i = 0; i &lt; conditions.length; i++) { conditions[i] = lock.newCondition(); } } // call the run() method of any runnable to execute its code public void wantsToEat(int philosopher, Runnable pickLeftFork, Runnable pickRightFork, Runnable eat, Runnable putLeftFork, Runnable putRightFork) throws InterruptedException { lock.lock(); while(!ready[philosopher] || !ready[(philosopher+1) % 5]) { conditions[philosopher].await(); } ready[philosopher] = false; ready[(philosopher+1) % 5] = false; pickLeftFork.run(); pickRightFork.run(); lock.unlock(); eat.run(); lock.lock(); putLeftFork.run(); putRightFork.run(); ready[philosopher] = true; ready[(philosopher+1) % 5] = true; conditions[(philosopher+1) % 5].signalAll(); conditions[(philosopher-1 + 5) % 5].signalAll(); lock.unlock(); }} çƒ¦æ­»äº†ï¼Œè¿™äº”ä¸ªå“²å­¦å®¶åƒé¥­å°±ä¸èƒ½å‡†å¤‡10æ ¹ç­·å­å— 1279. çº¢ç»¿ç¯è·¯å£ ç¾è´µçš„ä¼šå‘˜é¢˜ï¼Œä¸è¿‡æœ¬ç§‘çš„æ—¶å€™å­¦è¿‡ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package leetcode;import java.util.Random;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class TrafficLight { private int road = 0; private final Semaphore lockNS; private final Semaphore lockSW; private static final int NS = 1; private static final int SW = 2; private int carNumber = 0; public TrafficLight() { lockNS = new Semaphore(1); lockSW = new Semaphore(1); } public void carArrived(int carId, // ID of the car int roadId, // ID of the road the car travels on. Can be 1 (road A) or 2 (road B) int direction, // Direction of the car Runnable turnGreen, // Use turnGreen.run() to turn light to green on current road Runnable crossCar // Use crossCar.run() to make car cross the intersection ) { Semaphore lockOur, lockOther; if(roadId == NS) { lockOur = lockNS; lockOther = lockSW; } else { lockOur = lockSW; lockOther = lockNS; } try { lockOur.acquire(); if(roadId != road) { lockOther.acquire(); road = roadId; turnGreen.run(); } carNumber++; lockOur.release(); crossCar.run(); lockOur.acquire(); carNumber--; if(carNumber == 0) { lockOther.release(); } lockOur.release(); } catch (InterruptedException e) { } }}public class TestTrafficLight { public static void main(String[] args) { final TrafficLight trafficLight = new TrafficLight(); Random random = new Random(System.currentTimeMillis()); int carNumber = random.nextInt(100, 200); try(ExecutorService executor = Executors.newCachedThreadPool()) { for(int i = 0; i &lt; carNumber; i++) { final int carId = i; final int roadId = random.nextInt(1,3); final int direction = random.nextInt(1,3); executor.submit(()-&gt;trafficLight.carArrived( carId, roadId, direction, ()-&gt; System.out.printf(&quot;car:%d, onRoad:%d, direction:%d, turn traffic light green\\n&quot;, carId, roadId, direction), ()-&gt; System.out.printf(&quot;car:%d, onRoad:%d, direction:%d, running\\n&quot;, carId, roadId, direction) )); } } }} 1188. è®¾è®¡æœ‰é™é˜»å¡é˜Ÿåˆ— åˆæ˜¯ç¾è´µçš„ä¼šå‘˜é¢˜ç›® ç”Ÿäº§è€…æ¶ˆè´¹è€…æ¨¡å‹ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package leetcode;import java.util.*;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;import static leetcode.Tools.printf;import static leetcode.Tools.runCatching;class BoundedBlockingQueue { Semaphore consumer, producer; Lock mutex; final private int capacity; private LinkedList&lt;Integer&gt; q = new LinkedList&lt;&gt;(); public BoundedBlockingQueue(int capacity) { this.capacity = capacity; consumer = new Semaphore(0); producer = new Semaphore(capacity); mutex = new ReentrantLock(); } public void enqueue(int element) { try { producer.acquire(); mutex.lock(); q.add(element); } catch (Exception e) { producer.release(); throw new RuntimeException(e); } finally { mutex.unlock(); consumer.release(); } } public int dequeue() { int ret; try { consumer.acquire(); mutex.lock(); ret = q.remove(0); } catch (Exception e) { consumer.release(); throw new RuntimeException(e); } finally { mutex.unlock(); producer.release(); } return ret; } public int size() { return q.size(); }}public class TestBoundedBlockingQueue { static final int MIN_THREAD_NUM = 2; static final int MAX_THREAD_NUM = 50; static final int MIN_CAPACITY = 1; static final int MAX_CAPACITY = 50; static final int MIN_OP_NUM = 20; static final int MAX_OP_NUM = 100; static Random random = new Random(System.currentTimeMillis()); static int produceTotal; // ç”Ÿäº§è€…ç”Ÿäº§æ€»æ•° static int consumerTotal; // æ¶ˆè´¹è€…æ€»æ•° static void getOps(int[] producerNum, int[] consumerNum, int maxRemainNum) { produceTotal = consumerTotal = 0; for(int i = 0; i &lt; producerNum.length; i++){ int opNum = random.nextInt(MIN_OP_NUM, MAX_OP_NUM + 1); producerNum[i] = opNum; produceTotal += opNum; } for(int i = consumerNum.length-1; produceTotal - maxRemainNum - consumerTotal &gt; 0; i--) { int opNum = random.nextInt((produceTotal - maxRemainNum - consumerTotal) / (i*i + 1), (produceTotal - maxRemainNum - consumerTotal) / (i + 1) + 1); consumerNum[i] = opNum; consumerTotal += opNum; } } public static void main(String[] args) { int threadNum = random.nextInt(MIN_THREAD_NUM, MAX_THREAD_NUM + 1); int capacity = random.nextInt(MIN_CAPACITY, MAX_CAPACITY + 1); int maxRemainNum = random.nextInt(0, capacity + 1); int[] producerNum = new int[random.nextInt(1, threadNum)]; int[] consumerNum = new int[threadNum - producerNum.length]; getOps(producerNum, consumerNum, maxRemainNum); System.out.printf(&quot;producerNum=%s\\nconsumerNum=%s\\nthreadNum=%d\\ncapacity=%d\\nproducerTotal=%d\\nconsumerTotal=%d\\nsize=%d\\nmaxRemainNum=%d\\n&quot;, Arrays.toString(producerNum), Arrays.toString(consumerNum), threadNum, capacity, produceTotal, consumerTotal, produceTotal - consumerTotal, maxRemainNum); BoundedBlockingQueue boundedBlockingQueue = new BoundedBlockingQueue(capacity); try(ExecutorService executorService = Executors.newFixedThreadPool(threadNum)) { for(int i = 0; i &lt; producerNum.length; i++) { final int id = i; executorService.submit(runCatching(() -&gt; { for(int j = 0; j &lt; producerNum[id]; j++) { System.out.printf(&quot;%s, enqueue\\n&quot;, Thread.currentThread().getName()); boundedBlockingQueue.enqueue(id); } })); } for(int i = 0; i &lt; consumerNum.length; i++) { final int id = i; executorService.submit(runCatching(() -&gt; { for(int j = 0; j &lt; consumerNum[id]; j++) { int front = boundedBlockingQueue.dequeue(); System.out.printf(&quot;%s, dequeue, front = %d\\n&quot;, Thread.currentThread().getName(), front); } })); } } if(produceTotal - consumerTotal == boundedBlockingQueue.size()) { System.out.printf(&quot;ok!, size = %d\\n&quot;, produceTotal - consumerTotal); } else { throw new RuntimeException(printf(&quot;fail, you are foolish, correct size = %d, q.size = %d\\n&quot;, produceTotal - consumerTotal, boundedBlockingQueue.size())); } }} 12345678910111213141516171819package leetcode;import java.io.ByteArrayOutputStream;import java.io.PrintStream;public class Tools { interface ExceptionRunnable { void run() throws Exception; } static Runnable runCatching(ExceptionRunnable r) { return () -&gt; {try {r.run();} catch (Exception e) { e.printStackTrace(); }}; } static public String printf(String format, Object ... args) { ByteArrayOutputStream byteArrayOutputStream; PrintStream printStream = new PrintStream((byteArrayOutputStream = new ByteArrayOutputStream())); printStream.printf(format, args); return byteArrayOutputStream.toString(); }}","link":"/home/2024/03/04/LeetCode/LeetCode-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%931/"},{"title":"LeetCode-æ•°æ®åº“-2","text":"584. å¯»æ‰¾ç”¨æˆ·æ¨èäºº12345678SELECT nameFROM CustomerWHERE referee_id &lt;&gt; 2 OR referee_id IS NULL 577. å‘˜å·¥å¥–é‡‘1234567891011SELECT E.name, B.bonusFROM Employee E LEFT JOIN Bonus B ON E.empId = B.empIdWHERE B.bonus &lt; 1000 OR B.bonus IS NULL 570. è‡³å°‘æœ‰5åç›´æ¥ä¸‹å±çš„ç»ç†12345678910SELECT E1.nameFROM Employee E1 LEFT JOIN Employee E2 ON E1.id = E2.managerIdGROUP BY E1.idHAVING COUNT(E1.id) &gt;= 5 596. è¶…è¿‡5åå­¦ç”Ÿçš„è¯¾12345678SELECT classFROM CoursesGROUP BY classHAVING COUNT(class) &gt;= 5 595. å¤§çš„å›½å®¶12345678910SELECT name, population, areaFROM WorldWHERE population &gt;= 25000000 OR area &gt;= 3000000 586. è®¢å•æœ€å¤šçš„å®¢æˆ·123456789SELECT customer_numberFROM OrdersGROUP BY customer_numberORDER BY COUNT(customer_number) DESCLIMIT 1 585. 2016å¹´çš„æŠ•èµ„æ€è·¯1 joinä¸¤ä¸ªInsuranceè¡¨ï¼Œè¿æ¥æ–¹å¼ä¸ºpidä¸åŒ é€šè¿‡whereç­›é€‰å‡º2015æŠ•èµ„ç›¸ç­‰çš„è¡Œ å†æ¥ä¸€ä¸ªå­æŸ¥è¯¢æ‰¾å‡ºæ‰€æœ‰locationåªå‡ºç°ä¸€æ¬¡çš„id é€šè¿‡whereç­›é€‰å‡ºæ»¡è¶³æ¡ä»¶çš„id sql12345678910111213141516171819202122232425262728SELECT ROUND(SUM(T.tiv_2016), 2) as tiv_2016FROM( SELECT MAX(I1.tiv_2016) as tiv_2016 FROM Insurance I1 LEFT JOIN Insurance I2 ON I1.pid != I2.pid WHERE I1.pid IN ( SELECT pid FROM Insurance GROUP BY lat, lon HAVING COUNT(*) = 1 ) AND I1.tiv_2015 = I2.tiv_2015 GROUP BY I1.pid) T é”™è¯¯åˆ†æ ONå’Œ WHEREçš„æ¡ä»¶å¯ä»¥äº’æ¢å—ï¼Ÿ123456789101112131415161718192021222324252627SELECT ROUND(SUM(T.tiv_2016), 2) as tiv_2016FROM( SELECT I1.pid, MAX(I1.tiv_2016) as tiv_2016 FROM Insurance I1 LEFT JOIN Insurance I2 ON I1.pid != I2.pid AND I1.tiv_2015 = I2.tiv_2015 AND I1.pid IN ( SELECT pid FROM Insurance GROUP BY lat, lon HAVING COUNT(*) = 1 ) GROUP BY I1.pid) T å‘ç°ä¸Šé¢çš„ç»“æœä¸å¯¹ï¼ŒåŸå› æ˜¯ä½¿ç”¨äº†LEFT JOIN, å¯¼è‡´Onåçš„æ¡ä»¶æ²¡æœ‰æ»¡è¶³ï¼Œä½†æ˜¯å·¦ä¾§éƒ½è¢«ä¿ç•™äº†ä¸‹æ¥ï¼Œéœ€è¦æ”¹æˆå†…è¿æ¥ 123456789101112131415161718192021222324252627SELECT ROUND(SUM(T.tiv_2016), 2) as tiv_2016FROM( SELECT I1.pid, MAX(I1.tiv_2016) as tiv_2016 FROM Insurance I1 JOIN Insurance I2 ON I1.pid != I2.pid AND I1.tiv_2015 = I2.tiv_2015 AND I1.pid IN ( SELECT pid FROM Insurance GROUP BY lat, lon HAVING COUNT(*) = 1 ) GROUP BY I1.pid) T æ€è·¯2 count() + over(parition by) countè®¡ç®—ä¸ªæ•° partition byæŒ‡å®šè®¡ç®—æ—¶çš„èšåˆæ–¹æ³• sql123456789101112131415SELECT ROUND(SUM(T.tiv_2016), 2) as tiv_2016FROM( SELECT tiv_2016, COUNT(1) OVER(PARTITION BY tiv_2015) AS tiv_2015_cnt, COUNT(1) OVER(PARTITION BY lat, lon) AS pos_cnt FROM Insurance) TWHERE T.tiv_2015_cnt &gt; 1 AND T.pos_cnt = 1 602. å¥½å‹ç”³è¯· II ï¼šè°æœ‰æœ€å¤šçš„å¥½å‹æ€è·¯1 aå‘bç”³è¯·å¥½å‹ï¼Œé€šè¿‡åï¼Œa-béƒ½äº’ä¸ºå¥½å‹ æ‰€ä»¥éœ€è¦æŠŠrequesterå’Œaccepteräº’æ¢åï¼Œä½¿ç”¨UNION ALLè¿æ¥ ç„¶ågroup by + count() 12345678910111213141516171819202122SELECT id, COUNT(friend_id) AS numFROM( SELECT accepter_id AS id, requester_id AS friend_id FROM RequestAcceptedUNION ALL SELECT requester_id AS id, accepter_id AS friend_id FROM RequestAccepted) TGROUP BY idORDER BY COUNT(friend_id) DESCLIMIT 1 æ€è·¯2 é¢˜ç›®çš„æ„æ€æ˜¯ä¸å­˜åœ¨é‡å¤æ·»åŠ å¥½å‹çš„æƒ…å†µï¼Œæ¯”å¦‚aåŠ bï¼Œaåˆ bï¼ŒbåŠ å›aç­‰æƒ…å†µ æ‰€ä»¥å¯ä»¥ç›´æ¥åœ¨å­æŸ¥è¯¢ä¸­è®¡æ•°ï¼Œç„¶ååœ¨å¤–é¢æ±‚å’Œï¼Œå¯ä»¥å¿«ä¸€ç‚¹ 1234567891011121314151617181920212223242526SELECT id, SUM(num) AS numFROM( SELECT accepter_id AS id, COUNT(requester_id) AS num FROM RequestAccepted GROUP BY accepter_idUNION ALL SELECT requester_id AS id, COUNT(accepter_id) AS num FROM RequestAccepted GROUP BY requester_id) TGROUP BY idORDER BY SUM(num) DESCLIMIT 1 1661. æ¯å°æœºå™¨çš„è¿›ç¨‹å¹³å‡è¿è¡Œæ—¶é—´ unionå‰åå¿…é¡»åŠ æ‹¬å· 1234567891011121314SELECT A1.machine_id, ROUND(AVG(A2.timestamp - A1.timestamp), 3) AS processing_timeFROM Activity A1 JOIN Activity A2 ON A1.machine_id = A2.machine_id AND A1.process_id = A2.process_id AND A1.activity_type = 'start' AND A2.activity_type = 'end'GROUP BY A1.machine_id 1341. ç”µå½±è¯„åˆ†123456789101112131415161718192021222324252627282930313233( SELECT name AS results FROM Users JOIN MovieRating ON Users.user_id = MovieRating.user_id GROUP BY Users.user_id ORDER BY COUNT(rating) DESC,name LIMIT 1)UNION ALL( SELECT title AS results FROM Movies JOIN MovieRating ON Movies.movie_id = MovieRating.movie_id WHERE created_at BETWEEN DATE(&quot;2020-02-01&quot;) AND DATE(&quot;2020-02-29&quot;) GROUP BY Movies.movie_id ORDER BY AVG(rating) DESC, title LIMIT 1) 1141. æŸ¥è¯¢è¿‘30å¤©æ´»è·ƒç”¨æˆ·æ•° ç¬¨è›‹ï¼Œæœ€è¿‘30å¤©æ˜¯å¾€å‰æ•°29å¤© 12345678910111213SELECT activity_date AS 'day', COUNT(DISTINCT user_id) AS 'active_users'FROM ActivityWHERE activity_date BETWEEN DATE_SUB(&quot;2019-07-27&quot;, INTERVAL 29 DAY) AND DATE(&quot;2019-07-27&quot;)GROUP BY activity_date 1731. æ¯ä½ç»ç†çš„ä¸‹å±å‘˜å·¥æ•°é‡12345678910111213141516# Write your MySQL query statement belowSELECT E1.employee_id, E1.name, COUNT(E2.reports_to) AS reports_count, ROUND(AVG(E2.age), 0) AS average_ageFROM Employees E1 JOIN Employees E2 ON E1.employee_id = E2.reports_toGROUP BY employee_idORDER BY employee_id 1527. æ‚£æŸç§ç–¾ç—…çš„æ‚£è€…LIKE1234567891011# Write your MySQL query statement belowSELECT patient_id, patient_name, conditionsFROM PatientsWHERE conditions LIKE '% DIAB1%' OR conditions LIKE 'DIAB1%' REGEXP å†™ä¸å‡ºè¿™ä¸ªæ­£åˆ™ \\b:åŒ¹é…ä¸€ä¸ªå•è¯è¾¹ç•Œï¼Œä¹Ÿå°±æ˜¯æŒ‡å•è¯å’Œç©ºæ ¼é—´çš„ä½ç½®ã€‚ä¾‹å¦‚ï¼Œ â€˜er\\bâ€™ å¯ä»¥åŒ¹é…â€neverâ€ ä¸­çš„ â€˜erâ€™ï¼Œä½†ä¸èƒ½åŒ¹é… â€œverbâ€ ä¸­çš„ â€˜erâ€™ã€‚ \\B:åŒ¹é…éå•è¯è¾¹ç•Œã€‚â€™er\\Bâ€™ èƒ½åŒ¹é… â€œverbâ€ ä¸­çš„ â€˜erâ€™ï¼Œä½†ä¸èƒ½åŒ¹é… â€œneverâ€ ä¸­çš„ â€˜erâ€™ 123456789# Write your MySQL query statement belowSELECT patient_id, patient_name, conditionsFROM PatientsWHERE conditions REGEXP '\\\\bDIAB1' 1070. äº§å“é”€å”®åˆ†æ III123456789101112131415161718192021SELECT Sales.product_id, T.first_year, Sales.quantity, Sales.priceFROM Sales JOIN ( SELECT product_id, MIN(year) AS first_year FROM Sales GROUP BY product_id ) T ON Sales.year = T.first_year AND Sales.product_id = T.product_id rank overé‡Œé¢æ—¢èƒ½partition by, ä¹Ÿèƒ½order by 123456789101112131415161718SELECT T.product_id, T.first_year, T.quantity, T.priceFROM ( SELECT product_id, year AS first_year, quantity, price, rank() OVER(PARTITION BY product_id ORDER BY year) AS 'year_rank' FROM Sales ) TWHERE T.year_rank = 1","link":"/home/2024/03/04/LeetCode/LeetCode-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932/"},{"title":"LeetCode-ä½è¿ç®—","text":"ä½è¿ç®—å¸¸è§æŠ€å·§ ä½è¿ç®—è®¡ç®— a op b res x xor 0x00 x x xor 0xff ~x x xor x 0 x and 0x00 0 x and 0xff x x and x x x or 0x00 x x or 0xff 0xff x or x x x and x-1 å»æ‰æœ€ä½ä½ x and -x å¾—åˆ°æœ€ä½ä½ çŠ¶æ€å‹ç¼© ç”¨äºŒè¿›åˆ¶ä½è¡¨ç¤ºçŠ¶æ€ 268. ä¸¢å¤±çš„æ•°å­—1234567891011class Solution {public: int missingNumber(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int ans = n; for(int i = 0; i &lt; n; i++) { ans ^= nums[i]^i; } return ans; }}; æ€è·¯æ¨¡ä»¿136. åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—ï¼Œå°†ä¸‹æ ‡å’Œæ‰€æœ‰æ•°å­—è¿›è¡Œå¼‚æˆ–ã€‚ 693. äº¤æ›¿ä½äºŒè¿›åˆ¶æ•°ç¥ç»ç—…åšæ³• 0x5555555 æ˜¯æœ€ä½ä½ä¸º1çš„01äº¤æ›¿ 0xaaaaaaa æ˜¯æœ€ä½ä½ä¸º0çš„01äº¤æ›¿ nåˆ†åˆ«ä¸ä¸¤ä¸ªæ•°ç›¸ä¸ï¼Œç»“æœä¸åŒæ—¶å¤§äº0æˆ–ä¸åŒæ—¶ä¸º0çš„è¯ï¼Œè¯´æ˜æ²¡æœ‰è¿ç»­çš„0 å¯¹nå–åï¼Œå³å¯åˆ¤æ–­æœ‰æ— è¿ç»­çš„0123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: bool hasAlternatingBits(int n) { if(!(((0x55555555 &amp; n) &amp;&amp; !(0xaaaaaaaa &amp; n)) || (!(0x55555555 &amp; n) &amp;&amp; (0xaaaaaaaa &amp; n)))) return false; if(n == 1) return true; // for(int i = 1; i &lt; 32; i++) { // printf( // &quot;if(!(n &amp; 0x%x)) return &quot; // &quot;((0x55555555 &amp; 0x%x &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x%x &amp; ~n)) || (!(0x55555555 &amp; 0x%x &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x%x &amp; ~n)); else\\n&quot;, // (0xffffffffffffffff &lt;&lt; i), // ~(0xffffffffffffffff &lt;&lt; i), ~(0xffffffffffffffff &lt;&lt; i), ~(0xffffffffffffffff &lt;&lt; i), ~(0xffffffffffffffff &lt;&lt; i) // ); // } // printf(&quot;return false; // unreachable\\n&quot;); if(!(n &amp; 0xfffffffe)) return ((0x55555555 &amp; 0x1 &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x1 &amp; ~n)) || (!(0x55555555 &amp; 0x1 &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x1 &amp; ~n)); else if(!(n &amp; 0xfffffffc)) return ((0x55555555 &amp; 0x3 &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x3 &amp; ~n)) || (!(0x55555555 &amp; 0x3 &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x3 &amp; ~n)); else if(!(n &amp; 0xfffffff8)) return ((0x55555555 &amp; 0x7 &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x7 &amp; ~n)) || (!(0x55555555 &amp; 0x7 &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x7 &amp; ~n)); else if(!(n &amp; 0xfffffff0)) return ((0x55555555 &amp; 0xf &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0xf &amp; ~n)) || (!(0x55555555 &amp; 0xf &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0xf &amp; ~n)); else if(!(n &amp; 0xffffffe0)) return ((0x55555555 &amp; 0x1f &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x1f &amp; ~n)) || (!(0x55555555 &amp; 0x1f &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x1f &amp; ~n)); else if(!(n &amp; 0xffffffc0)) return ((0x55555555 &amp; 0x3f &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x3f &amp; ~n)) || (!(0x55555555 &amp; 0x3f &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x3f &amp; ~n)); else if(!(n &amp; 0xffffff80)) return ((0x55555555 &amp; 0x7f &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x7f &amp; ~n)) || (!(0x55555555 &amp; 0x7f &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x7f &amp; ~n)); else if(!(n &amp; 0xffffff00)) return ((0x55555555 &amp; 0xff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0xff &amp; ~n)) || (!(0x55555555 &amp; 0xff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0xff &amp; ~n)); else if(!(n &amp; 0xfffffe00)) return ((0x55555555 &amp; 0x1ff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x1ff &amp; ~n)) || (!(0x55555555 &amp; 0x1ff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x1ff &amp; ~n)); else if(!(n &amp; 0xfffffc00)) return ((0x55555555 &amp; 0x3ff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x3ff &amp; ~n)) || (!(0x55555555 &amp; 0x3ff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x3ff &amp; ~n)); else if(!(n &amp; 0xfffff800)) return ((0x55555555 &amp; 0x7ff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x7ff &amp; ~n)) || (!(0x55555555 &amp; 0x7ff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x7ff &amp; ~n)); else if(!(n &amp; 0xfffff000)) return ((0x55555555 &amp; 0xfff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0xfff &amp; ~n)) || (!(0x55555555 &amp; 0xfff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0xfff &amp; ~n)); else if(!(n &amp; 0xffffe000)) return ((0x55555555 &amp; 0x1fff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x1fff &amp; ~n)) || (!(0x55555555 &amp; 0x1fff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x1fff &amp; ~n)); else if(!(n &amp; 0xffffc000)) return ((0x55555555 &amp; 0x3fff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x3fff &amp; ~n)) || (!(0x55555555 &amp; 0x3fff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x3fff &amp; ~n)); else if(!(n &amp; 0xffff8000)) return ((0x55555555 &amp; 0x7fff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x7fff &amp; ~n)) || (!(0x55555555 &amp; 0x7fff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x7fff &amp; ~n)); else if(!(n &amp; 0xffff0000)) return ((0x55555555 &amp; 0xffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0xffff &amp; ~n)) || (!(0x55555555 &amp; 0xffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0xffff &amp; ~n)); else if(!(n &amp; 0xfffe0000)) return ((0x55555555 &amp; 0x1ffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x1ffff &amp; ~n)) || (!(0x55555555 &amp; 0x1ffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x1ffff &amp; ~n)); else if(!(n &amp; 0xfffc0000)) return ((0x55555555 &amp; 0x3ffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x3ffff &amp; ~n)) || (!(0x55555555 &amp; 0x3ffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x3ffff &amp; ~n)); else if(!(n &amp; 0xfff80000)) return ((0x55555555 &amp; 0x7ffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x7ffff &amp; ~n)) || (!(0x55555555 &amp; 0x7ffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x7ffff &amp; ~n)); else if(!(n &amp; 0xfff00000)) return ((0x55555555 &amp; 0xfffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0xfffff &amp; ~n)) || (!(0x55555555 &amp; 0xfffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0xfffff &amp; ~n)); else if(!(n &amp; 0xffe00000)) return ((0x55555555 &amp; 0x1fffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x1fffff &amp; ~n)) || (!(0x55555555 &amp; 0x1fffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x1fffff &amp; ~n)); else if(!(n &amp; 0xffc00000)) return ((0x55555555 &amp; 0x3fffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x3fffff &amp; ~n)) || (!(0x55555555 &amp; 0x3fffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x3fffff &amp; ~n)); else if(!(n &amp; 0xff800000)) return ((0x55555555 &amp; 0x7fffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x7fffff &amp; ~n)) || (!(0x55555555 &amp; 0x7fffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x7fffff &amp; ~n)); else if(!(n &amp; 0xff000000)) return ((0x55555555 &amp; 0xffffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0xffffff &amp; ~n)) || (!(0x55555555 &amp; 0xffffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0xffffff &amp; ~n)); else if(!(n &amp; 0xfe000000)) return ((0x55555555 &amp; 0x1ffffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x1ffffff &amp; ~n)) || (!(0x55555555 &amp; 0x1ffffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x1ffffff &amp; ~n)); else if(!(n &amp; 0xfc000000)) return ((0x55555555 &amp; 0x3ffffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x3ffffff &amp; ~n)) || (!(0x55555555 &amp; 0x3ffffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x3ffffff &amp; ~n)); else if(!(n &amp; 0xf8000000)) return ((0x55555555 &amp; 0x7ffffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x7ffffff &amp; ~n)) || (!(0x55555555 &amp; 0x7ffffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x7ffffff &amp; ~n)); else if(!(n &amp; 0xf0000000)) return ((0x55555555 &amp; 0xfffffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0xfffffff &amp; ~n)) || (!(0x55555555 &amp; 0xfffffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0xfffffff &amp; ~n)); else if(!(n &amp; 0xe0000000)) return ((0x55555555 &amp; 0x1fffffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x1fffffff &amp; ~n)) || (!(0x55555555 &amp; 0x1fffffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x1fffffff &amp; ~n)); else if(!(n &amp; 0xc0000000)) return ((0x55555555 &amp; 0x3fffffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x3fffffff &amp; ~n)) || (!(0x55555555 &amp; 0x3fffffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x3fffffff &amp; ~n)); else if(!(n &amp; 0x80000000)) return ((0x55555555 &amp; 0x7fffffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x7fffffff &amp; ~n)) || (!(0x55555555 &amp; 0x7fffffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x7fffffff &amp; ~n)); else return false; // unreachable }}; æ­£å¸¸åšæ³• n ^ (n&gt;&gt;1) ï¼ŒæŸä¸€ä½ä¸º1ï¼Œç›¸å½“äºè¿™ä¸€ä½å’Œå…¶å‰ä¸€ä½ä¸ä¸€æ · ä»»ä½•ç»“æœå½¢å¦‚ 0b000_..._011...111çš„ï¼Œéƒ½æ˜¯æ­£ç¡® è€ƒè™‘åˆ° 0b000_..._011...111 + 1 å°±æ˜¯ 0b00..00100..00ï¼Œ åªè¦(n ^ (n&gt;&gt;1)) + 1ä¸­åªæœ‰ä¸€ä¸ª1å°±å¥½äº† (x &amp; (x-1))ç›¸å½“äºå»æ‰æœ€ä½ä½çš„1 åªè¦((n ^ (n&gt;&gt;1)) + 1) &amp; ((n ^ (n&gt;&gt;1)))æ˜¯0å°±å¥½äº†1234567class Solution {public: bool hasAlternatingBits(int n) { int a = n ^ (n &gt;&gt; 1); return a == INT_MAX || (a &amp; (a+1)) == 0; }}; æ­£å¸¸åšæ³•2æš´åŠ›æ‰“è¡¨ 1234567891011121314151617181920212223242526272829class Solution {public: bool hasAlternatingBits(int n) { // int x = 0; // for(int i = 0; i &lt; 16; i++) { // x &lt;&lt;= 2; // x++; // printf(&quot;if(n == 0x%x || n == 0x%x) return true; else\\n&quot;, x, ~x &amp; ((1 &lt;&lt; (i &lt;&lt; 1)) - 1)); // } // printf(&quot;return false;&quot;); if(n == 0x1 || n == 0x0) return true; else if(n == 0x5 || n == 0x2) return true; else if(n == 0x15 || n == 0xa) return true; else if(n == 0x55 || n == 0x2a) return true; else if(n == 0x155 || n == 0xaa) return true; else if(n == 0x555 || n == 0x2aa) return true; else if(n == 0x1555 || n == 0xaaa) return true; else if(n == 0x5555 || n == 0x2aaa) return true; else if(n == 0x15555 || n == 0xaaaa) return true; else if(n == 0x55555 || n == 0x2aaaa) return true; else if(n == 0x155555 || n == 0xaaaaa) return true; else if(n == 0x555555 || n == 0x2aaaaa) return true; else if(n == 0x1555555 || n == 0xaaaaaa) return true; else if(n == 0x5555555 || n == 0x2aaaaaa) return true; else if(n == 0x15555555 || n == 0xaaaaaaa) return true; else if(n == 0x55555555 || n == 0x2aaaaaaa) return true; else return false; }}; 476. æ•°å­—çš„è¡¥æ•°12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution {public: int findComplement(int num) { // for(int i = 1; i &lt; 32; i++) { // printf( // &quot;if(!(num &amp; 0x%x)) return &quot; // &quot;0x%x &amp; ~num; else\\n&quot;, // (0xffffffffffffffff &lt;&lt; i), // ~(0xffffffffffffffff &lt;&lt; i), ~(0xffffffffffffffff &lt;&lt; i), ~(0xffffffffffffffff &lt;&lt; i), ~(0xffffffffffffffff &lt;&lt; i) // ); // } // printf(&quot;return 0;\\n&quot;); if(!(num &amp; 0xfffffffe)) return 0x1 &amp; ~num; else if(!(num &amp; 0xfffffffc)) return 0x3 &amp; ~num; else if(!(num &amp; 0xfffffff8)) return 0x7 &amp; ~num; else if(!(num &amp; 0xfffffff0)) return 0xf &amp; ~num; else if(!(num &amp; 0xffffffe0)) return 0x1f &amp; ~num; else if(!(num &amp; 0xffffffc0)) return 0x3f &amp; ~num; else if(!(num &amp; 0xffffff80)) return 0x7f &amp; ~num; else if(!(num &amp; 0xffffff00)) return 0xff &amp; ~num; else if(!(num &amp; 0xfffffe00)) return 0x1ff &amp; ~num; else if(!(num &amp; 0xfffffc00)) return 0x3ff &amp; ~num; else if(!(num &amp; 0xfffff800)) return 0x7ff &amp; ~num; else if(!(num &amp; 0xfffff000)) return 0xfff &amp; ~num; else if(!(num &amp; 0xffffe000)) return 0x1fff &amp; ~num; else if(!(num &amp; 0xffffc000)) return 0x3fff &amp; ~num; else if(!(num &amp; 0xffff8000)) return 0x7fff &amp; ~num; else if(!(num &amp; 0xffff0000)) return 0xffff &amp; ~num; else if(!(num &amp; 0xfffe0000)) return 0x1ffff &amp; ~num; else if(!(num &amp; 0xfffc0000)) return 0x3ffff &amp; ~num; else if(!(num &amp; 0xfff80000)) return 0x7ffff &amp; ~num; else if(!(num &amp; 0xfff00000)) return 0xfffff &amp; ~num; else if(!(num &amp; 0xffe00000)) return 0x1fffff &amp; ~num; else if(!(num &amp; 0xffc00000)) return 0x3fffff &amp; ~num; else if(!(num &amp; 0xff800000)) return 0x7fffff &amp; ~num; else if(!(num &amp; 0xff000000)) return 0xffffff &amp; ~num; else if(!(num &amp; 0xfe000000)) return 0x1ffffff &amp; ~num; else if(!(num &amp; 0xfc000000)) return 0x3ffffff &amp; ~num; else if(!(num &amp; 0xf8000000)) return 0x7ffffff &amp; ~num; else if(!(num &amp; 0xf0000000)) return 0xfffffff &amp; ~num; else if(!(num &amp; 0xe0000000)) return 0x1fffffff &amp; ~num; else if(!(num &amp; 0xc0000000)) return 0x3fffffff &amp; ~num; else if(!(num &amp; 0x80000000)) return 0x7fffffff &amp; ~num; else return 0; }}; 137. åªå‡ºç°ä¸€æ¬¡çš„æ•°å­— II æ²¡åšå‡ºæ¥ï¼Œå†æ¥å†å‰ 260. åªå‡ºç°ä¸€æ¬¡çš„æ•°å­— IIIæ²¡åšå‡ºæ¥ï¼Œå†æ¥å†å‰ 29. ä¸¤æ•°ç›¸é™¤ åœ¨LeetCodeå†™è¿‡ï¼Œå½“æ—¶æ²¡æœ‰æ„è¯†åˆ°æ˜¯ä½è¿ç®— å¤§ä½“æ€è·¯å°±æ˜¯ç±»ä¼¼å¿«é€Ÿå¹‚ 67. äºŒè¿›åˆ¶æ±‚å’Œ å¯¹äºŒè¿›åˆ¶çš„ç†è§£ï¼Œå’Œä½è¿ç®—å…³ç³»ä¸å¤§ 78. å­é›†é€’å½’æ³• æ¯å±‚é€’å½’å‘æŒ‡å®šé›†åˆä¸­ä¾æ¬¡åŠ å…¥ä¸€ä¸ªå‰©ä½™å…ƒç´ ï¼Œå¹¶å†æ¬¡é€’å½’ é¦–å…ˆåŠ å…¥ç©ºé›†ï¼Œç¬¬ä¸€å±‚é€’å½’åœ¨ç©ºé›†çš„åŸºç¡€ä¸ŠåŠ å…¥ä¸€ä¸ªå…ƒç´  ç¬¬äºŒå±‚é€’å½’åŠ å…¥ç¬¬äºŒä¸ªå…ƒç´  12345678910111213141516171819class Solution {public: vector&lt;vector&lt;int&gt;&gt; res; int n; vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { n = nums.size(); res.push_back(move(vector&lt;int&gt;())); insert(0, res[0], nums); return res; } void insert(int i, vector&lt;int&gt; v, const vector&lt;int&gt;&amp; nums) { for(int j = i; j &lt; n; j++) { vector&lt;int&gt; vv = v; vv.push_back(nums[j]); res.push_back(vv); insert(j+1, vv, nums); } }}; äºŒè¿›åˆ¶çŠ¶æ€ åˆ©ç”¨0åˆ°1 &lt;&lt; Nçš„æ‰€æœ‰çŠ¶æ€ï¼Œåˆšå¥½å¯¹åº”Nä¸ªå…ƒç´ çš„æ‰€æœ‰çŠ¶æ€ çŠ¶æ€ç¬¬iä½è¡¨ç¤ºç¬¬iä¸ªå…ƒç´ æ˜¯å¦åœ¨é›†åˆä¸­ 1234567891011121314151617181920212223class Solution {public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { int state = 0; int n = nums.size(); int len = 1 &lt;&lt; n; vector&lt;vector&lt;int&gt;&gt; res; while(state &lt; len) { int s = state, j = 0; vector&lt;int&gt; v; while(s) { if(s &amp; 1) { v.push_back(nums[j]); } s &gt;&gt;= 1; j++; } res.push_back(v); state++; } return res; }}; æ ¼é›·ç ä¼˜åŒ– åˆ©ç”¨æ ¼é›·ç æ¯æ¬¡åªæ”¹å˜ä¸€ä¸ªå…ƒç´ çš„ç‰¹æ€§ï¼Œåˆ©ç”¨å¼‚æˆ–æ‰¾å‡ºå˜åŒ–çš„å…ƒç´ ï¼Œå¹¶åˆ¤æ–­åº”è¯¥åŠ å…¥å…ƒç´ è¿˜æ˜¯åˆ å»å…ƒç´  è¿™æ ·å¯ä»¥ä¼˜åŒ–ä¸ºéé€’å½’ç®—æ³•12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution {public: vector&lt;vector&lt;int&gt;&gt; stateSubsets(vector&lt;int&gt;&amp; nums) { int state = 0; int n = nums.size(); int len = 1 &lt;&lt; n; vector&lt;vector&lt;int&gt;&gt; res; while(state &lt; len) { int s = state, j = 0; vector&lt;int&gt; v; while(s) { if(s &amp; 1) { v.push_back(nums[j]); } s &gt;&gt;= 1; j++; } res.push_back(v); state++; } return res; } vector&lt;vector&lt;int&gt;&gt; graySubsets(vector&lt;int&gt;&amp; nums) { int state = 0; int n = nums.size(); int len = 1 &lt;&lt; n; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; v; res.push_back(v); int lastGray = 0; for(int i = 1; i &lt; len; i++) { int gray = i ^ (i &gt;&gt; 1); int diff = gray ^ lastGray; int l = 0, r = n-1; int mid = (r - l)/2 + l; while(l &lt;= r) { mid = (r - l)/2 + l; if((1&lt;&lt;mid) == diff) { break; } else if((1&lt;&lt;mid) &gt; diff) { r = mid - 1; } else { l = mid + 1; } } if((1 &lt;&lt; mid) &amp; gray) { v.push_back(nums[mid]); } else { v.erase(find(v.begin(), v.end(), nums[mid])); } res.push_back(v); lastGray = gray; } return res; } vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { // return stateSubsets(nums); return graySubsets(nums); }}; 89. æ ¼é›·ç¼–ç éœ€è¦ç”Ÿæˆæ ¼é›·ç ï¼Œæ ¼é›·ç æ¯ç›¸é‚»ä¸¤ä½éƒ½ä¸åŒgi = i ^ (i &gt;&gt; 1) è‹¥iä¸ºå¶æ•°ï¼Œiä¸i+1ä»…æœ€ä½ä½ä¸åŒï¼Œi&gt;&gt;1å’Œ(i+1)&gt;&gt;1ç›¸ç­‰ï¼Œgi^g(i+1) = i^(i+1) = 1è‹¥iä¸ºå¥‡æ•°ï¼Œiæœ€ä½ä½çš„0æ˜¯ç¬¬kä½ï¼Œ i^(i+1) = kä¸ª1ï¼Œ (i &gt;&gt; 2)^((i+1) &gt;&gt; 2) = k-1ä¸ª1ï¼Œgi^g(i+1) = ä»…ç¬¬kä½ä¸º1 1234567891011class Solution {public: vector&lt;int&gt; grayCode(int n) { int len = 1 &lt;&lt; n; vector&lt;int&gt; res(len, 0); for(int i = 0; i &lt; len; i++) { res[i] = i ^ (i &gt;&gt; 1); } return res; }}; 90. å­é›† II ä¸å…·æœ‰ä¸é‡å¤æ€§ï¼Œä½†å…·æœ‰æ— åºæ€§çš„ç‰¹æ®Šé›†åˆ ç»Ÿè®¡æ¯ä¸ªå…ƒç´ çš„å‡ºç°æ¬¡æ•°ï¼Œå°†åŸæ•°ç»„å»é‡ åˆ©ç”¨çŠ¶æ€äºŒè¿›åˆ¶ä½è¡¨ç¤ºæ˜¯å¦å‡ºç°æŸæŸå…ƒç´ ï¼Œå¯¹äºæ¯ä¸ªå…ƒç´ ï¼Œè¦è€ƒè™‘ä¸åŒçš„å‡ºç°æ¬¡æ•°ï¼Œè¿™ä¸ªåœ°æ–¹åˆ©ç”¨é€’å½’ 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution {public: vector&lt;vector&lt;int&gt;&gt; res; void push(vector&lt;int&gt;&amp; nums, int state, int j, vector&lt;int&gt; vv) { while(state) { if(state &amp; 1) { for(int i = 0; i &lt; numsCnt[j]; i++) { vv.push_back(nums[j]); if(state &gt;&gt; 1)push(nums, state &gt;&gt; 1, j+1, vv); else res.push_back(vv); } break; } state &gt;&gt;= 1; j++; } } vector&lt;vector&lt;int&gt;&gt; stateSubsets(vector&lt;int&gt;&amp; nums, int n) { int state = 0; int len = 1 &lt;&lt; n; res.push_back({}); while(state &lt; len) { push(nums, state, 0, {}); state++; } return res; } vector&lt;int&gt; numsCnt; vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); int i = 0, j = 0; int n = nums.size(); while(i &lt; n) { nums[j] = nums[i]; int cnt = i; while(i &lt; n &amp;&amp; nums[i] == nums[j]) i++; cnt = i - cnt; numsCnt.push_back(cnt); j++; } return stateSubsets(nums, j); }}; 187. é‡å¤çš„DNAåºåˆ— å°†ATGCç¼–ç ï¼Œé€šè¿‡ç¼–ç ä¹‹é—´çš„æ¯”è¾ƒä»£æ›¿å­—ç¬¦ä¸²æ¯”è¾ƒ ç”±äºæœ‰å››ä¸ªçŠ¶æ€ï¼Œè€ƒè™‘ä½¿ç”¨ä¸¤ä½æ¥è¡¨ç¤º 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution {public: vector&lt;string&gt; findRepeatedDnaSequences(string s) { auto code = make_pair(0, 0); int len = s.length(); map&lt;pair&lt;int, int&gt;, int&gt; m; for(int i = 0; i &lt; 10; i++) { code.first &lt;&lt;= 1; code.second &lt;&lt;= 1; if(s[i] == 'A') { code.first |= 0; code.second |= 0; } else if(s[i] == 'C') { code.first |= 1; code.second |= 0; } else if(s[i] == 'G') { code.first |= 0; code.second |= 1; } else if(s[i] == 'T') { code.first |= 1; code.second |= 1; } else { // unreachable } } m[code]++; vector&lt;string&gt; res; // cout &lt;&lt; code[0].first &lt;&lt; &quot;, &quot; &lt;&lt; code[0].second &lt;&lt; endl; for(int i = 10; i &lt; len; i++) { int mask = 1024-1; code.first &lt;&lt;= 1; code.second &lt;&lt;= 1; code.first &amp;= mask; code.second &amp;= mask; if(s[i] == 'A') { code.first |= 0; code.second |= 0; } else if(s[i] == 'C') { code.first |= 1; code.second |= 0; } else if(s[i] == 'G') { code.first |= 0; code.second |= 1; } else if(s[i] == 'T') { code.first |= 1; code.second |= 1; } else { // unreachable } // cout &lt;&lt; codei.first &lt;&lt; &quot;, &quot; &lt;&lt; codei.second &lt;&lt; endl; m[code]++; if(m[code] == 2) { res.push_back(s.substr(i - 9, 10)); } } return res; }}; ç”±äºä¸€æ¬¡åªå­˜å‚¨é•¿åº¦ä¸º10çš„å­ä¸²ï¼Œç¼–ç æ—¶å…¨éƒ½ç¼–ç åˆ°åŒä¸€ä¸ªintï¼Œé¿å…ä½¿ç”¨pair 12345678910111213141516171819202122232425262728class Solution {public: unordered_map&lt;char, int&gt; bin = {{'A', 0}, {'C', 1}, {'G', 2}, {'T', 3}}; vector&lt;string&gt; findRepeatedDnaSequences(string s) { auto code = 0; int len = s.length(); unordered_map&lt;int, int&gt; m; for(int i = 0; i &lt; 10; i++) { code &lt;&lt;= 2; code |= bin[s[i]]; } m[code]++; // cout &lt;&lt; code[0].first &lt;&lt; &quot;, &quot; &lt;&lt; code[0].second &lt;&lt; endl; vector&lt;string&gt; res; int mask = (1 &lt;&lt; 20) - 1; for(int i = 10; i &lt; len; i++) { code &lt;&lt;= 2; code &amp;= mask; code |= bin[s[i]]; // cout &lt;&lt; codei.first &lt;&lt; &quot;, &quot; &lt;&lt; codei.second &lt;&lt; endl; m[code]++; if(m[code] == 2) { res.push_back(s.substr(i - 9, 10)); } } return res; }}; 190. é¢ å€’äºŒè¿›åˆ¶ä½191. ä½1çš„ä¸ªæ•°è¿™ä¸¤ä¸ªé¢˜æ²¡ä»€ä¹ˆå¥½è¯´çš„ï¼Œ 123456789101112131415161718192021class Solution { unordered_map&lt;uint32_t, int&gt; cache; unordered_map&lt;uint32_t, int&gt; cache_len;public: int hammingWeight(uint32_t n) { uint32_t nn = n; if (cache[nn]) return cache[nn]; while (n) { if (cache[n]) { cache[nn] += cache[n]; cache_len[nn] += cache_len[n]; n &gt;&gt;= cache_len[n]; } else if (n &amp; 1) { cache[nn]++; cache_len[nn]++; } n &gt;&gt;= 1; } return cache[nn]; }}; 201. æ•°å­—èŒƒå›´æŒ‰ä½ä¸å°†åŒºé—´å†…çš„æ‰€æœ‰æ•°å­—ç›¸ä¸ï¼Œå¾—åˆ°ç»“æœ è€ƒè™‘ç‰¹æ®Šå€¼ï¼Œå³äºŒçš„å¹‚æ¬¡ å¦‚æœ[left, right]åŒºé—´å†…å‡ºç°äº†ä¸€ä¸ªäºŒçš„å¹‚æ¬¡ï¼Œå¦‚[3, 7]å†…åªå‡ºç°äº†4ï¼Œé‚£ä¹ˆå¯¹äº å°äº4çš„æ•°ï¼Œ3=011ï¼Œä¸4ç›¸ä¸çš„ç»“æœéƒ½ä¸º0 å¤§äº4çš„æ•°ï¼Œ5=101ï¼Œ6=110ï¼Œ7=111ï¼Œä¸4å‘ä¸åªæœ‰ä¸€ä¸ª1 ä¹‹å‰å‡ºç°è¿‡0ï¼Œæ‰€ä»¥ç»“æœä¸º0 å¦‚æœåŒºé—´å†…å‡ºç°äº†å¤§äºä¸€ä¸ªäºŒçš„å¹‚æ¬¡ï¼Œa, bï¼ˆa &lt; båˆ©ç”¨ä¸Šé¢çš„ç»“è®ºï¼Œä¹Ÿå¯ä»¥å¾—åˆ°ç»“æœä¸º0 å¦‚æœåŒºé—´å†…æ²¡æœ‰å‡ºç°2çš„å¹‚æ¬¡ï¼Œä¹Ÿè¯´æ˜left, rightä¹‹é—´çš„æ‰€æœ‰æ•°å­—æœ€é«˜ä½éƒ½ä¸º1ï¼Œç»“æœè‡³å°‘ä¸º1ï¼ŒæŠ›å¼ƒæœ€é«˜ä½ï¼Œé‡å¤ä»¥ä¸Šè¿‡ç¨‹ï¼Œå¯ä»¥ä¾æ¬¡æ‰¾åˆ°åç»­ä½ç›¸ä¸åæ˜¯å¦æœ‰1 1234567891011121314151617181920class Solution {public: inline unsigned highestBit(int n) { return 1 &lt;&lt; (sizeof(unsigned) * CHAR_BIT - 1 - __builtin_clz(n)); } int rangeBitwiseAnd(int left, int right) { int ret = 0; // printf(&quot;%x, %x\\n&quot;, left, right); while (left) { unsigned highest = highestBit(left); // cout &lt;&lt; highest &lt;&lt; endl; if ((highest &lt;&lt; 1) &lt;= right) return ret; ret |= highest; left &amp;= ~highest; right &amp;= ~highest; } return ret; }}; 222. å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°ä¸€èˆ¬æ–¹æ³•éå†å…¨éƒ¨èŠ‚ç‚¹è®¡æ•° 123456class Solution {public: int countNodes(TreeNode* root) { return (root ? (1 + countNodes(root-&gt;left) + countNodes(root-&gt;right)): 0); }}; äºŒåˆ† å®Œå…¨äºŒå‰æ ‘çš„é«˜åº¦å¾ˆå¥½ç®—ï¼Œç„¶åå°±å¯ä»¥ç®—å‡ºæ»¡äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•° å¯¹äºæ»¡äºŒå‰æ ‘ï¼ŒèŠ‚ç‚¹æ ‡å·çš„äºŒè¿›åˆ¶åºåˆ—å°±æ˜¯ä»rootåˆ°èŠ‚ç‚¹çš„è·¯å¾„ åˆ©ç”¨äºŒåˆ†æŸ¥æ‰¾ï¼Œå¯»æ‰¾æœ€å³ä¾§å­˜åœ¨çš„èŠ‚ç‚¹ï¼Œåˆ©ç”¨ç¬¬äºŒç‚¹çš„æ€§è´¨æŸ¥æ‰¾èŠ‚ç‚¹ï¼Œå¤æ‚åº¦ä¸ºO(log^2(N)) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int getMaxDepth(TreeNode *root) { int maxDepth = 0; while(root) { root = root-&gt;left; maxDepth++; } return maxDepth; } bool contains(TreeNode *root, int n, int maxDepth) { int mask = 1 &lt;&lt; (maxDepth - 1); while(root) { mask &gt;&gt;= 1; if(mask &amp; n) { root = root-&gt;right; } else { root = root-&gt;left; } } return mask == 0; } int countNodes(TreeNode* root) { int maxDepth = getMaxDepth(root); if(maxDepth &lt;= 0) return 0; int l = ((1 &lt;&lt; (maxDepth-1))), r = ((1 &lt;&lt; (maxDepth)) - 1); while(l &lt; r) { int mid = (r - l + 1) / 2 + l; if(contains(root, mid, maxDepth)) { l = mid; } else { r = mid - 1; } } return l; }}; 231. 2 çš„å¹‚ åˆ¤æ–­ä¸€ä¸ªæ•°æ˜¯å¦æ•°2çš„å¹‚ï¼Œä¹Ÿå°±æ˜¯åªæœ‰ä¸€ä¸ªäºŒè¿›åˆ¶ä½ï¼Œä¸”ä¸ºæ­£æ•° 123456class Solution {public: bool isPowerOfTwo(int n) { return n &gt; 0 &amp;&amp; (n &amp;(n-1)) == 0; }}; 342. 4çš„å¹‚ ä¹Ÿå°±æ˜¯åªæœ‰ä¸€ä¸ªäºŒè¿›åˆ¶ä½ï¼Œä¸”æ˜¯å¶æ•°æ¬¡å¹‚çš„ä½ï¼Œä¸”ä¸æ˜¯ç¬¬0ä½ï¼Œè€Œä¸”æ˜¯æ­£æ•° 123456class Solution {public: bool isPowerOfFour(int n) { return (!(n&amp;0xaaaaaaaa) &amp;&amp; n &gt; 0 &amp;&amp; !(n&amp;(n-1))); }}; 287. å¯»æ‰¾é‡å¤æ•° æ²¡åšå‡ºæ¥ï¼Œå†æ¥å†å‰ 318. æœ€å¤§å•è¯é•¿åº¦ä¹˜ç§¯ è¦æ±‚ä¸åŒ…å«ç›¸åŒå­—æ¯ å¯ä»¥å°†å­—ç¬¦ä¸²å«æœ‰çš„å­—ç¬¦ç¼–ç æˆäºŒè¿›åˆ¶ï¼Œåˆ©ç”¨ä¸è¿ç®—çš„ç»“æœåˆ¤æ–­æ˜¯å¦æœ‰ç›¸åŒå­—ç¬¦ 1234567891011121314151617181920212223class Solution {public: int maxProduct(vector&lt;string&gt;&amp; words) { int n = words.size(); map&lt;int, int&gt; bitMap; for(int i = 0; i &lt; n; i++) { int mask = 0; for(auto ite = words[i].rbegin(); ite != words[i].rend(); ite++) { mask |= 1 &lt;&lt; (*ite - 'a'); } bitMap[mask] = max(bitMap[mask], (int)words[i].length()); } int maxRes = 0; for(auto ite = bitMap.begin(); ite != bitMap.end(); ite++) { map&lt;int, int&gt;::iterator jte = ite; jte++; for(; jte != bitMap.end(); jte++) { if((ite-&gt;first &amp; jte-&gt;first) == 0) maxRes = max(maxRes, ite-&gt;second * jte-&gt;second); } } return maxRes; }}; 338. æ¯”ç‰¹ä½è®¡æ•° è¦æ±‚å¯»æ‰¾[0,n]ä¸­æ‰€æœ‰æ•°çš„æ¯”ç‰¹ä½æ•° æ²¡åšå‡ºæ¥ï¼Œå†æ¥å†å‰ dpï¼Œå¯¹äºå¶æ•°ï¼ŒäºŒè¿›åˆ¶æ•°ç­‰äº(i &gt;&gt; 2),å¯¹äºå¥‡æ•°ï¼Œç­‰äº(i &gt;&gt; 2) + 1 12345678910class Solution {public: vector&lt;int&gt; countBits(int num) { vector&lt;int&gt; ans(num+1, 0); for(int i = 1; i &lt;= num; i++) { ans[i] = ans[i &gt;&gt; 1] + (i &amp; 1); } return ans; }}; 371. ä¸¤æ•´æ•°ä¹‹å’Œ å¤ä¹ ä¸€ä¸‹æ•°ç”µçš„çŸ¥è¯†å°±å¥½å•¦ 1234567891011// 0 0 0 0 0// 0 0 1 1 0// 0 1 0 1 0// 0 1 1 0 1 ~abc// 1 0 0 1 0// 1 0 1 0 1 a~bc// 1 1 0 0 1 ab~c// 1 1 1 1 1 abc// ~abc + a~bc + ab~c + abc// bc + a(~bc+b~c)// bc + a(b^c) 123456789101112131415class Solution {public: int getSum(int a, int b) { int carry = 0; int sum = 0; int mask = 1; for(int i = 0; i &lt; 32; i++) { sum |= (a ^ b ^ carry) &amp; mask; carry = (b&amp;carry) | (a &amp; (b ^ carry)); carry &lt;&lt;= 1; mask &lt;&lt;= 1; } return sum; }}; 389. æ‰¾ä¸åŒå±…ç„¶æ²¡æƒ³åˆ°ï¼Œé•¿å¤§åå†è¯•è¯•å§ 393. UTF-8 ç¼–ç éªŒè¯ä¸»è¦æ˜¯åº”ç”¨ä½è¿ç®—ï¼Œè¿˜æ˜¯å…³ç³»ä¸å¤§ 123456789101112131415161718192021222324252627class Solution {public: bool validUtf8(vector&lt;int&gt;&amp; data) { int n = data.size(); for(int i = 0; i &lt; n; i++) { int cnt = (0xf8 &amp; data[i]) &gt;&gt; 3; // printf(&quot;%x, %x\\n&quot;, cnt, data[i]); if(cnt &lt; 0x10) { cnt = 0; } else if(cnt &gt;= 0x18 &amp;&amp; cnt &lt; 0x1c) { cnt = 1; } else if(cnt &gt;= 0x1c &amp;&amp; cnt &lt; 0x1e) { cnt = 2; } else if(cnt == 0x1e) { cnt = 3; } else { return false; } while(cnt--) { i++; if(i &gt;= n) return false; if((data[i] &amp; 0xc0) != 0x80) return false; } } return true; }}; 397. æ•´æ•°æ›¿æ¢æš´åŠ›+è®°å¿†ä¼˜åŒ–1234567891011class Solution { unordered_map&lt;int, int&gt; cnt;public: int integerReplacement(int n) { if(cnt.count(n)) return cnt[n]; if(n == 1) cnt[n] = 0; else if(n&amp;1) cnt[n] = 2 + min(integerReplacement(n&gt;&gt;1), integerReplacement((n&gt;&gt;1) + 1)); else cnt[n] = 1 + integerReplacement(n &gt;&gt; 1); return cnt[n]; }}; è´ªå¿ƒ å¶æ•°ï¼Œç›´æ¥é™¤ä»¥2 å¥‡æ•°ï¼Œé™¤ä»¥4ä½™æ•°ä¸º1ï¼Œ-1ï¼Œç›¸å½“äºå°½é‡é¿å…å¥‡æ•°çš„å‡ºç°ï¼Œå»¶è¿Ÿå¥‡æ•°çš„å‡ºç°ï¼Œå› ä¸ºå¥‡æ•°æ“ä½œæ•°æ˜¯2ï¼Œå¶æ•°æ˜¯1 å¥‡æ•°ï¼Œé™¤ä»¥4ä½™æ•°ä¸º3ï¼Œ+1ï¼Œç›¸å½“äºå°½é‡é¿å…å¥‡æ•°çš„å‡ºç°ï¼Œå»¶è¿Ÿå¥‡æ•°çš„å‡ºç°ï¼Œå› ä¸ºå¥‡æ•°æ“ä½œæ•°æ˜¯2ï¼Œå¶æ•°æ˜¯1123456789101112131415161718192021222324252627282930class Solution { unordered_map&lt;int, int&gt; cnt;public: int integerReplacement(int n) { cnt[3] = 2; if(cnt.count(n)) return cnt[n]; int nn = n; while(n &gt; 1) { int add = 0; if(!(n&amp;1)) { add = 1; n &gt;&gt;= 1; } else { add = 2; if((n &gt;&gt; 1) &amp; 1) { n &gt;&gt;= 1; n++; } else { n &gt;&gt;= 1; } } if(cnt.count(n)) { cnt[nn] += add + cnt[n]; break; } cnt[nn] += add; } return cnt[nn]; }}; 401. äºŒè¿›åˆ¶æ‰‹è¡¨åˆ©ç”¨äºŒè¿›åˆ¶åšçŠ¶æ€ çŠ¶æ€+æ£€æŸ¥bitCount12345678910111213141516171819202122232425class Solution {public: int bitCount(int n) { int cnt = 0; while(n) { if(n &amp; 1) cnt++; n &gt;&gt;= 1; } return cnt; } vector&lt;string&gt; readBinaryWatch(int turnedOn) { vector&lt;string&gt; res; for(int h = 0; h &lt; 16; h++) { for(int m = 0; m &lt; 64; m++) { if(bitCount(h) + bitCount(m) != turnedOn) continue; char time[6]; if(h &gt;= 0 &amp;&amp; h &lt; 12 &amp;&amp; m &gt;= 0 &amp;&amp; m &lt; 60) { sprintf(time, &quot;%d:%02d&quot;, h, m); res.push_back(time); } } } return res; }}; æ ¼é›·ç ç”¨æ ¼é›·ç çš„ç‰¹æ€§ï¼Œbitcountæ¯æ¬¡åªä¼šåŠ 1æˆ–å‡ä¸€ï¼Œçœå»bitcountsçš„è®¡ç®— 1234567891011121314151617181920212223242526272829303132class Solution {public: vector&lt;string&gt; readBinaryWatch(int turnedOn) { vector&lt;string&gt; res; int hBitCount = 0; int H = 0; int lastH = 0, lastM = 0; for(int h = 0; h &lt; 16; h++) { int M = 0; int mBitCount = 0; lastH = H; H = h^(h &gt;&gt; 1); if(H &amp; (lastH ^ H)) hBitCount++; else if(h) hBitCount--; // printf(&quot;H=%x, hBitCount=%d\\n&quot;, H, hBitCount); for(int m = 0; m &lt; 64; m++) { lastM = M; M = m^(m &gt;&gt; 1); if(M &amp; (lastM ^ M)) mBitCount++; else if(m) mBitCount--; // printf(&quot;M=%x, mBitCount=%d\\n&quot;, M, mBitCount); if(hBitCount + mBitCount != turnedOn) continue; char time[6]; if(H &gt;= 0 &amp;&amp; H &lt; 12 &amp;&amp; M &gt;= 0 &amp;&amp; M &lt; 60) { sprintf(time, &quot;%d:%02d&quot;, H, M); res.push_back(time); } } } return res; }}; 405. æ•°å­—è½¬æ¢ä¸ºåå…­è¿›åˆ¶æ•°1234567891011121314class Solution { static constexpr int m[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};public: string toHex(int num) { int cnt = 8; string res; while(cnt-- &amp;&amp; !(0xf &amp; (num &gt;&gt; (cnt * 4)))); if(cnt &gt;= 0) do { res.push_back(m[0xf &amp; (num &gt;&gt; (cnt * 4))]); } while(cnt--); else return &quot;0&quot;; return res; }}; 421. æ•°ç»„ä¸­ä¸¤ä¸ªæ•°çš„æœ€å¤§å¼‚æˆ–å€¼æ²¡å†™å‡ºæ¥ï¼Œé¢˜è§£ä¹Ÿæ˜¯ä¸€ä½ä¸€ä½çš„ç®— æ€»ç»“ æŠ€å·§ä¸€ï¼šåˆ©ç”¨äºŒè¿›åˆ¶åšçŠ¶æ€ç  æŠ€å·§äºŒï¼šè®¡ç§‘åŸºç¡€ï¼ŒåŠ æ³•å™¨ã€æ•°ç”µ æŠ€å·§ä¸‰ï¼šåˆ©ç”¨äºŒè¿›åˆ¶å‡å°‘è®¡ç®—é‡ï¼Œå¯¹çŠ¶æ€å°‘çš„æ•°æ®è¿›è¡Œç¼–ç ï¼Œç”¨ä½è¿ç®—ä¸€æ¬¡è®¡ç®—å¤šä¸ªæ•°æ® æŠ€å·§å››ï¼šè€ƒå¯Ÿå¸¸ç”¨æŠ€å·§ æŠ€å·§äº”ï¼šåˆ©ç”¨æ ¼é›·ç ä¼˜åŒ– æŠ€å·§å…­ï¼šé€ä½è®¡ç®—ç»“æœ","link":"/home/2023/11/05/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"title":"PTA-Advance-1001","text":"PROBLEMCalculate a+b and output the sum in standard format â€“ that is, the digits must be separated into groups of three by commas (unless there are less than four digits). Input Specification:Each input file contains one test case. Each case contains a pair of integers a and b where $âˆ’10^6â‰¤a,bâ‰¤10^6$. The numbers are separated by a space. Output Specification:For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format. Sample Input:1-1000000 9 Sample Output:1-999,991 ACCEPTED CODE12345678910111213141516#include &lt;iostream&gt;using namespace std;int main () { int a, b; string ans; char temp[32] = {0}; scanf (&quot;%d%d&quot;, &amp;a, &amp;b); int c = a + b; sprintf(temp, &quot;%d&quot;, c); ans = temp; for (int i = ans.length() - 1, count = 1; i &gt; 0; i--, count++) if (count % 3 == 0 &amp;&amp; ans[i - 1] != '-') ans.insert(i, 1, ','); printf (&quot;%s&quot;, ans.data()); return 0;} THINKING AND NOTICE Insert a comma every 3 character. Traversal the string from the end of it. If the result of a+b is negative, check that there are no negative sign - before inserting a comma,. REFLECTION AND COMMENTS Relatively easy. Hope that I can stick to using English to write articles.","link":"/home/2019/07/13/PAT-(Advanced-Level)-Practice/1001-A+B-Format(PAT-(Advanced-Level)-Practice)/"},{"title":"PAT-Basic-1014","text":"é¢˜ç›® å¤§ä¾¦æ¢ç¦å°”æ‘©æ–¯æ¥åˆ°ä¸€å¼ å¥‡æ€ªçš„å­—æ¡ï¼šæˆ‘ä»¬çº¦ä¼šå§ï¼ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnmã€‚å¤§ä¾¦æ¢å¾ˆå¿«å°±æ˜ç™½äº†ï¼Œå­—æ¡ä¸Šå¥‡æ€ªçš„ä¹±ç å®é™…ä¸Šå°±æ˜¯çº¦ä¼šçš„æ—¶é—´æ˜ŸæœŸå›› 14:04ï¼Œå› ä¸ºå‰é¢ä¸¤å­—ç¬¦ä¸²ä¸­ç¬¬ 1 å¯¹ç›¸åŒçš„å¤§å†™è‹±æ–‡å­—æ¯ï¼ˆå¤§å°å†™æœ‰åŒºåˆ†ï¼‰æ˜¯ç¬¬ 4 ä¸ªå­—æ¯ Dï¼Œä»£è¡¨æ˜ŸæœŸå››ï¼›ç¬¬ 2 å¯¹ç›¸åŒçš„å­—ç¬¦æ˜¯ E ï¼Œé‚£æ˜¯ç¬¬ 5 ä¸ªè‹±æ–‡å­—æ¯ï¼Œä»£è¡¨ä¸€å¤©é‡Œçš„ç¬¬ 14 ä¸ªé’Ÿå¤´ï¼ˆäºæ˜¯ä¸€å¤©çš„ 0 ç‚¹åˆ° 23 ç‚¹ç”±æ•°å­— 0 åˆ° 9ã€ä»¥åŠå¤§å†™å­—æ¯ A åˆ° N è¡¨ç¤ºï¼‰ï¼›åé¢ä¸¤å­—ç¬¦ä¸²ç¬¬ 1 å¯¹ç›¸åŒçš„è‹±æ–‡å­—æ¯ s å‡ºç°åœ¨ç¬¬ 4 ä¸ªä½ç½®ï¼ˆä» 0 å¼€å§‹è®¡æ•°ï¼‰ä¸Šï¼Œä»£è¡¨ç¬¬ 4 åˆ†é’Ÿã€‚ç°ç»™å®šä¸¤å¯¹å­—ç¬¦ä¸²ï¼Œè¯·å¸®åŠ©ç¦å°”æ‘©æ–¯è§£ç å¾—åˆ°çº¦ä¼šçš„æ—¶é—´ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥åœ¨ 4 è¡Œä¸­åˆ†åˆ«ç»™å‡º 4 ä¸ªéç©ºã€ä¸åŒ…å«ç©ºæ ¼ã€ä¸”é•¿åº¦ä¸è¶…è¿‡ 60 çš„å­—ç¬¦ä¸²ã€‚ è¾“å‡ºæ ¼å¼ï¼š åœ¨ä¸€è¡Œä¸­è¾“å‡ºçº¦ä¼šçš„æ—¶é—´ï¼Œæ ¼å¼ä¸º DAY HH:MMï¼Œå…¶ä¸­ DAY æ˜¯æŸæ˜ŸæœŸçš„ 3 å­—ç¬¦ç¼©å†™ï¼Œå³ MON è¡¨ç¤ºæ˜ŸæœŸä¸€ï¼ŒTUE è¡¨ç¤ºæ˜ŸæœŸäºŒï¼ŒWED è¡¨ç¤ºæ˜ŸæœŸä¸‰ï¼ŒTHU è¡¨ç¤ºæ˜ŸæœŸå››ï¼ŒFRI è¡¨ç¤ºæ˜ŸæœŸäº”ï¼ŒSAT è¡¨ç¤ºæ˜ŸæœŸå…­ï¼ŒSUN è¡¨ç¤ºæ˜ŸæœŸæ—¥ã€‚é¢˜ç›®è¾“å…¥ä¿è¯æ¯ä¸ªæµ‹è¯•å­˜åœ¨å”¯ä¸€è§£ã€‚ è¾“å…¥æ ·ä¾‹ï¼š3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm è¾“å‡ºæ ·ä¾‹ï¼šTHU 14:04 é€šè¿‡ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;int main() { string clue[4]; int day, hour, minute; string week[7] = {&quot;MON&quot;, &quot;TUE&quot;, &quot;WED&quot;, &quot;THU&quot;, &quot;FRI&quot;, &quot;SAT&quot;, &quot;SUN&quot;}; for (int i = 0; i &lt; 4; i++) { cin &gt;&gt; clue[i]; } int count = -1; int y = 0; char c[2]; for (int i = 0; i &lt; min(clue[0].length(), clue[1].length()); i++) { if (count == -1 &amp;&amp; clue[0][i] == clue[1][i] &amp;&amp; (clue[0][i] &gt;= 'A' &amp;&amp; clue[0][i] &lt;= 'G')) { c[++count] = clue[0][i]; } if (count == 0 &amp;&amp; clue[0][i] == clue[1][i]) { if ((clue[0][i] &gt;= '0' &amp;&amp; clue[0][i] &lt;= '9') || (clue[0][i] &gt;= 'A' &amp;&amp; clue[0][i] &lt;= 'N')) { y++; } if (y == 2) { c[++count] = clue[0][i]; } } if (count == 1) { break; } } day = c[0] - 'A' + 1; if (c[1] &gt;= '0' &amp;&amp; c[1] &lt;= '9') { hour = c[1] - '0'; } else { hour = c[1] - 'A' + 10; } int pos = 0; for (int i = 0; i &lt; min(clue[2].length(), clue[3].length()); i++) { if (clue[2][i] == clue[3][i] &amp;&amp; ((clue[2][i] &gt;= 'a' &amp;&amp; clue[2][i] &lt;= 'z') || (clue[2][i] &gt;= 'A' &amp;&amp; clue[2][i] &lt;= 'Z'))) { pos = i; break; } } minute = pos; printf(&quot;%s %02d:%02d\\n&quot;, week[day - 1].data(), hour, minute); return 0;} æ€è·¯ä¸æ³¨æ„ è¿™é“é¢˜å®åœ¨æ˜¯å¤ªå’¬æ–‡åš¼å­—äº†ï¼ï¼ ç¬¬ä¸€ä¸ªçº¿ç´¢å¿…é¡»æ˜¯â€™Aâ€™ åˆ° â€˜Gâ€™ \bç›¸åŒï¼Œå› ä¸ºä¸€å‘¨åªæœ‰7å¤© ç¬¬äºŒä¸ªçº¿ç´¢å¿…é¡»æ˜¯ç¬¬äºŒä¸ªç›¸åŒçš„å­—ç¬¦ï¼Œè€Œä¸”å¿…é¡»æ˜¯â€™0â€™-â€˜9â€™æˆ–â€™Aâ€™-â€˜Nâ€™çš„ï¼Œå› ä¸ºä¸€å¤©åªæœ‰24ä¸ªå°æ—¶ï¼ˆæ„Ÿè§‰é¢˜ç›®è‡ªå·±å’Œè‡ªå·±çŸ›ç›¾ï¼Œé¢˜ç›®ä¸å¤ªä¸¥è°¨ï¼‰ ç¬¬äºŒä¸ªçº¿ç´¢å¿…é¡»åœ¨ç¬¬ä¸€ä¸ªçº¿ç´¢çš„ä½ç½®åé¢å¼€å§‹æ‰¾ï¼ˆ\bï¼Ÿï¼Ÿï¼Ÿ\båæ­£æˆ‘ä»é¢˜é‡Œé¢å¾ˆéš¾è¯»å‡ºæ¥ï¼‰ åæ€ä¸è¯„ä»· å¾ˆè®¨åŒçš„ä¸€é“é¢˜ï¼Œçº¯å±æµªè´¹äººæ—¶é—´ï¼Œåšä¸å‡ºæ¥ä¹Ÿä¸çº ç»“å®ƒä¹Ÿå¯ä»¥çš„ã€‚","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1014-%E7%A6%8F%E5%B0%94%E6%91%A9%E6%96%AF%E7%9A%84%E7%BA%A6%E4%BC%9A(PAT-(Basic-Level)-Practice)/"},{"title":"LeetCode-æ’åº","text":"å¤ä¹ æ’åºç®—æ³• ç¨³å®šæ€§å®¹æ˜“è®°é”™çš„æ˜¯é€‰æ‹©æ’åº é€‰æ‹©æ’åºæ˜¯ä»æœªæ’åºä¸­é€‰æ‹©æœ€å°çš„ï¼Œç›´æ¥ä¸æœªæ’åºçš„ç¬¬ä¸€ä¸ªäº¤æ¢ï¼Œæ‰€ä»¥ä¸ç¨³å®š é€‰æ‹©æ’åºæ˜¯ä»æœªæ’åºä¸­é€‰æ‹©æœ€å°çš„ï¼Œæ’å…¥åˆ°å·²æ’åºçš„åé¢ï¼Œå°±æ˜¯ç¨³å®šçš„ å…ˆæ‰‹å†™ä¸€éå¸¸è§æ’åºç®—æ³• æ¯”è¾ƒæ’åº äº¤æ¢æ’åº å†’æ³¡ å¿«æ’ æ’å…¥æ’åº ç®€å•æ’å…¥ å¸Œå°”æ’åº é€‰æ‹©æ’åº ç®€å•é€‰æ‹© å †æ’åº å½’å¹¶æ’åº äºŒè·¯å½’å¹¶ å¤šè·¯å½’å¹¶ éæ¯”è¾ƒæ’åº è®¡æ•°æ’åº æ¡¶æ’åº åŸºæ•°æ’åº 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#include &lt;random&gt;using namespace std;template &lt;typename T&gt;void printVec(const vector&lt;T&gt;&amp; vec, function&lt;string(const T&amp;)&gt; toString);template&lt;typename T&gt;void bubbleSort(vector&lt;T&gt;&amp; vec, function&lt;int(const T&amp;, const T&amp;)&gt; compare) { int len = vec.size(); for(int i = 0; i &lt; len; i++) { for(int j = 0; j &lt; len - i - 1; j++) { if(compare(vec[j], vec[j+1]) &gt; 0) { swap(vec[j], vec[j+1]); } } }}template&lt;typename T&gt;void selectSort(vector&lt;T&gt;&amp; vec, function&lt;int(const T&amp;, const T&amp;)&gt; compare) { int len = vec.size(); for(int i = 0; i &lt; len; i++) { int minIndex = i; for(int j = i+1; j &lt; len; j++) { if(compare(vec[minIndex], vec[j]) &gt; 0) { minIndex = j; } } swap(vec[i], vec[minIndex]); }}template&lt;typename T&gt;void stableSelectSort(vector&lt;T&gt;&amp; vec, function&lt;int(const T&amp;, const T&amp;)&gt; compare) { int len = vec.size(); for(int i = 0; i &lt; len; i++) { int minIndex = i; for(int j = i+1; j &lt; len; j++) { if(compare(vec[minIndex], vec[j]) &gt; 0) { minIndex = j; } } T t = vec[minIndex]; for(int j = minIndex; j &gt; i; j--) { vec[j] = vec[j-1]; } vec[i] = t; }}template&lt;typename T&gt;void insertSort(vector&lt;T&gt;&amp; vec, function&lt;int(const T&amp;, const T&amp;)&gt; compare) { int len = vec.size(); for(int i = 0; i &lt; len-1; i++) { // ä¸‹é¢æ˜¯i+1ï¼Œè¿™é‡Œè¦len-1 for(int j = i+1; j &gt; 0; j--) { if(compare(vec[j], vec[j-1]) &lt; 0) { swap(vec[j], vec[j-1]); } else { break; } } }}template&lt;typename T&gt;void mergeSort(vector&lt;T&gt;&amp; vec, function&lt;int(const T&amp;, const T&amp;)&gt; compare, int start, int end) { if(end - start &lt;= 1) return; int mid = (end - start) / 2 + start; mergeSort(vec, compare, start, mid); mergeSort(vec, compare, mid, end); // merge vector&lt;T&gt; tmp(end - start); int cur = 0, i = start, j = mid; while(i &lt; mid &amp;&amp; j &lt; end) { if(compare(vec[i], vec[j]) &lt;= 0) { // ç¨³å®šæ€§ tmp[cur++] = vec[i++]; } else { tmp[cur++] = vec[j++]; } } while(i &lt; mid) { tmp[cur++] = vec[i++]; } while(j &lt; end) { tmp[cur++] = vec[j++]; } for(i = start; i &lt; end; i++) { vec[i] = tmp[i - start]; }}template&lt;typename T&gt;void mergeSort(vector&lt;T&gt;&amp; vec, function&lt;int(const T&amp;, const T&amp;)&gt; compare) { int len = vec.size(); mergeSort(vec, compare, 0, len);}template&lt;typename T&gt;void quickSort(vector&lt;T&gt;&amp; vec, function&lt;int(const T&amp;, const T&amp;)&gt; compare, int start, int end) { if(end - start &lt;= 1) return; int i = start, j = end - 1; while(i &lt; j) { while(i &lt; j &amp;&amp; compare(vec[i], vec[j]) &lt;= 0) j--; swap(vec[j], vec[i]); while(i &lt; j &amp;&amp; compare(vec[i], vec[j]) &lt;= 0) i++; swap(vec[i], vec[j]); } quickSort(vec, compare, start, i); quickSort(vec, compare, i+1, end); // i + 1, å·²æ’åºçš„æ¢è½´å°±ä¸ç”¨äº†}template&lt;typename T&gt;void quickSort(vector&lt;T&gt;&amp; vec, function&lt;int(const T&amp;, const T&amp;)&gt; compare) { int len = vec.size(); quickSort(vec, compare, 0, len);}template&lt;typename T&gt;void heapAdjust(vector&lt;T&gt;&amp; vec, int i, int end, function&lt;int(const T&amp;, const T&amp;)&gt; compare) { for(int j = i; ; ) { int largest = j; if(j*2+1 &lt; end &amp;&amp; compare(vec[largest], vec[j*2+1]) &lt; 0) { largest = j*2+1; } if(j*2+2 &lt; end &amp;&amp; compare(vec[largest], vec[j*2+2]) &lt; 0) { largest = j*2+2; } if(j == largest) break; swap(vec[j], vec[largest]); j = largest; }}template&lt;typename T&gt;void heapSort(vector&lt;T&gt;&amp; vec, function&lt;int(const T&amp;, const T&amp;)&gt; compare) { int len = vec.size(); // heapAdjust// for(int i = len-1; i &gt; 0; i--) {// if(compare(vec[i], vec[(i+1)/2-1]) &gt; 0) {// swap(vec[i], vec[(i+1)/2-1]);// }// } //wrong for(int i = len/2; i &gt;= 0; i--) { heapAdjust(vec, i, len, compare); } // sort for(int i = len-1; i &gt; 0; i--) { swap(vec[0], vec[i]); heapAdjust(vec, 0, i, compare); }}const int MAX_NUMBER = 1000;const int MIN_NUMBER = -1000;const int MAX_LEN = 2000000;template &lt;typename T&gt;int compare(const T&amp; a, const T&amp; b) { if(a == b) return 0; else if(a &gt; b) return 1; else return -1;}template &lt;typename T&gt;void printVec(const vector&lt;T&gt;&amp; vec, function&lt;string(const T&amp;)&gt; toString) { cout &lt;&lt; &quot;[&quot;; if(vec.size() &gt; 0) cout &lt;&lt; toString(vec[0]); for(size_t i = 1; i &lt; vec.size(); i++) { cout &lt;&lt; &quot;, &quot; &lt;&lt; toString(vec[i]); } cout &lt;&lt; &quot;]\\n&quot;;}clock_t execTime(const function&lt;void(vector&lt;pair&lt;int, int&gt;&gt; &amp;)&gt;&amp; f, vector&lt;pair&lt;int, int&gt;&gt; &amp;vec) { clock_t start = clock(); f(vec); clock_t end = clock(); return end - start;}void speedTest(decltype(bubbleSort&lt;pair&lt;int, int&gt;&gt;) sort, vector&lt;pair&lt;int, int&gt;&gt; &amp;a, vector&lt;pair&lt;int, int&gt;&gt; b) { auto cmp = [](const pair&lt;int, int&gt;&amp; x, const pair&lt;int, int&gt;&amp; y){ return compare(x.first, y.first); }; clock_t our = execTime([&amp;](vector&lt;pair&lt;int, int&gt;&gt; &amp; vec) {sort(vec, cmp);}, a); clock_t libc = execTime([](vector&lt;pair&lt;int, int&gt;&gt; &amp; vec) {std::sort(vec.begin(), vec.end());}, b); cout &lt;&lt; &quot;our: &quot; &lt;&lt; our &lt;&lt; &quot;, libc: &quot; &lt;&lt; libc &lt;&lt; &quot;, promoted: &quot; &lt;&lt; double(libc - our) / double(libc) * 100 &lt;&lt; &quot;%&quot; &lt;&lt; endl;}void test(decltype(bubbleSort&lt;pair&lt;int, int&gt;&gt;) sort, bool is_stable) { int len = rand() % MAX_LEN; vector&lt;pair&lt;int, int&gt;&gt; vec; map&lt;int, int&gt; cnt; for(int i = 0; i &lt; len; i++) { int num = rand() % (MAX_NUMBER - MIN_NUMBER) + MIN_NUMBER; vec.emplace_back(num, ++cnt[num]); } speedTest(sort, vec, vec); bool stability = true, ok = true; for(int i = 0; i &lt; len - 1; i++) { cnt[vec[i].first]--; if(compare(vec[i].first, vec[i+1].first) &gt; 0) { ok = false; } else if(compare(vec[i].first, vec[i+1].first) == 0) { if(vec[i].second + 1 != vec[i+1].second) { stability = false; } } } if(len &gt; 0) cnt[vec[len-1].first]--; for(auto &amp; ite : cnt) { if(ite.second != 0) { ok = false; break; } }// cout &lt;&lt; &quot;ok: &quot; &lt;&lt; ok &lt;&lt; &quot;, stable: &quot; &lt;&lt; stability &lt;&lt; endl; if(!ok) { printVec&lt;pair&lt;int, int&gt;&gt;(vec, [](const pair&lt;int, int&gt;&amp; item) { stringstream ss; ss &lt;&lt; &quot;{&quot; &lt;&lt; item.first &lt;&lt; &quot;, &quot; &lt;&lt; item.second &lt;&lt; &quot;}&quot;; return ss.str(); }); throw runtime_error(&quot;sort failed!\\n&quot;); } if(is_stable &amp;&amp; !stability) { throw runtime_error(&quot;stability not match&quot;); }}int main() { srand(time(NULL)); test(bubbleSort, true); test(selectSort, false); test(stableSelectSort, true); test(insertSort, true); test(mergeSort, true); test(quickSort, false); test(heapSort, false);}","link":"/home/2024/03/17/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%E6%8E%92%E5%BA%8F/"},{"title":"PTA-Advance-1002","text":"PROBLEMThis time, you are supposed to find A+B where A and B are two polynomials. Input Specification:Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 â€¦ NK aNK where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1,2,â‹¯,K) are the exponents and coefficients, respectively. It is given that 1â‰¤Kâ‰¤10ï¼Œ0â‰¤NK&lt;â‹¯&lt;N2&lt;N1â‰¤1000. Output Specification:For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place. Sample Input:122 1 2.4 0 3.22 2 1.5 1 0.5 Sample Output:13 2 1.5 1 2.9 0 3.2 ACCEPTED CODE1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int main () { map&lt;int , double, greater&lt;int&gt;&gt; m; int k, count = 0; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) { double exp , cof; cin &gt;&gt; exp &gt;&gt; cof; m[exp] += cof; } cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) { double exp , cof; cin &gt;&gt; exp &gt;&gt; cof; m[exp] += cof; if (m[exp] == 0) count++;//if this item is zero, count++ } printf (&quot;%d&quot;, m.size() - count);//print the nonzero item num, if result is zero, print zero for (map&lt;int, double&gt;::iterator ite = m.begin(); ite != m.end(); ite++) { if (ite-&gt;second != 0)//if this item is zero, do not print printf (&quot; %d %.1lf&quot;, ite-&gt;first, ite-&gt;second); } return 0;} THINKING AND NOTICES Creating a map from the exponents to coefficients. Add up the two coefficients of each exponents. Print a zero(the total number of nonzero items) if the result of a+b is zero. Map will sort your data by the keys in declining order, but you should print it in increasing order, so give map the third parameter â€“ the class or struct name which has a member function like this:bool operator() (const double&amp; str1, const double&amp; str2);, a function (Iâ€™m not sure.) greater&lt;int&gt; ,or you can simply traversal the map from the end of it. REFLECTION AND COMMENT Noting to reflect.","link":"/home/2019/07/13/PAT-(Advanced-Level)-Practice/1002-A+B-for-Polynomials(PAT-(Advanced-Level)-Practice)/"},{"title":"PAT-Basic-1005","text":"é¢˜ç›® å¡æ‹‰å…¹(Callatz)çŒœæƒ³å·²ç»åœ¨1001ä¸­ç»™å‡ºäº†æè¿°ã€‚åœ¨è¿™ä¸ªé¢˜ç›®é‡Œï¼Œæƒ…å†µç¨å¾®æœ‰äº›å¤æ‚ã€‚ å½“æˆ‘ä»¬éªŒè¯å¡æ‹‰å…¹çŒœæƒ³çš„æ—¶å€™ï¼Œä¸ºäº†é¿å…é‡å¤è®¡ç®—ï¼Œå¯ä»¥è®°å½•ä¸‹é€’æ¨è¿‡ç¨‹ä¸­é‡åˆ°çš„æ¯ä¸€ä¸ªæ•°ã€‚ä¾‹å¦‚å¯¹ n=3 è¿›è¡ŒéªŒè¯çš„æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦è®¡ç®— 3ã€5ã€8ã€4ã€2ã€1ï¼Œåˆ™å½“æˆ‘ä»¬å¯¹ n=5ã€8ã€4ã€2 è¿›è¡ŒéªŒè¯çš„æ—¶å€™ï¼Œå°±å¯ä»¥ç›´æ¥åˆ¤å®šå¡æ‹‰å…¹çŒœæƒ³çš„çœŸä¼ªï¼Œè€Œä¸éœ€è¦é‡å¤è®¡ç®—ï¼Œå› ä¸ºè¿™ 4 ä¸ªæ•°å·²ç»åœ¨éªŒè¯3çš„æ—¶å€™é‡åˆ°è¿‡äº†ï¼Œæˆ‘ä»¬ç§° 5ã€8ã€4ã€2 æ˜¯è¢« 3â€œè¦†ç›–â€çš„æ•°ã€‚æˆ‘ä»¬ç§°ä¸€ä¸ªæ•°åˆ—ä¸­çš„æŸä¸ªæ•° n ä¸ºâ€œå…³é”®æ•°â€ï¼Œå¦‚æœ n ä¸èƒ½è¢«æ•°åˆ—ä¸­çš„å…¶ä»–æ•°å­—æ‰€è¦†ç›–ã€‚ ç°åœ¨ç»™å®šä¸€ç³»åˆ—å¾…éªŒè¯çš„æ•°å­—ï¼Œæˆ‘ä»¬åªéœ€è¦éªŒè¯å…¶ä¸­çš„å‡ ä¸ªå…³é”®æ•°ï¼Œå°±å¯ä»¥ä¸å¿…å†é‡å¤éªŒè¯ä½™ä¸‹çš„æ•°å­—ã€‚ä½ çš„ä»»åŠ¡å°±æ˜¯æ‰¾å‡ºè¿™äº›å…³é”®æ•°å­—ï¼Œå¹¶æŒ‰ä»å¤§åˆ°å°çš„é¡ºåºè¾“å‡ºå®ƒä»¬ã€‚ è¾“å…¥æ ¼å¼ï¼š æ¯ä¸ªæµ‹è¯•è¾“å…¥åŒ…å« 1 ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œç¬¬ 1 è¡Œç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° K (&lt;100)ï¼Œç¬¬ 2 è¡Œç»™å‡º K ä¸ªäº’ä¸ç›¸åŒçš„å¾…éªŒè¯çš„æ­£æ•´æ•° n (1&lt;nâ‰¤100)çš„å€¼ï¼Œæ•°å­—é—´ç”¨ç©ºæ ¼éš”å¼€ã€‚ è¾“å‡ºæ ¼å¼ï¼š æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹çš„è¾“å‡ºå ä¸€è¡Œï¼ŒæŒ‰ä»å¤§åˆ°å°çš„é¡ºåºè¾“å‡ºå…³é”®æ•°å­—ã€‚æ•°å­—é—´ç”¨ 1 ä¸ªç©ºæ ¼éš”å¼€ï¼Œä½†ä¸€è¡Œä¸­æœ€åä¸€ä¸ªæ•°å­—åæ²¡æœ‰ç©ºæ ¼ã€‚ è¾“å…¥æ ·ä¾‹ï¼š1263 5 6 7 8 11 è¾“å‡ºæ ·ä¾‹ï¼š17 6 é€šè¿‡ä»£ç ï¼ˆæè‡´å‹è¡Œç‰ˆï¼‰12345678910111213141516#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int arr[999999], brr[999999], n;int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n &amp;&amp; cin &gt;&gt; brr[i]; i++) for (int t = brr[i]; t != 1;) if (t % 2 == 0) arr[t /= 2] = 1; else arr[t = (3 * t + 1) / 2] = 1; sort(brr, brr + n, greater&lt;int&gt;()); for (int i = 0, count = 0; i &lt; n; i++) if (!arr[brr[i]] &amp;&amp; count++ == 0) cout &lt;&lt; brr[i]; else if (!arr[brr[i]])cout &lt;&lt; &quot; &quot; &lt;&lt; brr[i]; return 0;} é€šè¿‡ä»£ç 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int arr[999999];int main() { int n; cin &gt;&gt; n; int brr[n] = {0}; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; brr[i]; for (int t = brr[i]; t != 1;) { if (t % 2 == 0) { arr[t/=2] = 1; } else { arr[t = (3*t + 1)/2] = 1; } } } sort(brr, brr+n, greater&lt;int&gt;()); for (int i = 0, count = 0; i &lt; n; i++) { if (!arr[brr[i]]) { if (count++ == 0) cout &lt;&lt; brr[i]; else cout &lt;&lt; &quot; &quot; &lt;&lt; brr[i]; } } return 0;} æ€è·¯ æ•°å­—å½“å¼•ç´¢çš„æ•°ç»„å­˜æ˜¯å¦å­˜åœ¨çš„çœŸå‡å€¼","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1005-%E7%BB%A7%E7%BB%AD(3n+1)%E7%8C%9C%E6%83%B3(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1018","text":"é¢˜ç›® å¤§å®¶åº”è¯¥éƒ½ä¼šç©â€œé”¤å­å‰ªåˆ€å¸ƒâ€çš„æ¸¸æˆï¼šä¸¤äººåŒæ—¶ç»™å‡ºæ‰‹åŠ¿ï¼Œèƒœè´Ÿè§„åˆ™å¦‚å›¾æ‰€ç¤ºï¼š ç°ç»™å‡ºä¸¤äººçš„äº¤é”‹è®°å½•ï¼Œè¯·ç»Ÿè®¡åŒæ–¹çš„èƒœã€å¹³ã€è´Ÿæ¬¡æ•°ï¼Œå¹¶ä¸”ç»™å‡ºåŒæ–¹åˆ†åˆ«å‡ºä»€ä¹ˆæ‰‹åŠ¿çš„èƒœç®—æœ€å¤§ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥ç¬¬ 1 è¡Œç»™å‡ºæ­£æ•´æ•° Nï¼ˆâ‰¤10^5ï¼‰ï¼Œå³åŒæ–¹äº¤é”‹çš„æ¬¡æ•°ã€‚éšå N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€æ¬¡äº¤é”‹çš„ä¿¡æ¯ï¼Œå³ç”²ã€ä¹™åŒæ–¹åŒæ—¶ç»™å‡ºçš„çš„æ‰‹åŠ¿ã€‚C ä»£è¡¨â€œé”¤å­â€ã€J ä»£è¡¨â€œå‰ªåˆ€â€ã€B ä»£è¡¨â€œå¸ƒâ€ï¼Œç¬¬ 1 ä¸ªå­—æ¯ä»£è¡¨ç”²æ–¹ï¼Œç¬¬ 2 ä¸ªä»£è¡¨ä¹™æ–¹ï¼Œä¸­é—´æœ‰ 1 ä¸ªç©ºæ ¼ã€‚ è¾“å‡ºæ ¼å¼ï¼š è¾“å‡ºç¬¬ 1ã€2 è¡Œåˆ†åˆ«ç»™å‡ºç”²ã€ä¹™çš„èƒœã€å¹³ã€è´Ÿæ¬¡æ•°ï¼Œæ•°å­—é—´ä»¥ 1 ä¸ªç©ºæ ¼åˆ†éš”ã€‚ç¬¬ 3 è¡Œç»™å‡ºä¸¤ä¸ªå­—æ¯ï¼Œåˆ†åˆ«ä»£è¡¨ç”²ã€ä¹™è·èƒœæ¬¡æ•°æœ€å¤šçš„æ‰‹åŠ¿ï¼Œä¸­é—´æœ‰ 1 ä¸ªç©ºæ ¼ã€‚å¦‚æœè§£ä¸å”¯ä¸€ï¼Œåˆ™è¾“å‡ºæŒ‰å­—æ¯åºæœ€å°çš„è§£ã€‚ è¾“å…¥æ ·ä¾‹ï¼š10 C J J B C B B B B C C C C B J B B C J J è¾“å‡ºæ ·ä¾‹ï¼š5 3 2 2 3 5 B B 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;using namespace std;class Player { private: int win; int equal; int lose; int cw; int jw; int bw; char op; public: Player() { win = 0; lose = 0; equal = 0; cw = 0; jw = 0; bw = 0; op = 'n'; } void setOp(char a) { op = a; } static void game(Player &amp;a, Player &amp;b) { if (a.op == 'C') { if (b.op == 'C') { a.equal++; b.equal++; } else if (b.op == 'J') { a.win++; a.cw++; b.lose++; } else if (b.op == 'B') { a.lose++; b.win++; b.bw++; } } else if (a.op == 'J') { if (b.op == 'C') { a.lose++; b.win++; b.cw++; } else if (b.op == 'J') { a.equal++; b.equal++; } else if (b.op == 'B') { a.win++; a.jw++; b.lose++; } } else if (a.op == 'B') { if (b.op == 'C') { a.win++; b.lose++; a.bw++; } else if (b.op == 'J') { a.lose++; b.win++; b.jw++; } else if (b.op == 'B') { a.equal++; b.equal++; } } } void showCondition() { cout &lt;&lt; win &lt;&lt; &quot; &quot; &lt;&lt; equal &lt;&lt; &quot; &quot; &lt;&lt; lose &lt;&lt; endl; } char showMost() { if (jw &gt; cw) { if (jw &gt; bw) return 'J'; else return 'B'; } else if (jw == cw) { if (jw &gt; bw) return 'C'; else return 'B'; } else { if (cw &lt;= bw) return 'B'; else return 'C'; } }};int main(){ int n; cin &gt;&gt; n; cin.ignore(); Player a, b; for (int i = 0; i &lt; n; i++) { char aop, bop; cin &gt;&gt; aop; cin.ignore(); cin &gt;&gt; bop; cin.ignore(); a.setOp(aop); b.setOp(bop); Player::game(a, b); } a.showCondition(); b.showCondition(); cout &lt;&lt; a.showMost() &lt;&lt; &quot; &quot; &lt;&lt; b.showMost() &lt;&lt; endl; return 0;} æ€è·¯ä¸æ³¨æ„ æ²¡ä»€ä¹ˆå¥½ä¸»æ„çš„ï¼Œç®€å•é¢˜ åæ€ä¸è¯„ä»· æ²¡ä»€ä¹ˆå¥½åæ€çš„ éè¦åæ€çš„è¯ï¼Œå‹è¡Œæ˜¯é—¨æŠ€æœ¯æ´»","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1018-%E9%94%A4%E5%AD%90%E5%89%AA%E5%88%80%E5%B8%83(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1020","text":"é¢˜ç›® æœˆé¥¼æ˜¯ä¸­å›½äººåœ¨ä¸­ç§‹ä½³èŠ‚æ—¶åƒçš„ä¸€ç§ä¼ ç»Ÿé£Ÿå“ï¼Œä¸åŒåœ°åŒºæœ‰è®¸å¤šä¸åŒé£å‘³çš„æœˆé¥¼ã€‚ç°ç»™å®šæ‰€æœ‰ç§ç±»æœˆé¥¼çš„åº“å­˜é‡ã€æ€»å”®ä»·ã€ä»¥åŠå¸‚åœºçš„æœ€å¤§éœ€æ±‚é‡ï¼Œè¯·ä½ è®¡ç®—å¯ä»¥è·å¾—çš„æœ€å¤§æ”¶ç›Šæ˜¯å¤šå°‘ã€‚ æ³¨æ„ï¼šé”€å”®æ—¶å…è®¸å–å‡ºä¸€éƒ¨åˆ†åº“å­˜ã€‚æ ·ä¾‹ç»™å‡ºçš„æƒ…å½¢æ˜¯è¿™æ ·çš„ï¼šå‡å¦‚æˆ‘ä»¬æœ‰ 3 ç§æœˆé¥¼ï¼Œå…¶åº“å­˜é‡åˆ†åˆ«ä¸º 18ã€15ã€10 ä¸‡å¨ï¼Œæ€»å”®ä»·åˆ†åˆ«ä¸º 75ã€72ã€45 äº¿å…ƒã€‚å¦‚æœå¸‚åœºçš„æœ€å¤§éœ€æ±‚é‡åªæœ‰ 20 ä¸‡å¨ï¼Œé‚£ä¹ˆæˆ‘ä»¬æœ€å¤§æ”¶ç›Šç­–ç•¥åº”è¯¥æ˜¯å–å‡ºå…¨éƒ¨ 15 ä¸‡å¨ç¬¬ 2 ç§æœˆé¥¼ã€ä»¥åŠ 5 ä¸‡å¨ç¬¬ 3 ç§æœˆé¥¼ï¼Œè·å¾— 72 + 45/2 = 94.5ï¼ˆäº¿å…ƒï¼‰ã€‚ è¾“å…¥æ ¼å¼ï¼š æ¯ä¸ªè¾“å…¥åŒ…å«ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹ã€‚æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹å…ˆç»™å‡ºä¸€ä¸ªä¸è¶…è¿‡ 1000 çš„æ­£æ•´æ•° N è¡¨ç¤ºæœˆé¥¼çš„ç§ç±»æ•°ã€ä»¥åŠä¸è¶…è¿‡ 500ï¼ˆä»¥ä¸‡å¨ä¸ºå•ä½ï¼‰çš„æ­£æ•´æ•° D è¡¨ç¤ºå¸‚åœºæœ€å¤§éœ€æ±‚é‡ã€‚éšåä¸€è¡Œç»™å‡º N ä¸ªæ­£æ•°è¡¨ç¤ºæ¯ç§æœˆé¥¼çš„åº“å­˜é‡ï¼ˆä»¥ä¸‡å¨ä¸ºå•ä½ï¼‰ï¼›æœ€åä¸€è¡Œç»™å‡º N ä¸ªæ­£æ•°è¡¨ç¤ºæ¯ç§æœˆé¥¼çš„æ€»å”®ä»·ï¼ˆä»¥äº¿å…ƒä¸ºå•ä½ï¼‰ã€‚æ•°å­—é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚ è¾“å‡ºæ ¼å¼ï¼š å¯¹æ¯ç»„æµ‹è¯•ç”¨ä¾‹ï¼Œåœ¨ä¸€è¡Œä¸­è¾“å‡ºæœ€å¤§æ”¶ç›Šï¼Œä»¥äº¿å…ƒä¸ºå•ä½å¹¶ç²¾ç¡®åˆ°å°æ•°ç‚¹å 2 ä½ã€‚ è¾“å…¥æ ·ä¾‹ï¼š1233 2018 15 1075 72 45 è¾“å‡ºæ ·ä¾‹ï¼š194.50 é€šè¿‡ä»£ç 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct moonCake {double storage, money, price;};bool cmp(moonCake&amp; a, moonCake&amp; b) {return a.price &gt; b.price;}int main () { int n, m, i;//æœˆé¥¼ç§ç±»ï¼Œå¸‚åœºéœ€æ±‚ï¼Œå¾ªç¯å˜é‡ï¼ˆå‹è¡Œï¼‰ cin &gt;&gt; n &gt;&gt; m; moonCake data[n]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; data[i].storage;//è¾“å…¥ for (int i = 0; i &lt; n; i++) {//è¾“å…¥ cin &gt;&gt; data[i].money; data[i].price = data[i].money/data[i].storage; } sort(data, data + n, cmp); double sale = 0, temp; for (i = 0; i != n &amp;&amp; m; i++, m-= temp) {//æ¯æ¬¡å¾ªç¯ï¼Œmå‡å»å–å‡ºå»çš„è´¨é‡ temp = m &lt; data[i].storage ? m : data[i].storage; sale += temp/data[i].storage * data[i].money; } printf(&quot;%.2lf\\n&quot;, sale); return 0;} æ€è·¯ä¸æ³¨æ„ è´ªå¿ƒç®—æ³•ï¼Œåœ¨é™åˆ¶å‡ºå”®çš„æ€»è´¨é‡ä¸€å®šæ—¶ï¼Œå–å‡ºçš„è´§ç‰©çš„å¹³å‡å•ä»·è¶Šå¤§ï¼Œåˆ©æ¶¦è¶Šé«˜ï¼Œå³å°½é‡å¤šå–å‡ºå­˜é‡/æ€»å”®ä»·å¤§çš„æœˆé¥¼ è¾“å…¥æ•°æ®ï¼Œè®¡ç®—å‡ºå•ä»·ï¼ˆå­˜é‡/æ€»å”®ä»·ï¼‰ï¼Œæ ¹æ®å•ä»·é™åºæ’åº å–æœˆé¥¼ï¼Œå°½é‡å¤šçš„ä¹°ï¼Œå¦‚æœå­˜é‡å°äºç­‰äºmï¼Œåˆ™å…¨éƒ¨å–å‡ºï¼Œå¦‚æœå­˜é‡å¤§äºmï¼Œå°±å–å‡ºmï¼Œå³å–å‡ºmä¸å­˜é‡çš„æœ€æœ€å°å€¼ è®¡ç®—å”®ä»·ï¼ŒåŠ èµ·æ¥ è¾“å‡º æ³¨æ„ï¼šæŠŠæ•°æ®å…¨æ”¹æˆdoubleï¼Œä¹Ÿè®¸æ˜¯intä¼šæº¢å‡º åæ€ä¸è¯„ä»· è¿™é¢˜æŒºå¥½ åˆšå¼€å§‹è¿˜æƒ³æš´åŠ›æ±‚è§£ï¼Œè¿˜TMDå†™ä¸å‡ºæ¥nä¸ªforå¾ªç¯åµŒå¥—ï¼ˆæ‰‹åŠ¨ç¬‘å“­ï¼‰ åŸæ¥æˆ‘å­¦ä¼šè´ªå¿ƒç®—æ³•äº†å•Šï¼Œå“ˆå“ˆå“ˆ å‹è¡Œå‹ä¸Šç˜¾äº†","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1020-%E6%9C%88%E9%A5%BC%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1033","text":"é¢˜ç›® æ—§é”®ç›˜ä¸Šåäº†å‡ ä¸ªé”®ï¼Œäºæ˜¯åœ¨æ•²ä¸€æ®µæ–‡å­—çš„æ—¶å€™ï¼Œå¯¹åº”çš„å­—ç¬¦å°±ä¸ä¼šå‡ºç°ã€‚ç°åœ¨ç»™å‡ºåº”è¯¥è¾“å…¥çš„ä¸€æ®µæ–‡å­—ã€ä»¥åŠåæ‰çš„é‚£äº›é”®ï¼Œæ‰“å‡ºçš„ç»“æœæ–‡å­—ä¼šæ˜¯æ€æ ·ï¼Ÿ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥åœ¨ 2 è¡Œä¸­åˆ†åˆ«ç»™å‡ºåæ‰çš„é‚£äº›é”®ã€ä»¥åŠåº”è¯¥è¾“å…¥çš„æ–‡å­—ã€‚å…¶ä¸­å¯¹åº”è‹±æ–‡å­—æ¯çš„åé”®ä»¥å¤§å†™ç»™å‡ºï¼›æ¯æ®µæ–‡å­—æ˜¯ä¸è¶…è¿‡ 10^5ä¸ªå­—ç¬¦çš„ä¸²ã€‚å¯ç”¨çš„å­—ç¬¦åŒ…æ‹¬å­—æ¯ [a-z, A-Z]ã€æ•°å­— 0-9ã€ä»¥åŠä¸‹åˆ’çº¿ **_ï¼ˆä»£è¡¨ç©ºæ ¼ï¼‰ã€,ã€.ã€-ã€+**ï¼ˆä»£è¡¨ä¸Šæ¡£é”®ï¼‰ã€‚é¢˜ç›®ä¿è¯ç¬¬ 2 è¡Œè¾“å…¥çš„æ–‡å­—ä¸²éç©ºã€‚æ³¨æ„ï¼šå¦‚æœä¸Šæ¡£é”®åæ‰äº†ï¼Œé‚£ä¹ˆå¤§å†™çš„è‹±æ–‡å­—æ¯æ— æ³•è¢«æ‰“å‡ºã€‚ è¾“å‡ºæ ¼å¼ï¼š åœ¨ä¸€è¡Œä¸­è¾“å‡ºèƒ½å¤Ÿè¢«æ‰“å‡ºçš„ç»“æœæ–‡å­—ã€‚å¦‚æœæ²¡æœ‰ä¸€ä¸ªå­—ç¬¦èƒ½è¢«æ‰“å‡ºï¼Œåˆ™è¾“å‡ºç©ºè¡Œã€‚ è¾“å…¥æ ·ä¾‹ï¼š7+IE. 7_This_is_a_test. è¾“å‡ºæ ·ä¾‹ï¼š_hs_s_a_tst é€šè¿‡ä»£ç 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;int main () { string err; string origin; int chart[200] = {0}; char temp[100010] = {0}; cin.getline(temp, sizeof(temp)); err = temp; cin.getline(temp, sizeof(temp)); origin = temp; bool shift = false; for (int i = 0; i &lt; err.length(); i++) { chart[err[i]] = -1; if (err[i] == '+') {shift = true;} else { if (err[i] &gt;= 'a' &amp;&amp; err[i] &lt;= 'z'){ chart[err[i] - 'a' + 'A'] = -1; } if (err[i] &gt;= 'A' &amp;&amp; err[i] &lt;= 'Z') { chart[err[i] - 'A' + 'a'] = -1; } } } if (shift) { for (int i = 'A'; i &lt;= 'Z'; i++) chart[i] = -1; } for (int i = 0; i &lt; origin.length(); i++) { if (chart[origin[i]] != -1) cout &lt;&lt; origin[i]; } cout &lt;&lt; endl; return 0;} æ€è·¯ä¸æ³¨æ„ è¿™é“é¢˜åˆæ˜¯å¾ˆå‘çš„ä¸€é“é¢˜ 121. è¾“å…¥æ ·ä¾‹åçš„'.'ä¸çŸ¥é“æ˜¯ç®—shifté”®è¿˜æ˜¯æ™®é€šé”®2. å®é™…ä»£ç ä¸­åªæœ‰'+'æ‰æ˜¯shiftï¼Œå…¶ä»–éƒ½ä¸æ˜¯ è¦æ˜ç¡®å¦‚æœä¸€ä¸ªé”®åæ‰ï¼Œé‚£ä¹ˆå®ƒå¯¹åº”çš„å¤§å°å†™éƒ½ä¸èƒ½ç”¨äº†ï¼Œå¦‚æœshifté”®ä¸èƒ½ç”¨äº†ï¼Œæ‰€æœ‰çš„å¤§å†™å­—æ¯éƒ½ä¸èƒ½ç”¨äº† é‡‡ç”¨æŸ¥è¡¨æ³•ï¼ŒæŠŠä¸èƒ½ç”¨çš„é”®éƒ½å˜æˆ-1ï¼Œå…¶ä»–éƒ½æ˜¯0 åæ€ä¸è¯„ä»· åˆæ˜¯å‘é¢˜ï¼Œå¾ˆè®¨åŒ","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1033-%E6%97%A7%E9%94%AE%E7%9B%98%E6%89%93%E5%AD%97(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1025","text":"é¢˜ç›® ç»™å®šä¸€ä¸ªå¸¸æ•° K ä»¥åŠä¸€ä¸ªå•é“¾è¡¨ Lï¼Œè¯·ç¼–å†™ç¨‹åºå°† L ä¸­æ¯ K ä¸ªç»“ç‚¹åè½¬ã€‚ä¾‹å¦‚ï¼šç»™å®š L ä¸º 1â†’2â†’3â†’4â†’5â†’6ï¼ŒK ä¸º 3ï¼Œåˆ™è¾“å‡ºåº”è¯¥ä¸º 3â†’2â†’1â†’6â†’5â†’4ï¼›å¦‚æœ K ä¸º 4ï¼Œåˆ™è¾“å‡ºåº”è¯¥ä¸º 4â†’3â†’2â†’1â†’5â†’6ï¼Œå³æœ€åä¸åˆ° K ä¸ªå…ƒç´ ä¸åè½¬ã€‚ è¾“å…¥æ ¼å¼ï¼š æ¯ä¸ªè¾“å…¥åŒ…å« 1 ä¸ªæµ‹è¯•ç”¨ä¾‹ã€‚æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ç¬¬ 1 è¡Œç»™å‡ºç¬¬ 1 ä¸ªç»“ç‚¹çš„åœ°å€ã€ç»“ç‚¹æ€»ä¸ªæ•°æ­£æ•´æ•° N (â‰¤10^5)ã€ä»¥åŠæ­£æ•´æ•° K (â‰¤N)ï¼Œå³è¦æ±‚åè½¬çš„å­é“¾ç»“ç‚¹çš„ä¸ªæ•°ã€‚ç»“ç‚¹çš„åœ°å€æ˜¯ 5 ä½éè´Ÿæ•´æ•°ï¼ŒNULL åœ°å€ç”¨ âˆ’1 è¡¨ç¤ºã€‚æ¥ä¸‹æ¥æœ‰ N è¡Œï¼Œæ¯è¡Œæ ¼å¼ä¸ºï¼šAddress Data Nextå…¶ä¸­ Address æ˜¯ç»“ç‚¹åœ°å€ï¼ŒData æ˜¯è¯¥ç»“ç‚¹ä¿å­˜çš„æ•´æ•°æ•°æ®ï¼ŒNext æ˜¯ä¸‹ä¸€ç»“ç‚¹çš„åœ°å€ã€‚ è¾“å‡ºæ ¼å¼ï¼š å¯¹æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œé¡ºåºè¾“å‡ºåè½¬åçš„é“¾è¡¨ï¼Œå…¶ä¸Šæ¯ä¸ªç»“ç‚¹å ä¸€è¡Œï¼Œæ ¼å¼ä¸è¾“å…¥ç›¸åŒã€‚ è¾“å…¥æ ·ä¾‹ï¼š00100 6 4 00000 4 99999 00100 1 12309 68237 6 -1 33218 3 00000 99999 5 68237 12309 2 33218 è¾“å‡ºæ ·ä¾‹ï¼š00000 4 33218 33218 3 12309 12309 2 00100 00100 1 99999 99999 5 68237 68237 6 -1 é€šè¿‡ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct node { int add; int next; int data;};int main () { int first, num, k; scanf (&quot;%d%d%d&quot;, &amp;first, &amp;num, &amp;k); vector&lt;node&gt; v(100005); node temp; for (int i = 0; i &lt; num; i++) { scanf (&quot;%d%d%d&quot;, &amp;temp.add, &amp;temp.data, &amp;temp.next); v[temp.add] = temp; } int find = first; vector&lt;node&gt; x; while (find != -1) { x.push_back(v[find]); find = v[find].next; } num = (int)x.size(); for (int i = 0; i &lt; num/k; i++) { for (int j = (i+1)*k - 1,m = 0; m &lt; k/2; m++) { temp = x[j-m]; x[j-m] = x[j-k+1+m]; x[j-k+1+m] = temp; } } for (int i = 0; i &lt; num - 1; i++) { printf (&quot;%05d %d %05d\\n&quot;, x[i].add, x[i].data, x[i+1].add); } printf (&quot;%05d %d -1\\n&quot;, x[num - 1].add, x[num - 1].data); return 0;} æ€è·¯ä¸æ³¨æ„ åŸæ¥çš„æ€è·¯æ˜¯mallocåˆ›å»ºæ•°ç»„ï¼Œç„¶ånodeç»“æ„ä½“ææˆæŒ‡é’ˆçš„æ ·å­ï¼Œææˆä¸€ä¸ªæ—¢æ˜¯æ•°ç»„åˆæ˜¯é“¾è¡¨çš„ä¸œè¥¿ï¼Œç»“æœå•Šï¼Œè¶Šé«˜è¶Šå¤æ‚ã€‚ æä¸€ä¸ªvectoræ•°ç»„ï¼Œç”¨äºæŸ¥è¡¨ï¼ŒæŠŠåœ°å€\bä½œä¸ºå¼•ç´¢ ç„¶åæ ¹æ®\bé¦–åœ°å€ä¸€ç›´æŸ¥æ‰¾åˆ°ç»“æŸï¼ŒæŒ‰é¡ºåºæåˆ°ä¸€ä¸ªvectoré‡Œé¢ å¤„ç†åè½¬å…³ç³» è¾“å‡º åæ€ä¸è¯„ä»· ç”¨ä¹‹å‰çš„æƒ³æ³•å†™ä¸å‡ºæ¥å¾ˆ\bä¸å¼€å¿ƒï¼Œä¸è¿‡stlçœŸå¿ƒç‰›é€¼ï¼","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1025-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1044","text":"é¢˜ç›® ç«æ˜Ÿäººæ˜¯ä»¥ 13 è¿›åˆ¶è®¡æ•°çš„ï¼š åœ°çƒäººçš„ 0 è¢«ç«æ˜Ÿäººç§°ä¸º tretã€‚ åœ°çƒäººæ•°å­— 1 åˆ° 12 çš„ç«æ˜Ÿæ–‡åˆ†åˆ«ä¸ºï¼šjan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, decã€‚ ç«æ˜Ÿäººå°†è¿›ä½ä»¥åçš„ 12 ä¸ªé«˜ä½æ•°å­—åˆ†åˆ«ç§°ä¸ºï¼štam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jouã€‚ ä¾‹å¦‚åœ°çƒäººçš„æ•°å­— 29 ç¿»è¯‘æˆç«æ˜Ÿæ–‡å°±æ˜¯ hel marï¼›è€Œç«æ˜Ÿæ–‡ elo nov å¯¹åº”åœ°çƒæ•°å­— 115ã€‚ä¸ºäº†æ–¹ä¾¿äº¤æµï¼Œè¯·ä½ ç¼–å†™ç¨‹åºå®ç°åœ°çƒå’Œç«æ˜Ÿæ•°å­—ä¹‹é—´çš„äº’è¯‘ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆ&lt;100ï¼‰ï¼Œéšå N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä¸ª [0, 169) åŒºé—´å†…çš„æ•°å­— â€”â€” æˆ–è€…æ˜¯åœ°çƒæ–‡ï¼Œæˆ–è€…æ˜¯ç«æ˜Ÿæ–‡ã€‚ è¾“å‡ºæ ¼å¼ï¼š å¯¹åº”è¾“å…¥çš„æ¯ä¸€è¡Œï¼Œåœ¨ä¸€è¡Œä¸­è¾“å‡ºç¿»è¯‘åçš„å¦ä¸€ç§è¯­è¨€çš„æ•°å­—ã€‚ è¾“å…¥æ ·ä¾‹ï¼š123454295elo novtam è¾“å‡ºæ ·ä¾‹ï¼š1234hel marmay11513 é€šè¿‡ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;ctype.h&gt;using namespace std;string num[2][13] = { {&quot;tret&quot;, &quot;jan&quot;, &quot;feb&quot;, &quot;mar&quot;, &quot;apr&quot;, &quot;may&quot;, &quot;jun&quot;, &quot;jly&quot;, &quot;aug&quot;, &quot;sep&quot;, &quot;oct&quot;, &quot;nov&quot;, &quot;dec&quot;}, {&quot;tret&quot;, &quot;tam&quot;, &quot;hel&quot;, &quot;maa&quot;, &quot;huh&quot;, &quot;tou&quot;, &quot;kes&quot;, &quot;hei&quot;, &quot;elo&quot;, &quot;syy&quot;, &quot;lok&quot;, &quot;mer&quot;, &quot;jou&quot;}};void C(string&amp; str) { int n = atoi(str.data()); string ans; int count = 0; for (int tn = n; tn; tn /= 13, count++); if (count == 1 || count == 0) ans = num[0][n]; else ans = num[1][n / 13] + ((n % 13 != 0) ? (&quot; &quot; + num[0][n % 13]) : &quot;&quot;); cout &lt;&lt; ans &lt;&lt; endl;}int D(string&amp; str) { if (str == &quot;tret&quot;) return 0; string a, b; a = str.substr(0, 3); if (str.length() &gt; 3) b = str.substr(4, str.length() - 3); if (b == &quot;&quot;) { for (int i = 0; i &lt; 13; i++) if (a == num[0][i]) return i; for (int i = 0; i &lt; 13; i++) if (a == num[1][i]) return i * 13; } else { int n = 0; for (int i = 0; i &lt; 13; i++) if (a == num[1][i]) n += i * 13; for (int i = 0; i &lt; 13; i++) if (b == num[0][i]) n += i; return n; }}int main() { int n; cin &gt;&gt; n; getchar(); for (int i = 0; i &lt; n; i++) { string temp; getline(cin, temp); if (!isalpha(temp[0])) C(temp); else cout &lt;&lt; D(temp) &lt;&lt; endl; } return 0;} æ€è·¯ä¸æ³¨æ„ 13, 26, 39â€¦è½¬æ¢ä¸º13è¿›åˆ¶åï¼Œtretä¸è¾“å‡º é¢˜ç›®è¯´æ•°æ˜¯å±äº[0,169)çš„ï¼Œæ‰€ä»¥ç¿»è¯‘ä»¥åæœ€å¤šæœ‰ä¸¤ä½ã€‚æ ¹æ®è¿™ä¸ªæ€§è´¨ï¼Œåªç®—ä¸¤ä½å°±å¥½ã€‚","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1044-%E7%81%AB%E6%98%9F%E6%95%B0%E5%AD%97(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1040","text":"é¢˜ç›® å­—ç¬¦ä¸² APPAPT ä¸­åŒ…å«äº†ä¸¤ä¸ªå•è¯ PATï¼Œå…¶ä¸­ç¬¬ä¸€ä¸ª PAT æ˜¯ç¬¬ 2 ä½(P)ï¼Œç¬¬ 4 ä½(A)ï¼Œç¬¬ 6 ä½(T)ï¼›ç¬¬äºŒä¸ª PAT æ˜¯ç¬¬ 3 ä½(P)ï¼Œç¬¬ 4 ä½(A)ï¼Œç¬¬ 6 ä½(T)ã€‚ ç°ç»™å®šå­—ç¬¦ä¸²ï¼Œé—®ä¸€å…±å¯ä»¥å½¢æˆå¤šå°‘ä¸ª PATï¼Ÿ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥åªæœ‰ä¸€è¡Œï¼ŒåŒ…å«ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œé•¿åº¦ä¸è¶…è¿‡105ï¼ŒåªåŒ…å« Pã€Aã€T ä¸‰ç§å­—æ¯ã€‚ è¾“å‡ºæ ¼å¼ï¼š åœ¨ä¸€è¡Œä¸­è¾“å‡ºç»™å®šå­—ç¬¦ä¸²ä¸­åŒ…å«å¤šå°‘ä¸ª PATã€‚ç”±äºç»“æœå¯èƒ½æ¯”è¾ƒå¤§ï¼Œåªè¾“å‡ºå¯¹ 1000000007 å–ä½™æ•°çš„ç»“æœã€‚ è¾“å…¥æ ·ä¾‹ï¼š1APPAPT è¾“å‡ºæ ·ä¾‹ï¼š12 é€šè¿‡ä»£ç 1234567891011121314#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { char n[100100] = {0}; scanf(&quot;%s&quot;, n); int len = strlen(n); long long pat = 0, at = 0, t = 0; for (int i = len - 1; i &gt;= 0; i--) { if (n[i] == 'T') t++; if (n[i] == 'A') at = (at + t) % 1000000007; if (n[i] == 'P') pat = (pat + at) % 1000000007; } printf(&quot;%lld\\n&quot;, pat % 1000000007);} æ€è·¯ä¸æ³¨æ„ é¢˜ç›®é™åˆ¶150msï¼Œåº”è¯¥åªæœ‰O(N)çš„ç®—æ³•æ‰å¯ä»¥ æ²¡æ€è·¯ æœ‰å‡ ä¸ªPATï¼ˆ25ï¼‰çœ‹è¿™é‡Œ åæ€ä¸è¯„ä»· è¿™é¢˜æŒºå¥½ è¿™é“é¢˜æ²¡æ€è·¯ï¼Œçœ‹é¢˜ç›®è¦æ±‚150mså°±çŸ¥é“è¿™é¢˜ç”¨O(N)çš„æ–¹æ³•æ‰è¡Œï¼Œæœæ–­é—®åº¦å¨˜æ‰¾äº†æ€è·¯ã€‚æœ‰å‡ ä¸ªPATï¼ˆ25ï¼‰ å¯èƒ½æ˜¯è‡ªå·±è„‘å­ä¸å¤Ÿç”¨å§","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1040-%E6%9C%89%E5%87%A0%E4%B8%AAPAT(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1045","text":"é¢˜ç›® è‘—åçš„å¿«é€Ÿæ’åºç®—æ³•é‡Œæœ‰ä¸€ä¸ªç»å…¸çš„åˆ’åˆ†è¿‡ç¨‹ï¼šæˆ‘ä»¬é€šå¸¸é‡‡ç”¨æŸç§æ–¹æ³•å–ä¸€ä¸ªå…ƒç´ ä½œä¸ºä¸»å…ƒï¼Œé€šè¿‡äº¤æ¢ï¼ŒæŠŠæ¯”ä¸»å…ƒå°çš„å…ƒç´ æ”¾åˆ°å®ƒçš„å·¦è¾¹ï¼Œæ¯”ä¸»å…ƒå¤§çš„å…ƒç´ æ”¾åˆ°å®ƒçš„å³è¾¹ã€‚ ç»™å®šåˆ’åˆ†åçš„ N ä¸ªäº’ä¸ç›¸åŒçš„æ­£æ•´æ•°çš„æ’åˆ—ï¼Œè¯·é—®æœ‰å¤šå°‘ä¸ªå…ƒç´ å¯èƒ½æ˜¯åˆ’åˆ†å‰é€‰å–çš„ä¸»å…ƒï¼Ÿ ä¾‹å¦‚ç»™å®š $N = 5$, æ’åˆ—æ˜¯1ã€3ã€2ã€4ã€5ã€‚åˆ™ï¼š 1 çš„å·¦è¾¹æ²¡æœ‰å…ƒç´ ï¼Œå³è¾¹çš„å…ƒç´ éƒ½æ¯”å®ƒå¤§ï¼Œæ‰€ä»¥å®ƒå¯èƒ½æ˜¯ä¸»å…ƒï¼› å°½ç®¡ 3 çš„å·¦è¾¹å…ƒç´ éƒ½æ¯”å®ƒå°ï¼Œä½†å…¶å³è¾¹çš„ 2 æ¯”å®ƒå°ï¼Œæ‰€ä»¥å®ƒä¸èƒ½æ˜¯ä¸»å…ƒï¼› å°½ç®¡ 2 çš„å³è¾¹å…ƒç´ éƒ½æ¯”å®ƒå¤§ï¼Œä½†å…¶å·¦è¾¹çš„ 3 æ¯”å®ƒå¤§ï¼Œæ‰€ä»¥å®ƒä¸èƒ½æ˜¯ä¸»å…ƒï¼› ç±»ä¼¼åŸå› ï¼Œ4 å’Œ 5 éƒ½å¯èƒ½æ˜¯ä¸»å…ƒã€‚ å› æ­¤ï¼Œæœ‰ 3 ä¸ªå…ƒç´ å¯èƒ½æ˜¯ä¸»å…ƒã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥åœ¨ç¬¬ 1 è¡Œä¸­ç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤105ï¼‰ï¼› ç¬¬ 2 è¡Œæ˜¯ç©ºæ ¼åˆ†éš”çš„ N ä¸ªä¸åŒçš„æ­£æ•´æ•°ï¼Œæ¯ä¸ªæ•°ä¸è¶…è¿‡ 109ã€‚ è¾“å‡ºæ ¼å¼ï¼š åœ¨ç¬¬ 1 è¡Œä¸­è¾“å‡ºæœ‰å¯èƒ½æ˜¯ä¸»å…ƒçš„å…ƒç´ ä¸ªæ•°ï¼›åœ¨ç¬¬ 2 è¡Œä¸­æŒ‰é€’å¢é¡ºåºè¾“å‡ºè¿™äº›å…ƒç´ ï¼Œå…¶é—´ä»¥ 1 ä¸ªç©ºæ ¼åˆ†éš”ï¼Œè¡Œé¦–å°¾ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚ è¾“å…¥æ ·ä¾‹ï¼š1251 3 2 4 5 è¾“å‡ºæ ·ä¾‹ï¼š1231 4 5 é€šè¿‡ä»£ç  123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int arr[1000000], brr[1000000], crr[1000000];int main () { int n, m = 0; scanf (&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) { scanf (&quot;%d&quot;, &amp;arr[i]); brr[i] = arr[i]; } sort(brr, brr + n); int max = -999999; for (int i = 0; i &lt; n; i++) { if (max &lt; arr[i]) max = arr[i]; if (arr[i] == brr[i] &amp;&amp; max == arr[i]) { crr[m++] = arr[i]; } } printf (&quot;%d\\n&quot;, m); if (m &gt; 0) printf(&quot;%d&quot;, crr[0]); for (int i = 1; i &lt; m ; i++) { printf (&quot; %d&quot;, crr[i]); } printf (&quot;\\n&quot;); return 0;} æ€è·¯ä¸æ³¨æ„ åªè¦æ»¡è¶³ä¸€ä¸ªæ•°çš„å·¦è¾¹æ²¡æœ‰æ•°æˆ–è€…æ•°éƒ½æ¯”å®ƒå°ï¼Œå³è¾¹æ²¡æœ‰å…ƒç´ æˆ–è€…éƒ½æ¯”å®ƒå¤§ï¼Œå®ƒå°±å¯èƒ½æ˜¯ä¸»å…ƒã€‚æ ¹æ®è¿™ä¸ªæ€è·¯ï¼Œå†™ä¸€ä¸ªO(N^2)çš„ç®—æ³•è‚¯å®šä¼šè¶…æ—¶ æ ¹æ®å¿«é€Ÿæ’åºçš„æ€æƒ³ï¼ŒæŒ‘é€‰ä¸€ä¸ªæ•°ä½œä¸ºä¸»å…ƒï¼ŒæŠŠæ¯”å®ƒå°çš„æ•°æ”¾å·¦è¾¹ï¼Œæ¯”å®ƒå¤§çš„æ”¾å³è¾¹ï¼Œè¿™æ ·ç„¶åä»¥ä¸»å…ƒä¸ºåˆ†ç•Œçº¿ï¼Œä¸¤è¾¹è§†ä¸ºä¸¤ä¸ªæ•°ç»„é‡æ–°è¿›è¡Œä»¥ä¸Šæ“ä½œï¼Œç›´åˆ°ä¸èƒ½å†ç»†åˆ†ã€‚æ’åºå®Œæˆã€‚æˆ‘ä»¬å¯ä»¥å¾—åˆ°ä¸»å…ƒåœ¨æ’åºå‰åä½ç½®ä¸å˜ä¸”å·¦è¾¹çš„æ•°éƒ½æ¯”å®ƒå°ï¼Œè¿™æ ·ï¼Œç®—æ³•å°±å˜æˆäº† å¯¹æ•°ç»„è¿›è¡Œæ’åºï¼Œæ¯”è¾ƒé‚£äº›å…ƒç´ çš„ä½ç½®æ²¡æœ‰å˜ åˆ¤æ–­è¿™ä¸ªæ•°æ˜¯ä¸æ˜¯ä»å·¦å¾€å³çš„æœ€å¤§å€¼ è¿™æ ·å°±O(N)äº† åæ€ä¸è¯„ä»· å¿«é€Ÿæ’åº(25)å‚è€ƒäº†è¿™ä¸ªæ•™ç¨‹ï¼Œå¸Œæœ›ä»¥åèƒ½æ›´å¤šçš„ç‹¬ç«‹æ€è€ƒï¼Œé”»ç‚¼æ€è€ƒèƒ½åŠ› åŠ æ²¹å°å¤©å¤©ãƒ¾(â—Â°âˆ‡Â°â—)ï¾‰ï¾ï¼Œä½ æ˜¯æœ€èƒ–çš„ï¼","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1045-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1015","text":"é¢˜ç›® å®‹ä»£å²å­¦å®¶å¸é©¬å…‰åœ¨ã€Šèµ„æ²»é€šé‰´ã€‹ä¸­æœ‰ä¸€æ®µè‘—åçš„â€œå¾·æ‰è®ºâ€ï¼šâ€œæ˜¯æ•…æ‰å¾·å…¨å°½è°“ä¹‹åœ£äººï¼Œæ‰å¾·å…¼äº¡è°“ä¹‹æ„šäººï¼Œå¾·èƒœæ‰è°“ä¹‹å›å­ï¼Œæ‰èƒœå¾·è°“ä¹‹å°äººã€‚å‡¡å–äººä¹‹æœ¯ï¼Œè‹Ÿä¸å¾—åœ£äººï¼Œå›å­è€Œä¸ä¹‹ï¼Œä¸å…¶å¾—å°äººï¼Œä¸è‹¥å¾—æ„šäººã€‚â€ç°ç»™å‡ºä¸€æ‰¹è€ƒç”Ÿçš„å¾·æ‰åˆ†æ•°ï¼Œè¯·æ ¹æ®å¸é©¬å…‰çš„ç†è®ºç»™å‡ºå½•å–æ’åã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡º 3 ä¸ªæ­£æ•´æ•°ï¼Œåˆ†åˆ«ä¸ºï¼šNï¼ˆâ‰¤10^5ï¼‰ï¼Œå³è€ƒç”Ÿæ€»æ•°ï¼›Lï¼ˆâ‰¥60ï¼‰ï¼Œä¸ºå½•å–æœ€ä½åˆ†æ•°çº¿ï¼Œå³å¾·åˆ†å’Œæ‰åˆ†å‡ä¸ä½äº L çš„è€ƒç”Ÿæ‰æœ‰èµ„æ ¼è¢«è€ƒè™‘å½•å–ï¼›Hï¼ˆ&lt;100ï¼‰ï¼Œä¸ºä¼˜å…ˆå½•å–çº¿â€”â€”å¾·åˆ†å’Œæ‰åˆ†å‡ä¸ä½äºæ­¤çº¿çš„è¢«å®šä¹‰ä¸ºâ€œæ‰å¾·å…¨å°½â€ï¼Œæ­¤ç±»è€ƒç”ŸæŒ‰å¾·æ‰æ€»åˆ†ä»é«˜åˆ°ä½æ’åºï¼›æ‰åˆ†ä¸åˆ°ä½†å¾·åˆ†åˆ°çº¿çš„ä¸€ç±»è€ƒç”Ÿå±äºâ€œå¾·èƒœæ‰â€ï¼Œä¹ŸæŒ‰æ€»åˆ†æ’åºï¼Œä½†æ’åœ¨ç¬¬ä¸€ç±»è€ƒç”Ÿä¹‹åï¼›å¾·æ‰åˆ†å‡ä½äº Hï¼Œä½†æ˜¯å¾·åˆ†ä¸ä½äºæ‰åˆ†çš„è€ƒç”Ÿå±äºâ€œæ‰å¾·å…¼äº¡â€ä½†å°šæœ‰â€œå¾·èƒœæ‰â€è€…ï¼ŒæŒ‰æ€»åˆ†æ’åºï¼Œä½†æ’åœ¨ç¬¬äºŒç±»è€ƒç”Ÿä¹‹åï¼›å…¶ä»–è¾¾åˆ°æœ€ä½çº¿ L çš„è€ƒç”Ÿä¹ŸæŒ‰æ€»åˆ†æ’åºï¼Œä½†æ’åœ¨ç¬¬ä¸‰ç±»è€ƒç”Ÿä¹‹åã€‚ éšå N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä½è€ƒç”Ÿçš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬ï¼šå‡†è€ƒè¯å· å¾·åˆ† æ‰åˆ†ï¼Œå…¶ä¸­å‡†è€ƒè¯å·ä¸º 8 ä½æ•´æ•°ï¼Œå¾·æ‰åˆ†ä¸ºåŒºé—´ [0, 100] å†…çš„æ•´æ•°ã€‚æ•°å­—é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚ è¾“å‡ºæ ¼å¼ï¼š è¾“å‡ºç¬¬ä¸€è¡Œé¦–å…ˆç»™å‡ºè¾¾åˆ°æœ€ä½åˆ†æ•°çº¿çš„è€ƒç”Ÿäººæ•° Mï¼Œéšå M è¡Œï¼Œæ¯è¡ŒæŒ‰ç…§è¾“å…¥æ ¼å¼è¾“å‡ºä¸€ä½è€ƒç”Ÿçš„ä¿¡æ¯ï¼Œè€ƒç”ŸæŒ‰è¾“å…¥ä¸­è¯´æ˜çš„è§„åˆ™ä»é«˜åˆ°ä½æ’åºã€‚å½“æŸç±»è€ƒç”Ÿä¸­æœ‰å¤šäººæ€»åˆ†ç›¸åŒæ—¶ï¼ŒæŒ‰å…¶å¾·åˆ†é™åºæ’åˆ—ï¼›è‹¥å¾·åˆ†ä¹Ÿå¹¶åˆ—ï¼Œåˆ™æŒ‰å‡†è€ƒè¯å·çš„å‡åºè¾“å‡ºã€‚ è¾“å…¥æ ·ä¾‹ï¼š14 60 80 10000001 64 90 10000002 90 60 10000011 85 80 10000003 85 80 10000004 80 85 10000005 82 77 10000006 83 76 10000007 90 78 10000008 75 79 10000009 59 90 10000010 88 45 10000012 80 100 10000013 90 99 10000014 66 60 è¾“å‡ºæ ·ä¾‹ï¼š12 10000013 90 99 10000012 80 100 10000003 85 80 10000011 85 80 10000004 80 85 10000007 90 78 10000006 83 76 10000005 82 77 10000002 90 60 10000014 66 60 10000008 75 79 10000001 64 90 é€šè¿‡ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct stu { long id; int modest; int skill;};bool cmp(stu a, stu b) { if (a.modest + a.skill != b.modest + b.skill) return a.modest + a.skill &gt; b.modest + b.skill; else if (a.modest != b.modest) return a.modest &gt; b.modest; else return a.id &lt; b.id;}int main() { vector&lt;stu&gt; class1; vector&lt;stu&gt; class2; vector&lt;stu&gt; class3; vector&lt;stu&gt; class4; stu temp; int n, l, h; cin &gt;&gt; n &gt;&gt; l &gt;&gt; h; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; temp.id &gt;&gt; temp.modest &gt;&gt; temp.skill; if (temp.modest &gt;= l &amp;&amp; temp.skill &gt;= l) { if (temp.modest &gt;= h &amp;&amp; temp.skill &gt;= h) class1.push_back(temp); else if (temp.modest &gt;= h &amp;&amp; temp.skill &lt; h) class2.push_back(temp); else if (temp.modest &lt; h &amp;&amp; temp.skill &lt; h &amp;&amp; temp.modest &gt;= temp.skill) class3.push_back(temp); else class4.push_back(temp); } } sort(class1.begin(), class1.end(), cmp); sort(class2.begin(), class2.end(), cmp); sort(class3.begin(), class3.end(), cmp); sort(class4.begin(), class4.end(), cmp); cout &lt;&lt; class1.size() + class2.size() + class3.size() + class4.size() &lt;&lt; endl; for (vector&lt;stu&gt;::iterator ite = class1.begin(); ite != class1.end(); ite++) {printf(&quot;%08ld %d %d\\n&quot;, (*ite).id, (*ite).modest, (*ite).skill);} for (vector&lt;stu&gt;::iterator ite = class2.begin(); ite != class2.end(); ite++) {printf(&quot;%08ld %d %d\\n&quot;, (*ite).id, (*ite).modest, (*ite).skill);} for (vector&lt;stu&gt;::iterator ite = class3.begin(); ite != class3.end(); ite++) {printf(&quot;%08ld %d %d\\n&quot;, (*ite).id, (*ite).modest, (*ite).skill);} for (vector&lt;stu&gt;::iterator ite = class4.begin(); ite != class4.end(); ite++) {printf(&quot;%08ld %d %d\\n&quot;, (*ite).id, (*ite).modest, (*ite).skill);} return 0;} æ€è·¯ä¸æ³¨æ„ æœ¬è´¨ä¸Šè¿˜æ˜¯ç»Ÿè®¡æ•°æ®ï¼Œç”¨\bstlä¼šå¾ˆæ–¹ä¾¿ã€‚ \bå¿…é¡»åŠæ ¼çš„è€ƒç”Ÿæ‰èƒ½å‚ä¸æ’åºã€‚ æ³¨æ„é¢˜çœŸçš„å¾ˆéš¾è¯»æ‡‚ï¼Œé•¿é•¿çš„ä¸€å¤§ç‰‡ã€‚ å¤§æ¦‚åˆ†å››ç±»è€ƒç”Ÿ ç¬¬ä¸€ç±»æ˜¯ä¸¤ç§‘éƒ½è¶…è¿‡ä¼˜èƒœçº¿çš„ã€‚ ç¬¬äºŒç±»æ˜¯å¾·åˆ†è¿‡ä¼˜èƒœçº¿ï¼Œæ‰åˆ†åŠæ ¼çš„ã€‚ ç¬¬ä¸‰ç±»æ˜¯ä¸¤ç§‘éƒ½åŠæ ¼ï¼Œä½†éƒ½ä¸åˆ°ä¼˜èƒœçº¿ï¼Œä¸”å¾·åˆ†é«˜äºæ‰åˆ†çš„ã€‚ ç¬¬å››ç±»æ˜¯ä¸¤ç§‘è¿‡äº†åŠæ ¼çº¿ä½†ä¸å±äºä»¥ä¸Šä»»ä½•ä¸€ç§çš„è€ƒç”Ÿ åæ€ä¸è¯„ä»· æˆ‘è§‰å¾—æˆ‘è¿™ä¸ªä»£ç å®Œç¾ï¼Œä¸éœ€è¦åæ€","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1015-%E5%BE%B7%E6%89%8D%E8%AE%BA(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1048","text":"é¢˜ç›® æœ¬é¢˜è¦æ±‚å®ç°ä¸€ç§æ•°å­—åŠ å¯†æ–¹æ³•ã€‚é¦–å…ˆå›ºå®šä¸€ä¸ªåŠ å¯†ç”¨æ­£æ•´æ•° Aï¼Œå¯¹ä»»ä¸€æ­£æ•´æ•° Bï¼Œå°†å…¶æ¯ 1 ä½æ•°å­—ä¸ A çš„å¯¹åº”ä½ç½®ä¸Šçš„æ•°å­—è¿›è¡Œä»¥ä¸‹è¿ç®—ï¼š å¯¹å¥‡æ•°ä½ï¼Œå¯¹åº”ä½çš„æ•°å­—ç›¸åŠ åå¯¹ 13 å–ä½™â€”â€”è¿™é‡Œç”¨ J ä»£è¡¨ 10ã€Q ä»£è¡¨ 11ã€K ä»£è¡¨ 12ï¼›å¯¹å¶æ•°ä½ï¼Œç”¨ B çš„æ•°å­—å‡å» A çš„æ•°å­—ï¼Œè‹¥ç»“æœä¸ºè´Ÿæ•°ï¼Œåˆ™å†åŠ  10ã€‚è¿™é‡Œä»¤ä¸ªä½ä¸ºç¬¬ 1 ä½ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥åœ¨ä¸€è¡Œä¸­ä¾æ¬¡ç»™å‡º A å’Œ Bï¼Œå‡ä¸ºä¸è¶…è¿‡ 100 ä½çš„æ­£æ•´æ•°ï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚ è¾“å‡ºæ ¼å¼ï¼š åœ¨ä¸€è¡Œä¸­è¾“å‡ºåŠ å¯†åçš„ç»“æœã€‚ è¾“å…¥æ ·ä¾‹ï¼š1234567 368782971 è¾“å‡ºæ ·ä¾‹ï¼š3695Q8118 é€šè¿‡ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.*;public class Main { static Scanner sc;\b static { sc = new Scanner(System.in); } static int max(int a, int b) { return a &gt; b ? a : b; } public static void main(String[] args) { // code here String in = sc.nextLine(); StringBuffer a = new StringBuffer(in.substring(0, in.indexOf(' '))); StringBuffer b = new StringBuffer(in.substring(in.indexOf(' ') + 1, in.length())); StringBuffer ans = new StringBuffer(); //å­—ç¬¦å’Œæ•°å­—äº’è½¬ char[] num = new char[13]; for (int i = 0; i &lt; 10; i++) { num[i] = (char) (i + '0'); } num[10] = 'J'; num[11] = 'Q'; num[12] = 'K'; int[] Char = new int[128]; for (char i = '0'; i &lt;= '9'; i++) {Char[i] = i - '0';} Char['J'] = 10;Char['Q'] = 11;Char['K'] = 12; int len = max(a.length(), b.length()); StringBuffer temp = new StringBuffer(); for (int i = 0; i &lt; len - a.length(); i++) { temp.append('0'); } a.insert(0, temp.toString()); temp = new StringBuffer(); for (int i = 0; i &lt; len - b.length(); i++) { temp.append('0'); } b.insert(0, temp.toString()); int cmp = len % 2; for (int i = 0; i &lt; len; i++) { char x; if ((i + 1) % 2 == cmp) { x = num[(Char[a.charAt(i)] + Char[b.charAt(i)]) % 13]; ans.append(x); } else { int n = (Char[b.charAt(i)] - Char[a.charAt(i)]); x = num[n &gt;= 0 ? n : n + 10]; ans.append(x); } } System.out.println(ans); }} åæ€ä¸è¯„ä»·åæ€Â Â Â Â Â Â Â Â è¿™é“é¢˜æ˜¯ç”¨Javaå†™çš„ï¼Œæ€»ä½“æ¥è¯´æ²¡æœ‰ä»€ä¹ˆéš¾åº¦ï¼Œä½†æ˜¯\bé¢˜ç›®ä¸­è§„å®šå„ä½ä¸ºç¬¬ä¸€ä½ï¼Œæˆ‘ç›´æ¥ç”¨forä»0å¼€å§‹å¾ªç¯åˆ¤æ–­(i+1)çš„\b\bå¥‡å¶æ€§ï¼Œè¿™å°±å¯¼è‡´æœ€é•¿ä½æ•°å¦‚æœæ˜¯å¥‡æ•°ï¼Œé‚£ä¹ˆä¸ªä½å°±æ˜¯å¥‡æ•°ä½ï¼Œåä¹‹åˆ™ä¸ºå¶æ•°ä½ã€‚Â Â Â Â Â Â Â Â ä¸ºäº†è§£å†³è¿™ä¸ªç¼ºé™·ï¼Œè€ƒè™‘åˆ°å¦‚æœæœ€é•¿ä½æ•°ä¸ºå¶æ•°\bï¼Œ\bæ“ä½œè·ŸåŸæ¥äº’æ¢å°±å¥½\bï¼Œå°±è¦æŠŠ0å˜æˆ1ï¼Œ\b1å˜æˆ0ï¼Œæ‰€ä»¥æˆ‘å®šä¹‰äº†ä¸€ä¸ªæ•´å‹cmpï¼Œ\bå®ƒçš„å€¼ä¸ºlen%2ï¼Œè¿™æ ·å°±è§£å†³äº†ã€‚ è¯„ä»·Â Â Â Â é¢˜ç›®ç®€å•ï¼Œæ²¡ä»€ä¹ˆå¥½è¯´çš„ï¼Œä½†æ˜¯ä»£ç çœ‹èµ·æ¥è¿˜æ˜¯å¤ªå¤æ‚ã€‚","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1048-%E6%95%B0%E5%AD%97%E5%8A%A0%E5%AF%86(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1050","text":"é¢˜ç›® æœ¬é¢˜è¦æ±‚å°†ç»™å®šçš„ N ä¸ªæ­£æ•´æ•°æŒ‰éé€’å¢çš„é¡ºåºï¼Œå¡«å…¥â€œèºæ—‹çŸ©é˜µâ€ã€‚æ‰€è°“â€œèºæ—‹çŸ©é˜µâ€ï¼Œæ˜¯æŒ‡ä»å·¦ä¸Šè§’ç¬¬ 1 ä¸ªæ ¼å­å¼€å§‹ï¼ŒæŒ‰é¡ºæ—¶é’ˆèºæ—‹æ–¹å‘å¡«å……ã€‚è¦æ±‚çŸ©é˜µçš„è§„æ¨¡ä¸º m è¡Œ n åˆ—ï¼Œæ»¡è¶³æ¡ä»¶ï¼šmÃ—n ç­‰äº Nï¼›mâ‰¥nï¼›ä¸” mâˆ’n å–æ‰€æœ‰å¯èƒ½å€¼ä¸­çš„æœ€å°å€¼ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥åœ¨ç¬¬ 1 è¡Œä¸­ç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Nï¼Œç¬¬ 2 è¡Œç»™å‡º N ä¸ªå¾…å¡«å……çš„æ­£æ•´æ•°ã€‚æ‰€æœ‰æ•°å­—ä¸è¶…è¿‡ 104ï¼Œç›¸é‚»æ•°å­—ä»¥ç©ºæ ¼åˆ†éš”ã€‚ è¾“å‡ºæ ¼å¼ï¼š è¾“å‡ºèºæ—‹çŸ©é˜µã€‚æ¯è¡Œ n ä¸ªæ•°å­—ï¼Œå…± m è¡Œã€‚ç›¸é‚»æ•°å­—ä»¥ 1 ä¸ªç©ºæ ¼åˆ†éš”ï¼Œè¡Œæœ«ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚ è¾“å…¥æ ·ä¾‹ï¼š121237 76 20 98 76 42 53 95 60 81 58 93 è¾“å‡ºæ ·ä¾‹ï¼š123498 95 9342 37 8153 20 7658 60 76 é€šè¿‡ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void get_mn(int* m, int* n, int N) { int i = 0; do { *n = sqrt(N) - i; *m = N / (*n); i++; } while ((*m) * (*n) != N);}int main() { int n; int t; vector&lt;int&gt; arr; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; t; arr.push_back(t); } sort(arr.begin(), arr.end()); int count = n - 1; int N, M; get_mn(&amp;M, &amp;N, n); vector&lt;vector&lt;int&gt; &gt; a; vector&lt;int&gt; temp(N); for (int i = 0; i &lt; M; i++) { a.push_back(temp); } int i = 0; while (count &gt;= 0) { for (int j = i; j &lt; N - 1 - i &amp;&amp; i &lt; M; j++)//â‘ ä»ä¸‹æ ‡iå¼€å§‹ï¼Œç›´åˆ°N - 1 - i a[i][j] = arr[count--]; for (int j = i; j &lt; M - i &amp;&amp; i &lt; N; j++)//â‘¡ä»ä¸‹æ ‡iå¼€å§‹ï¼Œç›´åˆ°M - i a[j][N - 1 - i] = arr[count--]; for (int j = N - 1 - i - 1; j &gt; i - 1 &amp;&amp; i &lt; M; j--)//â‘ çš„å€’åº a[M - 1 - i][j] = arr[count--]; if (N - 1 - i &gt; i) for (int j = M - 1 - i - 1; j &gt; i &amp;&amp; i &lt; N; j--)//â‘¡çš„å€’åº a[j][i] = arr[count--]; i++; } for (int i = 0; i &lt; M; i++) { cout &lt;&lt; a[i][0]; for (int j = 1; j &lt; N; j++) cout &lt;&lt; &quot; &quot; &lt;&lt; a[i][j]; cout &lt;&lt; endl; }} æ€è·¯ä¸æ³¨æ„ å…ˆæŠŠæ•°å‚¨å­˜ï¼Œå†é¡ºåºè¾“å‡º ä»¥ä¸€åœˆä¸ºå•ä½ï¼Œ4ä¸ªå¾ªç¯å¡«å¥½ä¸€åœˆ è®°å½•ç¬¬å‡ åœˆï¼Œä»¥è¿™ä¸ªæ•°ç¡®å®šæ¯æ¬¡ä»å“ªé‡Œå¼€å§‹å¡«æ•° æœ€åè¦åˆ¤æ–­( N - 1 - i &gt; i ) è®¡ç®—MNæ—¶è¦æ³¨æ„(n/N)*N ä¸ä¸€å®šç­‰äº n åæ€ä¸è¯„ä»· ä¸€ç›´æ²¡æœ‰è€ƒè™‘åˆ°åˆ¤æ–­( N - 1 - i &gt; i ) è®¡ç®—MNçš„æ—¶å€™æƒ³çš„å¤ªç®€å•","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1050-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1055","text":"é¢˜ç›® æ‹é›†ä½“ç…§æ—¶é˜Ÿå½¢å¾ˆé‡è¦ï¼Œè¿™é‡Œå¯¹ç»™å®šçš„ N ä¸ªäºº K æ’çš„é˜Ÿå½¢è®¾è®¡æ’é˜Ÿè§„åˆ™å¦‚ä¸‹ï¼š æ¯æ’äººæ•°ä¸º N/Kï¼ˆå‘ä¸‹å–æ•´ï¼‰ï¼Œå¤šå‡ºæ¥çš„äººå…¨éƒ¨ç«™åœ¨æœ€åä¸€æ’ï¼› åæ’æ‰€æœ‰äººçš„ä¸ªå­éƒ½ä¸æ¯”å‰æ’ä»»ä½•äººçŸ®ï¼› æ¯æ’ä¸­æœ€é«˜è€…ç«™ä¸­é—´ï¼ˆä¸­é—´ä½ç½®ä¸º m/2+1ï¼Œå…¶ä¸­ m ä¸ºè¯¥æ’äººæ•°ï¼Œé™¤æ³•å‘ä¸‹å–æ•´ï¼‰ï¼› æ¯æ’å…¶ä»–äººä»¥ä¸­é—´äººä¸ºè½´ï¼ŒæŒ‰èº«é«˜éå¢åºï¼Œå…ˆå³åå·¦äº¤æ›¿å…¥é˜Ÿç«™åœ¨ä¸­é—´äººçš„ä¸¤ä¾§ï¼ˆä¾‹å¦‚5äººèº«é«˜ä¸º190ã€188ã€186ã€175ã€170ï¼Œåˆ™é˜Ÿå½¢ä¸º175ã€188ã€190ã€186ã€170ã€‚è¿™é‡Œå‡è®¾ä½ é¢å¯¹æ‹ç…§è€…ï¼Œæ‰€ä»¥ä½ çš„å·¦è¾¹æ˜¯ä¸­é—´äººçš„å³è¾¹ï¼‰ï¼› è‹¥å¤šäººèº«é«˜ç›¸åŒï¼Œåˆ™æŒ‰åå­—çš„å­—å…¸åºå‡åºæ’åˆ—ã€‚è¿™é‡Œä¿è¯æ— é‡åã€‚ ç°ç»™å®šä¸€ç»„æ‹ç…§äººï¼Œè¯·ç¼–å†™ç¨‹åºè¾“å‡ºä»–ä»¬çš„é˜Ÿå½¢ã€‚ è¾“å…¥æ ¼å¼ï¼š æ¯ä¸ªè¾“å…¥åŒ…å« 1 ä¸ªæµ‹è¯•ç”¨ä¾‹ã€‚æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ç¬¬ 1 è¡Œç»™å‡ºä¸¤ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤104ï¼Œæ€»äººæ•°ï¼‰å’Œ Kï¼ˆâ‰¤10ï¼Œæ€»æ’æ•°ï¼‰ã€‚éšå N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä¸ªäººçš„åå­—ï¼ˆä¸åŒ…å«ç©ºæ ¼ã€é•¿åº¦ä¸è¶…è¿‡ 8 ä¸ªè‹±æ–‡å­—æ¯ï¼‰å’Œèº«é«˜ï¼ˆ[30, 300] åŒºé—´å†…çš„æ•´æ•°ï¼‰ã€‚ è¾“å‡ºæ ¼å¼ï¼š è¾“å‡ºæ‹ç…§çš„é˜Ÿå½¢ã€‚å³Kæ’äººåï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ï¼Œè¡Œæœ«ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚æ³¨æ„ï¼šå‡è®¾ä½ é¢å¯¹æ‹ç…§è€…ï¼Œåæ’çš„äººè¾“å‡ºåœ¨ä¸Šæ–¹ï¼Œå‰æ’è¾“å‡ºåœ¨ä¸‹æ–¹ã€‚ è¾“å…¥æ ·ä¾‹ï¼š123456789101110 3Tom 188Mike 170Eva 168Tim 160Joe 190Ann 168Bob 175Nick 186Amy 160John 159 è¾“å‡ºæ ·ä¾‹ï¼š123Bob Tom Joe NickAnn Mike EvaTim Amy John é€šè¿‡ä»£ç 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct data { string name; int hight; };bool cmp(data&amp; a, data&amp; b) { if (a.hight != b.hight) return a.hight &gt; b.hight; else return a.name &lt; b.name;}int main () { int n, k; cin &gt;&gt; n &gt;&gt; k; int cmin = n / k; int cmax = n % k + cmin; data arr[k][cmax], in[n]; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; in[i].name &gt;&gt; in[i].hight; } sort(in, in + n, cmp); int i = 0, c = cmax; for (int K = 0; K &lt; k; K++) { arr[K][c / 2] = in[i++]; for (int j = 0; j &lt; c / 2; j++) { if (c / 2 - j - 1 &gt;= 0) arr[K][c / 2 - j - 1] = in[i++]; if (c / 2 + j + 1 &lt; c) arr[K][c / 2 + j + 1] = in[i++]; } c = cmin; } c = cmax; for (int i = 0; i &lt; k; i++) { cout &lt;&lt; arr[i][0].name; for (int j = 1; j &lt; c; j++) cout &lt;&lt; &quot; &quot; &lt;&lt; arr[i][j].name; cout &lt;&lt; endl; c = cmin; }} æ€è·¯ä¸æ³¨æ„ è¾“å…¥ï¼Œæ’åºï¼ˆæŒ‰èº«é«˜é™åºï¼Œèº«é«˜ä¸€æ ·æŒ‰åå­—çš„ASCIIå€¼å‡åºï¼‰ è®¡ç®—æ¯æ’äººæ•°cminï¼Œæœ€åä¸€æ’äººæ•°cmaxã€‚ç„¶åå¾€é‡Œé¢å­˜ã€‚ å­˜å’Œè¾“å‡ºæ—¶ï¼Œæœ€åä¸€æ’å’Œå…¶ä»–æ’äººæ•°ä¸ä¸€æ ·ï¼Œæ‰€ä»¥ä»¤åˆ—æ•°c = cmaxï¼Œæ¯æ¬¡å¾ªç¯å®Œä»¤c = cmin ç”±äºæŠŠæœ€åä¸€æ’å’Œå…¶ä»–æ’éƒ½ç»Ÿä¸€èµ·æ¥è€ƒè™‘ï¼Œæ‰€ä»¥æ¯æ¬¡å­˜çš„æ—¶å€™è¦åˆ¤æ–­ä¸‹æ ‡æœ‰æ²¡æœ‰è¶Šç•Œ åæ€ä¸è¯„ä»· å¼€å¿ƒï¼Œé¢˜ç›®è¶Šåšè¶Šé¡ºæ‰‹","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1055-%E9%9B%86%E4%BD%93%E7%85%A7(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1058","text":"é¢˜ç›® æ‰¹æ”¹å¤šé€‰é¢˜æ˜¯æ¯”è¾ƒéº»çƒ¦çš„äº‹æƒ…ï¼Œæœ¬é¢˜å°±è¯·ä½ å†™ä¸ªç¨‹åºå¸®åŠ©è€å¸ˆæ‰¹æ”¹å¤šé€‰é¢˜ï¼Œå¹¶ä¸”æŒ‡å‡ºå“ªé“é¢˜é”™çš„äººæœ€å¤šã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥åœ¨ç¬¬ä¸€è¡Œç»™å‡ºä¸¤ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤ 1000ï¼‰å’Œ Mï¼ˆâ‰¤ 100ï¼‰ï¼Œåˆ†åˆ«æ˜¯å­¦ç”Ÿäººæ•°å’Œå¤šé€‰é¢˜çš„ä¸ªæ•°ã€‚éšå M è¡Œï¼Œæ¯è¡Œé¡ºæ¬¡ç»™å‡ºä¸€é“é¢˜çš„æ»¡åˆ†å€¼ï¼ˆä¸è¶…è¿‡ 5 çš„æ­£æ•´æ•°ï¼‰ã€é€‰é¡¹ä¸ªæ•°ï¼ˆä¸å°‘äº 2 ä¸”ä¸è¶…è¿‡ 5 çš„æ­£æ•´æ•°ï¼‰ã€æ­£ç¡®é€‰é¡¹ä¸ªæ•°ï¼ˆä¸è¶…è¿‡é€‰é¡¹ä¸ªæ•°çš„æ­£æ•´æ•°ï¼‰ã€æ‰€æœ‰æ­£ç¡®é€‰é¡¹ã€‚æ³¨æ„æ¯é¢˜çš„é€‰é¡¹ä»å°å†™è‹±æ–‡å­—æ¯ a å¼€å§‹é¡ºæ¬¡æ’åˆ—ã€‚å„é¡¹é—´ä»¥ 1 ä¸ªç©ºæ ¼åˆ†éš”ã€‚æœ€å N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä¸ªå­¦ç”Ÿçš„ç­”é¢˜æƒ…å†µï¼Œå…¶æ¯é¢˜ç­”æ¡ˆæ ¼å¼ä¸º (é€‰ä¸­çš„é€‰é¡¹ä¸ªæ•° é€‰é¡¹1 â€¦â€¦)ï¼ŒæŒ‰é¢˜ç›®é¡ºåºç»™å‡ºã€‚æ³¨æ„ï¼šé¢˜ç›®ä¿è¯å­¦ç”Ÿçš„ç­”é¢˜æƒ…å†µæ˜¯åˆæ³•çš„ï¼Œå³ä¸å­˜åœ¨é€‰ä¸­çš„é€‰é¡¹æ•°è¶…è¿‡å®é™…é€‰é¡¹æ•°çš„æƒ…å†µã€‚ è¾“å‡ºæ ¼å¼ï¼š æŒ‰ç…§è¾“å…¥çš„é¡ºåºç»™å‡ºæ¯ä¸ªå­¦ç”Ÿçš„å¾—åˆ†ï¼Œæ¯ä¸ªåˆ†æ•°å ä¸€è¡Œã€‚æ³¨æ„åˆ¤é¢˜æ—¶åªæœ‰é€‰æ‹©å…¨éƒ¨æ­£ç¡®æ‰èƒ½å¾—åˆ°è¯¥é¢˜çš„åˆ†æ•°ã€‚æœ€åä¸€è¡Œè¾“å‡ºé”™å¾—æœ€å¤šçš„é¢˜ç›®çš„é”™è¯¯æ¬¡æ•°å’Œç¼–å·ï¼ˆé¢˜ç›®æŒ‰ç…§è¾“å…¥çš„é¡ºåºä» 1 å¼€å§‹ç¼–å·ï¼‰ã€‚å¦‚æœæœ‰å¹¶åˆ—ï¼Œåˆ™æŒ‰ç¼–å·é€’å¢é¡ºåºè¾“å‡ºã€‚æ•°å­—é—´ç”¨ç©ºæ ¼åˆ†éš”ï¼Œè¡Œé¦–å°¾ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚å¦‚æœæ‰€æœ‰é¢˜ç›®éƒ½æ²¡æœ‰äººé”™ï¼Œåˆ™åœ¨æœ€åä¸€è¡Œè¾“å‡º Too simpleã€‚ è¾“å…¥æ ·ä¾‹ï¼š3 4 3 4 2 a c 2 5 1 b 5 3 2 b c 1 5 4 a b d e (2 a c) (2 b d) (2 a c) (3 a b e) (2 a c) (1 b) (2 a b) (4 a b d e) (2 b d) (1 e) (2 b c) (4 a b c d) è¾“å‡ºæ ·ä¾‹ï¼š3 6 5 2 2 3 4 é€šè¿‡ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Option { public: int score; int optionNum; int corOptionNum; int FalseNum; int num; vector&lt;char&gt; correctOption; Option() { score = 0; optionNum = 0; corOptionNum = 0; FalseNum = 0; num = 0; } Option(Option &amp;other) { score = other.score; optionNum = other.optionNum; corOptionNum = other.corOptionNum; correctOption = other.correctOption; } friend istream &amp;operator&gt;&gt;(istream &amp;file, Option &amp;object);};istream &amp;operator&gt;&gt;(istream &amp;file, Option &amp;object) { file &gt;&gt; object.score &gt;&gt; object.optionNum &gt;&gt; object.corOptionNum; for (int i = 0; i &lt; object.corOptionNum; i++) { file.ignore(); char temp; file &gt;&gt; temp; object.correctOption.push_back(temp); } return file;}class choose { public: int num; vector&lt;char&gt; option; friend istream &amp;operator&gt;&gt;(istream &amp;file, choose &amp;object); friend ostream &amp;operator&lt;&lt;(ostream &amp;file, choose &amp;object); void clear() { option.clear(); num = 0; }};istream &amp;operator&gt;&gt;(istream &amp;file, choose &amp;object) { char x; cin &gt;&gt; x; file &gt;&gt; object.num; for (int i = 0; i &lt; object.num; i++) { file.ignore(); char temp; file &gt;&gt; temp; object.option.push_back(temp); } file.ignore(); return file;}class Stu { public: vector&lt;choose&gt; cho; int score; Stu() { score = 0; } Stu(Stu &amp;other) { cho = other.cho; score = other.score; }};int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; Stu student[n]; Option op[m]; choose choTemp; bool hasFalse = false; for (int i = 0; i &lt; m; i++) { cin &gt;&gt; op[i]; op[i].num = i + 1; } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { choTemp.clear(); cin &gt;&gt; choTemp; cin.ignore(); student[i].cho.push_back(choTemp); } for (int j = 0; j &lt; m; j++) { if (student[i].cho[j].option == op[j].correctOption) { student[i].score += op[j].score; } else { hasFalse = true; op[j].FalseNum++; } } } for (int i = 0; i &lt; n; i++) { cout &lt;&lt; student[i].score &lt;&lt; endl; } if (hasFalse) { int max = op[0].FalseNum; for (int i = 0; i &lt; m; i++) { if (max &lt; op[i].FalseNum) { max = op[i].FalseNum; } } cout &lt;&lt; max; for (int i = 0; i &lt; m; i++) { if (op[i].FalseNum == max) { cout &lt;&lt; ' ' &lt;&lt; op[i].num; } } cout &lt;&lt; endl; } else { cout &lt;&lt; &quot;Too simple&quot; &lt;&lt; endl; } return 0;} æ€è·¯ä¸æ³¨æ„ åˆ©ç”¨\bç±»æ¥å‚¨å­˜ä¿¡æ¯ï¼Œæ³¨æ„æ„é€ å‡½æ•°é‡Œåˆå§‹åŒ–å˜é‡ã€‚ æ³¨æ„è¾“å…¥å­—ç¬¦ç±»å‹æ—¶ï¼Œåˆ©ç”¨ignore()ç­‰å‡½æ•°è·³è¿‡ç©ºç™½ç¬¦\b æœ€åä¸€è¡Œçš„è¾“å‡ºæ˜¯æœ€å¤§å€¼ æœ€å¤§å€¼çš„åºå·åˆ—è¡¨ï¼Œä¸æ˜¯æœ€å¤§å€¼+åºå·+æœ€å¤§å€¼+åºå·ã€‚åœ¨è¿™é‡Œè¢«å‘ä½äº†ã€‚ è¾“å…¥chooseç±»çš„æ—¶å€™ç”¨äº†ä¸€ä¸ªchoTempè¾“å…¥ï¼Œchooseç±»å†…éƒ¨é‡‡ç”¨äº†vectorï¼Œé‚£ä¹ˆæ¯æ¬¡è¾“å…¥å®Œæˆè¦æ¸…ç©ºä¸€æ¬¡ã€‚ åæ€ä¸è¯„ä»·\bè¿™é“é¢˜å…¶å®ä¸ç”¨å†™è¿™ä¹ˆå¤šç±»ï¼Œè¿ç®—ç¬¦é‡è½½ï¼Œæ„é€ å‡½æ•°ä»€ä¹ˆçš„ï¼Œä»£ç å¯ä»¥\bæ›´åŠ ç²¾ç®€ã€‚ä½†æ˜¯è¿™æ ·å†™çš„å¥½å¤„æœ‰ï¼š æ•°æ®å¤„ç†æ–¹ä¾¿ï¼Œä¸ä¼šå¯¼è‡´mainå‡½æ•°é‡Œé¢å®šä¹‰è¿‡å¤šå˜é‡å¯¼è‡´ä»£ç å¯è¯»æ€§å˜å·®ã€‚ mainå‡½æ•°æ›´åŠ ç®€æ´ï¼Œå¯ä»¥æŠŠ\bæ€è·¯æ”¾åœ¨\bé€»è¾‘ç®—æ³•ä¸Šè€Œä¸æ˜¯æ•°æ®çš„å¤„ç†ä¸Šï¼Œå°±åƒ\bæˆ‘ä»¬ä½¿ç”¨vectorï¼Œsetï¼Œmapç­‰æ¨¡æ¿æ—¶ï¼Œå¹¶ä¸éœ€è¦çŸ¥é“å…¶å†…éƒ¨å¦‚ä½•å®ç°ï¼Œä½¿å¾—ç¼–ç æ•ˆç‡æé«˜ã€‚","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1058-%E9%80%89%E6%8B%A9%E9%A2%98(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1054","text":"é¢˜ç›® æœ¬é¢˜çš„åŸºæœ¬è¦æ±‚éå¸¸ç®€å•ï¼šç»™å®š N ä¸ªå®æ•°ï¼Œè®¡ç®—å®ƒä»¬çš„å¹³å‡å€¼ã€‚ä½†å¤æ‚çš„æ˜¯æœ‰äº›è¾“å…¥æ•°æ®å¯èƒ½æ˜¯éæ³•çš„ã€‚ä¸€ä¸ªâ€œåˆæ³•â€çš„è¾“å…¥æ˜¯ [âˆ’1000,1000] åŒºé—´å†…çš„å®æ•°ï¼Œå¹¶ä¸”æœ€å¤šç²¾ç¡®åˆ°å°æ•°ç‚¹å 2 ä½ã€‚å½“ä½ è®¡ç®—å¹³å‡å€¼çš„æ—¶å€™ï¼Œä¸èƒ½æŠŠé‚£äº›éæ³•çš„æ•°æ®ç®—åœ¨å†…ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºæ­£æ•´æ•° Nï¼ˆâ‰¤100ï¼‰ã€‚éšåä¸€è¡Œç»™å‡º N ä¸ªå®æ•°ï¼Œæ•°å­—é—´ä»¥ä¸€ä¸ªç©ºæ ¼åˆ†éš”ã€‚ è¾“å‡ºæ ¼å¼ï¼š å¯¹æ¯ä¸ªéæ³•è¾“å…¥ï¼Œåœ¨ä¸€è¡Œä¸­è¾“å‡º ERROR: X is not a legal numberï¼Œå…¶ä¸­ X æ˜¯è¾“å…¥ã€‚æœ€ååœ¨ä¸€è¡Œä¸­è¾“å‡ºç»“æœï¼šThe average of K numbers is Yï¼Œå…¶ä¸­ K æ˜¯åˆæ³•è¾“å…¥çš„ä¸ªæ•°ï¼ŒY æ˜¯å®ƒä»¬çš„å¹³å‡å€¼ï¼Œç²¾ç¡®åˆ°å°æ•°ç‚¹å 2 ä½ã€‚å¦‚æœå¹³å‡å€¼æ— æ³•è®¡ç®—ï¼Œåˆ™ç”¨ Undefined æ›¿æ¢ Yã€‚å¦‚æœ K ä¸º 1ï¼Œåˆ™è¾“å‡º The average of 1 number is Yã€‚ è¾“å…¥æ ·ä¾‹ 1ï¼š1275 -3.2 aaa 9999 2.3.4 7.123 2.35 è¾“å‡ºæ ·ä¾‹ 1ï¼š12345ERROR: aaa is not a legal numberERROR: 9999 is not a legal numberERROR: 2.3.4 is not a legal numberERROR: 7.123 is not a legal numberThe average of 3 numbers is 1.38 è¾“å…¥æ ·ä¾‹ 2ï¼š122aaa -9999 è¾“å‡ºæ ·ä¾‹ 2ï¼š123ERROR: aaa is not a legal numberERROR: -9999 is not a legal numberThe average of 0 numbers is Undefined é€šè¿‡ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;iomanip&gt;using namespace std;bool check(string t, double* x) { int dot = -1; int dotNum = 0; bool ok = true; int i = 0; if (t[i] == '-')i++; for ( ; i &lt; t.length(); i++) { if (!(t[i] &gt;= '0' &amp;&amp; t[i] &lt;= '9')) { if (t[i] == '.') { dotNum++; if (dotNum == 1) dot = i; } else { ok = false; break; } } } if (dotNum &gt; 1) ok = false; if (dot != -1 &amp;&amp; t.length() - dot - 1 &gt; 2)ok = false; if (ok) { *x = atof(t.data()); if (fabs(*x) &gt; 1000) ok = false; } return ok;}int main() { int n; cin &gt;&gt; n; int count = 0; double sum = 0; string str; for (int j = 0; j &lt; n; j++) { double StrToNum = 0; cin &gt;&gt; str; if (check(str, &amp;StrToNum)) { sum += StrToNum; count++; } else { cout &lt;&lt; &quot;ERROR: &quot; &lt;&lt; str &lt;&lt; &quot; is not a legal number&quot; &lt;&lt; endl; } } if (count == 1) { cout &lt;&lt; &quot;The average of &quot; &lt;&lt; count &lt;&lt; &quot; number is &quot; &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; sum / count &lt;&lt; endl; } else if (count == 0) { cout &lt;&lt; &quot;The average of 0 numbers is Undefined&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;The average of &quot; &lt;&lt; count &lt;&lt; &quot; numbers is &quot; &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; sum / count &lt;&lt; endl; }} æ€è·¯ä¸æ³¨æ„ åˆ¤æ–­è¾“å…¥æ˜¯å¦ç¬¦åˆé¢˜ç›®è¦æ±‚ åˆ©ç”¨æˆå‘˜å‡½æ•°data()æŠŠstringè½¬ä¸ºchar*ï¼Œ å†åˆ©ç”¨atof()è½¬åŒ–ä¸ºå®æ•° ç»Ÿè®¡å¹¶è®¡ç®— åæ€ä¸è¯„ä»· æ²¡æœ‰è€ƒè™‘æ²¡æœ‰å°æ•°ç‚¹çš„æ—¶å€™ï¼Œä¸ç”¨è®¡ç®—å°æ•°ç‚¹ä½æ•°ï¼Œä¸€ç›´é”™ã€‚","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1054-%E6%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1060","text":"é¢˜ç›® è‹±å›½å¤©æ–‡å­¦å®¶çˆ±ä¸é¡¿å¾ˆå–œæ¬¢éª‘è½¦ã€‚æ®è¯´ä»–ä¸ºäº†ç‚«è€€è‡ªå·±çš„éª‘è½¦åŠŸåŠ›ï¼Œè¿˜å®šä¹‰äº†ä¸€ä¸ªâ€œçˆ±ä¸é¡¿æ•°â€ E ï¼Œå³æ»¡è¶³æœ‰ E å¤©éª‘è½¦è¶…è¿‡ E è‹±é‡Œçš„æœ€å¤§æ•´æ•° Eã€‚æ®è¯´çˆ±ä¸é¡¿è‡ªå·±çš„ E ç­‰äº87ã€‚ ç°ç»™å®šæŸäºº N å¤©çš„éª‘è½¦è·ç¦»ï¼Œè¯·ä½ ç®—å‡ºå¯¹åº”çš„çˆ±ä¸é¡¿æ•° Eï¼ˆâ‰¤Nï¼‰ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° N (â‰¤105)ï¼Œå³è¿ç»­éª‘è½¦çš„å¤©æ•°ï¼›ç¬¬äºŒè¡Œç»™å‡º N ä¸ªéè´Ÿæ•´æ•°ï¼Œä»£è¡¨æ¯å¤©çš„éª‘è½¦è·ç¦»ã€‚ è¾“å‡ºæ ¼å¼ï¼š åœ¨ä¸€è¡Œä¸­ç»™å‡º N å¤©çš„çˆ±ä¸é¡¿æ•°ã€‚ è¾“å…¥æ ·ä¾‹ï¼š12106 7 6 9 3 10 8 2 7 8 è¾“å‡ºæ ·ä¾‹ï¼š16 é€šè¿‡ä»£ç 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int num[1001000];int main() { int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; num[i]; } sort(num, num + n, greater&lt;int&gt;()); for (int i = 0; i &lt; n; i++) { if (i + 1 &gt;= num[i] - 1) { cout &lt;&lt; num[i] - 1 &lt;&lt; endl; break; } } return 0;} æ€è·¯ä¸æ³¨æ„ ä¸èƒ½ä¸¤å±‚å¾ªç¯æ±‚å‡ºæ‰€æœ‰å€¼å†å€’å™æ‰¾æ»¡è¶³çš„å€¼ï¼Œä¼šè¶…æ—¶ å…ˆæ’åºï¼Œå¯¹äºè¾“å…¥æ ·ä¾‹æœ‰ï¼š 110 9 8 8 7 7 6 6 3 2 é€šè¿‡è§‚å¯Ÿå¯çŸ¥ ç¬¬1ä¸ªæ•°ä»£è¡¨æœ‰1å¤©è¶…è¿‡(10-1) ç¬¬2ä¸ªæ•°ä»£è¡¨æœ‰2å¤©è¶…è¿‡(9-1) ç¬¬3ä¸ªæ•°ä»£è¡¨æœ‰3å¤©è¶…è¿‡(8-1) ç¬¬4ä¸ªæ•°ä»£è¡¨æœ‰4å¤©è¶…è¿‡(8-1) ç¬¬5ä¸ªæ•°ä»£è¡¨æœ‰5å¤©è¶…è¿‡(7-1) ç¬¬6ä¸ªæ•°ä»£è¡¨æœ‰6å¤©è¶…è¿‡(7-1) æ‰€ä»¥ç­”æ¡ˆä¸º6 æ ¹æ®ä»¥ä¸Šæ–¹æ³•æ¨¡æ‹Ÿå³å¯ åæ€ä¸è¯„ä»· è¿™é¢˜æŒºå¥½","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1060-%E7%88%B1%E4%B8%81%E9%A1%BF%E6%95%B0(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1034","text":"é¢˜ç›® æœ¬é¢˜è¦æ±‚ç¼–å†™ç¨‹åºï¼Œè®¡ç®— 2 ä¸ªæœ‰ç†æ•°çš„å’Œã€å·®ã€ç§¯ã€å•†ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥åœ¨ä¸€è¡Œä¸­æŒ‰ç…§ a1/b1 a2/b2 çš„æ ¼å¼ç»™å‡ºä¸¤ä¸ªåˆ†æ•°å½¢å¼çš„æœ‰ç†æ•°ï¼Œå…¶ä¸­åˆ†å­å’Œåˆ†æ¯å…¨æ˜¯æ•´å‹èŒƒå›´å†…çš„æ•´æ•°ï¼Œè´Ÿå·åªå¯èƒ½å‡ºç°åœ¨åˆ†å­å‰ï¼Œåˆ†æ¯ä¸ä¸º 0ã€‚ è¾“å‡ºæ ¼å¼ï¼š åˆ†åˆ«åœ¨ 4 è¡Œä¸­æŒ‰ç…§ æœ‰ç†æ•°1 è¿ç®—ç¬¦ æœ‰ç†æ•°2 = ç»“æœ çš„æ ¼å¼é¡ºåºè¾“å‡º 2 ä¸ªæœ‰ç†æ•°çš„å’Œã€å·®ã€ç§¯ã€å•†ã€‚æ³¨æ„è¾“å‡ºçš„æ¯ä¸ªæœ‰ç†æ•°å¿…é¡»æ˜¯è¯¥æœ‰ç†æ•°çš„æœ€ç®€å½¢å¼ k a/bï¼Œå…¶ä¸­ k æ˜¯æ•´æ•°éƒ¨åˆ†ï¼Œa/b æ˜¯æœ€ç®€åˆ†æ•°éƒ¨åˆ†ï¼›è‹¥ä¸ºè´Ÿæ•°ï¼Œåˆ™é¡»åŠ æ‹¬å·ï¼›è‹¥é™¤æ³•åˆ†æ¯ä¸º 0ï¼Œåˆ™è¾“å‡º Infã€‚é¢˜ç›®ä¿è¯æ­£ç¡®çš„è¾“å‡ºä¸­æ²¡æœ‰è¶…è¿‡æ•´å‹èŒƒå›´çš„æ•´æ•°ã€‚ è¾“å…¥æ ·ä¾‹ 1ï¼š2/3 -4/2 è¾“å‡ºæ ·ä¾‹ 1ï¼š2/3 + (-2) = (-1 1/3) 2/3 - (-2) = 2 2/3 2/3 * (-2) = (-1 1/3) 2/3 / (-2) = (-1/3) è¾“å…¥æ ·ä¾‹ 2ï¼š5/3 0/6 è¾“å‡ºæ ·ä¾‹ 2ï¼š1 2/3 + 0 = 1 2/3 1 2/3 - 0 = 1 2/3 1 2/3 * 0 = 0 1 2/3 / 0 = Inf é€šè¿‡ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;string toString (ll a) { string ans; while (a) { ans.append(1,(char)(a%10 + '0')); a/=10; } reverse(ans.begin(), ans.end()); return ans;}class Main {private: ll ans1,ans2, pos;public: Main(ll a, ll b) { pos = 1; ans1 = a; ans2 = b; if (a &lt; 0) { ans1 *= -1; pos*=-1; } if (b &lt; 0) { ans2 *= -1; pos*=-1; } } Main(Main&amp; ob) { ans1 = ob.ans1; ans2 = ob.ans2; pos = ob.pos; } void set(ll a, ll b) { pos = 1; ans1 = a; ans2 = b; if (a &lt; 0) { ans1 *= -1; pos*=-1; } if (b &lt; 0) { ans2 *= -1; pos*=-1; } } string toString() { string ans; if (ans1 == 0 &amp;&amp; ans2 != 0) { ans.append(&quot;0&quot;); return ans; } if (ans2 == 0) { ans.append(&quot;Inf&quot;); return ans; } getSmall(); if (pos == -1) { ans.append(&quot;(-&quot;); } if (ans2 != 1) { if (ans1 &lt; ans2) { ans.append(::toString(ans1)); ans.append(&quot;/&quot;); ans.append(::toString(ans2)); } else if (ans1 == ans2) { ans.append(&quot;1&quot;); } else { ll y = ans1 / ans2; ll ta1 = ans1; ta1 -= y * ans2; ans.append(::toString(y)); ans.append(&quot; &quot;); ans.append(::toString(ta1)); ans.append(&quot;/&quot;); ans.append(::toString(ans2)); } } else { ans.append(::toString(ans1)); } if (pos == -1) { ans.append(&quot;)&quot;); } return ans; } void getSmall() { ll ta = ans1, tb = ans2; while (tb != 0) { ll temp = ta % tb; ta = tb; tb = temp; } ans1 /= ta; ans2 /= ta; } static void add(Main* a, Main* b, Main* ans) { ll ans1 = a-&gt;ans1 * b-&gt;ans2 * a-&gt;pos + a-&gt;ans2 * b-&gt;ans1 * b-&gt;pos; ll ans2 = a-&gt;ans2 * b-&gt;ans2; ans-&gt;set(ans1, ans2); } static void sub(Main* a, Main* b, Main* ans) { ll ans1 = a-&gt;ans1 * b-&gt;ans2*a-&gt;pos - a-&gt;ans2 * b-&gt;ans1*b-&gt;pos; ll ans2 = a-&gt;ans2 * b-&gt;ans2; ans-&gt;set(ans1, ans2); } static void mul(Main* a, Main* b, Main* ans) { ll ans1 = a-&gt;pos * b-&gt;pos * a-&gt;ans1 * b-&gt;ans1; ll ans2 = a-&gt;ans2 * b-&gt;ans2; ans-&gt;set(ans1, ans2); } static void dev(Main* a, Main* b, Main* ans) { ll ans1 = a-&gt;pos * b-&gt;pos * a-&gt;ans1 * b-&gt;ans2; ll ans2 = a-&gt;ans2 * b-&gt;ans1; ans-&gt;set(ans1, ans2); }};int main() { ll a1,a2,b1,b2; scanf(&quot;%lld/%lld %lld/%lld&quot;, &amp;a1, &amp;a2, &amp;b1, &amp;b2); Main x(a1, a2); Main y(b1, b2); Main ans(0,0); Main::add(&amp;x, &amp;y, &amp;ans); cout &lt;&lt; x.toString() &lt;&lt; &quot; + &quot; &lt;&lt; y.toString() &lt;&lt; &quot; = &quot; &lt;&lt; ans.toString() &lt;&lt; endl; Main::sub(&amp;x, &amp;y, &amp;ans); cout &lt;&lt; x.toString() &lt;&lt; &quot; - &quot; &lt;&lt; y.toString() &lt;&lt; &quot; = &quot; &lt;&lt; ans.toString() &lt;&lt; endl; Main::mul(&amp;x, &amp;y, &amp;ans); cout &lt;&lt; x.toString() &lt;&lt; &quot; * &quot; &lt;&lt; y.toString() &lt;&lt; &quot; = &quot; &lt;&lt; ans.toString() &lt;&lt; endl; Main::dev(&amp;x, &amp;y, &amp;ans); cout &lt;&lt; x.toString() &lt;&lt; &quot; / &quot; &lt;&lt; y.toString() &lt;&lt; &quot; = &quot; &lt;&lt; ans.toString() &lt;&lt; endl; return 0;} æ€è·¯ä¸æ³¨æ„ å†™ä¸€ä¸ªå¯¹åˆ†æ•°çš„å¤„ç†ç±»ï¼Œåˆ†åˆ«è®°å½•åˆ†å­ï¼Œåˆ†æ¯å’Œç¬¦å· è®¡ç®—ä»€ä¹ˆçš„ç›´æ¥ç®—ï¼Œç­‰æœ€åè¦è¾“å‡ºä¹‹å‰æ±‚ä¸€ä¸‹æœ€å¤§å…¬å€æ•°çº¦åˆ†ä¸€ä¸‹å°±å¥½äº†ï¼Œï¼ˆåŸè°…æˆ‘ä¸ä¼šçº¦åˆ†çš„è‹±æ–‡ï¼Œåªå¥½å†™æˆgetSmalläº†ï¼Œhhhï¼‰ è¿™é“é¢˜é¢˜ç›®ä¸Šè¯´è¾“å…¥å’Œç»“æ„éƒ½åœ¨intèŒƒå›´ï¼Œä½†æ˜¯ä¸ä¿è¯ä¸­é—´è¿‡ç¨‹ä¹Ÿåœ¨intèŒƒå›´ï¼Œæ‰€ä»¥è¦ç”¨long æ³¨æ„ç¬¬äºŒä¸ªæ•°ä¸º0æ—¶çš„è¦ç‰¹åˆ¤ åæ€ä¸è¯„ä»· è¿™æ¬¡æŠŠJavaç§»æ¤æˆC++ï¼ŒæŠŠä»¥ä¸‹é—®é¢˜éƒ½è§£å†³äº†ï¼Œä¸ªäººè®¤ä¸ºè¿™é¢˜å¤§æ¦‚å°±æ˜¯ç»™C++è®¾è®¡çš„å§ï¼Ÿ12&gt;* å¤„ç†åŠ å’Œå‡çš„å‡½æ•°æœ‰ç‚¹è‡ƒè‚¿\bï¼Œæœ‰å¾…æé«˜&gt;* è¿™ä¸ªä»£ç åœ¨è¶…æ—¶çš„è¾¹ç¼˜ç–¯ç‹‚è¯•æ¢ï¼Œæœ‰æ—¶å€™èƒ½å…¨éƒ¨é€šè¿‡ï¼Œæœ‰æ—¶å€™ä¼šè¿è¡Œè¶…æ—¶ã€‚å¥½ç¥å¥‡ï¼Œè€Œä¸”è¶Šå‹è¡Œï¼Œè¶Šè¶…æ—¶ã€‚ åœ¨ç§»æ¤çš„æ—¶å€™ï¼Œæ„é€ å‡½æ•°å†™æˆåªæœ‰å‚æ•°ä¸ºè´Ÿæ‰ä¼šèµ‹å€¼ï¼Œä¸€ç›´ç®—ä¸å‡ºæ¥ï¼ŒæŠ˜è…¾å¾ˆä¹…ï¼Œä»¥åç§»æ¤çš„æ—¶å€™è¦å°å¿ƒã€‚ ç§»æ¤è¿‡ç¨‹ä¸­æœ‰å¾ˆå¤šå†…å­˜æ³„æ¼çš„é—®é¢˜ï¼Œåæ¥ä¹Ÿéƒ½æ”¹äº†ã€‚Javaæ ¹æœ¬ä¸ç”¨è€ƒè™‘å†…å­˜çš„é—®é¢˜ï¼Œä»¥åç§»æ¤çš„æ—¶å€™è¿™ä¸€ç‚¹ä¹Ÿè¦æ³¨æ„ã€‚","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1034-%E6%9C%89%E7%90%86%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1059","text":"é¢˜ç›® C è¯­è¨€ç«èµ›æ˜¯æµ™æ±Ÿå¤§å­¦è®¡ç®—æœºå­¦é™¢ä¸»æŒçš„ä¸€ä¸ªæ¬¢ä¹çš„ç«èµ›ã€‚æ—¢ç„¶ç«èµ›ä¸»æ—¨æ˜¯ä¸ºäº†å¥½ç©ï¼Œé¢å¥–è§„åˆ™ä¹Ÿå°±åˆ¶å®šå¾—å¾ˆæ»‘ç¨½ï¼š 0ã€å† å†›å°†èµ¢å¾—ä¸€ä»½â€œç¥ç§˜å¤§å¥–â€ï¼ˆæ¯”å¦‚å¾ˆå·¨å¤§çš„ä¸€æœ¬å­¦ç”Ÿç ”ç©¶è®ºæ–‡é›†â€¦â€¦ï¼‰ã€‚ 1ã€æ’åä¸ºç´ æ•°çš„å­¦ç”Ÿå°†èµ¢å¾—æœ€å¥½çš„å¥–å“ â€”â€” å°é»„äººç©å¶ï¼ 2ã€å…¶ä»–äººå°†å¾—åˆ°å·§å…‹åŠ›ã€‚ ç»™å®šæ¯”èµ›çš„æœ€ç»ˆæ’åä»¥åŠä¸€ç³»åˆ—å‚èµ›è€…çš„ IDï¼Œä½ è¦ç»™å‡ºè¿™äº›å‚èµ›è€…åº”è¯¥è·å¾—çš„å¥–å“ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤104ï¼‰ï¼Œæ˜¯å‚èµ›è€…äººæ•°ã€‚éšå N è¡Œç»™å‡ºæœ€ç»ˆæ’åï¼Œæ¯è¡ŒæŒ‰æ’åé¡ºåºç»™å‡ºä¸€ä½å‚èµ›è€…çš„ IDï¼ˆ4 ä½æ•°å­—ç»„æˆï¼‰ã€‚æ¥ä¸‹æ¥ç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° K ä»¥åŠ K ä¸ªéœ€è¦æŸ¥è¯¢çš„ IDã€‚ è¾“å‡ºæ ¼å¼ï¼š å¯¹æ¯ä¸ªè¦æŸ¥è¯¢çš„ IDï¼Œåœ¨ä¸€è¡Œä¸­è¾“å‡º ID: å¥–å“ï¼Œå…¶ä¸­å¥–å“æˆ–è€…æ˜¯ Mystery Awardï¼ˆç¥ç§˜å¤§å¥–ï¼‰ã€æˆ–è€…æ˜¯ Minionï¼ˆå°é»„äººï¼‰ã€æˆ–è€…æ˜¯ Chocolateï¼ˆå·§å…‹åŠ›ï¼‰ã€‚å¦‚æœæ‰€æŸ¥ ID æ ¹æœ¬ä¸åœ¨æ’åé‡Œï¼Œæ‰“å° Are you kidding?ï¼ˆè€æˆ‘å‘¢ï¼Ÿï¼‰ã€‚å¦‚æœè¯¥ ID å·²ç»æŸ¥è¿‡äº†ï¼ˆå³å¥–å“å·²ç»é¢†è¿‡äº†ï¼‰ï¼Œæ‰“å° ID: Checkedï¼ˆä¸èƒ½å¤šåƒå¤šå ï¼‰ã€‚ è¾“å…¥æ ·ä¾‹ï¼š123456789101112131461111666688881234555500016888800011111222288882222 è¾“å‡ºæ ·ä¾‹ï¼š1234568888: Minion0001: Chocolate1111: Mystery Award2222: Are you kidding?8888: Checked2222: Are you kidding? é€šè¿‡ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;int prime[10005] = {0, 1, 2, 2, 3};void get_prime() { for (int i = 5; i &lt; 10005; i++) { prime[i] = 2; for (int j = 2; j * j &lt;= i; j++) { if (i % j == 0) { prime[i] = 3; break; } } }}int main() { get_prime(); int rank[10005] = {0}; string str[4] = {&quot;Are you kidding?&quot;, &quot;Mystery Award&quot;, &quot;Minion&quot;, &quot;Chocolate&quot;}; string checked = &quot;Checked&quot;; int has[10005] = {0}; int n, id; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; id; rank[id] = i + 1; } cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; id; int RANK = rank[id], HAS = has[id]; if (!HAS || RANK == 0) { printf (&quot;%04d: %s\\n&quot;, id, str[prime[RANK]].data()); has[id] = 1; } else { printf (&quot;%04d: %s\\n&quot;, id, checked.data()); } } return 0;} æ€è·¯ä¸æ³¨æ„ å…ˆæŠŠéœ€è¦è¾“å‡ºçš„å­—ç¬¦ä¸²å­˜èµ·æ¥ï¼Œåˆ†åˆ«ä¸º0ï¼Œ1ï¼Œ2ï¼Œ3 æ ¹æ®é¢˜æ„ï¼Œæä¸€ä¸ªæ•°ç»„ï¼Œå¦‚æœæ˜¯0ï¼Œ1ï¼Œåˆ™å€¼ä¸º0ï¼Œ1ï¼Œå…¶ä»–æ•°å¦‚æœæ˜¯ç´ æ•°ä¸º2ï¼ˆå¯¹åº”millionï¼‰ï¼Œä¸æ˜¯ç´ æ•°ä¸º3ï¼Œå¯¹åº”chocolate å†æä¸€ä¸ªæ•°ç»„ï¼Œä»¥ç¼–å·ä¸ºå¼•ç´¢ï¼Œè®°å½•æ’å æä¸€ä¸ªhasæ•°ç»„ï¼Œè®°å½•æ˜¯å¦è¾“å‡ºè¿‡ åæ€ä¸è¯„ä»· è¿™é“é¢˜æŒºç®€å•çš„ é€šè¿‡æ‰“è¡¨è®°å½•æ˜¯å¦ä¸ºç´ æ•°ï¼Œå¯ä»¥å‡å°‘è®¡ç®—æ¬¡æ•°","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1059-C%E8%AF%AD%E8%A8%80%E7%AB%9E%E8%B5%9B(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1065","text":"é¢˜ç›® â€œå•èº«ç‹—â€æ˜¯ä¸­æ–‡å¯¹äºå•èº«äººå£«çš„ä¸€ç§çˆ±ç§°ã€‚æœ¬é¢˜è¯·ä½ ä»ä¸Šä¸‡äººçš„å¤§å‹æ´¾å¯¹ä¸­æ‰¾å‡ºè½å•çš„å®¢äººï¼Œä»¥ä¾¿ç»™äºˆç‰¹æ®Šå…³çˆ±ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤ 50 000ï¼‰ï¼Œæ˜¯å·²çŸ¥å¤«å¦»/ä¼´ä¾£çš„å¯¹æ•°ï¼›éšå N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€å¯¹å¤«å¦»/ä¼´ä¾£â€”â€”ä¸ºæ–¹ä¾¿èµ·è§ï¼Œæ¯äººå¯¹åº”ä¸€ä¸ª ID å·ï¼Œä¸º 5 ä½æ•°å­—ï¼ˆä» 00000 åˆ° 99999ï¼‰ï¼ŒID é—´ä»¥ç©ºæ ¼åˆ†éš”ï¼›ä¹‹åç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Mï¼ˆâ‰¤ 10 000ï¼‰ï¼Œä¸ºå‚åŠ æ´¾å¯¹çš„æ€»äººæ•°ï¼›éšåä¸€è¡Œç»™å‡ºè¿™ M ä½å®¢äººçš„ IDï¼Œä»¥ç©ºæ ¼åˆ†éš”ã€‚é¢˜ç›®ä¿è¯æ— äººé‡å©šæˆ–è„šè¸©ä¸¤æ¡èˆ¹ã€‚ è¾“å‡ºæ ¼å¼ï¼š é¦–å…ˆç¬¬ä¸€è¡Œè¾“å‡ºè½å•å®¢äººçš„æ€»äººæ•°ï¼›éšåç¬¬äºŒè¡ŒæŒ‰ ID é€’å¢é¡ºåºåˆ—å‡ºè½å•çš„å®¢äººã€‚ID é—´ç”¨ 1 ä¸ªç©ºæ ¼åˆ†éš”ï¼Œè¡Œçš„é¦–å°¾ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚ è¾“å…¥æ ·ä¾‹ï¼š123456311111 2222233333 4444455555 66666755555 44444 10000 88888 22222 11111 23333 è¾“å‡ºæ ·ä¾‹ï¼š12510000 23333 44444 55555 88888 é€šè¿‡ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;using namespace std;struct people { int id; bool pair;} c[10100];bool cmp (people&amp;a, people&amp; b) { return a.id &lt; b.id;}int p[100100], x, y, n, num;int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; x &gt;&gt; y; p[x] = y; p[y] = x; } cin &gt;&gt; num; for (int i = 0; i &lt; num; i++) { cin &gt;&gt; c[i].id; c[i].pair = false; } int count = 0; for (int i = 0; i &lt; num; i++) { for (int j = 0; j &lt; num; j++) { if (p[c[i].id] == c[j].id) { c[i].pair = true; count++; } } } cout &lt;&lt; num - count &lt;&lt; endl; sort(c, c + num, cmp); int i = 0; while (c[i++].pair &amp;&amp; i &lt;= num); if (i &lt;= num)//è¿™é‡Œæ˜¯i&lt;=num cout &lt;&lt; setw(5) &lt;&lt; setfill('0') &lt;&lt; c[i - 1].id; //æ³¨æ„è¿™é‡Œæ˜¯i-1 for (; i &lt; num; i++) { if (!c[i].pair) { cout &lt;&lt; &quot; &quot; &lt;&lt; setw(5) &lt;&lt; setfill('0') &lt;&lt; c[i].id; } }} æ€è·¯ä¸æ³¨æ„ å› ä¸ºç»™çš„æ•°å¾ˆå°ï¼Œæ‰€ä»¥å¯ä»¥åˆ—ä¸€ä¸ªè¡¨æ ¼ï¼ŒæŠŠä¸¤ä¸ªidä¸€ä¸ªä½œä¸ºå€¼ï¼Œä¸€ä¸ªä½œä¸ºå¼•ç´¢ ä¸¤å±‚forå¾ªç¯ï¼Œç¬¬ä¸€å±‚å›ºå®šè¦åˆ¤æ–­çš„å¯¹è±¡ï¼Œç¬¬äºŒæ¬¡é€ä¸ªéå†å…¶ä»–äººï¼Œæ¯”è¾ƒid è¾“å‡ºï¼Œæ³¨æ„è¦äº”ä½æ•°è¾“å‡ºï¼Œä¸è¶³å‰é¢è¡¥0 åæ€ä¸è¯„ä»· æœ€åè¾“å‡ºçš„æ¡ä»¶æ˜¯i&lt;=num ä¸æ˜¯ i&lt;num, å› ä¸ºæˆ‘æŠŠi++å†™åœ¨äº†whileçš„æ‹¬å·é‡Œé¢ è¾“å‡ºç¬¬ä¸€ä¸ªçš„æ—¶å€™ä¸‹æ ‡è¦i-1,å› ä¸ºæˆ‘æŠŠi++å†™åœ¨äº†whileçš„æ‹¬å·é‡Œé¢","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1065-%E5%8D%95%E8%BA%AB%E7%8B%97(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1062","text":"é¢˜ç›® ä¸€ä¸ªåˆ†æ•°ä¸€èˆ¬å†™æˆä¸¤ä¸ªæ•´æ•°ç›¸é™¤çš„å½¢å¼ï¼šN/Mï¼Œå…¶ä¸­ M ä¸ä¸º0ã€‚æœ€ç®€åˆ†æ•°æ˜¯æŒ‡åˆ†å­å’Œåˆ†æ¯æ²¡æœ‰å…¬çº¦æ•°çš„åˆ†æ•°è¡¨ç¤ºå½¢å¼ã€‚ ç°ç»™å®šä¸¤ä¸ªä¸ç›¸ç­‰çš„æ­£åˆ†æ•° N1/M1 å’Œ N2/M2ï¼Œè¦æ±‚ä½ æŒ‰ä»å°åˆ°å¤§çš„é¡ºåºåˆ—å‡ºå®ƒä»¬ä¹‹é—´åˆ†æ¯ä¸º K çš„æœ€ç®€åˆ†æ•°ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥åœ¨ä¸€è¡Œä¸­æŒ‰ N/M çš„æ ¼å¼ç»™å‡ºä¸¤ä¸ªæ­£åˆ†æ•°ï¼Œéšåæ˜¯ä¸€ä¸ªæ­£æ•´æ•°åˆ†æ¯ Kï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚é¢˜ç›®ä¿è¯ç»™å‡ºçš„æ‰€æœ‰æ•´æ•°éƒ½ä¸è¶…è¿‡ 1000ã€‚ è¾“å‡ºæ ¼å¼ï¼š åœ¨ä¸€è¡Œä¸­æŒ‰ N/M çš„æ ¼å¼åˆ—å‡ºä¸¤ä¸ªç»™å®šåˆ†æ•°ä¹‹é—´åˆ†æ¯ä¸º K çš„æ‰€æœ‰æœ€ç®€åˆ†æ•°ï¼ŒæŒ‰ä»å°åˆ°å¤§çš„é¡ºåºï¼Œå…¶é—´ä»¥ 1 ä¸ªç©ºæ ¼åˆ†éš”ã€‚è¡Œé¦–å°¾ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚é¢˜ç›®ä¿è¯è‡³å°‘æœ‰ 1 ä¸ªè¾“å‡ºã€‚ è¾“å…¥æ ·ä¾‹ï¼š17/18 13/20 12 è¾“å‡ºæ ·ä¾‹ï¼š15/12 7/12 é€šè¿‡ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;typedef long long ll;class Main {private: ll ans1, ans2, pos;public: Main(ll a, ll b) { set(a, b); } void set(ll a, ll b) { pos = 1; ans1 = a; ans2 = b; if (a &lt; 0) { ans1 *= -1; pos *= -1; } if (b &lt; 0) { ans2 *= -1; pos *= -1; } } void getSmall() { ll ta = ans1, tb = ans2; while (tb != 0) { ll temp = ta % tb; ta = tb; tb = temp; } ans1 /= ta; ans2 /= ta; } static void swap(Main&amp; a, Main&amp; b) {Main temp = a; a = b; b = temp; } static void add(Main* a, Main* b, Main* ans) { ll ans1 = a-&gt;ans1 * b-&gt;ans2 * a-&gt;pos + a-&gt;ans2 * b-&gt;ans1 * b-&gt;pos; ll ans2 = a-&gt;ans2 * b-&gt;ans2; ans-&gt;set(ans1, ans2); ans-&gt;getSmall(); } double toDouble() { return 1.0 * pos * ans1 / ans2; } ll getSon() { return ans1; } ll getMother() { return ans2; }};int main() { ll a1, a2, b1, b2, n; scanf(&quot;%lld/%lld %lld/%lld %lld&quot;, &amp;a1, &amp;a2, &amp;b1, &amp;b2, &amp;n); Main x(a1, a2), y(b1, b2), ans(1, n), one(1, n); if (x.toDouble() &gt; y.toDouble()) Main::swap(x, y); int count = 0; while (1) { if (ans.toDouble() &gt; x.toDouble() &amp;&amp; ans.toDouble() &lt; y.toDouble()) { if (ans.getMother() == n) { if (count++ == 0) cout &lt;&lt; ans.getSon() &lt;&lt; &quot;/&quot; &lt;&lt; n; else cout &lt;&lt; &quot; &quot; &lt;&lt; ans.getSon() &lt;&lt; &quot;/&quot; &lt;&lt; n; } } else if (ans.toDouble() &gt; y.toDouble()) { break; } Main::add(&amp;ans, &amp;one, &amp;ans); } return 0;} æ€è·¯ä¸æ³¨æ„ copyå¹¶ç²¾ç®€ä¸Šä¸€æ¬¡å†™çš„åˆ†æ•°å¤„ç†ç±»ï¼ˆä¼ é€é—¨PATä¹™çº§é¢˜â€“1034 æœ‰ç†æ•°å››åˆ™è¿ç®—ï¼‰1. æ·»åŠ äº†è½¬æ¢æˆdoubleï¼ˆtoDouble()ï¼‰å‡½æ•°2. å¾—åˆ°åˆ†å­åˆ†æ¯ï¼ˆgetSon(), getMother()ï¼‰å‡½æ•° 3. äº¤æ¢å€¼çš„ï¼ˆswap()ï¼‰å‡½æ•°ã€‚4. è¾“å…¥åï¼Œä¿è¯x&lt;=y å¾—åˆ°K(æˆ‘çš„ä»£ç ä¸­çš„n)ï¼Œæ„é€ ä¸¤ä¸ªåˆ†æ•°1/nï¼Œç„¶åå¾ªç¯ç›¸åŠ  å¦‚æœæ•°åœ¨å‰ä¸¤ä¸ªæ•°ä¹‹é—´ï¼ˆæ³¨æ„ä¸ºå¼€åŒºé—´ï¼Œä¸åŒ…æ‹¬åŒºé—´çš„ç«¯ç‚¹ï¼‰ï¼Œå¹¶ä¸”åˆ†æ¯ä¸ºn(æ¯æ¬¡è¿ç®—åå°±çº¦åˆ†ä¸€æ¬¡ï¼ŒåªæŒ‘çº¦åˆ†ååˆ†æ¯è¿˜æ˜¯nçš„)ï¼Œåˆ™æŒ‰ç…§è¦æ±‚è¾“å‡ºã€‚ åæ€ä¸è¯„ä»· ä»£ç ç§¯ç´¯å¾ˆé‡è¦","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1062-%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1052","text":"é¢˜ç›®èŒèŒå“’è¡¨æƒ…ç¬¦å·é€šå¸¸ç”±â€œæ‰‹â€ã€â€œçœ¼â€ã€â€œå£â€ä¸‰ä¸ªä¸»è¦éƒ¨åˆ†ç»„æˆã€‚ç®€å•èµ·è§ï¼Œæˆ‘ä»¬å‡è®¾ä¸€ä¸ªè¡¨æƒ…ç¬¦å·æ˜¯æŒ‰ä¸‹åˆ—æ ¼å¼è¾“å‡ºçš„ï¼š 1[å·¦æ‰‹]([å·¦çœ¼][å£][å³çœ¼])[å³æ‰‹] ç°ç»™å‡ºå¯é€‰ç”¨çš„ç¬¦å·é›†åˆï¼Œè¯·ä½ æŒ‰ç”¨æˆ·çš„è¦æ±‚è¾“å‡ºè¡¨æƒ…ã€‚ è¾“å…¥æ ¼å¼ï¼šè¾“å…¥é¦–å…ˆåœ¨å‰ä¸‰è¡Œé¡ºåºå¯¹åº”ç»™å‡ºæ‰‹ã€çœ¼ã€å£çš„å¯é€‰ç¬¦å·é›†ã€‚æ¯ä¸ªç¬¦å·æ‹¬åœ¨ä¸€å¯¹æ–¹æ‹¬å· []å†…ã€‚é¢˜ç›®ä¿è¯æ¯ä¸ªé›†åˆéƒ½è‡³å°‘æœ‰ä¸€ä¸ªç¬¦å·ï¼Œå¹¶ä¸è¶…è¿‡ 10 ä¸ªç¬¦å·ï¼›æ¯ä¸ªç¬¦å·åŒ…å« 1 åˆ° 4 ä¸ªéç©ºå­—ç¬¦ã€‚ ä¹‹åä¸€è¡Œç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Kï¼Œä¸ºç”¨æˆ·è¯·æ±‚çš„ä¸ªæ•°ã€‚éšå K è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä¸ªç”¨æˆ·çš„ç¬¦å·é€‰æ‹©ï¼Œé¡ºåºä¸ºå·¦æ‰‹ã€å·¦çœ¼ã€å£ã€å³çœ¼ã€å³æ‰‹â€”â€”è¿™é‡Œåªç»™å‡ºç¬¦å·åœ¨ç›¸åº”é›†åˆä¸­çš„åºå·ï¼ˆä» 1 å¼€å§‹ï¼‰ï¼Œæ•°å­—é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚ è¾“å‡ºæ ¼å¼ï¼šå¯¹æ¯ä¸ªç”¨æˆ·è¯·æ±‚ï¼Œåœ¨ä¸€è¡Œä¸­è¾“å‡ºç”Ÿæˆçš„è¡¨æƒ…ã€‚è‹¥ç”¨æˆ·é€‰æ‹©çš„åºå·ä¸å­˜åœ¨ï¼Œåˆ™è¾“å‡º Are you kidding me? @\\/@ã€‚ è¾“å…¥æ ·ä¾‹ï¼š12345678[â•®][â•­][o][~\\][/~] [&lt;][&gt;] [â•¯][â•°][^][-][=][&gt;][&lt;][@][âŠ™][Ğ”][â–½][_][Îµ][^] ...41 1 2 2 26 8 1 5 53 3 4 3 32 10 3 9 3 è¾“å‡ºæ ·ä¾‹ï¼š1234â•®(â•¯â–½â•°)â•­&lt;(@Ğ”=)/~o(^Îµ^)oAre you kidding me? @\\/@ é€šè¿‡ä»£ç 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main () { vector&lt;string&gt; data[3]; string line; for (int j = 0; j &lt; 3; j++) { getline(cin, line); for (int i = 0, k = 0, count = 0; i &lt; line.length(); count++) { while ( i &lt; line.length() &amp;&amp; line[i] != '[')i++; while ( k &lt; line.length() &amp;&amp; line[k] != ']')k++; if (i &lt; line.length() &amp;&amp; k &lt; line.length()) { data[j].push_back(line.substr(i + 1, k - 1 - i)); k++; i = k; } else { break; } } } int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { int a[5]; for (int j = 0; j &lt; 5; j++) { cin &gt;&gt; a[j]; a[j]--; } if (a[0] &lt; data[0].size() &amp;&amp; a[1] &lt; data[1].size() &amp;&amp; a[2] &lt; data[2].size() &amp;&amp; a[3] &lt; data[1].size() &amp;&amp; a[4] &lt; data[0].size()) cout &lt;&lt; data[0][a[0]] &lt;&lt; &quot;(&quot; &lt;&lt; data[1][a[1]] &lt;&lt; data[2][a[2]] &lt;&lt; data[1][a[3]] &lt;&lt; &quot;)&quot; &lt;&lt; data[0][a[4]] &lt;&lt; endl; else printf(&quot;Are you kidding me? @\\\\/@\\n&quot;); }} æ€è·¯ä¸æ³¨æ„ è¿™é“é¢˜å…¶å®å°±æ˜¯åˆ†æå­—ç¬¦ä¸²ï¼ŒæŠŠæ‰€æœ‰[]å†…çš„å­—ç¬¦ä¸²å…¨éƒ½å­˜èµ·æ¥ï¼Œç„¶åç”¨æˆ·è¾“å…¥åºå·ï¼Œæ ¹æ®åºå·æŒ‰ç…§æ¡ä»¶è¾“å‡ºå°±å¯ä»¥äº† æ³¨æ„[]å†…ä¸ä¸€å®šåªæœ‰ä¸€ä¸ªå­—ç¬¦ï¼Œè€Œä¸”å¯èƒ½æ˜¯å®½å­—ç¬¦ï¼ˆç›´æ¥ä¿å­˜æˆstringå°±è¡Œï¼‰ æ³¨æ„ç”¨æˆ·è¾“å…¥çš„åºå·æ˜¯ä»1å¼€å§‹çš„ æ³¨æ„è¾“å‡ºæ ¼å¼ï¼ˆå·¦æ‰‹å³è¾¹ã€å³æ‰‹å·¦è¾¹æœ‰åŠè§’æ‹¬å·ï¼‰ 1[å·¦æ‰‹]([å·¦çœ¼][å£][å³çœ¼])[å³æ‰‹] åæ€ä¸è¯„ä»· è¿™é“é¢˜æ€è·¯å¾ˆæ¸…æ™°ï¼Œåˆ©ç”¨vectorä¼šå¾ˆæ–¹ä¾¿ å†™é¢˜çš„æ—¶å€™ä¸€ç›´è®¤ä¸ºsubstr()å‡½æ•°çš„ä¸¤ä¸ªå‚æ•°éƒ½æ˜¯indexï¼Œä¸€ç›´å‡ºé”™ï¼ˆæ‰‹åŠ¨ç¬‘å“­ï¼‰","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1052-%E5%8D%96%E4%B8%AA%E8%90%8C(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1067","text":"é¢˜ç›® å½“ä½ è¯•å›¾ç™»å½•æŸä¸ªç³»ç»Ÿå´å¿˜äº†å¯†ç æ—¶ï¼Œç³»ç»Ÿä¸€èˆ¬åªä¼šå…è®¸ä½ å°è¯•æœ‰é™å¤šæ¬¡ï¼Œå½“è¶…å‡ºå…è®¸æ¬¡æ•°æ—¶ï¼Œè´¦å·å°±ä¼šè¢«é”æ­»ã€‚æœ¬é¢˜å°±è¯·ä½ å®ç°è¿™ä¸ªå°åŠŸèƒ½ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥åœ¨ç¬¬ä¸€è¡Œç»™å‡ºä¸€ä¸ªå¯†ç ï¼ˆé•¿åº¦ä¸è¶…è¿‡ 20 çš„ã€ä¸åŒ…å«ç©ºæ ¼ã€Tabã€å›è½¦çš„éç©ºå­—ç¬¦ä¸²ï¼‰å’Œä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤ 10ï¼‰ï¼Œåˆ†åˆ«æ˜¯æ­£ç¡®çš„å¯†ç å’Œç³»ç»Ÿå…è®¸å°è¯•çš„æ¬¡æ•°ã€‚éšåæ¯è¡Œç»™å‡ºä¸€ä¸ªä»¥å›è½¦ç»“æŸçš„éç©ºå­—ç¬¦ä¸²ï¼Œæ˜¯ç”¨æˆ·å°è¯•è¾“å…¥çš„å¯†ç ã€‚è¾“å…¥ä¿è¯è‡³å°‘æœ‰ä¸€æ¬¡å°è¯•ã€‚å½“è¯»åˆ°ä¸€è¡Œåªæœ‰å•ä¸ª # å­—ç¬¦æ—¶ï¼Œè¾“å…¥ç»“æŸï¼Œå¹¶ä¸”è¿™ä¸€è¡Œä¸æ˜¯ç”¨æˆ·çš„è¾“å…¥ã€‚ è¾“å‡ºæ ¼å¼ï¼š å¯¹ç”¨æˆ·çš„æ¯ä¸ªè¾“å…¥ï¼Œå¦‚æœæ˜¯æ­£ç¡®çš„å¯†ç ä¸”å°è¯•æ¬¡æ•°ä¸è¶…è¿‡ Nï¼Œåˆ™åœ¨ä¸€è¡Œä¸­è¾“å‡º Welcome inï¼Œå¹¶ç»“æŸç¨‹åºï¼›å¦‚æœæ˜¯é”™è¯¯çš„ï¼Œåˆ™åœ¨ä¸€è¡Œä¸­æŒ‰æ ¼å¼è¾“å‡º Wrong password: ç”¨æˆ·è¾“å…¥çš„é”™è¯¯å¯†ç ï¼›å½“é”™è¯¯å°è¯•è¾¾åˆ° N æ¬¡æ—¶ï¼Œå†è¾“å‡ºä¸€è¡Œ Account lockedï¼Œå¹¶ç»“æŸç¨‹åºã€‚ è¾“å…¥æ ·ä¾‹ 1ï¼š123456Correct%pw 3correct%pwCorrect@PWwhatisthepassword!Correct%pw# è¾“å‡ºæ ·ä¾‹ 1ï¼š1234Wrong password: correct%pwWrong password: Correct@PWWrong password: whatisthepassword!Account locked è¾“å…¥æ ·ä¾‹ 2ï¼š123456cool@gplt 3coolman@gpltcoollady@gpltcool@gplttry again# è¾“å‡ºæ ·ä¾‹ 2ï¼š123Wrong password: coolman@gpltWrong password: coollady@gpltWelcome in é€šè¿‡ä»£ç 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main () { string corPwd; string pwd; int time; cin &gt;&gt; corPwd &gt;&gt; time; int i; getline(cin, pwd); for (i = 0; i &lt; time; i++) { getline(cin, pwd); if (pwd == corPwd) {cout &lt;&lt; &quot;Welcome in&quot; &lt;&lt; endl; break;} else if (pwd == &quot;#&quot;) {break;} else {cout &lt;&lt; &quot;Wrong password: &quot; &lt;&lt; pwd &lt;&lt; endl;} } if (i == time) cout &lt;&lt; &quot;Account locked&quot; &lt;&lt; endl; return 0;} æ€è·¯ä¸æ³¨æ„ æŒ‰ç…§è¦æ±‚ï¼Œè¾“å…¥ï¼Œåˆ¤æ–­ï¼Œè¾“å‡ºç»“æœ æ³¨æ„ç¬¬ä¸€æ¬¡è¾“å…¥ç”¨äº†cinçš„æå–è¿ç®—ç¬¦&gt;&gt;ï¼Œåé¢ç”¨äº†getline()å‡½æ•°ï¼Œæ³¨æ„åƒæ‰ç¬¬ä¸€è¡Œè¾“å…¥å‰©ä¸‹çš„æ¢è¡Œç¬¦ã€‚ åæ€ä¸è¯„ä»· ç®€å•","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1067-%E8%AF%95%E5%AF%86%E7%A0%81(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1072","text":"é¢˜ç›® ä¸‹å›¾æ˜¯ä¸Šæµ·æŸæ ¡çš„æ–°å­¦æœŸå¼€å­¦å¯„è¯­ï¼šå¤©å°†é™å¤§ä»»äºæ–¯äººä¹Ÿï¼Œå¿…å…ˆåˆ å…¶å¾®åšï¼Œå¸å…¶ QQï¼Œå°å…¶ç”µè„‘ï¼Œå¤ºå…¶æ‰‹æœºï¼Œæ”¶å…¶ ipadï¼Œæ–­å…¶ wifiï¼Œä½¿å…¶ç™¾æ— èŠèµ–ï¼Œç„¶åï¼Œå‡€é¢ã€ç†å‘ã€æ•´è¡£ï¼Œç„¶åæ€è¿‡ã€è¯»ä¹¦ã€é”»ç‚¼ã€æ˜æ™ºã€å¼€æ‚Ÿã€ç²¾è¿›ã€‚è€Œåå¿…æˆå¤§å™¨ä¹Ÿï¼æœ¬é¢˜è¦æ±‚ä½ å†™ä¸ªç¨‹åºå¸®åŠ©è¿™æ‰€å­¦æ ¡çš„è€å¸ˆæ£€æŸ¥æ‰€æœ‰å­¦ç”Ÿçš„ç‰©å“ï¼Œä»¥åŠ©å…¶æˆå¤§å™¨ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸¤ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤ 1000ï¼‰å’Œ Mï¼ˆâ‰¤ 6ï¼‰ï¼Œåˆ†åˆ«æ˜¯å­¦ç”Ÿäººæ•°å’Œéœ€è¦è¢«æŸ¥ç¼´çš„ç‰©å“ç§ç±»æ•°ã€‚ç¬¬äºŒè¡Œç»™å‡º M ä¸ªéœ€è¦è¢«æŸ¥ç¼´çš„ç‰©å“ç¼–å·ï¼Œå…¶ä¸­ç¼–å·ä¸º 4 ä½æ•°å­—ã€‚éšå N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä½å­¦ç”Ÿçš„å§“åç¼©å†™ï¼ˆç”± 1-4 ä¸ªå¤§å†™è‹±æ–‡å­—æ¯ç»„æˆï¼‰ã€ä¸ªäººç‰©å“æ•°é‡ Kï¼ˆ0 â‰¤ K â‰¤ 10ï¼‰ã€ä»¥åŠ K ä¸ªç‰©å“çš„ç¼–å·ã€‚ è¾“å‡ºæ ¼å¼ï¼š é¡ºæ¬¡æ£€æŸ¥æ¯ä¸ªå­¦ç”Ÿæºå¸¦çš„ç‰©å“ï¼Œå¦‚æœæœ‰éœ€è¦è¢«æŸ¥ç¼´çš„ç‰©å“å­˜åœ¨ï¼Œåˆ™æŒ‰ä»¥ä¸‹æ ¼å¼è¾“å‡ºè¯¥ç”Ÿçš„ä¿¡æ¯å’Œå…¶éœ€è¦è¢«æŸ¥ç¼´çš„ç‰©å“çš„ä¿¡æ¯ï¼ˆæ³¨æ„è¡Œæœ«ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ï¼‰ï¼š 1å§“åç¼©å†™: ç‰©å“ç¼–å·1 ç‰©å“ç¼–å·2 â€¦â€¦ æœ€åä¸€è¡Œè¾“å‡ºå­˜åœ¨é—®é¢˜çš„å­¦ç”Ÿçš„æ€»äººæ•°å’Œè¢«æŸ¥ç¼´ç‰©å“çš„æ€»æ•°ã€‚ è¾“å…¥æ ·ä¾‹ï¼š1234564 22333 6666CYLL 3 1234 2345 3456U 4 9966 6666 8888 6666GG 2 2333 7777JJ 3 0012 6666 2333 è¾“å‡ºæ ·ä¾‹ï¼š1234U: 6666 6666GG: 2333JJ: 6666 23333 5 é€šè¿‡ä»£ç 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int main () { int n, m, stu = 0, item = 0; cin &gt;&gt; n &gt;&gt; m; string ob[n]; for (int i = 0; i &lt; m; i++) cin &gt;&gt; ob[i]; for (int i = 0; i &lt; n; i++) { string name, object; int num, count = 0; cin &gt;&gt; name &gt;&gt; num; for (int j = 0; j &lt; num; j++) { cin &gt;&gt; object; for (int k = 0; k &lt; m; k++) { if (object == ob[k]) { if (count++ == 0) cout &lt;&lt; name &lt;&lt; &quot;:&quot;; cout &lt;&lt; &quot; &quot; &lt;&lt; object; break; } } } item += count; stu += count &gt; 0 ? 1 : 0; if (count) cout &lt;&lt; endl; } cout &lt;&lt; stu &lt;&lt; &quot; &quot; &lt;&lt; item &lt;&lt; endl; return 0;}","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1072-%E5%BC%80%E5%AD%A6%E5%AF%84%E8%AF%AD(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1073","text":"é¢˜ç›® æ‰¹æ”¹å¤šé€‰é¢˜æ˜¯æ¯”è¾ƒéº»çƒ¦çš„äº‹æƒ…ï¼Œæœ‰å¾ˆå¤šä¸åŒçš„è®¡åˆ†æ–¹æ³•ã€‚æœ‰ä¸€ç§æœ€å¸¸è§çš„è®¡åˆ†æ–¹æ³•æ˜¯ï¼šå¦‚æœè€ƒç”Ÿé€‰æ‹©äº†éƒ¨åˆ†æ­£ç¡®é€‰é¡¹ï¼Œå¹¶ä¸”æ²¡æœ‰é€‰æ‹©ä»»ä½•é”™è¯¯é€‰é¡¹ï¼Œåˆ™å¾—åˆ° 50% åˆ†æ•°ï¼›å¦‚æœè€ƒç”Ÿé€‰æ‹©äº†ä»»ä½•ä¸€ä¸ªé”™è¯¯çš„é€‰é¡¹ï¼Œåˆ™ä¸èƒ½å¾—åˆ†ã€‚æœ¬é¢˜å°±è¯·ä½ å†™ä¸ªç¨‹åºå¸®åŠ©è€å¸ˆæ‰¹æ”¹å¤šé€‰é¢˜ï¼Œå¹¶ä¸”æŒ‡å‡ºå“ªé“é¢˜çš„å“ªä¸ªé€‰é¡¹é”™çš„äººæœ€å¤šã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥åœ¨ç¬¬ä¸€è¡Œç»™å‡ºä¸¤ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤1000ï¼‰å’Œ Mï¼ˆâ‰¤100ï¼‰ï¼Œåˆ†åˆ«æ˜¯å­¦ç”Ÿäººæ•°å’Œå¤šé€‰é¢˜çš„ä¸ªæ•°ã€‚éšå M è¡Œï¼Œæ¯è¡Œé¡ºæ¬¡ç»™å‡ºä¸€é“é¢˜çš„æ»¡åˆ†å€¼ï¼ˆä¸è¶…è¿‡ 5 çš„æ­£æ•´æ•°ï¼‰ã€é€‰é¡¹ä¸ªæ•°ï¼ˆä¸å°‘äº 2 ä¸”ä¸è¶…è¿‡ 5 çš„æ­£æ•´æ•°ï¼‰ã€æ­£ç¡®é€‰é¡¹ä¸ªæ•°ï¼ˆä¸è¶…è¿‡é€‰é¡¹ä¸ªæ•°çš„æ­£æ•´æ•°ï¼‰ã€æ‰€æœ‰æ­£ç¡®é€‰é¡¹ã€‚æ³¨æ„æ¯é¢˜çš„é€‰é¡¹ä»å°å†™è‹±æ–‡å­—æ¯ a å¼€å§‹é¡ºæ¬¡æ’åˆ—ã€‚å„é¡¹é—´ä»¥ 1 ä¸ªç©ºæ ¼åˆ†éš”ã€‚æœ€å N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä¸ªå­¦ç”Ÿçš„ç­”é¢˜æƒ…å†µï¼Œå…¶æ¯é¢˜ç­”æ¡ˆæ ¼å¼ä¸º (é€‰ä¸­çš„é€‰é¡¹ä¸ªæ•° é€‰é¡¹1 â€¦â€¦)ï¼ŒæŒ‰é¢˜ç›®é¡ºåºç»™å‡ºã€‚æ³¨æ„ï¼šé¢˜ç›®ä¿è¯å­¦ç”Ÿçš„ç­”é¢˜æƒ…å†µæ˜¯åˆæ³•çš„ï¼Œå³ä¸å­˜åœ¨é€‰ä¸­çš„é€‰é¡¹æ•°è¶…è¿‡å®é™…é€‰é¡¹æ•°çš„æƒ…å†µã€‚ è¾“å‡ºæ ¼å¼ï¼š æŒ‰ç…§è¾“å…¥çš„é¡ºåºç»™å‡ºæ¯ä¸ªå­¦ç”Ÿçš„å¾—åˆ†ï¼Œæ¯ä¸ªåˆ†æ•°å ä¸€è¡Œï¼Œè¾“å‡ºå°æ•°ç‚¹å 1 ä½ã€‚æœ€åè¾“å‡ºé”™å¾—æœ€å¤šçš„é¢˜ç›®é€‰é¡¹çš„ä¿¡æ¯ï¼Œæ ¼å¼ä¸ºï¼šé”™è¯¯æ¬¡æ•° é¢˜ç›®ç¼–å·ï¼ˆé¢˜ç›®æŒ‰ç…§è¾“å…¥çš„é¡ºåºä»1å¼€å§‹ç¼–å·ï¼‰-é€‰é¡¹å·ã€‚å¦‚æœæœ‰å¹¶åˆ—ï¼Œåˆ™æ¯è¡Œä¸€ä¸ªé€‰é¡¹ï¼ŒæŒ‰é¢˜ç›®ç¼–å·é€’å¢é¡ºåºè¾“å‡ºï¼›å†å¹¶åˆ—åˆ™æŒ‰é€‰é¡¹å·é€’å¢é¡ºåºè¾“å‡ºã€‚è¡Œé¦–å°¾ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚å¦‚æœæ‰€æœ‰é¢˜ç›®éƒ½æ²¡æœ‰äººé”™ï¼Œåˆ™åœ¨æœ€åä¸€è¡Œè¾“å‡º Too simpleã€‚ è¾“å…¥æ ·ä¾‹ 1ï¼š123456783 4 3 4 2 a c2 5 1 b5 3 2 b c1 5 4 a b d e(2 a c) (3 b d e) (2 a c) (3 a b e)(2 a c) (1 b) (2 a b) (4 a b d e)(2 b d) (1 e) (1 c) (4 a b c d) è¾“å‡ºæ ·ä¾‹ 1ï¼š1234563.56.02.52 2-e2 3-a2 3-b è¾“å…¥æ ·ä¾‹ 2ï¼š123452 2 3 4 2 a c2 5 1 b(2 a c) (1 b)(2 a c) (1 b) è¾“å‡ºæ ·ä¾‹ 2ï¼š1235.05.0Too simple é€šè¿‡ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;using namespace std;class Option {//ç”¨äºç»Ÿè®¡æ­£ç¡®é€‰é¡¹çš„ä¿¡æ¯public: double score = 0;int optionNum = 0, corOptionNum = 0, num = 0, maxFalseNum = -1, FalseNum[6] = {0}; //æ­£ç¡®é€‰é¡¹çš„åˆ†æ•°,é€‰é¡¹ä¸ªæ•°,æ­£ç¡®é€‰é¡¹çš„ä¸ªæ•°,é¢˜ç›®çš„ç¼–å·ï¼Œä»1å¼€å§‹,é”™è¯¯æ¬¡æ•°çš„æœ€å¤§å€¼,æ¯ä¸€ä¸ªé€‰é¡¹çš„é”™è¯¯æ¬¡æ•° vector&lt;char&gt; correctOption, FalseMostOp;//è®°å½•æ­£ç¡®é€‰é¡¹,è®°å½•é”™è¯¯æ¬¡æ•°æœ€å¤šçš„é€‰é¡¹ int check(vector&lt;char&gt; select) { //0é”™ï¼Œ1å¯¹ï¼Œ2åŠå¯¹ bool want1 = false, want2 = false; for (int i = 0; i &lt; select.size(); i++) {//ç¬¬ä¸€æ¬¡æŸ¥æ‰¾ï¼Œæœ‰æ²¡æœ‰å¤šé€‰çš„ bool found = false; for (int j = 0; j &lt; correctOption.size(); j++) { if (correctOption[j] == select[i]) { found = true; break; } } if (!found) { //å­¦ç”Ÿé€‰äº†ï¼Œä¸æ˜¯æ­£ç¡®é€‰é¡¹ want1 = true; FalseNum[select[i]-'a']++; } } for (int i = 0; i &lt; correctOption.size(); i++) {//ç¬¬äºŒæ¬¡æŸ¥æ‰¾ï¼Œæœ‰æ²¡æœ‰æ¼é€‰çš„ bool found = false; for (int j = 0; j &lt; select.size(); j++) { if (correctOption[i] == select[j]) { found = true; break; } } if (!found) { //æœ¬èº«æ˜¯æ­£ç¡®é€‰é¡¹ï¼Œå­¦ç”Ÿæ²¡é€‰ want2 = true; FalseNum[correctOption[i]-'a']++; } } if (want1) return 0;//å­¦ç”Ÿçš„é€‰æ‹©æœ‰æ­£ç¡®é€‰æ‹©ä¸­æ²¡æœ‰çš„ï¼Œé”™ï¼ //å­¦ç”Ÿçš„é€‰æ‹©æ˜¯æ­£ç¡®é€‰é¡¹çš„å­é›† if (want2) return 2;//å­¦ç”Ÿçš„é€‰æ‹©æ­£ç¡®é€‰é¡¹éƒ½æœ‰ï¼Œä½†æ˜¯æ­£ç¡®é€‰é¡¹ä¸­æœ‰å­¦ç”Ÿæ²¡é€‰çš„ï¼ŒåŠå¯¹ï¼ //æ­£ç¡®é€‰é¡¹æ˜¯å­¦ç”Ÿé€‰æ‹©çš„å­é›† return 1;//ä¸¤ä¸ªäº’ä¸ºå­é›†ï¼Œåˆ™é€‰æ‹©ç›¸åŒï¼Œå¯¹ï¼ } friend istream &amp;operator&gt;&gt;(istream &amp;file, Option &amp;object); void caculate () {//è®¡ç®—é”™è¯¯æ¬¡æ•°çš„æœ€å¤§å€¼ï¼Œå¹¶è®°å½•é”™çš„å¤šçš„é€‰é¡¹ maxFalseNum = FalseNum[0]; for (int i = 0; i &lt; optionNum; i++) if (FalseNum[i] &gt; maxFalseNum) maxFalseNum = FalseNum[i]; for (int i = 0; i &lt; optionNum; i++) if (FalseNum[i] == maxFalseNum) FalseMostOp.push_back(i + 'a'); } int getAllFalseNum() { return maxFalseNum; }};istream &amp;operator&gt;&gt;(istream &amp;file, Option &amp;object) {//æ­£ç¡®é€‰é¡¹ä¿¡æ¯ file &gt;&gt; object.score &gt;&gt; object.optionNum &gt;&gt; object.corOptionNum; for (int i = 0; i &lt; object.corOptionNum; i++) { file.ignore(); char temp; file &gt;&gt; temp; object.correctOption.push_back(temp); } return file;}class choose {//è®°å½•æŸä¸ªé¢˜å­¦ç”Ÿçš„é€‰æ‹©ä¿¡æ¯public: int num = 0; vector&lt;char&gt; option; friend istream &amp;operator&gt;&gt;(istream &amp;file, choose &amp;object); void clear() { option.clear(); num = 0; }};istream &amp;operator&gt;&gt;(istream &amp;file, choose &amp;object) {//è¾“å…¥å­¦ç”Ÿçš„é€‰æ‹© char x; cin &gt;&gt; x; file &gt;&gt; object.num; for (int i = 0; i &lt; object.num; i++) { file.ignore(); char temp; file &gt;&gt; temp; object.option.push_back(temp); } file.ignore(); return file;}struct Stu { vector&lt;choose&gt; cho; double score = 0; };//è®°å½•å­¦ç”Ÿé€‰æ‹©å’Œå¾—åˆ†int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; Stu student[n]; Option op[m]; choose choTemp;//ç”¨äºæš‚æ—¶å‚¨å­˜è¾“å…¥ï¼Œç”±äºç”¨äº†vectorï¼Œæ¯æ¬¡è¦clear() for (int i = 0; i &lt; m; i++) { cin &gt;&gt; op[i]; op[i].num = i + 1; } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { choTemp.clear(); cin &gt;&gt; choTemp; cin.ignore(); student[i].cho.push_back(choTemp); }//ä¸€ä¸ªå­¦ç”Ÿçš„é€‰æ‹©è¾“å…¥å®Œæˆ for (int j = 0; j &lt; m; j++) {//å¯¹åˆšåˆšè¾“å…¥çš„è¿™ä¸ªå­¦ç”Ÿè¿›è¡Œåˆ¤åˆ† int n = op[j].check(student[i].cho[j].option); if (n == 1) student[i].score += op[j].score; else if (n == 2) student[i].score += op[j].score*0.5; } } for (int i = 0; i &lt; n; i++)//è¾“å‡ºåˆ†æ•° cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; student[i].score &lt;&lt; endl; for (int i = 0; i &lt; m; i++)//è®¡ç®—é”™çš„æœ€å¤šçš„é€‰é¡¹ op[i].caculate(); int max = 0; for (int i = 0; i &lt; m; i++)//æŸ¥æ‰¾æœ€å¤§å€¼ if (max &lt; op[i].getAllFalseNum()) max = op[i].getAllFalseNum(); if (max &gt; 0) {//è¾“å‡º for (int i = 0; i &lt; m; i++) if (op[i].getAllFalseNum() == max) for (int j = 0; j &lt; op[i].FalseMostOp.size(); j++) cout &lt;&lt; max &lt;&lt; ' ' &lt;&lt; op[i].num &lt;&lt; '-' &lt;&lt; op[i].FalseMostOp[j] &lt;&lt; endl; } else { cout &lt;&lt; &quot;Too simple&quot; &lt;&lt; endl; } return 0;} æ€è·¯ä¸æ³¨æ„ è¿™é“é¢˜æ˜¯é¢˜ç›®ï¼šPATä¹™çº§é¢˜â€“1058 é€‰æ‹©é¢˜ï¼Œçš„å‡çº§ç‰ˆï¼Œå…¶ä¸­è¾“å…¥ä¸€æ ·ï¼Œåªæ˜¯ç»™åˆ†æ–¹å¼å˜æˆäº†ï¼šå…¨å¯¹ç»™å…¨åˆ†ï¼Œéƒ¨åˆ†å¯¹ç»™ä¸€åŠåˆ†ï¼Œæœ‰é”™ä¸å¾—åˆ† åˆ¤åˆ†æ–¹å¼ åˆ¤åˆ†æ€æƒ³ï¼šaæ˜¯bçš„å­é›†ï¼Œä¸”bæ˜¯açš„å­é›†ï¼Œé‚£ä¹ˆaï¼Œbä¸¤ä¸ªé›†åˆç›¸ç­‰ å®šä¹‰ä¸€ä¸ªåˆ¤åˆ†å‡½æ•°ï¼Œå±äºOptionç±»ï¼Œå…¨å¯¹è¿”å›1ï¼Œæœ‰é”™è¿”å›0ï¼ŒåŠå¯¹è¿”å›2ã€‚ ä¸¤æ¬¡éå†æŸ¥æ‰¾ï¼Œç¬¬ä¸€éæŸ¥æ‰¾å­¦ç”Ÿçš„é€‰æ‹©ä¸­æœ‰æ²¡æœ‰ä¸æ˜¯æ­£ç¡®é€‰é¡¹çš„ï¼Œå¦‚æœæœ‰ï¼Œè®°å½•è¿™ä¸ªé€‰é¡¹é”™äº†ä¸€æ¬¡ã€‚ç¬¬äºŒæ¬¡æŸ¥æ‰¾æ­£ç¡®é€‰é¡¹ä¸­æ˜¯å¦å­˜åœ¨å­¦ç”Ÿæ²¡æœ‰é€‰çš„ï¼Œå¦‚æœæœ‰è®°å½•è¿™ä¸ªé€‰é¡¹é”™äº†ä¸€æ¬¡ ç¬¬ä¸€æ¬¡æŸ¥æ‰¾å°±æœ‰é”™ï¼Œè¿”å›0ã€‚ï¼ˆå¦‚æœæ²¡é”™ï¼Œè¯´æ˜ï¼šå­¦ç”Ÿçš„é€‰æ‹©æ˜¯æ­£ç¡®é€‰é¡¹çš„å­é›†ï¼‰ å¦‚æœç¬¬äºŒæ¬¡æŸ¥æ‰¾æœ‰é”™è€Œç¬¬ä¸€æ¬¡æ²¡æœ‰ï¼Œè¯´æ˜å­¦ç”Ÿæ²¡é€‰å…¨ï¼Œè¿”å›2ã€‚ï¼ˆå¦‚æœæ²¡é”™ï¼Œè¯´æ˜ï¼šæ­£ç¡®é€‰é¡¹æ˜¯å­¦ç”Ÿçš„å­é›†ï¼‰ å¦‚æœä¸¤æ¬¡éå†éƒ½æ²¡é”™ï¼Œè¯´æ˜å­¦ç”Ÿé€‰æ‹©å°±æ˜¯æ­£ç¡®ç­”æ¡ˆï¼Œè¿”å›1ã€‚ï¼ˆè¯´æ˜ï¼šä¸¤ä¸ªé›†åˆäº’ä¸ºå­é›†ï¼Œä¸¤ä¸ªé›†åˆç›¸ç­‰ï¼‰ ç»Ÿè®¡é”™è¯¯é€‰é¡¹ å®šä¹‰äº†ä¸€ä¸ªcalculate()å‡½æ•°ï¼Œç”¨äºç»Ÿè®¡é‚£ä¸ªé¢˜é”™çš„æœ€å¤šï¼Œæœ€å¤šçš„é€‰é¡¹æœ‰å“ªäº› åœ¨æ‰€æœ‰å­¦ç”Ÿçš„é¢˜åˆ¤å®Œä»¥åï¼Œæ‰€æœ‰é€‰é¡¹çš„é”™è¯¯æ¬¡æ•°ä¹Ÿå°±ç»Ÿè®¡å®Œæ•´äº†ï¼Œè¿™æ—¶è°ƒç”¨è®¡ç®—ä¸€ä¸‹ æ³¨æ„ ä¸èƒ½ä¸€è¾¹æ‰¾æœ€å¤§å€¼ä¸€è¾¹è®¡ç®—ï¼Œæˆ‘ä¹Ÿä¸çŸ¥é“ä¸ºå•¥ï¼Œä¸€å®šè¦å…ˆè®¡ç®—ä¸€è¾¹é”™è¯¯æœ€å¤šçš„é€‰é¡¹ï¼Œå†æ‰¾æœ€å¤§å€¼ã€‚ åæ€ä¸è¯„ä»· è¿™é“é¢˜å…¶å®ä¸ç”¨å†™è¿™ä¹ˆå¤šç±»ï¼Œè¿ç®—ç¬¦é‡è½½ï¼Œæ„é€ å‡½æ•°ä»€ä¹ˆçš„ï¼Œä»£ç å¯ä»¥æ›´åŠ ç²¾ç®€ã€‚ä½†æ˜¯è¿™æ ·å†™çš„å¥½å¤„æœ‰ï¼š æ•°æ®å¤„ç†æ–¹ä¾¿ï¼Œä¸ä¼šå¯¼è‡´mainå‡½æ•°é‡Œé¢å®šä¹‰è¿‡å¤šå˜é‡å¯¼è‡´ä»£ç å¯è¯»æ€§å˜å·®ã€‚ mainå‡½æ•°æ›´åŠ ç®€æ´ï¼Œå¯ä»¥æŠŠæ€è·¯æ”¾åœ¨é€»è¾‘ç®—æ³•ä¸Šè€Œä¸æ˜¯æ•°æ®çš„å¤„ç†ä¸Šï¼Œå°±åƒæˆ‘ä»¬ä½¿ç”¨vectorï¼Œsetï¼Œmapç­‰æ¨¡æ¿æ—¶ï¼Œå¹¶ä¸éœ€è¦çŸ¥é“å…¶å†…éƒ¨å¦‚ä½•å®ç°ï¼Œä½¿å¾—ç¼–ç æ•ˆç‡æé«˜ã€‚ è¿™é“é¢˜å¾ˆåŠªåŠ›çš„åœ¨å‹è¡Œï¼Œå¦‚æœç”¨Astyleé£æ ¼formatä¸€ä¸‹çš„è¯èƒ½æœ‰200è¡Œ","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1073-%E5%A4%9A%E9%80%89%E9%A2%98%E5%B8%B8%E8%A7%81%E8%AE%A1%E5%88%86%E6%B3%95(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1071","text":"é¢˜ç›® å¸¸è¨€é“â€œå°èµŒæ€¡æƒ…â€ã€‚è¿™æ˜¯ä¸€ä¸ªå¾ˆç®€å•çš„å°æ¸¸æˆï¼šé¦–å…ˆç”±è®¡ç®—æœºç»™å‡ºç¬¬ä¸€ä¸ªæ•´æ•°ï¼›ç„¶åç©å®¶ä¸‹æ³¨èµŒç¬¬äºŒä¸ªæ•´æ•°å°†ä¼šæ¯”ç¬¬ä¸€ä¸ªæ•°å¤§è¿˜æ˜¯å°ï¼›ç©å®¶ä¸‹æ³¨ t ä¸ªç­¹ç åï¼Œè®¡ç®—æœºç»™å‡ºç¬¬äºŒä¸ªæ•°ã€‚è‹¥ç©å®¶çŒœå¯¹äº†ï¼Œåˆ™ç³»ç»Ÿå¥–åŠ±ç©å®¶ t ä¸ªç­¹ç ï¼›å¦åˆ™æ‰£é™¤ç©å®¶ t ä¸ªç­¹ç ã€‚ æ³¨æ„ï¼šç©å®¶ä¸‹æ³¨çš„ç­¹ç æ•°ä¸èƒ½è¶…è¿‡è‡ªå·±å¸æˆ·ä¸Šæ‹¥æœ‰çš„ç­¹ç æ•°ã€‚å½“ç©å®¶è¾“å…‰äº†å…¨éƒ¨ç­¹ç åï¼Œæ¸¸æˆå°±ç»“æŸã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥åœ¨ç¬¬ä¸€è¡Œç»™å‡º 2 ä¸ªæ­£æ•´æ•° T å’Œ Kï¼ˆâ‰¤ 100ï¼‰ï¼Œåˆ†åˆ«æ˜¯ç³»ç»Ÿåœ¨åˆå§‹çŠ¶æ€ä¸‹èµ é€ç»™ç©å®¶çš„ç­¹ç æ•°ã€ä»¥åŠéœ€è¦å¤„ç†çš„æ¸¸æˆæ¬¡æ•°ã€‚éšå K è¡Œï¼Œæ¯è¡Œå¯¹åº”ä¸€æ¬¡æ¸¸æˆï¼Œé¡ºåºç»™å‡º 4 ä¸ªæ•°å­—ï¼š 1n1 b t n2 å…¶ä¸­ n1 å’Œ n2 æ˜¯è®¡ç®—æœºå…ˆåç»™å‡ºçš„ä¸¤ä¸ª[0, 9]å†…çš„æ•´æ•°ï¼Œä¿è¯ä¸¤ä¸ªæ•°å­—ä¸ç›¸ç­‰ã€‚b ä¸º 0 è¡¨ç¤ºç©å®¶èµŒå°ï¼Œä¸º 1 è¡¨ç¤ºç©å®¶èµŒå¤§ã€‚t è¡¨ç¤ºç©å®¶ä¸‹æ³¨çš„ç­¹ç æ•°ï¼Œä¿è¯åœ¨æ•´å‹èŒƒå›´å†…ã€‚ è¾“å‡ºæ ¼å¼ï¼š å¯¹æ¯ä¸€æ¬¡æ¸¸æˆï¼Œæ ¹æ®ä¸‹åˆ—æƒ…å†µå¯¹åº”è¾“å‡ºï¼ˆå…¶ä¸­ t æ˜¯ç©å®¶ä¸‹æ³¨é‡ï¼Œx æ˜¯ç©å®¶å½“å‰æŒæœ‰çš„ç­¹ç é‡ï¼‰ï¼š ç©å®¶èµ¢ï¼Œè¾“å‡º Win t! Total = x.ï¼› ç©å®¶è¾“ï¼Œè¾“å‡º Lose t. Total = x.ï¼› ç©å®¶ä¸‹æ³¨è¶…è¿‡æŒæœ‰çš„ç­¹ç é‡ï¼Œè¾“å‡º Not enough tokens. Total = x.ï¼› ç©å®¶è¾“å…‰åï¼Œè¾“å‡º Game Over. å¹¶ç»“æŸç¨‹åºã€‚ è¾“å…¥æ ·ä¾‹ 1ï¼š12345100 48 0 100 23 1 50 15 1 200 67 0 200 8 è¾“å‡ºæ ·ä¾‹ 1ï¼š1234Win 100! Total = 200.Lose 50. Total = 150.Not enough tokens. Total = 150.Not enough tokens. Total = 150. è¾“å…¥æ ·ä¾‹ 2ï¼š12345100 48 0 100 23 1 200 15 1 200 67 0 200 8 è¾“å‡ºæ ·ä¾‹ 2ï¼š123Win 100! Total = 200.Lose 200. Total = 0.Game Over. é€šè¿‡ä»£ç 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main () { int T, K; cin &gt;&gt; T &gt;&gt; K; for (int i = 0; i &lt; K; i++) { int n1, b, t, n2; cin &gt;&gt; n1 &gt;&gt; b &gt;&gt; t &gt;&gt; n2; if (T &amp;&amp; t &lt;= T) { if ((n2 &gt; n1) == b) { T += t; cout &lt;&lt; &quot;Win &quot; &lt;&lt; t &lt;&lt; &quot;! Total = &quot; &lt;&lt; T &lt;&lt; &quot;.&quot; &lt;&lt; endl; } else { T -= t; cout &lt;&lt; &quot;Lose &quot; &lt;&lt; t &lt;&lt; &quot;. Total = &quot; &lt;&lt; T &lt;&lt; &quot;.&quot; &lt;&lt; endl; } } else if (T &amp;&amp; t &gt; T) { cout &lt;&lt; &quot;Not enough tokens. Total = &quot; &lt;&lt; T &lt;&lt; &quot;.&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;Game Over.&quot; &lt;&lt; endl; break; } } return 0;} æ€è·¯ä¸æ³¨æ„ è¿™é“é¢˜åˆå‘äººäº†ï¼Œè¾“å‡ºçš„æ—¶å€™è¦ä»¥è¾“å‡ºæ ·ä¾‹ä¸ºå‡†ï¼ŒTotalä¸å‰é¢çš„ ! æˆ– . ç›´æ¥æœ‰ä¸¤ä¸ªç©ºæ ¼ï¼Œé¢˜å¹²ä¸Šåªæœ‰ä¸€ä¸ªã€‚","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1071-%E5%B0%8F%E8%B5%8C%E6%80%A1%E6%83%85(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1074","text":"é¢˜ç›® åœ°çƒäººä¹ æƒ¯ä½¿ç”¨åè¿›åˆ¶æ•°ï¼Œå¹¶ä¸”é»˜è®¤ä¸€ä¸ªæ•°å­—çš„æ¯ä¸€ä½éƒ½æ˜¯åè¿›åˆ¶çš„ã€‚è€Œåœ¨ PAT æ˜Ÿäººå¼€æŒ‚çš„ä¸–ç•Œé‡Œï¼Œæ¯ä¸ªæ•°å­—çš„æ¯ä¸€ä½éƒ½æ˜¯ä¸åŒè¿›åˆ¶çš„ï¼Œè¿™ç§ç¥å¥‡çš„æ•°å­—ç§°ä¸ºâ€œPATæ•°â€ã€‚æ¯ä¸ª PAT æ˜Ÿäººéƒ½å¿…é¡»ç†Ÿè®°å„ä½æ•°å­—çš„è¿›åˆ¶è¡¨ï¼Œä¾‹å¦‚â€œâ€¦â€¦0527â€å°±è¡¨ç¤ºæœ€ä½ä½æ˜¯ 7 è¿›åˆ¶æ•°ã€ç¬¬ 2 ä½æ˜¯ 2 è¿›åˆ¶æ•°ã€ç¬¬ 3 ä½æ˜¯ 5 è¿›åˆ¶æ•°ã€ç¬¬ 4 ä½æ˜¯ 10 è¿›åˆ¶æ•°ï¼Œç­‰ç­‰ã€‚æ¯ä¸€ä½çš„è¿›åˆ¶ d æˆ–è€…æ˜¯ 0ï¼ˆè¡¨ç¤ºåè¿›åˆ¶ï¼‰ã€æˆ–è€…æ˜¯ [2ï¼Œ9] åŒºé—´å†…çš„æ•´æ•°ã€‚ç†è®ºä¸Šè¿™ä¸ªè¿›åˆ¶è¡¨åº”è¯¥åŒ…å«æ— ç©·å¤šä½æ•°å­—ï¼Œä½†ä»å®é™…åº”ç”¨å‡ºå‘ï¼ŒPAT æ˜Ÿäººé€šå¸¸åªéœ€è¦è®°ä½å‰ 20 ä½å°±å¤Ÿç”¨äº†ï¼Œä»¥åå„ä½é»˜è®¤ä¸º 10 è¿›åˆ¶ã€‚ åœ¨è¿™æ ·çš„æ•°å­—ç³»ç»Ÿä¸­ï¼Œå³ä½¿æ˜¯ç®€å•çš„åŠ æ³•è¿ç®—ä¹Ÿå˜å¾—ä¸ç®€å•ã€‚ä¾‹å¦‚å¯¹åº”è¿›åˆ¶è¡¨â€œ0527â€ï¼Œè¯¥å¦‚ä½•è®¡ç®—â€œ6203 + 415â€å‘¢ï¼Ÿæˆ‘ä»¬å¾—é¦–å…ˆè®¡ç®—æœ€ä½ä½ï¼š3 + 5 = 8ï¼›å› ä¸ºæœ€ä½ä½æ˜¯ 7 è¿›åˆ¶çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¾—åˆ° 1 å’Œ 1 ä¸ªè¿›ä½ã€‚ç¬¬ 2 ä½æ˜¯ï¼š0 + 1 + 1ï¼ˆè¿›ä½ï¼‰= 2ï¼›å› ä¸ºæ­¤ä½æ˜¯ 2 è¿›åˆ¶çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¾—åˆ° 0 å’Œ 1 ä¸ªè¿›ä½ã€‚ç¬¬ 3 ä½æ˜¯ï¼š2 + 4 + 1ï¼ˆè¿›ä½ï¼‰= 7ï¼›å› ä¸ºæ­¤ä½æ˜¯ 5 è¿›åˆ¶çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¾—åˆ° 2 å’Œ 1 ä¸ªè¿›ä½ã€‚ç¬¬ 4 ä½æ˜¯ï¼š6 + 1ï¼ˆè¿›ä½ï¼‰= 7ï¼›å› ä¸ºæ­¤ä½æ˜¯ 10 è¿›åˆ¶çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å°±å¾—åˆ° 7ã€‚æœ€åæˆ‘ä»¬å¾—åˆ°ï¼š6203 + 415 = 7201ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥é¦–å…ˆåœ¨ç¬¬ä¸€è¡Œç»™å‡ºä¸€ä¸ª N ä½çš„è¿›åˆ¶è¡¨ï¼ˆ0 &lt; N â‰¤ 20ï¼‰ï¼Œä»¥å›è½¦ç»“æŸã€‚ éšåä¸¤è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä¸ªä¸è¶…è¿‡ N ä½çš„éè´Ÿçš„ PAT æ•°ã€‚ è¾“å‡ºæ ¼å¼ï¼š åœ¨ä¸€è¡Œä¸­è¾“å‡ºä¸¤ä¸ª PAT æ•°ä¹‹å’Œã€‚ è¾“å…¥æ ·ä¾‹ï¼š1233052706203415 è¾“å‡ºæ ·ä¾‹ï¼š17201 é€šè¿‡ä»£ç 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main () { string a, b, n, ans; getline(cin, n); getline(cin, a); getline(cin, b); int len = a.length() &gt; b.length() ? a.length() : b.length(); len = len &gt; n.length() ? len : n.length(); a.insert(0, (len - a.length() &gt; 0 ? len - a.length() : 0), '0'); b.insert(0, (len - b.length() &gt; 0 ? len - b.length() : 0), '0'); n.insert(0, (len - n.length() &gt; 0 ? len - n.length() : 0), '0'); int carry = 0; for (int i = len - 1, count = 0; i &gt;= 0; i--, count++) { int c = (a[i] + b[i] - '0' * 2) + carry; carry = c / ((n[i] - '0') == 0 ? 10 : (n[i] - '0')); c %= ((n[i] - '0') == 0 ? 10 : (n[i] - '0')); ans.insert(0, 1, c + '0'); } ans.insert(0, 1, carry + '0'); int i = 0; bool zero = true; while (ans[i] == '0' || ans[i] == 0)i++; for (; i &lt; ans.length(); i++) { cout &lt;&lt; ans[i]; zero = false; } if (zero) cout &lt;&lt; &quot;0&quot; &lt;&lt; endl; return 0;} æ³¨æ„ æ³¨æ„è®¡ç®—ç»“æœä¸º0 æ³¨æ„è®¡ç®—ç»“æœå¯èƒ½å¤§äºè¾“å…¥çš„æœ€å¤§é•¿åº¦","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1074-%E5%AE%87%E5%AE%99%E6%97%A0%E6%95%8C%E5%8A%A0%E6%B3%95%E5%99%A8(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1069","text":"é¢˜ç›® å°æ˜ PAT è€ƒäº†æ»¡åˆ†ï¼Œé«˜å…´ä¹‹ä½™å†³å®šå‘èµ·å¾®åšè½¬å‘æŠ½å¥–æ´»åŠ¨ï¼Œä»è½¬å‘çš„ç½‘å‹ä¸­æŒ‰é¡ºåºæ¯éš” N ä¸ªäººå°±å‘å‡ºä¸€ä¸ªçº¢åŒ…ã€‚è¯·ä½ ç¼–å†™ç¨‹åºå¸®åŠ©ä»–ç¡®å®šä¸­å¥–åå•ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸‰ä¸ªæ­£æ•´æ•° Mï¼ˆâ‰¤ 1000ï¼‰ã€N å’Œ Sï¼Œåˆ†åˆ«æ˜¯è½¬å‘çš„æ€»é‡ã€å°æ˜å†³å®šçš„ä¸­å¥–é—´éš”ã€ä»¥åŠç¬¬ä¸€ä½ä¸­å¥–è€…çš„åºå·ï¼ˆç¼–å·ä» 1 å¼€å§‹ï¼‰ã€‚éšå M è¡Œï¼Œé¡ºåºç»™å‡ºè½¬å‘å¾®åšçš„ç½‘å‹çš„æ˜µç§°ï¼ˆä¸è¶…è¿‡ 20 ä¸ªå­—ç¬¦ã€ä¸åŒ…å«ç©ºæ ¼å›è½¦çš„éç©ºå­—ç¬¦ä¸²ï¼‰ã€‚ æ³¨æ„ï¼šå¯èƒ½æœ‰äººè½¬å‘å¤šæ¬¡ï¼Œä½†ä¸èƒ½ä¸­å¥–å¤šæ¬¡ã€‚æ‰€ä»¥å¦‚æœå¤„äºå½“å‰ä¸­å¥–ä½ç½®çš„ç½‘å‹å·²ç»ä¸­è¿‡å¥–ï¼Œåˆ™è·³è¿‡ä»–é¡ºæ¬¡å–ä¸‹ä¸€ä½ã€‚ è¾“å‡ºæ ¼å¼ï¼š æŒ‰ç…§è¾“å…¥çš„é¡ºåºè¾“å‡ºä¸­å¥–åå•ï¼Œæ¯ä¸ªæ˜µç§°å ä¸€è¡Œã€‚å¦‚æœæ²¡æœ‰äººä¸­å¥–ï¼Œåˆ™è¾“å‡º Keep going...ã€‚ è¾“å…¥æ ·ä¾‹ 1ï¼š123456789109 3 2Imgonnawin!PickMePickMeMeMeeeLookHereImgonnawin!TryAgainAgainTryAgainAgainImgonnawin!TryAgainAgain è¾“å‡ºæ ·ä¾‹ 1ï¼š123PickMeImgonnawin!TryAgainAgain è¾“å…¥æ ·ä¾‹ 2ï¼š1232 3 5Imgonnawin!PickMe è¾“å‡ºæ ·ä¾‹ 2ï¼š1Keep going... é€šè¿‡ä»£ç 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;int main () { map&lt;string, int&gt; check; vector&lt;string&gt; v; bool out = false; int m, n, s; cin &gt;&gt; m &gt;&gt; n &gt;&gt; s; for (int i = 0; i &lt; m; i++) { string name; cin &gt;&gt; name; check[name] = 1; v.push_back(name); } for (int i = s - 1; i &lt; v.size(); i += n) { while (!check[v[i]]) i++; cout &lt;&lt; v[i] &lt;&lt; endl; out = true; check[v[i]] = 0; } if (!out) cout &lt;&lt; &quot;Keep going...&quot; &lt;&lt; endl; return 0;} åæ€ä¸è¯„ä»· stlç‰›é€¼","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1069-%E5%BE%AE%E5%8D%9A%E8%BD%AC%E5%8F%91%E6%8A%BD%E5%A5%96(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1075","text":"é¢˜ç›® ç»™å®šä¸€ä¸ªå•é“¾è¡¨ï¼Œè¯·ç¼–å†™ç¨‹åºå°†é“¾è¡¨å…ƒç´ è¿›è¡Œåˆ†ç±»æ’åˆ—ï¼Œä½¿å¾—æ‰€æœ‰è´Ÿå€¼å…ƒç´ éƒ½æ’åœ¨éè´Ÿå€¼å…ƒç´ çš„å‰é¢ï¼Œè€Œ [0, K] åŒºé—´å†…çš„å…ƒç´ éƒ½æ’åœ¨å¤§äº K çš„å…ƒç´ å‰é¢ã€‚ä½†æ¯ä¸€ç±»å†…éƒ¨å…ƒç´ çš„é¡ºåºæ˜¯ä¸èƒ½æ”¹å˜çš„ã€‚ä¾‹å¦‚ï¼šç»™å®šé“¾è¡¨ä¸º 18â†’7â†’-4â†’0â†’5â†’-6â†’10â†’11â†’-2ï¼ŒK ä¸º 10ï¼Œåˆ™è¾“å‡ºåº”è¯¥ä¸º -4â†’-6â†’-2â†’7â†’0â†’5â†’10â†’18â†’11ã€‚ è¾“å…¥æ ¼å¼ï¼š æ¯ä¸ªè¾“å…¥åŒ…å«ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹ã€‚æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ç¬¬ 1 è¡Œç»™å‡ºï¼šç¬¬ 1 ä¸ªç»“ç‚¹çš„åœ°å€ï¼›ç»“ç‚¹æ€»ä¸ªæ•°ï¼Œå³æ­£æ•´æ•°N (â‰¤105)ï¼›ä»¥åŠæ­£æ•´æ•°K (â‰¤103)ã€‚ç»“ç‚¹çš„åœ°å€æ˜¯ 5 ä½éè´Ÿæ•´æ•°ï¼ŒNULL åœ°å€ç”¨ âˆ’1 è¡¨ç¤ºã€‚ æ¥ä¸‹æ¥æœ‰ N è¡Œï¼Œæ¯è¡Œæ ¼å¼ä¸ºï¼š 1Address Data Next å…¶ä¸­ Address æ˜¯ç»“ç‚¹åœ°å€ï¼›Data æ˜¯è¯¥ç»“ç‚¹ä¿å­˜çš„æ•°æ®ï¼Œä¸º [âˆ’105,105] åŒºé—´å†…çš„æ•´æ•°ï¼›Next æ˜¯ä¸‹ä¸€ç»“ç‚¹çš„åœ°å€ã€‚é¢˜ç›®ä¿è¯ç»™å‡ºçš„é“¾è¡¨ä¸ä¸ºç©ºã€‚ è¾“å‡ºæ ¼å¼ï¼š å¯¹æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼ŒæŒ‰é“¾è¡¨ä»å¤´åˆ°å°¾çš„é¡ºåºè¾“å‡ºé‡æ’åçš„ç»“æœé“¾è¡¨ï¼Œå…¶ä¸Šæ¯ä¸ªç»“ç‚¹å ä¸€è¡Œï¼Œæ ¼å¼ä¸è¾“å…¥ç›¸åŒã€‚ è¾“å…¥æ ·ä¾‹ï¼š1234567891000100 9 1023333 10 2777700000 0 9999900100 18 1230968237 -6 2333333218 -4 0000048652 -2 -199999 5 6823727777 11 4865212309 7 33218 è¾“å‡ºæ ·ä¾‹ï¼š12345678933218 -4 6823768237 -6 4865248652 -2 1230912309 7 0000000000 0 9999999999 5 2333323333 10 0010000100 18 2777727777 11 -1 é€šè¿‡ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;using namespace std;struct node { int add; int next; int data;};int first, num, k;node v[100005];node x[100005];node a[100005], b[100005], c[100005];void print(node* m, int size) { for (int i = 0; i &lt; size - 1; i++) printf (&quot;%05d %d %05d\\n&quot;, m[i].add, m[i].data, m[i + 1].add); printf (&quot;%05d %d -1\\n&quot;, m[size - 1].add, m[size - 1].data);}int get() { scanf (&quot;%d%d%d&quot;, &amp;first, &amp;num, &amp;k); node temp; for (int i = 0; i &lt; num; i++) { scanf (&quot;%d%d%d&quot;, &amp;temp.add, &amp;temp.data, &amp;temp.next); v[temp.add] = temp; } int find = first; int c = 0; while (find != -1) { x[c++] = (v[find]); find = v[find].next; } return c;}int main () { int real = get(); int an = 0, bn = 0, cn = 0; for (int i = 0; i &lt; real; i++) { if (x[i].data &lt; 0) a[an++] = (x[i]); else if (x[i].data &gt; k) c[cn++] = (x[i]); else b[bn++] = (x[i]); } int count = 0; for (int i = 0; i &lt; an; i++) x[count++] = a[i]; for (int i = 0; i &lt; bn; i++) x[count++] = b[i]; for (int i = 0; i &lt; cn; i++) x[count++] = c[i]; print(x, real); return 0;} æ€è·¯ä¸æ³¨æ„ è¾“å…¥æ•°æ®ï¼ˆç”±äºåé¢è¦è¿˜åŸé“¾è¡¨ï¼Œä¸ºäº†é™ä½å¤æ‚åº¦ï¼ŒæŠŠaddrå½“åšå¼•ç´¢ï¼‰ æŠŠé“¾è¡¨å…ˆè¿˜åŸï¼ŒåŒæ—¶è¿”å›è¿˜åŸåçš„èŠ‚ç‚¹ä¸ªæ•°ï¼ˆå› ä¸ºæœ‰å¯èƒ½æŸäº›èŠ‚ç‚¹ä¸åœ¨é“¾è¡¨ä¸Šï¼‰ åˆ†ç±»ç»Ÿè®¡ï¼Œæœ€åå†é‡æ–°æ’å›å» è¾“å‡ºï¼ˆè¾“å‡ºçš„æ—¶å€™æœ€å¥½æŠŠå®ƒå˜æˆä¸€ä¸ªæ•´ä½“ï¼Œä¸è¦åˆ†å—è¾“å‡ºï¼ˆå¯èƒ½å­˜åœ¨æŸä¸€éƒ¨åˆ†ç©ºçš„æƒ…å†µï¼‰ï¼‰ åæ€ä¸è¯„ä»· è¿™é“é¢˜å°±æ˜¯æ”¹äº†æ”¹åè½¬é“¾è¡¨ æ€æƒ³å®é™…ä¸Šæ˜¯å¾·æ‰è®ºå’Œåè½¬é“¾è¡¨çš„ç»¼åˆï¼Œç®€å•é¢˜ åè½¬é“¾è¡¨ç”¨vectorå¯ä»¥è¿‡ï¼Œä½†æ˜¯è¿™ä¸ªé¢˜ç”¨vectorå°±ä¼šæ®µé”™è¯¯ï¼Œæ‰€ä»¥ç”¨æ™®é€šæ•°ç»„","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1075-%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E5%88%86%E7%B1%BB(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1078","text":"é¢˜ç›® æ–‡æœ¬å‹ç¼©æœ‰å¾ˆå¤šç§æ–¹æ³•ï¼Œè¿™é‡Œæˆ‘ä»¬åªè€ƒè™‘æœ€ç®€å•çš„ä¸€ç§ï¼šæŠŠç”±ç›¸åŒå­—ç¬¦ç»„æˆçš„ä¸€ä¸ªè¿ç»­çš„ç‰‡æ®µç”¨è¿™ä¸ªå­—ç¬¦å’Œç‰‡æ®µä¸­å«æœ‰è¿™ä¸ªå­—ç¬¦çš„ä¸ªæ•°æ¥è¡¨ç¤ºã€‚ä¾‹å¦‚ ccccc å°±ç”¨ 5c æ¥è¡¨ç¤ºã€‚å¦‚æœå­—ç¬¦æ²¡æœ‰é‡å¤ï¼Œå°±åŸæ ·è¾“å‡ºã€‚ä¾‹å¦‚ aba å‹ç¼©åä»ç„¶æ˜¯ abaã€‚ è§£å‹æ–¹æ³•å°±æ˜¯åè¿‡æ¥ï¼ŒæŠŠå½¢å¦‚ 5c è¿™æ ·çš„è¡¨ç¤ºæ¢å¤ä¸º cccccã€‚ æœ¬é¢˜éœ€è¦ä½ æ ¹æ®å‹ç¼©æˆ–è§£å‹çš„è¦æ±‚ï¼Œå¯¹ç»™å®šå­—ç¬¦ä¸²è¿›è¡Œå¤„ç†ã€‚è¿™é‡Œæˆ‘ä»¬ç®€å•åœ°å‡è®¾åŸå§‹å­—ç¬¦ä¸²æ˜¯å®Œå…¨ç”±è‹±æ–‡å­—æ¯å’Œç©ºæ ¼ç»„æˆçš„éç©ºå­—ç¬¦ä¸²ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸€ä¸ªå­—ç¬¦ï¼Œå¦‚æœæ˜¯ C å°±è¡¨ç¤ºä¸‹é¢çš„å­—ç¬¦ä¸²éœ€è¦è¢«å‹ç¼©ï¼›å¦‚æœæ˜¯ D å°±è¡¨ç¤ºä¸‹é¢çš„å­—ç¬¦ä¸²éœ€è¦è¢«è§£å‹ã€‚ç¬¬äºŒè¡Œç»™å‡ºéœ€è¦è¢«å‹ç¼©æˆ–è§£å‹çš„ä¸è¶…è¿‡ 1000 ä¸ªå­—ç¬¦çš„å­—ç¬¦ä¸²ï¼Œä»¥å›è½¦ç»“å°¾ã€‚é¢˜ç›®ä¿è¯å­—ç¬¦é‡å¤ä¸ªæ•°åœ¨æ•´å‹èŒƒå›´å†…ï¼Œä¸”è¾“å‡ºæ–‡ä»¶ä¸è¶…è¿‡ 1MBã€‚ è¾“å‡ºæ ¼å¼ï¼š æ ¹æ®è¦æ±‚å‹ç¼©æˆ–è§£å‹å­—ç¬¦ä¸²ï¼Œå¹¶åœ¨ä¸€è¡Œä¸­è¾“å‡ºç»“æœã€‚ è¾“å…¥æ ·ä¾‹ 1ï¼š12CTTTTThhiiiis isssss a tesssst CAaaa as è¾“å‡ºæ ·ä¾‹ 1ï¼š15T2h4is i5s a3 te4st CA3a as è¾“å…¥æ ·ä¾‹ 2ï¼š12D5T2h4is i5s a3 te4st CA3a as10Z è¾“å‡ºæ ·ä¾‹ 2ï¼š1TTTTThhiiiis isssss a tesssst CAaaa asZZZZZZZZZZ é€šè¿‡ä»£ç ï¼ˆæè‡´å‹è¡Œç‰ˆï¼‰12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;ctype.h&gt;using namespace std;void Cprint(int&amp; count, char a) {//æ³¨æ„countæ˜¯å¼•ç”¨å˜é‡ if (count != 1) cout &lt;&lt; count; cout &lt;&lt; a; count = 0;}int main () { string str, c; int i = 0, count = 1;//iæ˜¯è§£ç çš„å¾ªç¯å˜é‡ï¼Œæ§åˆ¶ä¸‹æ ‡ã€‚countæ˜¯å‹ç¼©è¿‡ç¨‹ä¸­è®°å½•é‡å¤å­—ç¬¦å‡ºç°æ¬¡æ•°çš„ getline(cin, c); getline(cin, str);//è¾“å…¥ if (c == &quot;C&quot;) { for (int j = 1; j &lt; str.length(); j++, count++)//æ¯æ¬¡å¾ªç¯count++ if (str[j - 1] != str[j]) Cprint(count, str[j - 1]);//å¦‚æœé‡åˆ°ä¸€ä¸ªå­—ç¬¦å’Œå‰ä¸€ä¸ªä¸ä¸€æ ·ï¼Œè¾“å‡ºï¼Œè®©countå½’é›¶ Cprint(count, str[str.length() - 1]);//è¾“å‡ºæœ€æœ«å°¾çš„ä¸€ä¸ªæˆ–ä¸€ä¸² } else if (c == &quot;D&quot;) { if (!isdigit(str[i])) cout &lt;&lt; str[i++];//ç¬¬ä¸€ä¸ªä¸æ˜¯æ•°å­—ï¼Œç›´æ¥è¾“å‡ºï¼Œi++è®¿é—®ä¸‹ä¸€ä¸ªå­—ç¬¦ for (int n = 0; i &lt; str.length(); n = 0, i++) {//nä¸ºæ¯ä¸ªå­—ç¬¦å‰çš„æ•°å­— for (; i &lt; str.length() &amp;&amp; isdigit(str[i]); n *= 10, n += (str[i++] - '0'));//å¦‚æœæ˜¯æ•°å­—ï¼Œå°±æŠŠæ•°å­—å­—ç¬¦è½¬æ¢æˆæ•°ï¼Œè¿™é‡Œä¸æ˜¯åŒå±‚forå¾ªç¯åµŒå¥—ï¼Œè¿™ä¸ªforå¾ªç¯åæœ‰ä¸€ä¸ªåˆ†å· for (int j = 0; j &lt; (n == 0 ? 1 : n); j++) cout &lt;&lt; str[i];//å¾ªç¯è¾“å‡ºå­—ç¬¦ï¼Œå¦‚æœæ²¡æœ‰é‡åˆ°æ•°å­—ï¼Œnä¸º0ï¼Œå°±è¾“å‡ºä¸€æ¬¡ } } return 0;} é€šè¿‡ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;ctype.h&gt;using namespace std;struct out { char c; int n; };void C () { string str; getline(cin, str); int n = str.length(); out data[n] = {0}; char last = -1; int count = -1; for (int i = 0; i &lt; n; i++) { if (str[i] != last) data[++count].c = str[i]; data[count].n++; last = str[i]; } for (int i = 0; i &lt; count + 1; i++) { if (data[i].n != 1) cout &lt;&lt; data[i].n; cout &lt;&lt; data[i].c; }}void D () { string str; getline(cin, str); int i = 0; if (!isdigit(str[i])) cout &lt;&lt; str[i++]; while (i &lt; str.length()) { int n = 0; while (i &lt; str.length() &amp;&amp; isdigit(str[i])) { n *= 10; n += str[i++] - '0'; } for (int j = 0; j &lt; n; j++) cout &lt;&lt; str[i]; i++; while ( i &lt; str.length() &amp;&amp; !isdigit(str[i])) cout &lt;&lt; str[i++]; }}int main () { char c; scanf(&quot;%c%*c&quot;, &amp;c); if (c == 'C') C(); else D(); return 0;} æ€è·¯ä¸æ³¨æ„ codingï¼ˆå‹ç¼©ï¼‰ä¸€ä¸ªå‡½æ•°ï¼Œdecodingï¼ˆè§£å‹ï¼‰ä¸€ä¸ªå‡½æ•°åˆ†åˆ«å¤„ç† ä¸¤ä¸ªå‡½æ•°ç»Ÿä¸€ä½¿ç”¨getlineï¼Œmainå‡½æ•°é‡Œé¢è¦åƒæ‰ç¬¬ä¸€è¡Œçš„æ¢è¡Œç¬¦ å¯¹äºcodingè¿‡ç¨‹ å®šä¹‰ä¸€ä¸ªç»“æ„ä½“æ•°ç»„ï¼Œå‚¨å­˜å­—ç¬¦ä¸ä¸ªæ•°ã€‚æ•°ç»„é•¿åº¦ä¸ºè¾“å…¥stringçš„é•¿åº¦ï¼ˆå¦‚æœè¾“å…¥çš„stringä¸èƒ½å‹ç¼©ï¼Œæ­£å¥½å¤Ÿç”¨ï¼‰ éå†ä¸€éstringï¼Œå¦‚æœå­—ç¬¦å’Œå‰ä¸€ä¸ªå­—ç¬¦ä¸€æ ·ï¼Œé‚£ä¹ˆå½“å‰ç»“æ„ä½“ï¼ˆå˜é‡ï¼‰çš„å­—ç¬¦ä¸ªæ•°++ï¼Œä¸€æ—¦æ”¹å˜ï¼Œå­˜åˆ°ä¸‹ä¸€ä¸ªç»“æ„ä½“ä¸­ã€‚ è¾“å‡ºç»“æ„ä½“ï¼Œå…ˆè¾“å‡ºä¸ªæ•°ï¼ˆå¤§äº1æ‰è¾“å‡ºï¼‰ï¼Œå†è¾“å‡ºè¿™ä¸ªå­—ç¬¦ å¯¹äºdecodingè¿‡ç¨‹ å…ˆåˆ¤æ–­ç¬¬ä¸€ä¸ªå­—ç¬¦ï¼Œå¦‚æœæ˜¯å­—æ¯ç›´æ¥è¾“å‡ºè¿™ä¸ªå­—æ¯ï¼Œç„¶åå­—ç¬¦ä¸²çš„â€œæŒ‡é’ˆâ€å‘åç§»ã€‚ è¿›å…¥å¾ªç¯ï¼Œå¾ªç¯çš„æ“ä½œä¸ºï¼Œå¾—åˆ°æ•°å­—ï¼Œè¾“å‡ºæ•°å­—åçš„å­—æ¯ï¼Œç„¶åè¾“å‡ºåé¢çš„å•ä¸ªå­—æ¯ï¼Œç›´åˆ°é‡åˆ°ä¸‹ä¸€ä¸ªæ•°å­—ï¼Œè¿›å…¥ä¸‹ä¸€æ¬¡å¾ªç¯ï¼Œæˆ–è€…é‡åˆ°å­—ç¬¦ä¸²ç»“æŸï¼Œé‚£å°±ç»“æŸã€‚ æ³¨æ„ä¸è¦ç”¨isalpha()å‡½æ•°ï¼ˆè€ƒè™‘ç©ºæ ¼çš„å­˜åœ¨ï¼‰ åæ€ä¸è¯„ä»· å—¯","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1078-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1079","text":"é¢˜ç›® ç»™å®šä¸€ä¸ª k+1 ä½çš„æ­£æ•´æ•° Nï¼Œå†™æˆ akâ‹¯a1a0 çš„å½¢å¼ï¼Œå…¶ä¸­å¯¹æ‰€æœ‰ i æœ‰ 0â‰¤ai&lt;10 ä¸” ak&gt;0ã€‚N è¢«ç§°ä¸ºä¸€ä¸ªå›æ–‡æ•°ï¼Œå½“ä¸”ä»…å½“å¯¹æ‰€æœ‰ i æœ‰ ai=akâˆ’iã€‚é›¶ä¹Ÿè¢«å®šä¹‰ä¸ºä¸€ä¸ªå›æ–‡æ•°ã€‚ éå›æ–‡æ•°ä¹Ÿå¯ä»¥é€šè¿‡ä¸€ç³»åˆ—æ“ä½œå˜å‡ºå›æ–‡æ•°ã€‚é¦–å…ˆå°†è¯¥æ•°å­—é€†è½¬ï¼Œå†å°†é€†è½¬æ•°ä¸è¯¥æ•°ç›¸åŠ ï¼Œå¦‚æœå’Œè¿˜ä¸æ˜¯ä¸€ä¸ªå›æ–‡æ•°ï¼Œå°±é‡å¤è¿™ä¸ªé€†è½¬å†ç›¸åŠ çš„æ“ä½œï¼Œç›´åˆ°ä¸€ä¸ªå›æ–‡æ•°å‡ºç°ã€‚å¦‚æœä¸€ä¸ªéå›æ–‡æ•°å¯ä»¥å˜å‡ºå›æ–‡æ•°ï¼Œå°±ç§°è¿™ä¸ªæ•°ä¸ºå»¶è¿Ÿçš„å›æ–‡æ•°ã€‚ï¼ˆå®šä¹‰ç¿»è¯‘è‡ª https://en.wikipedia.org/wiki/Palindromic_number ï¼‰ ç»™å®šä»»æ„ä¸€ä¸ªæ­£æ•´æ•°ï¼Œæœ¬é¢˜è¦æ±‚ä½ æ‰¾åˆ°å…¶å˜å‡ºçš„é‚£ä¸ªå›æ–‡æ•°ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºä¸€ä¸ªä¸è¶…è¿‡1000ä½çš„æ­£æ•´æ•°ã€‚ è¾“å‡ºæ ¼å¼ï¼š å¯¹ç»™å®šçš„æ•´æ•°ï¼Œä¸€è¡Œä¸€è¡Œè¾“å‡ºå…¶å˜å‡ºå›æ–‡æ•°çš„è¿‡ç¨‹ã€‚æ¯è¡Œæ ¼å¼å¦‚ä¸‹ 1A + B = C å…¶ä¸­ A æ˜¯åŸå§‹çš„æ•°å­—ï¼ŒB æ˜¯ A çš„é€†è½¬æ•°ï¼ŒC æ˜¯å®ƒä»¬çš„å’Œã€‚A ä»è¾“å…¥çš„æ•´æ•°å¼€å§‹ã€‚é‡å¤æ“ä½œç›´åˆ° C åœ¨ 10 æ­¥ä»¥å†…å˜æˆå›æ–‡æ•°ï¼Œè¿™æ—¶åœ¨ä¸€è¡Œä¸­è¾“å‡º C is a palindromic number.ï¼›æˆ–è€…å¦‚æœ 10 æ­¥éƒ½æ²¡èƒ½å¾—åˆ°å›æ–‡æ•°ï¼Œæœ€åå°±åœ¨ä¸€è¡Œä¸­è¾“å‡º Not found in 10 iterations.ã€‚ è¾“å…¥æ ·ä¾‹ 1ï¼š197152 è¾“å‡ºæ ·ä¾‹ 1ï¼š12397152 + 25179 = 122331122331 + 133221 = 255552255552 is a palindromic number. è¾“å…¥æ ·ä¾‹ 2ï¼š1196 è¾“å‡ºæ ·ä¾‹ 2ï¼š1234567891011196 + 691 = 887887 + 788 = 16751675 + 5761 = 74367436 + 6347 = 1378313783 + 38731 = 5251452514 + 41525 = 9403994039 + 93049 = 187088187088 + 880781 = 10678691067869 + 9687601 = 1075547010755470 + 07455701 = 18211171Not found in 10 iterations. é€šè¿‡ä»£ç 12345678910111213141516171819202122232425262728293031323334import java.util.*;import java.math.*;class Main { static BigInteger getReverseNum(BigInteger a) { StringBuffer bf = new StringBuffer(a.toString()); bf.reverse(); BigInteger b = new BigInteger(bf.toString()); return b; } static boolean isPalindromicNumber(BigInteger a) { String n = a.toString(); int len = n.length(); for (int i = 0; i &lt; len / 2; i++) if (n.charAt(i) != n.charAt(len - i - 1)) return false; return true; } public static void main (String[] args) { Scanner sc = new Scanner(System.in); boolean ok = false; BigInteger a = sc.nextBigInteger(); for (int i = 0; i &lt; 10; i++) { if (isPalindromicNumber(a)) { System.out.println(a + &quot; is a palindromic number.&quot;); ok = true; break; } BigInteger b = getReverseNum(a); BigInteger c = a.add(b); System.out.println(a + &quot; + &quot; + b + &quot; = &quot; + c); a = c; } if (!ok) System.out.println(&quot;Not found in 10 iterations.&quot;); }} æ€è·¯ä¸æ³¨æ„ é¢˜ç›®ä¸­è¯´æ˜¯1000ä½çš„æ•´æ•°ï¼Œæ‰€ä»¥ä¸€èˆ¬çš„longè§£å†³ä¸äº†ï¼Œè¦ç”¨åˆ°java.math.*;ä¸­çš„BigIntegerç±» æ ¹æ®é¢˜ç›®è¦æ±‚è®¡ç®—å°±å¥½ è¦åœ¨10æ­¥å†…å‡ºç»“æœï¼Œé€‚åˆç”¨forå¾ªç¯ å¾ªç¯çš„æ—¶å€™è¦å…ˆåˆ¤æ–­æ˜¯å¦ä¸ºPalindromic Numberï¼Œæœ‰å¯èƒ½è¾“å…¥çš„ç¬¬ä¸€ä¸ªæ•°å°±æ˜¯Palindromic Numberã€‚ åæ€ä¸è¯„ä»· é€‰æ‹©è¯­è¨€å¾ˆé‡è¦ï¼ŒJavaæä¾›çš„BigIntegerå®Œç¾è§£å†³ c++å†™çš„è¯å¯ä»¥åœ¨ç½‘ä¸Šæ‰¾ä¸€ä»½å¤§æ•´å‹çš„æ¨¡æ¿æ¥ç”¨","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1079-%E5%BB%B6%E8%BF%9F%E7%9A%84%E5%9B%9E%E6%96%87%E6%95%B0(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1080","text":"é¢˜ç›® å¯¹äºåœ¨ä¸­å›½å¤§å­¦MOOCï¼ˆhttp://www.icourse163.org/ ï¼‰å­¦ä¹ â€œæ•°æ®ç»“æ„â€è¯¾ç¨‹çš„å­¦ç”Ÿï¼Œæƒ³è¦è·å¾—ä¸€å¼ åˆæ ¼è¯ä¹¦ï¼Œå¿…é¡»é¦–å…ˆè·å¾—ä¸å°‘äº200åˆ†çš„åœ¨çº¿ç¼–ç¨‹ä½œä¸šåˆ†ï¼Œç„¶åæ€»è¯„è·å¾—ä¸å°‘äº60åˆ†ï¼ˆæ»¡åˆ†100ï¼‰ã€‚æ€»è¯„æˆç»©çš„è®¡ç®—å…¬å¼ä¸º G=(Gmidâˆ’termÃ—40%+GfinalÃ—60%)ï¼Œå¦‚æœ Gmidâˆ’term&gt;Gfinalï¼›å¦åˆ™æ€»è¯„ G å°±æ˜¯ Gfinalã€‚è¿™é‡Œ Gmidâˆ’term å’Œ Gfinal åˆ†åˆ«ä¸ºå­¦ç”Ÿçš„æœŸä¸­å’ŒæœŸæœ«æˆç»©ã€‚ ç°åœ¨çš„é—®é¢˜æ˜¯ï¼Œæ¯æ¬¡è€ƒè¯•éƒ½äº§ç”Ÿä¸€å¼ ç‹¬ç«‹çš„æˆç»©å•ã€‚æœ¬é¢˜å°±è¯·ä½ ç¼–å†™ç¨‹åºï¼ŒæŠŠä¸åŒçš„æˆç»©å•åˆä¸ºä¸€å¼ ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥åœ¨ç¬¬ä¸€è¡Œç»™å‡º3ä¸ªæ•´æ•°ï¼Œåˆ†åˆ«æ˜¯ Pï¼ˆåšäº†åœ¨çº¿ç¼–ç¨‹ä½œä¸šçš„å­¦ç”Ÿæ•°ï¼‰ã€Mï¼ˆå‚åŠ äº†æœŸä¸­è€ƒè¯•çš„å­¦ç”Ÿæ•°ï¼‰ã€Nï¼ˆå‚åŠ äº†æœŸæœ«è€ƒè¯•çš„å­¦ç”Ÿæ•°ï¼‰ã€‚æ¯ä¸ªæ•°éƒ½ä¸è¶…è¿‡10000ã€‚ æ¥ä¸‹æ¥æœ‰ä¸‰å—è¾“å…¥ã€‚ç¬¬ä¸€å—åŒ…å« P ä¸ªåœ¨çº¿ç¼–ç¨‹æˆç»© Gpï¼›ç¬¬äºŒå—åŒ…å« M ä¸ªæœŸä¸­è€ƒè¯•æˆç»© Gmidâˆ’termï¼›ç¬¬ä¸‰å—åŒ…å« N ä¸ªæœŸæœ«è€ƒè¯•æˆç»© Gfinalã€‚æ¯ä¸ªæˆç»©å ä¸€è¡Œï¼Œæ ¼å¼ä¸ºï¼šå­¦ç”Ÿå­¦å· åˆ†æ•°ã€‚å…¶ä¸­å­¦ç”Ÿå­¦å·ä¸ºä¸è¶…è¿‡20ä¸ªå­—ç¬¦çš„è‹±æ–‡å­—æ¯å’Œæ•°å­—ï¼›åˆ†æ•°æ˜¯éè´Ÿæ•´æ•°ï¼ˆç¼–ç¨‹æ€»åˆ†æœ€é«˜ä¸º900åˆ†ï¼ŒæœŸä¸­å’ŒæœŸæœ«çš„æœ€é«˜åˆ†ä¸º100åˆ†ï¼‰ã€‚ è¾“å‡ºæ ¼å¼ï¼š æ‰“å°å‡ºè·å¾—åˆæ ¼è¯ä¹¦çš„å­¦ç”Ÿåå•ã€‚æ¯ä¸ªå­¦ç”Ÿå ä¸€è¡Œï¼Œæ ¼å¼ä¸ºï¼š å­¦ç”Ÿå­¦å· Gp Gmidâˆ’term Gfinal G å¦‚æœæœ‰çš„æˆç»©ä¸å­˜åœ¨ï¼ˆä¾‹å¦‚æŸäººæ²¡å‚åŠ æœŸä¸­è€ƒè¯•ï¼‰ï¼Œåˆ™åœ¨ç›¸åº”çš„ä½ç½®è¾“å‡ºâ€œâˆ’1â€ã€‚è¾“å‡ºé¡ºåºä¸ºæŒ‰ç…§æ€»è¯„åˆ†æ•°ï¼ˆå››èˆäº”å…¥ç²¾ç¡®åˆ°æ•´æ•°ï¼‰é€’å‡ã€‚è‹¥æœ‰å¹¶åˆ—ï¼Œåˆ™æŒ‰å­¦å·é€’å¢ã€‚é¢˜ç›®ä¿è¯å­¦å·æ²¡æœ‰é‡å¤ï¼Œä¸”è‡³å°‘å­˜åœ¨1ä¸ªåˆæ ¼çš„å­¦ç”Ÿã€‚ è¾“å…¥æ ·ä¾‹ï¼š12345678910111213141516171819206 6 701234 880a1903 199ydjh2 200wehu8 300dx86w 220missing 400ydhfu77 99wehu8 55ydjh2 98dx86w 88a1903 8601234 39ydhfu77 88a1903 6601234 58wehu8 84ydjh2 82missing 99dx86w 81 è¾“å‡ºæ ·ä¾‹ï¼š1234missing 400 -1 99 99ydjh2 200 98 82 88dx86w 220 88 81 84wehu8 300 55 84 84 é€šè¿‡ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;class data {public: double Gp, GmidTerm, Gfinal, G; string name; data() { G = -1; Gfinal = -1; Gp = -1; GmidTerm = -1; } void setGp(double a) {Gp = a;} void setGmidTerm(double a) {GmidTerm = a;} void setGfinal(double a) {Gfinal = a;} void setName(string n) { name = n; } void final() { if (GmidTerm &gt; Gfinal) G = GmidTerm * 0.4 + Gfinal * 0.6; else G = Gfinal; G = round(G); GmidTerm = round(GmidTerm); Gfinal = round(Gfinal); Gp = round(Gp); }};typedef pair&lt;string, data&gt; PAIR;bool cmp1(PAIR&amp; a, PAIR&amp; b) { if (a.second.G != b.second.G) return a.second.G &gt; b.second.G; else return a.second.name &lt; b.second.name;}int main () { map&lt;string, data&gt; m; int a, b, c; double score; string name; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; for (int i = 0; i &lt; a; i++) { cin &gt;&gt; name &gt;&gt; score; m[name].setGp(score); m[name].setName(name); } for (int i = 0; i &lt; b; i++) { cin &gt;&gt; name &gt;&gt; score; m[name].setGmidTerm(score); } for (int i = 0; i &lt; c; i++) { cin &gt;&gt; name &gt;&gt; score; m[name].setGfinal(score); m[name].final(); } vector&lt;PAIR&gt; v; int i = 0; for (map&lt;string, data&gt;::iterator ite = m.begin(); ite != m.end(); ite++, i++) v.push_back(*ite); sort(v.begin(), v.end(), cmp1); for (int i = 0; i &lt; v.size(); i++) if (v[i].second.Gp &gt;= 200 &amp;&amp; v[i].second.G &gt;= 60) printf (&quot;%s %.0lf %.0lf %.0lf %.0lf\\n&quot;, v[i].second.name.data(), v[i].second.Gp, v[i].second.GmidTerm, v[i].second.Gfinal, v[i].second.G); return 0;} æ€è·¯ä¸æ³¨æ„ åˆ©ç”¨ç±»æ¥ç®¡ç†æ•°æ®ï¼Œæ¯”è¾ƒæ–¹ä¾¿ ç¬¬ä¸€ä¸ªéš¾ç‚¹åœ¨äºIDä¸æ˜¯çº¯æ•°å­—ï¼Œä¸èƒ½æŠŠIDå½“åšæ•°ç»„å¼•ç´¢ï¼Œæƒ³åˆ°ä½¿ç”¨map ç¬¬äºŒä¸ªéš¾ç‚¹åœ¨äºå¯¹mapæ’åºï¼Œmapæ˜¯é»˜è®¤ä»¥keyæ’åºçš„ï¼Œè¿™é“é¢˜è¦å¯¹mapçš„valueè¿›è¡Œæ’åº æ³¨æ„ï¼Œæ•°æ®è¾“å…¥å¹¶è®¡ç®—å¥½ä»¥åï¼Œå…ˆå››èˆäº”å…¥ï¼ˆround() å‡½æ•°ï¼‰ï¼Œå†æ’åºè¾“å‡ºã€‚ åæ€ä¸è¯„ä»· å­¦åˆ°äº†å¾ˆå¤šå…³äºmapçš„çŸ¥è¯† åˆšå¼€å§‹ä¸ç”¨vectorç”¨æ™®é€šæ•°ç»„çš„æ—¶å€™ï¼Œæœ€åä¸€ä¸ªæµ‹è¯•ç‚¹å‡ºç°æ®µé”™è¯¯ï¼Œä¸çŸ¥é“æ˜¯ä»€ä¹ˆé—®é¢˜ã€‚ æ”¶è· mapçš„æ’åº mapé»˜è®¤æŒ‰ç…§keyè¿›è¡Œå‡åºæ’åºï¼Œå’Œè¾“å…¥çš„é¡ºåºæ— å…³ã€‚å¦‚æœæ˜¯int/doubleç­‰æ•°å€¼å‹ä¸ºkeyï¼Œé‚£ä¹ˆå°±æŒ‰ç…§å¤§å°æ’åˆ—ï¼›å¦‚æœæ˜¯stringç±»å‹ï¼Œé‚£ä¹ˆå°±æŒ‰ç…§å­—ç¬¦ä¸²çš„å­—å…¸åºè¿›è¡Œæ’åˆ— æˆ‘ä»¬åœ¨å®šä¹‰mapç±»æ¨¡æ¿çš„æ—¶å€™ä¸æ˜¯åªæœ‰ä¸¤ä¸ªå‚æ•°å—~ï¼ˆmap&lt;string, int&gt;ï¼‰~~å…¶å®mapä¸€å…±æœ‰4ä¸ªå‚æ•°ï¼Œåé¢çœç•¥çš„ï¼Œæˆ–è€…è¯´æ˜¯é»˜è®¤çš„ç¬¬ä¸‰ä¸ªå‚æ•°å°±æ˜¯å…³äºæ’åºè§„åˆ™çš„ å…·ä½“è€Œè¨€ï¼Œå®ƒæœ‰å››ä¸ªå‚æ•°ï¼Œå…¶ä¸­æˆ‘ä»¬æ¯”è¾ƒç†Ÿæ‚‰çš„æœ‰ä¸¤ä¸ª: Key å’Œ Valueã€‚ç¬¬ä¸‰ä¸ªæ˜¯class Compare = less&lt;Key&gt;(æ’åºæ–¹å¼)ï¼Œç¬¬å››ä¸ªæ˜¯ Allocatorï¼Œç”¨æ¥å®šä¹‰å­˜å‚¨åˆ†é…æ¨¡å‹çš„ã€‚ å¯¹keyè¿›è¡Œè‡ªå®šä¹‰æ’åº mapä¸èƒ½è°ƒç”¨sortæ’åºï¼Œæ˜¯å› ä¸ºï¼šmapæ˜¯ä¸ªå…³è”å®¹å™¨ï¼Œä¸æ˜¯åºåˆ—å®¹å™¨ã€‚åƒæ˜¯ä¸€äº›åºåˆ—å®¹å™¨list, vectoréƒ½æ˜¯å¯ä»¥æ’åºçš„ã€‚ å¯¹mapçš„valueæ’åºçš„æƒ³æ³• é¦–å…ˆï¼Œmapä¸­çš„&lt;key, value&gt;æ˜¯pairå½¢å¼çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥æŠŠä¸€ä¸ªpairä½œä¸ºvectorä¸­çš„å…ƒç´ ï¼› ç„¶åï¼Œè°ƒç”¨vetorå®¹å™¨ä¸­çš„sortå‡½æ•°ï¼Œsortå‡½æ•°ä¹Ÿæ˜¯å¯ä»¥ç”¨æˆ·æŒ‡å®šæ¯”è¾ƒç±»å‹çš„ã€‚ å¯¹keyè¿›è¡Œè‡ªå®šä¹‰æ’åº 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;map&gt;using namespace std;struct cmp //è‡ªå®šä¹‰æ¯”è¾ƒè§„åˆ™{ bool operator() (const string&amp; str1, const string&amp; str2) { return str1.length() &lt; str2.length(); }};int main(){ map&lt;string, int, cmp &gt; scoreMap; //è¿™è¾¹è°ƒç”¨cmp map&lt;string, int, cmp &gt;::iterator iter; scoreMap[&quot;LiMin&quot;] = 90; scoreMap[&quot;ZZihsf&quot;] = 95; scoreMap[&quot;Kim&quot;] = 100; scoreMap.insert(map&lt;string, int&gt;::value_type(&quot;Jack&quot;, 88)); for (iter = scoreMap.begin(); iter != scoreMap.end(); iter++) cout &lt;&lt; iter-&gt;first &lt;&lt; ' ' &lt;&lt; iter-&gt;second &lt;&lt; endl; return 0;} æ ¹æ®valueæ’åº 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;vector&gt;using namespace std; typedef pair&lt;string, int&gt; PAIR; struct cmp //è‡ªå®šä¹‰æ¯”è¾ƒè§„åˆ™{ bool operator() (const PAIR&amp; P1, const PAIR&amp; P2) //æ³¨æ„æ˜¯PAIRç±»å‹ï¼Œéœ€è¦.firtå’Œ.secondã€‚è¿™ä¸ªå’Œmapç±»ä¼¼ { return P1.second &lt; P2.second; }}; int main(){ map&lt;string, int&gt; scoreMap; //è¿™è¾¹è°ƒç”¨cmp map&lt;string, int&gt;::iterator iter; scoreMap[&quot;LiMin&quot;] = 90; scoreMap[&quot;ZZihsf&quot;] = 95; scoreMap[&quot;Kim&quot;] = 100; scoreMap.insert(map&lt;string, int&gt;::value_type(&quot;Jack&quot;, 88)); vector&lt;PAIR&gt;scoreVector; for(iter=scoreMap.begin(); iter!=scoreMap.end();iter++) //è¿™è¾¹æœ¬æ¥æ˜¯ä½¿ç”¨vectorç›´æ¥åˆå§‹åŒ–çš„ï¼Œå½“æ—¶ç”±äºvc 6.0 ç¼–è¯‘å™¨é—®é¢˜ï¼Œåªèƒ½è¿™æ ·å†™ï¼Œè€Œä¸”è¿˜æœ‰éæ³•å†…å­˜ã€‚ã€‚ scoreVector.push_back(*iter); //è½¬åŒ–ä¸ºPAIRçš„vector sort(scoreVector.begin(), scoreVector.end(), cmp()); //éœ€è¦æŒ‡å®šcmp for(int i=0; i&lt;=scoreVector.size(); i++) //ä¹Ÿè¦æŒ‰ç…§vectorçš„å½¢å¼è¾“å‡º cout&lt;&lt; scoreVector[i].first&lt;&lt;' '&lt;&lt;scoreVector[i].second &lt;&lt;endl; /* for(iter=scoreMap.begin(); iter!=scoreMap.end(); iter++) cout&lt;&lt;iter-&gt;first&lt;&lt;' '&lt;&lt;iter-&gt;second&lt;&lt;endl; */ return 0; } å››èˆäº”å…¥å‡½æ•°ï¼ˆå…¶å®æ—©å°±å­¦è¿‡ï¼Œå·æ‡’æ²¡æœ‰è®°ï¼‰ round(); å¤´æ–‡ä»¶ cmath å‚è€ƒæ–‡çŒ®CSDNâ€”â€”STLå®¹å™¨ï¼ˆä¸‰ï¼‰â€”â€”å¯¹mapæ’åº","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1080-MOOC%E6%9C%9F%E7%BB%88%E6%88%90%E7%BB%A9(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1068","text":"é¢˜ç›® å¯¹äºè®¡ç®—æœºè€Œè¨€ï¼Œé¢œè‰²ä¸è¿‡æ˜¯åƒç´ ç‚¹å¯¹åº”çš„ä¸€ä¸ª 24 ä½çš„æ•°å€¼ã€‚ç°ç»™å®šä¸€å¹…åˆ†è¾¨ç‡ä¸º MÃ—N çš„ç”»ï¼Œè¦æ±‚ä½ æ‰¾å‡ºä¸‡ç»¿ä¸›ä¸­çš„ä¸€ç‚¹çº¢ï¼Œå³æœ‰ç‹¬ä¸€æ— äºŒé¢œè‰²çš„é‚£ä¸ªåƒç´ ç‚¹ï¼Œå¹¶ä¸”è¯¥ç‚¹çš„é¢œè‰²ä¸å…¶å‘¨å›´ 8 ä¸ªç›¸é‚»åƒç´ çš„é¢œè‰²å·®å……åˆ†å¤§ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸‰ä¸ªæ­£æ•´æ•°ï¼Œåˆ†åˆ«æ˜¯ M å’Œ Nï¼ˆâ‰¤ 1000ï¼‰ï¼Œå³å›¾åƒçš„åˆ†è¾¨ç‡ï¼›ä»¥åŠ TOLï¼Œæ˜¯æ‰€æ±‚åƒç´ ç‚¹ä¸ç›¸é‚»ç‚¹çš„é¢œè‰²å·®é˜ˆå€¼ï¼Œè‰²å·®è¶…è¿‡ TOL çš„ç‚¹æ‰è¢«è€ƒè™‘ã€‚éšå N è¡Œï¼Œæ¯è¡Œç»™å‡º M ä¸ªåƒç´ çš„é¢œè‰²å€¼ï¼ŒèŒƒå›´åœ¨ [0,224) å†…ã€‚æ‰€æœ‰åŒè¡Œæ•°å­—é—´ç”¨ç©ºæ ¼æˆ– TAB åˆ†å¼€ã€‚ è¾“å‡ºæ ¼å¼ï¼š åœ¨ä¸€è¡Œä¸­æŒ‰ç…§ (x, y): color çš„æ ¼å¼è¾“å‡ºæ‰€æ±‚åƒç´ ç‚¹çš„ä½ç½®ä»¥åŠé¢œè‰²å€¼ï¼Œå…¶ä¸­ä½ç½® x å’Œ y åˆ†åˆ«æ˜¯è¯¥åƒç´ åœ¨å›¾åƒçŸ©é˜µä¸­çš„åˆ—ã€è¡Œç¼–å·ï¼ˆä» 1 å¼€å§‹ç¼–å·ï¼‰ã€‚å¦‚æœè¿™æ ·çš„ç‚¹ä¸å”¯ä¸€ï¼Œåˆ™è¾“å‡º Not Uniqueï¼›å¦‚æœè¿™æ ·çš„ç‚¹ä¸å­˜åœ¨ï¼Œåˆ™è¾“å‡º Not Existã€‚ è¾“å…¥æ ·ä¾‹ 1ï¼š12345678 6 2000 0 0 0 0 0 0 065280 65280 65280 16711479 65280 65280 65280 6528016711479 65280 65280 65280 16711680 65280 65280 6528065280 65280 65280 65280 65280 65280 165280 16528065280 65280 16777015 65280 65280 165280 65480 16528016777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 è¾“å‡ºæ ·ä¾‹ 1ï¼š1(5, 3): 16711680 è¾“å…¥æ ·ä¾‹ 2ï¼š1234564 5 20 0 0 00 0 3 00 0 0 00 5 0 00 0 0 0 è¾“å‡ºæ ·ä¾‹ 2ï¼š1Not Unique è¾“å…¥æ ·ä¾‹ 3ï¼š12343 3 51 2 33 4 55 6 7 è¾“å‡ºæ ·ä¾‹ 3ï¼š1Not Exist é€šè¿‡ä»£ç 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;int main () { int m, n, t; cin &gt;&gt; n &gt;&gt; m &gt;&gt; t; int dot[1005][1005] = {0}; map&lt;int, int&gt; check; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { cin &gt;&gt; dot[i][j]; check[dot[i][j]]++; } } int count = 0, x, y; for (int i = 0; i &lt; m &amp;&amp; count &lt;= 1; i++) for (int j = 0; j &lt; n &amp;&amp; count &lt;= 1; j++) if (abs(dot[i][j] - dot[i + 1][j]) &gt; t &amp;&amp; abs(dot[i][j] - dot[i][j + 1]) &gt; t &amp;&amp; abs(dot[i][j] - dot[i - 1][j]) &gt; t &amp;&amp; abs(dot[i][j] - dot[i][j - 1]) &gt; t) if (abs(dot[i][j] - dot[i + 1][j + 1]) &gt; t &amp;&amp; abs(dot[i][j] - dot[i + 1][j - 1]) &gt; t &amp;&amp; abs(dot[i][j] - dot[i - 1][j + 1]) &gt; t &amp;&amp; abs(dot[i][j] - dot[i - 1][j - 1]) &gt; t) if (check[dot[i][j]] == 1) { count++; x = i; y = j; } if (count &gt; 1) cout &lt;&lt; &quot;Not Unique&quot; &lt;&lt; endl; else if (count == 1) cout &lt;&lt; &quot;(&quot; &lt;&lt; y + 1 &lt;&lt; &quot;, &quot; &lt;&lt; x + 1 &lt;&lt; &quot;): &quot; &lt;&lt; dot[x][y] &lt;&lt; endl; else cout &lt;&lt; &quot;Not Exist&quot; &lt;&lt; endl; return 0;} æ³¨æ„ æ³¨æ„ï¼Œæ»¡è¶³é¢˜ç›®æ¡ä»¶çš„ç‚¹å‡ºæ¥è¦å’Œå‘¨å›´8ä¸ªå·®è·å¤§äºtolä»¥å¤–ï¼Œè¿™ä¸ªç‚¹çš„æ•°å€¼åªèƒ½å‡ºç°ä¸€æ¬¡ ç”±äºæ•°å­—æœ€å¤§2^24ï¼Œintè¶³å¤Ÿ æ•°ç»„è¦å¤§äºè¾“å…¥çš„mï¼Œnï¼Œæœ€åä¸€ä¸ªæµ‹è¯•ç‚¹å’Œå€’æ•°ç¬¬äºŒä¸ªæµ‹è¯•ç‚¹å®¹æ˜“æŒ‚","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1068-%E4%B8%87%E7%BB%BF%E4%B8%9B%E4%B8%AD%E4%B8%80%E7%82%B9%E7%BA%A2(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1082","text":"é¢˜ç›® æœ¬é¢˜ç›®ç»™å‡ºçš„å°„å‡»æ¯”èµ›çš„è§„åˆ™éå¸¸ç®€å•ï¼Œè°æ‰“çš„å¼¹æ´è·ç¦»é¶å¿ƒæœ€è¿‘ï¼Œè°å°±æ˜¯å† å†›ï¼›è°å·®å¾—æœ€è¿œï¼Œè°å°±æ˜¯èœé¸Ÿã€‚æœ¬é¢˜ç»™å‡ºä¸€ç³»åˆ—å¼¹æ´çš„å¹³é¢åæ ‡(x,y)ï¼Œè¯·ä½ ç¼–å†™ç¨‹åºæ‰¾å‡ºå† å†›å’Œèœé¸Ÿã€‚æˆ‘ä»¬å‡è®¾é¶å¿ƒåœ¨åŸç‚¹(0,0)ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥åœ¨ç¬¬ä¸€è¡Œä¸­ç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤ 10 000ï¼‰ã€‚éšå N è¡Œï¼Œæ¯è¡ŒæŒ‰ä¸‹åˆ—æ ¼å¼ç»™å‡ºï¼š 1ID x y å…¶ä¸­ ID æ˜¯è¿åŠ¨å‘˜çš„ç¼–å·ï¼ˆç”± 4 ä½æ•°å­—ç»„æˆï¼‰ï¼›x å’Œ y æ˜¯å…¶æ‰“å‡ºçš„å¼¹æ´çš„å¹³é¢åæ ‡(x,y)ï¼Œå‡ä¸ºæ•´æ•°ï¼Œä¸” 0 â‰¤ |x|, |y| â‰¤ 100ã€‚é¢˜ç›®ä¿è¯æ¯ä¸ªè¿åŠ¨å‘˜çš„ç¼–å·ä¸é‡å¤ï¼Œä¸”æ¯äººåªæ‰“ 1 æªã€‚ è¾“å‡ºæ ¼å¼ï¼š è¾“å‡ºå† å†›å’Œèœé¸Ÿçš„ç¼–å·ï¼Œä¸­é—´ç©º 1 æ ¼ã€‚é¢˜ç›®ä¿è¯ä»–ä»¬æ˜¯å”¯ä¸€çš„ã€‚ è¾“å…¥æ ·ä¾‹ï¼š123430001 5 71020 -1 30233 0 -1 è¾“å‡ºæ ·ä¾‹ï¼š10233 0001 é€šè¿‡ä»£ç 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;struct shoot { int id; double x; double y; double len; };bool cmp(shoot&amp; a, shoot&amp; b) { return a.len &lt; b.len;}int main () { int n; cin &gt;&gt; n; shoot v[n]; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; v[i].id &gt;&gt; v[i].x &gt;&gt; v[i].y; v[i].len = sqrt(v[i].x * v[i].x + v[i].y * v[i].y); } sort(v, v + n, cmp); printf (&quot;%04d %04d\\n&quot;, v[0].id, v[n - 1].id); return 0;} æ€è·¯ä¸æ³¨æ„ æ²¡æœ‰éš¾åº¦ åæ€ä¸è¯„ä»· æ²¡æœ‰éš¾åº¦ é™„ï¼ˆåˆšå­¦Cä¸€ä¸ªæœˆæ—¶å†™çš„ä»£ç ï¼‰ï¼ˆå½“æ—¶ç»“æ„ä½“éƒ½ä¸ä¼šï¼‰123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt; bool find_max (double, double *, int);bool find_min (double, double *, int);int main () { int n; scanf (&quot;%d&quot;, &amp;n); int num[n] = {0}; double x = 0; double y = 0; double distance[n] = {0}; for (int i = 0; i &lt; n; i++) { scanf (&quot;%d%lf%lf&quot;, &amp;num[i], &amp;x, &amp;y); distance[i] = sqrt(x*x+ y*y); } //std::sort(distance, distance+n); int max_n = 0, min_n = 0; for (int i = 0; i &lt; n; i++) { if (find_max(distance[i], distance, n)) { max_n = i; } if (find_min(distance[i], distance, n)) { min_n = i; } } printf (&quot;%04d %04d&quot;, num[min_n], num[max_n]); return 0;}bool find_max (double a, double * arr, int len) { for (int i = 0; i &lt; len; i++) { if (a &gt;= arr[i]) { if (i == len - 1) { return true; } } else { break; } } return false;}bool find_min (double a, double * arr, int len) { for (int i = 0; i &lt; len; i++) { if (a &lt;= arr[i]) { if (i == len - 1) { return true; } } else { break; } } return false;}","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1082-%E5%B0%84%E5%87%BB%E6%AF%94%E8%B5%9B(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1086","text":"é¢˜ç›® åšä½œä¸šçš„æ—¶å€™ï¼Œé‚»åº§çš„å°ç›†å‹é—®ä½ ï¼šâ€œäº”ä¹˜ä»¥ä¸ƒç­‰äºå¤šå°‘ï¼Ÿâ€ä½ åº”è¯¥ä¸å¤±ç¤¼è²Œåœ°å›´ç¬‘ç€å‘Šè¯‰ä»–ï¼šâ€œäº”åä¸‰ã€‚â€æœ¬é¢˜å°±è¦æ±‚ä½ ï¼Œå¯¹ä»»ä½•ä¸€å¯¹ç»™å®šçš„æ­£æ•´æ•°ï¼Œå€’ç€è¾“å‡ºå®ƒä»¬çš„ä¹˜ç§¯ã€‚#### è¾“å…¥æ ¼å¼ï¼šè¾“å…¥åœ¨ç¬¬ä¸€è¡Œç»™å‡ºä¸¤ä¸ªä¸è¶…è¿‡ 1000 çš„æ­£æ•´æ•° A å’Œ Bï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚ è¾“å‡ºæ ¼å¼ï¼š åœ¨ä¸€è¡Œä¸­å€’ç€è¾“å‡º A å’Œ B çš„ä¹˜ç§¯ã€‚ è¾“å…¥æ ·ä¾‹ï¼š15 7 è¾“å‡ºæ ·ä¾‹ï¼š153 é€šè¿‡ä»£ç ï¼ˆæè‡´å‹è¡Œç‰ˆï¼‰123456789#include &lt;stdio.h&gt;int main () { int a, b; scanf (&quot;%d%d&quot;, &amp;a, &amp;b); int c = a * b; while (c &amp;&amp; c % 10 == 0)c /= 10;//å¿½ç•¥å‰å¯¼0ï¼Œab == 0åˆ™ä¸å¾ªç¯ do printf (&quot;%d&quot;, c % 10); while (c /= 10);//do-whileï¼Œå…ˆè¾“å‡ºï¼Œå†é™¤10ï¼Œab == 0åˆ™åªè¾“å‡ºä¸€ä¸ª0 return 0;} é€šè¿‡ä»£ç ï¼ˆæ­£å¸¸ç‰ˆï¼‰1234567891011121314#include &lt;stdio.h&gt;int main () { int a, b; scanf (&quot;%d%d&quot;, &amp;a, &amp;b); int c = a * b; while (c &amp;&amp; c % 10 == 0) { c /= 10; }//å¿½ç•¥å‰å¯¼0ï¼Œab == 0åˆ™ä¸å¾ªç¯ do { printf (&quot;%d&quot;, c % 10); c /= 10; } while (c);//do-whileï¼Œå…ˆè¾“å‡ºï¼Œå†é™¤10ï¼Œab == 0åˆ™åªè¾“å‡ºä¸€ä¸ª0 return 0;} æ€è·¯ä¸æ³¨æ„ ç®€å• åæ€ä¸è¯„ä»· ç®€å•","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1086-%E5%B0%B1%E4%B8%8D%E5%91%8A%E8%AF%89%E4%BD%A0(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1085","text":"é¢˜ç›® æ¯æ¬¡ PAT è€ƒè¯•ç»“æŸåï¼Œè€ƒè¯•ä¸­å¿ƒéƒ½ä¼šå‘å¸ƒä¸€ä¸ªè€ƒç”Ÿå•ä½æ’è¡Œæ¦œã€‚æœ¬é¢˜å°±è¯·ä½ å®ç°è¿™ä¸ªåŠŸèƒ½ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤10^5ï¼‰ï¼Œå³è€ƒç”Ÿäººæ•°ã€‚éšå N è¡Œï¼Œæ¯è¡ŒæŒ‰ä¸‹åˆ—æ ¼å¼ç»™å‡ºä¸€ä¸ªè€ƒç”Ÿçš„ä¿¡æ¯ï¼š 1å‡†è€ƒè¯å· å¾—åˆ† å­¦æ ¡ å…¶ä¸­å‡†è€ƒè¯å·æ˜¯ç”± 6 ä¸ªå­—ç¬¦ç»„æˆçš„å­—ç¬¦ä¸²ï¼Œå…¶é¦–å­—æ¯è¡¨ç¤ºè€ƒè¯•çš„çº§åˆ«ï¼šBä»£è¡¨ä¹™çº§ï¼ŒAä»£è¡¨ç”²çº§ï¼ŒTä»£è¡¨é¡¶çº§ï¼›å¾—åˆ†æ˜¯ [0, 100] åŒºé—´å†…çš„æ•´æ•°ï¼›å­¦æ ¡æ˜¯ç”±ä¸è¶…è¿‡ 6 ä¸ªè‹±æ–‡å­—æ¯ç»„æˆçš„å•ä½ç ï¼ˆå¤§å°å†™æ— å…³ï¼‰ã€‚æ³¨æ„ï¼šé¢˜ç›®ä¿è¯æ¯ä¸ªè€ƒç”Ÿçš„å‡†è€ƒè¯å·æ˜¯ä¸åŒçš„ã€‚ è¾“å‡ºæ ¼å¼ï¼š é¦–å…ˆåœ¨ä¸€è¡Œä¸­è¾“å‡ºå•ä½ä¸ªæ•°ã€‚éšåæŒ‰ä»¥ä¸‹æ ¼å¼éé™åºè¾“å‡ºå•ä½çš„æ’è¡Œæ¦œï¼š 1æ’å å­¦æ ¡ åŠ æƒæ€»åˆ† è€ƒç”Ÿäººæ•° å…¶ä¸­æ’åæ˜¯è¯¥å•ä½çš„æ’åï¼ˆä» 1 å¼€å§‹ï¼‰ï¼›å­¦æ ¡æ˜¯å…¨éƒ¨æŒ‰å°å†™å­—æ¯è¾“å‡ºçš„å•ä½ç ï¼›åŠ æƒæ€»åˆ†å®šä¹‰ä¸ºä¹™çº§æ€»åˆ†/1.5 + ç”²çº§æ€»åˆ† + é¡¶çº§æ€»åˆ†*1.5çš„æ•´æ•°éƒ¨åˆ†ï¼›è€ƒç”Ÿäººæ•°æ˜¯è¯¥å±äºå•ä½çš„è€ƒç”Ÿçš„æ€»äººæ•°ã€‚å­¦æ ¡é¦–å…ˆæŒ‰åŠ æƒæ€»åˆ†æ’è¡Œã€‚å¦‚æœ‰å¹¶åˆ—ï¼Œåˆ™åº”å¯¹åº”ç›¸åŒçš„æ’åï¼Œå¹¶æŒ‰è€ƒç”Ÿäººæ•°å‡åºè¾“å‡ºã€‚å¦‚æœä»ç„¶å¹¶åˆ—ï¼Œåˆ™æŒ‰å•ä½ç çš„å­—å…¸åºè¾“å‡ºã€‚ è¾“å…¥æ ·ä¾‹ï¼š123456789101110A57908 85 AuB57908 54 LanXA37487 60 auT28374 67 CMUT32486 24 hypuA66734 92 cmuB76378 71 AUA47780 45 lanxA72809 100 pkuA03274 45 hypu è¾“å‡ºæ ·ä¾‹ï¼š12345651 cmu 192 21 au 192 33 pku 100 14 hypu 81 24 lanx 81 2 é€šè¿‡ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct data { int count; double score;};typedef pair&lt;string, data&gt; PAIR;bool cmp(PAIR &amp;a, PAIR &amp;b) { //æ¯”è¾ƒï¼Œä¸‰ä¸ªæ’åºå…³é”®è¯ if (a.second.score != b.second.score) return a.second.score &gt; b.second.score; else if (a.second.count != b.second.count) return a.second.count &lt; b.second.count; else return a.first &lt; b.first;}void input(map&lt;string, data&gt; &amp;m) { //è¾“å…¥å¹¶è®¡ç®—åˆ†æ•° int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { string id, school; int score; cin &gt;&gt; id &gt;&gt; score &gt;&gt; school; transform(school.begin(), school.end(), school.begin(), ::tolower); //å˜æˆå°å†™ if (id[0] == 'B') m[school].score += score / 1.5; else if (id[0] == 'A') m[school].score += score; else if (id[0] == 'T') m[school].score += score * 1.5; m[school].count++; }}void mapToVector(map&lt;string, data&gt; &amp;m, vector&lt;PAIR&gt; &amp;v) { //æ”¾è¿›vectoræ¥åˆ©ç”¨sortæ’åº for (map&lt;string, data&gt;::iterator ite = m.begin(); ite != m.end(); ite++) { ite-&gt;second.score = floor(ite-&gt;second.score); //æ ¹æ®é¢˜æ„è¦floorå‘å·¦å–æ•´ v.push_back(*ite); }}void print(vector&lt;PAIR&gt; &amp;v) { //æŒ‰è¦æ±‚æ’åå¹¶è¾“å‡ºæ•°æ® cout &lt;&lt; v.size() &lt;&lt; endl; int now = v[0].second.score, r = 1; for (int i = 0; i &lt; v.size(); i++) { if (v[i].second.score != now) r = i + 1; cout &lt;&lt; r &lt;&lt; &quot; &quot; &lt;&lt; v[i].first &lt;&lt; &quot; &quot; &lt;&lt; v[i].second.score &lt;&lt; &quot; &quot; &lt;&lt; v[i].second.count &lt;&lt; endl; now = v[i].second.score; }}int main() { map&lt;string, data&gt; m; vector&lt;PAIR&gt; v; input(m); //è¾“å…¥å¹¶è®¡ç®—åˆ†æ•° mapToVector(m, v); //æ”¾è¿›vectoræ¥åˆ©ç”¨sortæ’åº sort(v.begin(), v.end(), cmp); //æ’åº print(v); //æŒ‰è¦æ±‚æ’åå¹¶è¾“å‡ºæ•°æ® return 0;} æ€è·¯ä¸æ³¨æ„ è¿™é“é¢˜ä¸ç”¨è€ƒè™‘åŒä¸€äººå‚ä¸å¤šåœºè€ƒè¯• ç”±äºä¸æƒ³å¤ªå¤šå˜é‡ï¼Œæ‰€ä»¥åªæœ‰ä¸€ä¸ªæ€»åˆ†å˜é‡ï¼Œæ‰€ä»¥è¦ç”¨doubleï¼Œæœ€åè¦floorå‘å·¦å–æ•´ã€‚ mapæ˜¯å…³è”å®¹å™¨ä¸èƒ½sortæ’åºï¼Œè¦æ”¾è¿›vectoré‡Œé¢å†æ’åº è¯¦è§PATä¹™çº§é¢˜â€“1080 MOOCæœŸç»ˆæˆç»©ï¼Œé‡Œé¢æœ‰å¯¹mapæ’åºçš„ç¬”è®° æ’åºçš„æ—¶å€™æ³¨æ„æœ‰ä¸‰ä¸ªå…³é”®è¯ï¼Œåˆ†æ•°ï¼ˆé™åºï¼‰ã€äººæ•°ï¼ˆå‡åºï¼‰å’Œå­¦æ ¡åç§°ï¼ˆASCIIå‡åºï¼‰ åˆ©ç”¨å¼•ç”¨ä¼ é€’å˜é‡ï¼Œæµ…æ‹·è´ï¼Œé¿å…æ·±æ‹·è´ å…³äºæ’åï¼Œæ€æƒ³æ˜¯ï¼šå…ˆæ’åºï¼Œæ’åºåï¼Œä»¤ä¸€ä¸ªå€¼nowä¸ºç¬¬ä¸€ä¸ªæ•°ï¼Œå¾ªç¯åªè¦æ˜¯å’Œç¬¬ä¸€ä¸ªæ•°ç›¸åŒçš„å°±è¿˜æ˜¯è¿™ä¸ªæ’åï¼Œä¸€æ—¦ä¸ç­‰ï¼Œè¯´æ˜åä¸€åå‡ºç°äº†ï¼Œè¿™æ˜¯è®©nowä¸ºå½“å‰è¿™ä¸ªæ•°ï¼Œç„¶åè®©æ’å = i+1ï¼ˆæ ¹æ®éœ€è¦ï¼Œæœ‰æ—¶æ˜¯æ’å++ï¼‰ã€‚åæ¥ä¸ºäº†å‹è¡Œï¼Œè¿›ä¸€æ­¥æç‚¼ï¼Œæ¯æ¬¡å¾ªç¯è®©now = v[i].second.scoreï¼Œå³è®©nowè®°å½•ä¸Šä¸€æ¬¡å¾ªç¯çš„å€¼ï¼Œæ¯”è¾ƒä¸ä¸Šæ¬¡å¾ªç¯çš„åˆ†æ•°æ˜¯å¦ç›¸åŒï¼Œç›¸åŒåˆ™æ’åç›¸åŒï¼Œä¸åŒåˆ™æ’åæŒ‰ç…§éœ€è¦æ”¹å˜ åæ€ä¸è¯„ä»· å¾ˆå¥½çš„åˆ©ç”¨äº†STLï¼Œå¸Œæœ›èƒ½å°½å¿«ç”¨çº¯Cå†™å‡ºæ¥ å¼€å¿ƒå˜¿å˜¿ï¼Œç»ˆäºè¿›å…¥å‰1000äº†ï¼ŒåŠ æ²¹ï¼è¿™ä¸ªå¯’å‡åˆ·å®Œä¹™çº§é¢˜ï¼","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1085-PAT%E5%8D%95%E4%BD%8D%E6%8E%92%E8%A1%8C(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1088","text":"é¢˜ç›® å­æ›°ï¼šâ€œä¸‰äººè¡Œï¼Œå¿…æœ‰æˆ‘å¸ˆç„‰ã€‚æ‹©å…¶å–„è€…è€Œä»ä¹‹ï¼Œå…¶ä¸å–„è€…è€Œæ”¹ä¹‹ã€‚â€ æœ¬é¢˜ç»™å®šç”²ã€ä¹™ã€ä¸™ä¸‰ä¸ªäººçš„èƒ½åŠ›å€¼å…³ç³»ä¸ºï¼šç”²çš„èƒ½åŠ›å€¼ç¡®å®šæ˜¯ 2 ä½æ­£æ•´æ•°ï¼›æŠŠç”²çš„èƒ½åŠ›å€¼çš„ 2 ä¸ªæ•°å­—è°ƒæ¢ä½ç½®å°±æ˜¯ä¹™çš„èƒ½åŠ›å€¼ï¼›ç”²ä¹™ä¸¤äººèƒ½åŠ›å·®æ˜¯ä¸™çš„èƒ½åŠ›å€¼çš„ X å€ï¼›ä¹™çš„èƒ½åŠ›å€¼æ˜¯ä¸™çš„ Y å€ã€‚è¯·ä½ æŒ‡å‡ºè°æ¯”ä½ å¼ºåº”â€œä»ä¹‹â€ï¼Œè°æ¯”ä½ å¼±åº”â€œæ”¹ä¹‹â€ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºä¸‰ä¸ªæ•°ï¼Œä¾æ¬¡ä¸ºï¼šMï¼ˆä½ è‡ªå·±çš„èƒ½åŠ›å€¼ï¼‰ã€X å’Œ Yã€‚ä¸‰ä¸ªæ•°å­—å‡ä¸ºä¸è¶…è¿‡ 1000 çš„æ­£æ•´æ•°ã€‚ è¾“å‡ºæ ¼å¼ï¼š åœ¨ä¸€è¡Œä¸­é¦–å…ˆè¾“å‡ºç”²çš„èƒ½åŠ›å€¼ï¼Œéšåä¾æ¬¡è¾“å‡ºç”²ã€ä¹™ã€ä¸™ä¸‰äººä¸ä½ çš„å…³ç³»ï¼šå¦‚æœå…¶æ¯”ä½ å¼ºï¼Œè¾“å‡º Congï¼›å¹³ç­‰åˆ™è¾“å‡º Pingï¼›æ¯”ä½ å¼±åˆ™è¾“å‡º Gaiã€‚å…¶é—´ä»¥ 1 ä¸ªç©ºæ ¼åˆ†éš”ï¼Œè¡Œé¦–å°¾ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚ æ³¨æ„ï¼šå¦‚æœè§£ä¸å”¯ä¸€ï¼Œåˆ™ä»¥ç”²çš„æœ€å¤§è§£ä¸ºå‡†è¿›è¡Œåˆ¤æ–­ï¼›å¦‚æœè§£ä¸å­˜åœ¨ï¼Œåˆ™è¾“å‡º No Solutionã€‚ è¾“å…¥æ ·ä¾‹ 1ï¼š48 3 7 è¾“å‡ºæ ·ä¾‹ 1ï¼š48 Ping Cong Gai è¾“å…¥æ ·ä¾‹ 2ï¼š48 11 6 è¾“å‡ºæ ·ä¾‹ 2ï¼šNo Solution 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.*;class Main { static Scanner sc; static { sc = new Scanner(System.in); } static String print(double a, double b) { if (a &lt; b) { return &quot;Cong&quot;; } else if (a == b) { return &quot;Ping&quot;; } else { return &quot;Gai&quot;; } } public static void main(String[] args) { int m = sc.nextInt(); int x = sc.nextInt(); int y = sc.nextInt(); boolean find = false; for (int a = 99; a &gt;= 10; a--) { double b = a % 10 * 10 + a / 10; double c = b / y; if (c != Math.abs((a - b) / x)) { continue; } else { find = true; System.out.print(a + &quot; &quot; + Main.print(m, a) + &quot; &quot; + Main.print(m, b) + &quot; &quot; + Main.print(m, c)); break; } } if (!find) { System.out.println(&quot;No Solution&quot;); } }}/* * a b c * c/x = a-b * c/y = b * c(1/x+1/y) = a * */ æ€è·¯ä¸æ³¨æ„ abc\bä¸‰ä¸ªå˜é‡ä»£è¡¨ç”²ä¹™ä¸™ï¼Œç”±äºaå·²çŸ¥æ˜¯ä¸¤ä½æ•°ï¼Œä¸”éœ€è¦\bè§£ä¸­ç”²æœ€å¤§çš„æƒ…å†µï¼Œæ‰€ä»¥å°±forå¾ªç¯ä»99åˆ°10 \b2. æ³¨æ„bï¼Œcè¦çš„æ˜¯ç²¾ç¡®å€¼ï¼Œä¸æ˜¯\bæ•´å‹å–å•†çš„ç»“æœ åæ€ä¸è¯„ä»·åæ€Â  Â  Â  Â å¥½åƒæ˜¯ä¸€éè¿‡çš„å§ï¼Ÿ è¯„ä»·Â  Â  Â  Â æ— ","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1088-%E4%B8%89%E4%BA%BA%E8%A1%8C(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1093","text":"é¢˜ç›® ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸² A å’Œ Bï¼Œæœ¬é¢˜è¦æ±‚ä½ è¾“å‡º A+Bï¼Œå³ä¸¤ä¸ªå­—ç¬¦ä¸²çš„å¹¶é›†ã€‚è¦æ±‚å…ˆè¾“å‡º Aï¼Œå†è¾“å‡º Bï¼Œä½†é‡å¤çš„å­—ç¬¦å¿…é¡»è¢«å‰”é™¤ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥åœ¨ä¸¤è¡Œä¸­åˆ†åˆ«ç»™å‡º A å’Œ Bï¼Œå‡ä¸ºé•¿åº¦ä¸è¶…è¿‡ 106çš„ã€ç”±å¯è§ ASCII å­—ç¬¦ (å³ç å€¼ä¸º32~126)å’Œç©ºæ ¼ç»„æˆçš„ã€ç”±å›è½¦æ ‡è¯†ç»“æŸçš„éç©ºå­—ç¬¦ä¸²ã€‚ è¾“å‡ºæ ¼å¼ï¼š åœ¨ä¸€è¡Œä¸­è¾“å‡ºé¢˜é¢è¦æ±‚çš„ A å’Œ B çš„å’Œã€‚ è¾“å…¥æ ·ä¾‹ï¼š12This is a sample testto show you_How it works è¾“å‡ºæ ·ä¾‹ï¼š1This ampletowyu_Hrk é€šè¿‡ä»£ç 123456789101112131415#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main () { char arr[128] = {0}; memset(arr, -1, sizeof(arr)); char c; while ((c = getchar()) != -1) { if (c == '\\n') continue; if (arr[c] == -1) { putchar(c); arr[c] = 1; } }} æ€è·¯ä¸æ³¨æ„ è§‚å¯Ÿè¾“å…¥ä¸è¾“å‡º æ¢è¡Œä¸è¾“å‡º æŸä¸ªå­—ç¬¦å¦‚æœå‰é¢å‡ºç°è¿‡ï¼Œå°±ä¸è¾“å‡º æä¸€ä¸ªæ•°ç»„ï¼ŒASCIIå€¼ä¸ºå¼•ç´¢ï¼Œåˆå§‹åŒ–ä¸º-1ï¼Œæ¯æ‰“ä¸€ä¸ªå­—ï¼ŒæŠŠå¯¹åº”çš„å€¼æ”¹æˆé-1çš„å€¼ æ³¨æ„è¦è®©ç¨‹åºç»“æŸï¼Œé€šè¿‡ç¬¬äºŒä¸ªå›è½¦åˆ¤æ–­ï¼Œæˆ–è€…EOF çš„-1åˆ¤æ–­","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1093-%E5%AD%97%E7%AC%A6%E4%B8%B2A+B(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1092","text":"é¢˜ç›® æœˆé¥¼æ˜¯ä¹…è´Ÿç››åçš„ä¸­å›½ä¼ ç»Ÿç³•ç‚¹ä¹‹ä¸€ï¼Œè‡ªå”æœä»¥æ¥ï¼Œå·²ç»å‘å±•å‡ºå‡ ç™¾å“ç§ã€‚ è‹¥æƒ³è¯„æ¯”å‡ºä¸€ç§â€œæœ€å¥½åƒâ€çš„æœˆé¥¼ï¼Œé‚£åŠ¿å¿…åœ¨åƒè´§ç•Œå¼•å‘ä¸€åœºè…¥é£è¡€é›¨â€¦â€¦ åœ¨è¿™é‡Œæˆ‘ä»¬ç”¨æ•°å­—è¯´è¯ï¼Œç»™å‡ºå…¨å›½å„åœ°å„ç§æœˆé¥¼çš„é”€é‡ï¼Œè¦æ±‚ä½ ä»ä¸­æ‰¾å‡ºé”€é‡å† å†›ï¼Œè®¤å®šä¸ºæœ€å¥½åƒçš„æœˆé¥¼ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥é¦–å…ˆç»™å‡ºä¸¤ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤1000ï¼‰å’Œ Mï¼ˆâ‰¤100ï¼‰ï¼Œåˆ†åˆ«ä¸ºæœˆé¥¼çš„ç§ç±»æ•°ï¼ˆäºæ˜¯é»˜è®¤æœˆé¥¼ç§ç±»ä» 1 åˆ° N ç¼–å·ï¼‰å’Œå‚ä¸ç»Ÿè®¡çš„åŸå¸‚æ•°é‡ã€‚æ¥ä¸‹æ¥ M è¡Œï¼Œæ¯è¡Œç»™å‡º N ä¸ªéè´Ÿæ•´æ•°ï¼ˆå‡ä¸è¶…è¿‡ 1 ç™¾ä¸‡ï¼‰ï¼Œå…¶ä¸­ç¬¬ i ä¸ªæ•´æ•°ä¸ºç¬¬ i ç§æœˆé¥¼çš„é”€é‡ï¼ˆå—ï¼‰ã€‚æ•°å­—é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚ è¾“å‡ºæ ¼å¼ï¼š åœ¨ç¬¬ä¸€è¡Œä¸­è¾“å‡ºæœ€å¤§é”€é‡ï¼Œç¬¬äºŒè¡Œè¾“å‡ºé”€é‡æœ€å¤§çš„æœˆé¥¼çš„ç§ç±»ç¼–å·ã€‚å¦‚æœå† å†›ä¸å”¯ä¸€ï¼Œåˆ™æŒ‰ç¼–å·é€’å¢é¡ºåºè¾“å‡ºå¹¶åˆ—å† å†›ã€‚æ•°å­—é—´ä»¥ 1 ä¸ªç©ºæ ¼åˆ†éš”ï¼Œè¡Œé¦–å°¾ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚ è¾“å…¥æ ·ä¾‹ï¼š5 3 1001 992 0 233 6 8 0 2018 0 2008 36 18 0 1024 4 è¾“å‡ºæ ·ä¾‹ï¼š2018 3 5 é€šè¿‡ä»£ç 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int main() { int n, m, max = -10000, count = 0, temp; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int sale[n] = {0}; for (int i = 0; i &lt; m - 1; i++) { for (int j = 0; j &lt; n; j++) { scanf(&quot;%d&quot;, &amp;temp); sale[j] += temp; } } for (int i = 0; i &lt; n; i++) { scanf(&quot;%d&quot;, &amp;temp); sale[i] += temp; if (sale[i] &gt; max) max = sale[i]; } printf(&quot;%d\\n&quot;, max); for (int i = 0; i &lt; n; i++) { if (sale[i] == max) { if (count++ == 0) printf(&quot;%d&quot;, i + 1); else printf(&quot;%s%d&quot;, &quot; &quot;, (i + 1)); } } return 0;} è¯„ä»·ä¸åæ€æ²¡æœ‰éš¾åº¦ï¼ŒæŒ‰ç…§é¢˜æ„ç»Ÿè®¡è®¡ç®—å°±å¥½","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1092-%E6%9C%80%E5%A5%BD%E5%90%83%E7%9A%84%E6%9C%88%E9%A5%BC(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1091","text":"é¢˜ç›® å¦‚æœæŸä¸ªæ•° K çš„å¹³æ–¹ä¹˜ä»¥ N ä»¥åï¼Œç»“æœçš„æœ«å°¾å‡ ä½æ•°ç­‰äº Kï¼Œé‚£ä¹ˆå°±ç§°è¿™ä¸ªæ•°ä¸ºâ€œN-è‡ªå®ˆæ•°â€ã€‚ä¾‹å¦‚ 3Ã—922 = 25392ï¼Œè€Œ 25392 çš„æœ«å°¾ä¸¤ä½æ­£å¥½æ˜¯ 92ï¼Œæ‰€ä»¥ 92 æ˜¯ä¸€ä¸ª 3-è‡ªå®ˆæ•°ã€‚ æœ¬é¢˜å°±è¯·ä½ ç¼–å†™ç¨‹åºåˆ¤æ–­ä¸€ä¸ªç»™å®šçš„æ•°å­—æ˜¯å¦å…³äºæŸä¸ª N æ˜¯ N-è‡ªå®ˆæ•°ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥åœ¨ç¬¬ä¸€è¡Œä¸­ç»™å‡ºæ­£æ•´æ•° Mï¼ˆâ‰¤20ï¼‰ï¼Œéšåä¸€è¡Œç»™å‡º M ä¸ªå¾…æ£€æµ‹çš„ã€ä¸è¶…è¿‡ 1000 çš„æ­£æ•´æ•°ã€‚ è¾“å‡ºæ ¼å¼ï¼š å¯¹æ¯ä¸ªéœ€è¦æ£€æµ‹çš„æ•°å­—ï¼Œå¦‚æœå®ƒæ˜¯ N-è‡ªå®ˆæ•°å°±åœ¨ä¸€è¡Œä¸­è¾“å‡ºæœ€å°çš„ N å’Œ NK^2 çš„å€¼ï¼Œä»¥ä¸€ä¸ªç©ºæ ¼éš”å¼€ï¼›å¦åˆ™è¾“å‡º Noã€‚æ³¨æ„é¢˜ç›®ä¿è¯ N&lt;10ã€‚ è¾“å…¥æ ·ä¾‹ï¼š3 92 5 233 è¾“å‡ºæ ·ä¾‹ï¼š3 25392 1 25 No é€šè¿‡ä»£ç 12345678910111213141516171819202122232425262728293031323334import java.util.*;class Main { static Scanner sc; static { sc = new Scanner(System.in); } public static void main(String[] args) { int n = sc.nextInt(); int arr = 0; for (int i = 0; i &lt; n; i++) { arr = sc.nextInt(); Integer temp = arr; int len = temp.toString().length(); boolean find = false; for (int j = 1; j &lt; 10; j++) { temp = arr * arr * j; String y = temp.toString().substring(temp.toString().length() - len, temp.toString().length()); temp = arr; if (y.equals(temp.toString())) { System.out.println(j + &quot; &quot; + arr * arr * j); find = true; break; } } if (!find) { System.out.println(&quot;No&quot;); } } }} é”™è¯¯åæ€ä¸ä»£ç è¯„ä»·é”™è¯¯åæ€å¥½åƒæ˜¯ä¸€éè¿‡çš„å§ï¼Ÿ ä»£ç è¯„ä»·javaçš„ç±»éƒ½æœ‰ä¸€ä¸ªtoStringæ–¹æ³•çœŸçš„è¶…çº§æ–¹ä¾¿å“¦ï¼Œç›´æ¥å¹³æ–¹ï¼Œèµ‹å€¼ç»™Integerè°ƒç”¨toStringå†æˆªå–åé¢ä¸€æ®µï¼Œè·ŸåŸæ¥çš„æ•°æ¯”è¾ƒï¼ŒSo easy!","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1091-N-%E8%87%AA%E5%AE%88%E6%95%B0(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1090","text":"é¢˜ç›® é›†è£…ç®±è¿è¾“è´§ç‰©æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»ç‰¹åˆ«å°å¿ƒï¼Œä¸èƒ½æŠŠä¸ç›¸å®¹çš„è´§ç‰©è£…åœ¨ä¸€åªç®±å­é‡Œã€‚æ¯”å¦‚æ°§åŒ–å‰‚ç»å¯¹ä¸èƒ½è·Ÿæ˜“ç‡ƒæ¶²ä½“åŒç®±ï¼Œå¦åˆ™å¾ˆå®¹æ˜“é€ æˆçˆ†ç‚¸ã€‚ æœ¬é¢˜ç»™å®šä¸€å¼ ä¸ç›¸å®¹ç‰©å“çš„æ¸…å•ï¼Œéœ€è¦ä½ æ£€æŸ¥æ¯ä¸€å¼ é›†è£…ç®±è´§å“æ¸…å•ï¼Œåˆ¤æ–­å®ƒä»¬æ˜¯å¦èƒ½è£…åœ¨åŒä¸€åªç®±å­é‡Œã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸¤ä¸ªæ­£æ•´æ•°ï¼šN (â‰¤104) æ˜¯æˆå¯¹çš„ä¸ç›¸å®¹ç‰©å“çš„å¯¹æ•°ï¼›M (â‰¤100) æ˜¯é›†è£…ç®±è´§å“æ¸…å•çš„å•æ•°ã€‚ éšåæ•°æ®åˆ†ä¸¤å¤§å—ç»™å‡ºã€‚ç¬¬ä¸€å—æœ‰ N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€å¯¹ä¸ç›¸å®¹çš„ç‰©å“ã€‚ç¬¬äºŒå—æœ‰ M è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ç®±è´§ç‰©çš„æ¸…å•ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š 1K G[1] G[2] ... G[K] å…¶ä¸­ K (â‰¤1000) æ˜¯ç‰©å“ä»¶æ•°ï¼ŒG[i] æ˜¯ç‰©å“çš„ç¼–å·ã€‚ç®€å•èµ·è§ï¼Œæ¯ä»¶ç‰©å“ç”¨ä¸€ä¸ª 5 ä½æ•°çš„ç¼–å·ä»£è¡¨ã€‚ä¸¤ä¸ªæ•°å­—ä¹‹é—´ç”¨ç©ºæ ¼åˆ†éš”ã€‚ è¾“å‡ºæ ¼å¼ï¼š å¯¹æ¯ç®±è´§ç‰©æ¸…å•ï¼Œåˆ¤æ–­æ˜¯å¦å¯ä»¥å®‰å…¨è¿è¾“ã€‚å¦‚æœæ²¡æœ‰ä¸ç›¸å®¹ç‰©å“ï¼Œåˆ™åœ¨ä¸€è¡Œä¸­è¾“å‡º Yesï¼Œå¦åˆ™è¾“å‡º Noã€‚ è¾“å…¥æ ·ä¾‹ï¼š123456789106 320001 2000220003 2000420005 2000620003 2000120005 2000420004 200064 00001 20004 00002 200035 98823 20002 20003 20006 100103 12345 67890 23333 è¾“å‡ºæ ·ä¾‹ï¼š123NoYesYes é€šè¿‡ä»£ç 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;int main() { int n, k; map&lt;int, vector&lt;int&gt;&gt; m; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 0; i &lt; n; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); m[x].push_back(y); m[y].push_back(x); } while (k--) { int K, has[100000] = {0}; scanf(&quot;%d&quot;, &amp;K); vector&lt;int&gt; v(K); for (int i = 0; i &lt; K; i++) { scanf(&quot;%d&quot;, &amp;v[i]); has[v[i]] = 1; } bool find = false; for (int i = 0; i &lt; v.size(); i++) for (int j = 0; j &lt; m[v[i]].size(); j++) if (has[m[v[i]][j]]) find = true; if (find) printf(&quot;No\\n&quot;); else printf (&quot;Yes\\n&quot;); } return 0;} æ€è·¯ä¸æ³¨æ„ æä¸€ä¸ªæ•°ç»„hasï¼Œç”¨idå½“å¼•ç´¢ï¼Œå‚¨å­˜æ˜¯å¦å­˜åœ¨è¿™ä¸ªç‰©å“ æä¸€ä¸ªmapæ˜ å°„ï¼Œä»idåˆ°ä¸€ä¸ªvectorï¼Œvectorä¸ºä¸è¿™ä¸ªç‰©å“ä¸å…±å­˜çš„ç‰©å“ç¼–å·ï¼ˆå¯èƒ½å­˜åœ¨å¤šä¸ªä¸å…±å­˜ç‰©ä½“ï¼‰ ä¸¤å±‚forå¾ªç¯ï¼Œåˆ©ç”¨hasæ•°ç»„ï¼Œè·Ÿè‡ªå·±ä¸å…±å­˜çš„ç‰©å“ç©¿ä¸Šæœ‰æ²¡æœ‰ï¼Œå¦‚æœæœ‰ï¼Œå°±ç»“æŸ åæ€ä¸è¯„ä»· è¿™é“é¢˜æœ¬èº«æƒ³ç”¨äºŒç»´æ•°ç»„è®°å½•æ˜¯å¦é…å¯¹ï¼Œè¿™æ ·å¤æ‚åº¦ä¸ºn * nï¼Œä¸€ç›´è¿‡ä¸äº† è¿™é“é¢˜æŒºæœ‰éš¾åº¦çš„ï¼Œä¹Ÿæ˜¯çœ‹äº†ç½‘ä¸Šçš„å¤§ç¥æ‰å†™å‡ºæ¥çš„","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1090-%E5%8D%B1%E9%99%A9%E5%93%81%E8%A3%85%E7%AE%B1(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1094","text":"é¢˜ç›® 2004 å¹´ 7 æœˆï¼Œè°·æ­Œåœ¨ç¡…è°·çš„ 101 å·å…¬è·¯è¾¹ç«–ç«‹äº†ä¸€å—å·¨å¤§çš„å¹¿å‘Šç‰Œï¼ˆå¦‚ä¸‹å›¾ï¼‰ç”¨äºæ‹›è˜ã€‚å†…å®¹è¶…çº§ç®€å•ï¼Œå°±æ˜¯ä¸€ä¸ªä»¥ .com ç»“å°¾çš„ç½‘å€ï¼Œè€Œå‰é¢çš„ç½‘å€æ˜¯ä¸€ä¸ª 10 ä½ç´ æ•°ï¼Œè¿™ä¸ªç´ æ•°æ˜¯è‡ªç„¶å¸¸æ•° e ä¸­æœ€æ—©å‡ºç°çš„ 10 ä½è¿ç»­æ•°å­—ã€‚èƒ½æ‰¾å‡ºè¿™ä¸ªç´ æ•°çš„äººï¼Œå°±å¯ä»¥é€šè¿‡è®¿é—®è°·æ­Œçš„è¿™ä¸ªç½‘ç«™è¿›å…¥æ‹›è˜æµç¨‹çš„ä¸‹ä¸€æ­¥ã€‚ è‡ªç„¶å¸¸æ•° e æ˜¯ä¸€ä¸ªè‘—åçš„è¶…è¶Šæ•°ï¼Œå‰é¢è‹¥å¹²ä½å†™å‡ºæ¥æ˜¯è¿™æ ·çš„ï¼še = 2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427427466391932003059921â€¦ å…¶ä¸­ç²—ä½“æ ‡å‡ºçš„ 10 ä½æ•°å°±æ˜¯ç­”æ¡ˆã€‚ æœ¬é¢˜è¦æ±‚ä½ ç¼–ç¨‹è§£å†³ä¸€ä¸ªæ›´é€šç”¨çš„é—®é¢˜ï¼šä»ä»»ä¸€ç»™å®šçš„é•¿åº¦ä¸º L çš„æ•°å­—ä¸­ï¼Œæ‰¾å‡ºæœ€æ—©å‡ºç°çš„ K ä½è¿ç»­æ•°å­—æ‰€ç»„æˆçš„ç´ æ•°ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥åœ¨ç¬¬ä¸€è¡Œç»™å‡º 2 ä¸ªæ­£æ•´æ•°ï¼Œåˆ†åˆ«æ˜¯ Lï¼ˆä¸è¶…è¿‡ 1000 çš„æ­£æ•´æ•°ï¼Œä¸ºæ•°å­—é•¿åº¦ï¼‰å’Œ Kï¼ˆå°äº 10 çš„æ­£æ•´æ•°ï¼‰ã€‚æ¥ä¸‹æ¥ä¸€è¡Œç»™å‡ºä¸€ä¸ªé•¿åº¦ä¸º L çš„æ­£æ•´æ•° Nã€‚ è¾“å‡ºæ ¼å¼ï¼š åœ¨ä¸€è¡Œä¸­è¾“å‡º N ä¸­æœ€æ—©å‡ºç°çš„ K ä½è¿ç»­æ•°å­—æ‰€ç»„æˆçš„ç´ æ•°ã€‚å¦‚æœè¿™æ ·çš„ç´ æ•°ä¸å­˜åœ¨ï¼Œåˆ™è¾“å‡º 404ã€‚æ³¨æ„ï¼ŒåŸå§‹æ•°å­—ä¸­çš„å‰å¯¼é›¶ä¹Ÿè®¡ç®—åœ¨ä½æ•°ä¹‹å†…ã€‚ä¾‹å¦‚åœ¨ 200236 ä¸­æ‰¾ 4 ä½ç´ æ•°ï¼Œ0023 ç®—æ˜¯è§£ï¼›ä½†ç¬¬ä¸€ä½ 2 ä¸èƒ½è¢«å½“æˆ 0002 è¾“å‡ºï¼Œå› ä¸ºåœ¨åŸå§‹æ•°å­—ä¸­ä¸å­˜åœ¨è¿™ä¸ª 2 çš„å‰å¯¼é›¶ã€‚ è¾“å…¥æ ·ä¾‹ 1ï¼š1220 523654987725541023819 è¾“å‡ºæ ·ä¾‹ 1ï¼š149877 è¾“å…¥æ ·ä¾‹ 2ï¼š1210 32468024680 è¾“å‡ºæ ·ä¾‹ 2ï¼š1404 é€šè¿‡ä»£ç 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;bool isPrime[10] = {false, false, true, true, false, true, false, true, false};bool Prime(int i) { if (i &lt; 9 &amp;&amp; i &gt;= 0) return isPrime[i]; if (i % 2 == 0) return false; else for (int j = 3; j * j &lt;= i; j += 2)//åªèƒ½&gt;=9çš„å¥‡æ•° if (i % j == 0) return false; return true;}int main () { int a, b; string bf; bool ok = false; cin &gt;&gt; a &gt;&gt; b &gt;&gt; bf; for (int i = 0; i &lt;= a - b; i++) { string n = bf.substr(i, b); int x = atoi(n.data()); if (Prime(x)) { printf (&quot;%s\\n&quot;, n.data()); ok = true; break; } } if (!ok) printf (&quot;404\\n&quot;); return 0;} æ€è·¯ä¸æ³¨æ„ æŒ‰ç…§é¢˜æ„ç®—å°±å¯ä»¥ï¼Œæ³¨æ„éœ€è¦åˆ¤æ–­å“ªä¸ªæ˜¯ç´ æ•°å†ç®—å“ªä¸ª åæ€ä¸è¯„ä»· è¿™é“é¢˜ä¸éš¾ï¼Œä½†æ˜¯å†™äº†ä¸€ä¸ªä¸‹åˆï¼Œå› ä¸ºè„‘è¢‹å¾ˆè½´ï¼Œéè¦æŠŠæ‰€æœ‰0~`999999999`çš„ç´ æ•°å…¨ç®—å‡ºæ¥","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1094-%E8%B0%B7%E6%AD%8C%E7%9A%84%E6%8B%9B%E8%81%98(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1081","text":"é¢˜ç›® æœ¬é¢˜è¦æ±‚ä½ å¸®åŠ©æŸç½‘ç«™çš„ç”¨æˆ·æ³¨å†Œæ¨¡å—å†™ä¸€ä¸ªå¯†ç åˆæ³•æ€§æ£€æŸ¥çš„å°åŠŸèƒ½ã€‚è¯¥ç½‘ç«™è¦æ±‚ç”¨æˆ·è®¾ç½®çš„å¯†ç å¿…é¡»ç”±ä¸å°‘äº6ä¸ªå­—ç¬¦ç»„æˆï¼Œå¹¶ä¸”åªèƒ½æœ‰è‹±æ–‡å­—æ¯ã€æ•°å­—å’Œå°æ•°ç‚¹ .ï¼Œè¿˜å¿…é¡»æ—¢æœ‰å­—æ¯ä¹Ÿæœ‰æ•°å­—ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤ 100ï¼‰ï¼Œéšå N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä¸ªç”¨æˆ·è®¾ç½®çš„å¯†ç ï¼Œä¸ºä¸è¶…è¿‡ 80 ä¸ªå­—ç¬¦çš„éç©ºå­—ç¬¦ä¸²ï¼Œä»¥å›è½¦ç»“æŸã€‚ è¾“å‡ºæ ¼å¼ï¼š å¯¹æ¯ä¸ªç”¨æˆ·çš„å¯†ç ï¼Œåœ¨ä¸€è¡Œä¸­è¾“å‡ºç³»ç»Ÿåé¦ˆä¿¡æ¯ï¼Œåˆ†ä»¥ä¸‹5ç§ï¼š å¦‚æœå¯†ç åˆæ³•ï¼Œè¾“å‡ºYour password is wan mei.ï¼› å¦‚æœå¯†ç å¤ªçŸ­ï¼Œä¸è®ºåˆæ³•ä¸å¦ï¼Œéƒ½è¾“å‡ºYour password is tai duan le.ï¼› å¦‚æœå¯†ç é•¿åº¦åˆæ³•ï¼Œä½†å­˜åœ¨ä¸åˆæ³•å­—ç¬¦ï¼Œåˆ™è¾“å‡ºYour password is tai luan le.ï¼› å¦‚æœå¯†ç é•¿åº¦åˆæ³•ï¼Œä½†åªæœ‰å­—æ¯æ²¡æœ‰æ•°å­—ï¼Œåˆ™è¾“å‡ºYour password needs shu zi.ï¼› å¦‚æœå¯†ç é•¿åº¦åˆæ³•ï¼Œä½†åªæœ‰æ•°å­—æ²¡æœ‰å­—æ¯ï¼Œåˆ™è¾“å‡ºYour password needs zi mu.ã€‚ è¾“å…¥æ ·ä¾‹ï¼š1234565123szheshi.wodepw1234.5678WanMei23333pass*word.6 è¾“å‡ºæ ·ä¾‹ï¼š12345Your password is tai duan le.Your password needs shu zi.Your password needs zi mu.Your password is wan mei.Your password is tai luan le. é€šè¿‡ä»£ç 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int main () { string pwd; getline(cin, pwd); while (getline(cin, pwd)) { if (pwd.length() &gt;= 6) { bool alpha = false, num = false, dot = false, other = false; for (int i = 0; i &lt; pwd.length(); i++) { if (isalpha(pwd[i])) alpha = true; else if (isdigit(pwd[i])) num = true; else if (pwd[i] == '.') dot = true; else other = true; } if (!other &amp;&amp; alpha &amp;&amp; num) cout &lt;&lt; &quot;Your password is wan mei.&quot; &lt;&lt; endl; else if (other) cout &lt;&lt; &quot;Your password is tai luan le.&quot; &lt;&lt; endl; else if (!num &amp;&amp; alpha) cout &lt;&lt; &quot;Your password needs shu zi.&quot; &lt;&lt; endl; else if (num &amp;&amp; !alpha) cout &lt;&lt; &quot;Your password needs zi mu.&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;Your password is tai duan le.&quot; &lt;&lt; endl; } } return 0;}","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1081-%E6%A3%80%E6%9F%A5%E5%AF%86%E7%A0%81(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1095","text":"é¢˜ç›® PAT å‡†è€ƒè¯å·ç”± 4 éƒ¨åˆ†ç»„æˆï¼š ç¬¬ 1 ä½æ˜¯çº§åˆ«ï¼Œå³ T ä»£è¡¨é¡¶çº§ï¼›A ä»£è¡¨ç”²çº§ï¼›B ä»£è¡¨ä¹™çº§ï¼› ç¬¬ 2~4 ä½æ˜¯è€ƒåœºç¼–å·ï¼ŒèŒƒå›´ä» 101 åˆ° 999ï¼› ç¬¬ 5~10 ä½æ˜¯è€ƒè¯•æ—¥æœŸï¼Œæ ¼å¼ä¸ºå¹´ã€æœˆã€æ—¥é¡ºæ¬¡å„å  2 ä½ï¼› æœ€å 11~13 ä½æ˜¯è€ƒç”Ÿç¼–å·ï¼ŒèŒƒå›´ä» 000 åˆ° 999ã€‚ ç°ç»™å®šä¸€ç³»åˆ—è€ƒç”Ÿçš„å‡†è€ƒè¯å·å’Œä»–ä»¬çš„æˆç»©ï¼Œè¯·ä½ æŒ‰ç…§è¦æ±‚è¾“å‡ºå„ç§ç»Ÿè®¡ä¿¡æ¯ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥é¦–å…ˆåœ¨ä¸€è¡Œä¸­ç»™å‡ºä¸¤ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤104ï¼‰å’Œ Mï¼ˆâ‰¤100ï¼‰ï¼Œåˆ†åˆ«ä¸ºè€ƒç”Ÿäººæ•°å’Œç»Ÿè®¡è¦æ±‚çš„ä¸ªæ•°ã€‚ æ¥ä¸‹æ¥ N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä¸ªè€ƒç”Ÿçš„å‡†è€ƒè¯å·å’Œå…¶åˆ†æ•°ï¼ˆåœ¨åŒºé—´ [0,100] å†…çš„æ•´æ•°ï¼‰ï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚ è€ƒç”Ÿä¿¡æ¯ä¹‹åï¼Œå†ç»™å‡º M è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä¸ªç»Ÿè®¡è¦æ±‚ï¼Œæ ¼å¼ä¸ºï¼šç±»å‹ æŒ‡ä»¤ï¼Œå…¶ä¸­ ç±»å‹ ä¸º 1 è¡¨ç¤ºè¦æ±‚æŒ‰åˆ†æ•°éå‡åºè¾“å‡ºæŸä¸ªæŒ‡å®šçº§åˆ«çš„è€ƒç”Ÿçš„æˆç»©ï¼Œå¯¹åº”çš„ æŒ‡ä»¤ åˆ™ç»™å‡ºä»£è¡¨æŒ‡å®šçº§åˆ«çš„å­—æ¯ï¼› ç±»å‹ ä¸º 2 è¡¨ç¤ºè¦æ±‚å°†æŸæŒ‡å®šè€ƒåœºçš„è€ƒç”Ÿäººæ•°å’Œæ€»åˆ†ç»Ÿè®¡è¾“å‡ºï¼Œå¯¹åº”çš„ æŒ‡ä»¤ åˆ™ç»™å‡ºæŒ‡å®šè€ƒåœºçš„ç¼–å·ï¼› ç±»å‹ ä¸º 3 è¡¨ç¤ºè¦æ±‚å°†æŸæŒ‡å®šæ—¥æœŸçš„è€ƒç”Ÿäººæ•°åˆ†è€ƒåœºç»Ÿè®¡è¾“å‡ºï¼Œå¯¹åº”çš„ æŒ‡ä»¤ åˆ™ç»™å‡ºæŒ‡å®šæ—¥æœŸï¼Œæ ¼å¼ä¸å‡†è€ƒè¯ä¸Šæ—¥æœŸç›¸åŒã€‚ è¾“å‡ºæ ¼å¼ï¼š å¯¹æ¯é¡¹ç»Ÿè®¡è¦æ±‚ï¼Œé¦–å…ˆåœ¨ä¸€è¡Œä¸­è¾“å‡º Case #: è¦æ±‚ï¼Œå…¶ä¸­ # æ˜¯è¯¥é¡¹è¦æ±‚çš„ç¼–å·ï¼Œä» 1 å¼€å§‹ï¼›è¦æ±‚ å³å¤åˆ¶è¾“å…¥ç»™å‡ºçš„è¦æ±‚ã€‚éšåè¾“å‡ºç›¸åº”çš„ç»Ÿè®¡ç»“æœï¼š ç±»å‹ ä¸º 1 çš„æŒ‡ä»¤ï¼Œè¾“å‡ºæ ¼å¼ä¸è¾“å…¥çš„è€ƒç”Ÿä¿¡æ¯æ ¼å¼ç›¸åŒï¼Œå³ å‡†è€ƒè¯å· æˆç»©ã€‚å¯¹äºåˆ†æ•°å¹¶åˆ—çš„è€ƒç”Ÿï¼ŒæŒ‰å…¶å‡†è€ƒè¯å·çš„å­—å…¸åºé€’å¢è¾“å‡ºï¼ˆé¢˜ç›®ä¿è¯æ— é‡å¤å‡†è€ƒè¯å·ï¼‰ï¼› ç±»å‹ ä¸º 2 çš„æŒ‡ä»¤ï¼ŒæŒ‰ äººæ•° æ€»åˆ† çš„æ ¼å¼è¾“å‡ºï¼› ç±»å‹ ä¸º 3 çš„æŒ‡ä»¤ï¼Œè¾“å‡ºæŒ‰äººæ•°éé€’å¢é¡ºåºï¼Œæ ¼å¼ä¸º è€ƒåœºç¼–å· æ€»äººæ•°ã€‚è‹¥äººæ•°å¹¶åˆ—åˆ™æŒ‰è€ƒåœºç¼–å·é€’å¢é¡ºåºè¾“å‡ºã€‚ å¦‚æœæŸ¥è¯¢ç»“æœä¸ºç©ºï¼Œåˆ™è¾“å‡º NAã€‚ è¾“å…¥æ ·ä¾‹ï¼š123456789101112138 4B123180908127 99B102180908003 86A112180318002 98T107150310127 62A107180908108 100T123180908010 78B112160918035 88A107180908021 981 A2 1073 1809082 999 è¾“å‡ºæ ·ä¾‹ï¼š123456789101112Case 1: 1 AA107180908108 100A107180908021 98A112180318002 98Case 2: 2 1073 260Case 3: 3 180908107 2123 2102 1Case 4: 2 999NA é€šè¿‡ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#define map unordered_map#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct POS { int Num = 0; int Score = 0;};struct STU { string id; int score;};typedef pair&lt;string, POS&gt; PAIR;map&lt;string, POS&gt; Pos;map&lt;char, vector&lt;STU&gt;&gt; type;map&lt;string, POS&gt; PosWithTime;vector&lt;PAIR&gt; vPosWithTime;void update(STU* ob) { string pos = ob-&gt;id.substr(1, 3); Pos[pos].Num++; Pos[pos].Score += ob-&gt;score; pos = ob-&gt;id.substr(1, 9); PosWithTime[pos].Num++; PosWithTime[pos].Score++; type[ob-&gt;id[0]].push_back(*ob);}bool cmp1(STU&amp; a, STU&amp; b) { return (a.score != b.score ? a.score &gt; b.score : a.id &lt; b.id);}bool cmp2(PAIR&amp; a, PAIR&amp; b) { return (a.second.Num != b.second.Num ? a.second.Num &gt; b.second.Num : a.first &lt; b.first);}void final() { for (map&lt;char, vector&lt;STU&gt;&gt;::iterator ite = type.begin(); ite != type.end(); ite++) sort(ite-&gt;second.begin(), ite-&gt;second.end(), cmp1); for (map&lt;string, POS&gt;::iterator ite = PosWithTime.begin(); ite != PosWithTime.end(); ite++) vPosWithTime.push_back(*ite); sort(vPosWithTime.begin(), vPosWithTime.end(), cmp2);}int one(int num) { char grade; cin &gt;&gt; grade; printf(&quot;Case %d: 1 %c\\n&quot;, num, grade); vector&lt;STU&gt;&amp; temp = type[grade]; if (!temp.size()) return 1; for (int i = 0; i &lt; temp.size(); i++) printf(&quot;%s %d\\n&quot;, temp[i].id.data(), temp[i].score); return 0;}int two(int num) { string pos; cin &gt;&gt; pos; printf(&quot;Case %d: 2 %s\\n&quot;, num, pos.data()); POS&amp; temp = Pos[pos]; if (!temp.Num) return 1; printf(&quot;%d %d\\n&quot;, temp.Num, temp.Score); return 0;}int three(int num) { string date; cin &gt;&gt; date; printf(&quot;Case %d: 3 %s\\n&quot;, num, date.data()); int n = 0; for (vector&lt;PAIR&gt;::iterator ite = vPosWithTime.begin(); ite != vPosWithTime.end(); ite++) { if (ite-&gt;first.substr(3, 6) == date) { printf(&quot;%s %d\\n&quot;, ite-&gt;first.substr(0, 3).data(), ite-&gt;second.Num); n++; } } if (!n) return 1; return 0;}int main() { int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); STU temp; for (int i = 0; i &lt; n; i++) { char str[1024]; scanf (&quot;%s%d&quot;, str, &amp;temp.score); temp.id = str; update(&amp;temp); } final(); for (int i = 0; i &lt; m; i++) { int ins, result; scanf (&quot;%d&quot;, &amp;ins); getchar(); if (ins == 1) result = one(i + 1); else if (ins == 2) result = two(i + 1); else result = three(i + 1); if (result) printf(&quot;NA\\n&quot;); } return 0;} æ€è·¯ä¸æ³¨æ„ å»ºç«‹ä¸¤ä¸ªç»“æ„ä½“ è€ƒåœºPOSï¼Œå‚¨å­˜è€ƒåœºäººæ•°Numï¼Œæ‰€æœ‰äººçš„æ€»åˆ†Score å­¦ç”ŸSTUï¼Œå‚¨å­˜è€ƒå·idï¼Œåˆ†æ•°score å»ºç«‹ä¸‰ä¸ªæ˜ å°„map Posè€ƒåœºå·ï¼ˆstringï¼‰-&gt;è€ƒåœºï¼ˆPOSï¼‰ï¼Œç»™ç¬¬äºŒä¸ªåŠŸèƒ½ç”¨çš„ï¼Œå¼•ç´¢æ˜¯è€ƒåœºå· typeç­‰çº§ï¼ˆcharï¼‰-&gt;å­¦ç”Ÿï¼ˆSTUï¼‰å‘é‡ï¼ˆvectorï¼‰ï¼Œæ¯ä¸ªç­‰çº§å¯¹åº”ä¸€ä¸ªvector PosWithTimeè€ƒåœºå·+æ—¶é—´ï¼ˆstringï¼‰-&gt;è€ƒåœºï¼ˆPOSï¼‰ï¼Œå¼•ç´¢æ˜¯è€ƒåœº+æ—¶é—´ï¼Œè¿™æ ·å¯ä»¥ä¿è¯æ˜¯æŸä¸€å¤©çš„æŸæ•™å®¤çš„äººæ•°ã€‚ ä¸å•ç‹¬åˆ›å»ºvectorå‚¨å­˜å­¦ç”Ÿä¿¡æ¯ï¼Œæ¯æ¬¡è¾“å…¥åï¼Œåˆ©ç”¨updata()å‡½æ•°ï¼Œå‘ä»¥ä¸Šä¸‰ä¸ªæ˜ å°„mapä¸­æ›´æ–°æ•°æ®ï¼ˆå¢åŠ POS çš„Scoreã€æŸä¸€ç­‰çº§çš„å­¦ç”Ÿä¿¡æ¯ï¼‰ æœ€åä¸€æ¬¡æ€§æŠŠæ‰€æœ‰æ•°æ®å…¨éƒ¨æ’å¥½åºï¼ˆåˆ©ç”¨final()å‡½æ•°ï¼‰ï¼ˆvPosWithTimeå°±æ˜¯ä¸ºäº†ç»™PosWithTimeæ’åºçš„ï¼‰ï¼ˆtypeè¿™ä¸ªmapä¸­çš„æ‰€æœ‰vectoræŒ‰ç…§è¦æ±‚æ’åºï¼‰ï¼Œé˜²æ­¢æ•°æ®åå¤æ‹·è´ã€éå†ã€‚ æ¯ä¸ªåŠŸèƒ½ä¸€ä¸ªå‡½æ•°ï¼Œè®¡ç®—è¾“å‡º ä½¿ç”¨printfå’Œscanfï¼Œé˜²æ­¢åä¸¤ä¸ªæµ‹è¯•ç‚¹è¶…æ—¶ åæ€ä¸è¯„ä»·è¿™é“é¢˜å†™äº†ä¸€ä¸‹åˆï¼Œä¸»è¦çŠ¯äº†ä»¥ä¸‹é”™è¯¯ é€»è¾‘é—®é¢˜ã€‚å¯¹äºç±»å‹äºŒçš„è¾“å‡ºï¼Œæ²¡æœ‰è€ƒè™‘åˆ°ä¸€é—´è€ƒåœºå¯ä»¥å¯¹åº”å¤šåœºè€ƒè¯•ã€‚åˆšå¼€å§‹æƒ³è¦ç”¨ç±»ï¼Œæä¸€ä¸ªç±»çš„é™æ€å˜é‡ï¼ˆä»è€ƒåœºå·åˆ°è€ƒåœºç»“æ„ä½“å˜é‡çš„mapæ˜ å°„ï¼‰ï¼Œåœ¨ä¸€éè¾“å…¥ï¼Œä¸€è¾¹æ„é€ äº†å¯¹è±¡ï¼Œå°±åˆ©ç”¨è¯¥å¯¹è±¡çš„æ•°æ®è¿›è¡Œåˆ†æï¼Œç„¶åç»Ÿè®¡ã€‚è¿™æ—¶çŠ¯äº†é€»è¾‘é”™è¯¯ï¼Œè®¤ä¸ºè¿™ä¸ªmapç»Ÿè®¡çš„è€ƒç”Ÿæ•°å°±æ˜¯æŸä¸€å¤©çš„è€ƒç”Ÿæ•°ã€‚æœ¬åœ°è¿è¡Œçš„æ—¶å€™ä¹Ÿæ²¡æ³¨æ„æ£€æŸ¥ã€‚ é˜…è¯»é—®é¢˜ã€‚è¿™ä¸¤é“é¢˜çš„æœ€åä¸¤ä¸ªæµ‹è¯•ç‚¹ä¸€ç›´è¶…æ—¶ï¼ˆä¹‹å‰ä½¿ç”¨cinï¼Œcoutçš„æ—¶å€™ï¼‰ï¼Œç„¶åå»çœ‹äº†csdnä¸Šä¸€ä½å¤§ä½¬çš„ä»£ç ã€‚æ²¡å‘ç°è·Ÿè‡ªå·±çš„ç®—æ³•çš„åŒºåˆ«ã€‚åæ¥ä»”ç»†è¯»äº†TAçš„æ–‡ç« åï¼Œæ‰ååº”è¿‡æ¥æ˜¯ç”±äºcinå’Œcoutçš„å·´æ‹‰å·´æ‹‰å·´æ‹‰çš„åŸå› ã€‚ç„¶åæˆ‘æŠŠæ‰€æœ‰çš„cinå’Œcoutæ¢æˆprintfå’Œscanfï¼Œå°±ä¸è¶…æ—¶äº†ã€‚ çœŸÂ·çœŸå¼€å¿ƒï¼ï¼ˆä¸è®¤è¯†â€œçœŸâ€äº†ï¼‰","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1095-%E8%A7%A3%E7%A0%81PAT%E5%87%86%E8%80%83%E8%AF%81(PAT-(Basic-Level)-Practice)/"},{"title":"gallery","text":".galleria{ width: 100%; height: 100vh; } (function() { Galleria.loadTheme('https://cdnjs.cloudflare.com/ajax/libs/galleria/1.5.7/themes/classic/galleria.classic.min.js'); Galleria.run('.galleria', { extend: function() { var gallery = this; // \"this\" is the gallery instance $('.galleria').click(function() { console.log(\"click\"); gallery.playToggle(1000).toggleFullscreen(); // call the play method }); } }); }());","link":"/home/2024/04/23/gallery/index/"},{"title":"MIUISupermarketç§»æ¤","text":"VerifyError1java.lang.VerifyError: Verifier rejected class com.xiaomi.market.util.UIUtils: void com.xiaomi.market.util.UIUtils.setStatusBarDarkMode(android.app.Activity, boolean) failed to verify: void com.xiaomi.market.util.UIUtils.setStatusBarDarkMode(android.app.Activity, boolean): [0x15] type Undefined unexpected as arg to if-eqz/if-nez (declaration of 'com.xiaomi.market.util.UIUtils' appears in /data/app/~~pH0reBrzyfvMag1T-TAoDw==/com.xiaomi.market-EzZXS_MznmhQs5NCCbvqfA==/base.apk!classes2.dex) ä¸€èˆ¬å‡ºç°VerifyErroréƒ½æ˜¯å› ä¸ºå¯¹smaliä»£ç ä¿®æ”¹ï¼Œå¯¼è‡´æ— æ³•é€šè¿‡éªŒè¯ã€‚å½“å‰é‡åˆ°è¿‡çš„æƒ…å†µæœ‰ï¼š æ’å…¥ä»£ç æ—¶æ— æ„è¦†ç›–äº†ä¸‹é¢ä¼šç”¨åˆ°çš„å¯„å­˜å™¨çš„å€¼ï¼Œå¯¼è‡´å¯„å­˜å™¨ç±»å‹ä¸åŒ¹é…ç­‰é—®é¢˜ã€‚ å¯¹æ–¹æ³•å‚æ•°ç±»å‹ä¿®æ”¹ä½†æœªä¿®æ”¹è°ƒç”¨æ—¶ä¼ å…¥çš„å‚æ•° ä¼ é€’å‚æ•°æ—¶ä¼ é€’äº†ç±»å‹ä¸åŒ¹é…çš„å‚æ•° ClassNotFoundåœ¨xiaomiå•†åº—ä¸­ä½¿ç”¨äº†Lmiui/os/Buildç±»ï¼Œè¯¥ç±»ç»§æ‰¿Landroid/os/Buildï¼Œä¸”å­˜åœ¨äºå°ç±³ç³»ç»Ÿä¸­ï¼Œå¯¼è‡´ç±»æ‰¾ä¸åˆ°ã€‚å¯¼è‡´è¿è¡Œæ—¶é—ªé€€ã€‚ å¯¹äºè¿™ç±»å°ç±³ç³»ç»Ÿä¸­æ‰èƒ½è·å–åˆ°çš„ç±»ï¼Œé‡‡ç”¨ç­‰ä»·æ›¿æ¢çš„æ–¹æ³•è¿›è¡Œä¿®å¤ã€‚å¦‚åœ¨Lmiui/os/Buildä¸­æœ‰ï¼š IS_INTERNATIONAL_BUILD IS_ALPHA_BUILD IS_DEVELOPMENT_VERSION IS_INTERNATIONAL_BUILD getRegion()ç­‰å­—æ®µå’Œæ–¹æ³•ï¼Œå¯ä»¥åœ¨miuiä¸­æŸ¥çœ‹ä¸€ä¸‹å¯¹åº”çš„å€¼ï¼Œç„¶åæ‰‹åŠ¨ä¿®æ”¹smaliä»£ç ï¼Œå°†å€¼æ›¿æ¢ä¸ºå¯¹åº”çš„å€¼ã€‚ Dexæ–¹æ³•æ•°é™åˆ¶1org.jf.util.ExceptionWithContext: Error while writing instruction at code offset 0x2 åœ¨apktoolsæ‰“åŒ…smaliæ—¶æŠ¥é”™ï¼Œå¯¹smaliä¿®æ”¹æ—¶æ·»åŠ äº†å¾ˆå¤šæ–¹æ³•ï¼Œå¯¼è‡´ä¸€ä¸ªdexå†…æ–¹æ³•æ•°è¶…è¿‡65,535ï¼Œå¯¼è‡´æ‰“åŒ…å¤±è´¥ã€‚ è§£å†³æ–¹æ³•ï¼šåœ¨smaliæºç ç›®å½•ä¸­æ–°å»ºæ–‡sources_dex${n}ç›®å½•ï¼Œå°†ä»£ç æ”¾å…¥è¯¥ä½ç½®ï¼Œé‡æ–°ç¼–è¯‘ï¼Œå³å¯å°†ä»£ç æ‰“åŒ…å…¥æ–°çš„dexæ–‡ä»¶ä¸­ã€‚ åº”ç”¨æ— æ³•å®‰è£…MIUIé­”æ”¹äº†PackageInstallerå½“ä½¿ç”¨packageinstallerè·å–sessionå†™å…¥å®‰è£…åŒ…åï¼Œä½¿ç”¨commitä¼ å…¥ä¸€ä¸ªPendingIntentå¯¹è±¡ï¼Œç”¨äºæ¥æ”¶åº”ç”¨å®‰è£…ç»“æœçš„å¹¿æ’­ã€‚è€Œè¯¥é€šçŸ¥çš„å†…å®¹è¢«é­”æ”¹ï¼Œå¯¼è‡´æ”¶åˆ°åŸç”Ÿç³»ç»Ÿçš„å¹¿æ’­æ—¶ï¼Œæ— æ³•æ­£ç¡®å¤„ç†åç»­çš„é€»è¾‘ï¼Œå¯¼è‡´å®‰è£…å¤±è´¥ã€‚ ä¸­é—´è¿˜å°è¯•è¿‡ä½¿ç”¨ACTION_VIEWæˆ–ACTION_INSTALL_PACKAGEstartActivityå¯åŠ¨å®‰è£…å™¨ï¼Œä½†è¿™ä¸¤ä¸ªACTIONåœ¨å®‰å“10åè¢«åºŸå¼ƒäº†ï¼Œå¯¼è‡´æ²¡æœ‰Activityå“åº”è¯¥Intentï¼Œæ— æ³•è¿›è¡Œå®‰è£…ã€‚ ä½¿ç”¨ACTIONå®‰è£…apkæ—¶ï¼Œå¦‚æœapkæ–‡ä»¶åœ¨ç§æœ‰å­˜å‚¨ç©ºé—´å†…ï¼Œè¦ä½¿ç”¨FileProviderã€‚ æœªè§£å†³çš„é—®é¢˜ æ— æ³•å¸è½½ æ— æ³•æš‚åœä»»åŠ¡ å®‰è£…åæ²¡æœ‰è°ƒç”¨sessionçš„abandon()æ–¹æ³• é¦–é¡µé¡¶éƒ¨æ ‡é¢˜æ ä¸ç³»ç»ŸçŠ¶æ€æ ä¹‹é—´å­˜åœ¨ç©ºç™½éƒ¨åˆ† å¦å¤–ä¸­é—´è¿˜æœ‰ä¸€ä¸ªMIUISettingsProviderçš„ç±»æ‰¾ä¸åˆ°ï¼Œæˆ‘å½“æ—¶ç›´æ¥æŠŠmiuiä¸­çš„SettingsProvideræ›¿æ¢åˆ°PixelOSçš„SettingsProviderä¸­ï¼Œå¯¼æ‰‹æœºè‡´å˜ç –ï¼Œæ•‘ç –æ•‘äº†å¥½ä¹…ã€‚","link":"/home/2024/07/13/misc/MIUISupermarket%E7%A7%BB%E6%A4%8D/"},{"title":"qq.md","text":"æˆ‘çš„QQ123&quot;&quot;&quot; -... .- . -.. --. .... -.-. .--- -... -...&quot;&quot;&quot;","link":"/home/2022/10/22/social/qq/"},{"title":"cè¯­è¨€å‡½æ•°ç»˜å›¾","text":"ä»£ç  github 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402#define _XOPEN_SOURCE 500#define _C99_SOURCE#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;stdbool.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdarg.h&gt;#include &lt;float.h&gt;//#define LOG_LEVEL DEBUG_LOG#define DEBUG_LOG 7#define INFO_LOG 5#define ERR_LOG 4#ifndef LOG_LEVEL#define LOG_LEVEL INFO_LOG#endif#ifndef GREATER_CHAR#define GREATER_CHAR ' '#endif#ifndef SMALLER_CHAR#define SMALLER_CHAR '+'#endifvoid logger(int level, const char *format, ...) { if(level &gt; LOG_LEVEL) return; va_list args; va_start(args, format); int len = vsnprintf(NULL, 0, format, args)+1; va_end(args); va_start(args, format); char *str = malloc(len); vsprintf(str, format, args); va_end(args); fprintf(stderr, &quot;%s\\n&quot;, str); free(str);}double x1, x2, _y1, _y2, s1, s2;#define PUSH(s, n) (s[s##_ptr++] = (n))#define POP(s, n) (n = s[--s##_ptr])#define TOP(s, n) (n = s[s##_ptr-1])#define EMPTY(s) (s##_ptr == 0)enum { op_acos = 48, op_asin , op_atan , op_cos , op_cosh , op_sin , op_sinh , op_tan , op_tanh , op_exp , op_log , op_floor , op_sqrt , op_fabs , op_ceil};const static int op_min = op_acos;const static int op_max = op_ceil;static double stack[1024];static char op_stack[1024];static int priv[128] = { [0 ... 39] = 0, ['('] = 1, [')'] = 2, ['*'] = 3, ['+'] = 2, [44] = 0, ['-'] = 2, [46] = 0, ['/'] = 3, [48 ... 93] = 0, ['^'] = 4, [95 ... 127] = 0};static int stack_ptr = 0;static int op_stack_ptr = 0;void logStack() { logger(DEBUG_LOG, &quot;op_stack: &quot;); for(int cnt = 0; cnt &lt; op_stack_ptr; cnt++) { logger(DEBUG_LOG, &quot;%c &quot;, op_stack[cnt]); } logger(DEBUG_LOG, &quot;stack: &quot;); for(int cnt = 0; cnt &lt; stack_ptr; cnt++) { logger(DEBUG_LOG, &quot;%lf &quot;, stack[cnt]); } logger(DEBUG_LOG, &quot;&quot;);}void biCheck() { if(EMPTY(stack)) { logger(ERR_LOG, &quot;empty stack!&quot;); exit(1); }}void pushOP(char cur_op) { double n1, n2; char op; while(!EMPTY(op_stack) &amp;&amp; priv[TOP(op_stack, op)] &gt;= priv[cur_op]) { POP(op_stack, op); double res = 0; POP(stack, n2); if(!EMPTY(stack))POP(stack, n1); else n1 = 0; switch(op) { case '+': res = n1 + n2; break; case '-': res = n1 - n2; break; case '*': res = n1 * n2; break; case '/': if(n2 == 0) { logger(ERR_LOG, &quot;divisor is zeor!&quot;);// exit(1); } res = n1 / n2; break; case '^': res = pow(n1, n2); break; default: break; } PUSH(stack, res); }}int len_strncmp(const char *a, const char *b) { return strncmp(a, b, strlen(b));}double eval(double y, double x, const char *expr) { int len = strlen(expr); int i = 0; stack_ptr = 0; op_stack_ptr = 0; while(i &lt; len) { switch(expr[i]) { case '^': biCheck(); pushOP(expr[i]); // if(EMPTY(stack)) PUSH(stack, 0); PUSH(op_stack, expr[i]); break; case 'x': case 'X': PUSH(stack, x); break; case 'y': case 'Y': PUSH(stack, y); break; case '(': PUSH(op_stack, '('); break; case ')': { double n1, n2; char op; if(EMPTY(op_stack)) { logger(ERR_LOG, &quot;no match ')'&quot;); exit(1); } pushOP(')'); POP(op_stack, op); if(TOP(op_stack, op) &gt;= op_min &amp;&amp; TOP(op_stack, op) &lt;= op_max) { POP(op_stack, op); double n; if(!EMPTY(stack)) { POP(stack, n); } else { logger(ERR_LOG, &quot;Error : no opvalue&quot;); exit(1); } double (*op_func)(double); switch(op) { case op_acos: if(n &gt; 1 || n &lt; -1) return DBL_MAX; op_func = acos; break; case op_asin: if(n &gt; 1 || n &lt; -1) return DBL_MAX; op_func = asin; break; case op_atan: op_func = atan; break; case op_cos: op_func = cos; break; case op_cosh: op_func = cosh; break; case op_sin: op_func = sin; break; case op_sinh: op_func = sinh; break; case op_tan: op_func = tan; break; case op_tanh: op_func = tanh; break; case op_exp: op_func = exp; break; case op_log: if(n &lt; 0) return DBL_MAX; op_func = log; break; case op_sqrt: if(n &lt; 0) return DBL_MAX; op_func = sqrt; break; case op_fabs: op_func = fabs; break; case op_ceil: op_func = ceil; break; case op_floor: op_func = floor; break; } PUSH(stack, op_func(n)); } } break; case '+':case '-': { if((i &gt; 0 &amp;&amp; expr[i-1] != '(')) { // fixï¼š a-(-b) // if stack is empty or last op is '(', â€˜-â€™ is an Unary operator // else it's a Binary operator biCheck(); pushOP(expr[i]); } else { PUSH(stack, 0); } PUSH(op_stack, expr[i]); } break; case '*': case '/': biCheck(); pushOP(expr[i]); // if(EMPTY(stack)) PUSH(stack, 0); PUSH(op_stack, expr[i]); break; case 'p': // p1 = 3.14 if(i + 1 &lt; len &amp;&amp; expr[i + 1] == 'i') { PUSH(stack, M_PI); i++; } else { logger(ERR_LOG, &quot;Error 'pi': unknown char(%c)&quot;, expr[i]); exit(1); } break; case 'e': // e = 2.7 PUSH(stack, M_E); break; case '0':case '1':case '2':case '3':case '4':case '5':case '6':case '7':case '8':case '9':case '.': { double n = 0; double n1 = 1; while(i &lt; len) { if(expr[i] &lt; '0' || expr[i] &gt; '9') { break; } n *= 10; n += expr[i] - '0'; i++; } if(expr[i] == '.') { i++; while(i &lt; len &amp;&amp; expr[i] != '.') { if(expr[i] &lt; '0' || expr[i] &gt; '9') { break; } n1 /= 10.0; n += n1 * (expr[i] - '0'); i++; } }if(expr[i] == '.') { logger(ERR_LOG, &quot;error : two '.' in one number&quot;); exit(1); } PUSH(stack, n); i--; } break; default: if(!len_strncmp(expr + i, &quot;ACOS&quot;)) { PUSH(op_stack, op_acos); i+=3; } else if(!len_strncmp(expr + i, &quot;ASIN&quot;)) { PUSH(op_stack, op_asin); i+=3; } else if(!len_strncmp(expr + i, &quot;ATAN&quot;)) { PUSH(op_stack, op_atan); i+=3; } else if(!len_strncmp(expr + i, &quot;COS&quot;)) { if(expr[i+3] == 'H') { PUSH(op_stack, op_cosh); i+=3; } else { PUSH(op_stack, op_cos); i+=2; } } else if(!len_strncmp(expr + i, &quot;SIN&quot;)) { if(expr[i+3] == 'H') { PUSH(op_stack, op_sinh); i+=3; } else { PUSH(op_stack, op_sin); i+=2; } } else if(!len_strncmp(expr + i, &quot;TAN&quot;)) { if(expr[i+3] == 'H') { PUSH(op_stack, op_tanh); i+=3; } else { PUSH(op_stack, op_tan); i+=2; } } else if(!len_strncmp(expr + i, &quot;EXP&quot;)) { PUSH(op_stack, op_exp); i+=2; } else if(!len_strncmp(expr + i, &quot;LOG&quot;)) { PUSH(op_stack, op_log); i+=2; } else if(!len_strncmp(expr + i, &quot;SQRT&quot;)) { PUSH(op_stack, op_sqrt); i+=3; } else if(!len_strncmp(expr + i, &quot;FABS&quot;)) { PUSH(op_stack, op_fabs); i+=3; } else if(!len_strncmp(expr + i, &quot;CEIL&quot;)) { PUSH(op_stack, op_ceil); i+=3; } else if(!len_strncmp(expr + i, &quot;FLOOR&quot;)) { PUSH(op_stack, op_floor); i+=4; } else { logger(ERR_LOG, &quot;Error: unknown char(%c)&quot;, expr[i]); exit(1); } break; } i++; logStack(); } biCheck(); pushOP(0); logStack(); return stack[0];}void INIT(char **argv) { int i = 0; _y1 = eval(0, 0, argv[i++]); _y2 = eval(0, 0, argv[i++]); s1 = eval(0, 0, argv[i++]); x1 = eval(0, 0, argv[i++]); x2 = eval(0, 0, argv[i++]); s2 = eval(0, 0, argv[i++]); logger(DEBUG_LOG, &quot;%lf, %lf, %lf, %lf, %lf, %lf\\n&quot;, _y1, _y2, s1, x1, x2, s2);}int main(int argc, char **argv) { if(argc &lt; 8) { logger(INFO_LOG, &quot;Usage: %s y1 y2 sy x1 x2 sy expression&quot;, argv[0]); logger(INFO_LOG, &quot;example: %s -1 1 0.125 -1 1 0.0625 \\&quot;x*x+y*y-1\\&quot; 2&gt;errs.log&quot;, argv[0]); logger(INFO_LOG, &quot;example: %s \\&quot;-pi/2\\&quot; \\&quot;pi/2\\&quot; 0.25 \\&quot;-3*pi\\&quot; \\&quot;2*pi\\&quot; 0.125 \\&quot;y^2-SIN(x+y)^2\\&quot; 2&gt;errs.log&quot;, argv[0]); logger(INFO_LOG, &quot;example: %s \\&quot;-pi/2\\&quot; \\&quot;pi/2\\&quot; 0.25 \\&quot;-3*pi\\&quot; \\&quot;2*pi\\&quot; 0.125 \\&quot;y^2-SIN(x)^2\\&quot; 2&gt;errs.log&quot;, argv[0]); logger(INFO_LOG, &quot;example: %s \\&quot;-2\\&quot; \\&quot;ACOS(1/2)-pi/4\\&quot; 0.125 \\&quot;-pi/2\\&quot; \\&quot;pi/2\\&quot; 0.0625 \\&quot;y*y+x*x+y-SQRT(y*y+x*x)\\&quot; 2&gt;errs.log&quot;, argv[0]); logger(INFO_LOG, &quot;example: %s \\&quot;-pi\\&quot; \\&quot;1\\&quot; 0.125 \\&quot;-2\\&quot; \\&quot;2\\&quot; 0.0625 \\&quot;(ACOS(1-FABS(x))-pi)-y\\&quot; \\&quot;y-SQRT(1-(FABS(x)-1)^2)\\&quot; 2&gt;errs.log&quot;, argv[0]); logger(INFO_LOG, &quot;example: %s \\&quot;-1\\&quot; \\&quot;pi/2\\&quot; 0.125 \\&quot;-1\\&quot; \\&quot;1\\&quot; 0.0625 \\&quot;x*x+(y-FABS(x)^(2.0/3.0))^2-1\\&quot; 2&gt;errs.log&quot;, argv[0]); exit(0); } INIT(argv + 1); for(double i = _y2; i &gt;= _y1; ) { for(double j = x1; j &lt;= x2; ) { logger(DEBUG_LOG, &quot;x = %lf, y = %lf&quot;, j, i); bool ok = true; for(char **expr = argv + 7; *expr; expr++) { if(eval(i, j, *expr) &gt;= 0) { ok = false; break; } } if(ok) { printf(&quot;%c&quot;, SMALLER_CHAR); } else { printf(&quot;%c&quot;, GREATER_CHAR); } j+=s2; } printf(&quot;\\n&quot;); i-=s1; }} exampleåœ†1234567891011121314151617..........................................+++++++++++++++...............+++++++++++++++++++++..........+++++++++++++++++++++++++.......+++++++++++++++++++++++++++.....+++++++++++++++++++++++++++++...+++++++++++++++++++++++++++++++..+++++++++++++++++++++++++++++++..+++++++++++++++++++++++++++++++..+++++++++++++++++++++++++++++++..+++++++++++++++++++++++++++++++...+++++++++++++++++++++++++++++.....+++++++++++++++++++++++++++.......+++++++++++++++++++++++++..........+++++++++++++++++++++...............+++++++++++++++.......................................... ç³–è‘«èŠ¦12345678910111213............................................................................................................................................................................................................................................................................................................................................................................................+++++++++................+++++++++................++++++++++...............++++++++++...............++++++++++...............+++++++++++++++..........+++++++++++++++..........+++++++++++++++..........++++++++++++++++.........++++++++++++++++..........+++++++++++++++++++......++++++++++++++++++++.....++++++++++++++++++++.....++++++++++++++++++++.....++++++++++++++++++++......+++++++++++++++++++++++..++++++++++++++++++++++++.++++++++++++++++++++++++.++++++++++++++++++++++++.++++++++++++++++++++++++....+++++++++++++++++++++++...++++++++++++++++++++++...++++++++++++++++++++++...++++++++++++++++++++++...++++++++++++++++++++++.......+++++++++++++++++++.......++++++++++++++++++.......++++++++++++++++++.......++++++++++++++++++.......++++++++++++++++++............+++++++++++++............+++++++++++++............+++++++++++++............+++++++++++++............++++++++++++++.................+++++++...................++++++...................++++++...................++++++...................++++++.............................................................................................................................................................................................................................................................. è¿™ä¸ªæ‰‹æœºä¸Šçš„mathlabéƒ½ç”»ä¸äº† ç³–è‘«èŠ¦112345678910111213..................................................................................................................................................................................................................................................................................................................................................................................................++++++++++...............++++++++++...............++++++++++................+++++++++................+++++++++.............++++++++++++++++.........++++++++++++++++..........+++++++++++++++..........+++++++++++++++..........+++++++++++++++........++++++++++++++++++++.....++++++++++++++++++++.....++++++++++++++++++++......+++++++++++++++++++......++++++++++++++++++++...++++++++++++++++++++++++.++++++++++++++++++++++++.++++++++++++++++++++++++.++++++++++++++++++++++++..++++++++++++++++++++++++..++++++++++++++++++++++...++++++++++++++++++++++...++++++++++++++++++++++...+++++++++++++++++++++++..+++++++++++++++++++++++.....++++++++++++++++++.......++++++++++++++++++.......++++++++++++++++++.......++++++++++++++++++........++++++++++++++++++.........++++++++++++++............+++++++++++++............+++++++++++++............+++++++++++++............+++++++++++++................++++++...................++++++...................++++++...................++++++....................++++++..................................................................................................................................................................................................................................................................... ç¬›å¡å°”å¿ƒ12345678910111213141516171819...............................................................++++++++++++...++++++++++++......................+++++++++++++++++++++++++++++++..................+++++++++++++++++++++++++++++++++++...............+++++++++++++++++++++++++++++++++++++.............+++++++++++++++++++++++++++++++++++++++...........+++++++++++++++++++++++++++++++++++++++++..........+++++++++++++++++++++++++++++++++++++++++..........+++++++++++++++++++++++++++++++++++++++++..........+++++++++++++++++++++++++++++++++++++++++..........+++++++++++++++++++++++++++++++++++++++++...........+++++++++++++++++++++++++++++++++++++++.............++++++++++++++++++++++++++++++++++++++..............++++++++++++++++++++++++++++++++++++................+++++++++++++++++++++++++++++++++....................++++++++++++++++++++++++++++++.......................+++++++++++++++++++++++++.............................+++++++++++++++++++.......................................+++++....................... å¿ƒ12345678910111213141516171819202122232425262728293031323334..........................................................................+++++++++++++++.................+++++++++++++++...............+++++++++++++++++++++...........+++++++++++++++++++++..........+++++++++++++++++++++++++.......+++++++++++++++++++++++++.......+++++++++++++++++++++++++++.....+++++++++++++++++++++++++++.....+++++++++++++++++++++++++++++...+++++++++++++++++++++++++++++...+++++++++++++++++++++++++++++++.+++++++++++++++++++++++++++++++..+++++++++++++++++++++++++++++++.+++++++++++++++++++++++++++++++..+++++++++++++++++++++++++++++++.+++++++++++++++++++++++++++++++..+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++..+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++...+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++....+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++......+++++++++++++++++++++++++++++++++++++++++++++++++++++++++.........+++++++++++++++++++++++++++++++++++++++++++++++++++++++...........+++++++++++++++++++++++++++++++++++++++++++++++++++++..............+++++++++++++++++++++++++++++++++++++++++++++++++..................+++++++++++++++++++++++++++++++++++++++++++++.....................+++++++++++++++++++++++++++++++++++++++++++........................+++++++++++++++++++++++++++++++++++++++............................+++++++++++++++++++++++++++++++++++................................+++++++++++++++++++++++++++++++....................................+++++++++++++++++++++++++++........................................+++++++++++++++++++++++............................................+++++++++++++++++++................................................+++++++++++++++....................................................+++++++++++.......................................................+++++++++.........................................................+++++++...........................................................+++++.............................................................+++...............................................................+................................................................+................................................................+................................ è¿˜æ˜¯å¿ƒ123456789101112131415161718192021....................................++++++++...........++++++++.....+++++++++++.......+++++++++++...++++++++++++++...++++++++++++++..+++++++++++++++.+++++++++++++++..+++++++++++++++++++++++++++++++..+++++++++++++++++++++++++++++++..+++++++++++++++++++++++++++++++...+++++++++++++++++++++++++++++....+++++++++++++++++++++++++++++.....+++++++++++++++++++++++++++.......+++++++++++++++++++++++++.........+++++++++++++++++++++++............+++++++++++++++++++...............+++++++++++++++++.................+++++++++++++++....................+++++++++++.......................+++++++++..........................+++++.............................+++...............................+................ ä¹å¿ƒè¿ç 12345678N=5size=1for i in `seq $N`; do ./a.out &quot;-pi&quot; &quot;1&quot; 0.04 &quot;-2/$size&quot; &quot;2/$size&quot; 0.02 &quot;(ACOS(1-FABS($size*x))-pi)-$size*y&quot; &quot;$size*y-SQRT(1-(FABS($size*x)-1)^2)&quot; 2&gt;errs.log 1&gt;out.$i size=$(echo &quot;scale = 8; $size * sqrt(2)&quot; | bc) echo $sizedonepaste `for i in $(seq $N | tr ' ' '\\n'| tac | tr '\\n' ' '); do echo out.$i; done;for i in $(seq 2 $N); do echo out.$i; done` &gt; out.paste 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 +++++++++++++++++++++++ +++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++ ++++++ +++++++ ++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++ ++++++ +++++++ ++++++++++++++++++++ ++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++ ++++++++++++++++++++ +++++++++++++++++++++++++++ +++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++ +++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++ +++++++++++++ ++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++ +++++++++++++ +++++++++++++ ++++++++++++++++++++ ++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++ ++++++++++++++++++++ +++++++ ++++++ ++++++++++++++++++++++++ +++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++ +++++++++++++++++++++++++ +++++++ ++++++ ++++++++++++++ ++++++++++++++ ++++++++++++++++++++++++++++ +++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++ +++++++++++++++++++++++++++ ++++++++++++++ ++++++++++++++ ++++++++ +++++++ +++++++++++++++++++ ++++++++++++++++++ ++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++ +++++++++++++++++++ ++++++++++++++++++ ++++++++ +++++++ +++++++++++++ +++++++++++++ +++++++++++++++++++++ +++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++ +++++++++++++++++++++ +++++++++++++++++++++ +++++++++++++ +++++++++++++ +++++++++++++++ +++++++++++++++ +++++++++++++++++++++++ ++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++ +++++++++++++++++++++++ ++++++++++++++++++++++ +++++++++++++++ +++++++++++++++ +++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++ +++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++ ++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++ ++++++++++++++++++ ++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++ ++++++++++++++++++ ++++++++++++++ +++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++ ++++++++++++++ ++++++++++ ++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++ ++++++++++ ++++++ ++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++ ++++++ ++++ ++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++ ++++ ++ ++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++ ++ ++++++++++++ ++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++ ++++++++++++ ++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ ++++++++ ++++++ ++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++ ++++++ ++++ ++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++ ++++ ++ ++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++ ++ +++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++ ++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++ ++++++++++ ++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++ ++++++++++ ++++++++ ++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++ ++++++++ ++++++ ++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++ ++++++ ++++ ++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ ++++ ++ +++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++ ++ + +++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++ + +++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++ ++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++ +++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++ ++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++ +++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++ +++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++ +++++ ++++++++++++++++++++++++++++++++++++++++++++++ +++++ +++ ++++++++++++++++++++++++++++++++++++++++++ +++ ++ +++++++++++++++++++++++++++++++++++++++ ++ + +++++++++++++++++++++++++++++++++++ + + ++++++++++++++++++++++++++++++++ + ++++++++++++++++++++++++++++ +++++++++++++++++++++++++ ++++++++++++++++++++++ +++++++++++++++++++ ++++++++++++++++ ++++++++++++++ ++++++++++++ ++++++++++ ++++++++ ++++++ ++++ +++ ++ + æ”¯æŒç”Ÿæˆpngæ”¯æŒç”Ÿæˆå›¾ç‰‡ï¼Œç²¾ç¡®åº¦å¤§å¤§æé«˜äº†ï¼Œå¯ä»¥è€ƒè™‘ç»˜åˆ¶æ›²çº¿è€Œä¸æ˜¯åŒºåŸŸäº† è®¾ç½®ä¸€ä¸ªç²¾ç¡®åº¦ï¼Œè®¡ç®—ç»“æœç»å¯¹å€¼å°äºä»–çš„éƒ½è¢«è®¤ä¸ºæ˜¯0ï¼Œå°±å¯ä»¥ç”»æ›²çº¿äº† é—®é¢˜1$y-sqrt(x)=0$åœ¨$x=0$é™„è¿‘æ–­æ–­ç»­ç»­ å®é™…ä¸Šæ˜¯è¿™ä¸ªåœ°æ–¹å˜åŒ–ç‡å¤ªé«˜ï¼Œxã€yçš„è½»å¾®å˜åŒ–å¯¼è‡´è¶…å‡ºäº†ç²¾ç¡®åº¦ï¼Œæœ‰äº›åœ°æ–¹$\\frac{dz}{dy}$è¿‡å¤§è€Œ$\\frac{dz}{dx}$ä¸å¤§æ—¶ï¼ˆæˆ–äºŒè€…éƒ½å¾ˆå¤§æ—¶ï¼‰ï¼Œä¹Ÿä¼šæ–­æ–­ç»­ç»­ï¼Œç„¶è€Œå½“è®¡ç®—æ—¶çš„xyåæ ‡é€‰å–åœ¨å½“å‰åƒç´ ç‚¹å†…çš„æŸä¸ªä½ç½®æ—¶ï¼Œå¯èƒ½å°±å¯ä»¥å°äºç²¾ç¡®åº¦ã€‚ä»¤$z=y-sqrt(x)$ï¼Œåˆ†åˆ«è®¡ç®—zå¯¹xï¼Œyçš„åå¯¼ï¼Œè®¡ç®—ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘çš„å–æœ€å¤§å€¼ã€‚è®¡ç®—ç‚¹$(x+i/max(\\frac{dz}{dx},\\frac{dz}{dy}),y+i/max(\\frac{dz}{dx},\\frac{dz}{dy}))$å¤„çš„å‡½æ•°å€¼ï¼Œè‹¥å°äºç²¾ç¡®åº¦ï¼Œå¯¹è¯¥åƒç´ ç‚¹ç»˜åˆ¶ï¼Œå¦åˆ™ä¸ç»˜åˆ¶å…¶ä¸­$1&lt;i&lt;max(\\frac{dz}{dx},\\frac{dz}{dy})$ é—®é¢˜2åœ¨æŸäº›æ›²çº¿çš„äº¤ç‚¹å¤„ï¼Œå¦‚$y^2-sin(x)^2=0$ï¼Œå½“$x=k*pi$æ—¶ï¼Œçº¿æ¡å¾ˆç²— å®é™…ä¸Šæ˜¯è¿™ä¸ªåœ°æ–¹å˜åŒ–ç‡å¤ªä½ï¼Œxæˆ–yçš„å˜åŒ–æ— æ³•å¼•èµ·zçš„å˜åŒ–è¶…è¿‡è®¾å®šçš„å˜åŒ–ç‡æ—¶ï¼Œå°±ä¼šå‡ºç°è¿™ç§æƒ…å†µï¼Œä»¤$z=y^2-sin(x)^2$ï¼Œåˆ†åˆ«è®¡ç®—zå¯¹xï¼Œyçš„å˜åŒ–é‡çš„ç»å¯¹å€¼$|z(x_0+dx,y_0) - z(x_0,y_0)$,$|z(x_0,y_0+dy) - z(x_0,y_0)$,$|z(x_0-dx,y_0) - z(x_0,y_0)$,$|z(x_0,y_0-dy) - z(x_0,y_0)$ï¼Œå°†ç²¾ç¡®åº¦è®¾ç½®ä¸ºå˜åŒ–é‡ç»å¯¹å€¼çš„æœ€å¤§å€¼å³å¯,å¯¹äºå¯¼æ•°éå¸¸å¤§çš„ä½ç½®ï¼Œä¼šå¯¼è‡´ç²¾ç¡®åº¦è¢«æ— é™æ”¾å¤§ï¼Œæ­¤æ—¶ç²¾ç¡®åº¦ä¸è®¸å¤§äº$max(dx,dy)$","link":"/home/2023/10/22/misc/c%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E7%BB%98%E5%9B%BE/"},{"title":"gitçš„ä½¿ç”¨","text":"ç‰ˆæœ¬æ§åˆ¶å‘å±•å†å²æœ¬åœ°ä»£ç ç‰ˆæœ¬æ§åˆ¶RCS: åªèƒ½ä¿å­˜æœ¬åœ°çš„å˜åŒ–æƒ…å†µï¼Œæ— æ³•ååŒåˆä½œ é›†ä¸­å¼ç‰ˆæœ¬æ§åˆ¶SVN: è¿œç«¯æœåŠ¡å™¨ç»´æŠ¤ç‰ˆæœ¬ï¼Œæœ¬åœ°ä¸ä¿å­˜ä»£ç ç‰ˆæœ¬ åˆ†å¸ƒå¼ç‰ˆæœ¬æ§åˆ¶git: æ¯ä¸ªä»“åº“éƒ½è®°å½•ç‰ˆæœ¬å†å²ï¼Œè§£å†³ä¸€ä¸ªæœåŠ¡å™¨æŒ‚æ‰å¯¼è‡´æ‰€æœ‰å†å²ç‰ˆæœ¬ä¸¢å¤±çš„é—®é¢˜ cherry-pickfast-forward","link":"/home/2024/05/07/misc/git%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"PAT-Basic-1084","text":"é¢˜ç›® å¤–è§‚æ•°åˆ—æ˜¯æŒ‡å…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹çš„æ•´æ•°åºåˆ—ï¼š 1d, d1, d111, d113, d11231, d112213111, ... å®ƒä»ä¸ç­‰äº 1 çš„æ•°å­— d å¼€å§‹ï¼Œåºåˆ—çš„ç¬¬ n+1 é¡¹æ˜¯å¯¹ç¬¬ n é¡¹çš„æè¿°ã€‚æ¯”å¦‚ç¬¬ 2 é¡¹è¡¨ç¤ºç¬¬ 1 é¡¹æœ‰ 1 ä¸ª dï¼Œæ‰€ä»¥å°±æ˜¯ d1ï¼›ç¬¬ 2 é¡¹æ˜¯ 1 ä¸ª dï¼ˆå¯¹åº” d1ï¼‰å’Œ 1 ä¸ª 1ï¼ˆå¯¹åº” 11ï¼‰ï¼Œæ‰€ä»¥ç¬¬ 3 é¡¹å°±æ˜¯ d111ã€‚åˆæ¯”å¦‚ç¬¬ 4 é¡¹æ˜¯ d113ï¼Œå…¶æè¿°å°±æ˜¯ 1 ä¸ª dï¼Œ2 ä¸ª 1ï¼Œ1 ä¸ª 3ï¼Œæ‰€ä»¥ä¸‹ä¸€é¡¹å°±æ˜¯ d11231ã€‚å½“ç„¶è¿™ä¸ªå®šä¹‰å¯¹ d = 1 ä¹Ÿæˆç«‹ã€‚æœ¬é¢˜è¦æ±‚ä½ æ¨ç®—ä»»æ„ç»™å®šæ•°å­— d çš„å¤–è§‚æ•°åˆ—çš„ç¬¬ N é¡¹ã€‚ è¾“å…¥æ ¼å¼ï¼š è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡º [0,9] èŒƒå›´å†…çš„ä¸€ä¸ªæ•´æ•° dã€ä»¥åŠä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤ 40ï¼‰ï¼Œç”¨ç©ºæ ¼åˆ†éš”ã€‚ è¾“å‡ºæ ¼å¼ï¼š åœ¨ä¸€è¡Œä¸­ç»™å‡ºæ•°å­— d çš„å¤–è§‚æ•°åˆ—çš„ç¬¬ N é¡¹ã€‚ è¾“å…¥æ ·ä¾‹ï¼š11 8 è¾“å‡ºæ ·ä¾‹ï¼š11123123111 é€šè¿‡ä»£ç 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;void add(string&amp; str, char c, int&amp; n) { char toNum[1024] = {0}; str.append(&amp;c, 1);//è¿™æ ·å¯ä»¥â€œéª—â€appendå‡½æ•°cæ˜¯åªæœ‰ä¸€ä¸ªå­—ç¬¦çš„å­—ç¬¦ä¸² sprintf(toNum, &quot;%d&quot;, n); str.append(toNum); n = 0;}int main () { string d; int n; cin &gt;&gt; d &gt;&gt; n; string&amp; temp = d;//å»ºç«‹ä¸€ä¸ªå¯¹å­—ç¬¦ä¸²çš„å¼•ç”¨ï¼Œå¾ªç¯çš„æ—¶å€™å¯ä»¥é¿å…æ‹·è´ for (int i = 0, count = 1; i &lt; n - 1; i++, count = 1) { string next = &quot;&quot;; for (int j = 1; j &lt; temp.length(); j++, count++) if (temp[j - 1] != temp[j]) add(next, temp[j - 1], count); add(next, temp[temp.length() - 1], count); temp = next; } cout &lt;&lt; temp &lt;&lt; endl; return 0;} æ€è·¯å’Œæ³¨æ„ è¯»æ‡‚é¢˜å¾ˆå…³é”®ç¬¬n+1é¡¹æ˜¯å¯¹ç¬¬né¡¹çš„æè¿° å°±æ˜¯éå†å‰ä¸€é¡¹ï¼Œæ•°å‡ºè¿ç»­çš„æŸä¸ªå­—ç¬¦cæœ‰å‡ ä¸ªï¼Œç„¶åè‡ªå·±å°±å˜æˆäº†c + cçš„ä¸ªæ•° è¿™é“é¢˜çš„æ ¸å¿ƒç®—æ³•å’ŒPATä¹™çº§é¢˜â€“1078 å­—ç¬¦ä¸²å‹ç¼©ä¸è§£å‹çš„å‹ç¼©éƒ¨åˆ†çš„ç®—æ³•ç±»ä¼¼","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1084-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97(PAT-(Basic-Level)-Practice)/"},{"title":"æ˜¾å¡é©±åŠ¨è¸©å‘","text":"nvidiaæ˜¾å¡é©±åŠ¨è¸©å‘ ä¹‹å‰æ›´æ–°äº†ä¸€æ¬¡linuxçš„å†…æ ¸ï¼Œå¯¼è‡´å†…æ ¸çš„æ˜¾å¡å†²çªäº†ï¼Œhdmiæ²¡æœ‰è¾“å‡ºï¼Œnvidia-smiå‘½ä»¤ä¹Ÿæ²¡äº† é‡è£…äº†nvidiaçš„æ˜¾å¡ï¼Œå‘ç°é»˜è®¤ä½¿ç”¨æ ¸æ˜¾ï¼ŒåŠ¨ç”»éå¸¸å¡ åæ¥å±è”½äº†linuxè‡ªå¸¦çš„é©±åŠ¨nouveauï¼Œhdmiç»ˆäºæœ‰è¾“å‡ºäº†ï¼Œæ˜¾å¡é©±åŠ¨çš„daemonä¹Ÿå¯ä»¥ä½¿ç”¨äº†(nvidia-smiè¾“å‡ºæ­£å¸¸)ï¼Œä½†æ˜¯è‡ªå¸¦çš„æ˜¾ç¤ºå™¨å´ä¸èƒ½ç”¨äº† è§£å†³æ–¹æ³• /etc/X11/xorg.confæ–‡ä»¶ä¸çŸ¥é“ä»€ä¹ˆåŸå› å‡ºç°äº†é”™è¯¯ï¼ŒæŠŠè¿™ä¸ªæ–‡ä»¶å†…å®¹æ¸…ç©ºï¼Œå°±å¥½äº† é‡å¯åå‘ç°è¿™ä¸ªæ–‡ä»¶é‡Œé¢æœ¬èº«å°±æ²¡ä¸œè¥¿","link":"/home/2022/10/28/linux/%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8%E8%B8%A9%E5%9D%91/"},{"title":"shellçš„ä½¿ç”¨","text":"shell fuctionå‡½æ•°å®šä¹‰ å®šä¹‰1xxx.sh123function funcName() { # do sth} å®šä¹‰2xxx.sh1234f2() { value=$(($1+$2+1)) echo $1 &quot;+&quot; $2 &quot;=&quot; $value} ä¼ å‚xxx.sh1234function funcName() { echo $1 # æ‰“å°ç¬¬ä¸€ä¸ªå‚æ•° echo $2 # æ‰“å°ç¬¬äºŒä¸ªå‚æ•°} è°ƒç”¨ ç›´æ¥åœ¨è„šæœ¬ä¸­è°ƒç”¨ xxx.sh12345function funcName() { echo $1 # æ‰“å°ç¬¬ä¸€ä¸ªå‚æ•° echo $2 # æ‰“å°ç¬¬äºŒä¸ªå‚æ•°}funcName åˆ˜å–µå–µ å¤§å¸…å“¥ åœ¨shellä¸­è°ƒç”¨ shell12. xxx.sh # importå¯¼å…¥å…¶ä¸­çš„å‡½æ•°funcName åˆ˜å–µå–µ å¤§å¸…å“¥ å¦‚æœfunctionå†™åœ¨/etc/profileã€~/.bashrcä¸‹ï¼Œåˆ™å¯ä»¥ç›´æ¥è°ƒç”¨ åº”ç”¨ æœ‰äº†ä»¥ä¸Šæ–¹æ³•ï¼Œåœ¨bashrcä¸­å°†è‡ªå·±å¸¸ç”¨ä½†å®¹æ˜“é—å¿˜çš„å‘½ä»¤å†™æˆå‡½æ•°ï¼Œå°±å¯ä»¥æ–¹ä¾¿çš„è°ƒç”¨äº† å¦‚æœå‡½æ•°å¿˜äº†ï¼Œï¼Œé‚£å°±å¯ä»¥å»~/.bashrcä¸‹çœ‹çœ‹ğŸ˜…x1 å¦‚æœå¿˜è®°å»å“ªé‡Œçœ‹äº†ï¼Œï¼Œï¼Œé‚£å°±æ¥çœ‹çœ‹è¿™ç¯‡æ–‡ç« ğŸ˜…x2 å¦‚æœå¿˜è®°è¿™ç¯‡æ–‡ç« ï¼Œï¼Œï¼Œé‚£æˆ‘ç›´æ¥ğŸ˜…x3 ~/.bashrc12345678function setgitproxy() { git config --global http.proxy 'socks5h://localhost:7890' git config --global https.proxy 'socks5h://localhost:7890'}function unsetgitproxy() { git config --global --unset http.proxy git config --global --unset https.proxy} ubuntuä¸­åˆ›å»ºunitsystemctlsystemctl æä¾›äº†ä¸€ç»„å­å‘½ä»¤æ¥ç®¡ç†å•ä¸ªçš„ unitï¼Œå…¶å‘½ä»¤æ ¼å¼ä¸ºï¼š 1systemctl [command] [unit] åˆ›å»ºunit ç¼–å†™.serviceæ–‡ä»¶1sudo vim /etc/systemd/system/xxx.service xxx.service1234567891011[Unit]Description=clash daemon[Service]Type=simpleUser=rootExecStart=/opt/xxx/xxx -d /etc/xxx/ #startæ—¶æ‰§è¡Œçš„å‘½ä»¤Restart=on-failure[Install]WantedBy=multi-user.target é‡æ–°åŠ è½½systemctl daemon 1sudo systemctl daemon-reload å¯åŠ¨service 1sudo systemctl start xxx.service è®¾ç½®ä¸ºå¼€æœºå¯åŠ¨ 1sudo systemctl enable xxx.service","link":"/home/2022/10/27/linux/shell/"},{"title":"shellç¼–ç¨‹ç›¸å…³","text":"killåƒµå°¸è¿›ç¨‹ å¼ºåˆ¶killæ‰å…¶çˆ¶è¿›ç¨‹ï¼Œä½†æ˜¯ä¼šå¯¼è‡´shellä¹Ÿæ­»æ‰1ps -ef | grep defunct | awk '{ len=split($0, a, &quot; &quot;);print a[3]; }' | xargs kill -9","link":"/home/2023/04/20/misc/shell%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3/"},{"title":"gethæ­å»ºç§é“¾","text":"ä¸»è¦å·¥ä½œå‚è€ƒgo-ethereumå®˜ç½‘çš„Private Networksæ–‡æ¡£æ­å»ºäº†ä¸€ä¸ªç§æœ‰é“¾ï¼Œå¹¶æ€»ç»“å‡ºå‡ ä¸ªè„šæœ¬ï¼Œå¯ä»¥åŠè‡ªåŠ¨åŒ–åœ°å®ç°gethç½‘ç»œçš„æ­å»ºï¼Œè„šæœ¬å·²ä¸Šä¼ è‡³githubä»“åº“DLCCB setup.sh è¿™ä¸€æ­¥ä½¿ç”¨äº†ä»¥ä¸‹å‡ ä¸ªå·¥å…· gethå‘½ä»¤ï¼Œç”¨äºç”Ÿæˆåˆå§‹ä¸¤ä¸ªèŠ‚ç‚¹çš„è´¦æˆ·ï¼Œä½¿ç”¨åˆ›ä¸–å—é…ç½®æ–‡ä»¶å¯¹ä¸¤ä¸ªè´¦æˆ·è¿›è¡Œåˆå§‹åŒ– puppeth ç”¨äºç”Ÿæˆåˆ›ä¸–å—çš„é…ç½®æ–‡ä»¶ï¼Œè¿™ä¸ªå‘½ä»¤æ˜¯äº¤äº’å¼çš„ï¼Œç¼–å†™äº†ä¸€ä¸ªpuppeth.txtä½œä¸ºå…¶è¾“å…¥ï¼Œé»˜è®¤ç”Ÿæˆä¸€ä¸ªåŸºäºpowçš„åŒºå—é“¾ bootnode ç”¨äºç”Ÿæˆå¯åŠ¨bootnode è¿™ä¸€æ­¥ä½¿ç”¨äº†ä»¥ä¸‹å‡ ä¸ªlinuxå‘½ä»¤ sed éäº¤äº’å¼çš„æ–‡æœ¬ç¼–è¾‘å™¨ï¼Œç”¨äºè¯»å–ç”Ÿæˆçš„è´¦æˆ·çš„åŒºå—é“¾åœ°å€ï¼Œå†™å…¥puppeth.txtä¸­ï¼Œä½¿å¾—puppethå·¥å…·èƒ½ä¸ºåˆå§‹çš„ä¸¤ä¸ªèŠ‚ç‚¹åˆ†é…ä¸€å®šçš„ä»¥å¤ªå¸ awkï¼Œç”¨äºå¯¹æ–‡æœ¬çš„å¤„ç† setup.sh123456789101112131415161718mkdir node1 node2geth --datadir node1 account new &lt; password.txtgeth --datadir node2 account new &lt; password.txtsed -i &quot;5i$(cat node1/keystore/UTC--* | awk '{split($0, arr, &quot;\\&quot;&quot;); print arr[4]}')&quot; puppeth.txt sed -i &quot;5i$(cat node2/keystore/UTC--* | awk '{split($0, arr, &quot;\\&quot;&quot;); print arr[4]}')&quot; puppeth.txt puppeth &lt; puppeth.txtsed -i &quot;5d&quot; puppeth.txtsed -i &quot;5d&quot; puppeth.txtgeth init --datadir node1 tianer.jsongeth init --datadir node2 tianer.jsoncat password.txt | head -n 1 | tee node1/password.txtcat password.txt | head -n 1 | tee node2/password.txtbootnode -genkey boot.keybootnode -nodekey boot.key -addr :30305 ä¸¤ä¸ªè¾“å…¥æ–‡ä»¶çš„å†…å®¹password.txt1212345678901234567890 è¿™é‡Œä¸¤ä¸ªèŠ‚ç‚¹çš„å¯†ç æ˜¯ç›¸åŒçš„ï¼Œä¹Ÿå¯ä»¥å•ç‹¬ä¸ºæ¯ä¸ªèŠ‚ç‚¹å†™ä¸€ä¸ªå¯†ç æ–‡ä»¶ï¼Œä½†æ˜¯å¯†ç æ–‡ä»¶å¿…é¡»ä¸¤è¡Œç›¸åŒï¼Œå› ä¸ºåˆ›å»ºè´¦æˆ·æ—¶éœ€è¦è¾“å…¥ä¸¤æ¬¡å¯†ç  puppeth.txt123456789101112tianer211yes123452223 ä»ä¸Šåˆ°ä¸‹ä¾æ¬¡å¯¹é…ç½®åˆ›ä¸–å—çš„é…ç½®æ–‡ä»¶è¿›è¡Œåˆ›å»ºï¼Œå¯¼å‡ºä¿å­˜ï¼Œåˆ é™¤ã€‚ä¼šä½¿ç”¨sedå‘½ä»¤åœ¨ç¬¬äº”è¡Œä¸´æ—¶æ’å…¥åˆšåˆšç”Ÿæˆçš„è´¦æˆ·æ–‡ä»¶çš„åŒºå—é“¾åœ°å€ï¼Œè¿™æ ·puppethå‘½ä»¤å°±çŸ¥é“è¦ç»™å“ªäº›åœ°å€åˆ†é…åˆå§‹çš„ä»¥å¤ªå¸ sedå‘½ä»¤sed å‘½ä»¤æ˜¯ä¸€ä¸ªé¢å‘è¡Œå¤„ç†çš„å·¥å…·ï¼Œå®ƒä»¥â€œè¡Œâ€ä¸ºå¤„ç†å•ä½ï¼Œé’ˆå¯¹æ¯ä¸€è¡Œè¿›è¡Œå¤„ç†ï¼Œå¤„ç†åçš„ç»“æœä¼šè¾“å‡ºåˆ°æ ‡å‡†è¾“å‡ºï¼ˆSTDOUTï¼‰ã€‚ä½ ä¼šå‘ç° sed å‘½ä»¤æ˜¯å¾ˆæ‡‚ç¤¼è²Œçš„ä¸€ä¸ªå‘½ä»¤ï¼Œå®ƒä¸ä¼šå¯¹è¯»å–çš„æ–‡ä»¶åšä»»ä½•è´¸ç„¶çš„ä¿®æ”¹ï¼Œè€Œæ˜¯å°†å†…å®¹éƒ½è¾“å‡ºåˆ°æ ‡å‡†è¾“å‡ºä¸­ã€‚ åŸºæœ¬ç”¨æ³• 1sed [é€‰é¡¹] &quot;æŒ‡ä»¤&quot; æ–‡ä»¶ é€‰é¡¹ï¼Œå¦‚æœå¸Œæœ›sedå‘½ä»¤å¯¹æ–‡ä»¶ç›´æ¥è¿›è¡Œæ›´æ”¹ï¼Œéœ€è¦æ·»åŠ -iå‚æ•°ï¼Œ ä»¥ä¸‹æ˜¯å‡ ä¸ªæŸ¥é‚£ä¸ªç”¨çš„å‚æ•° -e â€“å®ƒå‘Šè¯‰sedå°†ä¸‹ä¸€ä¸ªå‚æ•°è§£é‡Šä¸ºä¸€ä¸ªsedæŒ‡ä»¤ï¼Œåªæœ‰å½“å‘½ä»¤è¡Œä¸Šç»™å‡ºå¤šä¸ªsedæŒ‡ä»¤æ—¶ä½¿ç”¨ -f â€“åè·Ÿä¿å­˜äº†sedæŒ‡ä»¤çš„æ–‡ä»¶ -i â€“ç›´æ¥å¯¹å†…å®¹è¿›è¡Œä¿®æ”¹ï¼Œä¸åŠ  i æ—¶é»˜è®¤åªæ˜¯é¢„è§ˆï¼Œä¸ä¼šå¯¹æ–‡ä»¶è¿›è¡Œå®é™…ä¿®æ”¹ -n â€“å–æ¶ˆé»˜è®¤è¾“å‡ºï¼Œsedé»˜è®¤ä¼šè¾“å‡ºæ‰€æœ‰æ–‡æœ¬å†…å®¹ï¼Œä½¿ç”¨ -n å‚æ•°ååªæ˜¾ç¤ºå¤„ç†è¿‡çš„è¡Œ æŒ‡ä»¤ï¼Œç±»ä¼¼vimï¼Œsedä¹Ÿæœ‰ç¼–è¾‘å‘½ä»¤ a â€“è¿½åŠ ï¼Œå‘åŒ¹é…è¡Œåæ’å…¥å†…å®¹ c â€“æ›´æ”¹ï¼Œæ›´æ”¹åŒ¹é…è¡Œçš„å†…å®¹ i â€“æ’å…¥ï¼Œå‘åŒ¹é…è¡Œå‰æ’å…¥å†…å®¹ d â€“åˆ é™¤ï¼Œåˆ é™¤åŒ¹é…çš„å†…å®¹ s â€“æ›¿æ¢ï¼Œæ›¿æ¢åŒ¹é…åˆ°çš„å†…å®¹ p â€“æ‰“å°ï¼Œæ‰“å°åŒ¹é…åˆ°çš„å†…å®¹ï¼Œé€šå¸¸ä¸ -n å’Œç”¨ = â€“ç”¨æ¥æ‰“å°è¢«åŒ¹é…åˆ°çš„è¡Œçš„è¡Œå· n â€“è¯»å–ä¸‹ä¸€è¡Œï¼Œé‡åˆ°næ—¶ä¼šè‡ªåŠ¨è·³å…¥ä¸‹ä¸€è¡Œ r,w â€“è¯»å’Œå†™ï¼Œrç”¨äºå°†å†…å®¹è¯»å…¥æ–‡ä»¶ï¼Œwç”¨äºå°†åŒ¹é…å†…å®¹å†™å…¥åˆ°æ–‡ä»¶ å…¶ä¸­så‘½ä»¤åè·Ÿæ­£åˆ™ä¸²å’Œç›®æ ‡ä¸²ï¼Œå¯ä»¥èµ·åˆ°æ–‡æœ¬çš„åŒ¹é…æ›¿æ¢sedçš„æŒ‡ä»¤ä½¿ç”¨/ä½œä¸ºå®šç•Œç¬¦ï¼Œè½¬ä¹‰ç¬¦ä¸º\\ ä¾‹å­ï¼š 1234sed -i 's/book/books/' filesed -i 's/book/books/g' file # åç¼€gå¯¹æ¯è¡Œçš„æ‰€æœ‰åŒ¹é…è¿›è¡Œæ›¿æ¢sed -i '2d' file #åˆ é™¤æŒ‡å®šè¡Œsed -i '5ixxxxx' file #åœ¨æŒ‡å®šè¡Œæ’å…¥xxxxx å…·ä½“å¯ä»¥å‚è€ƒè¿™é‡Œ awkå‘½ä»¤AWK æ˜¯ä¸€ç§å¤„ç†æ–‡æœ¬æ–‡ä»¶çš„è¯­è¨€ï¼Œæ˜¯ä¸€ä¸ªå¼ºå¤§çš„æ–‡æœ¬åˆ†æå·¥å…·ã€‚ä¹‹æ‰€ä»¥å« AWK æ˜¯å› ä¸ºå…¶å–äº†ä¸‰ä½åˆ›å§‹äºº Alfred Ahoï¼ŒPeter Weinberger, å’Œ Brian Kernighan çš„ Family Name çš„é¦–å­—ç¬¦linuxä¸­æœ‰ä¸‰å‰‘å®¢ä¹‹ç§°ï¼šä¸‰å‰‘å®¢ä¹‹é¦–å°±æ˜¯ AWKä¸‰å‰‘å®¢åŠŸèƒ½:grep ï¼š è¿‡æ»¤æ–‡æœ¬sed : ä¿®æ”¹æ–‡æœ¬awk : å¤„ç†æ–‡æœ¬ è¯­æ³•æ ¼å¼ 1awk [å‚æ•°] [å¤„ç†å†…å®¹] [æ“ä½œå¯¹è±¡] å…·ä½“å¯ä»¥å‚è€ƒè¿™é‡Œ mine.shç”¨äºå¯åŠ¨åˆ›å»ºçš„ä¸¤ä¸ªèŠ‚ç‚¹ mine.sh12345678NODE=$2ENODE=$1AUTHRPCPORT=$(($2+8554))PORT=$(($2+30308))echo geth --datadir node$NODE --port $PORT --bootnodes $ENODE --networkid 12345 --unlock 0x$(cat node$NODE/keystore/UTC--* | awk '{split($0, arr, &quot;\\&quot;&quot;); print arr[4]}') --password node1/password.txt --authrpc.port $AUTHRPCPORTgeth --datadir node$NODE --port $PORT --bootnodes $ENODE --networkid 12345 --unlock 0x$(cat node$NODE/keystore/UTC--* | awk '{split($0, arr, &quot;\\&quot;&quot;); print arr[4]}') --password node1/password.txt --authrpc.port $AUTHRPCPORT --mine å‰ä¸€ä¸ªè„šæœ¬æ‰§è¡Œåï¼Œä¼šè¾“å‡ºenodeï¼Œ å°†å…¶å¤åˆ¶ä¸‹æ¥ï¼Œæ‰“å¼€ä¸¤ä¸ªæ–°çš„terminalçª—å£ï¼Œenodeä½œä¸ºè¿™ä¸ªè„šæœ¬çš„ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯å¸Œæœ›å¯åŠ¨çš„èŠ‚ç‚¹çš„ç¼–å· attach.shç”¨äºè®©ä¸¤ä¸ªèŠ‚ç‚¹å¼€å§‹æŒ–çŸ¿ï¼Œä½¿ç”¨geth attachæ‰“å¼€jsäº¤äº’ç•Œé¢ï¼Œminer.txtä½œä¸ºè¾“å…¥æ–‡ä»¶ï¼Œæ‰§è¡Œå‘½ä»¤miner.start(1)å¼€å§‹æŒ–çŸ¿ attach.sh123NODE=$1echo geth attach node$NODE/geth.ipcgeth attach node$NODE/geth.ipc &lt; miner.txt å‚æ•°ä¸ºå¸Œæœ›å¼€å§‹æŒ–çŸ¿çš„èŠ‚ç‚¹ç¼–å·ï¼Œä¹Ÿéœ€è¦æ‰“å¼€æ–°çš„terminalæ‰§è¡Œ miner.txt123net.peerCounteth.getBalance(eth.accounts[0])miner.start(1) sk.jsç”¨äºè·å–èŠ‚ç‚¹çš„ç§é’¥ï¼Œåœ¨å¼€å‘æ—¶ç§é’¥å¾ˆé‡è¦ sk.js1234567var keythereum = require(&quot;keythereum&quot;);var datadir = &quot;/home/tt/eth/net/node2/&quot;;var address= &quot;e43b98ac32beb344c94b15b9af5b46674d6c3e6d&quot;;//è¦å°å†™const password = &quot;1234567890&quot;;var keyObject = keythereum.importFromFile(address, datadir);var privateKey = keythereum.recover(password, keyObject);console.log(privateKey.toString('hex')); éœ€è¦èŠ‚ç‚¹çš„datadirå’ŒèŠ‚ç‚¹çš„address","link":"/home/2023/01/10/misc/geth%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E9%93%BE/"},{"title":"hexoé…ç½®&amp;è¸©å‘&amp;è‡ªå®šä¹‰","text":"git deplyerref æ–‡ç« ç›®å½• icarusçš„æ–‡ç« ç›®å½•åªæœ‰äºŒçº§æ ‡é¢˜å¼€å§‹æ‰å¯ä»¥è·³è½¬ é˜…è¯»æ›´å¤šæŒ‰é’® å®‰è£…hexo-excerptæ’ä»¶ live2d å®‰è£…è¿™ä¸ªhexo-helper-live2d ä»£ç å—123{% codeblock filename lang:code-lang %} your code here...{% endcodeblock %} gittalk æŒ‰ç…§æ•™ç¨‹åˆ›å»ºgittalkï¼Œå¡«å†™é…ç½®æ–‡ä»¶ å®˜æ–¹æ•™ç¨‹ æ³¨æ„è¿™é‡Œçš„repoæ˜¯ä»“åº“åå­—ï¼Œä¸æ˜¯repoçš„urlï¼Œä¸æ˜¯repoçš„åç§° é€šè¿‡f12çš„networkå‘ç°å‘é€çš„æ˜¯apiurl+repo _config.icaruc.yml12345678910111213141516comment: type: gitalk client_id: xxxxxxxxxxxxxxxxxxxx client_secret: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx repo: Some-of-Your-GitHub-Repo # è¿™é‡Œæ˜¯repoçš„åå­—ï¼Œä¸æ˜¯url owner: you_github_name admin: - you_github_name per_page: 20 # å¯é€‰å¡« distraction_free_mode: false # å¯é€‰å¡« pager_direction: last # å¯é€‰å¡« create_issue_manually: false # å¯é€‰å¡« proxy: # å¯é€‰å¡« flip_move_options: # å¯é€‰å¡« enable_hotkey: true # å¯é€‰å¡« language: zh-CN # å¯é€‰å¡« åŒæ—¶ï¼Œåœ¨_config.ymlä¸‹é…ç½®gitalk _config.yml12345678gitalk: enable: true #é»˜è®¤çš„æ˜¯falseï¼Œæ²¡æœ‰æ‰“å¼€ owner: 'github name' repo: 'repo name' oauth: clientId: 'clientId' clientSecret: 'clientSecret' admin: ['githubname'] fairyDust é¼ æ ‡ç‰¹æ•ˆåœ¨source/jsä¸‹åˆ›å»ºæ–‡ä»¶fairyDustCursor.js source/js/fairyDustCursor.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123(function fairyDustCursor() { var possibleColors = [&quot;#D61C59&quot;, &quot;#E7D84B&quot;, &quot;#1B8798&quot;] var width = window.innerWidth; var height = window.innerHeight; var cursor = { x: width / 2, y: width / 2 }; var particles = []; function init() { bindEvents(); loop(); } // Bind events that are needed function bindEvents() { document.addEventListener('mousemove', onMouseMove); document.addEventListener('touchmove', onTouchMove); document.addEventListener('touchstart', onTouchMove); window.addEventListener('resize', onWindowResize); } function onWindowResize(e) { width = window.innerWidth; height = window.innerHeight; } function onTouchMove(e) { if (e.touches.length &gt; 0) { for (var i = 0; i &lt; e.touches.length; i++) { addParticle(e.touches[i].clientX, e.touches[i].clientY, possibleColors[Math.floor(Math.random() * possibleColors.length)]); } } } function onMouseMove(e) { cursor.x = e.clientX; cursor.y = e.clientY; addParticle(cursor.x, cursor.y, possibleColors[Math.floor(Math.random() * possibleColors.length)]); } function addParticle(x, y, color) { var particle = new Particle(); particle.init(x, y, color); particles.push(particle); } function updateParticles() { for (var i = 0; i &lt; particles.length; i++) { particles[i].update(); } for (var i = particles.length - 1; i &gt;= 0; i--) { if (particles[i].lifeSpan &lt; 0) { particles[i].die(); particles.splice(i, 1); } } } function loop() { requestAnimationFrame(loop); updateParticles(); } function Particle() { this.character = &quot;*&quot;; this.lifeSpan = 120; //ms this.initialStyles = { &quot;position&quot;: &quot;fixed&quot;, &quot;top&quot;: &quot;0&quot;, //å¿…é¡»åŠ  &quot;display&quot;: &quot;block&quot;, &quot;pointerEvents&quot;: &quot;none&quot;, &quot;z-index&quot;: &quot;10000000&quot;, &quot;fontSize&quot;: &quot;20px&quot;, &quot;will-change&quot;: &quot;transform&quot; }; this.init = function (x, y, color) { this.velocity = { x: (Math.random() &lt; 0.5 ? -1 : 1) * (Math.random() / 2), y: 1 }; this.position = { x: x - 10, y: y - 20 }; this.initialStyles.color = color; console.log(color); this.element = document.createElement('span'); this.element.innerHTML = this.character; applyProperties(this.element, this.initialStyles); this.update(); document.body.appendChild(this.element); }; this.update = function () { this.position.x += this.velocity.x; this.position.y += this.velocity.y; this.lifeSpan--; this.element.style.transform = &quot;translate3d(&quot; + this.position.x + &quot;px,&quot; + this.position.y + &quot;px,0) scale(&quot; + (this.lifeSpan / 120) + &quot;)&quot;; } this.die = function () { this.element.parentNode.removeChild(this.element); } } function applyProperties(target, properties) { for (var key in properties) { target.style[key] = properties[key]; } } init();})(); ä¿®æ”¹node_modules/hexo-theme-icarus/layoutä¸‹çš„layout.jsxï¼Œåœ¨bodyä¸­å¼•ç”¨è¿™ä¸ªjsæ–‡ä»¶ node_modules/hexo-theme-icarus/layout/layout.jsx1&lt;script type=&quot;text/javascript&quot; src=&quot;/home/js/fairyDustCursor.js&quot;&gt;&lt;/script&gt; ç‚¹å‡»ç‰¹æ•ˆç¼–å†™äº§ç”Ÿç‚¹å‡»ç‰¹æ•ˆçš„jsæ–‡ä»¶ source/js/textPopup.js12345678910111213141516171819202122232425262728293031323334var colors = new Array(&quot;#FF0000&quot;,&quot;#FF7F00&quot;,&quot; #FFFF00&quot;,&quot;#00FF00&quot;,&quot;#00FFFF&quot;,&quot;#0000FF&quot;,&quot;#8B00FF&quot;,&quot;#FF0000&quot;,&quot;#FF7F00&quot;,&quot; #FFFF00&quot;,&quot;#00FF00&quot;,&quot;#00FFFF&quot;,&quot;#0000FF&quot;,&quot;#8B00FF&quot;);var fnTextPopup = function (arr, options) { // arrå‚æ•°æ˜¯å¿…é¡»çš„ if (!arr || !arr.length) { return; } // ä¸»é€»è¾‘ var index = 0; document.documentElement.addEventListener('click', function (event) { var x = event.pageX, y = event.pageY; var eleText = document.createElement('span'); eleText.className = 'text-popup'; this.appendChild(eleText); if (arr[index]) { eleText.innerHTML = arr[index]; } else { index = 0; eleText.innerHTML = arr[0]; } // åŠ¨ç”»ç»“æŸååˆ é™¤è‡ªå·± eleText.addEventListener('animationend', function () { eleText.parentNode.removeChild(eleText); }); // ä½ç½® eleText.style.left = (x - eleText.clientWidth / 2) + 'px'; eleText.style.top = (y - eleText.clientHeight) + 'px'; //è®¾ç½®é¢œè‰² eleText.style.color = colors[index%14] // indexé€’å¢ index++; });};fnTextPopup(['å¯Œå¼º', 'æ°‘ä¸»', 'æ–‡æ˜', 'å’Œè°', 'è‡ªç”±', 'å¹³ç­‰', 'å…¬æ­£', 'æ³•æ²»', 'çˆ±å›½', 'æ•¬ä¸š', 'è¯šä¿¡', 'å‹å–„']); ç¼–å†™cssæ–‡ä»¶ source/css/textPopup.css123456789101112131415161718.text-popup { animation: textPopup 1s; user-select: none; white-space: nowrap; position: absolute; z-index: 99;}@keyframes textPopup { 0%, 100% { opacity: 0; } 5% { opacity: 1; } 100% { transform: translateY(-50px); }} åœ¨layout.jsxä¸­å¼•ç”¨ node_modules/hexo-theme-icarus/layout/layout.jsx12&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/home/css/textPopup.css&quot; /&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/home/js/textPopup.js&quot;&gt;&lt;/script&gt; RSSç”Ÿæˆæ’ä»¶ï¼Œå¢åŠ RSSè®¢é˜…æŒ‰é’® å®‰è£…ä¸€ä¸ªæ’ä»¶ï¼Œç”¨æ¥ç”Ÿæˆatom.xmlæ–‡ä»¶ 1npm install --save hexo-generator-feed é…ç½®æ’ä»¶ headä¸‹å¢åŠ rssé…ç½®_config.icarus.yml12head: rss: /atom.xml å¢åŠ å¯¹æ’ä»¶çš„é…ç½®_config.yml123456789# Extensionsplugins: hexo-generator-feed#Feed Atomfeed: type: atom path: atom.xml limit: 20rss: /atom.xml é…ç½®RSSæŒ‰é’®_config.icarus.yml1234social_links: RSS: icon: fa fa-rss url: /atom.xml ä¼˜åŒ–RSSæŒ‰é’®ä¸Šé¢é…ç½®ç‚¹å‡»rssæŒ‰é’®ï¼Œå¦‚æœæµè§ˆå™¨æ²¡æœ‰å®‰è£…rssç›¸å…³æ’ä»¶ï¼Œä¼šç›´æ¥æ˜¾ç¤ºatom.xmlçš„åŸå§‹æ ·å¼ï¼Œä¸ç¾è§‚ï¼Œåˆ©ç”¨jså®ç°ç‚¹å‡»rssæŒ‰é’®å°†è®¢é˜…é“¾æ¥å¤åˆ¶åˆ°å‰ªåˆ‡æ¿ source/js/clickClipBoard.js123456789101112131415161718192021222324function copyToClipboard(text, callBack) { navigator.clipboard.writeText(text).then( value =&gt; { // fulfillment callBack() }, reason =&gt; { // rejection alert(&quot;fail: &quot; + reason) } )}$(document).ready(function() { var buttons = document.getElementsByClassName(&quot;button&quot;) for (let i = 0; i &lt; buttons.length; i++) { if (buttons[i].getAttribute(&quot;title&quot;) == &quot;RSS&quot;) { var url = document.baseURI + &quot;atom.xml&quot; buttons[i].href = &quot;javascript:;&quot; buttons[i].target = &quot;_self&quot; buttons[i].setAttribute('onclick', &quot;copyToClipboard(\\&quot;&quot; + url + &quot;\\&quot;, function() { alert(\\&quot;copied to clipboard\\&quot;) })&quot;) break } }}) ä¿®å¤æ’ä»¶çš„é—®é¢˜ æ’ä»¶ç”Ÿæˆçš„xmlæ–‡ä»¶ä¸­ï¼Œåšå®¢çš„baseUrlä¸å¯¹ï¼Œåº”è¯¥æ˜¯jingtianer.github.io å®ƒç”Ÿæˆçš„æ˜¯github.com/jingtianer ç”Ÿæˆåä½¿ç”¨è„šæœ¬æ›¿æ¢ å…¶å®æ˜¯é…ç½®æ–‡ä»¶é‡Œå†™é”™äº† deploy.sh1sed -i 's/github.com\\/jingtianer/jingtianer.github.io/g' public/atom.xml ä»£ç å—å¤åˆ¶æŒ‰é’®ä¼˜åŒ– icarusçš„ä»£ç å—å¤åˆ¶æŒ‰é’®ç‚¹å‡»ååªä¼šé€‰ä¸­ä»£ç ï¼Œå¸Œæœ›ç‚¹å‡»åèƒ½è‡ªåŠ¨å¤åˆ¶åˆ°å‰ªåˆ‡æ¿ source/js/clickClipBoard.js12345678910111213141516171819202122232425262728293031323334353637function copyToClipboard(text, callBack) { navigator.clipboard.writeText(text).then( value =&gt; { // fulfillment callBack() }, reason =&gt; { // rejection alert(&quot;fail: &quot; + reason) } )}$(document).ready(function() { $(&quot;.copy&quot;).click(function() { copyCode(this) })})function copyCode(element) { if (element instanceof Element) { var elemt = element while(elemt.tagName != &quot;FIGURE&quot;) { elemt = elemt.parentElement } elemt = elemt.getElementsByClassName(&quot;code&quot;)[0] var text =elemt.innerText copyToClipboard(text, function() { var node = $(element.childNodes[0]) node.attr('class', &quot;fa fa-check&quot;) setTimeout(function () { node.attr('class', &quot;fas fa-copy&quot;) } ,1000) }) } } hexo-pdf åœ°å€ usage1{% pdf ./bash_freshman.pdf %} mermaid.jsæ”¯æŒå®‰è£…hexo-filter-mermaid-diagrams1npm install hexo-filter-mermaid-diagrams ç¼–å†™mermaidInitializer.jsï¼Œå¹¶æ·»åŠ åˆ°layout.jsxä¸­source/js/mermaidInitializer.js12345import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.6.0/+esm'function initMermaid() { mermaid.initialize({ startOnLoad: true })}initMermaid() layout.jsx1&lt;script type=&quot;module&quot; src=&quot;/home/js/mermaidInitializer.js&quot;&gt;&lt;/script&gt; æµ‹è¯•ä¸€ä¸‹graph TD A[å¼€å§‹] --> B{æ¡ä»¶åˆ¤æ–­} B -->|æ˜¯| C[æ‰§è¡Œæ“ä½œ] B -->|å¦| D[ç»“æŸ] C --> D","link":"/home/2022/10/26/misc/hexo%E9%85%8D%E7%BD%AE&%E8%B8%A9%E5%9D%91&%E8%87%AA%E5%AE%9A%E4%B9%89/"},{"title":"ç‰›å®¢åˆ·é¢˜-1","text":"å°ç±³2019ç§‹æ‹›å®‰å“å¼€å‘ç¬”è¯•é¢˜ï¼ˆBï¼‰21. æœ€å°‘ç«‹æ–¹æ•°ä¹‹å’Œç»™å‡ºä¸€ä¸ªæ•°å­—Nï¼ˆ0&lt;N&lt;1000000ï¼‰,å°†Nå†™æˆç«‹æ–¹æ•°å’Œçš„å½¢å¼ï¼Œæ±‚å‡ºéœ€è¦çš„æœ€å°‘ç«‹æ–¹æ•°ä¸ªæ•°ã€‚ä¾‹å¦‚N=17ï¼Œ1+8+8 = 17ï¼Œæœ€å°‘éœ€è¦3ä¸ªç«‹æ–¹æ•°ï¼Œåˆ™è¾“å‡º3ã€‚N= 28,1+1+1+1+8+8+8=28, éœ€è¦7ä¸ªç«‹æ–¹æ•°ï¼Œ1+27=28,éœ€è¦2ä¸ªç«‹æ–¹æ•°ï¼Œæ‰€ä»¥æœ€å°‘ç«‹æ–¹æ•°ä¸º2ï¼Œåˆ™è¾“å‡º2ã€‚ 12345678910111213141516171819202122232425262728293031323334353637import java.util.*; // æ³¨æ„ç±»åå¿…é¡»ä¸º Main, ä¸è¦æœ‰ä»»ä½• package xxx ä¿¡æ¯public class Main { private static final List&lt;Integer&gt; cubs; private static final int cubNum; static { cubs = new ArrayList&lt;Integer&gt;(); for(int i = 1; i*i*i &lt;= 1000000; i++) { cubs.add(i*i*i); } cubNum = cubs.size(); } public static void main(String[] args) { Scanner in = new Scanner(System.in); // æ³¨æ„ hasNext å’Œ hasNextLine çš„åŒºåˆ« while (in.hasNextInt()) { // æ³¨æ„ while å¤„ç†å¤šä¸ª case int n = in.nextInt(); int index = Collections.binarySearch(cubs, n); if(index &lt; 0) { index = -index - 2; } if(index &lt; 0) { throw new RuntimeException(&quot;unreachable&quot;); } int[] dp = new int[n+1]; Arrays.fill(dp, Integer.MAX_VALUE); dp[0] = 0; for(int j = 1; j &lt;= index+1; j++) { for(int i = cubs.get(j-1); i &lt;= n; i++) { dp[i] = Math.min(dp[i], dp[i - cubs.get(j-1)] + 1); } } System.out.println(dp[n]); } }} å®Œå…¨èƒŒåŒ…ï¼Œä»æ‰€æœ‰ç«‹æ–¹æ•°é‡Œé€‰æ•°ï¼Œå–æ•°ç›®æœ€å°çš„æƒ…å†µ èµ„äº§åŒ…æ‰“åŒ…åœ¨é‡‘èèµ„äº§äº¤æ˜“ä¸­ï¼Œç»å¸¸æ¶‰åŠåˆ°èµ„äº§åŒ…çš„æŒ‘é€‰æ‰“åŒ…ã€‚åœ¨èµ„äº§åŒ…æ‰“åŒ…è¿‡ç¨‹ä¸­ï¼Œæ¯ç§ç±»å‹çš„èµ„äº§æœ‰å›ºå®šçš„æ•°é‡ä¸ä»·å€¼ï¼Œéœ€é€‰æ‹©æŸå‡ ç§èµ„äº§æ‰“åŒ…ï¼Œä½¿å¾—èµ„äº§åŒ…æ€»ä»·å€¼æœ€å¤§ã€‚æ‰“åŒ…æ—¶æ¯ç§èµ„äº§åªèƒ½æ•´ä½“æ‰“åŒ…ï¼Œä¸èƒ½åˆ†å‰²ã€‚å‡è®¾ç°æœ‰å¯å®¹çº³Mæ¡èµ„äº§çš„èµ„äº§åŒ…ï¼Œå¦å¤–æœ‰Nç§èµ„äº§ã€‚èµ„äº§Naæ•°é‡ä¸ºTaæ¡ï¼Œæ€»ä»·å€¼ä¸ºVaå…ƒï¼›èµ„äº§Nbæ•°é‡ä¸ºTbæ¡ï¼Œæ€»ä»·å€¼ä¸ºVbå…ƒï¼›èµ„äº§Ncæ•°é‡ä¸ºTcæ¡ï¼Œæ€»ä»·å€¼ä¸ºVcå…ƒâ€¦â€¦ï¼›èµ„äº§Nnæ•°é‡ä¸ºTnï¼Œæ€»ä»·å€¼ä¸ºVnã€‚ç¼–å†™ç®—æ³•ï¼ŒæŒ‘é€‰å“ªäº›ç±»å‹èµ„äº§æ”¾å…¥èµ„äº§åŒ…å¯ä½¿å¾—èµ„äº§åŒ…æ€»ä»·å€¼æœ€å¤§ï¼Ÿ 12345678910111213141516171819202122232425262728293031import java.util.Scanner;// æ³¨æ„ç±»åå¿…é¡»ä¸º Main, ä¸è¦æœ‰ä»»ä½• package xxx ä¿¡æ¯public class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); while (in.hasNext()) { String[] input = in.nextLine().split(&quot;,&quot;); int index = 0; int W = Integer.parseInt(input[index++], 10); int N = Integer.parseInt(input[index++], 10); int[][] properties = new int[N][2]; String[] weights = input[index++].split(&quot; &quot;); for (int i = 0; i &lt; N; i++) { properties[i][0] = Integer.parseInt(weights[i], 10); } String[] values = input[index++].split(&quot; &quot;); for (int i = 0; i &lt; N; i++) { properties[i][1] = Integer.parseInt(values[i], 10); } int[] dp = new int[W + 1]; for (int i = 1; i &lt;= N; i++) { for (int j = W; j &gt;= properties[i - 1][0]; j--) { dp[j] = Math.max(dp[j], dp[j - properties[i - 1][0]] + properties[i - 1][1]); } } System.out.println(dp[W]); } }} 0-1èƒŒåŒ…ï¼Œè¦æ³¨æ„0-1èƒŒåŒ…å’Œå®Œå…¨èƒŒåŒ…çš„åŒºåˆ« æ— å‹ç¼©æƒ…å†µ 0-1èƒŒåŒ…è½¬ç§»æ–¹ç¨‹ä¸ºï¼š dp[i][j] = max(dp[i][j], dp[i-1][j-wi]+vi) (å½“j &gt;= wiæ—¶) dp[i][j] = dp[i][j] (å½“j &lt; wiæ—¶) å®Œå…¨èƒŒåŒ…è½¬ç§»æ–¹ç¨‹ä¸ºï¼š dp[i][j] = max(dp[i][j], dp[i][j-wi]+vi) (å½“j &gt;= wiæ—¶) è¿™é‡Œæ˜¯dp[i] dp[i][j] = dp[i][j] (å½“j &lt; wiæ—¶) æœ‰å‹ç¼©æƒ…å†µ 0-1èƒŒåŒ…å¯¹å®¹é‡æ˜¯é€†å‘éå† å®Œå…¨èƒŒåŒ…æ˜¯æ­£å‘éå† superå’Œthiså…³é”®å­— this()å’Œsuper()ä¸å¯ä»¥åŒæ—¶å‡ºç°åœ¨åŒä¸€ä¸ªæ„é€ å‡½æ•°ä¸­ this()æˆ–super()è¦æ”¾åœ¨æ„é€ å‡½æ•°ç¬¬ä¸€è¡Œ Androidæ•°æ®å­˜å‚¨æ–¹å¼ SharedPreference File SQLite Content Provider ç½‘ç»œ é¢˜ç›®ä¸­è¯´Bundleä¹Ÿå¯ä»¥ï¼Œä½†æ˜¯åº”è¯¥ä¸å¯¹Bundleæ˜¯å¯ä»¥åºåˆ—åŒ–ï¼Œä½†æ˜¯ä¸€èˆ¬ä¸ä½œä¸ºå­˜å‚¨æ•°æ®çš„æ–¹å¼ å¹¿æ’­ Ã— å½“é™æ€æ³¨å†Œçš„å¹¿æ’­è®¾ç½®çš„ä¼˜å…ˆçº§é«˜äºåŠ¨æ€æ³¨å†Œçš„å¹¿æ’­æ—¶ï¼Œé™æ€æ³¨å†Œå°†å…ˆæ¥æ”¶åˆ°å¹¿æ’­ åŠ¨æ€å¹¿æ’­è·ŸéšActivity/Applicationçš„ç”Ÿå‘½å‘¨æœŸï¼Œé™æ€å¹¿æ’­ä¸å—é™åˆ¶ã€‚ éæœ‰åºå¹¿æ’­çš„æƒ…å†µä¸‹ï¼ŒåŠ¨æ€å¹¿æ’­æ€»æ˜¯è¦ä¼˜å…ˆäºé™æ€å¹¿æ’­ æ¯æ¬¡å¹¿æ’­è¢«æ¥æ”¶åä¼šé‡æ–°åˆ›å»ºBroadcastReceiverå¯¹è±¡ï¼Œå¹¶åœ¨onReceiveæ–¹æ³•ä¸­æ‰§è¡Œå®Œæ—¶é”€æ¯ AndroidåŠ¨ç”»åˆ†ç±»IntentServiceï¼ˆå·²ç»å¼ƒç”¨ï¼‰ å¯¹Serviceçš„åŒ…è£… é»˜è®¤å®ç°onBindï¼Œè¿”å›null åŒ…å«ä¸€ä¸ªHandlerThread(çš„looper)ï¼Œï¼ˆServiceæœ¬èº«ä¸åŒ…æ‹¬çº¿ç¨‹ï¼Œè¿è¡Œåœ¨ä¸»çº¿ç¨‹ï¼‰ æŒæœ‰ä¸€ä¸ªhandlerï¼Œæ¯æ¬¡startæŠŠintentæ”¾å…¥msgçš„objé‡Œï¼Œç”¨handlerå‘é€ 12@Deprecatedpublic abstract class IntentService extends Service { 12345678910111213141516171819202122232425262728private final class ServiceHandler extends Handler { public ServiceHandler(Looper looper) { super(looper); } @Override public void handleMessage(Message msg) { onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); }}@WorkerThreadprotected abstract void onHandleIntent(@Nullable Intent intent); //è¿è¡Œåœ¨WorkerThreadä¸­@Overridepublic void onStart(@Nullable Intent intent, int startId) { Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg);}@Overridepublic int onStartCommand(@Nullable Intent intent, int flags, int startId) { onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;} å°ç±³2019ç§‹æ‹›å®‰å“å¼€å‘ç¬”è¯•é¢˜ï¼ˆAï¼‰è¿›åˆ¶é—´è½¬æ¢è®¾è®¡ä¸€ä¸ªå‡½æ•°ï¼Œ å¯ä»¥å°†ä»»æ„åè¿›åˆ¶çš„æ•°ï¼Œ è½¬æ¢æˆä»»æ„2åˆ°9çš„è¿›åˆ¶è¡¨ç¤ºçš„å½¢å¼ 123456789101112131415161718192021222324import java.util.Scanner;// æ³¨æ„ç±»åå¿…é¡»ä¸º Main, ä¸è¦æœ‰ä»»ä½• package xxx ä¿¡æ¯public class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); // æ³¨æ„ hasNext å’Œ hasNextLine çš„åŒºåˆ« while (in.hasNext()) { // æ³¨æ„ while å¤„ç†å¤šä¸ª case long n = in.nextLong(); int base = in.nextInt(); if(n == 0) { System.out.println(&quot;0&quot;); continue; } StringBuilder sb = new StringBuilder(); while(n &gt; 0) { sb.append(n % base); n /= base; } sb.reverse(); System.out.println(sb); } }} CCNumberCCæœ€è¿‘å¯¹ä¸€ç§æ•´æ•°æ¯”è¾ƒæ„Ÿå…´è¶£ï¼Œæˆ‘ä»¬æš‚ä¸”æŠŠè¿™ç§æ•´æ•°ç§°ä¸ºC Number, C Numberæ˜¯æŒ‡ä¸€ä¸ªæ•´æ•°{C0, C1 â€¦ Cn-1} (C0 &gt; 0 , n &gt;= 3)ï¼Œ å­˜åœ¨ä¸€ä¸ªCmï¼ˆ0&lt;m&lt;n-1ï¼‰æ»¡è¶³ä»¥ä¸‹æ¡ä»¶: Ci-1 &lt; Ci (0&lt;i&lt;=m), Ciä»£è¡¨è¿™ä¸ªæ•´æ•°ä¸­çš„ç¬¬iä½æ•°å­— Ci&gt;Ci+1(m&lt;=i&lt;n-1) å¦‚æœä¸€ä¸ªæ•´æ•°é‡Œé¢æœ‰ç›¸é‚»çš„2ä¸ªC Numberçš„è¯ï¼Œæˆ‘ä»¬ç§°è¿™ä¸ªæ•´æ•°ä¸ºCC Numberï¼ˆ2ä¸ªC Numberä¸å¯ä»¥æœ‰å…¬ç”¨çš„æ•°å­—Ciï¼Œå¹¶ä¸”2ä¸ªC Numberè¦ç´§ç´§ç›¸é‚»ï¼‰ã€‚ è¯·åœ¨[A,B]åŒºé—´å†…æ‰¾å‡ºæ‰¾å‡ºscoreæœ€å¤§çš„CCNumber å¹¶è¾“å‡ºè¿™ä¸ªscore.(scoreï¼šCC Numberä¸­æ‰€æœ‰æ•°å­—çš„å’Œ) Activityè·³è½¬FirstActivityè·³è½¬åˆ°SecondActivityåï¼Œç„¶åç‚¹å‡»è¿”å›é”®ï¼Œä»¥ä¸‹æ‰§è¡Œé¡ºåºä¸å¯èƒ½å‡ºç°çš„æ˜¯ï¼š SecondActivityçš„onPause()-&gt;SecondActivityçš„onStop()-&gt;SecondActivityçš„onDestroy()-&gt;FirstActivityçš„onRestart()-&gt;FirstActivityçš„onResume() ä¸ä¼šåœ¨ä¸‹ä¸€ä¸ªActivityå¯è§å‰ï¼ŒæŠŠå½“å‰Activityå˜æˆä¸å¯è§çš„ï¼Œï¼ˆè¿›å…¥stop/destroyï¼‰ ANRinputäº‹ä»¶åœ¨5så†…æ²¡æœ‰å¤„ç†å®Œæˆä¼šå‘ç”ŸANRå‰å°å¹¿æ’­çš„onReceiveå¤„ç†äº‹åŠ¡æ—¶è¶…è¿‡10sä¼šå‘ç”ŸANRåå°Serviceåœ¨200så†…æ²¡æœ‰å¤„ç†å®Œæˆä¼šå‘ç”ŸANRå‰å°Serviceåœ¨20så†…æ²¡æœ‰å¤„ç†å®Œæˆä¼šå‘ç”ŸANRåœ¨Activityä¸­ï¼ŒMainçº¿ç¨‹æ¶ˆæ¯é˜Ÿåˆ—ä¸­çš„æ¶ˆæ¯åœ¨5ç§’å†…æ²¡æœ‰å¾—åˆ°å“åº” APPè¿›ç¨‹ ä¸€ä¸ªAPPå¯ä»¥è¿è¡Œåœ¨å¤šä¸ªè¿›ç¨‹ åœ¨Activity/Serviceä¸­æ·»åŠ ä¸åŒçš„è¿›ç¨‹åandroid:process=&quot;processName&quot; æ¯ä¸ªè¿›ç¨‹ä¼šæœ‰ä¸€ä¸ªApplicationå¯¹è±¡ å¤šä¸ªAPPå¯ä»¥è¿è¡Œåœ¨åŒä¸€è¿›ç¨‹ åœ¨Manifestä¸­æ·»åŠ android:sharedUserId=&lt;java package&gt; åœ¨Manifestä¸­æ·»åŠ android:sharedUserLabel=@string/id åœ¨Applicationä¸­æ·»åŠ android:process=&quot;processName&quot; é¡ºä¸°ç§‘æŠ€2019ç§‹æ‹›å®‰å“å¼€å‘å·¥ç¨‹å¸ˆç¬”è¯•å®¢è§‚é¢˜åˆé›†select intoå’Œinsert into1SELECT xxx INTO target_table FROM origin_table è¦æ±‚æ‰§è¡Œå‰è¡¨ä¸å­˜åœ¨ï¼Œä¼šè‡ªåŠ¨åˆ›å»º 1INSERT INTO target_table (filed1, field2, ...) VALUES (val1, val2, ...) è¦æ±‚æ‰§è¡Œå‰è¡¨å·²ç»å­˜åœ¨ EventBusç®€å•å®ç°ä¸€å¥—viewçš„æ³¨å…¥æ¡†æ¶ï¼ˆï¼‰åº¦å°æ»¡æ ¡æ‹›Androidç ”å‘å·¥ç¨‹å¸ˆç¬¬2æ‰¹è¿‘ä¼¼å‘¨æœŸä¸²å°æ˜å‘ç°æœ‰çš„å­—ç¬¦ä¸²ä¸­è•´å«ç€ä¸€äº›è§„å¾‹ï¼Œä½†æ˜¯å®ƒä»¬åˆå’Œæ™®é€šçš„å‘¨æœŸä¸²æœ‰ç‚¹ä¸ä¸€æ ·ã€‚ä¾‹å¦‚:ABCABDABDABEã€‚å¦‚æœä»¥3ä¸ºå‘¨æœŸï¼Œå¯ä»¥çœ‹åˆ°å…¶ä¸­ åŒ…å«â€œABCâ€ã€â€œABDâ€å’Œâ€œABEâ€ç­‰å­ä¸²ï¼Œå…¶ä¸­â€œABDâ€å‡ºç°äº†ä¸¤æ¬¡ã€‚ è¿™äº›å­ä¸²ä¸¤ä¸¤ä¹‹é—´æœ€å¤šåªæœ‰æŸä¸€ä½ä¸Šçš„å­—ç¬¦ä¸ç›¸åŒï¼Œå…¶ä»–ä½ç½®ä¸Šçš„å­—ç¬¦éƒ½ä¸€æ ·ã€‚å°æ˜å°†å…¶ç§°ä¸ºâ€œè¿‘ä¼¼ä¸²â€ï¼Œç”±å¤šä¸ªâ€œè¿‘ä¼¼ä¸²â€ç»„æˆçš„å­—ç¬¦ä¸²ç§°ä¸ºâ€œè¿‘ ä¼¼å‘¨æœŸä¸²â€ã€‚â€œè¿‘ä¼¼å‘¨æœŸä¸²â€ä¸­çš„æ¯ä¸€ä¸ªâ€œè¿‘ä¼¼ä¸²â€çš„é•¿åº¦éœ€å¤§äºç­‰äº2ã€‚ éœ€è¦æ³¨æ„çš„æ˜¯â€œABCABBACDâ€å¹¶ä¸æ˜¯ä¸€ä¸ªâ€œè¿‘ä¼¼å‘¨æœŸä¸²â€ã€‚å¦‚æœä»¥3ä¸ºå‘¨æœŸï¼Œå…¶å­ä¸²åŒ… æ‹¬â€œABCâ€ã€â€œABBâ€å’Œâ€œACDâ€ï¼Œâ€œABBâ€ä¸â€œACDâ€ã€â€œABCâ€ä¸â€œACDâ€å‡å­˜åœ¨ä¸¤ä¸ªä½ç½®ä¸Šçš„å­—ç¬¦ä¸ç›¸åŒï¼Œå› æ­¤ä¸æ˜¯â€œè¿‘ä¼¼å‘¨æœŸä¸²â€ã€‚ç‰¹åˆ« çš„ï¼Œâ€œAAAAAAâ€ä¹Ÿæ˜¯ä¸€ä¸ªâ€œè¿‘ä¼¼å‘¨æœŸä¸²â€ï¼Œå› ä¸ºå®ƒæ»¡è¶³ä¸Šè¿°â€œè¿‘ä¼¼å‘¨æœŸä¸²â€çš„å®šä¹‰ã€‚ ç°åœ¨ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¯·ç¼–å†™ä¸€ä¸ªç¨‹åºåˆ¤æ–­è¯¥å­—ç¬¦ä¸²æ˜¯å¦æ˜¯ä»¥3ä¸ºå‘¨æœŸçš„â€œè¿‘ä¼¼å‘¨æœŸä¸²â€ã€‚ 1234567891011121314151617181920212223242526import java.util.Scanner; // æ³¨æ„ç±»åå¿…é¡»ä¸º Main, ä¸è¦æœ‰ä»»ä½• package xxx ä¿¡æ¯public class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); // æ³¨æ„ hasNext å’Œ hasNextLine çš„åŒºåˆ« while (in.hasNextInt()) { // æ³¨æ„ while å¤„ç†å¤šä¸ª case int n = in.nextInt(); while(n-- &gt; 0) { String s = in.nextLine(); int i = 0; int ans = 0; while(i &lt; s.length()) { ans = ans ^ ((s.charAt(i) - 'A') &lt;&lt; 2) + ((s.charAt(i+1) - 'A') &lt;&lt; 1) + (s.charAt(i+2) - 'A'); i += 3; } if((ans &amp; (ans-1)) != 0) { System.out.println(&quot;No&quot;); } else { System.out.println(&quot;Yes&quot;); } } } }} DNSDNSè¾…åŠ©æœåŠ¡å™¨ä¸DNSä¸»æœåŠ¡å™¨é€šè®¯æ—¶ä½¿ç”¨TCPåè®® Androidé¢˜åº“onNewIntent()çš„è§¦å‘æ—¶æœºè®¾å¤‡ç®¡ç†å™¨æƒé™sleep,wait,yield,joinçš„åŒºåˆ«sleep,yield: è®©æ¸¡cpuä½¿ç”¨æƒï¼Œä¸é‡Šæ”¾é”wait: ç›¸å½“äºæ¡ä»¶å˜é‡ï¼Œé‡Šæ”¾é”join: åº•å±‚è°ƒç”¨äº†wait Hookæ¡†æ¶xposed,Substrate,Cydia,frida dexç„¦ç‚¹toastæ²¡æœ‰ç„¦ç‚¹ Viewç»˜åˆ¶æµç¨‹ContentProviderdrawable-xxhdpiç­‰ç›®å½•æºç¨‹ç¬”è¯•ç®—æ³•1 ç»™nä¸ªæ•°1 &lt;= ai &lt;= 1e6ï¼Œ æ±‚PI(ai!)aiçš„é˜¶ä¹˜çš„ç§¯ä¸­å› æ•°çš„ä¸ªæ•° åˆ†è§£è´¨å› æ•° è´¨å› æ•°å‡ºç°æ¬¡æ•°+1çš„ç§¯å°±æ˜¯åŸæ¥æ•°å­—çš„å› æ•°ä¸ªæ•° å¯¹æ•°ç»„æ’åºï¼Œè®¡ç®—æ¯ä¸ªæ•°åœ¨é˜¶ä¹˜ä¸­å‡ºç°çš„æ¬¡æ•°ï¼Œè®¡ç®—æ¯ä¸ªæ•°çš„è´¨å› æ•°ï¼Œè´¨å› æ•°ä¸ªæ•°ä¸ºå‡ºç°æ¬¡æ•° è®¡ç®—æ‰€æœ‰æ•°çš„è´¨å› æ•°å‡ºç°æ¬¡æ•°*è¯¥æ•°åœ¨é˜¶ä¹˜ä¸­å‡ºç°çš„æ¬¡æ•° 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.*;import java.util.function.UnaryOperator;public class Main { private static final int MOD = 1000000000 + 7; private static final int MAX_VAL = 1000000; private static &lt;K, V&gt; void mapReplace(Map&lt;K, V&gt; map, K key, V def, UnaryOperator&lt;V&gt; operator) { V old = map.get(key); map.put(key, operator.apply(old == null ? def : old)); } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); List&lt;Integer&gt; primes = new ArrayList&lt;&gt;(List.of(2, 3)); for(int i = 5; i &lt;= MAX_VAL; i+=2) { boolean flag = true; for(int j = 3; j*j &lt;= i; j++) { if(i % j == 0) { flag = false; break; } } if (flag) { primes.add(i); } } while(scanner.hasNext()) { int n = scanner.nextInt(); int[] arr = new int[n]; Map&lt;Integer, Integer&gt; cnt = new HashMap&lt;&gt;(); for(int i = 0; i &lt; n; i++) { arr[i] = scanner.nextInt(); } Arrays.sort(arr); for(int j = 1; j &lt;= arr.length; j++) { final int incr = (arr.length - j + 1); if(Collections.binarySearch(primes, arr[j-1]) &gt;= 0) { mapReplace(cnt, arr[j-1], 0, (old) -&gt; (old + incr) % MOD); continue; } for(int i = 1; i &lt;= primes.size(); i++) { int val = arr[j-1]; int prime = primes.get(i-1); while(val % prime == 0) { val = val / prime; mapReplace(cnt, prime, 0, (old) -&gt; (old + incr) % MOD); } } } long ans = 1; for(var entry : cnt.entrySet()) { ans = (ans * (entry.getValue() + 1)) % MOD; } System.out.println(ans); } }} åˆ·é¢˜ è´¦å·å¡”å­å“¥æœ‰nä¸ªè´¦å·ï¼Œæ¯ä¸ªè´¦å·ç²‰ä¸æ•°ä¸ºai è¿™å¤©ä»–åˆåˆ›å»ºäº†ä¸€ä¸ªæ–°è´¦å·ï¼Œä»–å¸Œæœ›æ–°è´¦å·çš„ç²‰ä¸æ•°æ°å¥½ç­‰äºxã€‚ä¸ºæ­¤ä»–å¯ä»¥å‘è‡ªå·±å·²æœ‰è´¦å·çš„ç²‰ä¸ä»¬æ¨èè‡ªå·±çš„æ–°è´¦å·ï¼Œè¿™æ ·ä»¥æ¥æ–°è´¦å·å°±å¾—åˆ°äº†ä¹‹å‰ç²‰ä¸çš„å…³æ³¨ã€‚ä»–æƒ³çŸ¥é“ï¼Œä»–æœ€å°‘éœ€è¦åœ¨å‡ ä¸ªæ—§è´¦å·å‘â€œæ¨èæ–°è´¦å·â€çš„æ–‡ç« ï¼Œå¯ä»¥ä½¿å¾—ä»–çš„æ–°è´¦å·ç²‰ä¸æ•°æ°å¥½ä¸º xï¼Œé™¤æ­¤ä»¥å¤–ï¼Œä»–å¯ä»¥æœ€å¤šä»ä¸­é€‰æ‹©ä¸€ä¸ªè´¦å·å¤šæ¬¡å‘â€œæ¨èæ–°è´¦å·â€çš„æ–‡ç« ã€‚ å‡è®¾ä¸€ä¸ªæ—§è´¦å·ç²‰ä¸æ•°ä¸ºaiï¼Œå¦‚æœä»…æ¨èä¸€æ¬¡ï¼Œé‚£ä¹ˆæ–°è´¦å·ç²‰ä¸æ•°å¢åŠ ai/2ï¼Œå¦‚æœå¤šä»¥æ¨èï¼Œåˆ™ç²‰ä¸æ•°å¢åŠ ai è¯»é¢˜è¯»é”™äº†ï¼Œåªèƒ½é€‰ä¸€ä¸ªè´¦å·æ¨å¹¿å¤šæ¬¡ 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int main() { int n, x; while(cin &gt;&gt; n &gt;&gt; x) { vector&lt;int&gt; accounts(n); for(int i = 0; i &lt; n; i++) { cin &gt;&gt; accounts[i]; } vector&lt;int&gt; dp(x+1, n+1); // ä¸€æ¬¡ vector&lt;int&gt; dp1(x+1, n+1); // æœ‰æŸä¸€ä¸ªè´¦å·æ˜¯å¤šæ¬¡çš„æƒ…å†µ dp[0] = 0; dp1[0] = 0; for(int i = 1; i &lt;= n; i++) { for(int j = x; j &gt;= 1; j--) { if(j &gt;= accounts[i-1]) dp1[j] = min(dp1[j], dp[j - accounts[i-1]] + 1); // è¯¥è´¦å·å¤šæ¬¡å‘å¸ƒ if(j &gt;= accounts[i-1]/2) dp1[j] = min(dp1[j], dp1[j - accounts[i-1]/2] + 1); // ä¸Šä¸€ä¸ªè´¦å·å¤šæ¬¡å‘å¸ƒï¼Œè¯¥è´¦å·ä¸å¤šæ¬¡å‘å¸ƒ if(j &gt;= accounts[i-1]/2) dp[j] = min(dp[j], dp[j - accounts[i-1]/2] + 1); } } cout &lt;&lt; (min(dp[x], dp1[x]) &gt; n ? -1 : min(dp[x], dp1[x])) &lt;&lt; &quot;\\n&quot;; } return 0;} é¢˜ç›®ä¸€ä¸ªæ­£æ•´æ•™xï¼Œåœ¨åŒºé—´[l, r]ä¸­é€‰æ ·ä¸€ä¸ªæ•°yï¼Œæ»¡å®šx*yæ˜¯å®Œå…¨å¹³ä¸‡æ•°ã€‚æƒ³çŸ¥é“æœ‰å¤šå°‘ç§é€‰æ‹©æ–¹æ¡ˆ?ä¸€å…±æœ‰qæ¬¡è¯¢é—® 1 &lt;= q &lt;= 1e41 &lt;= x &lt;= 1e141 &lt;= l, r &lt;= 1e14 æ€è·¯ æˆ‘ä»¬è¦æ‰¾æ‰€æœ‰y*x == t*tçš„æ•°yï¼Œä¹Ÿå°±æ˜¯æ‰¾æ‰€æœ‰çš„y=t*t/x ä¸” t*t%x == 0 æ‰€æœ‰æ»¡è¶³t*t%x == 0çš„æ•°(t*t/x)ï¼Œ(t*t/x)åœ¨[1, 1e14]èŒƒå›´å†… ä¹Ÿå°±æ˜¯t*t=q*x å› ä¸ºt,q,xéƒ½æ˜¯æ•´æ•°ï¼Œæ‰€ä»¥sqrt(q*x)æ˜¯æ•´æ•°ä¹Ÿå°±æ˜¯qå¯ä»¥å†™æˆi*i*xçš„å½¢å¼ ä¹Ÿå°±æ˜¯t=i*x ä¹Ÿå°±æ˜¯æ‰¾åˆ°æ‰€æœ‰i*i*xï¼Œä¸”åœ¨[1, 1e14]èŒƒå›´å†… 12345678910111213141516171819202122232425import java.util.*;public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while(scanner.hasNext()) { int q = scanner.nextInt(); long x = scanner.nextLong(); List&lt;Long&gt; isSquare = new ArrayList&lt;&gt;(); for(long i = 1; i*i*x &lt;= 1e14; i++) { isSquare.add(i*i*x); } for(int i = 0; i &lt; q; i++) { long l = scanner.nextLong(); long r = scanner.nextLong(); int leftIndex = Collections.binarySearch(isSquare, l); int rightIndex = Collections.binarySearch(isSquare, r); if(leftIndex &lt; 0) leftIndex = -leftIndex-1; if(rightIndex &lt; 0) rightIndex = -rightIndex-1; else rightIndex++; System.out.println(rightIndex - leftIndex); } } }} 2024.3.31 é—®é¢˜5æ–¹é˜µé‡Œé¢ä¸Šä¸‹å·¦å³èµ°æ‰¾tencent é—®é¢˜4æ•°ç»„åˆ†æˆkç»„ï¼Œæ¯ç»„å†…éƒ¨å¼‚æˆ–ï¼Œæ±‚kç»„å¼‚æˆ–å’Œæœ€å¤§ é—®é¢˜3ä¸€ä¸ªå›¾ï¼ŒåŠ ä¸€ä¸ªè¾¹æ°å¥½å¯ä»¥è¿é€šæœ‰å‡ ç§åŠ æ³• é—®é¢˜2ä¸€ä¸ªæ•°ç»„ï¼Œåˆ†æˆä¸¤æ®µï¼ˆå¯ç©ºï¼‰ï¼Œæ˜¯å¦æ°å¥½å¯ä»¥é‡æ–°æ’åˆ—æˆé€’å¢ é—®é¢˜1è¾¹æœ‰RWä¸¤è‰²å¦‚æœä¸€ä¸ªç‚¹å‘¨å›´çš„è¾¹å…¨éƒ½æ˜¯Rï¼Œåˆ™æ˜¯å¥½ç‚¹ï¼Œç»Ÿè®¡å¥½ç‚¹çš„ä¸ªæ•° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188import java.util.*;import java.util.stream.IntStream;import java.util.stream.Stream;public class Main { private static final Scanner scanner = new Scanner(System.in); private static final String match = &quot;tencent&quot;; private static final int[] pos = {0, 1, 0, -1, 0}; private static int dfs5(int i, int j, int n, int m, int len, String[] map) { if(i &gt;= n || j &gt;= m || i &lt; 0 || j &lt; 0) return 0; if(match.charAt(len) != map[i].charAt(j)) return 0; if(len == 6) return 1; int ans = 0; for(int k = 0; k &lt; pos.length - 1; k++) { ans += dfs5(i + pos[k], j + pos[k+1], n, m, len + 1, map); } return ans; } private static void problem5() { int n = scanner.nextInt(); int m = scanner.nextInt(); String[] map = new String[n]; scanner.nextLine(); for(int i = 0; i &lt; n; i++) { map[i] = scanner.nextLine(); } int ans = 0; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; m; j++) { ans += dfs5(i, j, n, m, 0,map); } } System.out.println(ans); } private static class UnionSet { private final int[] set; public UnionSet(int n) { set = IntStream.iterate(0, (prev)-&gt;prev+1).limit(n).toArray(); } public int find(int i) { return i == set[i] ? i : (set[i] = find(set[i])); } public void union(int i, int j) { set[find(i)] = find(j); } } private static void problem3() { int n = scanner.nextInt(); int m = scanner.nextInt(); UnionSet unionSet = new UnionSet(n); for(int i = 0; i &lt; m; i++) { int u = scanner.nextInt(); int v = scanner.nextInt(); unionSet.union(u-1, v-1); } Map&lt;Integer, Integer&gt; setCnt = new HashMap&lt;&gt;(); for(int i = 0; i &lt; n; i++) { int part = unionSet.find(i); if(!setCnt.containsKey(part)) { setCnt.put(part, 0); } setCnt.put(part, setCnt.get(part) + 1); } if(setCnt.size() != 2) { System.out.println(0); } else { int ans = 0; int diff = 0; for (var entry : setCnt.entrySet()) { diff += entry.getValue(); ans += (n - diff) * entry.getValue(); } // a1 a2 a3 ... an // a1*(a2 + a3 + a4 + ... + an) // a2*(a3 + a4 + a5 + ... + an) System.out.println(ans); } } private static void problem2() { char[] input = scanner.nextLine().toCharArray(); int i = 0; while(i &lt; input.length) { if(input[i] == '[' || input[i] == ']') { System.out.print(input[i]); i++; continue; } List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(input[i] == '{') { i++; while (i &lt; input.length) { int cur = 0; while(i &lt; input.length &amp;&amp; input[i] &gt;= '0' &amp;&amp; input[i] &lt;= '9') { cur *= 10; cur += input[i] - '0'; i++; } list.add(cur); if(i &lt; input.length) { i++; if(input[i-1] == '}') { if(input[i] == ',') i++; break; } } } } int seg1 = 1, seg2; while(seg1 &lt; list.size() &amp;&amp; list.get(seg1) &gt; list.get(seg1-1)) { seg1++; } seg2 = seg1 + 1; while(seg2 &lt; list.size() &amp;&amp; list.get(seg2) &gt; list.get(seg2-1)) { seg2++; } if(seg1 == list.size()) { System.out.print(&quot;true&quot;); } else if (seg2 != list.size()){ System.out.print(&quot;false&quot;); } else { if(list.get(list.size() - 1) &lt; list.get(0)) { System.out.print(&quot;true&quot;); } else { System.out.print(&quot;false&quot;); } } if(i &lt; input.length) { if(input[i] != ']') { System.out.print(&quot;,&quot;); } } } System.out.println(); } private static void problem1() { int node = scanner.nextInt(); int edge = scanner.nextInt(); boolean[] res = new boolean[node]; Arrays.fill(res, true); for(int i = 0; i &lt; edge; i++) { int u = scanner.nextInt(); int v = scanner.nextInt(); String c = scanner.next(); if(c.equals(&quot;R&quot;)) { } else { res[u-1] = res[v-1] = false; } } int ans = 0; for(int i = 0; i &lt; res.length; i++) { if(res[i]) ans++; } System.out.println(ans); } private static void problem4() { int n = scanner.nextInt(); int k = scanner.nextInt(); int[] arr = new int[n]; int[][] dp = new int[n+1][k+1]; int[] xorSum = new int[n+1]; for(int i = 0; i &lt; n; i++) { arr[i] = scanner.nextInt(); xorSum[i+1] = arr[i] ^ xorSum[i]; dp[i+1][1] = xorSum[i+1]; } for(int j = 2; j &lt;= k; j++) { for(int i = j; i &lt;= n; i++) { for(int m = j-1; m &lt; i; m++) { dp[i][j] = Math.max(dp[i][j], dp[m][j-1] + (xorSum[i] ^ xorSum[m])); } } } int ans = 0; for(int i = k; i &lt;= n; i++) { ans = Math.max(ans, dp[i][k]); } System.out.println(ans); } public static void main(String[] args) { while(scanner.hasNext()) { problem5(); problem4(); problem3(); problem2(); problem1(); } }}","link":"/home/2024/03/27/%E7%89%9B%E5%AE%A2/%E7%89%9B%E5%AE%A2%E5%88%B7%E9%A2%98-1/"},{"title":"ç‰›å®¢åˆ·é¢˜-2","text":"1.å°ç¾çš„å¹³è¡¡çŸ©é˜µ 1. å°ç¾çš„å¹³è¡¡çŸ©é˜µ å°ç¾æ‹¿åˆ°äº†ä¸€ä¸ªnâˆ—nn*nnâˆ—nçš„çŸ©é˜µï¼Œå…¶ä¸­æ¯ä¸ªå…ƒç´ æ˜¯ 0 æˆ–è€… 1ã€‚ å°ç¾è®¤ä¸ºä¸€ä¸ªçŸ©å½¢åŒºåŸŸæ˜¯å®Œç¾çš„ï¼Œå½“ä¸”ä»…å½“è¯¥åŒºåŸŸå†… 0 çš„æ•°é‡æ°å¥½ç­‰äº 1 çš„æ•°é‡ã€‚ ç°åœ¨ï¼Œå°ç¾å¸Œæœ›ä½ å›ç­”æœ‰å¤šå°‘ä¸ªiâˆ—ii*iiâˆ—içš„å®Œç¾çŸ©å½¢åŒºåŸŸã€‚ä½ éœ€è¦å›ç­”1â‰¤iâ‰¤n1\\leq i \\leq n1â‰¤iâ‰¤nçš„æ‰€æœ‰ç­”æ¡ˆã€‚ æ—¶é—´é™åˆ¶ï¼šC/C++ 1ç§’ï¼Œå…¶ä»–è¯­è¨€2ç§’ ç©ºé—´é™åˆ¶ï¼šC/C++ 256Mï¼Œå…¶ä»–è¯­è¨€512M è¾“å…¥æè¿°ï¼š ç¬¬ä¸€è¡Œè¾“å…¥ä¸€ä¸ªæ­£æ•´æ•°ï¼Œä»£è¡¨çŸ©é˜µå¤§å°ã€‚æ¥ä¸‹æ¥çš„è¡Œï¼Œæ¯è¡Œè¾“å…¥ä¸€ä¸ªé•¿åº¦ä¸ºçš„ 01 ä¸²ï¼Œç”¨æ¥è¡¨ç¤ºçŸ©é˜µã€‚ è¾“å‡ºæè¿°ï¼š è¾“å‡ºè¡Œï¼Œç¬¬è¡Œè¾“å‡ºçš„å®Œç¾çŸ©å½¢åŒºåŸŸçš„æ•°é‡ã€‚ ç¤ºä¾‹1 è¾“å…¥ä¾‹å­ï¼š 4 1010 0101 1100 0011 è¾“å‡ºä¾‹å­ï¼š 0 7 0 1 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() { int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; preSum(n, vector&lt;int&gt;(n+1)); for(int i = 0; i &lt; n; i++) { string s; cin &gt;&gt; s; for(int j = 0; j &lt; n; j++) { preSum[i][j+1] = preSum[i][j] + (s[j] - '0'); } } for(int window = 1; window &lt;= n; window++) { if(window &amp; 1) { cout &lt;&lt; &quot;0\\n&quot;; continue; } int perfect = 0; for(int j = 0; j &lt;= n - window; j++) { int sum = 0; for(int i = 0; i &lt; window; i++) { sum += preSum[i][window + j] - preSum[i][j]; } if(sum * 2 == window * window) { perfect++; } for(int i = window; i &lt; n; i++) { sum -= preSum[i - window][window + j] - preSum[i - window][j]; sum += preSum[i][window + j] - preSum[i][j]; if(sum * 2 == window * window) { perfect++; } } } cout &lt;&lt; perfect &lt;&lt; &quot;\\n&quot;; }} 2.å°ç¾çš„æ•°ç»„è¯¢é—® 2. å°ç¾çš„æ•°ç»„è¯¢é—® å°ç¾æ‹¿åˆ°äº†ä¸€ä¸ªç”±æ­£æ•´æ•°ç»„æˆçš„æ•°ç»„ï¼Œä½†å…¶ä¸­æœ‰ä¸€äº›å…ƒç´ æ˜¯æœªçŸ¥çš„ï¼ˆç”¨ 0 æ¥è¡¨ç¤ºï¼‰ã€‚ ç°åœ¨å°ç¾æƒ³çŸ¥é“ï¼Œå¦‚æœé‚£äº›æœªçŸ¥çš„å…ƒç´ åœ¨åŒºé—´[l,r][l,r][l,r]èŒƒå›´å†…éšæœºå–å€¼çš„è¯ï¼Œæ•°ç»„æ‰€æœ‰å…ƒç´ ä¹‹å’Œçš„æœ€å°å€¼å’Œæœ€å¤§å€¼åˆ†åˆ«æ˜¯å¤šå°‘ï¼Ÿ å…±æœ‰qqqæ¬¡è¯¢é—®ã€‚ æ—¶é—´é™åˆ¶ï¼šC/C++ 1ç§’ï¼Œå…¶ä»–è¯­è¨€2ç§’ ç©ºé—´é™åˆ¶ï¼šC/C++ 256Mï¼Œå…¶ä»–è¯­è¨€512M è¾“å…¥æè¿°ï¼š ç¬¬ä¸€è¡Œè¾“å…¥ä¸¤ä¸ªæ­£æ•´æ•°ï¼Œä»£è¡¨æ•°ç»„å¤§å°å’Œè¯¢é—®æ¬¡æ•°ã€‚ç¬¬äºŒè¡Œè¾“å…¥ä¸ªæ•´æ•°ï¼Œå…¶ä¸­å¦‚æœè¾“å…¥çš„ä¸º 0ï¼Œé‚£ä¹ˆè¯´æ˜æ˜¯æœªçŸ¥çš„ã€‚æ¥ä¸‹æ¥çš„è¡Œï¼Œæ¯è¡Œè¾“å…¥ä¸¤ä¸ªæ­£æ•´æ•° ï¼Œä»£è¡¨ä¸€æ¬¡è¯¢é—®ã€‚ è¾“å‡ºæè¿°ï¼š è¾“å‡ºè¡Œï¼Œæ¯è¡Œè¾“å‡ºä¸¤ä¸ªæ­£æ•´æ•°ï¼Œä»£è¡¨æ‰€æœ‰å…ƒç´ ä¹‹å’Œçš„æœ€å°å€¼å’Œæœ€å¤§å€¼ã€‚ ç¤ºä¾‹1 è¾“å…¥ä¾‹å­ï¼š 3 2 1 0 3 1 2 4 4 è¾“å‡ºä¾‹å­ï¼š 5 6 8 8 ä¾‹å­è¯´æ˜ï¼š åªæœ‰ç¬¬äºŒä¸ªå…ƒç´ æ˜¯æœªçŸ¥çš„ã€‚ç¬¬ä¸€æ¬¡è¯¢é—®ï¼Œæ•°ç»„æœ€å°çš„å’Œæ˜¯ 1+1+3=5ï¼Œæœ€å¤§çš„å’Œæ˜¯ 1+2+3=6ã€‚ç¬¬äºŒæ¬¡è¯¢é—®ï¼Œæ˜¾ç„¶æ•°ç»„çš„å…ƒç´ å’Œå¿…ç„¶ä¸º 8ã€‚ 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main() { int n, q; cin &gt;&gt; n &gt;&gt; q; long long sum = 0; long long zeroCnt = 0; for(int i = 0; i &lt; n; i++) { int ai; cin &gt;&gt; ai; zeroCnt += (ai == 0 ? 1 : 0); sum += ai; } for(int i = 0; i &lt; q; i++) { int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; sum + zeroCnt*l &lt;&lt; &quot; &quot; &lt;&lt; sum + zeroCnt*r &lt;&lt; &quot;\\n&quot;; }} 3.å°ç¾çš„ MT 3. å°ç¾çš„ MT MT æ˜¯ç¾å›¢çš„ç¼©å†™ï¼Œå› æ­¤å°ç¾å¾ˆå–œæ¬¢è¿™ä¸¤ä¸ªå­—æ¯ã€‚ ç°åœ¨å°ç¾æ‹¿åˆ°äº†ä¸€ä¸ªä»…ç”±å¤§å†™å­—æ¯ç»„æˆå­—ç¬¦ä¸²ï¼Œå¥¹å¯ä»¥æœ€å¤šæ“ä½œkkkæ¬¡ï¼Œæ¯æ¬¡å¯ä»¥ä¿®æ”¹ä»»æ„ä¸€ä¸ªå­—ç¬¦ã€‚å°ç¾æƒ³çŸ¥é“ï¼Œæ“ä½œç»“æŸåæœ€å¤šå…±æœ‰å¤šå°‘ä¸ª'M'å’Œ'T'å­—ç¬¦ï¼Ÿ æ—¶é—´é™åˆ¶ï¼šC/C++ 1ç§’ï¼Œå…¶ä»–è¯­è¨€2ç§’ ç©ºé—´é™åˆ¶ï¼šC/C++ 256Mï¼Œå…¶ä»–è¯­è¨€512M è¾“å…¥æè¿°ï¼š ç¬¬ä¸€è¡Œè¾“å…¥ä¸¤ä¸ªæ­£æ•´æ•°ï¼Œä»£è¡¨å­—ç¬¦ä¸²é•¿åº¦å’Œæ“ä½œæ¬¡æ•°ã€‚ç¬¬äºŒè¡Œè¾“å…¥ä¸€ä¸ªé•¿åº¦ä¸ºçš„ã€ä»…ç”±å¤§å†™å­—æ¯ç»„æˆçš„å­—ç¬¦ä¸²ã€‚ è¾“å‡ºæè¿°ï¼š è¾“å‡ºæ“ä½œç»“æŸåæœ€å¤šå…±æœ‰å¤šå°‘ä¸ª'M'å’Œ'T'å­—ç¬¦ã€‚ ç¤ºä¾‹1 è¾“å…¥ä¾‹å­ï¼š 5 2 MTUAN è¾“å‡ºä¾‹å­ï¼š 4 ä¾‹å­è¯´æ˜ï¼š ä¿®æ”¹ç¬¬ä¸‰ä¸ªå’Œç¬¬äº”ä¸ªå­—ç¬¦ï¼Œå½¢æˆçš„å­—ç¬¦ä¸²ä¸º MTTAMï¼Œè¿™æ ·å…±æœ‰ 4 ä¸ª'M'å’Œ'T'ã€‚ 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; int cnt = 0; cin.get(); for(int i = 0; i &lt; n; i++) { char c = cin.get(); if(c != 'M' &amp;&amp; c != 'T') cnt++; } cout &lt;&lt; n - cnt + min(k, cnt) &lt;&lt; endl; return 0;}// 64 ä½è¾“å‡ºè¯·ç”¨ printf(&quot;%lld&quot;) 4. å°ç¾çš„æœ‹å‹å…³ç³»1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;class UnionSet { vector&lt;int&gt; array; public: UnionSet(vector&lt;set&lt;int&gt;&gt; graph, int n): array(n) { iota(array.begin(), array.end(), 0); for(int u = 0; u &lt; n; u++) { for(int v : graph[u]) { Union(u, v); } } } UnionSet(const vector&lt;set&lt;int&gt;&gt;&amp; graph): UnionSet(graph, graph.size()) {} UnionSet(int n): array(n) { iota(array.begin(), array.end(), 0); } int Find(int u) { return u == array[u] ? u : (array[u] = Find(array[u])); } void Union(int u, int v) { array[Find(u)] = Find(v); } bool Query(int u, int v) { return Find(u) == Find(v); }};int main() { int n, m, q; cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; vector&lt;set&lt;int&gt;&gt; graph(n); for(int i = 0; i &lt; m; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; u--; v--; graph[u].insert(v); graph[v].insert(u); } vector&lt;tuple&lt;int, int, int&gt;&gt; ops; for(int i = 0; i &lt; q; i++) { int op, u, v; cin &gt;&gt; op &gt;&gt; u &gt;&gt; v; u--; v--; ops.emplace_back(op, u, v); if(op == 1) { graph[u].erase(v); graph[v].erase(u); } } UnionSet unionSet(graph, n); vector&lt;int&gt; ans; for(auto ite = ops.rbegin(); ite != ops.rend(); ite++) { auto [op, u, v] = *ite; if(op == 1) { unionSet.Union(u, v); } else if(op == 2) { ans.push_back(unionSet.Query(u, v)); } } for(auto ite = ans.rbegin(); ite != ans.rend(); ite++) { cout &lt;&lt; (*ite ? &quot;Yes\\n&quot; : &quot;No\\n&quot;); } return 0;} åå‘å¹¶æŸ¥é›†ï¼Œå€’ç€è®¡ç®—ç­”æ¡ˆ å…ˆæŠŠè¦åˆ é™¤çš„å…³ç³»å…¨éƒ¨åˆ é™¤ï¼Œç„¶åå€’åºå°†åˆ é™¤çš„å…³ç³»è¿˜åŸ 5 å°ç¾çš„åŒºé—´åˆ é™¤ 5. å°ç¾çš„åŒºé—´åˆ é™¤ å°ç¾æ‹¿åˆ°äº†ä¸€ä¸ªå¤§å°ä¸ºnnnçš„æ•°ç»„ï¼Œå¥¹å¸Œæœ›åˆ é™¤ä¸€ä¸ªåŒºé—´åï¼Œä½¿å¾—å‰©ä½™æ‰€æœ‰å…ƒç´ çš„ä¹˜ç§¯æœ«å°¾è‡³å°‘æœ‰kkkä¸ª 0ã€‚å°ç¾æƒ³çŸ¥é“ï¼Œä¸€å…±æœ‰å¤šå°‘ç§ä¸åŒçš„åˆ é™¤æ–¹æ¡ˆï¼Ÿ æ—¶é—´é™åˆ¶ï¼šC/C++ 1ç§’ï¼Œå…¶ä»–è¯­è¨€2ç§’ ç©ºé—´é™åˆ¶ï¼šC/C++ 256Mï¼Œå…¶ä»–è¯­è¨€512M è¾“å…¥æè¿°ï¼š ç¬¬ä¸€è¡Œè¾“å…¥ä¸¤ä¸ªæ­£æ•´æ•°ã€‚ç¬¬äºŒè¡Œè¾“å…¥ä¸ªæ­£æ•´æ•°ï¼Œä»£è¡¨å°ç¾æ‹¿åˆ°çš„æ•°ç»„ã€‚ è¾“å‡ºæè¿°ï¼š ä¸€ä¸ªæ•´æ•°ï¼Œä»£è¡¨åˆ é™¤çš„æ–¹æ¡ˆæ•°ã€‚ ç¤ºä¾‹1 è¾“å…¥ä¾‹å­ï¼š 5 2 2 5 3 4 20 è¾“å‡ºä¾‹å­ï¼š 4 ä¾‹å­è¯´æ˜ï¼š ç¬¬ä¸€ä¸ªæ–¹æ¡ˆï¼Œåˆ é™¤[3]ã€‚ç¬¬äºŒä¸ªæ–¹æ¡ˆï¼Œåˆ é™¤[4]ã€‚ç¬¬ä¸‰ä¸ªæ–¹æ¡ˆï¼Œåˆ é™¤[3,4]ã€‚ç¬¬å››ä¸ªæ–¹æ¡ˆï¼Œåˆ é™¤[2]ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;int cntOfFact(long long n, long long fact) { int cnt = 0; long long facts[32] = {0}; int base = 0; facts[0] = fact; while(facts[base] &lt; n) { base++; facts[base] = facts[base-1] * facts[base-1]; } for(; base &gt;= 0; base--) { if(n / facts[base] &gt; 0 &amp;&amp; n % facts[base] == 0) { cnt += 1 &lt;&lt; base; n /= facts[base]; } } return cnt;}int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; arr(n); vector&lt;int&gt; cntOf2(n+1), cntOf5(n+1); for(int i = 0; i &lt; n; i++) { cin &gt;&gt; arr[i]; cntOf2[i+1] = cntOfFact(arr[i], 2) + cntOf2[i]; cntOf5[i+1] = cntOfFact(arr[i], 5) + cntOf5[i]; } int canDelete2 = cntOf2[n] - k; int canDelete5 = cntOf5[n] - k; int start = 0; long long ans = 0; for(int end = 1; end &lt;= n; end++) { while(start &lt; end &amp;&amp; (cntOf2[end] - cntOf2[start] &gt; canDelete2 || cntOf5[end] - cntOf5[start] &gt; canDelete5)) { start++; } ans += end - start; } cout &lt;&lt; ans &lt;&lt; endl; return 0;}// 64 ä½è¾“å‡ºè¯·ç”¨ printf(&quot;%lld&quot;)","link":"/home/2024/09/03/%E7%89%9B%E5%AE%A2/%E7%89%9B%E5%AE%A2%E5%88%B7%E9%A2%98-2/"},{"title":"å®éªŒ-ä½¿ç”¨åŠ¨æ€ä¼˜å…ˆæƒçš„è¿›ç¨‹è°ƒåº¦ç®—æ³•æ¨¡æ‹Ÿ","text":"1ã€å®éªŒç›®çš„é€šè¿‡åŠ¨æ€ä¼˜å…ˆæƒç®—æ³•çš„æ¨¡æ‹ŸåŠ æ·±å¯¹è¿›ç¨‹æ¦‚å¿µè¿›ç¨‹è°ƒåº¦è¿‡ç¨‹çš„ç†è§£ã€‚ 2ã€å®éªŒå†…å®¹ ç”¨Cè¯­è¨€æ¥å®ç°å¯¹Nä¸ªè¿›ç¨‹é‡‡ç”¨åŠ¨æ€ä¼˜å…ˆæƒä¼˜å…ˆç®—æ³•çš„è¿›ç¨‹è°ƒåº¦ã€‚ æ¯ä¸ªç”¨æ¥æ ‡è¯†è¿›ç¨‹çš„è¿›ç¨‹æ§åˆ¶å—PCBç”¨ç»“æ„æ¥æè¿°ï¼ŒåŒ…æ‹¬ä»¥ä¸‹å­—æ®µï¼š è¿›ç¨‹æ ‡è¯†æ•° IDã€‚ è¿›ç¨‹ä¼˜å…ˆæ•° PRIORITYï¼Œå¹¶è§„å®šä¼˜å…ˆæ•°è¶Šå¤§çš„è¿›ç¨‹ï¼Œå…¶ä¼˜å…ˆæƒè¶Šé«˜ã€‚ è¿›ç¨‹å·²å ç”¨çš„CPUæ—¶é—´CPUTIMEã€‚ è¿›ç¨‹è¿˜éœ€å ç”¨çš„CPUæ—¶é—´ALLTIMEã€‚å½“è¿›ç¨‹è¿è¡Œå®Œæ¯•æ—¶ï¼ŒALLTIMEå˜ä¸º0ã€‚â€¢â€¢â€¢â€¢ è¿›ç¨‹çš„é˜»å¡æ—¶é—´STARTBLOCKï¼Œè¡¨ç¤ºå½“è¿›ç¨‹å†è¿è¡ŒSTARTBLOCKä¸ªæ—¶é—´ç‰‡åï¼Œå°†è¿›å…¥é˜»å¡çŠ¶æ€ã€‚ è¿›ç¨‹è¢«é˜»å¡çš„æ—¶é—´BLOCKTIMEï¼Œè¡¨ç¤ºå·²è¶³èµ›çš„è¿›ç¨‹å†ç­‰å¾…BLOCKTIMEä¸ªæ—¶é—´ç‰‡åï¼Œå°†è½¬æ¢æˆå°±ç»ªçŠ¶æ€ã€‚ è¿›ç¨‹çŠ¶æ€STARTã€‚ é˜Ÿåˆ—æŒ‡é’ˆNEXTï¼Œç”¨æ¥å°†PCBæ’æˆé˜Ÿåˆ—ã€‚ ä¼˜å…ˆæ•°æ”¹å˜çš„åŸåˆ™ï¼š è¿›ç¨‹åœ¨å°±ç»ªé˜Ÿåˆ—ä¸­å‘†ä¸€ä¸ªæ—¶é—´ç‰‡ï¼Œä¼˜å…ˆæ•°åŠ 1ã€‚ è¿›ç¨‹æ¯è¿è¡Œä¸€ä¸ªæ—¶é—´ç‰‡ï¼Œä¼˜å…ˆæ•°å‡3ã€‚ å‡è®¾åœ¨è°ƒåº¦å‰ï¼Œç³»ç»Ÿä¸­æœ‰5ä¸ªè¿›ç¨‹ï¼Œå®ƒä»¬çš„åˆå§‹çŠ¶æ€å¦‚ä¸‹ï¼š1234567ID 0 1 2 3 4PRIORITY 9 38 30 29 0CPUTIME 0 0 0 0 0ALLTIME 3 3 6 3 4STARTBLOCK 2 -1 -1 -1 -1BLOCKTIME 3 0 0 0 0STATE READY READY READY READY READY ä¸ºäº†æ¸…æ¥šçš„è§‚å¯Ÿå„è¿›ç¨‹çš„è°ƒåº¦è¿‡ç¨‹ï¼Œç¨‹åºåº”å°†æ¯ä¸ªæ—¶é—´ç‰‡å†…çš„æƒ…å†µæ˜¾ç¤ºå‡ºæ¥ï¼Œå‚ç…§çš„å…·ä½“æ ¼å¼å¦‚ä¸‹ï¼š1234567891011RUNNING PROGï¼šiREADY-QUEUEï¼š-ã€‰id1-ã€‰id2BLOCK-QUEUEï¼š-ã€‰id3-ã€‰id4= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = == = =ID 0 1 2 3 4PRIORITY P0 P1 P2 P3 P4CUPTIME C0 C1 C2 C3 C4ALLTIME A0 A1 A2 A3 A4STARTBLOCK T0 T1 T2 T3 T4BLOCKTIME B0 B1 B2 B3 B4STATE S0 S1 S2 S3 S4 å®éªŒä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include&lt;queue&gt;#include&lt;iostream&gt;#include&lt;iomanip&gt; using namespace std;typedef int ID;typedef int Priority;typedef int Time;enum State { sready, sblocked, sruning, sstop};struct PCB{ ID id; Priority priority; Time cpu_time; Time all_time; Time start_block; Time block_time; State state; public: PCB( ID id0, Priority priority0, Time cpu_time0, Time all_time0, Time start_block0, Time block_time0, State state0 ): id(id0), priority(priority0), cpu_time(cpu_time0), all_time(all_time0), start_block(start_block0), block_time(block_time0), state(state0) { }};struct cmp //ï¿½ï¿½Ğ´ï¿½Âºï¿½ï¿½ï¿½{ bool operator() (PCB* a, PCB* b) { return a-&gt;priority &lt; b-&gt;priority; //ï¿½ó¶¥¶ï¿½ }};typedef priority_queue&lt;PCB*, vector&lt;PCB*&gt;, cmp&gt; mqueue;const int width = 10;void show_PCB(PCB* pcb) { string state = &quot;&quot;; switch(pcb-&gt;state) { case sready: state = &quot;ready&quot;; break; case sblocked : state = &quot;blocked&quot;;break; case sruning : state = &quot;runing&quot;;break; case sstop: state = &quot;stop&quot;;break; defalut:state=&quot;unknown&quot;;break; } cout &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; pcb-&gt;id &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; pcb-&gt;priority &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; pcb-&gt;cpu_time &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; pcb-&gt;all_time &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; pcb-&gt;start_block &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; pcb-&gt;block_time &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; state &lt;&lt; &quot;|&quot; &lt;&lt; endl; }void show_queue(queue&lt;PCB*&gt; q){ cout &lt;&lt; left &lt;&lt; setw(7*width+7) &lt;&lt; setfill('-') &lt;&lt; &quot;&quot; &lt;&lt; &quot;\\n&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;id&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;priority&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;cpuTime&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;allTime&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;startBlock&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;blockTime&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;state&quot; &lt;&lt; &quot;|&quot; &lt;&lt; endl; while(!q.empty()) { PCB* t = q.front(); q.pop(); show_PCB(t); } cout &lt;&lt; left &lt;&lt; setw(7*width+7) &lt;&lt; setfill('-') &lt;&lt; &quot;&quot; &lt;&lt; &quot;\\n&quot;;}void show_queue(mqueue q){ cout &lt;&lt; left &lt;&lt; setw(7*width+7) &lt;&lt; setfill('-') &lt;&lt; &quot;&quot; &lt;&lt; &quot;\\n&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;id&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;priority&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;cpuTime&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;allTime&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;startBlock&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;blockTime&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;state&quot; &lt;&lt; &quot;|&quot; &lt;&lt; endl; while(!q.empty()) { PCB* t = q.top(); q.pop(); show_PCB(t); } cout &lt;&lt; left &lt;&lt; setw(7*width+7) &lt;&lt; setfill('-') &lt;&lt; &quot;&quot; &lt;&lt; &quot;\\n&quot;;}queue&lt;PCB*&gt; finished;void run_a_time(mqueue&amp; ready,mqueue&amp; blocked,PCB* runing) { mqueue t_ready, t_blocked; runing = ready.top(); ready.pop(); runing-&gt;priority -= 3; runing-&gt;cpu_time += 1; runing-&gt;all_time -= 1; runing-&gt;start_block -= 1; if(runing-&gt;start_block == 0) { t_blocked.push(runing); runing-&gt;state = sruning; } else { if(runing-&gt;all_time &gt; 0) { t_ready.push(runing); } else { finished.push(runing); runing-&gt;state = sstop; } } mqueue t_queue = blocked; while(!t_queue.empty()) { PCB* t = t_queue.top(); t_queue.pop(); t-&gt;block_time -= 1; if(t-&gt;block_time == 0) { t_ready.push(t); t-&gt;block_time = 0; t-&gt;start_block = -1; t-&gt;state = sready; } else { t_blocked.push(t); t-&gt;state = sblocked; } } t_queue = ready; while(!t_queue.empty()) { PCB* t = t_queue.top(); t_queue.pop(); t-&gt;priority += 1; t-&gt;start_block -= 1; if(t-&gt;start_block == 0) { t_blocked.push(t); t-&gt;state = sblocked; } else { t_ready.push(t); t-&gt;state = sready; } } ready = t_ready; blocked = t_blocked; }int main() { mqueue ready, blocked; PCB* runing = nullptr; PCB* pcbs[] = { new PCB(0,9,0,3,2,3, sready), new PCB(1,38,0,3,-1,0, sready), new PCB(2,30,0,6,-1,0, sready), new PCB(3,29,0,3,-1,0, sready), new PCB(4,0,0,4,-1,0, sready) }; int pcb_num = sizeof(pcbs)/sizeof(PCB*); for(int i = 0; i &lt; pcb_num; i++) { ready.push(pcbs[i]); } show_queue(ready); int clock_ = 1; while(!ready.empty() || !blocked.empty()) { cout &lt;&lt; &quot;clock = &quot; &lt;&lt; clock_ &lt;&lt; endl; run_a_time(ready, blocked, runing); cout &lt;&lt; &quot;ready queue:&quot; &lt;&lt; endl; show_queue(ready); cout &lt;&lt; &quot;blocked queue:&quot; &lt;&lt; endl; show_queue(blocked); //system(&quot;pause&quot;); clock_++; } show_queue(finished); //delete for(int i = 0; i &lt; pcb_num; i++) { delete pcbs[i]; }}","link":"/home/2020/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C-%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E4%BC%98%E5%85%88%E6%9D%83%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/"},{"title":"å®éªŒ-ç®€å•æ–‡ä»¶ç³»ç»Ÿçš„å®ç°","text":"1ã€å®éªŒç›®çš„é€šè¿‡å…·ä½“çš„æ–‡ä»¶å­˜å‚¨ç©ºé—´çš„ç®¡ç†ã€æ–‡ä»¶çš„ç‰©ç†ç»“æ„ã€ç›®å½•ç»“æ„å’Œæ–‡ä»¶æ“ä½œçš„å®ç°ï¼ŒåŠ æ·±å¯¹æ–‡ä»¶ç³»ç»Ÿå†…éƒ¨åŠŸèƒ½å’Œå®ç°è¿‡ç¨‹çš„ç†è§£ã€‚ 2ã€å®éªŒå†…å®¹ åœ¨å†…å­˜ä¸­å¼€è¾Ÿä¸€ä¸ªè™šæ‹Ÿç£ç›˜ç©ºé—´ä½œä¸ºæ–‡ä»¶å­˜å‚¨å™¨ï¼Œåœ¨ä¸Šé¢å®ç°ä¸€ä¸ªç®€å•å•ç”¨æˆ·æ–‡ä»¶ç³»ç»Ÿã€‚é€€å‡ºæ—¶åº”è¯¥å°†è¯¥è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿä¿å­˜åˆ°ç£ç›˜ä¸Šï¼Œä»¥ä¾¿ä¸‹æ¬¡å¯ä»¥å†å°†å®ƒæ¢å¤åˆ°å†…å­˜å¯¹è™šæ‹Ÿç£ç›˜ç©ºé—´ä¸­ã€‚ æ–‡ä»¶å­˜å‚¨ç©ºé—´å¯¹åˆ†é…å¯ä»¥é‡‡ç”¨æ˜¾å¼é“¾æ¥åˆ†é…æˆ–è€…å…¶ä»–çš„åŠæ³•ã€‚ ç©ºé—²ç©ºé—´çš„ç®¡ç†å¯ä»¥é€‰æ‹©ä½ç¤ºå›¾æˆ–è€…å…¶ä»–çš„åŠæ³•ã€‚å¦‚æœé‡‡ç”¨ä½ç¤ºå›¾æ¥ç®¡ç†æ–‡ä»¶å­˜å‚¨ç©ºé—´ï¼Œå¹¶é‡‡ç”¨æ˜¾å¼é“¾æ¥åˆ†é…æ–¹å¼ï¼Œé‚£ä¹ˆå¯ä»¥å°†ä½ç¤ºå›¾åˆå¹¶åˆ°FATä¸­ã€‚ æ–‡ä»¶ç›®å½•ç»“æ„é‡‡ç”¨å¤šçº§ç›®å½•ç»“æ„ã€‚ä¸ºäº†ç®€å•èµ·è§ï¼Œå¯ä»¥ä¸ä½¿ç”¨ç´¢å¼•ç»“ç‚¹ï¼Œå…¶ä¸­çš„æ¯ä¸ªç›®å½•é¡¹åº”åŒ…å«æ–‡ä»¶åã€ç‰©ç†åœ°å€ã€é•¿åº¦ç­‰ä¿¡æ¯ï¼Œè¿˜å¯ä»¥é€šè¿‡ç›®å½•é¡¹å®ç°å¯¹æ–‡ä»¶å¯¹è¯»å’Œå†™çš„ä¿æŠ¤ã€‚ è¦æ±‚æä¾›ä»¥ä¸‹æœ‰å…³çš„æ“ä½œï¼š1234567891011âˆšformatï¼šå¯¹æ–‡ä»¶å­˜å‚¨å™¨è¿›è¡Œæ ¼å¼åŒ–ï¼Œå³æŒ‰ç…§æ–‡ä»¶ç³»ç»Ÿå¯¹ç»“æ„å¯¹è™šæ‹Ÿç£ç›˜ç©ºé—´è¿›è¡Œå¸ƒå±€ï¼Œå¹¶åœ¨å…¶ä¸Šåˆ›å»ºæ ¹ç›®å½•ä»¥åŠç”¨äºç®¡ç†æ–‡ä»¶å­˜å‚¨ç©ºé—´ç­‰çš„æ•°æ®ç»“æ„ã€‚âˆšmkdirï¼šç”¨äºåˆ›å»ºå­ç›®å½•ï¼›âˆšrmdirï¼šç”¨äºåˆ é™¤ç›®å½•ï¼›âˆšlsï¼šç”¨äºæ˜¾ç¤ºç›®å½•ï¼›âˆšcdï¼šç”¨äºæ›´æ”¹å½“å‰ç›®å½•ï¼›âˆšcreateï¼šç”¨äºåˆ›å»ºæ–‡ä»¶ï¼›âˆšopenï¼šç”¨äºæ‰“å¼€æ–‡ä»¶ï¼›âˆšcloseï¼šç”¨äºå…³é—­æ–‡ä»¶ï¼›âˆšwriteï¼šç”¨äºå†™æ–‡ä»¶ï¼›âˆšreadï¼šç”¨äºè¯»æ–‡ä»¶âˆšrmï¼šç”¨äºåˆ é™¤æ–‡ä»¶ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iomanip&gt;#include &lt;fstream&gt;using std::string;using std::vector;using std::cout;using std::endl;using std::cin;using std::ifstream;using std::ofstream;using std::ios;class FCB{public: int first_block; string fileName; int size; int real_size; FCB(int first_block0,const string &amp;fileName0, int size0, int real_size0): first_block(first_block0), fileName(fileName0), size(size0), real_size(real_size0*4) { }}; //æ–‡ä»¶æ§åˆ¶å—class DirItem { //æ–‡ä»¶æ ‘ string name; vector&lt;FCB*&gt; files; //ç›®å½•ä¸‹çš„æ–‡ä»¶ vector&lt;DirItem*&gt; dirs; //ç›®å½•ä¸‹çš„æ–‡ä»¶å¤¹ï¼Œæ ‘èŠ‚ç‚¹public: DirItem(const string&amp; name0):name(name0) {} void addFile(int first_block, const string&amp; fileName,int size, int real_size) { for (auto i = files.begin(); i != files.end(); i++) { if ((*i)-&gt;fileName == fileName) { cout &lt;&lt; &quot;same file name&quot; &lt;&lt; endl; return; } } files.push_back(new FCB(first_block, fileName, size, real_size)); } void addDir(DirItem* dir) { dirs.push_back(dir); } vector&lt;DirItem*&gt; getDirs() { return dirs; } vector&lt;FCB*&gt; getFiles() { return files; } string getName() { return name; } void del_file(const string&amp; fileName) { for (auto i = files.begin(); i != files.end(); i++) { if ((*i)-&gt;fileName == fileName) { files.erase(i); break; } } } void del_dir(const string&amp; fileName) { for (auto i = dirs.begin(); i != dirs.end(); i++) { if ((*i)-&gt;getName() == fileName) { dirs.erase(i); break; } } } void clear() { for (DirItem* item : dirs) { delete item; } for (FCB* item : files) { delete item; } dirs.clear(); files.clear(); } //é€’å½’åˆ é™¤æ—¶ç”¨åˆ°ï¼Œåˆ é™¤å½“å‰ç›®å½•ä¸‹çš„ç›®å½•å’Œæ–‡ä»¶çš„æŒ‡é’ˆ};class diskMgr { //ç£ç›˜ vector&lt;int&gt; blocks; //fatè¡¨ int n = 16; int block_num = n*n; int block_size = 4; //æ¯å—4B int disk_capacity = block_num * block_size; //1M vector&lt;vector&lt;int&gt;&gt; bit_map; //0ç©ºï¼Œ1æœ‰ï¼Œä½è§†å›¾public: vector&lt;char&gt; disk; diskMgr() { disk = vector&lt;char&gt;(disk_capacity, '\\0'); blocks = vector&lt;int&gt;(block_num, -1); bit_map = vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(n, 0)); } int getSize(int blockNum) { int n = 0; while (blockNum != -1) { n++; blockNum = blocks[blockNum]; } return n; } //å½“å‰å—å·å¼€å§‹çš„æ–‡ä»¶ä¸€ä¸ªæœ‰å¤šå°‘å—å„¿ int find_empty_block() { for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (bit_map[i][j] == 0) { return n*i+j; } } } return -1; }//æ‰¾åˆ°ä¸€ä¸ªç©ºé—²ç›˜å—ï¼Œä»ä½è§†å›¾ void update_bit_map(int x, int notempty) { int i = x / n,j = x % n; bit_map[i][j] = notempty; }//æ›´æ–°ä½è§†å›¾ void del(int blockNum) { while (blockNum != -1) { for(int i = 0; i &lt; block_size; i++) { disk[blockNum * block_size + i] = '\\0'; } update_bit_map(blockNum, 0); int t = blocks[blockNum]; blocks[blockNum] = -1; blockNum = t; } } //åˆ é™¤æ–‡ä»¶ vector&lt;char&gt; read(int blockNum) { vector&lt;char&gt; data; while (blockNum != -1) { for(int i = 0; i &lt; block_size; i++) { data.push_back(disk[blockNum * block_size + i]); } blockNum = blocks[blockNum]; } return data; } //è¯»å–æ–‡ä»¶ int write(vector&lt;char&gt; data) { int first_block = find_empty_block(); //æ‰¾åˆ°åˆå§‹ä½ç½® if (first_block == -1) return -1; int len = int(data.size()); int blockn = len%block_size == 0 ? len/block_size : len/block_size+1; //ä¸€å…±éœ€è¦çš„ç›˜å—å„¿æ•° int next_block = first_block; int temp = next_block; int fix = (block_size - len % block_size) % block_size; for (int i = 0; i &lt; fix; ++i) { //æ•°æ®é•¿åº¦å¯¹é½ data.push_back('*'); } for (int i = 0; i &lt; blockn; i++) { //å­˜æ•°æ® if (temp == -1) { break; } next_block = temp; for (int j = 0; j &lt; block_size; j++) { disk[next_block*block_size+j] = data[i*block_size+j]; } update_bit_map(next_block, 1); temp = find_empty_block(); blocks[next_block] = temp; } blocks[next_block] = -1; return first_block; }};#define chart_head std::left &lt;&lt; std::setw(len+1) &lt;&lt; std::setfill('-') &lt;&lt; &quot;&quot;#define chart_cell &quot;|&quot; &lt;&lt; std::left &lt;&lt; std::setw(len) &lt;&lt; std::setfill(' ')class fileMgr { DirItem * root; //æ ¹èŠ‚ç‚¹ diskMgr dm;//ç£ç›˜ç®¡ç†å™¨ DirItem * cur; //å½“å‰å‘½ä»¤è¡Œæ‰§çš„å·¥ä½œç›®å½• string cur_path; //å·¥ä½œå‘½ä»¤ DirItem* addmdir(DirItem * node, string name) { DirItem* newNode = new DirItem(name); node-&gt;addDir(newNode); return newNode; }public: fileMgr() { root = new DirItem(&quot;/&quot;); DirItem * temp = addmdir(addmdir(root, &quot;apps&quot;), &quot;tencent&quot;); addmdir(temp, &quot;qq&quot;); addmdir(temp, &quot;qqgame&quot;); addmdir(temp, &quot;qqmusic&quot;); temp = addmdir(root, &quot;docs&quot;); addmdir(temp, &quot;words&quot;); addmdir(temp, &quot;ppts&quot;); addmdir(temp, &quot;excels&quot;); root-&gt;addDir(new DirItem(&quot;pics&quot;)); root-&gt;addDir(new DirItem(&quot;musics&quot;)); cur = root; cur_path = &quot;/&quot;; cout_hint(); } //åˆå§‹åŒ–ä¸€äº›æ–‡ä»¶å¤¹ void ls() { int len = 20; cout &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; endl &lt;&lt; chart_cell &lt;&lt; &quot;file/dir name&quot; &lt;&lt; chart_cell &lt;&lt; &quot;type&quot; &lt;&lt; chart_cell &lt;&lt; &quot;size&quot; &lt;&lt; chart_cell &lt;&lt; &quot;real size&quot; &lt;&lt; &quot;|&quot; &lt;&lt; std::endl &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; endl; vector&lt;DirItem*&gt; dirs = cur-&gt;getDirs(); for (auto i = dirs.begin(); i != dirs.end(); i++) { cout &lt;&lt; chart_cell &lt;&lt; (*i)-&gt;getName() &lt;&lt; chart_cell &lt;&lt; &quot;directory&quot; &lt;&lt; chart_cell &lt;&lt; &quot;--&quot; &lt;&lt; chart_cell &lt;&lt; &quot;--&quot; &lt;&lt; &quot;|&quot; &lt;&lt; std::endl; } vector&lt;FCB*&gt; files = cur-&gt;getFiles(); for (auto i = files.begin(); i != files.end(); i++) { cout &lt;&lt; chart_cell &lt;&lt; (*i)-&gt;fileName &lt;&lt; chart_cell &lt;&lt; &quot;file&quot; &lt;&lt; chart_cell &lt;&lt; (*i)-&gt;size &lt;&lt; chart_cell &lt;&lt; (*i)-&gt;real_size &lt;&lt; &quot;|&quot; &lt;&lt; std::endl; } cout &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; endl; cout_hint(); } void cout_hint() { cout &lt;&lt; &quot;\\n&quot; &lt;&lt; cur_path &lt;&lt; &quot;&gt; &quot;; } //è¾“å‡ºå‘½ä»¤è¡Œæç¤ºç¬¦ void cd(string name) { if (name == &quot;..&quot;) { if(cur_path == &quot;/&quot;) { cout_hint(); } else { if (*cur_path.rbegin() == '/') { cur_path.pop_back(); } cur_path = cur_path.substr(0, cur_path.rfind('/')); if (cur_path.length() == 0) { cur_path = &quot;/&quot;; } cur = find_dir_node(cur_path); cout_hint(); return; } } DirItem* node = cur; for(DirItem* item : node-&gt;getDirs()){ if (item-&gt;getName() == name) { cur = item; cur_path += name+&quot;/&quot;; cout_hint(); return; } } cout &lt;&lt; &quot;no such dir&quot;; cout_hint(); } void cdn(string path) { cur = find_dir_node(path); if (*path.rbegin() != '/') { path.push_back('/'); } if (*path.begin() != '/') { path = &quot;/&quot; + path; } cur_path = path; cout_hint(); } DirItem* find_dir_node(string path) { if (path[0] == '/') { path = path.substr(1, path.length()-1); } if (*path.rbegin() != '/') { path.push_back('/'); } int r = 0; DirItem* node = root; if (path == &quot;/&quot;) return node; while (r != -1) { r = path.find('/'); if (r != -1) { string dir = path.substr(0, r); bool find = false; for(DirItem* item : node-&gt;getDirs()){ if (item-&gt;getName() == dir) { node = item; find = true; break; } } if (!find) { return nullptr; } path = path.substr(r+1, path.length() - r - 1); } else { break; } } return node; } void create_file(const string&amp; fileName, const vector&lt;char&gt;&amp; data) { DirItem *node = cur; if (node != nullptr) { int fb = dm.write(data); if(fb == -1) { cout &lt;&lt; &quot;no enough disk storage&quot;; cout_hint(); } int size = dm.getSize(fb); node-&gt;addFile(fb, fileName, data.size(), size); } cout_hint(); } void create_file(string path, const string&amp; fileName, const vector&lt;char&gt;&amp; data) { DirItem *node = find_dir_node(path); if (node != nullptr) { int fb = dm.write(data); int size = dm.getSize(fb); node-&gt;addFile(fb, fileName, data.size(), size); } } void create_dir(const string&amp; dirName) { if (cur != nullptr) { cur-&gt;addDir(new DirItem(dirName)); } cout_hint(); } void create_dir(string path, const string&amp; dirName) { DirItem * node = find_dir_node(path); if (node != nullptr) { node-&gt;addDir(new DirItem(dirName)); } } void del_dir(DirItem* node) { if (node != nullptr) { for(FCB* fcb : node-&gt;getFiles()) { dm.del(fcb-&gt;first_block); node-&gt;del_file(fcb-&gt;fileName); } for(auto i : node-&gt;getDirs()) { del_dir(i); } node-&gt;clear(); } } void del_dir(const string&amp; fileName) { if (cur != nullptr) { for (auto i : cur-&gt;getDirs()) { if(i-&gt;getName() == fileName) { del_dir(i); cur-&gt;del_dir(i-&gt;getName()); cout_hint(); return; } } } cout &lt;&lt; &quot;no such directory&quot;; cout_hint(); } void del_file(const string&amp; fileName) { DirItem*node = cur; if (node != nullptr) { for(FCB* fcb : node-&gt;getFiles()) { if (fcb-&gt;fileName == fileName) { dm.del(fcb-&gt;first_block); node-&gt;del_file(fileName); cout_hint(); return; } } } } void del_file(string path, const string&amp; fileName) { DirItem*node = find_dir_node(path); if (node != nullptr) { for(FCB* fcb : node-&gt;getFiles()) { if (fcb-&gt;fileName == fileName) { dm.del(fcb-&gt;first_block); node-&gt;del_file(fileName); return; } } } } void show(const vector&lt;char&gt;&amp; v) { for (char i : v) { cout &lt;&lt; i; } } void read(const string&amp; fileName) { if (cur != nullptr) { for(FCB* fcb : cur-&gt;getFiles()) { if (fcb-&gt;fileName == fileName) { vector&lt;char&gt; data = dm.read(fcb-&gt;first_block); show(data); cout_hint(); return; } } } cout &lt;&lt; &quot;file not found&quot;; cout_hint(); } vector&lt;char&gt; read(string path, const string&amp; fileName) { DirItem*node = find_dir_node(path); if (node != nullptr) { for(FCB* fcb : node-&gt;getFiles()) { if (fcb-&gt;fileName == fileName) { return dm.read(fcb-&gt;first_block); } } } return {}; }};int main() { fileMgr fm; /*ifstream Myfile2; Myfile2.open(&quot;file_sys.disk&quot;,ios::binary); //äºŒè¿›åˆ¶æ‰“å¼€ï¼Œç¼ºçœä¸ºæ–‡æœ¬ï¼Œios::out,ios::in,æ–‡æœ¬è¾“å…¥è¾“å‡ºç”¨&lt;&lt;,&gt;&gt; Myfile2.read((char *)&amp;fm,sizeof(fileMgr)); Myfile2.close();*/ string ins, para; while(cin &gt;&gt; ins) { if(ins == &quot;ls&quot;) { fm.ls(); } else if(ins == &quot;cd&quot;) { cin &gt;&gt; para; fm.cd(para); } else if (ins == &quot;read&quot;) { cin &gt;&gt; para; fm.read(para); } else if (ins == &quot;mkdir&quot;) { cin &gt;&gt; para; fm.create_dir(para); } else if (ins == &quot;rmdir&quot;) { cin &gt;&gt; para; fm.del_dir(para); } else if (ins == &quot;mkfile&quot;) { cin &gt;&gt; para; string c = &quot;&quot;; cout &lt;&lt; &quot;contents:\\n&quot;; string data; while(c != &quot;#&quot;) { data += c; std::getline(cin, c); data += '\\n'; } int k = 0; while (data[k] == '\\n') k++; data = data.substr(k, data.length()-k); vector&lt;char&gt; vdata; for(char i : data) { vdata.push_back(i); } fm.create_file(para, vdata); } else if (ins == &quot;rmfile&quot;) { cin &gt;&gt; para; fm.del_file(para); } else if (ins == &quot;exit&quot; || ins == &quot;quit&quot;) { break; } else if (ins == &quot;cdn&quot;) { cin &gt;&gt; para; fm.cdn(para); } else { string c; std::getline(cin, c); ins += &quot; &quot; + c; system(ins.c_str()); cout &lt;&lt; &quot;unknown cmd:&quot; &lt;&lt; ins &lt;&lt; endl; fm.cout_hint(); } } /*ofstream file; file.open(&quot;file_sys.disk&quot;,ios::binary); //ç¼“å­˜çš„ç±»å‹æ˜¯ unsigned char *ï¼Œéœ€è¦ç±»å‹è½¬æ¢ file.write((char *)&amp;fm,sizeof(fileMgr)); //winServerä¸ºç±»å¯¹è±¡ file.close();*/ return 0;}","link":"/home/2020/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C-%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"title":"å®éªŒ-ä½¿ç”¨åŠ¨æ€åˆ†åŒºåˆ†é…æ–¹å¼çš„æ¨¡æ‹Ÿ","text":"1ã€å®éªŒç›®çš„äº†è§£åŠ¨æ€åˆ†åŒºåˆ†é…æ–¹å¼ä¸­ä½¿ç”¨çš„æ•°æ®ç»“æ„å’Œåˆ†é…ç®—æ³•ï¼Œå¹¶è¿›ä¸€æ­¥åŠ æ·±å¯¹åŠ¨æ€åˆ†åŒºå­˜å‚¨ç®¡ç†æ–¹å¼åŠå…¶å®ç°è¿‡ç¨‹çš„ç†è§£ã€‚ 2ã€å®éªŒå†…å®¹ ç”¨Cè¯­è¨€åˆ†åˆ«å®ç°é‡‡ç”¨é¦–æ¬¡é€‚åº”ç®—æ³•å’Œæœ€ä½³é€‚åº”ç®—æ³•çš„åŠ¨æ€åˆ†åŒºåˆ†é…è¿‡ç¨‹alloc( )å’Œå›æ”¶è¿‡ç¨‹free( )ã€‚å…¶ä¸­ï¼Œç©ºé—²åˆ†åŒºé€šè¿‡ç©ºé—²åˆ†åŒºé“¾æ¥ç®¡ç†ï¼šåœ¨è¿›è¡Œå†…å­˜åˆ†é…æ—¶ï¼Œç³»ç»Ÿä¼˜å…ˆä½¿ç”¨ç©ºé—²åŒºä½ç«¯çš„ç©ºé—´ã€‚ å‡è®¾åˆå§‹çŠ¶æ€ä¸‹ï¼Œå¯ç”¨çš„å†…å­˜ç©ºé—´ä¸º640KBï¼Œå¹¶æœ‰ä¸‹åˆ—çš„è¯·æ±‚åºåˆ—ï¼šä½œä¸š1ç”³è¯·130KBã€‚ä½œä¸š2ç”³è¯·60KBã€‚ä½œä¸š3ç”³è¯·100KBã€‚ä½œä¸š2é‡Šæ”¾60KBã€‚ä½œä¸š4ç”³è¯·200KBã€‚ä½œä¸š3é‡Šæ”¾100KBã€‚ä½œä¸š1é‡Šæ”¾130KBã€‚ä½œä¸š5ç”³è¯·140KBã€‚ä½œä¸š6ç”³è¯·60KBã€‚ä½œä¸š7ç”³è¯·50KBã€‚ä½œä¸š6é‡Šæ”¾60KBã€‚ è¯·åˆ†åˆ«é‡‡ç”¨é¦–æ¬¡é€‚åº”ç®—æ³•å’Œæœ€ä½³é€‚åº”ç®—æ³•ï¼Œå¯¹å†…å­˜å—è¿›è¡Œåˆ†é…å’Œå›æ”¶ï¼Œè¦æ±‚æ¯æ¬¡åˆ†é…å’Œå›æ”¶åæ˜¾ç¤ºå‡ºç©ºé—²åˆ†åŒºé“¾çš„æƒ…å†µã€‚ å®éªŒä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;iomanip&gt;using namespace std;enum Unit { KB, MB};typedef int Addr;Addr getAddr(int num, Unit unit) { return (unit == KB) ? (num) : (unit == MB) ? (num*1024) : 0;}struct mem_block { Addr start; Addr len; int task_id; mem_block(Addr start0, Addr len0, int task_id0):start(start0), len(len0), task_id(task_id0) {}};struct FF_cmp { bool operator() (mem_block a, mem_block b) { return a.start &gt; b.start; //å°é¡¶å † }};struct BF_cmp { bool operator() (mem_block a, mem_block b) { return a.len &gt; b.len; //å°é¡¶å † }};typedef priority_queue&lt;mem_block, vector&lt;mem_block&gt;, FF_cmp&gt; FF_Queue;typedef priority_queue&lt;mem_block, vector&lt;mem_block&gt;, BF_cmp&gt; BF_Queue;FF_Queue ffq;BF_Queue bfq;set&lt;int&gt; tasks;void init() { ffq.push(mem_block(0,getAddr(640, KB), 0)); bfq.push(mem_block(0,getAddr(640, KB), 0));}template&lt;class T&gt;void merge_mem(T&amp; q) { FF_Queue tq; while (!q.empty()) { tq.push(q.top()); q.pop(); } vector&lt;mem_block&gt; vt; while (!tq.empty()) { mem_block t = tq.top(); tq.pop(); while (!tq.empty() &amp;&amp; tq.top().task_id == t.task_id) { t.len += tq.top().len; tq.pop(); } vt.push_back(t); } for(auto item : vt) { q.push(item); }}template&lt;class T&gt;void alloc_mem(T&amp; q, int task_id, Addr num) { if (num &lt;= 0) { return; } vector&lt;mem_block&gt; vt; while (!q.empty()) { mem_block t = q.top(); q.pop(); if (t.len &gt;= num &amp;&amp; t.task_id == 0) { q.push(mem_block(t.start, num, task_id)); if (t.len &gt; num) { q.push(mem_block(t.start +num, t.len - num, 0)); } for(auto item : vt) { q.push(item); } merge_mem&lt;T&gt;(q); return; } else { vt.push_back(t); } } cout &lt;&lt; &quot;error no enough mem alloc&quot; &lt;&lt; endl; for(auto item : vt) { q.push(item); }}template&lt;class T&gt;void free_mem(T&amp; q, int task_id, Addr num) { if (num &lt;= 0) { return; } vector&lt;mem_block&gt; vt; while (!q.empty()) { mem_block t = q.top(); q.pop(); if (t.task_id == task_id) { if(t.len &gt;= num) { q.push(mem_block(t.start, num, 0)); if (t.len &gt; num) { q.push(mem_block(t.start + num, t.len - num, task_id)); } } else { num -= t.len; continue; } for(auto item : vt) { q.push(item); } merge_mem&lt;T&gt;(q); return; } else { vt.push_back(t); } } cout &lt;&lt; &quot;error no enough mem free&quot; &lt;&lt; endl; for(auto item : vt) { q.push(item); }}const int char_len = 8;#define chart_item &lt;&lt; &quot;|&quot; &lt;&lt; setw(char_len) &lt;&lt; left &lt;&lt; setfill(' ')#define chart_head &lt;&lt; setw((char_len+1)*3+1) &lt;&lt; left &lt;&lt; setfill('-')string itoa(int n) { string s; while (n) { s = char(n%10+'0') + s; n /= 10; } return s;}template&lt;class T&gt;void show(T q) { T tq; while (!q.empty()) { tq.push(q.top()); q.pop(); } cout chart_head&lt;&lt;&quot;&quot;&lt;&lt;endl chart_item &lt;&lt; &quot;start&quot; &lt;&lt; &quot;&quot; chart_item &lt;&lt; &quot;len&quot; &lt;&lt; &quot;&quot; chart_item &lt;&lt; &quot;task_id&quot; &lt;&lt; &quot;|&quot;&lt;&lt; endl chart_head&lt;&lt;&quot;&quot;&lt;&lt;endl; while (!tq.empty()) { mem_block mb = tq.top(); cout chart_item&lt;&lt; mb.start &lt;&lt; &quot;&quot; chart_item&lt;&lt; mb.len &lt;&lt; &quot;&quot; chart_item&lt;&lt; ((mb.task_id == 0) ? &quot;spare&quot; : itoa(mb.task_id)) &lt;&lt; &quot;|&quot;&lt;&lt; endl; tq.pop(); } cout chart_head&lt;&lt;&quot;&quot;&lt;&lt;endl;}int main(int argc, const char * argv[]) { init(); const int free = 0, alloc = 1; vector&lt;vector&lt;int&gt;&gt; reqs = { {1,130,alloc}, {2,60, alloc}, {3,100, alloc}, {2,60,free}, {4, 200, alloc}, {3, 100, free}, {1, 130, free}, {5, 140, alloc}, {6, 60, alloc}, {7,50, alloc}, {6, 60, free} }; for(auto req : reqs) { if (req[2] == alloc) { alloc_mem&lt;FF_Queue&gt;(ffq,req[0], req[1]); alloc_mem&lt;BF_Queue&gt;(bfq,req[0], req[1]); } else if (req[2] == free) { free_mem&lt;FF_Queue&gt;(ffq,req[0], req[1]); free_mem&lt;BF_Queue&gt;(bfq,req[0], req[1]); } else { } cout &lt;&lt; &quot;FF&quot; &lt;&lt; endl; show&lt;FF_Queue&gt;(ffq); cout &lt;&lt; &quot;BF&quot; &lt;&lt; endl; show&lt;BF_Queue&gt;(bfq); } return 0;}","link":"/home/2020/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C-%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E6%A8%A1%E6%8B%9F/"},{"title":"OI KIWI 01-å€å¢","text":"OI KIWI å€å¢ æ€æƒ³ å›¾ç‰‡æ¥æº æŸ¥æ‰¾å°äºlimitçš„æœ€å¤§æ•°å­—1234567891011121314int maxValueInVecSmallerThenLimit(vector&lt;int&gt;&amp; vec, int limit) { int n = vec.size(); int l = 0; int p = 1; while(p) { if(l + p &lt; n &amp;&amp; vec[l + p] &lt; limit) { l += p; p &lt;&lt;= 1; } else { p &gt;&gt;= 1; } } return vec[l];} å’ŒäºŒåˆ†ä¸€æ ·ï¼Œéœ€è¦åœ¨æœ‰åºæ•°ç»„ä¸ŠæŸ¥æ‰¾ å¯¹äºæŸ¥æ‰¾åŒºé—´[l, l + p) å¦‚æœvec[l+p] &gt;= limitï¼Œ åˆ™æœ€å¤§å€¼å°±åœ¨[l, l + p)åŒºé—´ä¸Š,ä¸‹ä¸€æ­¥æŸ¥è¯¢[l, l + p / 2) å¦‚æœvec[l+p] &lt; limitï¼Œ åˆ™æœ€å¤§å€¼ä¸åœ¨[l, l + p)åŒºé—´ä¸Š,ä¸‹ä¸€æ­¥æŸ¥è¯¢[l + p, l + 3*p) å¦‚æœl+p &gt;= n, åˆ™ç¼©å°æŸ¥æ‰¾èŒƒå›´ æˆ‘ä»¬æŠŠä¸Šé¢çš„é€»è¾‘è¿­ä»£ä¸¤æ¬¡ å¦‚æœvec[l+p] &gt;= limitï¼Œ åˆ™æœ€å¤§å€¼å°±åœ¨[l, l + p)åŒºé—´ä¸Š,ä¸‹ä¸€æ­¥æŸ¥è¯¢[l, l + p / 2) å¦‚æœvec[l+p/2] &gt;= limitï¼Œ åˆ™æœ€å¤§å€¼å°±åœ¨[l, l + p/2)åŒºé—´ä¸Š,ä¸‹ä¸€æ­¥æŸ¥è¯¢[l, l + p / 4) å¦‚æœvec[l+p/2] &lt; limitï¼Œ åˆ™æœ€å¤§å€¼ä¸åœ¨[l, l + p/2)åŒºé—´ä¸Š,ä¸‹ä¸€æ­¥æŸ¥è¯¢[l + p/2, l + p/2 + p) å¦‚æœvec[l+p] &lt; limitï¼Œ åˆ™æœ€å¤§å€¼ä¸åœ¨[l, l + p)åŒºé—´ä¸Š,ä¸‹ä¸€æ­¥æŸ¥è¯¢[l + p, l + 3*p) å¦‚æœvec[l+3*p] &gt;= limitï¼Œ åˆ™æœ€å¤§å€¼å°±åœ¨[l + p, l + 3*p)åŒºé—´ä¸Š,ä¸‹ä¸€æ­¥æŸ¥è¯¢[l + p, l + 2*p) å¦‚æœvec[l+3*p] &lt; limitï¼Œ åˆ™æœ€å¤§å€¼ä¸åœ¨[l + p, l + 3*p)åŒºé—´ä¸Š,ä¸‹ä¸€æ­¥æŸ¥è¯¢[l + 3 * p, l + 7 * p) RMQåŒºé—´æœ€å€¼Range Maximum/Minimum Query å•è°ƒæ ˆç”¨å•è°ƒæ ˆæ‰¾åˆ°ä¸¤ä¸ªæ•°ç»„leftå’Œright left[i]ä»£è¡¨arr[i]åœ¨[left[i], i]çš„åŒºé—´ä¸Šæ˜¯æœ€å°å€¼ right[i]ä»£è¡¨arr[i]åœ¨[i, right[i]]çš„åŒºé—´ä¸Šæ˜¯æœ€å°å€¼ å¯¹äºä¸€ä¸ªæŸ¥è¯¢[l, r] å¦‚æœleft[r] &lt;= l, arr[r]æ˜¯åŒºé—´æœ€å°å€¼ å¦‚æœright[l] &gt;= r, arr[l]æ˜¯åŒºé—´æœ€å°å€¼ å¦åˆ™l = right[l] + 1, r = left[r] - 1ï¼Œç¼©å°æŸ¥æ‰¾èŒƒå›´ 12345678910111213141516171819202122232425262728293031323334353637vector&lt;int&gt; RangeMinimumQuery(vector&lt;int&gt;&amp; arr, vector&lt;vector&lt;int&gt;&gt;&amp; queries) { stack&lt;int&gt; monoStack; int len = arr.size(); int res = 0; vector&lt;int&gt; left(len), right(len, len - 1); for(int i = 0; i &lt; len; i++) { left[i] = right[i] = i; int top = -1; while(!monoStack.empty() &amp;&amp; arr[monoStack.top()] &gt;= arr[i]) { top = monoStack.top(); monoStack.pop(); } if(top != -1) left[i] = left[top]; monoStack.push(i); } monoStack = stack&lt;int&gt;(); for(int i = len - 1; i &gt;= 0; i--) { int top = -1; while(!monoStack.empty() &amp;&amp; arr[monoStack.top()] &gt; arr[i]) { top = monoStack.top(); monoStack.pop(); } if(top != -1) right[i] = right[top]; monoStack.push(i); } vector&lt;int&gt; ans; for(const auto&amp; query : queries) { int l = query[0], r = query[1]; while(right[l] &lt; r &amp;&amp; left[r] &gt; l) { // æœ‰å¯èƒ½å¾ªç¯n/2æ¬¡ï¼Œé€€åŒ–æˆO(n), å¦‚5,4,3,2,1,2,3,4,5 l = min(len - 1, right[l] + 1); r = max(0, left[r] - 1); } ans.push_back(min(arr[l], arr[r])); } return ans;} STè¡¨å‚è€ƒè¿™é‡Œï¼šhttps://oi-wiki.org/ds/sparse-table/ é€‚ç”¨èŒƒå›´ï¼šå¯é‡å¤è´¡çŒ®é—®é¢˜ op(x, x) = x, ä¸€ä¸ªæ“ä½œé‡å¤è®¡ç®—ç­‰äºå…¶æœ¬èº« æ¯”å¦‚max, min, gcdç­‰æ“ä½œ è¿™æ ·å¯ä»¥å…è®¸æˆ‘ä»¬åˆ’åˆ†å­é—®é¢˜æ—¶ï¼Œå³ä½¿å­é—®é¢˜ä¹‹é—´å­˜åœ¨é‡å ï¼Œä¹Ÿå¯ä»¥è·å¾—æ­£ç¡®çš„ç»“æœ $ ST[i][j] = min(arr[iâ€¦(i + 2^j - 1)]) $ (é—­åŒºé—´) 123456789101112131415/*6,5,1,4,6,1,5,3ç¨€ç–è¡¨0 1 3 70 1 2 3â€”â€”â€”â€”â€”â€”â€”6 5 4 15 1 1 11 1 1 14 4 5 16 1 1 11 1 1 15 3 3 33 3 3 3*/ å¯è§æ„é€ çš„æ—¶é—´ä¸ºO(nlogn) 12345678910/*0...1 1...2 2...3 3...4 4...5 5...6 6...70...3 1...4 2...5 3...6 4...7 5...7 6...70...7 1...7 2...7 3...7 4...7 5...7 6...70...2 -&gt; 0...1, 1...20...4 -&gt; 0...3, 1...40...5 -&gt; 0...3, 2...50...6 -&gt; 0...3, 3...6*/ ä¸€ä¸ªæŸ¥è¯¢æœ‰å¯æ‹†æˆåŒä¸€è¡Œçš„ä¸¤ä¸ªå­æ•°ç»„ å› ä¸º $ ST[i][j] = min(arr[iâ€¦(i + 2^j - 1)]) $ $ start = i $ , $end = i + 2^j - 1$ è§£å¾—$j = log(end - start + 1)$ è¦æŸ¥ $ 0 â€¦ 6 $ï¼ŒæŸ¥è¯¢ $ (0, log(6-0+1)) $ = $ (0, 2) $ = $ 0 â€¦ 3 $ä¸‹é¢æŸ¥ $ 3 â€¦ 6 $ï¼ŒæŸ¥è¯¢ $ (3, 2) $ = $ (6 - 2^2 + 1, 2) $å…¬å¼æ˜¯è¿™ä¹ˆæ¥çš„ï¼š$aâ€¦b$ = $(a, a + 2^j - 1)$ = $(b - 2^j + 1, b)$ è¦æŸ¥$0 â€¦ 5$ï¼ŒæŸ¥è¯¢$(0, log(5-0+1))$ = $(0, 2)$ = $0 â€¦ 3$ä¸‹é¢æŸ¥$ 2 â€¦ 5 $, æŸ¥è¯¢$(2, 2)$ = $(5 - 2^2 + 1, 2)$ä¹Ÿå°±æ˜¯è¯´ï¼Œè¦æŸ¥è¯¢$ aâ€¦b $ç›¸å½“äº$ min(aâ€¦(a+2^j-1), (b - 2^j + 1)â€¦b) $$ min(ST[a][j], ST[b-2^j+1][j]), j = log2(b-a+1)$ å¦‚ä½•æ„é€ STè¡¨ï¼š$ (i, i + 2^j - 1) = (i, i + 2^{j-1} - 1), (i + 2^{j-1}, i + 2^j - 1) $$ ST[i][j] = min(ST[i][j-1], ST[i+j][j-1]) $ 123456789101112131415161718192021vector&lt;int&gt; RMQ(vector&lt;int&gt;&amp; array, vector&lt;pair&lt;int, int&gt;&gt;&amp; query) { int n = array.size(); int log_n = log2(n); vector&lt;vector&lt;int&gt;&gt; ST(n); vector&lt;int&gt; ans; for(int i = 0; i &lt; n; i++) { ST[i].push_back(array[i]); } // sum[p=1...log2(n)](n-p) = n*log2(n) - (log2(n)+1)*log2(n)/2 for(int j = 1; j &lt;= log_n + 1; j++) { int off = 1 &lt;&lt; (j - 1); for(int i = 0; i + off &lt; n; i++) { // n - j ST[i].push_back(min(ST[i][j-1], ST[i+off][j-1])); } } for(auto [start, end] : query) { int pos = log2(end - start + 1); ans.push_back(min(ST[start][pos], ST[end - (1 &lt;&lt; pos) + 1][pos])); } return ans;} å¿«é€Ÿå¹‚å¯¹æŒ‡æ•°è¿›è¡ŒäºŒè¿›åˆ¶åˆ†è§£$ n $ = 22 = 10110 = $2^4 + 2^2 + 2^1$$ a^{n} = a^{2^4} \\times a^{2^2} \\times a^{2^1}$ 123456789int fastPow(int base, int pow, int mod) { int ans = 1 % mod; // æ³¨æ„è¦åœ¨æœ€åˆæˆ–æœ€åå¯¹anså–modï¼Œä»¥åº”å¯¹pow = 0, mod = 1çš„æƒ…å†µ while(pow) { if(pow &amp; 1) ans = (ans * base) % mod; base = (base * base) % mod; pow &gt;&gt;= 1; } return ans;} LCAæœ€è¿‘å…¬å…±ç¥–å…ˆéå†äºŒå‰æ ‘1234567891011class Solution {public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(!root) return nullptr; if(root == p || root == q) return root; TreeNode *l = lowestCommonAncestor(root-&gt;left, p, q); TreeNode *r = lowestCommonAncestor(root-&gt;right, p, q); if(l != nullptr &amp;&amp; r != nullptr) return root; // på’Œqåˆ†åˆ«åœ¨å·¦å³å­æ ‘ä¸­æ‰¾åˆ° return l == nullptr ? r : l; }}; å¤æ‚åº¦ä¸º$ O(n) $å¯¹äº$m$æ¬¡æŸ¥è¯¢,å¤æ‚åº¦ä¸º$O(m \\times n)$ STè¡¨å½“æŸ¥æ‰¾ä¸¤ä¸ªèŠ‚ç‚¹node0å’Œnode1çš„æœ€è¿‘å…¬å…±ç¥–å…ˆæ—¶ å¦‚æœnode0å’Œnode1åœ¨åŒä¸€å±‚ï¼Œæ·±åº¦ä¸ºd å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹åœ¨æ·±åº¦d-kå±‚å¤„çš„ç¥–å…ˆæ˜¯åŒä¸€ä¸ª é‚£ä¹ˆè¯´æ˜æœ€è¿‘å…¬å…±ç¥–å…ˆåœ¨[d-k, d+1] kåå¤§äº†ï¼Œéœ€è¦å‡å° å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹åœ¨æ·±åº¦d-kå±‚å¤„çš„ç¥–å…ˆä¸æ˜¯åŒä¸€ä¸ª é‚£ä¹ˆè¯´æ˜æœ€è¿‘å…¬å…±ç¥–å…ˆåœ¨[0, d-k] å°†ä¸¤ä¸ªèŠ‚ç‚¹ç§»åŠ¨åˆ°å„è‡ªd-kå±‚å¤„çš„ç¥–å…ˆå¤„ å¦‚æ­¤è¿­ä»£ï¼Œå°±å¯ä»¥å°†åŒºé—´ä¸æ–­ç¼©å°ï¼Œæœ€åå®šä½åˆ°æœ€è¿‘å…¬å…±ç¥–å…ˆå¦‚æœkå–å½“å‰æ·±åº¦çš„ä¸€åŠï¼Œå°±å¯ä»¥è¾¾åˆ°log(depth)çš„å¤æ‚åº¦ ST[i][j]è¡¨ç¤ºèŠ‚ç‚¹iå‘ä¸Š2^jå±‚çš„ç¥–å…ˆèŠ‚ç‚¹$ 2^j &lt; depth, j=0â€¦floor(log2(depth))$è½¬ç§»æ–¹ç¨‹ä¸º: 1ST[i][j] = ST[ST[i][j-1]][j-1] è¿™é‡Œå°±ç”¨åˆ°äº†å€å¢çš„æ€æƒ³ å¦‚æœnode0å’Œnode1åœ¨ä¸åŒä¸€å±‚ï¼Œå¯ä»¥å…ˆå°†æ·±åº¦è¾ƒæ·±çš„èŠ‚ç‚¹å‘ä¸Šç§»åŠ¨å‡è®¾é«˜åº¦å·®ä¸º5=101åˆ™12node = ST[node][0] // j = 0, 2^0node = ST[node][2] // j = 2, 2^2 å°†é«˜åº¦å·®çš„äºŒè¿›åˆ¶åˆ†è§£ï¼Œå³å¯ä»¥log(dep1 - dep2)çš„å¤æ‚åº¦å°†ä¸¤ä¸ªèŠ‚ç‚¹æ”¾åˆ°åŒä¸€å±‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class LCA { vector&lt;vector&lt;int&gt;&gt;&amp; tree; // tree[i][j]ä»£è¡¨èŠ‚ç‚¹içš„ç¬¬jä¸ªå­©å­åœ¨treeä¸­çš„ç´¢å¼• int N; // èŠ‚ç‚¹æ€»æ•° vector&lt;vector&lt;int&gt;&gt; ST; // ST[i][j]è¡¨ç¤ºèŠ‚ç‚¹iå‘ä¸Š2^jå±‚çš„ç¥–å…ˆèŠ‚ç‚¹ vector&lt;int&gt; depth; // depth[i]ä»£è¡¨èŠ‚ç‚¹çš„æ·±åº¦ int maxDepth = 0; // æ ‘çš„æ·±åº¦ void dfsInit(int root, int dep) { depth[root] = dep; // æ¯ä¸ªèŠ‚ç‚¹çš„æ·±åº¦ maxDepth = max(maxDepth, dep); for(int child : tree[root]) { dfsInit(child, dep + 1); ST[child][0] = root;// childèŠ‚ç‚¹å‘ä¸Š2^0=1å±‚çš„çˆ¶èŠ‚ç‚¹ } } void initST() { // iå‘ä¸Š2^jå±‚çš„çˆ¶èŠ‚ç‚¹ = iå‘ä¸Šå‘ä¸Š2^(j-1)å±‚çˆ¶èŠ‚ç‚¹å†å‘ä¸Š2^(j-1)å±‚çš„çˆ¶èŠ‚ç‚¹ for(int j = 1; (1 &lt;&lt; j) &lt;= maxDepth; j++) { for(int i = 0; i &lt; N; i++) { ST[i].push_back(ST[ST[i][j-1]][j-1]); } } } LCA(vector&lt;vector&lt;int&gt;&gt;&amp; tree, int N): tree(tree), N(N), depth(N), ST(N, vector&lt;int&gt;(1)) { dfsInit(0, 0); initST(); } public: LCA(vector&lt;vector&lt;int&gt;&gt;&amp; tree):LCA(tree, tree.size()) {} int lca(int node0, int node1) { if(depth[node0] &gt; depth[node1]) { swap(node0, node1); // node1ä¸ºæ·±åº¦æ›´æ·±çš„èŠ‚ç‚¹ } int depDiff = depth[node1] - depth[node0]; for(int i = 0; depDiff; depDiff &gt;&gt;= 1, i++) { if(depDiff &amp; 1) { node1 = ST[node1][i]; // å‘ä¸Šç§»åŠ¨node1ï¼Œä¸¤è€…depthç›¸åŒ } } if(node1 == node0) return node0; for(int i = log2(maxDepth); i &gt;= 0; i--) { // æ¯æ¬¡å‘ä¸ŠæŸ¥è¯¢çš„æ·±åº¦å‡åŠ if(ST[node0][i] != ST[node1][i]) { // å‘ä¸Šçš„ç¥–å…ˆèŠ‚ç‚¹ä¸åŒï¼Œç§»åŠ¨åˆ°å„è‡ªç¥–å…ˆèŠ‚ç‚¹ä¸Š node0 = ST[node0][i]; node1 = ST[node1][i]; } // else å‘ä¸Šçš„ç¥–å…ˆèŠ‚ç‚¹ç›¸åŒï¼Œç»§ç»­å‡å°æ·±åº¦ } return ST[node0][0]; // node0æˆ–node1çš„çˆ¶èŠ‚ç‚¹å°±æ˜¯lca }}; æ¯æ¬¡æŸ¥è¯¢çš„å¤æ‚åº¦ä¸º $O(log(depth))$ é¢„å¤„ç†çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(log(n \\times log(depth)))$ $ m $ æ¬¡æŸ¥è¯¢çš„å¤æ‚åº¦ä¸º $ O((m + n) \\times log(depth)) $","link":"/home/2024/08/23/%E7%AE%97%E6%B3%95/OI-KIWI-01-%E5%80%8D%E5%A2%9E/"},{"title":"OI KIWI 02-äºŒåˆ†","text":"äºŒåˆ†æŸ¥æ‰¾å·¦é—­å³é—­123456789101112131415int binarySearch(vector&lt;int&gt;&amp; vec, int target) { int len = vec.size(); int l = 0, r = len - 1; // while(l &lt;= r) { int mid = (r - l) / 2 + l; if(vec[mid] == target) { return mid; } else if(vec[mid] &gt; target) { r = mid - 1; } else { l = mid + 1; } } return -1;} å·¦é—­å³å¼€123456789101112131415161718class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { int len = nums.size(); int l = 0, r = len; while(l &lt; r) { int mid = (r - l) / 2 + l; if(nums[mid] == target) { return mid; } else if(nums[mid] &gt; target) { r = mid; } else { l = mid + 1; } } return -1; }}; æ€»ç»“ lå’Œrä»£è¡¨åŒºé—´ï¼Œå½“åŒºé—´å†…æ²¡æœ‰å…ƒç´ æ—¶æŸ¥æ‰¾ç»“æŸ å¯¹äºé—­åŒºé—´ï¼Œæ˜¯l &gt; r, æ‰€ä»¥å¾ªç¯æ¡ä»¶æ˜¯ l &lt;= r å¯¹äºå·¦é—­å³å¼€åŒºé—´ï¼Œæ˜¯l &gt;= r, æ‰€ä»¥å¾ªç¯æ¡ä»¶æ˜¯ l &lt; r åŒºé—´å·¦/å³è¾¹ç•Œç§»åŠ¨ï¼Œç§»åŠ¨åˆ°æœ€å°çš„æŸ¥æ‰¾åŒºé—´ï¼Œä¹Ÿå°±æ˜¯åŒºé—´ä¸åŒ…æ‹¬å¦ä¸€åŠåŒºé—´å’Œå½“å‰midå€¼ å¯¹äºé—­åŒºé—´ï¼Œr = mid - 1ï¼Œä¸åŒ…æ‹¬å½“å‰midå€¼[l, mid - 1] å¯¹äºå·¦é—­å³å¼€åŒºé—´ï¼Œr = midï¼Œä¸åŒ…æ‹¬å½“å‰midå€¼[l, mid) å·¦ä¾§è¾¹ç•Œé—­åŒºé—´å¦‚æœtargetåœ¨vecä¸­ï¼Œåˆ™æ‰¾åˆ°æœ€åä¸€ä¸ªtargetçš„ä¸‹æ ‡å¦‚æœtargetä¸åœ¨vecä¸­ï¼Œåˆ™æ‰¾åˆ°targetåº”è¯¥æ’å…¥åœ¨å“ªä¸ªå…ƒç´ åé¢ 123456789101112131415int binarySearch(vector&lt;int&gt;&amp; vec, int target) { int len = vec.size(); int l = 0, r = len - 1; while(l &lt;= r) { int mid = (r - l) / 2 + l; if(vec[mid] == target) { l = mid - 1; } else if(vec[mid] &gt; target) { r = mid - 1; } else { l = mid + 1; } } return l;} mid != targetçš„æƒ…å†µï¼Œæ­£å¸¸äºŒåˆ†æŸ¥æ‰¾ mid == targetï¼Œ æ‰¾targetçš„å‰é©±ï¼Œæ‰€ä»¥l = mid - 1ï¼ˆä¸ºå•¥ä¸æ˜¯midï¼‰","link":"/home/2024/09/01/%E7%AE%97%E6%B3%95/OI-KIWI-02-%E4%BA%8C%E5%88%86/"},{"title":"01-Binder","text":"çœ‹æºç çš„æ—¶å€™å¯ä»¥ç”¨umlå›¾è¾…åŠ©ç†è§£ å¤šè¿›ç¨‹ä¸ºä»€ä¹ˆå¤šè¿›ç¨‹ çªç ´å†…å­˜é™åˆ¶ï¼šAndroidç³»ç»Ÿåœ¨å†…å­˜ä¸è¶³æ—¶ï¼Œä¼šä¼˜å…ˆæ€å ç”¨å†…å­˜å¤šçš„è¿›ç¨‹ åŠŸèƒ½ç¨³å®šæ€§ï¼šæŠŠä¸€äº›åŠŸèƒ½æ”¾åˆ°ç‹¬ç«‹çš„è¿›ç¨‹ä¸­ï¼Œä¿è¯è¿›ç¨‹åŠŸèƒ½çš„çº¯ç²¹æ€§å’Œç¨³å®šæ€§ è§„é¿ç³»ç»Ÿå†…å­˜æ³„æ¼ï¼šç‹¬ç«‹çš„WebViewè¿›ç¨‹é˜»éš”å†…å­˜æ³„æ¼é—®é¢˜ éš”ç¦»é£é™©ï¼šä¸ç¨³å®šåŠŸèƒ½æ”¾åˆ°å­è¿›ç¨‹ï¼Œä¿è¯ä¸»è¿›ç¨‹çš„ç¨³å®šæ€§ Androidä¸­çš„è¿›ç¨‹é—´é€šä¿¡ Binder aidl Socket ç®¡é“ï¼šhandler å…±äº«å†…å­˜ frescoï¼Œmmkvï¼ˆåŒ¿åï¼‰ ä¿¡å·ï¼š ANRç›‘æ§ matrixã€xcrashã€å‹ç›Ÿapm binderçš„ä¼˜åŠ¿ ä¸€æ¬¡æ‹·è´ å°†å†…æ ¸ç©ºé—´å†…å­˜æ˜ å°„åˆ°ç”¨æˆ·ç©ºé—´ aå‘é€æ•°æ®åˆ°bï¼Œbinderç›´æ¥å°†æ•°æ®æ‹·è´åˆ°ä¸bå…±äº«çš„å†…å­˜ç©ºé—´ä¸­ csæ¶æ„ï¼Œç¨³å®šæ€§å¥½ å®‰å…¨ï¼Œæœ‰èº«ä»½éªŒè¯ï¼ˆäº¤æ¢pidï¼Œç”±å†…æ ¸å®Œæˆ AIDL DSL aidlå°†dslæ–‡ä»¶ç¼–è¯‘æˆJava å››å¤§ç»„ä»¶ initå¯åŠ¨ zygote servicemanager bindServiceä¸€å…±å‡ æ¬¡IPC å®¢æˆ·ç«¯ä¸ServiceManageräº¤äº’è·å¾—AMSçš„IBinder å®¢æˆ·ç«¯é€šè¿‡AMSçš„IBinderè¯·æ±‚bindService AMSä¸æœåŠ¡è¿›ç¨‹é€šä¿¡ï¼Œè°ƒç”¨onBindï¼Œè·å–IBinder æœåŠ¡ç«¯æŠŠIBinderäº¤ç»™AMSï¼Œå…ˆServiceManageräº¤äº’è·å¾—AMSçš„IBinder æœåŠ¡ç«¯é€šè¿‡AMSçš„IBinderå‘å¸ƒè‡ªå·±çš„IBinderç»™AMS AMSä¸å®¢æˆ·ç«¯é€šä¿¡ï¼Œè½¬å‘æœåŠ¡ç«¯çš„IBinderï¼ˆä»£ç†BinderProxyï¼‰ binderæ•°æ®ä¼ è¾“çš„å¤§å°é™åˆ¶ 10241024-40962 BIND_VM_SIZE = 1M - sysconf(_SC_PAGE_SIZE) * 2 aidl å¼‚æ­¥ä¼ è¾“ï¼šonewayï¼ŒBIND_VM_SIZE/2 åŒæ­¥ä¼ è¾“ï¼šBIND_VM_SIZE Binderå…¶ä»–çŸ¥è¯† å››æ£µçº¢é»‘æ ‘ Binderçº¿ç¨‹æ±  Binderé©±åŠ¨binder_inité€šè¿‡misc_registeræ³¨å†Œç‰¹æ®Šè®¾å¤‡ 12345678910111213141516static const struct file_operations binder_fops = { .owner = THIS_MODULE, .poll = binder_poll, .unlocked_ioctl = binder_ioctl, .compat_ioctl = binder_ioctl, .mmap = binder_mmap, .open = binder_open, .flush = binder_flush, .release = binder_release,}; // ç³»ç»Ÿè°ƒç”¨ä¸é©±åŠ¨çš„å¯¹åº”å…³ç³»static struct miscdevice binder_miscdev = { .minor = MISC_DYNAMIC_MINOR, //æ¬¡è®¾å¤‡å· åŠ¨æ€åˆ†é… .name = &quot;binder&quot;, //è®¾å¤‡å .fops = &amp;binder_fops //è®¾å¤‡çš„æ–‡ä»¶æ“ä½œç»“æ„ï¼Œè¿™æ˜¯file_operationsç»“æ„}; open -&gt; binder_open åˆ›å»ºbinder_procç»“æ„å¹¶åˆå§‹åŒ– ä¿å­˜è¿›ç¨‹ä¿¡æ¯ åŠ é”ï¼Œè®¡æ•°++ï¼Œhlist_add_head filpæ–‡ä»¶æŒ‡é’ˆçš„private_dataæŒ‡å‘binder_proc mmap -&gt; binder_mmap1234//åœ°å€åç§»é‡ = ç”¨æˆ·è™šæ‹Ÿåœ°å€ç©ºé—´ - å†…æ ¸è™šæ‹Ÿåœ°å€ç©ºé—´proc-&gt;user_buffer_offset = vma-&gt;vm_start - (uintptr_t)proc-&gt;buffer;//å¼‚æ­¥å¯ç”¨ç©ºé—´å¤§å°ä¸ºbufferæ€»å¤§å°çš„ä¸€åŠã€‚proc-&gt;free_async_space = proc-&gt;buffer_size / 2; ioctl -&gt; binder_ioctl ioctlå‘½ä»¤ æ•°æ®ç±»å‹ æ“ä½œ ä½¿ç”¨åœºæ™¯ BINDER_WRITE_READ struct binder_write_read æ”¶å‘Binder IPCæ•°æ® Binderè¯»å†™äº¤äº’åœºæ™¯ï¼ŒIPC.talkWithDriver BINDER_SET_MAX_THREADS __u32 è®¾ç½®Binderçº¿ç¨‹æœ€å¤§ä¸ªæ•° BINDER_SET_CONTEXT_MGR __s32 è®¾ç½®Service ManagerèŠ‚ç‚¹ servicemanagerè¿›ç¨‹æˆä¸ºä¸Šä¸‹æ–‡ç®¡ç†è€…ï¼Œbinder_become_context_manager() BINDER_THREAD_EXIT __s32 é‡Šæ”¾Binderçº¿ç¨‹ BINDER_VERSION struct binder_version è·å–Binderç‰ˆæœ¬ä¿¡æ¯ 12345678910111213141516171819202122232425static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { //è¿›å…¥ä¼‘çœ çŠ¶æ€ï¼Œç›´åˆ°ä¸­æ–­å”¤é†’ ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2); binder_lock(__func__); //è·å–binder_thread thread = binder_get_thread(proc); switch (cmd) { case BINDER_WRITE_READ: //è¿›è¡Œbinderçš„è¯»å†™æ“ä½œ ret = binder_ioctl_write_read(filp, cmd, arg, thread); if (ret) goto err; break; // case ....: // xxxx }err: if (thread) thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_NEED_RETURN; binder_unlock(__func__); wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);err_unlocked: trace_binder_ioctl_done(ret); return ret;} binder_get_thread ä»ä¸€é¢—çº¢é»‘æ ‘ä¸Šæ ¹æ®pidæ‰¾å½“å‰çº¿ç¨‹ å¦‚æœæ²¡æœ‰ï¼Œåˆ™åˆ›å»ºèŠ‚ç‚¹ binder_ioctl_write_read copy_from_userè¯»å–bwr æ£€æŸ¥è¯»å†™ç¼“å­˜ä¸­æ˜¯å¦æœ‰æ•°æ®ï¼Œå¦‚æœæœ‰ï¼Œå°±æ‰§è¡Œè¯»å†™ copy_to_userå°†bwrå†™å›ç”¨æˆ·ç©ºé—´ Binderå±‚æ¬¡ç»“æ„ Binderé€šä¿¡æ¨¡å‹ é€šä¿¡ç  ä»ICPå±‚è‡³å†…æ ¸ï¼šBC_è¯·æ±‚ç  ä»å†…æ ¸åˆ°IPCå±‚ï¼šBR_å“åº”ç  è¿‡ç¨‹ binder_thread_writeå¾ªç¯æ ¹æ®cmdå¤„ç†è¯·æ±‚ BC_FREE_BUFFER é€šè¿‡mmapæ˜ å°„å†…å­˜ï¼ŒServiceManageræ˜ å°„ç©ºé—´ä¸º128Kï¼ŒBinderåº”ç”¨è¿›ç¨‹ä¸º1M-8K allocated_bufferså’Œfree_buffersæ˜¯ä¸¤æ£µçº¢é»‘æ ‘ï¼Œåˆ†åˆ«å­˜æ”¾å·²åˆ†é…å†…å­˜å’Œæœªåˆ†é…å†…å­˜ã€‚åˆ†é…å†…å­˜æ—¶ä½¿ç”¨æœ€ä½³é€‚åº”ç®—æ³•ã€‚ BC_TRANSACTION æœ€å¸¸è§çš„ç ï¼Œå°†äº¤æ˜“è½¬åŒ–æˆbinder_work Clientå‘Binderé©±åŠ¨å‘é€è¯·æ±‚æ•°æ® BC_REPLY Serverå‘Binderé©±åŠ¨å‘é€è¯·æ±‚æ•°æ® binder_thread_read æ ¹æ®workå’Œå½“å‰çŠ¶æ€ç”Ÿæˆå“åº”ç ï¼Œæ¥ä¸‹æ¥ç”±ç”¨æˆ·æ€è¿›è¡Œå¤„ç† ServiceManager servicemanageræ˜¯æ“ä½œç³»ç»Ÿçš„ä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶ï¼Œåœ¨init.rcä¸­å¯åŠ¨ main1234567891011int main(int argc, char **argv) { struct binder_state *bs; //æ‰“å¼€binderé©±åŠ¨ï¼Œç”³è¯·128kå­—èŠ‚å¤§å°çš„å†…å­˜ç©ºé—´ bs = binder_open(128*1024); // ä¸æ˜¯ä¸Šé¢binder driverçš„binder_open //æˆä¸ºä¸Šä¸‹æ–‡ç®¡ç†è€… binder_become_context_manager(bs); // è°ƒç”¨ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, 0); //è¿›å…¥æ— é™å¾ªç¯ï¼Œå¤„ç†clientç«¯å‘æ¥çš„è¯·æ±‚ binder_loop(bs, svcmgr_handler); return 0;} binder_open1234567891011121314151617181920struct binder_state *binder_open(size_t mapsize){ struct binder_state *bs; struct binder_version vers; bs = malloc(sizeof(*bs)); //é€šè¿‡ç³»ç»Ÿè°ƒç”¨é™·å…¥å†…æ ¸ï¼Œæ‰“å¼€Binderè®¾å¤‡é©±åŠ¨ bs-&gt;fd = open(&quot;/dev/binder&quot;, O_RDWR); // è°ƒç”¨ä¸Šé¢é©±åŠ¨çš„binder_openï¼Œæ‰“å¼€é©±åŠ¨ï¼Œåˆå§‹åŒ–ï¼Œè¿”å›æ–‡ä»¶æè¿°ç¬¦ //é€šè¿‡ç³»ç»Ÿè°ƒç”¨ï¼Œioctlè·å–binderç‰ˆæœ¬ä¿¡æ¯ // ioctlå‘é€BINDER_VERSIONï¼Œè·å–ç‰ˆæœ¬å·ä¸ç”¨æˆ·ç©ºé—´çš„ç‰ˆæœ¬å·æ¯”è¾ƒ bs-&gt;mapsize = mapsize; //é€šè¿‡ç³»ç»Ÿè°ƒç”¨ï¼Œmmapå†…å­˜æ˜ å°„ï¼Œmmapå¿…é¡»æ˜¯pageçš„æ•´æ•°å€ bs-&gt;mapped = mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0); // è°ƒç”¨é©±åŠ¨çš„binder_mmapï¼Œå»ºç«‹å†…å­˜æ˜ å°„ return bs;} binder_become_context_manager1234567ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, 0);-&gt;binder_ioctl()-&gt;binder_ioctl_set_ctx_mgr()-&gt;// åˆ›å»ºbinder_new_nodeï¼Œweakã€strongå¼•ç”¨æ•°++ï¼Œå°†èŠ‚ç‚¹åŠ å…¥procçº¢é»‘æ ‘ binder_loop123456readbuf[0] = BC_ENTER_LOOPER;binder_write(bs, readbuf, sizeof(uint32_t));// é€šè¿‡binider_writeé€šçŸ¥è¿›å…¥loopfor(;;) { res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr); res = binder_parse(bs, 0, (uintptr_t) readbuf, bwr.read_consumed, func);} binder_write123456789101112131415int binder_write(struct binder_state *bs, void *data, size_t len) { struct binder_write_read bwr; int res; bwr.write_size = len; bwr.write_consumed = 0; bwr.write_buffer = (uintptr_t) data; //æ­¤å¤„dataä¸ºBC_ENTER_LOOPER bwr.read_size = 0; bwr.read_consumed = 0; bwr.read_buffer = 0; res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr); return res;} // å°±æ˜¯é€šè¿‡ioctlä¼ é€’æ¶ˆæ¯ï¼Œæœ€ç»ˆåœ¨é©±åŠ¨ä¸­æ‰¾åˆ°threadï¼Œè®¾ç½®æ ‡å¿—// thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED; æä¾›åŠŸèƒ½ï¼šæ³¨å†ŒæœåŠ¡ã€æ·»åŠ æœåŠ¡ BBinderå’ŒBpBinder12virtual BBinder* localBinder();virtual BpBinder* remoteBinder(); BpBinderè´Ÿè´£ä¼ è¾“æ•°æ®ï¼ŒBBinderè´Ÿè´£æ¥æ”¶æ•°æ®å’Œå¤„ç†æ•°æ®ã€‚","link":"/home/2024/03/24/Android%E9%AB%98%E7%BA%A7/FrameWork/01-Binder/"},{"title":"å®éªŒ-è¯·æ±‚è°ƒé¡µå­˜å‚¨ç®¡ç†æ–¹å¼çš„æ¨¡æ‹Ÿ","text":"1ã€å®éªŒç›®çš„é€šè¿‡å¯¹é¡µé¢ã€é¡µè¡¨ã€åœ°å€è½¬æ¢å’Œé¡µé¢ç½®æ¢è¿‡ç¨‹çš„æ¨¡æ‹Ÿï¼ŒåŠ æ·±å¯¹è¯·æ±‚è°ƒé¡µç³»ç»Ÿçš„åŸç†å’Œå®ç°è¿‡ç¨‹çš„ç†è§£ã€‚ 2ã€å®éªŒå†…å®¹ å‡è®¾æ¯ä¸ªé¡µé¢ä¸­å¯å­˜æ”¾10æ¡æŒ‡ä»¤ï¼Œåˆ†é…ç»™ä¸€ä½œä¸šçš„å†…å­˜å—æ•°ä¸º4ã€‚ ç”¨Cè¯­è¨€æ¨¡æ‹Ÿä¸€ä½œä¸šçš„æ‰§è¡Œè¿‡ç¨‹ã€‚è¯¥ä½œä¸šå…±æœ‰320æ¡æŒ‡ä»¤ï¼Œå³å®ƒçš„åœ°å€ç©ºé—´ä¸º32é¡µï¼Œç›®å‰å®ƒçš„æ‰€æœ‰é¡µéƒ½è¿˜æœªè°ƒå…¥å†…å­˜ã€‚åœ¨æ¨¡æ‹Ÿè¿‡ç¨‹ä¸­ï¼Œå¦‚æœæ‰€è®¿é—®çš„æŒ‡ä»¤å·²ç»åœ¨å†…å­˜ä¸­ï¼Œåˆ™æ˜¾ç¤ºå…¶ç‰©ç†åœ°å€ï¼Œå¹¶è½¬ä¸‹ä¸€æ¡æŒ‡ä»¤ã€‚å¦‚æœæ‰€è®¿é—®çš„æŒ‡ä»¤è¿˜æœªè£…å…¥å†…å­˜ï¼Œåˆ™å‘ç”Ÿç¼ºé¡µï¼Œæ­¤æ—¶éœ€è®°å½•ç¼ºé¡µçš„æ¬¡æ•°ï¼Œå¹¶å°†ç›¸åº”é¡µè°ƒå…¥å†…å­˜ã€‚å¦‚æœ4ä¸ªå†…å­˜å—ä¸­å‡å·²è£…å…¥è¯¥ä½œä¸šï¼Œåˆ™éœ€è¿›è¡Œé¡µé¢ç½®æ¢ã€‚æœ€åæ˜¾ç¤ºå…¶ç‰©ç†åœ°å€ï¼Œå¹¶è½¬ä¸‹ä¸€æ¡æŒ‡ä»¤ã€‚åœ¨æ‰€æœ‰320æ¡æŒ‡ä»¤æ‰§è¡Œå®Œæ¯•åï¼Œè¯·è®¡ç®—å¹¶æ˜¾ç¤ºä½œä¸šè¿è¡Œè¿‡ç¨‹ä¸­å‘ç”Ÿçš„ç¼ºé¡µç‡ã€‚ ç½®æ¢ç®—æ³•ï¼šè¯·åˆ†åˆ«è€ƒè™‘OPTã€FIFOå’ŒLRUç®—æ³•ã€‚ ä½œä¸šä¸­æŒ‡ä»¤çš„è®¿é—®æ¬¡åºæŒ‰ä¸‹è¿°åŸåˆ™ç”Ÿæˆï¼š â€¢ 50%çš„æŒ‡ä»¤æ˜¯é¡ºåºæ‰§è¡Œçš„ã€‚â€¢ 25%çš„æŒ‡ä»¤æ˜¯å‡åŒ€åˆ†å¸ƒåœ¨å‰åœ°å€éƒ¨åˆ†ã€‚â€¢ 25%çš„æŒ‡ä»¤æ—¶å‡åŒ€åˆ†å¸ƒåœ¨ååœ°å€éƒ¨åˆ†ã€‚ å…·ä½“çš„å®æ–½åŠæ³•æ˜¯ï¼š â‘  åœ¨[0ï¼Œ319]ä¹‹é—´éšæœºé€‰å–ä¸€æ¡èµ·å§‹æ‰§è¡ŒæŒ‡ä»¤ï¼Œå…¶åºå·ä¸ºmï¼›â‘¡ é¡ºåºæ‰§è¡Œä¸‹ä¸€æ¡æŒ‡ä»¤ï¼Œå³åºå·ä¸ºm+1çš„æŒ‡ä»¤ï¼›â‘¢ é€šè¿‡éšæœºæ•°ï¼Œè·³è½¬åˆ°å‰åœ°å€éƒ¨åˆ†[0ï¼Œm-1]ä¸­çš„æŸæ¡æŒ‡ä»¤å¤„ï¼Œå…¶åºå·ä¸ºm1ï¼›â‘£ é¡ºåºæ‰§è¡Œä¸‹ä¸€æ¡æŒ‡ä»¤ï¼Œå³åºå·ä¸ºm1+1çš„æŒ‡ä»¤ï¼›â‘¤ é€šè¿‡éšæœºæ•°ï¼Œè·³è½¬åˆ°ååœ°å€éƒ¨åˆ†[m1+2ï¼Œ319]ä¸­çš„æŸæ¡æŒ‡ä»¤å¤„ï¼Œå…¶åºå·ä¸ºm2ï¼›â‘¥ é¡ºåºæ‰§è¡Œä¸‹ä¸€æ¡æŒ‡ä»¤ï¼Œå³åºå·ä¸ºm2+1çš„æŒ‡ä»¤ï¼›â‘¦ é‡å¤è·³è½¬åˆ°å‰åœ°å€éƒ¨åˆ†ã€é¡ºåºæ‰§è¡Œã€è·³è½¬åˆ°ååœ°å€éƒ¨åˆ†ã€é¡ºåºæ‰§è¡Œçš„è¿‡ç¨‹ï¼Œç›´è‡³æ‰§è¡Œ320æ¡æŒ‡ä»¤ã€‚ å®éªŒä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;random&gt;#include &lt;ctime&gt;#include &lt;iomanip&gt;#include &lt;queue&gt;#include &lt;stack&gt;using std::cout;using std::endl;#define show_progressconst int max_ins_num = 320;const int ins_per_mb = 10;const int mem_max_mb = 4;int cur_clock = 0;const int total_mb = max_ins_num/ins_per_mb;int get_inst_i(int min, int max) { static std::default_random_engine engine(time(nullptr)); //std::uniform_int_distribution&lt;int&gt;distribution(min, max); return engine() %(max - min + 1) + min;}#define chart_head std::left &lt;&lt; std::setw(len+1) &lt;&lt; std::setfill('-') &lt;&lt; &quot;&quot;#define chart_cell &quot;|&quot; &lt;&lt; std::left &lt;&lt; std::setw(len) &lt;&lt; std::setfill(' ')void show_chart(std::queue&lt;int&gt; fifo, std::stack&lt;int&gt; lru, const std::vector&lt;int&gt;&amp; opt, int ins, int block) { std::cout &lt;&lt; &quot;cur_ins = &quot; &lt;&lt; ins &lt;&lt; &quot;\\ncur_block = &quot; &lt;&lt; block &lt;&lt; std::endl; int len = 5; std::cout &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;-&quot; &lt;&lt; std::endl &lt;&lt; chart_cell &lt;&lt; &quot;fifo&quot; &lt;&lt; chart_cell&lt;&lt; &quot;lru&quot; &lt;&lt; chart_cell &lt;&lt; &quot;opt&quot; &lt;&lt; &quot;|&quot; &lt;&lt; std::endl &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;-&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; mem_max_mb; ++i) { int lru_cout = -1; int fifo_cout = -1; if (!fifo.empty()) { fifo_cout = fifo.front(); fifo.pop(); } if (!lru.empty()) { lru_cout = lru.top(); lru.pop(); } std::cout &lt;&lt; chart_cell &lt;&lt; fifo_cout &lt;&lt; chart_cell &lt;&lt; lru_cout &lt;&lt; chart_cell &lt;&lt; opt[i] &lt;&lt; &quot;|&quot; &lt;&lt; std::endl; } std::cout &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;-&quot; &lt;&lt; std::endl;}int fifo_exchange = 0;int lru_exchange = 0;int opt_exchange = 0;void exe_inst_i(int ins, const std::vector&lt;int&gt;&amp; ins_arr) { static std::queue&lt;int&gt; fifo_mem_blocks; static std::vector&lt;bool&gt; fifo_map(total_mb, false); static std::stack&lt;int&gt; lru_mem_blocks; static std::vector&lt;bool&gt; lru_map(total_mb, false); static std::vector&lt;int&gt; opt_mem_blocks(mem_max_mb, -1); static std::vector&lt;int&gt; opt_map(total_mb, max_ins_num); int cur_ins = ins; int cur_block = ins/ins_per_mb; //fifo if(!fifo_map[cur_block]) { if (fifo_mem_blocks.size() &gt;= mem_max_mb) { fifo_map[fifo_mem_blocks.front()] = false; fifo_mem_blocks.pop(); fifo_exchange++; } fifo_mem_blocks.push(cur_block); fifo_map[cur_block] = true; } else { } // lru std::stack&lt;int&gt; lru_temp; if (!lru_map[cur_block]) { while (!lru_mem_blocks.empty()) { lru_temp.push(lru_mem_blocks.top()); lru_mem_blocks.pop(); } if (lru_temp.size() &gt;= mem_max_mb) { lru_map[lru_temp.top()] = false; lru_temp.pop(); lru_exchange++; } lru_map[cur_block] = true; while (!lru_temp.empty()) { lru_mem_blocks.push(lru_temp.top()); lru_temp.pop(); } lru_mem_blocks.push(cur_block); } else { while (lru_mem_blocks.top() != cur_block) { lru_temp.push(lru_mem_blocks.top()); lru_mem_blocks.pop(); } lru_mem_blocks.pop(); while (!lru_temp.empty()) { lru_mem_blocks.push(lru_temp.top()); lru_temp.pop(); } lru_mem_blocks.push(cur_block); } //opt for (int i = cur_clock; i &lt; max_ins_num; i++) { int block_i = ins_arr[i]/ins_per_mb; opt_map[block_i] = opt_map[block_i] &lt; i ? opt_map[block_i] : i; //è®¾ç½®opt=ä»clockå¼€å§‹ï¼ŒæŸä¸ªå—å„¿ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½® } static int opt_num = 0; int opt_exchange_i = 0; for (int i = 0; i &lt; mem_max_mb; ++i) { if (opt_mem_blocks[i] == cur_block || opt_mem_blocks[i] == -1) { opt_exchange_i = i; // éœ€è¦çš„å—å„¿å·²ç»åœ¨é‡Œé¢äº†ï¼Œåœæ­¢ break; }// å¦‚æœä¸åœ¨é‡Œé¢ï¼Œåˆ†æ”¯ä¸ä¼šæ‰§è¡Œï¼Œå¯ä»¥æ‰¾åˆ°æœ€è¿œè¢«è®¿é—®çš„æœ€ä½³æ›¿æ¢ if (opt_map[opt_mem_blocks[i]] &gt; opt_map[opt_mem_blocks[opt_exchange_i]]) { //è¿™é‡Œopt_exchange_i å’Œ iç­‰ä»·çš„ï¼Œå°‘å¥—ç”¨äº†ä¸€å±‚ opt_exchange_i = i; } } if (opt_mem_blocks[opt_exchange_i] == -1) { opt_mem_blocks[opt_num] = cur_block; opt_num++; } else if (opt_mem_blocks[opt_exchange_i] != cur_block) { opt_mem_blocks[opt_exchange_i] = cur_block; opt_exchange++; } //opt_map[cur_block] = max_ins_num; for (int i = 0; i &lt; total_mb; i++) { opt_map[i] = max_ins_num; } //æ‰§è¡Œè¿‡çš„å—å„¿ç½®ä¸ºæœ€å¤§å€¼ï¼Œæ„ä¸ºå†ä¹Ÿä¸ç”¨ï¼ˆå¯èƒ½ï¼‰#ifdef show_progress show_chart(fifo_mem_blocks, lru_mem_blocks, opt_mem_blocks, cur_ins, cur_block);#endif}void show_info(int fifo, int lru, int opt) { int len = int(std::string(&quot;miss_ratio&quot;).length()+1); std::cout &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;-&quot; &lt;&lt; std::endl &lt;&lt; chart_cell &lt;&lt; &quot;item&quot; &lt;&lt; chart_cell &lt;&lt; &quot;fifo&quot; &lt;&lt; chart_cell&lt;&lt; &quot;lru&quot; &lt;&lt; chart_cell &lt;&lt; &quot;opt&quot; &lt;&lt; &quot;|&quot; &lt;&lt; std::endl &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;-&quot; &lt;&lt; std::endl &lt;&lt; chart_cell &lt;&lt; &quot;hit&quot; &lt;&lt; chart_cell &lt;&lt; max_ins_num-fifo &lt;&lt; chart_cell &lt;&lt; max_ins_num-lru &lt;&lt; chart_cell &lt;&lt; max_ins_num-opt &lt;&lt; &quot;|&quot; &lt;&lt; std::endl &lt;&lt; chart_cell &lt;&lt; &quot;hit_ratio&quot; &lt;&lt; chart_cell &lt;&lt; (1-fifo/(double)max_ins_num)*100 &lt;&lt; chart_cell &lt;&lt; (1-lru/(double)max_ins_num)*100 &lt;&lt; chart_cell &lt;&lt; (1-opt/(double)max_ins_num)*100 &lt;&lt; &quot;|&quot; &lt;&lt; std::endl &lt;&lt; chart_cell &lt;&lt; &quot;miss&quot; &lt;&lt; chart_cell &lt;&lt; fifo &lt;&lt; chart_cell &lt;&lt; lru &lt;&lt; chart_cell &lt;&lt; opt &lt;&lt; &quot;|&quot; &lt;&lt; std::endl &lt;&lt; chart_cell &lt;&lt; &quot;miss_ratio&quot; &lt;&lt; chart_cell &lt;&lt; fifo/(double)max_ins_num*100 &lt;&lt; chart_cell &lt;&lt; lru/(double)max_ins_num*100 &lt;&lt; chart_cell &lt;&lt; opt/(double)max_ins_num*100 &lt;&lt; &quot;|&quot; &lt;&lt; std::endl &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;-&quot; &lt;&lt; std::endl;}int main() { std::vector&lt;int&gt; ins_arr(max_ins_num,0); int ins; for(int i = 0; i &lt; max_ins_num; i++) { if (i%6 == 0) { ins = get_inst_i(0,max_ins_num-1); ins_arr[i] = ins; } else if (i%6 == 1 || i%6 == 3 || i%6 == 5) { ins_arr[i] = ins_arr[i-1] + 1 &lt; max_ins_num ? ins_arr[i-1] + 1 : max_ins_num-1; } else if (i%6 == 2){ ins = get_inst_i(0, ins - 1 &gt; 0 ? ins - 1 : 1); ins_arr[i] = ins; } else if (i%6 == 4) { ins = get_inst_i(ins + 2 &gt; max_ins_num-2 ? max_ins_num-2 : ins+2, max_ins_num-1); ins_arr[i] = ins; } } for (cur_clock = 0; cur_clock &lt; max_ins_num; ++cur_clock) { exe_inst_i(ins_arr[cur_clock], ins_arr); } show_info(fifo_exchange, lru_exchange, opt_exchange); return 0;} è¿è¡Œç»“æœ1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783178417851786178717881789179017911792179317941795179617971798179918001801180218031804180518061807180818091810181118121813181418151816181718181819182018211822182318241825182618271828182918301831183218331834183518361837183818391840184118421843184418451846184718481849185018511852185318541855185618571858185918601861186218631864186518661867186818691870187118721873187418751876187718781879188018811882188318841885188618871888188918901891189218931894189518961897189818991900190119021903190419051906190719081909191019111912191319141915191619171918191919201921192219231924192519261927192819291930193119321933193419351936193719381939194019411942194319441945194619471948194919501951195219531954195519561957195819591960196119621963196419651966196719681969197019711972197319741975197619771978197919801981198219831984198519861987198819891990199119921993199419951996199719981999200020012002200320042005200620072008200920102011201220132014201520162017201820192020202120222023202420252026202720282029203020312032203320342035203620372038203920402041204220432044204520462047204820492050205120522053205420552056205720582059206020612062206320642065206620672068206920702071207220732074207520762077207820792080208120822083208420852086208720882089209020912092209320942095209620972098209921002101210221032104210521062107210821092110211121122113211421152116211721182119212021212122212321242125212621272128212921302131213221332134213521362137213821392140214121422143214421452146214721482149215021512152215321542155215621572158215921602161216221632164216521662167216821692170217121722173217421752176217721782179218021812182218321842185218621872188218921902191219221932194219521962197219821992200220122022203220422052206220722082209221022112212221322142215221622172218221922202221222222232224222522262227222822292230223122322233223422352236223722382239224022412242224322442245224622472248224922502251225222532254225522562257225822592260226122622263226422652266226722682269227022712272227322742275227622772278227922802281228222832284228522862287228822892290229122922293229422952296229722982299230023012302230323042305230623072308230923102311231223132314231523162317231823192320232123222323232423252326232723282329233023312332233323342335233623372338233923402341234223432344234523462347234823492350235123522353235423552356235723582359236023612362236323642365236623672368236923702371237223732374237523762377237823792380238123822383238423852386238723882389239023912392239323942395239623972398239924002401240224032404240524062407240824092410241124122413241424152416241724182419242024212422242324242425242624272428242924302431243224332434243524362437243824392440244124422443244424452446244724482449245024512452245324542455245624572458245924602461246224632464246524662467246824692470247124722473247424752476247724782479248024812482248324842485248624872488248924902491249224932494249524962497249824992500250125022503250425052506250725082509251025112512251325142515251625172518251925202521252225232524252525262527252825292530253125322533253425352536253725382539254025412542254325442545254625472548254925502551255225532554255525562557255825592560256125622563256425652566256725682569257025712572257325742575257625772578257925802581258225832584258525862587258825892590259125922593259425952596259725982599260026012602260326042605260626072608260926102611261226132614261526162617261826192620262126222623262426252626262726282629263026312632263326342635263626372638263926402641264226432644264526462647264826492650265126522653265426552656265726582659266026612662266326642665266626672668266926702671267226732674267526762677267826792680268126822683268426852686268726882689269026912692269326942695269626972698269927002701270227032704270527062707270827092710271127122713271427152716271727182719272027212722272327242725272627272728272927302731273227332734273527362737273827392740274127422743274427452746274727482749275027512752275327542755275627572758275927602761276227632764276527662767276827692770277127722773277427752776277727782779278027812782278327842785278627872788278927902791279227932794279527962797279827992800280128022803280428052806280728082809281028112812281328142815281628172818281928202821282228232824282528262827282828292830283128322833283428352836283728382839284028412842284328442845284628472848284928502851285228532854285528562857285828592860286128622863286428652866286728682869287028712872287328742875287628772878287928802881288228832884288528862887288828892890289128922893289428952896289728982899290029012902290329042905290629072908290929102911291229132914291529162917291829192920292129222923292429252926292729282929293029312932293329342935293629372938293929402941294229432944294529462947294829492950295129522953295429552956295729582959296029612962296329642965296629672968296929702971297229732974297529762977297829792980298129822983298429852986298729882989299029912992299329942995299629972998299930003001300230033004300530063007300830093010301130123013301430153016301730183019302030213022302330243025302630273028302930303031303230333034303530363037303830393040304130423043304430453046304730483049305030513052305330543055305630573058305930603061306230633064306530663067306830693070307130723073307430753076307730783079308030813082308330843085308630873088308930903091309230933094309530963097309830993100310131023103310431053106310731083109311031113112311331143115311631173118311931203121312231233124312531263127312831293130313131323133313431353136313731383139314031413142314331443145314631473148314931503151315231533154315531563157315831593160316131623163316431653166316731683169317031713172317331743175317631773178317931803181318231833184318531863187318831893190319131923193319431953196319731983199320032013202320332043205320632073208cur_ins = 222cur_block = 22-------------------|fifo |lru |opt |-------------------|22 |22 |22 ||-1 |-1 |-1 ||-1 |-1 |-1 ||-1 |-1 |-1 |-------------------cur_ins = 223cur_block = 22-------------------|fifo |lru |opt |-------------------|22 |22 |22 ||-1 |-1 |-1 ||-1 |-1 |-1 ||-1 |-1 |-1 |-------------------cur_ins = 179cur_block = 17-------------------|fifo |lru |opt |-------------------|22 |17 |22 ||17 |22 |17 ||-1 |-1 |-1 ||-1 |-1 |-1 |-------------------cur_ins = 180cur_block = 18-------------------|fifo |lru |opt |-------------------|22 |18 |22 ||17 |17 |17 ||18 |22 |18 ||-1 |-1 |-1 |-------------------cur_ins = 255cur_block = 25-------------------|fifo |lru |opt |-------------------|22 |25 |22 ||17 |18 |17 ||18 |17 |18 ||25 |22 |25 |-------------------cur_ins = 256cur_block = 25-------------------|fifo |lru |opt |-------------------|22 |25 |22 ||17 |18 |17 ||18 |17 |18 ||25 |22 |25 |-------------------cur_ins = 312cur_block = 31-------------------|fifo |lru |opt |-------------------|17 |31 |22 ||18 |25 |31 ||25 |18 |18 ||31 |17 |25 |-------------------cur_ins = 313cur_block = 31-------------------|fifo |lru |opt |-------------------|17 |31 |22 ||18 |25 |31 ||25 |18 |18 ||31 |17 |25 |-------------------cur_ins = 17cur_block = 1-------------------|fifo |lru |opt |-------------------|18 |1 |22 ||25 |31 |1 ||31 |25 |18 ||1 |18 |25 |-------------------cur_ins = 18cur_block = 1-------------------|fifo |lru |opt |-------------------|18 |1 |22 ||25 |31 |1 ||31 |25 |18 ||1 |18 |25 |-------------------cur_ins = 232cur_block = 23-------------------|fifo |lru |opt |-------------------|25 |23 |22 ||31 |1 |1 ||1 |31 |23 ||23 |25 |25 |-------------------cur_ins = 233cur_block = 23-------------------|fifo |lru |opt |-------------------|25 |23 |22 ||31 |1 |1 ||1 |31 |23 ||23 |25 |25 |-------------------cur_ins = 83cur_block = 8-------------------|fifo |lru |opt |-------------------|31 |8 |22 ||1 |23 |1 ||23 |1 |8 ||8 |31 |25 |-------------------cur_ins = 84cur_block = 8-------------------|fifo |lru |opt |-------------------|31 |8 |22 ||1 |23 |1 ||23 |1 |8 ||8 |31 |25 |-------------------cur_ins = 23cur_block = 2-------------------|fifo |lru |opt |-------------------|1 |2 |22 ||23 |8 |1 ||8 |23 |2 ||2 |1 |25 |-------------------cur_ins = 24cur_block = 2-------------------|fifo |lru |opt |-------------------|1 |2 |22 ||23 |8 |1 ||8 |23 |2 ||2 |1 |25 |-------------------cur_ins = 196cur_block = 19-------------------|fifo |lru |opt |-------------------|23 |19 |22 ||8 |2 |1 ||2 |8 |2 ||19 |23 |19 |-------------------cur_ins = 197cur_block = 19-------------------|fifo |lru |opt |-------------------|23 |19 |22 ||8 |2 |1 ||2 |8 |2 ||19 |23 |19 |-------------------cur_ins = 212cur_block = 21-------------------|fifo |lru |opt |-------------------|8 |21 |21 ||2 |19 |1 ||19 |2 |2 ||21 |8 |19 |-------------------cur_ins = 213cur_block = 21-------------------|fifo |lru |opt |-------------------|8 |21 |21 ||2 |19 |1 ||19 |2 |2 ||21 |8 |19 |-------------------cur_ins = 45cur_block = 4-------------------|fifo |lru |opt |-------------------|2 |4 |4 ||19 |21 |1 ||21 |19 |2 ||4 |2 |19 |-------------------cur_ins = 46cur_block = 4-------------------|fifo |lru |opt |-------------------|2 |4 |4 ||19 |21 |1 ||21 |19 |2 ||4 |2 |19 |-------------------cur_ins = 193cur_block = 19-------------------|fifo |lru |opt |-------------------|2 |19 |4 ||19 |4 |1 ||21 |21 |2 ||4 |2 |19 |-------------------cur_ins = 194cur_block = 19-------------------|fifo |lru |opt |-------------------|2 |19 |4 ||19 |4 |1 ||21 |21 |2 ||4 |2 |19 |-------------------cur_ins = 157cur_block = 15-------------------|fifo |lru |opt |-------------------|19 |15 |15 ||21 |19 |1 ||4 |4 |2 ||15 |21 |19 |-------------------cur_ins = 158cur_block = 15-------------------|fifo |lru |opt |-------------------|19 |15 |15 ||21 |19 |1 ||4 |4 |2 ||15 |21 |19 |-------------------cur_ins = 31cur_block = 3-------------------|fifo |lru |opt |-------------------|21 |3 |3 ||4 |15 |1 ||15 |19 |2 ||3 |4 |19 |-------------------cur_ins = 32cur_block = 3-------------------|fifo |lru |opt |-------------------|21 |3 |3 ||4 |15 |1 ||15 |19 |2 ||3 |4 |19 |-------------------cur_ins = 142cur_block = 14-------------------|fifo |lru |opt |-------------------|4 |14 |14 ||15 |3 |1 ||3 |15 |2 ||14 |19 |19 |-------------------cur_ins = 143cur_block = 14-------------------|fifo |lru |opt |-------------------|4 |14 |14 ||15 |3 |1 ||3 |15 |2 ||14 |19 |19 |-------------------cur_ins = 190cur_block = 19-------------------|fifo |lru |opt |-------------------|15 |19 |14 ||3 |14 |1 ||14 |3 |2 ||19 |15 |19 |-------------------cur_ins = 191cur_block = 19-------------------|fifo |lru |opt |-------------------|15 |19 |14 ||3 |14 |1 ||14 |3 |2 ||19 |15 |19 |-------------------cur_ins = 115cur_block = 11-------------------|fifo |lru |opt |-------------------|3 |11 |11 ||14 |19 |1 ||19 |14 |2 ||11 |3 |19 |-------------------cur_ins = 116cur_block = 11-------------------|fifo |lru |opt |-------------------|3 |11 |11 ||14 |19 |1 ||19 |14 |2 ||11 |3 |19 |-------------------cur_ins = 192cur_block = 19-------------------|fifo |lru |opt |-------------------|3 |19 |11 ||14 |11 |1 ||19 |14 |2 ||11 |3 |19 |-------------------cur_ins = 193cur_block = 19-------------------|fifo |lru |opt |-------------------|3 |19 |11 ||14 |11 |1 ||19 |14 |2 ||11 |3 |19 |-------------------cur_ins = 271cur_block = 27-------------------|fifo |lru |opt |-------------------|14 |27 |11 ||19 |19 |1 ||11 |11 |2 ||27 |14 |27 |-------------------cur_ins = 272cur_block = 27-------------------|fifo |lru |opt |-------------------|14 |27 |11 ||19 |19 |1 ||11 |11 |2 ||27 |14 |27 |-------------------cur_ins = 27cur_block = 2-------------------|fifo |lru |opt |-------------------|19 |2 |11 ||11 |27 |1 ||27 |19 |2 ||2 |11 |27 |-------------------cur_ins = 28cur_block = 2-------------------|fifo |lru |opt |-------------------|19 |2 |11 ||11 |27 |1 ||27 |19 |2 ||2 |11 |27 |-------------------cur_ins = 264cur_block = 26-------------------|fifo |lru |opt |-------------------|11 |26 |11 ||27 |2 |1 ||2 |27 |2 ||26 |19 |26 |-------------------cur_ins = 265cur_block = 26-------------------|fifo |lru |opt |-------------------|11 |26 |11 ||27 |2 |1 ||2 |27 |2 ||26 |19 |26 |-------------------cur_ins = 9cur_block = 0-------------------|fifo |lru |opt |-------------------|27 |0 |11 ||2 |26 |1 ||26 |2 |0 ||0 |27 |26 |-------------------cur_ins = 10cur_block = 1-------------------|fifo |lru |opt |-------------------|2 |1 |11 ||26 |0 |1 ||0 |26 |0 ||1 |2 |26 |-------------------cur_ins = 4cur_block = 0-------------------|fifo |lru |opt |-------------------|2 |0 |11 ||26 |1 |1 ||0 |26 |0 ||1 |2 |26 |-------------------cur_ins = 5cur_block = 0-------------------|fifo |lru |opt |-------------------|2 |0 |11 ||26 |1 |1 ||0 |26 |0 ||1 |2 |26 |-------------------cur_ins = 219cur_block = 21-------------------|fifo |lru |opt |-------------------|26 |21 |11 ||0 |0 |1 ||1 |1 |21 ||21 |26 |26 |-------------------cur_ins = 220cur_block = 22-------------------|fifo |lru |opt |-------------------|0 |22 |11 ||1 |21 |1 ||21 |0 |22 ||22 |1 |26 |-------------------cur_ins = 122cur_block = 12-------------------|fifo |lru |opt |-------------------|1 |12 |11 ||21 |22 |1 ||22 |21 |12 ||12 |0 |26 |-------------------cur_ins = 123cur_block = 12-------------------|fifo |lru |opt |-------------------|1 |12 |11 ||21 |22 |1 ||22 |21 |12 ||12 |0 |26 |-------------------cur_ins = 121cur_block = 12-------------------|fifo |lru |opt |-------------------|1 |12 |11 ||21 |22 |1 ||22 |21 |12 ||12 |0 |26 |-------------------cur_ins = 122cur_block = 12-------------------|fifo |lru |opt |-------------------|1 |12 |11 ||21 |22 |1 ||22 |21 |12 ||12 |0 |26 |-------------------cur_ins = 295cur_block = 29-------------------|fifo |lru |opt |-------------------|21 |29 |11 ||22 |12 |1 ||12 |22 |29 ||29 |21 |26 |-------------------cur_ins = 296cur_block = 29-------------------|fifo |lru |opt |-------------------|21 |29 |11 ||22 |12 |1 ||12 |22 |29 ||29 |21 |26 |-------------------cur_ins = 158cur_block = 15-------------------|fifo |lru |opt |-------------------|22 |15 |11 ||12 |29 |1 ||29 |12 |15 ||15 |22 |26 |-------------------cur_ins = 159cur_block = 15-------------------|fifo |lru |opt |-------------------|22 |15 |11 ||12 |29 |1 ||29 |12 |15 ||15 |22 |26 |-------------------cur_ins = 15cur_block = 1-------------------|fifo |lru |opt |-------------------|12 |1 |11 ||29 |15 |1 ||15 |29 |15 ||1 |12 |26 |-------------------cur_ins = 16cur_block = 1-------------------|fifo |lru |opt |-------------------|12 |1 |11 ||29 |15 |1 ||15 |29 |15 ||1 |12 |26 |-------------------cur_ins = 53cur_block = 5-------------------|fifo |lru |opt |-------------------|29 |5 |11 ||15 |1 |1 ||1 |15 |5 ||5 |29 |26 |-------------------cur_ins = 54cur_block = 5-------------------|fifo |lru |opt |-------------------|29 |5 |11 ||15 |1 |1 ||1 |15 |5 ||5 |29 |26 |-------------------cur_ins = 161cur_block = 16-------------------|fifo |lru |opt |-------------------|15 |16 |11 ||1 |5 |16 ||5 |1 |5 ||16 |15 |26 |-------------------cur_ins = 162cur_block = 16-------------------|fifo |lru |opt |-------------------|15 |16 |11 ||1 |5 |16 ||5 |1 |5 ||16 |15 |26 |-------------------cur_ins = 97cur_block = 9-------------------|fifo |lru |opt |-------------------|1 |9 |11 ||5 |16 |9 ||16 |5 |5 ||9 |1 |26 |-------------------cur_ins = 98cur_block = 9-------------------|fifo |lru |opt |-------------------|1 |9 |11 ||5 |16 |9 ||16 |5 |5 ||9 |1 |26 |-------------------cur_ins = 131cur_block = 13-------------------|fifo |lru |opt |-------------------|5 |13 |11 ||16 |9 |13 ||9 |16 |5 ||13 |5 |26 |-------------------cur_ins = 132cur_block = 13-------------------|fifo |lru |opt |-------------------|5 |13 |11 ||16 |9 |13 ||9 |16 |5 ||13 |5 |26 |-------------------cur_ins = 259cur_block = 25-------------------|fifo |lru |opt |-------------------|16 |25 |11 ||9 |13 |25 ||13 |9 |5 ||25 |16 |26 |-------------------cur_ins = 260cur_block = 26-------------------|fifo |lru |opt |-------------------|9 |26 |11 ||13 |25 |25 ||25 |13 |5 ||26 |9 |26 |-------------------cur_ins = 241cur_block = 24-------------------|fifo |lru |opt |-------------------|13 |24 |11 ||25 |26 |25 ||26 |25 |5 ||24 |13 |24 |-------------------cur_ins = 242cur_block = 24-------------------|fifo |lru |opt |-------------------|13 |24 |11 ||25 |26 |25 ||26 |25 |5 ||24 |13 |24 |-------------------cur_ins = 256cur_block = 25-------------------|fifo |lru |opt |-------------------|13 |25 |11 ||25 |24 |25 ||26 |26 |5 ||24 |13 |24 |-------------------cur_ins = 257cur_block = 25-------------------|fifo |lru |opt |-------------------|13 |25 |11 ||25 |24 |25 ||26 |26 |5 ||24 |13 |24 |-------------------cur_ins = 114cur_block = 11-------------------|fifo |lru |opt |-------------------|25 |11 |11 ||26 |25 |25 ||24 |24 |5 ||11 |26 |24 |-------------------cur_ins = 115cur_block = 11-------------------|fifo |lru |opt |-------------------|25 |11 |11 ||26 |25 |25 ||24 |24 |5 ||11 |26 |24 |-------------------cur_ins = 35cur_block = 3-------------------|fifo |lru |opt |-------------------|26 |3 |3 ||24 |11 |25 ||11 |25 |5 ||3 |24 |24 |-------------------cur_ins = 36cur_block = 3-------------------|fifo |lru |opt |-------------------|26 |3 |3 ||24 |11 |25 ||11 |25 |5 ||3 |24 |24 |-------------------cur_ins = 124cur_block = 12-------------------|fifo |lru |opt |-------------------|24 |12 |3 ||11 |3 |12 ||3 |11 |5 ||12 |25 |24 |-------------------cur_ins = 125cur_block = 12-------------------|fifo |lru |opt |-------------------|24 |12 |3 ||11 |3 |12 ||3 |11 |5 ||12 |25 |24 |-------------------cur_ins = 53cur_block = 5-------------------|fifo |lru |opt |-------------------|11 |5 |3 ||3 |12 |12 ||12 |3 |5 ||5 |11 |24 |-------------------cur_ins = 54cur_block = 5-------------------|fifo |lru |opt |-------------------|11 |5 |3 ||3 |12 |12 ||12 |3 |5 ||5 |11 |24 |-------------------cur_ins = 8cur_block = 0-------------------|fifo |lru |opt |-------------------|3 |0 |3 ||12 |5 |0 ||5 |12 |5 ||0 |3 |24 |-------------------cur_ins = 9cur_block = 0-------------------|fifo |lru |opt |-------------------|3 |0 |3 ||12 |5 |0 ||5 |12 |5 ||0 |3 |24 |-------------------cur_ins = 184cur_block = 18-------------------|fifo |lru |opt |-------------------|12 |18 |3 ||5 |0 |18 ||0 |5 |5 ||18 |12 |24 |-------------------cur_ins = 185cur_block = 18-------------------|fifo |lru |opt |-------------------|12 |18 |3 ||5 |0 |18 ||0 |5 |5 ||18 |12 |24 |-------------------cur_ins = 240cur_block = 24-------------------|fifo |lru |opt |-------------------|5 |24 |3 ||0 |18 |18 ||18 |0 |5 ||24 |5 |24 |-------------------cur_ins = 241cur_block = 24-------------------|fifo |lru |opt |-------------------|5 |24 |3 ||0 |18 |18 ||18 |0 |5 ||24 |5 |24 |-------------------cur_ins = 28cur_block = 2-------------------|fifo |lru |opt |-------------------|0 |2 |3 ||18 |24 |2 ||24 |18 |5 ||2 |0 |24 |-------------------cur_ins = 29cur_block = 2-------------------|fifo |lru |opt |-------------------|0 |2 |3 ||18 |24 |2 ||24 |18 |5 ||2 |0 |24 |-------------------cur_ins = 224cur_block = 22-------------------|fifo |lru |opt |-------------------|18 |22 |3 ||24 |2 |2 ||2 |24 |5 ||22 |18 |22 |-------------------cur_ins = 225cur_block = 22-------------------|fifo |lru |opt |-------------------|18 |22 |3 ||24 |2 |2 ||2 |24 |5 ||22 |18 |22 |-------------------cur_ins = 92cur_block = 9-------------------|fifo |lru |opt |-------------------|24 |9 |3 ||2 |22 |2 ||22 |2 |5 ||9 |24 |9 |-------------------cur_ins = 93cur_block = 9-------------------|fifo |lru |opt |-------------------|24 |9 |3 ||2 |22 |2 ||22 |2 |5 ||9 |24 |9 |-------------------cur_ins = 49cur_block = 4-------------------|fifo |lru |opt |-------------------|2 |4 |3 ||22 |9 |2 ||9 |22 |5 ||4 |2 |4 |-------------------cur_ins = 50cur_block = 5-------------------|fifo |lru |opt |-------------------|22 |5 |3 ||9 |4 |2 ||4 |9 |5 ||5 |22 |4 |-------------------cur_ins = 279cur_block = 27-------------------|fifo |lru |opt |-------------------|9 |27 |3 ||4 |5 |2 ||5 |4 |5 ||27 |9 |27 |-------------------cur_ins = 280cur_block = 28-------------------|fifo |lru |opt |-------------------|4 |28 |3 ||5 |27 |2 ||27 |5 |28 ||28 |4 |27 |-------------------cur_ins = 34cur_block = 3-------------------|fifo |lru |opt |-------------------|5 |3 |3 ||27 |28 |2 ||28 |27 |28 ||3 |5 |27 |-------------------cur_ins = 35cur_block = 3-------------------|fifo |lru |opt |-------------------|5 |3 |3 ||27 |28 |2 ||28 |27 |28 ||3 |5 |27 |-------------------cur_ins = 26cur_block = 2-------------------|fifo |lru |opt |-------------------|27 |2 |3 ||28 |3 |2 ||3 |28 |28 ||2 |27 |27 |-------------------cur_ins = 27cur_block = 2-------------------|fifo |lru |opt |-------------------|27 |2 |3 ||28 |3 |2 ||3 |28 |28 ||2 |27 |27 |-------------------cur_ins = 239cur_block = 23-------------------|fifo |lru |opt |-------------------|28 |23 |3 ||3 |2 |2 ||2 |3 |23 ||23 |28 |27 |-------------------cur_ins = 240cur_block = 24-------------------|fifo |lru |opt |-------------------|3 |24 |24 ||2 |23 |2 ||23 |2 |23 ||24 |3 |27 |-------------------cur_ins = 270cur_block = 27-------------------|fifo |lru |opt |-------------------|2 |27 |24 ||23 |24 |2 ||24 |23 |23 ||27 |2 |27 |-------------------cur_ins = 271cur_block = 27-------------------|fifo |lru |opt |-------------------|2 |27 |24 ||23 |24 |2 ||24 |23 |23 ||27 |2 |27 |-------------------cur_ins = 229cur_block = 22-------------------|fifo |lru |opt |-------------------|23 |22 |24 ||24 |27 |2 ||27 |24 |23 ||22 |23 |22 |-------------------cur_ins = 230cur_block = 23-------------------|fifo |lru |opt |-------------------|23 |23 |24 ||24 |22 |2 ||27 |27 |23 ||22 |24 |22 |-------------------cur_ins = 315cur_block = 31-------------------|fifo |lru |opt |-------------------|24 |31 |24 ||27 |23 |2 ||22 |22 |23 ||31 |27 |31 |-------------------cur_ins = 316cur_block = 31-------------------|fifo |lru |opt |-------------------|24 |31 |24 ||27 |23 |2 ||22 |22 |23 ||31 |27 |31 |-------------------cur_ins = 160cur_block = 16-------------------|fifo |lru |opt |-------------------|27 |16 |24 ||22 |31 |2 ||31 |23 |16 ||16 |22 |31 |-------------------cur_ins = 161cur_block = 16-------------------|fifo |lru |opt |-------------------|27 |16 |24 ||22 |31 |2 ||31 |23 |16 ||16 |22 |31 |-------------------cur_ins = 8cur_block = 0-------------------|fifo |lru |opt |-------------------|22 |0 |24 ||31 |16 |2 ||16 |31 |0 ||0 |23 |31 |-------------------cur_ins = 9cur_block = 0-------------------|fifo |lru |opt |-------------------|22 |0 |24 ||31 |16 |2 ||16 |31 |0 ||0 |23 |31 |-------------------cur_ins = 242cur_block = 24-------------------|fifo |lru |opt |-------------------|31 |24 |24 ||16 |0 |2 ||0 |16 |0 ||24 |31 |31 |-------------------cur_ins = 243cur_block = 24-------------------|fifo |lru |opt |-------------------|31 |24 |24 ||16 |0 |2 ||0 |16 |0 ||24 |31 |31 |-------------------cur_ins = 216cur_block = 21-------------------|fifo |lru |opt |-------------------|16 |21 |24 ||0 |24 |21 ||24 |0 |0 ||21 |16 |31 |-------------------cur_ins = 217cur_block = 21-------------------|fifo |lru |opt |-------------------|16 |21 |24 ||0 |24 |21 ||24 |0 |0 ||21 |16 |31 |-------------------cur_ins = 2cur_block = 0-------------------|fifo |lru |opt |-------------------|16 |0 |24 ||0 |21 |21 ||24 |24 |0 ||21 |16 |31 |-------------------cur_ins = 3cur_block = 0-------------------|fifo |lru |opt |-------------------|16 |0 |24 ||0 |21 |21 ||24 |24 |0 ||21 |16 |31 |-------------------cur_ins = 268cur_block = 26-------------------|fifo |lru |opt |-------------------|0 |26 |24 ||24 |0 |21 ||21 |21 |26 ||26 |24 |31 |-------------------cur_ins = 269cur_block = 26-------------------|fifo |lru |opt |-------------------|0 |26 |24 ||24 |0 |21 ||21 |21 |26 ||26 |24 |31 |-------------------cur_ins = 250cur_block = 25-------------------|fifo |lru |opt |-------------------|24 |25 |24 ||21 |26 |21 ||26 |0 |25 ||25 |21 |31 |-------------------cur_ins = 251cur_block = 25-------------------|fifo |lru |opt |-------------------|24 |25 |24 ||21 |26 |21 ||26 |0 |25 ||25 |21 |31 |-------------------cur_ins = 132cur_block = 13-------------------|fifo |lru |opt |-------------------|21 |13 |24 ||26 |25 |21 ||25 |26 |13 ||13 |0 |31 |-------------------cur_ins = 133cur_block = 13-------------------|fifo |lru |opt |-------------------|21 |13 |24 ||26 |25 |21 ||25 |26 |13 ||13 |0 |31 |-------------------cur_ins = 144cur_block = 14-------------------|fifo |lru |opt |-------------------|26 |14 |24 ||25 |13 |21 ||13 |25 |14 ||14 |26 |31 |-------------------cur_ins = 145cur_block = 14-------------------|fifo |lru |opt |-------------------|26 |14 |24 ||25 |13 |21 ||13 |25 |14 ||14 |26 |31 |-------------------cur_ins = 243cur_block = 24-------------------|fifo |lru |opt |-------------------|25 |24 |24 ||13 |14 |21 ||14 |13 |14 ||24 |25 |31 |-------------------cur_ins = 244cur_block = 24-------------------|fifo |lru |opt |-------------------|25 |24 |24 ||13 |14 |21 ||14 |13 |14 ||24 |25 |31 |-------------------cur_ins = 173cur_block = 17-------------------|fifo |lru |opt |-------------------|13 |17 |24 ||14 |24 |21 ||24 |14 |17 ||17 |13 |31 |-------------------cur_ins = 174cur_block = 17-------------------|fifo |lru |opt |-------------------|13 |17 |24 ||14 |24 |21 ||24 |14 |17 ||17 |13 |31 |-------------------cur_ins = 178cur_block = 17-------------------|fifo |lru |opt |-------------------|13 |17 |24 ||14 |24 |21 ||24 |14 |17 ||17 |13 |31 |-------------------cur_ins = 179cur_block = 17-------------------|fifo |lru |opt |-------------------|13 |17 |24 ||14 |24 |21 ||24 |14 |17 ||17 |13 |31 |-------------------cur_ins = 185cur_block = 18-------------------|fifo |lru |opt |-------------------|14 |18 |24 ||24 |17 |21 ||17 |24 |18 ||18 |14 |31 |-------------------cur_ins = 186cur_block = 18-------------------|fifo |lru |opt |-------------------|14 |18 |24 ||24 |17 |21 ||17 |24 |18 ||18 |14 |31 |-------------------cur_ins = 181cur_block = 18-------------------|fifo |lru |opt |-------------------|14 |18 |24 ||24 |17 |21 ||17 |24 |18 ||18 |14 |31 |-------------------cur_ins = 182cur_block = 18-------------------|fifo |lru |opt |-------------------|14 |18 |24 ||24 |17 |21 ||17 |24 |18 ||18 |14 |31 |-------------------cur_ins = 296cur_block = 29-------------------|fifo |lru |opt |-------------------|24 |29 |24 ||17 |18 |21 ||18 |17 |29 ||29 |24 |31 |-------------------cur_ins = 297cur_block = 29-------------------|fifo |lru |opt |-------------------|24 |29 |24 ||17 |18 |21 ||18 |17 |29 ||29 |24 |31 |-------------------cur_ins = 319cur_block = 31-------------------|fifo |lru |opt |-------------------|17 |31 |24 ||18 |29 |21 ||29 |18 |29 ||31 |17 |31 |-------------------cur_ins = 319cur_block = 31-------------------|fifo |lru |opt |-------------------|17 |31 |24 ||18 |29 |21 ||29 |18 |29 ||31 |17 |31 |-------------------cur_ins = 191cur_block = 19-------------------|fifo |lru |opt |-------------------|18 |19 |24 ||29 |31 |21 ||31 |29 |19 ||19 |18 |31 |-------------------cur_ins = 192cur_block = 19-------------------|fifo |lru |opt |-------------------|18 |19 |24 ||29 |31 |21 ||31 |29 |19 ||19 |18 |31 |-------------------cur_ins = 212cur_block = 21-------------------|fifo |lru |opt |-------------------|29 |21 |24 ||31 |19 |21 ||19 |31 |19 ||21 |29 |31 |-------------------cur_ins = 213cur_block = 21-------------------|fifo |lru |opt |-------------------|29 |21 |24 ||31 |19 |21 ||19 |31 |19 ||21 |29 |31 |-------------------cur_ins = 52cur_block = 5-------------------|fifo |lru |opt |-------------------|31 |5 |24 ||19 |21 |5 ||21 |19 |19 ||5 |31 |31 |-------------------cur_ins = 53cur_block = 5-------------------|fifo |lru |opt |-------------------|31 |5 |24 ||19 |21 |5 ||21 |19 |19 ||5 |31 |31 |-------------------cur_ins = 12cur_block = 1-------------------|fifo |lru |opt |-------------------|19 |1 |1 ||21 |5 |5 ||5 |21 |19 ||1 |19 |31 |-------------------cur_ins = 13cur_block = 1-------------------|fifo |lru |opt |-------------------|19 |1 |1 ||21 |5 |5 ||5 |21 |19 ||1 |19 |31 |-------------------cur_ins = 312cur_block = 31-------------------|fifo |lru |opt |-------------------|21 |31 |1 ||5 |1 |5 ||1 |5 |19 ||31 |21 |31 |-------------------cur_ins = 313cur_block = 31-------------------|fifo |lru |opt |-------------------|21 |31 |1 ||5 |1 |5 ||1 |5 |19 ||31 |21 |31 |-------------------cur_ins = 313cur_block = 31-------------------|fifo |lru |opt |-------------------|21 |31 |1 ||5 |1 |5 ||1 |5 |19 ||31 |21 |31 |-------------------cur_ins = 314cur_block = 31-------------------|fifo |lru |opt |-------------------|21 |31 |1 ||5 |1 |5 ||1 |5 |19 ||31 |21 |31 |-------------------cur_ins = 73cur_block = 7-------------------|fifo |lru |opt |-------------------|5 |7 |1 ||1 |31 |5 ||31 |1 |19 ||7 |5 |7 |-------------------cur_ins = 74cur_block = 7-------------------|fifo |lru |opt |-------------------|5 |7 |1 ||1 |31 |5 ||31 |1 |19 ||7 |5 |7 |-------------------cur_ins = 195cur_block = 19-------------------|fifo |lru |opt |-------------------|1 |19 |1 ||31 |7 |5 ||7 |31 |19 ||19 |1 |7 |-------------------cur_ins = 196cur_block = 19-------------------|fifo |lru |opt |-------------------|1 |19 |1 ||31 |7 |5 ||7 |31 |19 ||19 |1 |7 |-------------------cur_ins = 73cur_block = 7-------------------|fifo |lru |opt |-------------------|1 |7 |1 ||31 |19 |5 ||7 |31 |19 ||19 |1 |7 |-------------------cur_ins = 74cur_block = 7-------------------|fifo |lru |opt |-------------------|1 |7 |1 ||31 |19 |5 ||7 |31 |19 ||19 |1 |7 |-------------------cur_ins = 17cur_block = 1-------------------|fifo |lru |opt |-------------------|1 |1 |1 ||31 |7 |5 ||7 |19 |19 ||19 |31 |7 |-------------------cur_ins = 18cur_block = 1-------------------|fifo |lru |opt |-------------------|1 |1 |1 ||31 |7 |5 ||7 |19 |19 ||19 |31 |7 |-------------------cur_ins = 27cur_block = 2-------------------|fifo |lru |opt |-------------------|31 |2 |1 ||7 |1 |5 ||19 |7 |19 ||2 |19 |2 |-------------------cur_ins = 28cur_block = 2-------------------|fifo |lru |opt |-------------------|31 |2 |1 ||7 |1 |5 ||19 |7 |19 ||2 |19 |2 |-------------------cur_ins = 237cur_block = 23-------------------|fifo |lru |opt |-------------------|7 |23 |1 ||19 |2 |5 ||2 |1 |23 ||23 |7 |2 |-------------------cur_ins = 238cur_block = 23-------------------|fifo |lru |opt |-------------------|7 |23 |1 ||19 |2 |5 ||2 |1 |23 ||23 |7 |2 |-------------------cur_ins = 89cur_block = 8-------------------|fifo |lru |opt |-------------------|19 |8 |1 ||2 |23 |5 ||23 |2 |8 ||8 |1 |2 |-------------------cur_ins = 90cur_block = 9-------------------|fifo |lru |opt |-------------------|2 |9 |1 ||23 |8 |5 ||8 |23 |9 ||9 |2 |2 |-------------------cur_ins = 277cur_block = 27-------------------|fifo |lru |opt |-------------------|23 |27 |1 ||8 |9 |5 ||9 |8 |27 ||27 |23 |2 |-------------------cur_ins = 278cur_block = 27-------------------|fifo |lru |opt |-------------------|23 |27 |1 ||8 |9 |5 ||9 |8 |27 ||27 |23 |2 |-------------------cur_ins = 130cur_block = 13-------------------|fifo |lru |opt |-------------------|8 |13 |1 ||9 |27 |5 ||27 |9 |27 ||13 |8 |13 |-------------------cur_ins = 131cur_block = 13-------------------|fifo |lru |opt |-------------------|8 |13 |1 ||9 |27 |5 ||27 |9 |27 ||13 |8 |13 |-------------------cur_ins = 11cur_block = 1-------------------|fifo |lru |opt |-------------------|9 |1 |1 ||27 |13 |5 ||13 |27 |27 ||1 |9 |13 |-------------------cur_ins = 12cur_block = 1-------------------|fifo |lru |opt |-------------------|9 |1 |1 ||27 |13 |5 ||13 |27 |27 ||1 |9 |13 |-------------------cur_ins = 57cur_block = 5-------------------|fifo |lru |opt |-------------------|27 |5 |1 ||13 |1 |5 ||1 |13 |27 ||5 |27 |13 |-------------------cur_ins = 58cur_block = 5-------------------|fifo |lru |opt |-------------------|27 |5 |1 ||13 |1 |5 ||1 |13 |27 ||5 |27 |13 |-------------------cur_ins = 267cur_block = 26-------------------|fifo |lru |opt |-------------------|13 |26 |1 ||1 |5 |5 ||5 |1 |27 ||26 |13 |26 |-------------------cur_ins = 268cur_block = 26-------------------|fifo |lru |opt |-------------------|13 |26 |1 ||1 |5 |5 ||5 |1 |27 ||26 |13 |26 |-------------------cur_ins = 242cur_block = 24-------------------|fifo |lru |opt |-------------------|1 |24 |24 ||5 |26 |5 ||26 |5 |27 ||24 |1 |26 |-------------------cur_ins = 243cur_block = 24-------------------|fifo |lru |opt |-------------------|1 |24 |24 ||5 |26 |5 ||26 |5 |27 ||24 |1 |26 |-------------------cur_ins = 276cur_block = 27-------------------|fifo |lru |opt |-------------------|5 |27 |24 ||26 |24 |5 ||24 |26 |27 ||27 |5 |26 |-------------------cur_ins = 277cur_block = 27-------------------|fifo |lru |opt |-------------------|5 |27 |24 ||26 |24 |5 ||24 |26 |27 ||27 |5 |26 |-------------------cur_ins = 43cur_block = 4-------------------|fifo |lru |opt |-------------------|26 |4 |24 ||24 |27 |5 ||27 |24 |4 ||4 |26 |26 |-------------------cur_ins = 44cur_block = 4-------------------|fifo |lru |opt |-------------------|26 |4 |24 ||24 |27 |5 ||27 |24 |4 ||4 |26 |26 |-------------------cur_ins = 31cur_block = 3-------------------|fifo |lru |opt |-------------------|24 |3 |3 ||27 |4 |5 ||4 |27 |4 ||3 |24 |26 |-------------------cur_ins = 32cur_block = 3-------------------|fifo |lru |opt |-------------------|24 |3 |3 ||27 |4 |5 ||4 |27 |4 ||3 |24 |26 |-------------------cur_ins = 140cur_block = 14-------------------|fifo |lru |opt |-------------------|27 |14 |3 ||4 |3 |14 ||3 |4 |4 ||14 |27 |26 |-------------------cur_ins = 141cur_block = 14-------------------|fifo |lru |opt |-------------------|27 |14 |3 ||4 |3 |14 ||3 |4 |4 ||14 |27 |26 |-------------------cur_ins = 315cur_block = 31-------------------|fifo |lru |opt |-------------------|4 |31 |3 ||3 |14 |14 ||14 |3 |31 ||31 |4 |26 |-------------------cur_ins = 316cur_block = 31-------------------|fifo |lru |opt |-------------------|4 |31 |3 ||3 |14 |14 ||14 |3 |31 ||31 |4 |26 |-------------------cur_ins = 187cur_block = 18-------------------|fifo |lru |opt |-------------------|3 |18 |3 ||14 |31 |14 ||31 |14 |18 ||18 |3 |26 |-------------------cur_ins = 188cur_block = 18-------------------|fifo |lru |opt |-------------------|3 |18 |3 ||14 |31 |14 ||31 |14 |18 ||18 |3 |26 |-------------------cur_ins = 221cur_block = 22-------------------|fifo |lru |opt |-------------------|14 |22 |3 ||31 |18 |14 ||18 |31 |22 ||22 |14 |26 |-------------------cur_ins = 222cur_block = 22-------------------|fifo |lru |opt |-------------------|14 |22 |3 ||31 |18 |14 ||18 |31 |22 ||22 |14 |26 |-------------------cur_ins = 301cur_block = 30-------------------|fifo |lru |opt |-------------------|31 |30 |3 ||18 |22 |30 ||22 |18 |22 ||30 |31 |26 |-------------------cur_ins = 302cur_block = 30-------------------|fifo |lru |opt |-------------------|31 |30 |3 ||18 |22 |30 ||22 |18 |22 ||30 |31 |26 |-------------------cur_ins = 28cur_block = 2-------------------|fifo |lru |opt |-------------------|18 |2 |3 ||22 |30 |2 ||30 |22 |22 ||2 |18 |26 |-------------------cur_ins = 29cur_block = 2-------------------|fifo |lru |opt |-------------------|18 |2 |3 ||22 |30 |2 ||30 |22 |22 ||2 |18 |26 |-------------------cur_ins = 198cur_block = 19-------------------|fifo |lru |opt |-------------------|22 |19 |3 ||30 |2 |19 ||2 |30 |22 ||19 |22 |26 |-------------------cur_ins = 199cur_block = 19-------------------|fifo |lru |opt |-------------------|22 |19 |3 ||30 |2 |19 ||2 |30 |22 ||19 |22 |26 |-------------------cur_ins = 128cur_block = 12-------------------|fifo |lru |opt |-------------------|30 |12 |3 ||2 |19 |12 ||19 |2 |22 ||12 |30 |26 |-------------------cur_ins = 129cur_block = 12-------------------|fifo |lru |opt |-------------------|30 |12 |3 ||2 |19 |12 ||19 |2 |22 ||12 |30 |26 |-------------------cur_ins = 117cur_block = 11-------------------|fifo |lru |opt |-------------------|2 |11 |3 ||19 |12 |11 ||12 |19 |22 ||11 |2 |26 |-------------------cur_ins = 118cur_block = 11-------------------|fifo |lru |opt |-------------------|2 |11 |3 ||19 |12 |11 ||12 |19 |22 ||11 |2 |26 |-------------------cur_ins = 262cur_block = 26-------------------|fifo |lru |opt |-------------------|19 |26 |3 ||12 |11 |11 ||11 |12 |22 ||26 |19 |26 |-------------------cur_ins = 263cur_block = 26-------------------|fifo |lru |opt |-------------------|19 |26 |3 ||12 |11 |11 ||11 |12 |22 ||26 |19 |26 |-------------------cur_ins = 223cur_block = 22-------------------|fifo |lru |opt |-------------------|12 |22 |3 ||11 |26 |11 ||26 |11 |22 ||22 |12 |26 |-------------------cur_ins = 224cur_block = 22-------------------|fifo |lru |opt |-------------------|12 |22 |3 ||11 |26 |11 ||26 |11 |22 ||22 |12 |26 |-------------------cur_ins = 35cur_block = 3-------------------|fifo |lru |opt |-------------------|11 |3 |3 ||26 |22 |11 ||22 |26 |22 ||3 |11 |26 |-------------------cur_ins = 36cur_block = 3-------------------|fifo |lru |opt |-------------------|11 |3 |3 ||26 |22 |11 ||22 |26 |22 ||3 |11 |26 |-------------------cur_ins = 140cur_block = 14-------------------|fifo |lru |opt |-------------------|26 |14 |3 ||22 |3 |11 ||3 |22 |14 ||14 |26 |26 |-------------------cur_ins = 141cur_block = 14-------------------|fifo |lru |opt |-------------------|26 |14 |3 ||22 |3 |11 ||3 |22 |14 ||14 |26 |26 |-------------------cur_ins = 210cur_block = 21-------------------|fifo |lru |opt |-------------------|22 |21 |21 ||3 |14 |11 ||14 |3 |14 ||21 |22 |26 |-------------------cur_ins = 211cur_block = 21-------------------|fifo |lru |opt |-------------------|22 |21 |21 ||3 |14 |11 ||14 |3 |14 ||21 |22 |26 |-------------------cur_ins = 40cur_block = 4-------------------|fifo |lru |opt |-------------------|3 |4 |21 ||14 |21 |11 ||21 |14 |14 ||4 |3 |4 |-------------------cur_ins = 41cur_block = 4-------------------|fifo |lru |opt |-------------------|3 |4 |21 ||14 |21 |11 ||21 |14 |14 ||4 |3 |4 |-------------------cur_ins = 128cur_block = 12-------------------|fifo |lru |opt |-------------------|14 |12 |12 ||21 |4 |11 ||4 |21 |14 ||12 |14 |4 |-------------------cur_ins = 129cur_block = 12-------------------|fifo |lru |opt |-------------------|14 |12 |12 ||21 |4 |11 ||4 |21 |14 ||12 |14 |4 |-------------------cur_ins = 86cur_block = 8-------------------|fifo |lru |opt |-------------------|21 |8 |8 ||4 |12 |11 ||12 |4 |14 ||8 |21 |4 |-------------------cur_ins = 87cur_block = 8-------------------|fifo |lru |opt |-------------------|21 |8 |8 ||4 |12 |11 ||12 |4 |14 ||8 |21 |4 |-------------------cur_ins = 40cur_block = 4-------------------|fifo |lru |opt |-------------------|21 |4 |8 ||4 |8 |11 ||12 |12 |14 ||8 |21 |4 |-------------------cur_ins = 41cur_block = 4-------------------|fifo |lru |opt |-------------------|21 |4 |8 ||4 |8 |11 ||12 |12 |14 ||8 |21 |4 |-------------------cur_ins = 101cur_block = 10-------------------|fifo |lru |opt |-------------------|4 |10 |10 ||12 |4 |11 ||8 |8 |14 ||10 |12 |4 |-------------------cur_ins = 102cur_block = 10-------------------|fifo |lru |opt |-------------------|4 |10 |10 ||12 |4 |11 ||8 |8 |14 ||10 |12 |4 |-------------------cur_ins = 109cur_block = 10-------------------|fifo |lru |opt |-------------------|4 |10 |10 ||12 |4 |11 ||8 |8 |14 ||10 |12 |4 |-------------------cur_ins = 110cur_block = 11-------------------|fifo |lru |opt |-------------------|12 |11 |10 ||8 |10 |11 ||10 |4 |14 ||11 |8 |4 |-------------------cur_ins = 51cur_block = 5-------------------|fifo |lru |opt |-------------------|8 |5 |5 ||10 |11 |11 ||11 |10 |14 ||5 |4 |4 |-------------------cur_ins = 52cur_block = 5-------------------|fifo |lru |opt |-------------------|8 |5 |5 ||10 |11 |11 ||11 |10 |14 ||5 |4 |4 |-------------------cur_ins = 146cur_block = 14-------------------|fifo |lru |opt |-------------------|10 |14 |5 ||11 |5 |11 ||5 |11 |14 ||14 |10 |4 |-------------------cur_ins = 147cur_block = 14-------------------|fifo |lru |opt |-------------------|10 |14 |5 ||11 |5 |11 ||5 |11 |14 ||14 |10 |4 |-------------------cur_ins = 42cur_block = 4-------------------|fifo |lru |opt |-------------------|11 |4 |5 ||5 |14 |11 ||14 |5 |14 ||4 |11 |4 |-------------------cur_ins = 43cur_block = 4-------------------|fifo |lru |opt |-------------------|11 |4 |5 ||5 |14 |11 ||14 |5 |14 ||4 |11 |4 |-------------------cur_ins = 14cur_block = 1-------------------|fifo |lru |opt |-------------------|5 |1 |5 ||14 |4 |11 ||4 |14 |1 ||1 |5 |4 |-------------------cur_ins = 15cur_block = 1-------------------|fifo |lru |opt |-------------------|5 |1 |5 ||14 |4 |11 ||4 |14 |1 ||1 |5 |4 |-------------------cur_ins = 216cur_block = 21-------------------|fifo |lru |opt |-------------------|14 |21 |5 ||4 |1 |11 ||1 |4 |21 ||21 |14 |4 |-------------------cur_ins = 217cur_block = 21-------------------|fifo |lru |opt |-------------------|14 |21 |5 ||4 |1 |11 ||1 |4 |21 ||21 |14 |4 |-------------------cur_ins = 177cur_block = 17-------------------|fifo |lru |opt |-------------------|4 |17 |5 ||1 |21 |11 ||21 |1 |17 ||17 |4 |4 |-------------------cur_ins = 178cur_block = 17-------------------|fifo |lru |opt |-------------------|4 |17 |5 ||1 |21 |11 ||21 |1 |17 ||17 |4 |4 |-------------------cur_ins = 49cur_block = 4-------------------|fifo |lru |opt |-------------------|4 |4 |5 ||1 |17 |11 ||21 |21 |17 ||17 |1 |4 |-------------------cur_ins = 50cur_block = 5-------------------|fifo |lru |opt |-------------------|1 |5 |5 ||21 |4 |11 ||17 |17 |17 ||5 |21 |4 |-------------------cur_ins = 110cur_block = 11-------------------|fifo |lru |opt |-------------------|21 |11 |5 ||17 |5 |11 ||5 |4 |17 ||11 |17 |4 |-------------------cur_ins = 111cur_block = 11-------------------|fifo |lru |opt |-------------------|21 |11 |5 ||17 |5 |11 ||5 |4 |17 ||11 |17 |4 |-------------------cur_ins = 300cur_block = 30-------------------|fifo |lru |opt |-------------------|17 |30 |5 ||5 |11 |11 ||11 |5 |30 ||30 |4 |4 |-------------------cur_ins = 301cur_block = 30-------------------|fifo |lru |opt |-------------------|17 |30 |5 ||5 |11 |11 ||11 |5 |30 ||30 |4 |4 |-------------------cur_ins = 49cur_block = 4-------------------|fifo |lru |opt |-------------------|5 |4 |5 ||11 |30 |11 ||30 |11 |30 ||4 |5 |4 |-------------------cur_ins = 50cur_block = 5-------------------|fifo |lru |opt |-------------------|5 |5 |5 ||11 |4 |11 ||30 |30 |30 ||4 |11 |4 |-------------------cur_ins = 263cur_block = 26-------------------|fifo |lru |opt |-------------------|11 |26 |26 ||30 |5 |11 ||4 |4 |30 ||26 |30 |4 |-------------------cur_ins = 264cur_block = 26-------------------|fifo |lru |opt |-------------------|11 |26 |26 ||30 |5 |11 ||4 |4 |30 ||26 |30 |4 |-------------------cur_ins = 21cur_block = 2-------------------|fifo |lru |opt |-------------------|30 |2 |26 ||4 |26 |11 ||26 |5 |2 ||2 |4 |4 |-------------------cur_ins = 22cur_block = 2-------------------|fifo |lru |opt |-------------------|30 |2 |26 ||4 |26 |11 ||26 |5 |2 ||2 |4 |4 |-------------------cur_ins = 9cur_block = 0-------------------|fifo |lru |opt |-------------------|4 |0 |26 ||26 |2 |11 ||2 |26 |0 ||0 |5 |4 |-------------------cur_ins = 10cur_block = 1-------------------|fifo |lru |opt |-------------------|26 |1 |26 ||2 |0 |11 ||0 |2 |0 ||1 |26 |1 |-------------------cur_ins = 194cur_block = 19-------------------|fifo |lru |opt |-------------------|2 |19 |26 ||0 |1 |11 ||1 |0 |0 ||19 |2 |19 |-------------------cur_ins = 195cur_block = 19-------------------|fifo |lru |opt |-------------------|2 |19 |26 ||0 |1 |11 ||1 |0 |0 ||19 |2 |19 |-------------------cur_ins = 192cur_block = 19-------------------|fifo |lru |opt |-------------------|2 |19 |26 ||0 |1 |11 ||1 |0 |0 ||19 |2 |19 |-------------------cur_ins = 193cur_block = 19-------------------|fifo |lru |opt |-------------------|2 |19 |26 ||0 |1 |11 ||1 |0 |0 ||19 |2 |19 |-------------------cur_ins = 159cur_block = 15-------------------|fifo |lru |opt |-------------------|0 |15 |26 ||1 |19 |11 ||19 |1 |0 ||15 |0 |15 |-------------------cur_ins = 160cur_block = 16-------------------|fifo |lru |opt |-------------------|1 |16 |26 ||19 |15 |11 ||15 |19 |0 ||16 |1 |16 |-------------------cur_ins = 244cur_block = 24-------------------|fifo |lru |opt |-------------------|19 |24 |26 ||15 |16 |11 ||16 |15 |0 ||24 |19 |24 |-------------------cur_ins = 245cur_block = 24-------------------|fifo |lru |opt |-------------------|19 |24 |26 ||15 |16 |11 ||16 |15 |0 ||24 |19 |24 |-------------------cur_ins = 128cur_block = 12-------------------|fifo |lru |opt |-------------------|15 |12 |26 ||16 |24 |11 ||24 |16 |0 ||12 |15 |12 |-------------------cur_ins = 129cur_block = 12-------------------|fifo |lru |opt |-------------------|15 |12 |26 ||16 |24 |11 ||24 |16 |0 ||12 |15 |12 |-------------------cur_ins = 35cur_block = 3-------------------|fifo |lru |opt |-------------------|16 |3 |26 ||24 |12 |11 ||12 |24 |0 ||3 |16 |3 |-------------------cur_ins = 36cur_block = 3-------------------|fifo |lru |opt |-------------------|16 |3 |26 ||24 |12 |11 ||12 |24 |0 ||3 |16 |3 |-------------------cur_ins = 114cur_block = 11-------------------|fifo |lru |opt |-------------------|24 |11 |26 ||12 |3 |11 ||3 |12 |0 ||11 |24 |3 |-------------------cur_ins = 115cur_block = 11-------------------|fifo |lru |opt |-------------------|24 |11 |26 ||12 |3 |11 ||3 |12 |0 ||11 |24 |3 |-------------------cur_ins = 237cur_block = 23-------------------|fifo |lru |opt |-------------------|12 |23 |26 ||3 |11 |11 ||11 |3 |0 ||23 |12 |23 |-------------------cur_ins = 238cur_block = 23-------------------|fifo |lru |opt |-------------------|12 |23 |26 ||3 |11 |11 ||11 |3 |0 ||23 |12 |23 |-------------------cur_ins = 74cur_block = 7-------------------|fifo |lru |opt |-------------------|3 |7 |26 ||11 |23 |11 ||23 |11 |0 ||7 |3 |7 |-------------------cur_ins = 75cur_block = 7-------------------|fifo |lru |opt |-------------------|3 |7 |26 ||11 |23 |11 ||23 |11 |0 ||7 |3 |7 |-------------------cur_ins = 264cur_block = 26-------------------|fifo |lru |opt |-------------------|11 |26 |26 ||23 |7 |11 ||7 |23 |0 ||26 |11 |7 |-------------------cur_ins = 265cur_block = 26-------------------|fifo |lru |opt |-------------------|11 |26 |26 ||23 |7 |11 ||7 |23 |0 ||26 |11 |7 |-------------------cur_ins = 2cur_block = 0-------------------|fifo |lru |opt |-------------------|23 |0 |26 ||7 |26 |11 ||26 |7 |0 ||0 |23 |7 |-------------------cur_ins = 3cur_block = 0-------------------|fifo |lru |opt |-------------------|23 |0 |26 ||7 |26 |11 ||26 |7 |0 ||0 |23 |7 |-------------------cur_ins = 0cur_block = 0-------------------|fifo |lru |opt |-------------------|23 |0 |26 ||7 |26 |11 ||26 |7 |0 ||0 |23 |7 |-------------------cur_ins = 1cur_block = 0-------------------|fifo |lru |opt |-------------------|23 |0 |26 ||7 |26 |11 ||26 |7 |0 ||0 |23 |7 |-------------------cur_ins = 194cur_block = 19-------------------|fifo |lru |opt |-------------------|7 |19 |19 ||26 |0 |11 ||0 |26 |0 ||19 |7 |7 |-------------------cur_ins = 195cur_block = 19-------------------|fifo |lru |opt |-------------------|7 |19 |19 ||26 |0 |11 ||0 |26 |0 ||19 |7 |7 |-------------------cur_ins = 257cur_block = 25-------------------|fifo |lru |opt |-------------------|26 |25 |19 ||0 |19 |11 ||19 |0 |0 ||25 |26 |25 |-------------------cur_ins = 258cur_block = 25-------------------|fifo |lru |opt |-------------------|26 |25 |19 ||0 |19 |11 ||19 |0 |0 ||25 |26 |25 |-------------------cur_ins = 10cur_block = 1-------------------|fifo |lru |opt |-------------------|0 |1 |1 ||19 |25 |11 ||25 |19 |0 ||1 |0 |25 |-------------------cur_ins = 11cur_block = 1-------------------|fifo |lru |opt |-------------------|0 |1 |1 ||19 |25 |11 ||25 |19 |0 ||1 |0 |25 |-------------------cur_ins = 64cur_block = 6-------------------|fifo |lru |opt |-------------------|19 |6 |6 ||25 |1 |11 ||1 |25 |0 ||6 |19 |25 |-------------------cur_ins = 65cur_block = 6-------------------|fifo |lru |opt |-------------------|19 |6 |6 ||25 |1 |11 ||1 |25 |0 ||6 |19 |25 |-------------------cur_ins = 84cur_block = 8-------------------|fifo |lru |opt |-------------------|25 |8 |8 ||1 |6 |11 ||6 |1 |0 ||8 |25 |25 |-------------------cur_ins = 85cur_block = 8-------------------|fifo |lru |opt |-------------------|25 |8 |8 ||1 |6 |11 ||6 |1 |0 ||8 |25 |25 |-------------------cur_ins = 48cur_block = 4-------------------|fifo |lru |opt |-------------------|1 |4 |8 ||6 |8 |11 ||8 |6 |0 ||4 |1 |4 |-------------------cur_ins = 49cur_block = 4-------------------|fifo |lru |opt |-------------------|1 |4 |8 ||6 |8 |11 ||8 |6 |0 ||4 |1 |4 |-------------------cur_ins = 318cur_block = 31-------------------|fifo |lru |opt |-------------------|6 |31 |8 ||8 |4 |11 ||4 |8 |0 ||31 |6 |31 |-------------------cur_ins = 319cur_block = 31-------------------|fifo |lru |opt |-------------------|6 |31 |8 ||8 |4 |11 ||4 |8 |0 ||31 |6 |31 |-------------------cur_ins = 98cur_block = 9-------------------|fifo |lru |opt |-------------------|8 |9 |8 ||4 |31 |11 ||31 |4 |0 ||9 |8 |9 |-------------------cur_ins = 99cur_block = 9-------------------|fifo |lru |opt |-------------------|8 |9 |8 ||4 |31 |11 ||31 |4 |0 ||9 |8 |9 |-------------------cur_ins = 1cur_block = 0-------------------|fifo |lru |opt |-------------------|4 |0 |8 ||31 |9 |11 ||9 |31 |0 ||0 |4 |9 |-------------------cur_ins = 2cur_block = 0-------------------|fifo |lru |opt |-------------------|4 |0 |8 ||31 |9 |11 ||9 |31 |0 ||0 |4 |9 |-------------------cur_ins = 215cur_block = 21-------------------|fifo |lru |opt |-------------------|31 |21 |8 ||9 |0 |11 ||0 |9 |21 ||21 |31 |9 |-------------------cur_ins = 216cur_block = 21-------------------|fifo |lru |opt |-------------------|31 |21 |8 ||9 |0 |11 ||0 |9 |21 ||21 |31 |9 |-------------------cur_ins = 144cur_block = 14-------------------|fifo |lru |opt |-------------------|9 |14 |8 ||0 |21 |11 ||21 |0 |14 ||14 |9 |9 |-------------------cur_ins = 145cur_block = 14-------------------|fifo |lru |opt |-------------------|9 |14 |8 ||0 |21 |11 ||21 |0 |14 ||14 |9 |9 |-------------------cur_ins = 119cur_block = 11-------------------|fifo |lru |opt |-------------------|0 |11 |8 ||21 |14 |11 ||14 |21 |14 ||11 |0 |9 |-------------------cur_ins = 120cur_block = 12-------------------|fifo |lru |opt |-------------------|21 |12 |8 ||14 |11 |12 ||11 |14 |14 ||12 |21 |9 |-------------------cur_ins = 137cur_block = 13-------------------|fifo |lru |opt |-------------------|14 |13 |8 ||11 |12 |13 ||12 |11 |14 ||13 |14 |9 |-------------------cur_ins = 138cur_block = 13-------------------|fifo |lru |opt |-------------------|14 |13 |8 ||11 |12 |13 ||12 |11 |14 ||13 |14 |9 |-------------------cur_ins = 188cur_block = 18-------------------|fifo |lru |opt |-------------------|11 |18 |8 ||12 |13 |18 ||13 |12 |14 ||18 |11 |9 |-------------------cur_ins = 189cur_block = 18-------------------|fifo |lru |opt |-------------------|11 |18 |8 ||12 |13 |18 ||13 |12 |14 ||18 |11 |9 |-------------------cur_ins = 143cur_block = 14-------------------|fifo |lru |opt |-------------------|12 |14 |8 ||13 |18 |18 ||18 |13 |14 ||14 |12 |9 |-------------------cur_ins = 144cur_block = 14-------------------|fifo |lru |opt |-------------------|12 |14 |8 ||13 |18 |18 ||18 |13 |14 ||14 |12 |9 |-------------------cur_ins = 237cur_block = 23-------------------|fifo |lru |opt |-------------------|13 |23 |8 ||18 |14 |23 ||14 |18 |14 ||23 |13 |9 |-------------------cur_ins = 238cur_block = 23-------------------|fifo |lru |opt |-------------------|13 |23 |8 ||18 |14 |23 ||14 |18 |14 ||23 |13 |9 |-------------------cur_ins = 243cur_block = 24-------------------|fifo |lru |opt |-------------------|18 |24 |8 ||14 |23 |24 ||23 |14 |14 ||24 |18 |9 |-------------------cur_ins = 244cur_block = 24-------------------|fifo |lru |opt |-------------------|18 |24 |8 ||14 |23 |24 ||23 |14 |14 ||24 |18 |9 |-------------------cur_ins = 84cur_block = 8-------------------|fifo |lru |opt |-------------------|14 |8 |8 ||23 |24 |24 ||24 |23 |14 ||8 |14 |9 |-------------------cur_ins = 85cur_block = 8-------------------|fifo |lru |opt |-------------------|14 |8 |8 ||23 |24 |24 ||24 |23 |14 ||8 |14 |9 |-------------------cur_ins = 251cur_block = 25-------------------|fifo |lru |opt |-------------------|23 |25 |25 ||24 |8 |24 ||8 |24 |14 ||25 |23 |9 |-------------------cur_ins = 252cur_block = 25-------------------|fifo |lru |opt |-------------------|23 |25 |25 ||24 |8 |24 ||8 |24 |14 ||25 |23 |9 |-------------------cur_ins = 195cur_block = 19-------------------|fifo |lru |opt |-------------------|24 |19 |19 ||8 |25 |24 ||25 |8 |14 ||19 |24 |9 |-------------------cur_ins = 196cur_block = 19-------------------|fifo |lru |opt |-------------------|24 |19 |19 ||8 |25 |24 ||25 |8 |14 ||19 |24 |9 |-------------------cur_ins = 172cur_block = 17-------------------|fifo |lru |opt |-------------------|8 |17 |17 ||25 |19 |24 ||19 |25 |14 ||17 |8 |9 |-------------------cur_ins = 173cur_block = 17-------------------|fifo |lru |opt |-------------------|8 |17 |17 ||25 |19 |24 ||19 |25 |14 ||17 |8 |9 |-------------------cur_ins = 311cur_block = 31-------------------|fifo |lru |opt |-------------------|25 |31 |31 ||19 |17 |24 ||17 |19 |14 ||31 |25 |9 |-------------------cur_ins = 312cur_block = 31-------------------|fifo |lru |opt |-------------------|25 |31 |31 ||19 |17 |24 ||17 |19 |14 ||31 |25 |9 |-------------------cur_ins = 24cur_block = 2-------------------|fifo |lru |opt |-------------------|19 |2 |2 ||17 |31 |24 ||31 |17 |14 ||2 |19 |9 |-------------------cur_ins = 25cur_block = 2-------------------|fifo |lru |opt |-------------------|19 |2 |2 ||17 |31 |24 ||31 |17 |14 ||2 |19 |9 |--------------------------------------------------------------------|item |fifo |lru |opt |-------------------------------------------------|hit |167 |169 |204 ||hit_ratio |52.1875 |52.8125 |63.75 ||miss |153 |151 |116 ||miss_ratio |47.8125 |47.1875 |36.25 |-------------------------------------------------","link":"/home/2020/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C-%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E7%9A%84%E6%A8%A1%E6%8B%9F/"},{"title":"00-é¢è¯•æŸ¥æ¼è¡¥ç¼º","text":"2024.3.13Handler sendMessage post æœ‰callbackçš„message looperå¾ªç¯æ‰§è¡Œ sendMessage å‘é€è‡ªå®šä¹‰çš„message å¯ä»¥æ²¡æœ‰callback å¯ä»¥æœ‰whatã€objå»å’Œæ¥æ”¶è€…ä¼ é€’æ¶ˆæ¯ Messageæºç ï¼ˆä»…publicï¼‰ Messageçš„è·å– HandleråŒ…è£…çš„runnable new Message() obtain() æ¨èï¼ŒMessageä¸­çš„recycleæ–¹æ³•ä¼šå›æ”¶ä¸ç”¨çš„Messageï¼Œobtainçš„æ—¶å€™å¦‚æœæ¶ˆæ¯æ± ä¸ç©ºï¼Œå¯ä»¥æœç”¨æ¶ˆæ¯æ± 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370public final class Message implements Parcelable { /** * User-defined message code so that the recipient can identify * what this message is about. Each {@link Handler} has its own name-space * for message codes, so you do not need to worry about yours conflicting * with other handlers. */ public int what; /** * arg1 and arg2 are lower-cost alternatives to using * {@link #setData(Bundle) setData()} if you only need to store a * few integer values. */ public int arg1; /** * arg1 and arg2 are lower-cost alternatives to using * {@link #setData(Bundle) setData()} if you only need to store a * few integer values. */ public int arg2; /** * An arbitrary object to send to the recipient. When using * {@link Messenger} to send the message across processes this can only * be non-null if it contains a Parcelable of a framework class (not one * implemented by the application). For other data transfer use * {@link #setData}. * * &lt;p&gt;Note that Parcelable objects here are not supported prior to * the {@link android.os.Build.VERSION_CODES#FROYO} release. */ public Object obj; @UnsupportedAppUsage /*package*/ int flags; /** * The targeted delivery time of this message. The time-base is * {@link SystemClock#uptimeMillis}. * @hide Only for use within the tests. */ @UnsupportedAppUsage @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE) public long when; /** @hide */ public static final Object sPoolSync = new Object(); /** * Return a new Message instance from the global pool. Allows us to * avoid allocating new objects in many cases. */ public static Message obtain() { synchronized (sPoolSync) { if (sPool != null) { Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; } } return new Message(); } /** * Same as {@link #obtain()}, but copies the values of an existing * message (including its target) into the new one. * @param orig Original message to copy. * @return A Message object from the global pool. */ public static Message obtain(Message orig) { Message m = obtain(); m.what = orig.what; m.arg1 = orig.arg1; m.arg2 = orig.arg2; m.obj = orig.obj; m.replyTo = orig.replyTo; m.sendingUid = orig.sendingUid; m.workSourceUid = orig.workSourceUid; if (orig.data != null) { m.data = new Bundle(orig.data); } m.target = orig.target; m.callback = orig.callback; return m; } /** * Same as {@link #obtain()}, but sets the value for the &lt;em&gt;target&lt;/em&gt; member on the Message returned. * @param h Handler to assign to the returned Message object's &lt;em&gt;target&lt;/em&gt; member. * @return A Message object from the global pool. */ public static Message obtain(Handler h) { Message m = obtain(); m.target = h; return m; } /** * Same as {@link #obtain(Handler)}, but assigns a callback Runnable on * the Message that is returned. * @param h Handler to assign to the returned Message object's &lt;em&gt;target&lt;/em&gt; member. * @param callback Runnable that will execute when the message is handled. * @return A Message object from the global pool. */ public static Message obtain(Handler h, Runnable callback) { Message m = obtain(); m.target = h; m.callback = callback; return m; } /** * Same as {@link #obtain()}, but sets the values for both &lt;em&gt;target&lt;/em&gt; and * &lt;em&gt;what&lt;/em&gt; members on the Message. * @param h Value to assign to the &lt;em&gt;target&lt;/em&gt; member. * @param what Value to assign to the &lt;em&gt;what&lt;/em&gt; member. * @return A Message object from the global pool. */ public static Message obtain(Handler h, int what) { Message m = obtain(); m.target = h; m.what = what; return m; } /** * Same as {@link #obtain()}, but sets the values of the &lt;em&gt;target&lt;/em&gt;, &lt;em&gt;what&lt;/em&gt;, and &lt;em&gt;obj&lt;/em&gt; * members. * @param h The &lt;em&gt;target&lt;/em&gt; value to set. * @param what The &lt;em&gt;what&lt;/em&gt; value to set. * @param obj The &lt;em&gt;object&lt;/em&gt; method to set. * @return A Message object from the global pool. */ public static Message obtain(Handler h, int what, Object obj) { Message m = obtain(); m.target = h; m.what = what; m.obj = obj; return m; } /** * Same as {@link #obtain()}, but sets the values of the &lt;em&gt;target&lt;/em&gt;, &lt;em&gt;what&lt;/em&gt;, * &lt;em&gt;arg1&lt;/em&gt;, and &lt;em&gt;arg2&lt;/em&gt; members. * * @param h The &lt;em&gt;target&lt;/em&gt; value to set. * @param what The &lt;em&gt;what&lt;/em&gt; value to set. * @param arg1 The &lt;em&gt;arg1&lt;/em&gt; value to set. * @param arg2 The &lt;em&gt;arg2&lt;/em&gt; value to set. * @return A Message object from the global pool. */ public static Message obtain(Handler h, int what, int arg1, int arg2) { Message m = obtain(); m.target = h; m.what = what; m.arg1 = arg1; m.arg2 = arg2; return m; } /** * Same as {@link #obtain()}, but sets the values of the &lt;em&gt;target&lt;/em&gt;, &lt;em&gt;what&lt;/em&gt;, * &lt;em&gt;arg1&lt;/em&gt;, &lt;em&gt;arg2&lt;/em&gt;, and &lt;em&gt;obj&lt;/em&gt; members. * * @param h The &lt;em&gt;target&lt;/em&gt; value to set. * @param what The &lt;em&gt;what&lt;/em&gt; value to set. * @param arg1 The &lt;em&gt;arg1&lt;/em&gt; value to set. * @param arg2 The &lt;em&gt;arg2&lt;/em&gt; value to set. * @param obj The &lt;em&gt;obj&lt;/em&gt; value to set. * @return A Message object from the global pool. */ public static Message obtain(Handler h, int what, int arg1, int arg2, Object obj) { Message m = obtain(); m.target = h; m.what = what; m.arg1 = arg1; m.arg2 = arg2; m.obj = obj; return m; } /** @hide */ public static void updateCheckRecycle(int targetSdkVersion) { if (targetSdkVersion &lt; Build.VERSION_CODES.LOLLIPOP) { gCheckRecycle = false; } } /** * Return a Message instance to the global pool. * &lt;p&gt; * You MUST NOT touch the Message after calling this function because it has * effectively been freed. It is an error to recycle a message that is currently * enqueued or that is in the process of being delivered to a Handler. * &lt;/p&gt; */ public void recycle() { if (isInUse()) { if (gCheckRecycle) { throw new IllegalStateException(&quot;This message cannot be recycled because it &quot; + &quot;is still in use.&quot;); } return; } recycleUnchecked(); } /** * Return the targeted delivery time of this message, in milliseconds. */ public long getWhen() { return when; } public void setTarget(Handler target) { this.target = target; } /** * Retrieve the {@link android.os.Handler Handler} implementation that * will receive this message. The object must implement * {@link android.os.Handler#handleMessage(android.os.Message) * Handler.handleMessage()}. Each Handler has its own name-space for * message codes, so you do not need to * worry about yours conflicting with other handlers. */ public Handler getTarget() { return target; } /** * Retrieve callback object that will execute when this message is handled. * This object must implement Runnable. This is called by * the &lt;em&gt;target&lt;/em&gt; {@link Handler} that is receiving this Message to * dispatch it. If * not set, the message will be dispatched to the receiving Handler's * {@link Handler#handleMessage(Message)}. */ public Runnable getCallback() { return callback; } /** @hide */ @UnsupportedAppUsage public Message setCallback(Runnable r) { callback = r; return this; } /** * Obtains a Bundle of arbitrary data associated with this * event, lazily creating it if necessary. Set this value by calling * {@link #setData(Bundle)}. Note that when transferring data across * processes via {@link Messenger}, you will need to set your ClassLoader * on the Bundle via {@link Bundle#setClassLoader(ClassLoader) * Bundle.setClassLoader()} so that it can instantiate your objects when * you retrieve them. * @see #peekData() * @see #setData(Bundle) */ public Bundle getData() { if (data == null) { data = new Bundle(); } return data; } /** * Like getData(), but does not lazily create the Bundle. A null * is returned if the Bundle does not already exist. See * {@link #getData} for further information on this. * @see #getData() * @see #setData(Bundle) */ public Bundle peekData() { return data; } /** * Sets a Bundle of arbitrary data values. Use arg1 and arg2 members * as a lower cost way to send a few simple integer values, if you can. * @see #getData() * @see #peekData() */ public void setData(Bundle data) { this.data = data; } /** * Chainable setter for {@link #what} * * @hide */ public Message setWhat(int what) { this.what = what; return this; } /** * Sends this Message to the Handler specified by {@link #getTarget}. * Throws a null pointer exception if this field has not been set. */ public void sendToTarget() { target.sendMessage(this); } /** * Returns true if the message is asynchronous, meaning that it is not * subject to {@link Looper} synchronization barriers. * * @return True if the message is asynchronous. * * @see #setAsynchronous(boolean) */ public boolean isAsynchronous() { return (flags &amp; FLAG_ASYNCHRONOUS) != 0; } /** * Sets whether the message is asynchronous, meaning that it is not * subject to {@link Looper} synchronization barriers. * &lt;p&gt; * Certain operations, such as view invalidation, may introduce synchronization * barriers into the {@link Looper}'s message queue to prevent subsequent messages * from being delivered until some condition is met. In the case of view invalidation, * messages which are posted after a call to {@link android.view.View#invalidate} * are suspended by means of a synchronization barrier until the next frame is * ready to be drawn. The synchronization barrier ensures that the invalidation * request is completely handled before resuming. * &lt;/p&gt;&lt;p&gt; * Asynchronous messages are exempt from synchronization barriers. They typically * represent interrupts, input events, and other signals that must be handled independently * even while other work has been suspended. * &lt;/p&gt;&lt;p&gt; * Note that asynchronous messages may be delivered out of order with respect to * synchronous messages although they are always delivered in order among themselves. * If the relative order of these messages matters then they probably should not be * asynchronous in the first place. Use with caution. * &lt;/p&gt; * * @param async True if the message is asynchronous. * * @see #isAsynchronous() */ public void setAsynchronous(boolean async) { if (async) { flags |= FLAG_ASYNCHRONOUS; } else { flags &amp;= ~FLAG_ASYNCHRONOUS; } } /** Constructor (but the preferred way to get a Message is to call {@link #obtain() Message.obtain()}). */ public Message() { }} Looperæ¯æ¬¡å¾ªç¯åœ¨åšä»€ä¹ˆ å–æ¶ˆæ¯ åˆ†å‘æ¶ˆæ¯123456789101112@SuppressWarnings({&quot;UnusedTokenOfOriginalCallingIdentity&quot;, &quot;ClearIdentityCallNotFollowedByTryFinally&quot;})private static boolean loopOnce(final Looper me, final long ident, final int thresholdOverride) { Message msg = me.mQueue.next(); // might block if (msg == null) { // No message indicates that the message queue is quitting. return false; } msg.target.dispatchMessage(msg); // çœç•¥éƒ¨åˆ†å¤§æ¦‚æ˜¯å’Œobserveräº¤äº’è¿˜æœ‰æ‰“log} Handler.dispatchMessage æœ‰callbackå°±æ‰§è¡Œcallback æ²¡æœ‰åˆ™é€šè¿‡mCallbackå¯¹è±¡æˆ–è€…å­ç±»é‡å†™handleMessageåˆ†å‘æ¶ˆæ¯ã€‚123456789101112public void dispatchMessage(@NonNull Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); }} MessageQueueenqueueæ¶ˆæ¯çš„æ“ä½œ æŒ‰ç…§whenå¤§å°å…¥é˜Ÿ å¦‚æœä¸æ˜¯å¼‚æ­¥æ¶ˆæ¯ä¸”é˜Ÿåˆå§‹ä¸ºç©ºæˆ–é˜Ÿåˆ—ä¸­æ¶ˆæ¯ä¸ºå¼‚æ­¥æ¶ˆæ¯æˆ–æ¶ˆæ¯æ²¡æœ‰targetï¼Œåˆ™wakeå¯¹æ–¹12345678910111213141516171819202122232425262728293031323334353637383940414243444546boolean enqueueMessage(Message msg, long when) { if (msg.target == null) { throw new IllegalArgumentException(&quot;Message must have a target.&quot;); } synchronized (this) { if (msg.isInUse()) { throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); } msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) { // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; } else { // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) { prev = p; p = p.next; if (p == null || when &lt; p.when) { break; } if (needWake &amp;&amp; p.isAsynchronous()) { needWake = false; } } msg.next = p; // invariant: p == prev.next prev.next = msg; } // We can assume mPtr != 0 because mQuitting is false. if (needWake) { nativeWake(mPtr); } } return true;} enqueueçš„æ—¶å€™ä¸æ˜¯å…¨éƒ¨æ£€æŸ¥targetä¸ä¸ºç©ºäº†å—ï¼Ÿä¸ºä»€ä¹ˆåç»­è¿˜æœ‰targetä¸ºç©ºçš„æ¶ˆæ¯ï¼Ÿ Handler åŒæ­¥å±éšœ&amp;å¼‚æ­¥æ¶ˆæ¯ Androidæ¶ˆæ¯æœºåˆ¶1-Handler(Javaå±‚) é€šè¿‡ä¸€ä¸ªæ–¹æ³•å‘é€æ²¡æœ‰targetçš„æ¶ˆæ¯å±éšœï¼Œè¿™æ ·æš‚æ—¶å±è”½åŒæ­¥æ¶ˆæ¯ï¼Œåªå–å‡ºå¼‚æ­¥æ¶ˆæ¯ å–æ¶ˆæ¯çš„æ“ä½œ å–æ¶ˆæ¯ å¦‚æœæœ‰æ¶ˆæ¯ readyäº†ï¼Œå°±è¿”å› æ²¡readyï¼Œé˜»å¡ç­‰ç€é€šè¿‡nativePollOnceï¼Œå¦‚æœæœ‰äººenqueueï¼Œåˆ™ä¼šé€šè¿‡nativeWakeå”¤é†’ æ²¡æœ‰æ¶ˆæ¯äº†1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@UnsupportedAppUsageMessage next() { int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) { if (nextPollTimeoutMillis != 0) { Binder.flushPendingCommands(); } nativePollOnce(ptr, nextPollTimeoutMillis); // å¦‚æœæ¶ˆæ¯è¿˜æ²¡æœ‰readyï¼Œé˜»å¡ç­‰å¾…ä¸€æ®µæ—¶é—´ // nextPollTimeoutMillisçš„è®¡ç®—åœ¨ä¸Šä¸€æ¬¡å¾ªç¯ï¼Œçœ‹ä¸‹é¢çš„ä»£ç  synchronized (this) { // åªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½æ‹¿æ¶ˆæ¯ // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) { // Stalled by a barrier. Find the next asynchronous message in the queue. do { prevMsg = msg; msg = msg.next; } while (msg != null &amp;&amp; !msg.isAsynchronous()); } if (msg != null) { if (now &lt; msg.when) { // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); // nextPollTimeoutMillisçš„è®¡ç®— } else { // Got a message. mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; // æ‹¿åˆ°æ¶ˆæ¯ï¼Œè¿”å› } } else { // No more messages. nextPollTimeoutMillis = -1; } } }} Handlerå®æˆ˜ æ™®é€šè¿›ç¨‹ä½¿ç”¨ 1234567891011121314class LooperThread extends Thread { public Handler mHandler; public void run() { Looper.prepare(); mHandler = new Handler(Looper.myLooper()) { public void handleMessage(Message msg) { //å¤„ç†å³å°†å‘é€è¿‡æ¥çš„æ¶ˆæ¯ System.out.println(&quot;thread id=&quot;+Thread.currentThread().getId()); } } Looper.loop(); }}// å¤–éƒ¨å¼€å¯çº¿ç¨‹ã€è·å–handlerï¼Œpost/sendMessage HandlerThread 1234HandlerThread handlerThread = new HandlerThread(&quot;name&quot;);handlerThread.start(); // åˆ›å»ºHandlerThreadHandler handler = new Handler(handlerThread.getLooper());// æ‹¿åˆ°HandlerThreadçš„Looperï¼Œåˆ›å»ºhandler Looperé€€å‡º quit : åˆ é™¤æ‰€æœ‰æ¶ˆæ¯ï¼ŒåŒ…æ‹¬æ­£åœ¨è¿è¡Œçš„ quitSafely() : åˆ é™¤æœªè¿è¡Œçš„æ¶ˆæ¯ AOTå’ŒJITçš„å¯¹æ¯” System.arraycopyPerformance of System.arraycopy() vs. Arrays.copyOf() arraycopyæ˜¯nativeæ–¹æ³•ï¼Œç”¨cå®ç°çš„ï¼Œå¯èƒ½æ˜¯memcpyç­‰æ–¹æ³•å®ç°çš„ï¼Œæ•ˆç‡å› å¹³å°è€Œä¸åŒ ANR(App Not Responding) å“ªäº›åœºæ™¯å¯¼è‡´ANR Service Timeout:Serviceåœ¨ç‰¹å®šçš„æ—¶é—´å†…æ— æ³•å¤„ç†å®Œæˆ BroadcastQueue Timeoutï¼šBroadcastReceiveråœ¨ç‰¹å®šæ—¶é—´å†…æ— æ³•å¤„ç†å®Œæˆ ContentProvider Timeoutï¼šå†…å®¹æä¾›è€…æ‰§è¡Œè¶…æ—¶ inputDispatching Timeout: æŒ‰é”®æˆ–è§¦æ‘¸äº‹ä»¶åœ¨ç‰¹å®šæ—¶é—´å†…æ— å“åº”ã€‚ ServiceANRrealStartServiceLocked()-&gt;bumpServiceExecutingLocked()-&gt;scheduleServiceTimeoutLocked() åœ¨Serviceå¯åŠ¨è¿‡ç¨‹ä¸­ï¼ŒscheduleServiceTimeoutLockedé€šè¿‡nativeå±‚çš„handlerå‘é€äº†DelayedMessage 12345678910111213void scheduleServiceTimeoutLocked(ProcessRecord proc) { if (proc.executingServices.size() == 0 || proc.thread == null) { return; } Message msg = mAm.mHandler.obtainMessage( ActivityManagerService.SERVICE_TIMEOUT_MSG); msg.obj = proc; // åœ¨serviceDoneExecutingLockedä¸­ä¼šremoveè¯¥SERVICE_TIMEOUT_MSGæ¶ˆæ¯ï¼Œ // å½“è¶…æ—¶åä»æ²¡æœ‰remove SERVICE_TIMEOUT_MSGæ¶ˆæ¯ï¼Œåˆ™æ‰§è¡ŒActiveServices. serviceTimeout()æ–¹æ³•ï¼› mAm.mHandler.sendMessageDelayed(msg, proc.execServicesFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT); // å‰å°è¿›ç¨‹ä¸­æ‰§è¡ŒServiceï¼ŒSERVICE_TIMEOUT=20sï¼›åå°è¿›ç¨‹ä¸­æ‰§è¡ŒServiceï¼ŒSERVICE_BACKGROUND_TIMEOUT=200s} åœ¨Serviceçš„OnCreateç»“æŸåæˆ–å¯åŠ¨è¿‡ç¨‹æŠ›å‡ºå¼‚å¸¸ï¼Œè°ƒç”¨serviceDoneExecutingLockedåˆ é™¤æ¶ˆæ¯ 1234if (r.app.executingServices.size() == 0) { if (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING, &quot;No more executingServices of &quot; + r.shortName);mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app); åœ¨serviceçš„oncreateé˜¶æ®µä¸è¦æ‰§è¡Œè¿‡é‡çš„ä»»åŠ¡ InputDispatchingANRåœ¨åˆ†æ´¾è¾“å…¥äº‹ä»¶æ—¶ï¼ŒInputDispatcherä¼šæ£€æŸ¥å½“å‰æ˜¯å¦æœ‰èšç„¦çš„çª—å£å’Œåº”ç”¨ï¼Œè·å–è¶…æ—¶æ—¶é—´ï¼Œå¦‚æœå½“å‰æ—¶é—´å¤§äºè¶…æ—¶æ—¶é—´ï¼Œå°±å¼¹å‡ºANR Activity.onCreateæ‰§è¡Œè€—æ—¶æ“ä½œï¼Œä¸ç®¡ç”¨æˆ·å¦‚ä½•æ“ä½œéƒ½ä¸ä¼šå‘ç”ŸANRï¼Œå› ä¸ºè¾“å…¥äº‹ä»¶ç›¸å…³ç›‘å¬æœºåˆ¶è¿˜æ²¡æœ‰å»ºç«‹èµ·æ¥ï¼›InputChannelé€šé“è¿˜æ²¡æœ‰å»ºç«‹ åº”å¯¹æ–¹æ¡ˆ è€—æ—¶æ“ä½œå­çº¿ç¨‹å¤„ç†ï¼Œç»“æŸååˆ‡å›ä¸»çº¿ç¨‹æ›´æ–°ui Logsé™¤äº†ä¸»ä½“é€»è¾‘ï¼Œå‘ç”ŸANRæ—¶è¿˜ä¼šè¾“å‡ºå„ç§ç±»åˆ«çš„æ—¥å¿—ï¼ševent logï¼šé€šè¿‡æ£€ç´¢â€am_anrâ€å…³é”®å­—ï¼Œå¯ä»¥æ‰¾åˆ°å‘ç”ŸANRçš„åº”ç”¨main logï¼šé€šè¿‡æ£€ç´¢â€ANR in â€œå…³é”®å­—ï¼Œå¯ä»¥æ‰¾åˆ°ANRçš„ä¿¡æ¯ï¼Œæ—¥å¿—çš„ä¸Šä¸‹æ–‡ä¼šåŒ…å«CPUçš„ä½¿ç”¨æƒ…å†µdropboxï¼šé€šè¿‡æ£€ç´¢â€anrâ€ç±»å‹ï¼Œå¯ä»¥æ‰¾åˆ°ANRçš„ä¿¡æ¯tracesï¼šå‘ç”ŸANRæ—¶ï¼Œå„è¿›ç¨‹çš„å‡½æ•°è°ƒç”¨æ ˆä¿¡æ¯ çœ‹å®Œè¿™ç¯‡ Android ANR åˆ†æï¼Œå°±å¯ä»¥å’Œé¢è¯•å®˜è£…é€¼äº†ï¼ Activity/Fragment LifecycleActivity onSaveInstanceState() ä¸ onRestoreIntanceState() ä¸å±äºç”Ÿå‘½å‘¨æœŸ onSaveInstanceStateä¿å­˜ä¸´æ—¶æ€§çš„çŠ¶æ€ onRestoreIntanceStateæ¢å¤ä¸´æ—¶æ€§çš„çŠ¶æ€ è°ƒç”¨æ—¶æœº å¼‚å¸¸ç»ˆæ­¢çš„æ—¶å€™æ‰ä¼šè°ƒç”¨ èµ„æºå†…å­˜ä¸è¶³å¯¼è‡´ä½ä¼˜å…ˆçº§çš„ Activity è¢«æ€æ­» é«˜ä¼˜å…ˆçº§ï¼šå‰å°Activity ä¸­ä¼˜å…ˆçº§ï¼šå¯è§ä¸”éå‰å° ä½ä¼˜å…ˆçº§ï¼šåå°Activity èµ„æºç›¸å…³çš„ç³»ç»Ÿé…ç½®å‘ç”Ÿæ”¹å˜å¯¼è‡´Activityè¢«æ€æ­»å¹¶é‡æ–°åˆ›å»º æ—‹è½¬å±å¹• æ—‹è½¬å±å¹•æ—¶ æ—§Activityï¼špuase-&gt;onSaveInstanceState-&gt;stop-&gt;destory æ–°Activityï¼šcreate-&gt;start-&gt;onRestoreInstanceState-&gt;onresume onCreateä¸­ä¹Ÿèƒ½å–åˆ°onSaveInstanceStateï¼Œä½†æ˜¯å®˜æ–¹å»ºè®®ä½¿ç”¨onRestoreInstanceStateæ¢å¤æ•°æ® onCreate: åˆ›å»ºä¸­ï¼Œ onStartï¼šå¯è§ä½†ä¸å¯äº¤äº’ onResumeï¼šå¯è§å¯äº¤äº’ onPauseï¼šå¯è§ä¸å¯äº¤äº’ å…¶ä»–åº”ç”¨éœ€è¦å†…å­˜ï¼Œå°±ä¼šKillè¿›ç¨‹ï¼Œä¸‹æ¬¡å›æ¥æ—¶ï¼Œè¿›å…¥onCreate onStopï¼šä¸å¯è§ å…¶ä»–åº”ç”¨éœ€è¦å†…å­˜ï¼Œå°±ä¼šKillè¿›ç¨‹ï¼Œä¸‹æ¬¡å›æ¥æ—¶ï¼Œè¿›å…¥onCreate ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œä¸‹æ¬¡å›æ¥æ—¶ï¼Œè°ƒç”¨onRestartç„¶åonCreate onDestroyï¼šé”€æ¯ å…¶ä»–Activityè¿›å…¥å‰å°ï¼Œå½“å‰Activityå°±ä¼šonPauseï¼ŒonStopã€‚å¦‚æœæ‰‹å¿«ä¸€ç‚¹ï¼Œåœ¨å½“å‰Activityæ²¡æœ‰å½»åº•æ¶ˆå¤±æ—¶å°±å…³é—­ä¸‹ä¸€ä¸ªActivityï¼Œå°±ä¸ä¼šè¿›å…¥onStop Fragment AAR ä¹Ÿæ˜¯ä¸€ç§æ‰“åŒ…çš„zipæ–‡ä»¶ è¿œç¨‹aarå’Œæœ¬åœ°arr Ræ–‡ä»¶ èµ„æºid ç¼–è¯‘æ—¶ä¼šç”Ÿæˆresources.arscï¼ŒåŒ…å«idåˆ°å®é™…å€¼çš„æ˜ å°„ éƒ½æ˜¯static finalï¼Œå¯ä»¥è¢«å†…è” application moduleè¢«å†…è”äº† éƒ¨åˆ†ä¸æ˜¯finalï¼Œæ˜¯staticçš„ library moduleçš„Ræ–‡ä»¶ä¸­çš„å¸¸é‡æ²¡æœ‰è¢«å†…è” aaræ²¡æœ‰è¢«å†…è” å‹ç¼© AGP 4.1.0æ‰“åŒ…æ—¶ï¼Œåœ¨releaseåŒ…ä¸­å·²ç»å½»åº•ä¼˜åŒ–æ‰Ræ–‡ä»¶ æ··æ·†ï¼Œç¼©çŸ­idç­‰æ ‡è¯†ç¬¦é•¿åº¦ åˆ é™¤ä¸éœ€è¦çš„èµ„æº ä»åº”ç”¨åŠå…¶åº“ä¾èµ–ä¸­æ£€æµ‹å¹¶å®‰å…¨åœ°ç§»é™¤ä¸ä½¿ç”¨çš„ç±»ã€å­—æ®µã€æ–¹æ³•å’Œå±æ€§ HTTPæ–­ç‚¹ç»­ä¼ å„ç§ç”Ÿå‘½å‘¨æœŸsqläº‹åŠ¡viewç»˜åˆ¶åŸç†activityå¯åŠ¨æ¨¡å¼è¿™é‡Œçš„éƒ½ä¸å¤ªä¼š2024.3.17ç¾å›¢ç¬”è¯•é¢å‘å¯¹è±¡çš„å„ç§æ¦‚å¿µ å•ä¸€èŒè´£ ç­‰ ç¼–è¯‘åŸç†ç›¸å…³çŸ¥è¯† æ–‡æ³•è‡ªåŠ¨æœºç›¸å…³çŸ¥è¯† ç­‰ 2024.3.19ç¾å›¢äºŒé¢Serviceç”Ÿå‘½å‘¨æœŸ éç»‘å®šå¼ -(é¦–æ¬¡startService)-&gt;onCreate() -(éé¦–æ¬¡startService)-&gt;onStartCommand() -(stopService/stopSelf)-&gt;onDestroy() ç»‘å®šå¼ -(é¦–æ¬¡bindService)-&gt;onCreate() -(éé¦–æ¬¡bindService)-&gt;onBind() -(unbindService/stopSelf)-&gt;onUnbind()-&gt;onDestroy() Activityä¸Serviceäº¤äº’ä¿¡æ¯ éç»‘å®šå¼ startServiceæ—¶ç”¨Intentä¼ é€’ ç»‘å®šå¼ åˆ›å»ºServiceConnectå¯¹è±¡ï¼Œè·å–IBinder é€šè¿‡IBinderäº¤äº’ Serviceä¸­åˆ›å»ºå¯¹è±¡ï¼Œç»§æ‰¿Binder å‰å°Service å‰å°æœåŠ¡ï¼Œä¸€èˆ¬ç”¨æ¥åˆ›å»ºnotificationï¼Œä¸”ä¸å¯ç§»é™¤çš„é€šçŸ¥ onCreateæ—¶é€šè¿‡startForegroundåˆ›å»ºé€šçŸ¥ é€šè¿‡stopForegroundåœæ­¢å‰å°æœåŠ¡ åŠ¨æ€å¹¿æ’­çš„ä½¿ç”¨sendBroadCastæ¥å—åˆ›å»ºIntentFilteråˆ›å»ºBroadcastReceiverregisterReceiverunregistReceiver ä¸¤ä¸ªActivityä¹‹é—´ä¼ é€’æ¶ˆæ¯ é™æ€å¹¿æ’­åˆ›å»ºæ¥æ”¶å™¨åœ¨Manifestæ–‡ä»¶ä¸­æ³¨å†Œï¼ŒæŒ‡å®šæ¥æ”¶å™¨ç±»åå’ŒIntentFilter 8.0åæ— æ³•æ¥å—éšå¼å¹¿æ’­ï¼ˆintentåªæŒ‡å®šactionï¼‰ intent.setPackage(getPackageName()) // æ¥æ”¶æ–¹çš„åŒ…å intent.addFlags(FLAG_RECEIVER_INCLUDE_BACKGROUND) æœ‰åºå¹¿æ’­æ— åºå¹¿æ’­ æ— åºå¹¿æ’­ é»˜è®¤å°±æ˜¯æ— åºå¹¿æ’­ å¤šä¸ªæ¥æ”¶å™¨åŒæ—¶æ¥å— æœ‰åºå¹¿æ’­ æ¥æ”¶å™¨ä¾ç…§ä¼˜å…ˆçº§ä¾æ¬¡æ¥å—å¹¿æ’­ é€šè¿‡context.sendOrderedBroadcast(intent, permission);å‘é€ intentFilter.setPriority() sendOrderedBoradcast åœ¨å¹¿æ’­æ¥æ”¶å™¨ä¸­abortBroadcastä¼šæˆªæ–­å¹¿æ’­å‘ä½ä¼˜å…ˆçº§çš„ä¼ é€’ setResultExtraså’ŒgetResultExtrasï¼Œä¸Šæ¸¸æ¥æ”¶å™¨å‘ä¸‹æ¸¸å‘é€æ¶ˆæ¯ setResultDataå’ŒgetResultDataï¼Œä¸Šæ¸¸æ¥æ”¶å™¨å‘ä¸‹æ¸¸å‘é€æ¶ˆæ¯ æœ¬åœ°å¹¿æ’­å…¨å±€å¹¿æ’­ æœ¬åœ°å¹¿æ’­ï¼šä»…åœ¨appå†…éƒ¨ä¼ æ’­ åªèƒ½åŠ¨æ€æ³¨å†Œ LocalBroadCastReceiverï¼ˆå·²åºŸå¼ƒï¼Œéœ€è¦æ‰‹åŠ¨æ·»åŠ ä¾èµ–ï¼‰ å…¨å±€å¹¿æ’­ï¼šæ•´ä¸ªç³»ç»Ÿéƒ½èƒ½æ¥å— é»˜è®¤å°±æ˜¯å…¨å±€çš„ Javaæ–°æŠ€æœ¯ï¼ˆkotlinæ—©å·²æ”¯æŒï¼‰ å¯†å°ç±» è§„å®šå¯ä»¥æœ‰å“ªäº›å­ç±»12public abstract sealed class Reference&lt;T&gt; permits PhantomReference, SoftReference, WeakReference, FinalReference { HookæŠ€æœ¯é€šè¿‡åå°„ï¼Œå°†æŸäº›å›è°ƒå­—æ®µè®¾ç½®æˆä¸€ä¸ªä»£ç†å¯¹è±¡ï¼Œä»£ç†å­—æ®µä¸­å¯¹invokeè¿›è¡Œhook Xposedæ¡†æ¶é€šè¿‡æ›¿æ¢/system/bin/app_processç¨‹åºæ§åˆ¶zygoteè¿›ç¨‹ï¼Œä½¿app_processåœ¨å¯åŠ¨è¿‡ç¨‹ä¸­åŠ è½½XposedBridge.jarï¼Œä»è€Œå®Œæˆå¯¹Zygoteè¿›ç¨‹åŠå…¶åˆ›å»ºçš„Dalvikè™šæ‹Ÿæœºçš„åŠ«æŒ posedè‡ªå®šä¹‰æ¨¡å—å¼€å‘1234567891011121314151617181920public class Main implements IXposedHookLoadPackage { @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable { if (!loadPackageParam.packageName.equals(&quot;com.example.pengchengxiang.inputdemo&quot;)) { return; } XposedBridge.log(&quot;Loaded app:&quot; + loadPackageParam.packageName); //Hook ç±»çš„æ–¹æ³• findAndHookMethod(&quot;className&quot;, loadPackageParam.classLoader, &quot;methodNAme&quot;, String.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { } }); } }","link":"/home/2024/03/13/Android%E9%AB%98%E7%BA%A7/Android%20%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/00%E9%9D%A2%E8%AF%95%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"title":"02-http","text":"æ ¼å¼ æŠ¥æ–‡æ ¼å¼(Request) è¯·æ±‚è¡Œ eg: GET /users?id=xxxx HTTP/1.1 method path(åŒ…æ‹¬å‚æ•°éƒ¨åˆ†) Http version headers (Hoståœ¨è¿™é‡Œ) body æŠ¥æ–‡æ ¼å¼(Response) çŠ¶æ€è¡Œ eg: HTTP/1.1 200 OK Http Version status code status message headers body Requestmethod GET è·å–èµ„æº æ²¡æœ‰body POST å¢åŠ /ä¿®æ”¹èµ„æº æœ‰body PUT ä¿®æ”¹èµ„æº æœ‰body DELETE åˆ é™¤èµ„æº æ²¡æœ‰body HEAD è·å–èµ„æº æ²¡æœ‰body å“åº”æ— body ç”¨äºä¸‹è½½æ—¶ï¼Œç¡®å®šæ–‡ä»¶å¤§å°ï¼Œæœ‰æ— æ–­ç‚¹ç»­ä¼ ç­‰ä¿¡æ¯ å¹‚ç­‰æ€§ï¼šæŒ‡é‡å¤çš„è¯·æ±‚å¤šæ¬¡å‘æœåŠ¡å™¨ä¼ é€ï¼Œå¯¹æœåŠ¡å™¨çš„æ²¡æœ‰å½±å“ã€‚å¦‚GETå’ŒPUT,DELETEã€‚ Responsestatus codeä¸ºäº†æ–¹ä¾¿å¼€å‘äººå‘˜å®šä½é”™è¯¯ 1xx: ä¸´æ—¶æ€§æ¶ˆæ¯ 100 å½“å®¢æˆ·ç«¯ä¼ é€æ•°æ®è¿‡å¤§æ—¶ï¼Œå°†å…¶åˆ†æ®µå‘é€ï¼Œåœ¨æœ€åä¸€ä¸ªè¯·æ±‚ä¹‹å‰ï¼ŒæœåŠ¡å™¨æ¯æ”¶åˆ°ä¸€ä¸ªè¯·æ±‚ï¼Œè¿”å›100è¡¨ç¤ºæ”¶åˆ°ï¼Œå®¢æˆ·ç«¯å†å‘é€ä¸‹ä¸€ä¸ªã€‚ 101 è¡¨ç¤ºæ”¯æŒhttp2ï¼Œæµè§ˆå¹¶å°è¯•ä½¿ç”¨http2æ—¶ï¼Œä¼šå…ˆå‘é€ä¸€ä¸ªè¯•æ¢æ€§çš„è¯·æ±‚ï¼Œå¦‚æœè¿”å›200ï¼Œè¯´æ˜æœåŠ¡å™¨ä¸æ”¯æŒhttp2ï¼Œè¿”å›101åˆ™è¡¨ç¤ºæ”¯æŒ 2xx: æˆåŠŸ 3xx: é‡å®šå‘ 301 å¦‚ï¼Œæµè§ˆå™¨è®¿é—®httpæ—¶è¿”å›301ï¼Œè‡ªåŠ¨æ”¹ç”¨httpsè®¿é—® 304 å†…å®¹æœªæ”¹å˜ 4xx: å®¢æˆ·ç«¯é”™è¯¯ 400 è¯·æ±‚æœ‰é—®é¢˜ 401 æœªç™»å½• 404 æ²¡æ‰¾åˆ° 5xx: æœåŠ¡å™¨å‡ºé”™ Headerè¯·æ±‚çš„æ•°æ®çš„å…ƒæ•°æ® Host: æœåŠ¡å™¨ä¸»æœº(ä½œç”¨æ˜¯åŒºåˆ†å¤šä¸ªåŸŸåå¯¹åº”åŒä¸€ä¸ªipçš„æƒ…å†µï¼Œåœ¨å‘é€ä¹‹å‰å·²ç»è§£æå‡ºipäº†) Content-Length: å†…å®¹é•¿åº¦ï¼Œä½œç”¨æ˜¯å½“ä¼ é€äºŒè¿›åˆ¶æ•°æ®æ—¶ï¼Œç¡®å®šç»“æŸä½ç½® Content-type: å†…å®¹ç±»å‹ text/html: æ˜¯htmlé¡µé¢ application/x-www-form-urlencoded: æ™®é€šè¡¨å•(htmlé‡Œé¢é‚£ä¸ª)ï¼Œencoded URLæ ¼å¼ bodyä¸­çš„å†…å®¹å’Œpathä¸­çš„å‚æ•°ä¸€æ ·ï¼Œéƒ½æ˜¯ä½¿ç”¨urlencodedç¼–ç çš„çº¯æ–‡æœ¬ä¿¡æ¯ multipart/form-data: å¤šéƒ¨ä»½ï¼Œå¸¦æ–‡ä»¶çš„è¡¨å•ï¼ŒäºŒè¿›åˆ¶å†…å®¹ æ¯ä¸ªparté€šè¿‡boundaryæŒ‡å®š åˆ†éš” application/json image/jpeg, application/zip ä¼ é€å•ä¸ªæ–‡ä»¶ Chunked Transfer Encoding: åˆ†å—ä¼ è¾“ï¼Œè‹¥å“åº”é‡éå¸¸å¤§ï¼ŒæœåŠ¡å™¨ç›¸åº”éå¸¸è€—æ—¶æ—¶ï¼Œæƒ³è¦æ¯æŸ¥å‡ºä¸€éƒ¨åˆ†æ•°æ®åå°±ç«‹å³è¿”å›ç»™å®¢æˆ·ç«¯ã€‚ bodyæ ¼å¼12345678910&lt;len1&gt;&lt;content1&gt;&lt;len2&gt;&lt;content1&gt;&lt;len3&gt;&lt;content1&gt;...more&lt;len_n&gt;&lt;content1&gt;0 #ç»“æŸ Location: é‡å®šå‘çš„ç›®æ ‡URL User-Agent: æ ‡è¯†ç”¨æˆ·ä½¿ç”¨çš„å®¢æˆ·ç«¯ Range / Accept-Range: æŒ‡å®šæ¥æ”¶bodyçš„èŒƒå›´ï¼Œæ–­ç‚¹ç»­ä¼ æ—¶ä½¿ç”¨ï¼Œå¤šçº¿ç¨‹ä¸‹è½½ Cookie / set-Cookie: Cookie Authorization: æˆæƒä¿¡æ¯ more Cache-Control cacheå’Œbufferçš„åŒºåˆ« Cache: ç¼“å­˜ï¼Œå¦‚cpuçš„Cacheï¼ŒAndroidçš„LRUCacheã€‚å·²ç»ä½¿ç”¨è¿‡çš„å†…å­˜ï¼Œæœªæ¥å¯èƒ½è¿˜è¦ç”¨ï¼Œæš‚æ—¶å­˜èµ·æ¥ Buffer: ç¼“å†²ï¼Œæœªæ¥ä¸€å®šä¼šç”¨ï¼Œæ¥ä¸åŠä½¿ç”¨/é¢„è¯»æå‡é€Ÿåº¦ã€‚å¦‚è§†é¢‘ç¼“å†² no-cache: å¯ä»¥ç¼“å­˜ï¼Œå†æ¬¡è®¿é—®è¯¥é¡µé¢æ—¶ï¼Œé‡æ–°è¯·æ±‚ no-store: ä¸è¦ç¼“å­˜ max-age: è¯·æ±‚ç»“æœå…·æœ‰ç”Ÿæ•ˆæ—¶é—´ private/private: æ¶ˆæ¯é“¾è·¯ä¸Šçš„å…¶ä»–è·¯ç”±èŠ‚ç‚¹æ˜¯å¦å¯ä»¥ç¼“å­˜è¿™ä¸ªæ¶ˆæ¯ Last-Modifiedèµ„æºæœ€è¿‘ä¸€æ¬¡æ›´æ–°çš„æ—¶é—´ï¼Œè‹¥æ›´æ–°äºè¯·æ±‚ä¹‹åï¼Œåˆ™èµ„æºå¤±æ•ˆ Etagç±»ä¼¼hashå€¼ï¼Œè‹¥ä¸ä¸€æ ·åˆ™èµ„æºå¤±æ•ˆ REST REST æ›´å¤šhttpç›¸å…³èµ„æº","link":"/home/2023/09/23/Android%E9%AB%98%E7%BA%A7/Android%20%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/02Http/"},{"title":"00-é¢è¯•æŸ¥æ¼è¡¥ç¼º","text":"Viewç»˜åˆ¶æµç¨‹å›¾ èµ·ç‚¹ï¼šViewRootImplåœ¨ViewRootImplä¸­æœ‰ä¸€ä¸ªå·¨é•¿çš„æ–¹æ³•performTraversalsï¼Œå…¶ä¸­ä¼šä¾æ¬¡è°ƒç”¨ä¸‰ä¸ªå‡½æ•° performMeasure performLayout performDraw é€šè¿‡ViewRootImplçš„setViewæ–¹æ³•ï¼ŒViewRootImplå¯¹è±¡ä¼šæ‹¥æœ‰ä¸€ä¸ªmViewå¯¹è±¡ åœ¨performMeasureæ–¹æ³•ä¸­ä¼šè°ƒç”¨mView.measure() 1234567891011121314private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) { if (mView == null) { return; } Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;); try { mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); } finally { Trace.traceEnd(Trace.TRACE_TAG_VIEW); } mMeasuredWidth = mView.getMeasuredWidth(); mMeasuredHeight = mView.getMeasuredHeight(); mViewMeasureDeferred = false;} åœ¨performLayoutæ–¹æ³•ä¸­ä¼šè°ƒç”¨mView.layout() 123456789101112131415161718192021private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) { mScrollMayChange = true; mInLayout = true; final View host = mView; if (host == null) { return; } if (DEBUG_ORIENTATION || DEBUG_LAYOUT) { Log.v(mTag, &quot;Laying out &quot; + host + &quot; to (&quot; + host.getMeasuredWidth() + &quot;, &quot; + host.getMeasuredHeight() + &quot;)&quot;); } Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;layout&quot;); try { host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); // ... // todo: åé¢è¿˜æœ‰ä¸€ä¸ªrequestLayoutï¼Œåç»­å¯ä»¥äº†è§£ä¸€ä¸‹ } // ...} åœ¨performDrawæ–¹æ³•ä¸­ä¼šé€šè¿‡performDraw-&gt;draw-&gt;drawSoftware-&gt;mView.draw()è°ƒç”¨mViewçš„drawæ–¹æ³• measureå’ŒonMeasureViewçš„measureå’ŒonMeasure12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public final void measure(int widthMeasureSpec, int heightMeasureSpec) { boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) { Insets insets = getOpticalInsets(); int oWidth = insets.left + insets.right; int oHeight = insets.top + insets.bottom; widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth); heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight); } // Suppress sign extension for the low bytes long key = (long) widthMeasureSpec &lt;&lt; 32 | (long) heightMeasureSpec &amp; 0xffffffffL; if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2); final boolean forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT; // Optimize layout by avoiding an extra EXACTLY pass when the view is // already measured as the correct size. In API 23 and below, this // extra pass is required to make LinearLayout re-distribute weight. final boolean specChanged = widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec; final boolean isSpecExactly = MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY &amp;&amp; MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY; final boolean matchesSpecSize = getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec) &amp;&amp; getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec); final boolean needsLayout = specChanged &amp;&amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize); if (forceLayout || needsLayout) { // first clears the measured dimension flag mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET; resolveRtlPropertiesIfNeeded(); int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key); if (cacheIndex &lt; 0 || sIgnoreMeasureCache) { // measure ourselves, this should set the measured dimension flag back onMeasure(widthMeasureSpec, heightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } else { long value = mMeasureCache.valueAt(cacheIndex); // Casting a long to int drops the high 32 bits, no mask needed setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value); mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } // flag not set, setMeasuredDimension() was not invoked, we raise // an exception to warn the developer if ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) { throw new IllegalStateException(&quot;View with id &quot; + getId() + &quot;: &quot; + getClass().getName() + &quot;#onMeasure() did not set the&quot; + &quot; measured dimension by calling&quot; + &quot; setMeasuredDimension()&quot;); } mPrivateFlags |= PFLAG_LAYOUT_REQUIRED; } mOldWidthMeasureSpec = widthMeasureSpec; mOldHeightMeasureSpec = heightMeasureSpec; mMeasureCache.put(key, ((long) mMeasuredWidth) &lt;&lt; 32 | (long) mMeasuredHeight &amp; 0xffffffffL); // suppress sign extension} å‚æ•°1234567891011121314151617181920212223public static class MeasureSpec { private static final int MODE_SHIFT = 30; private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT; /** * Measure specification mode: The parent has not imposed any constraint * on the child. It can be whatever size it wants. */ public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; /** * Measure specification mode: The parent has determined an exact size * for the child. The child is going to be given those bounds regardless * of how big it wants to be. */ public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; /** * Measure specification mode: The child can be as large as it wants up * to the specified size. */ public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT;} specæ˜¯specificationçš„ç¼©å†™ï¼Œæ„æ€æ˜¯è§„æ ¼ï¼Œä¸‰ç§æµ‹é‡è§„æ ¼ UNSPECIFIED: å¯¹å­viewæ— é™åˆ¶ EXACTLY: ä¸¥æ ¼æŒ‰ç…§çˆ¶viewçš„é™åˆ¶ AT_MOST: æœ€å¤§è¿™ä¹ˆå¤§ 123456789101112131415161718public static int makeMeasureSpec(@IntRange(from = 0, to = (1 &lt;&lt; MeasureSpec.MODE_SHIFT) - 1) int size, @MeasureSpecMode int mode) { if (sUseBrokenMakeMeasureSpec) { return size + mode; } else { return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); }}@MeasureSpecModepublic static int getMode(int measureSpec) { //noinspection ResourceType return (measureSpec &amp; MODE_MASK);}public static int getSize(int measureSpec) { return (measureSpec &amp; ~MODE_MASK);} 0-29ä½æ˜¯sizeï¼Œæœ€é«˜ä¸¤ä½æ‰æ˜¯mode onMeasuremeasureæ–¹æ³•çš„å†…å®¹æš‚æ—¶ä¸çœ‹é‡è¦çš„æ˜¯onMeasureï¼Œä»–æ˜¯éfinalçš„ï¼Œåœ¨è‡ªå®šä¹‰viewæ—¶ï¼Œä¼šç”¨åˆ° 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));} ViewGroupçš„onMeasureå‡½æ•°ViewGroupæœ¬èº«æ²¡æœ‰é‡å†™onMeasureï¼Œä»¥FrameLayoutä¸ºä¾‹ï¼Œä¼šè°ƒç”¨å­viewçš„measureæ–¹æ³•,æ ¹æ®è‡ªèº«çš„å¸ƒå±€è§„åˆ™ç¡®å®šå­viewçš„sizeå’Œmode 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int count = getChildCount(); final boolean measureMatchParentChildren = MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY || MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY; mMatchParentChildren.clear(); int maxHeight = 0; int maxWidth = 0; int childState = 0; for (int i = 0; i &lt; count; i++) { final View child = getChildAt(i); if (mMeasureAllChildren || child.getVisibility() != GONE) { measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin); maxHeight = Math.max(maxHeight, child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin); childState = combineMeasuredStates(childState, child.getMeasuredState()); if (measureMatchParentChildren) { if (lp.width == LayoutParams.MATCH_PARENT || lp.height == LayoutParams.MATCH_PARENT) { mMatchParentChildren.add(child); } } } } // Account for padding too maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground(); maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground(); // Check against our minimum height and width maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight()); maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth()); // Check against our foreground's minimum height and width final Drawable drawable = getForeground(); if (drawable != null) { maxHeight = Math.max(maxHeight, drawable.getMinimumHeight()); maxWidth = Math.max(maxWidth, drawable.getMinimumWidth()); } setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), resolveSizeAndState(maxHeight, heightMeasureSpec, childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT)); count = mMatchParentChildren.size(); if (count &gt; 1) { for (int i = 0; i &lt; count; i++) { final View child = mMatchParentChildren.get(i); final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec; if (lp.width == LayoutParams.MATCH_PARENT) { final int width = Math.max(0, getMeasuredWidth() - getPaddingLeftWithForeground() - getPaddingRightWithForeground() - lp.leftMargin - lp.rightMargin); childWidthMeasureSpec = MeasureSpec.makeMeasureSpec( width, MeasureSpec.EXACTLY); } else { childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, getPaddingLeftWithForeground() + getPaddingRightWithForeground() + lp.leftMargin + lp.rightMargin, lp.width); } final int childHeightMeasureSpec; if (lp.height == LayoutParams.MATCH_PARENT) { final int height = Math.max(0, getMeasuredHeight() - getPaddingTopWithForeground() - getPaddingBottomWithForeground() - lp.topMargin - lp.bottomMargin); childHeightMeasureSpec = MeasureSpec.makeMeasureSpec( height, MeasureSpec.EXACTLY); } else { childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, getPaddingTopWithForeground() + getPaddingBottomWithForeground() + lp.topMargin + lp.bottomMargin, lp.height); } child.measure(childWidthMeasureSpec, childHeightMeasureSpec); } }} layoutå’ŒonLayoutViewçš„layoutå’ŒonLayout1234567891011@SuppressWarnings({&quot;unchecked&quot;})public void layout(int l, int t, int r, int b) { int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); onLayout(changed, l, t, r, b);} setFrameä¼šæ ¹æ®l, r, t, bçš„å€¼ï¼Œæ›´æ–°mLeft, mTop, mBottom, mRight 12protected void onLayout(boolean changed, int left, int top, int right, int bottom) {} ViewGroupçš„onLayoutæ–¹æ³•123@Overrideprotected abstract void onLayout(boolean changed, int l, int t, int r, int b); å­ç±»å¯é€‰å®ç°å˜æˆå­ç±»å¿…é¡»å®ç° FrameLayoutçš„onLayout1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@Overrideprotected void onLayout(boolean changed, int left, int top, int right, int bottom) { layoutChildren(left, top, right, bottom, false /* no force left gravity */);}void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) { final int count = getChildCount(); final int parentLeft = getPaddingLeftWithForeground(); final int parentRight = right - left - getPaddingRightWithForeground(); final int parentTop = getPaddingTopWithForeground(); final int parentBottom = bottom - top - getPaddingBottomWithForeground(); for (int i = 0; i &lt; count; i++) { final View child = getChildAt(i); if (child.getVisibility() != GONE) { final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final int width = child.getMeasuredWidth(); final int height = child.getMeasuredHeight(); int childLeft; int childTop; int gravity = lp.gravity; if (gravity == -1) { gravity = DEFAULT_CHILD_GRAVITY; } final int layoutDirection = getLayoutDirection(); final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection); final int verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK; switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) { case Gravity.CENTER_HORIZONTAL: childLeft = parentLeft + (parentRight - parentLeft - width) / 2 + lp.leftMargin - lp.rightMargin; break; case Gravity.RIGHT: if (!forceLeftGravity) { childLeft = parentRight - width - lp.rightMargin; break; } case Gravity.LEFT: default: childLeft = parentLeft + lp.leftMargin; } switch (verticalGravity) { case Gravity.TOP: childTop = parentTop + lp.topMargin; break; case Gravity.CENTER_VERTICAL: childTop = parentTop + (parentBottom - parentTop - height) / 2 + lp.topMargin - lp.bottomMargin; break; case Gravity.BOTTOM: childTop = parentBottom - height - lp.bottomMargin; break; default: childTop = parentTop + lp.topMargin; } child.layout(childLeft, childTop, childLeft + width, childTop + height); } }} è®¡ç®—childçš„ltrbï¼Œä¾æ¬¡è°ƒç”¨å­ç±»çš„Layout draw,onDrawå’ŒdispatchDraw12345678910111213141516171819202122232425262728293031323334public void draw(Canvas canvas) { /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) * 7. If necessary, draw the default focus highlight */ drawBackground(canvas); saveCount = canvas.getSaveCount(); // Step 3, draw the content onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 5, draw the fade effect and restore layers // canvas.drawXXX canvas.restoreToCount(saveCount); // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // Step 7, draw the default focus highlight drawDefaultFocusHighlight(canvas);} åˆ†ä¸º7æ­¥ ç»˜åˆ¶èƒŒæ™¯ è·å–å½“å‰ç”»å¸ƒsaveæ¬¡æ•°,è®°å½•çŠ¶æ€ ç»˜åˆ¶å†…å®¹ï¼Œç”±onDrawå®ç° ç»˜åˆ¶å­view æ¢å¤æ­¥éª¤2çš„ç”»å¸ƒçŠ¶æ€ ç»˜åˆ¶å‰æ™¯ï¼Œæ»šåŠ¨æ¡ å¦‚æœè·å–äº†ç„¦ç‚¹ï¼Œç»˜åˆ¶ä¸€ä¸ªé«˜å…‰ 1234567/** * Implement this to do your drawing. * * @param canvas the canvas on which the background will be drawn */protected void onDraw(Canvas canvas) {} 123456789/** * Called by draw to draw the child views. This may be overridden * by derived classes to gain control just before its children are drawn * (but after its own view has been drawn). * @param canvas the canvas on which to draw the view */protected void dispatchDraw(Canvas canvas) {} ViewGroupçš„dispatchDraw123456789101112131415@Overrideprotected void dispatchDraw(Canvas canvas) { // ... for (int i = 0; i &lt; childrenCount; i++) { // ... final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex); if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) { more |= drawChild(canvas, child, drawingTime); } // ... } // ...} å…¶ä¸­drawChildä¼šè°ƒç”¨å­viewçš„drawæ–¹æ³•","link":"/home/2024/03/13/Android%E9%AB%98%E7%BA%A7/Android%20%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/00%E9%9D%A2%E8%AF%95%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA2/"},{"title":"01-å¤šçº¿ç¨‹","text":"java threadsynchronized ç±»é” ä¿®é¥°staticå‡½æ•°å’Œsynchronized(ClassName.class)éƒ½æ˜¯è·å–ç±»é” å¯¹è±¡é” ä¿®é¥°æˆå‘˜å‡½æ•°å’Œsynchronized(this|object)éƒ½æ˜¯å¯¹è±¡é” å…¶ä¸­ä¿®é¥°æˆå‘˜å‡½æ•°å’Œsynchronized(this)è·å–çš„éƒ½æ˜¯å½“å‰ç±»å¯¹è±¡çš„é” ä¼˜ç‚¹ ç®€å•ï¼Œæ˜“ç”¨ å¼€é”€å°‘ ç¼ºç‚¹ å¯é‡å…¥æ€§å·® å¤§é‡ä½¿ç”¨å¯èƒ½å¯¼è‡´æ€§èƒ½ä¸‹é™ æ¨èç”¨æ³• å•ä¾‹æ¨¡å¼ä½¿ç”¨ ç”¨äºè®¡æ•°å™¨çš„è‡ªå¢æˆ–ç±»ä¼¼åœºæ™¯ Object.wait, Object.notify, Object.notifyAllå‡½æ•°ä½œç”¨é¡¾åæ€ä¹‰ wait: å…ˆé‡Šæ”¾å¯¹è±¡é”ï¼Œç­‰å¾…notify/notifyAllåé‡Šæ”¾ä¹Ÿå°±æ˜¯è¯´ï¼Œå¯ä»¥åŸºäºä»–ä»¬å®ç°æ¡ä»¶å˜é‡, pvæ“ä½œ native join: è®©è°ƒç”¨çº¿ç¨‹ç­‰å¾…å…¶ç»“æŸ yeild: æš‚æ—¶è®©å‡ºæ—¶é—´ç‰‡ sleep: sleep interrupt: æ‰“æ–­æ‰§è¡Œ è°ƒç”¨åï¼Œçº¿ç¨‹ä¸­çš„ä¸€äº›ä»»åŠ¡å¯èƒ½äº§ç”ŸInterruptedException interrupted(): çº¿ç¨‹ä¸­åˆ¤æ–­æ˜¯å¦è¢«æ‰“æ–­ï¼Œè‹¥ä¸­æ–­ï¼Œè¿”å›trueï¼Œå¹¶æ¸…é™¤æ ‡å¿—ä½(ä¸‹ä¸€æ¬¡ä¸€å®šè¿”å›false),try-catch InterruptExceptionä¹Ÿä¼šå¯¼è‡´æ ‡å¿—ä½æ¸…é™¤ isInterrupted(): æµ‹è¯•æ˜¯å¦è¢«æ‰“æ–­ï¼Œè‹¥ä¸­æ–­ï¼Œè¿”å›trueï¼Œä½†ä¸æ¸…é™¤æ ‡å¿—ä½(ä¸‹ä¸€æ¬¡ä¸€å®šè¿”å›ä¸ä¸Šä¸€æ¬¡ç›¸åŒ) Callable å®ç°Callableï¼Œèƒ½è·å–è¿”å›çŠ¶æ€ å®ˆæŠ¤çº¿ç¨‹åœ¨start()å‰ï¼Œè°ƒç”¨setDaemon(true)å³å¯åˆ›å»ºã€‚ç±»ä¼¼äºå®ˆæŠ¤è¿›ç¨‹ï¼Œæ˜¯ä¸€ç›´å­˜åœ¨è¿è¡Œçš„çº¿ç¨‹ã€‚ç”±äºjvmçš„å­˜åœ¨ï¼Œè‹¥ä¸»çº¿ç¨‹é€€å‡ºï¼Œå…¶ä»–çº¿ç¨‹è¿è¡Œç»“æŸåä¼šé€€å‡ºï¼Œ å…¶ä»– ThreadLocal ç›¸å½“äºpthreadçš„æ¯çº¿ç¨‹å­˜å‚¨ ä¸€ä¸ªåŒ…è£…å™¨ï¼ŒåŒ…è£…ä»»ä½•ç±»å‹åï¼Œè°ƒç”¨get,setæ–¹æ³•ï¼Œè·å–/ä¿®æ”¹å½“å‰çº¿ç¨‹ä¸­çš„å€¼ javaçº¿ç¨‹ç”Ÿå‘½å‘¨æœŸ GC Rootsåœ¨GCæ—¶ï¼Œå¦‚ä½•åˆ¤æ–­ä¸€ä¸ªå¯¹è±¡æ˜¯å¦å¯å›æ”¶ï¼Œå°±æ˜¯çœ‹å…¶æ˜¯å¦ç›´æ¥/é—´æ¥è¢«GC Rootså¼•ç”¨ï¼ŒGC Rootsä¸€èˆ¬åŒ…æ‹¬ ç³»ç»Ÿç±»åŠ è½½å™¨åŠ è½½çš„ç±»: Class: Classes loaded by a system class loader; contains references to static variables as well å½“å‰æ ˆä¸­çš„å¯¹è±¡: Stack Local: Local variables and parameters to methods stored on the local stack æ´»è·ƒçš„çº¿ç¨‹: Active Java Threads: All active Java threads JNI(nativeä»£ç )å¼•ç”¨çš„å¯¹è±¡: JNI References: Native code Java objects created for JNI calls; contains local variables,parameters to JNI methods, and global JNI references Additionally, there are a few more possible types of GC Roots: ç›‘è§†å™¨ç›‘è§†çš„å¯¹è±¡: Objects used as monitors for synchronization ç”±JVMå®ç°å®šä¹‰çš„ç‰¹å®šå¯¹è±¡: Specific objects defined by the JVM implementation that are not garbage collected for its purpose. That might contain important exception classes, system class loaders, or custom class loaders å†…å­˜æ³„éœ²è¦æ³¨æ„å†…å­˜æ³„éœ²ï¼Œéé™æ€çš„å†…éƒ¨ç±»ä¼šæŒæœ‰å¤–éƒ¨çš„å¯¹è±¡ï¼Œè‹¥å†…éƒ¨ç±»æ˜¯ä¸€ä¸ªçº¿ç¨‹ï¼Œåˆ™ä¼šå¯¼è‡´å¤–éƒ¨å¯¹è±¡ï¼ˆå¦‚Activityï¼‰æ— æ³•é‡Šæ”¾ï¼Œå¯¼è‡´å†…å­˜æ³„éœ² å‡ ç§å¤šçº¿ç¨‹å·¥å…·çš„é€‰æ‹© AsyncTask(å·²å¼ƒç”¨): å°è€ŒçŸ­çš„ä»»åŠ¡ï¼Œåå°ä»»åŠ¡éœ€è¦æ¨åˆ°å‰å° Executor: æ¨èä½¿ç”¨ï¼Œåå°ä»»åŠ¡æ‰§è¡Œï¼Œä¸éœ€è¦æ¨å›å‰å° Handler: å¯ä»¥æŠŠä»»åŠ¡æ¨åˆ°å‰å° HandlerThread: æŠŠä¸€ä¸ªä»»åŠ¡æ¨åˆ°åå°çš„ä¸€ä¸ªçº¿ç¨‹ä¸­ Service: ä¸æ˜¯çº¿ç¨‹ï¼Œä»–æ˜¯åå°ä»»åŠ¡çš„æ´»åŠ¨ç©ºé—´ï¼ˆå­˜åå°ä»»åŠ¡çš„çŠ¶æ€ï¼‰ IntentService: çº¿ç¨‹ä¸­ä½¿ç”¨contextæ—¶ isInterrupted å’Œ interruptd123456789101112131415161718192021public boolean isInterrupted() { return interrupted;}public static boolean interrupted() { return currentThread().getAndClearInterrupt();}boolean getAndClearInterrupt() { boolean oldValue = interrupted; // We may have been interrupted the moment after we read the field, // so only clear the field if we saw that it was set and will return // true; otherwise we could lose an interrupt. if (oldValue) { interrupted = false; clearInterruptEvent(); } return oldValue;}private static native void clearInterruptEvent();","link":"/home/2023/09/21/Android%E9%AB%98%E7%BA%A7/Android%20%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/01%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"title":"04-ç™»å½•æˆæƒ Https TCP&#x2F;IP","text":"ç™»å½•æˆæƒBasicåœ¨headerä¸­Authorization: Basic username:password(Base64ed, encrypted) Beareråœ¨headerä¸­Authorization: Bearer bearer_token è¿™é‡Œçš„bearer_tokenå°±ç±»ä¼¼äºgithubçš„Personal access tokensï¼Œåœ¨è¯·æ±‚ä¸­æŒæœ‰tokençš„è¯·æ±‚ï¼Œå¯ä»¥æ ¹æ®tokençš„æƒé™å¯¹ç¬¬ä¸‰æ–¹è´¦å·ä¸­çš„æ•°æ®è¿›è¡Œè·å–ã€ä¿®æ”¹ å¯ä»¥é…ç½®tokençš„å¤±æ•ˆæ—¶é—´ï¼Œæƒé™å¤§å° å®¢æˆ·ç«¯ä½¿ç”¨Basicæ–¹å¼ç™»å½•åè·å–tokenï¼Œä¹‹åçš„è¯·æ±‚éƒ½ä½¿ç”¨è¯¥tokenï¼Œä¸å¿…è®°å½•ç”¨æˆ·çš„ç”¨æˆ·åå¯†ç ã€‚ OAuth2æµç¨‹åœ¨Beareræ–¹å¼çš„æˆæƒæ–¹å¼ä¸­ï¼Œç¬¬ä¸‰æ–¹ç½‘ç«™çš„tokenç›´æ¥å­˜å‚¨åœ¨ç”¨æˆ·ç«¯è®¾å¤‡ä¸Šæ˜¯ä¸å®‰å…¨çš„(ç›´æ¥å°†tokenè¿”å›ç»™ç”¨æˆ·ç«¯è®¾å¤‡ä¸å®‰å…¨ï¼‰ã€‚åœ¨OAuth2ä¸­ï¼Œè¿”å›access codeï¼Œç”¨æˆ·ç«¯å‘è‡ªå®¶æœåŠ¡å™¨æä¾›access codeï¼Œè‡ªå®¶æœåŠ¡å™¨ä½¿ç”¨access codeä»¥å®‰å…¨çš„httpsä¿¡é“å‘ç¬¬ä¸‰æ–¹æœåŠ¡å™¨è·å–tokenï¼Œå‚¨å­˜åœ¨æœåŠ¡å™¨ä¸­ï¼Œä¹‹åçš„å¯¹ç¬¬ä¸‰æ–¹è´¦å·çš„æ“ä½œå…¨éƒ¨ç”±æœåŠ¡å™¨ä»£åŠ³ã€‚ HTTPShttp over sslåŠ å¯†åï¼Œä»ä¼ è¾“å±‚çœ‹ï¼Œæ— æ³•åˆ¤æ–­å…¶æ˜¯å¦æ˜¯httpæ¶ˆæ¯ã€‚ å»ºç«‹è¿‡ç¨‹ Client Hello Server Hello æœåŠ¡å™¨ï¨¸è¯ä¹¦ ä¿¡ä»»å»ºâ½´ç«‹ Pre-master Secret å®¢æˆ·ç«¯é€šçŸ¥ï¼šå°†ä½¿â½¤ç”¨åŠ å¯†é€šä¿¡ å®¢æˆ·ç«¯å‘é€ï¼šFinished æœåŠ¡å™¨ï¨¸é€šçŸ¥ï¼šå°†ä½¿â½¤ç”¨åŠ å¯†é€šä¿¡ æœåŠ¡å™¨ï¨¸å‘é€ï¼šFinished ä¿¡ä»»å»ºç«‹è¯ä¹¦ä¸ºäº†è®©å®¢æˆ·ç«¯ç›¸ä¿¡æˆ‘æ˜¯æˆ‘ï¼Œéœ€è¦ä½¿ç”¨æ•°å­—ç­¾åï¼Œä½†æ˜¯åœ¨ä¸çŸ¥é“å¯¹æ–¹å…¬é’¥çš„æƒ…å†µä¸‹ï¼Œå¦‚ä½•è¯æ˜æˆ‘æ˜¯æˆ‘å‘¢ï¼Ÿéœ€è¦ä¸€ä¸ªæƒå¨æœºæ„å‘å…¶è¯æ˜ã€‚è¯æ˜çš„æ–¹å¼æ˜¯ï¼š ä½¿ç”¨æˆ‘çš„å…¬é’¥å¯ä»¥è¯æ˜æˆ‘æ˜¯æˆ‘ï¼Œä½†æ˜¯ä¸ºäº†é˜²æ­¢å…¶ä»–äººç”Ÿæˆå¯†é’¥æ¬ºéª—æˆ‘ï¼Œæˆ‘åœ¨æ¶ˆæ¯é‡Œæ·»åŠ æˆ‘çš„è¯ä¹¦é¢å¸ƒæ”¾çš„å…¬é’¥å³ç›¸å…³ä¿¡æ¯ã€‚ä½¿ç”¨é¢å¸ƒæ”¾çš„å…¬é’¥å¯ä»¥éªŒè¯æˆ‘çš„è¯ä¹¦é¢å¸ƒæ–¹æ˜¯æˆ‘çš„è¯ä¹¦é¢å¸ƒæ–¹ã€‚ä½†æ˜¯æˆ‘ä¾ç„¶å¯ä»¥ç”Ÿæˆä¸€ä¸ªé¢å¸ƒæ”¾çš„å¯†é’¥ï¼Œé¢å¸ƒæ–¹çš„ä¿¡æ¯ä¸­éœ€è¦æ”¾å…¥æ ¹è¯ä¹¦ã€‚æ¯å°æœºå™¨ä¸Šéƒ½ç”±æ‰€æœ‰æ ¹è¯ä¹¦çš„åˆ—è¡¨å’Œæ ¹è¯ä¹¦çš„å…¬é’¥ï¼Œä½¿ç”¨è¯¥å…¬é’¥å³å¯éªŒè¯æˆ‘çš„é¢å¸ƒæ–¹çš„é¢å¸ƒæ–¹æ˜¯æˆ‘çš„é¢å¸ƒæ–¹çš„é¢å¸ƒæ–¹ã€‚æ‰€ä»¥åªè¦ç³»ç»Ÿä¸­æœ‰æ ¹è¯ä¹¦ï¼Œæˆ‘å°±æ˜¯å¯ä¿¡ä»»çš„ã€‚ è¯ä¹¦æ˜¯ç”±è¯ä¹¦çš„é¢å¸ƒæœºæ„æ‰€ç­¾åçš„ æµç¨‹ HMACHMAC = Hash-based Message Authenticate Code å°±æ˜¯ä¸€ç§ä¸å®¹æ˜“è¢«ç ´è§£çš„Hashï¼ŒåŠ ç›ï¼Œä¸”æ˜¯åªæœ‰æ”¶å‘ä¸¤æ–¹çŸ¥é“çš„ç›","link":"/home/2023/09/26/Android%E9%AB%98%E7%BA%A7/Android%20%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/04%E7%99%BB%E5%BD%95%E6%8E%88%E6%9D%83_Https_TCPIP/"},{"title":"03-ç¼–ç åŠ å¯†Hashåºåˆ—åŒ–å’Œå­—ç¬¦é›†","text":"å–µè¯¾ç¨‹é‡Œæœ‰é™„å¸¦è®²ä¹‰ï¼Œå°±ä¸èŠ±æ—¶é—´è®°å½•äº†","link":"/home/2023/09/24/Android%E9%AB%98%E7%BA%A7/Android%20%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/03%E7%BC%96%E7%A0%81%E5%8A%A0%E5%AF%86Hash%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86%20copy/"},{"title":"05-Retrofit","text":"HOSTéªŒè¯åœ¨ä¸ŠèŠ‚httpsçš„caè¯ä¹¦éªŒè¯æ—¶ï¼Œå¦‚æœæŸä¸ªæ¶æ„ç½‘ç«™ç›´æ¥è·å–æ•´ä¸ªcaè¯ä¹¦ï¼Œå‘ç»™å…¶ä»–ç”¨æˆ·éª—å–ä¿¡ä»»æ€ä¹ˆåŠã€‚è¿™ä¸ªæ—¶å€™å°±éœ€è¦hostéªŒè¯ï¼Œå³è¯ä¹¦çš„hostä¸»æœºä¸å‘é€è¯ä¹¦çš„ä¸»æœºhostæ˜¯å¦æ˜¯åŒä¸€ä¸ªåŸŸåã€‚ fiddlerå¦‚ä½•æŠ“åŒ…fiddleræ˜¯ä¸€ä¸ªä¸­é—´äººï¼Œé€šè¿‡ç³»ç»Ÿä»£ç†ï¼Œæµè§ˆå™¨/åº”ç”¨å°†è¯·æ±‚å‘é€è‡³fiddlerï¼Œfiddlerè‡ªç­¾ä¸€ä¸ªè¯ä¹¦ä¸æµè§ˆå™¨/åº”ç”¨ä½¿ç”¨ï¼Œä¸”éœ€è¦ç”¨æˆ·å‘æ“ä½œç³»ç»Ÿå®‰è£…æ ¹è¯ä¹¦ã€‚fiddleræ‹¿åˆ°æ•°æ®åŒ…åå†ä¸æœåŠ¡å™¨äº¤äº’ã€‚ retrofitæºç é˜…è¯»retrofitçš„ä½¿ç”¨ æ³¨è§£: é€šè¿‡æ³¨è§£å¯¹Interfaceä¸­çš„æ–¹æ³•å’Œå‚æ•°è¿›è¡Œæ ‡æ³¨ã€‚å¦‚@GET @POST @PUTå®šä¹‰HTTPçš„æ–¹æ³•ç±»å‹ Converter: å¯¹è¯·æ±‚å’Œå“åº”çš„è½¬æ¢ï¼Œå¦‚æŠŠä¸€ä¸ªJavaçš„Fileä¸httpçš„Multipartäº’ç›¸è½¬åŒ– CallAdapter: é€‚é…å™¨ï¼Œæ¥å£çš„è¿”å›å€¼å¯èƒ½ä¸ºä¸€ä¸ªCall&lt;R&gt;å¯¹è±¡ï¼Œä¹Ÿå¯èƒ½æ˜¯RxJavaçš„Single,Observaleå¯¹è±¡ã€‚é€‚é…å™¨çš„ä½œç”¨å³æ˜¯å°†å“åº”ç±»å‹å’Œè¿”å›ç±»å‹åšé€‚é… Retrofit.create(Class&lt;T&gt;)Tå³ä¸ºå£°æ˜çš„æ¥å£ï¼Œcrateä¸­ä½¿ç”¨åå°„åˆ›å»ºäº†Tç±»å‹çš„å¯¹è±¡ã€‚ é¦–å…ˆåˆ¤æ–­æ˜¯å¦æ˜¯Objectçš„æ–¹æ³•ï¼Œå¦‚æœæ˜¯ï¼Œç›´æ¥è°ƒç”¨ å…¶æ¬¡åˆ¤æ–­æ˜¯å¦ä¸ºjava8çš„Default Methodï¼ˆå³æ¥å£å®ç°çš„æ–¹æ³•ï¼‰ï¼Œå¦‚æœæ˜¯ï¼Œç›´æ¥è°ƒç”¨ å¦‚æœä¸æ˜¯ï¼Œè¯´æ˜æ˜¯æ¥å£ï¼Œç”Ÿæˆ/ä»ç¼“å­˜ä¸­è·å–ServiceMethod&lt;?&gt; ï¼Œå¹¶è°ƒç”¨ã€‚ æ–¹æ³•çš„ç”Ÿæˆretrofitä¸ºæ¯ä¸ªmethodç”Ÿæˆäº†ä¸€ä¸ªServiceMethod&lt;?&gt;ï¼Œå­˜å‚¨åœ¨ä¸€ä¸ªconcurrentMapä¸­ï¼Œè°ƒç”¨æ—¶æ ¹æ®è°ƒç”¨æ–¹æ³•å¯»æ‰¾å¯¹è±¡ï¼Œå¹¶è°ƒç”¨å¯¹è±¡çš„invokeæ–¹æ³•ã€‚æ–¹æ³•ç”Ÿæˆçš„ä¸œè¥¿å¾ˆå¤šï¼Œä¸»è¦æ˜¯ï¼š åˆ†ææ³¨è§£ï¼šæ ¹æ®æ³¨è§£è¿›è¡Œåˆæ³•æ€§æ£€æŸ¥ æ ¹æ®æ³¨è§£æ„é€ RequestFactoryã€‚ç”¨äºOKHttpç”ŸæˆOKhttpçš„Call æ„é€ CallAdaptorï¼ŒæŠŠBodyå˜æˆè¿”å›å€¼ æ„é€ ResponseConverterï¼ŒæŠŠå“åº”è½¬åŒ–ä¸ºå“åº”bodyServiceMethod&lt;?&gt;çš„invokeæ–¹æ³•æ„é€ äº†OkHttpCall&lt;&gt;ï¼Œä»–å®ç°äº†OKhttpè¯·æ±‚çš„æ„é€ ï¼Œå¹¶é€šè¿‡okhttpå‘é€è¯·æ±‚ï¼Œæœ€åè°ƒç”¨adaptæ–¹æ³•å°†OKHTTPçš„å“åº”åšè½¬æ¢ã€‚adaptæ–¹æ³•æ˜¯æŠ½è±¡å‡½æ•°ï¼Œç”±ä¸‰ä¸ªå­ç±»å®ç°ï¼š SuspendForBody: è¿”å›å€¼ä¸æ˜¯responseç±»å‹ï¼Œç›´æ¥è¿”å›body SuspendForResponse: è¿”å›å€¼æ˜¯response CallAdapted: ä¸æ˜¯kotlinçš„suspendæ–¹æ³•ä»–ä»¬ä¸‰ä¸ªéƒ½å®ç°äº†adaptæ–¹æ³•ï¼Œä½¿ç”¨CallAdapterè¿›è¡Œè½¬æ¢ åŠ¨æ€ä»£ç†retrofitä¸­ï¼ŒExecutorCallbackCallå¯¹Callè¿›è¡Œäº†ä»£ç†ï¼Œè´Ÿè´£æŠŠåå°ä»»åŠ¡æ‹‰å›åˆ°å‰å°ã€‚æ ¹æ®ä¸åŒçš„å¹³å°ï¼Œåœ¨androidä¸­ä½¿ç”¨handlerã€‚ Adaptoré€‚é…å™¨ï¼Œåšè½¬æ¥ retrofitä¸­ï¼Œä¸åŒçš„CallAdaptorå®ç°ä¸åŒçš„è½¬æ¥æ–¹å¼ Factoryæ ¹æ®ä¸åŒçš„æ¡ä»¶ç”Ÿäº§ä¸åŒçš„å¯¹è±¡ åœ¨retrofitä¸­RequestFactory.Builderå¯ä»¥æ ¹æ®æ¥å£çš„æ³¨é‡Šï¼Œåˆ†æå‡ºè¯·æ±‚çš„urlï¼Œheaderï¼Œè¦ä¸è¦bodyç­‰ä¿¡æ¯ï¼Œå¹¶æ ¹æ®è¯¥ä¿¡æ¯åˆ›å»ºRequestFactoryã€‚Request Factoryå¯ä»¥ç”Ÿäº§Okhttp.Requestã€‚ Builderæœ‰äº›å¯¹è±¡å¾ˆé‡ï¼Œå…ˆæ„é€ å†ä¿®æ”¹å…¶ä¸­çš„å€¼å›å¾ˆè€—æ—¶ï¼Œbuilderå¯ä»¥æå‰å°†å€¼è®¾ç½®å¥½ï¼Œæ ¹æ®å€¼åšæ£€æŸ¥åæ„é€ å¯¹è±¡ é™¤äº†RequestFactoryï¼ŒRetrofitçš„æœ¬èº«ä¹Ÿæœ‰buidlerï¼Œé…ç½®ä¸åŒçš„Converterã€Adapter Abstract Factoryå°±æ˜¯æœ‰çˆ¶ç±»çš„å·¥å‚å‘—ï¼Œå­ç±»å·¥å‚è´Ÿè´£ç”Ÿäº§æŸä¸€ç§ç±»çš„äº§å“Retrofitçš„å„ç§Converterå°±æ˜¯æŠ½è±¡å·¥å‚çš„å…·ä½“å®ç°","link":"/home/2023/09/27/Android%E9%AB%98%E7%BA%A7/Android%20%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/05Retrofit/"},{"title":"06-OKHTTP","text":"1234567891011121314151617181920212223242526272829final Dispatcher dispatcher; // çº¿ç¨‹æ§åˆ¶final @Nullable Proxy proxy; // ä»£ç†æœåŠ¡å™¨ï¼Œjava.netfinal List&lt;Protocol&gt; protocols;final List&lt;ConnectionSpec&gt; connectionSpecs;final List&lt;Interceptor&gt; interceptors;final List&lt;Interceptor&gt; networkInterceptors;final EventListener.Factory eventListenerFactory;final ProxySelector proxySelector;final CookieJar cookieJar;final @Nullable Cache cache;final @Nullable InternalCache internalCache;final SocketFactory socketFactory;final SSLSocketFactory sslSocketFactory;final CertificateChainCleaner certificateChainCleaner;final HostnameVerifier hostnameVerifier;final CertificatePinner certificatePinner;final Authenticator proxyAuthenticator;final Authenticator authenticator;final ConnectionPool connectionPool;final Dns dns;final boolean followSslRedirects;final boolean followRedirects;final boolean retryOnConnectionFailure;final int callTimeout;final int connectTimeout;final int readTimeout;final int writeTimeout;final int pingInterval; websocketwikipedia: åˆ©ç”¨tcpæä¾›å…¨åŒå·¥é€šä¿¡ WebSocket is a computer communications protocol, providing full-duplex communication channels over a single TCP connection. è¿è¡Œåœ¨80/443ç«¯å£ä¸Š WebSocket is designed to work over HTTP ports 443 and 80 as well as to support HTTP proxies and intermediaries Dispatcher - çº¿ç¨‹æ§åˆ¶ä½¿ç”¨Dequeæ§åˆ¶ä»»åŠ¡ 123456789101112131415private int maxRequests = 64; // æœ€å¤§è¯·æ±‚æ•°private int maxRequestsPerHost = 5; // æ¯ä¸ªhostæœ€å¤§è¯·æ±‚æ•°private @Nullable Runnable idleCallback;/** Executes calls. Created lazily. */private @Nullable ExecutorService executorService;/** Ready async calls in the order they'll be run. */private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();/** Running asynchronous calls. Includes canceled calls that haven't finished yet. */private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();/** Running synchronous calls. Includes canceled calls that haven't finished yet. */private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); 123456789101112131415void enqueue(AsyncCall call) { synchronized (this) { readyAsyncCalls.add(call); // Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to // the same host. if (!call.get().forWebSocket) { AsyncCall existingCall = findExistingCallWithHost(call.host()); // å…ˆä»runningAsyncCallä¸­æ‰¾hostï¼Œæ²¡æ‰¾åˆ°å†ä»readyä¸­æ‰¾ if (existingCall != null) call.reuseCallsPerHostFrom(existingCall); // ç›¸åŒhostä½¿ç”¨åŒä¸€ä¸ªè®¡æ•°å™¨ } } promoteAndExecute();} 123456789101112131415161718192021222324252627private boolean promoteAndExecute() { assert (!Thread.holdsLock(this)); // å½“å‰çº¿ç¨‹æ²¡æœ‰æŒæœ‰thisçš„é” List&lt;AsyncCall&gt; executableCalls = new ArrayList&lt;&gt;(); boolean isRunning; synchronized (this) { for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) { AsyncCall asyncCall = i.next(); if (runningAsyncCalls.size() &gt;= maxRequests) break; // Max capacity. if (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) continue; // Host max capacity. i.remove(); asyncCall.callsPerHost().incrementAndGet(); executableCalls.add(asyncCall); runningAsyncCalls.add(asyncCall); } isRunning = runningCallsCount() &gt; 0; } // æŠŠreadyçš„è¯·æ±‚æå‡ä¸ºexecutableï¼Œæ¡ä»¶æ˜¯hostæ²¡åˆ°capacityï¼Œæ€»æ•°æ²¡åˆ°capacity for (int i = 0, size = executableCalls.size(); i &lt; size; i++) { AsyncCall asyncCall = executableCalls.get(i); asyncCall.executeOn(executorService()); // ä½¿ç”¨ExecutorServiceæ‰§è¡Œ } return isRunning;} 1234567public synchronized ExecutorService executorService() { // å•ä¾‹ï¼Œè·å–çº¿ç¨‹æ±  if (executorService == null) { executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false)); } return executorService;} AsyncCall - å¼‚æ­¥è¯·æ±‚1234final class AsyncCall extends NamedRunnable { private final Callback responseCallback; //å›è°ƒ private volatile AtomicInteger callsPerHost = new AtomicInteger(0); //hostè®¡æ•°} æ‰¿æ¥ä¸Šæ–‡çš„executeOnï¼Œä½¿ç”¨çº¿ç¨‹æ± æ‰§è¡Œ 1234567891011121314151617void executeOn(ExecutorService executorService) { assert (!Thread.holdsLock(client.dispatcher())); boolean success = false; try { executorService.execute(this); success = true; } catch (RejectedExecutionException e) { InterruptedIOException ioException = new InterruptedIOException(&quot;executor rejected&quot;); ioException.initCause(e); transmitter.noMoreExchanges(ioException); responseCallback.onFailure(RealCall.this, ioException); } finally { if (!success) { client.dispatcher().finished(this); // This call is no longer running! } }} çº¿ç¨‹æ± æ‹¿åˆ°runnableï¼Œè°ƒç”¨runï¼ŒNamedRunnableè°ƒç”¨execute 1234567891011121314151617181920212223242526272829@Override protected void execute() { boolean signalledCallback = false; transmitter.timeoutEnter(); try { Response response = getResponseWithInterceptorChain(); // æ ¸å¿ƒï¼è°ƒç”¨interceptorï¼Œé€å±‚æ‰§è¡Œï¼Œè·å¾—å“åº” signalledCallback = true; responseCallback.onResponse(RealCall.this, response); // å›è°ƒ } catch (IOException e) { if (signalledCallback) { // Do not signal the callback twice! Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e); } else { responseCallback.onFailure(RealCall.this, e); //å›è°ƒ } } catch (Throwable t) { cancel(); if (!signalledCallback) { IOException canceledException = new IOException(&quot;canceled due to &quot; + t); canceledException.addSuppressed(t); responseCallback.onFailure(RealCall.this, canceledException); } throw t; } finally { client.dispatcher().finished(this); // é€šçŸ¥dispatcherç»“æŸï¼Œå¯¹ä¸¤ä¸ªcapacity decrement // ä»ç›¸åº”çš„é˜Ÿåˆ—ä¸­åˆ é™¤ä»»åŠ¡ // å†æ¬¡è°ƒç”¨promoteAndExecuteï¼Œä¸ºçº¿ç¨‹æ± æ·»åŠ ä»»åŠ¡ }} åˆ›å»ºæ‹¦æˆªå™¨ï¼Œå¹¶å¼€å§‹ä¸€å±‚å±‚æ‰§è¡Œ 12345678910111213141516171819202122232425262728293031323334Response getResponseWithInterceptorChain() throws IOException { // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(new RetryAndFollowUpInterceptor(client)); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) { interceptors.addAll(client.networkInterceptors()); } interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, transmitter, null, 0, originalRequest, this, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); boolean calledNoMoreExchanges = false; try { Response response = chain.proceed(originalRequest); if (transmitter.isCanceled()) { closeQuietly(response); throw new IOException(&quot;Canceled&quot;); } return response; } catch (IOException e) { calledNoMoreExchanges = true; throw transmitter.noMoreExchanges(e); } finally { if (!calledNoMoreExchanges) { transmitter.noMoreExchanges(null); } }} interceptor - æ‹¦æˆªå™¨RealInterceptorChain123456789101112131415161718192021@Override public Response proceed(Request request) throws IOException { return proceed(request, transmitter, exchange);}public Response proceed(Request request, Transmitter transmitter, @Nullable Exchange exchange) throws IOException { /* æ£€æŸ¥proceedåªè¢«è°ƒç”¨ä¸€æ¬¡ */ // Call the next interceptor in the chain. RealInterceptorChain next = new RealInterceptorChain(interceptors, transmitter, exchange, index + 1, request, call, connectTimeout, readTimeout, writeTimeout); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); /* æ£€æŸ¥proceedåªè¢«è°ƒç”¨ä¸€æ¬¡ */ /* æ£€æŸ¥responseï¼Œbodyä¸ä¸ºç©º */ return response;} XXXInterceptor - å¯¹äºä¸€èˆ¬çš„Interceptorå®ç°12345678@Override public Response intercept(Chain chain) throws IOException { /* do task0 */ Request request = chain.request(); /* do your task1 */ Response response = chain.proceed(request); /* do your task2 */ return response;} interceptorè·å¾—chainï¼Œå°±æ˜¯æ•´ä¸ªinterceptorçš„é“¾æ¡ï¼Œchainçš„requestè·å–è¯·æ±‚ï¼Œå¯¹è¯·æ±‚å¤„ç†åï¼Œè°ƒç”¨proceedï¼Œå°†è¯·æ±‚å¤„ç†ç»™ä¸‹ä¸€ä¸ªinterceptorï¼Œå¹¶è¿”å›responseï¼Œåœ¨å¯¹å“åº”å¤„ç†åï¼Œå°†responseè¿”å›ã€‚æ¯ä¸ªinterceptorå¯¹è±¡é…åˆä¸€ä¸ªRealInterceptorChainå·¥ä½œã€‚RealInterceptorChainæ˜¯ä¸€ä¸ªchainï¼Œï¼ˆä¹Ÿå°±æ˜¯interceptorçš„å‚æ•°ï¼‰ï¼ŒRealInterceptorChainä¿å­˜ä¸Šä¸€çº§çš„request interceptoré€šè¿‡è°ƒç”¨RealInterceptorChainçš„proceedå‡½æ•°ä¼ é€’è‡ªå·±å¤„ç†çš„requestï¼Œproceedå‡½æ•°åˆ›å»ºä¸‹ä¸€ä¸ªinterceptorçš„RealInterceptorChainï¼Œå¹¶è°ƒç”¨interceptorçš„interceptï¼Œè¿™æ ·ä¸‹ä¸€ä¸ªinterceptåˆä¼šè°ƒç”¨requestè·å–requestï¼Œç„¶åè°ƒç”¨proceedä¼ é€’å¤„ç†åçš„è¯·æ±‚ï¼Œå¾—åˆ°responseã€‚æ¯ä¸ªinterceptorè°ƒç”¨proceedè·å¾—å“åº”å¹¶å¤„ç†åï¼Œå°†è‡ªå·±å¤„ç†åçš„è¯·æ±‚è¿”å›ç»™ä¸Šä¸€çº§çš„RealInterceptorChain.proceedï¼Œä¸Šä¸€çº§çš„RealInterceptorChain.proceedåˆå°†å…¶è¿”å›ç»™ä¸Šä¸€çº§çš„interceptå‡½æ•° ConnectionSpec - è¿æ¥é…ç½®CertificatePinner - è‡ªç­¾åéªŒè¯Authenticator - ç™»å½•connectionPoolDNSfollowxxxredirectpingInterval - websocketçš„å¿ƒè·³é—´éš” ä¸€æ–¹å‘ping and ä¸€æ–¹å‘pong","link":"/home/2023/10/10/Android%E9%AB%98%E7%BA%A7/Android%20%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/06okhttp/"},{"title":"18-Javaå¤šçº¿ç¨‹","text":"Thread, Runnable, callable åŸºç¡€ ThreadFactory123public interface ThreadFactory { Thread newThread(Runnable r);} å®ç°ä¸€ä¸ªå·¥å‚ï¼Œç”Ÿæˆthreadï¼Œæ–¹ä¾¿å¯¹åŒç±»threadè¿›è¡Œç»Ÿä¸€çš„åˆå§‹åŒ–æ“ä½œ Executor è§æ€ç»´å¯¼å›¾ï¼Œã€ŠJavaæ ¸å¿ƒåŸºç¡€12å·ã€‹çš„ç¬”è®° synchronized å›ºæœ‰é”å’Œæ¡ä»¶ ä½œç”¨ æ§åˆ¶è¿›ç¨‹ä¹‹é—´äº’æ–¥è®¿é—® ä¿è¯ç›‘æ§ä¸­çš„æ•°æ®è¢«å†™å›å†…å­˜ éå…¬å¹³é”ï¼šå…ˆæŠ¢é”å†æ’é˜Ÿ ä¸ReentrantLockçš„åŒºåˆ«ä¸¤è€…çš„ä¸åŒç‚¹ï¼š ReentrantLock æ˜¾ç¤ºçš„è·å¾—ã€é‡Šæ”¾é”ï¼Œsynchronized éšå¼è·å¾—é‡Šæ”¾é” ReentrantLock å¯å“åº”ä¸­æ–­ã€å¯è½®å›ï¼Œsynchronized æ˜¯ä¸å¯ä»¥å“åº”ä¸­æ–­çš„ï¼Œä¸ºå¤„ç†é”çš„ä¸å¯ç”¨æ€§æä¾›äº†æ›´é«˜çš„çµæ´»æ€§ ReentrantLock æ˜¯API çº§åˆ«çš„ï¼Œsynchronized æ˜¯ JVM çº§åˆ«çš„ ReentrantLock å¯ä»¥å®ç°å…¬å¹³é” ReentrantLock é€šè¿‡ Condition å¯ä»¥ç»‘å®šå¤šä¸ªæ¡ä»¶ åº•å±‚å®ç°ä¸ä¸€æ ·ï¼Œ synchronized æ˜¯åŒæ­¥é˜»å¡ï¼Œä½¿ç”¨çš„æ˜¯æ‚²è§‚å¹¶å‘ç­–ç•¥ï¼Œlock æ˜¯åŒæ­¥éé˜»å¡ï¼Œé‡‡ç”¨çš„æ˜¯ä¹è§‚å¹¶å‘ç­–ç•¥ Lock æ˜¯ä¸€ä¸ªæ¥å£ï¼Œè€Œ synchronized æ˜¯ Java ä¸­çš„å…³é”®å­—ï¼Œsynchronized æ˜¯å†…ç½®çš„è¯­è¨€å®ç°ã€‚ synchronized åœ¨å‘ç”Ÿå¼‚å¸¸æ—¶ï¼Œä¼šè‡ªåŠ¨é‡Šæ”¾çº¿ç¨‹å æœ‰çš„é”ï¼Œå› æ­¤ä¸ä¼šå¯¼è‡´æ­»é”ç°è±¡å‘ç”Ÿï¼› è€Œ Lock åœ¨å‘ç”Ÿå¼‚å¸¸æ—¶ï¼Œå¦‚æœæ²¡æœ‰ä¸»åŠ¨é€šè¿‡ unLock()å»é‡Šæ”¾é”ï¼Œåˆ™å¾ˆå¯èƒ½é€ æˆæ­»é”ç°è±¡ï¼Œ å› æ­¤ä½¿ç”¨ Lock æ—¶éœ€è¦åœ¨finally å—ä¸­é‡Šæ”¾é”ã€‚ Lock å¯ä»¥è®©ç­‰å¾…é”çš„çº¿ç¨‹å“åº”ä¸­æ–­ï¼Œè€Œ synchronized å´ä¸è¡Œï¼Œä½¿ç”¨synchronized æ—¶ï¼Œ ç­‰å¾…çš„çº¿ç¨‹ä¼šä¸€ç›´ç­‰å¾…ä¸‹å»ï¼Œä¸èƒ½å¤Ÿå“åº”ä¸­æ–­ã€‚ é€šè¿‡ Lock å¯ä»¥çŸ¥é“æœ‰æ²¡æœ‰æˆåŠŸè·å–é”ï¼Œè€Œ synchronized å´æ— æ³•åŠåˆ°ã€‚ Lock å¯ä»¥æé«˜å¤šä¸ªçº¿ç¨‹è¿›è¡Œè¯»æ“ä½œçš„æ•ˆç‡ï¼Œæ—¢å°±æ˜¯å®ç°è¯»å†™é”ç­‰ã€‚ ä¹è§‚é”å’Œæ‚²è§‚é”ï¼ˆæ•°æ®åº“ï¼‰ ä¹è§‚é”ï¼šè®¤ä¸ºå¾ˆå°‘ä¼šå‘ç”Ÿå†²çªï¼Œåœ¨æ“ä½œæ—¶ä¸åŠ é”ï¼Œåœ¨å†™å…¥æ—¶è§‚å¯Ÿæ•°æ®ä¸ä¹‹å‰è¯»å–æ—¶æ˜¯å¦ç›¸åŒï¼Œç›¸åŒåˆ™ç›´æ¥å†™å›ï¼Œä¸ç›¸åŒåˆ™é‡æ–°æ“ä½œä¸€æ¬¡ æ‚²è§‚é”ï¼šä»¥æ¯æ¬¡åœ¨æ‹¿æ•°æ®çš„æ—¶å€™éƒ½ä¼šä¸Šé” å…¬å¹³é”éå…¬å¹³é” å…¬å¹³é”ï¼šæŒ‰è§„åˆ™æ’é˜Ÿç­‰é”ï¼Œå€¾å‘äºè°ƒåº¦ç­‰å¾…æ—¶é—´æœ€é•¿çš„çº¿ç¨‹ éå…¬å¹³é”ï¼šå…ˆç«äº‰é”ï¼Œå†æ’é˜Ÿ ReetrentLock è·å–æ¡ä»¶ è·å–è¯»å†™é”","link":"/home/2024/03/11/Android%E9%AB%98%E7%BA%A7/Android%20%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/18Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"title":"07-è‡ªå®šä¹‰view-ç»˜åˆ¶","text":"åæ ‡è½´ å°ºå¯¸å•ä½ ä¸€å¾‹ä¸ºåƒç´  apiCanvasç”»å¸ƒ 123456789101112131415drawLinedrawCircledrawOvaldrawBitmapdrawPathdrawdrawArc // ä»¥ä¸€ä¸ªçŸ©å½¢ç©ºé—´ä¸ºå‚è€ƒï¼ŒæŒ‡å®šèµ·å§‹è§’åº¦å’Œç»ˆæ­¢è§’åº¦ï¼Œç”»ä¸€ä¸ªå¼§çº¿save // ä¿å­˜ç”»å¸ƒçŠ¶æ€ï¼ˆæ ˆtranslate // ç§»åŠ¨ç”»å¸ƒï¼Œå…¶ä»–å˜æ¢è¿˜æœ‰translate,scale,rotate,skew,concat or clipRectç­‰restore //å¼¹æ ˆï¼Œæ¢å¤ç”»å¸ƒ// ç§»åŠ¨ç”»å¸ƒä¸ä¼šå½±å“å·²ç»ç»˜åˆ¶çš„å›¾å½¢çš„ä½ç½®ï¼Œrestoreä¹Ÿæ˜¯saved = saveLayer() // ä¸ºç”»å¸ƒæ–°å»ºå›¾å±‚ï¼Œå½“ä½¿ç”¨xfermodeèåˆå›¾åƒæ—¶ï¼Œå¦‚æœç›´æ¥åœ¨æ—§å›¾å±‚ä¸Šç»˜åˆ¶ï¼Œæ—§å›¾å±‚ä¼šé€ æˆå¹²æ‰°// åœ¨æ–°å›¾å±‚ä¸Šæ“ä½œrestoreToCount(saved) // æ¢å¤ç”»å¸ƒåˆ°ä¿å­˜çš„çŠ¶æ€ Path1234addRectaddCircleaddOvaladdRoundRect é€šè¿‡canvas.drawPathå°†pathç»˜åˆ¶ ç»˜åˆ¶æ–¹å‘1path.setFillType 123456789101112131415161718192021222324252627public enum FillType { // these must match the values in SkPath.h /** * Specifies that &quot;inside&quot; is computed by a non-zero sum of signed * edge crossings. */ WINDING (0), /** * Specifies that &quot;inside&quot; is computed by an odd number of edge * crossings. */ EVEN_ODD (1), /** * Same as {@link #WINDING}, but draws outside of the path, rather than inside. */ INVERSE_WINDING (2), /** * Same as {@link #EVEN_ODD}, but draws outside of the path, rather than inside. */ INVERSE_EVEN_ODD(3); FillType(int ni) { nativeInt = ni; } final int nativeInt;} ä½œç”¨åˆ¤æ–­ä¸€ä¸ªç‚¹æ˜¯å¦åœ¨å›¾å½¢å†…éƒ¨ ä»è¯¥ç‚¹å‘ä»»æ„æ–¹å‘å‘å°„å°„çº¿ï¼Œè·¯å¾„ä¸Šæ‰€æœ‰ç›¸äº¤è€Œéç›¸åˆ‡çš„ä½ç½®ä¸­ï¼Œè‹¥ä»å·¦ä¾§ç©¿è¿‡å°„çº¿ï¼Œcnt++ï¼Œå³ä¾§ç©¿è¿‡ï¼Œcntâ€“ã€‚è‹¥ä½¿ç”¨WINDINGï¼Œæœ€ç»ˆcntä¸º0ï¼Œåˆ™æ˜¯åœ¨å¤–éƒ¨ï¼Œå¦åˆ™åœ¨å†…éƒ¨ï¼›è‹¥ä½¿ç”¨EVEN_ODDï¼Œæœ€ç»ˆcntä¸ºå¥‡æ•°ï¼Œç‚¹åœ¨å†…éƒ¨ï¼Œä¸ºå¶æ•°ï¼Œç‚¹åœ¨å¤–éƒ¨ å¦‚æœä½¿ç”¨WINDINGï¼Œéœ€è¦ä¸¤ä¸ªå›¾å½¢ç›¸å‡çš„æ“ä½œï¼Œåˆ™å°†ä¸¤ä¸ªå›¾å½¢çš„ç»˜åˆ¶æ–¹å‘è®¾ä¸ºç›¸åçš„ï¼Œè¿™æ ·ç›¸äº¤éƒ¨åˆ†çš„ç‚¹å°±è¢«è®¤ä¸ºåœ¨å›¾å½¢å¤–éƒ¨ï¼Œè€Œä¸ä¼šè¢«æ¶‚è‰²ã€‚ å¦‚æœä½¿ç”¨EVEN_ODDï¼Œéœ€è¦ä¸¤ä¸ªå›¾å½¢ç›¸å‡çš„æ“ä½œï¼Œä¸éœ€è¦å¤„ç†å…¶ç»˜åˆ¶æ–¹å‘ View.onSizeChangedæ¯æ¬¡layoutå°ºå¯¸æ”¹å˜æ—¶ä¼šè°ƒç”¨ PathMeasureæµ‹é‡ä¸€ä¸ªpathï¼Œ 12getLength // æ•´ä¸ªå›¾åƒçš„å‘¨é•¿getPosTan // è·å¾—ä»èµ·ç‚¹è§¦å‘ï¼Œç»˜åˆ¶æŸä¸ªé•¿åº¦åçš„ç‚¹æ‰€å’‹ä½ç½®çš„æ­£åˆ‡å€¼ ç”¨å¤„æ¯”å¦‚è¦åšä¸€ä¸ªä»ªè¡¨ç›˜ï¼Œåœ¨æŸä¸ªä½ç½®ç”»åˆ»åº¦ï¼Œéœ€è¦æ€»é•¿åº¦è®¡ç®—åˆ»åº¦çš„é—´éš” misc javaé‡Œä¹Ÿæœ‰ç±»ä¼¼kotlinçš„init{}ï¼Œåªè¦åœ¨ç±»ä¸­ç›´æ¥ä½¿ç”¨{}å³å¯ 12345class XXX { { // init codes }} BitmapFactry.Options options.inJustDecodeBounds, åªè·å–é•¿å®½ï¼Œä¸åŠ åœ¨èµ„æº Xfermode æ˜¯ä¸€ç§å›¾åƒæ··åˆæ¨¡å¼ paintç”»ç¬”ï¼Œå®šä¹‰ç»˜åˆ¶æ—¶çš„å„ç§ç‰¹æ€§ 12setPathEffect // ä½¿ç”¨ä¸€ä¸ªpathä½œä¸ºç»˜åˆ¶çš„æ•ˆæœsetStyle dp2px1TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dip, Resources.getSystem().displayMetrics) æ³¨æ„è¿™é‡Œé€šè¿‡getSystemè·å–çš„Resourcesæ˜¯æ— æ³•è·å–åº”ç”¨ä¸­å®šä¹‰çš„colorsï¼Œstringsç­‰èµ„æºçš„å®˜æ–¹æ–‡æ¡£å¯¹å…¶çš„æè¿°æ˜¯: Return a global shared Resources object that provides access to only system resources (no application resources), is not configured for the current screen (can not use dimension units, does not change based on orientation, etc), and is not affected by Runtime Resource Overlay. ç»ƒä¹ PieChartDashBoardAvatarView(drawbitmap)","link":"/home/2023/10/24/Android%E9%AB%98%E7%BA%A7/Android%20%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/07%E8%87%AA%E5%AE%9A%E4%B9%89view-%E7%BB%98%E5%88%B6/"},{"title":"20-Androidå¤šçº¿ç¨‹","text":"Thread.yield() æš‚æ—¶æŠŠæ—¶é—´ç‰‡è®©å‡ºå»ï¼Œå˜æˆå¯è¿è¡ŒçŠ¶æ€(ready) handlerLooper ThreadLocalçš„ ç›¸å½“äºä¸€ä¸ªçº¿ç¨‹é‡Œçš„å¤§å¾ªç¯ åœ¨å¤§å¾ªç¯é‡Œå¾ªç¯ä»messageQueueä¸­æ‹¿æ¶ˆæ¯ æ‹¿åˆ°æ¶ˆæ¯åæ‰§è¡Œæ¶ˆæ¯ Handler æŒæœ‰messageQueueï¼Œé€šè¿‡postå°†Runnableå˜æˆMessageï¼Œæ ¹æ®whenåŠ å…¥åˆ°messageQueueä¸­ messageQueue ä¸€ä¸ªé˜Ÿåˆ—ï¼Œç”¨é“¾è¡¨ç»´æŠ¤çš„ æ¯ä¸ªæ¶ˆæ¯åŒ…å«runnableå’Œå¯¹åº”çš„handler","link":"/home/2024/03/11/Android%E9%AB%98%E7%BA%A7/Android%20%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/20Android%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"title":"19-RecyclerView","text":"RecyclerView flexible: limited: æœ‰é™å±å¹•ä¸­æ˜¾ç¤º large: å¤§é‡å†…å®¹ RecyclerViewçš„ä¼˜åŠ¿ Linear, Grid, Staggered Gridä¸‰ç§å¸ƒå±€ itemAnimatoræ¥å£ å¼ºåˆ¶å®ç°ViewHolder è§£è€¦è®¾è®¡ æ€§èƒ½æ›´å¥½ listViewçš„å±€é™ åªèƒ½çºµå‘åˆ—è¡¨ æ²¡æœ‰åŠ¨ç”»api apiè®¾è®¡å¤ªä¸ªæ€§äº†ï¼Œå’Œå…¶ä»–viewè®¾è®¡çš„é‡å¤ æ€§èƒ½ä¸å¥½ ä¸‰ä¸ªå¸®æ‰‹ LayoutManager: è´Ÿè´£å¸ƒå±€Views ItemAnimator: è´Ÿè´£ç»™ViewåŠ åŠ¨ç”» Adaptor: æä¾›views ViewHolder ä¸€ä¸ªItemViewå¯¹åº”ä¸€ä¸ªViewholderï¼ˆç¼“å­˜viewï¼Œé˜²æ­¢åå¤findViewByIdï¼‰ RecycclerViewç¼“å­˜æœºåˆ¶ å¯¹ViewHolderè¿›è¡Œç¼“å­˜ï¼Œå››çº§ç¼“å­˜ï¼Œä»ä¸Šåˆ°ä¸‹ scrap: å±å¹•å†…çš„ItemView, é€šè¿‡positionæ‰¾åˆ°ï¼Œä¸”æ•°æ®ä¾ç„¶æœ‰æ•ˆï¼Œå¯ä»¥ç›´æ¥å¤ç”¨ cache: é»˜è®¤ä¸º2,åˆšå‡ºå±å¹•çš„Itemè¿›è¡Œç¼“å­˜ï¼Œæ•°æ®ä¹Ÿæ˜¯cleançš„ï¼Œé€šè¿‡posæ‰¾åˆ° ViewCacheExtension: ç¼“å­˜å‡ ä¸ªå›ºå®šä¸å˜çš„ï¼Œå¤æ‚çš„itemï¼Œæ¯æ¬¡å¯ä»¥é‡å¤ä½¿ç”¨ RecycledViewPool: dirtyæ•°æ®ï¼Œéœ€è¦é‡æ–°ç»‘å®šæ•°æ®ï¼Œæ ¹æ®view typeç¼“å­˜ å¯¹itemå±•ç¤ºæ¬¡æ•°çš„ç»Ÿè®¡ ListView: getViewç»Ÿè®¡ RecyclerView: onViewAttachedToWindowç»Ÿè®¡ æ€§èƒ½ä¼˜åŒ– itemç›‘å¬ï¼šonCreateViewHolderæ—¶åˆ›å»ºï¼ˆå…¨éƒ¨å…±äº«ä¸€ä¸ªã€æ¯ä¸ªå¯¹è±¡ä¸€ä¸ªï¼‰ LinearLayoutManager.setInitialPrefetchItemCount(): éœ€è¦åœ¨ItemViewä¸­åˆ›å»ºå­RecyclerView RenderThreadï¼ˆåšæ¸²æŸ“çš„çº¿ç¨‹ï¼‰ä¸­ï¼Œä¼šåšRecyclerViewçš„prefetch æŒ‡å®šåˆå§‹çœ‹åˆ°æ—¶éœ€è¦æ˜¾ç¤ºçš„itemæ•°ç›® åœ¨å†…éƒ¨åµŒå¥—çš„viewä¸­è°ƒç”¨ RecyclerView.setHasFixedSize() RecyclerViewæœ‰æ•°æ®æ’å…¥ã€åˆ é™¤æ—¶ï¼Œæ ¹æ®è¿™ä¸ªflagé€‰æ‹©æ˜¯å¦é‡ç»˜æ•´ä¸ªRecyclerView å¦‚æœAdapteræ•°æ®å˜åŒ–ä¸ä¼šå½±å“RecyclerViewçš„å¤§å°å˜åŒ–æ—¶ï¼Œè®¾ç½®ä¸ºtrue å¤šä¸ªRecyclerViewæœ‰ç›¸åŒçš„viewTypeï¼Œå¤šä¸ªRecyclerViewå…±äº«RecycledViewPool DiffUtil è®¡ç®—ä¸¤ä¸ªlistçš„åŒºåˆ«å¹¶ç”ŸæˆæŠŠAåˆ—è¡¨è½¬æ¢ä¸ºBåˆ—è¡¨çš„æ“ä½œ è§£å†³çš„é—®é¢˜ï¼šæœ€å°åŒ–æ›´æ–°é¡µé¢çš„æ“ä½œï¼ŒèŠ‚çœè®¡ç®—èµ„æº notifyItemXXXä¸é€‚ç”¨äºæ‰€æœ‰æƒ…å†µ notifyDateSetChange: æ•´ä¸ªlisté‡æ–°ç»˜åˆ¶+åŠ¨ç”»ä¸¢å¤± åœ¨åˆ—è¡¨å¾ˆå¤§æ—¶ï¼Œå¼‚æ­¥è®¡ç®—diff Threadï¼Œ handler RxJava ListAdapterï¼Œ AsyncListDiffer payloadsView TypeItemDecoration ç”»åˆ†å‰²çº¿ é«˜äº® åˆ†ç»„ RecyclerViewå„ç§ç”¨æ³•çš„demoAdvancedRecyclerView function resize_iframe(div) { const width = div.offsetWidth; div.style.height = div.offsetWidth*4.0/3.0 + 'px'; // console.log(\"resize height : \" + div.style.height) } const div = document.getElementById('RecyclerViewIframe'); resize_iframe(div); window.addEventListener('resize', function() { resize_iframe(div); });","link":"/home/2024/03/12/Android%E9%AB%98%E7%BA%A7/Android%20%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/19RecyclerView/"},{"title":"01-Flutter-å¿«é€Ÿå…¥é—¨å®æˆ˜","text":"flutter everything is a widget widgetåœ¨flutterä¸­ï¼Œæ‰€æœ‰çœ‹å¾—è§çš„çœ‹ä¸è§çš„ä¸œè¥¿éƒ½æ˜¯widget ç›®å½•ç»“æ„ android: ios: lib: dartæ–‡ä»¶ï¼Œä¸šåŠ¡é€»è¾‘ lib/main.dart: å…¥å£ pubspec.yaml: å·¥ç¨‹ä¿¡æ¯ä»¥åŠä¾èµ– ä¾èµ–å£°æ˜pubspec.yamlä¸­ 123456789dependencies: package_name: [version_code] package_name: ^[version_code] # ^çš„ä½œç”¨æ˜¯è®©ç³»ç»Ÿé€‰æ‹©æ›´é«˜ä¸”ä¸version_codeç›¸å…¼å®¹çš„ç‰ˆæœ¬ packge_name: [git_url] packge_name: [local path]dev_dependencies: # ä»…åœ¨å¼€å‘æ—¶ä¾èµ–ï¼Œåœ¨releaseæ—¶ä¸æ‰“åŒ… package_name: param å¸ƒå±€æœ¬èŠ‚å†…å®¹æ¥è‡ªfluuter docs/ui/layout ç®€ä»‹ flutterä¸­çš„layout å¸¸è§layout Center Container Baseline Row Column Stack Table å°†å°éƒ¨ä»¶æ·»åŠ åˆ°å¸ƒå±€ child: å”¯ä¸€å­widget children: å¤šä¸ªåˆ—è¡¨å‹çš„å­widget(å¦‚Row, Column, Stack) buildæ–¹æ³•å¤§å¤šæ•°widgetséƒ½æœ‰buildæ–¹æ³•,flutter appæœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªwidget,é€šè¿‡buildæ–¹æ³•å®ä¾‹åŒ–å¹¶è¿”å›ä¸€ä¸ªwidgetå°±ä¼šæ˜¾ç¤ºè¯¥widget App CupertinoApp: iosé£æ ¼çš„app themeä¼ å…¥CupertinoThemeData homeå±æ€§ç”¨CupertinoPageScaffold å…¨éƒ¨Cupertino lib MaterialApp: Materialé£æ ¼çš„app homeç”¨Scaffold å¯ä»¥ä½¿ç”¨ActionButton, SneakBar Container: å¦‚æœä¸éœ€è¦Materialé£æ ¼æˆ–iosé£æ ¼ï¼Œç›´æ¥è¿”å›Container Rowå’ŒColum ä¸»è½´å’Œäº¤å‰è½´(main axis, cross axis) rowçš„ä¸»è½´å’Œäº¤å‰è½´åˆ†åˆ«æ˜¯æ°´å¹³çš„å’Œå‚ç›´çš„ columnçš„ä¸»è½´å’Œäº¤å‰è½´åè¿‡æ¥ MainAxisAlignmentå’ŒCrossAxisAlignmentæä¾›äº†æ§åˆ¶å¯¹é½æ–¹å¼çš„å¸¸é‡ å¤šä¸ªchildrençš„å¤§å° ä½¿ç”¨Expanded: è®©å­widgeté€‚åº”row/columnçš„å¤§å°ï¼Œä½¿ç”¨Expandedçš„å±æ€§flexåˆ¶å®šå…¶å¤§å°çš„æƒé‡ ä½¿ç”¨mainAxisSize: MainAxisSize.minæ§åˆ¶å¤§å°ï¼Œè®©å…¶ç´§å‡‘çš„è´´åœ¨ä¸€èµ· å¸¸ç”¨å¸ƒå±€å°ç»„ä»¶ æ ‡å‡†å°ç»„ä»¶Containerï¼šå‘å°éƒ¨ä»¶æ·»åŠ å¡«å……ã€è¾¹è·ã€è¾¹æ¡†ã€èƒŒæ™¯é¢œè‰²æˆ–å…¶ä»–è£…é¥°ã€‚GridViewï¼šå°†å°éƒ¨ä»¶å¸ƒç½®ä¸ºå¯æ»šåŠ¨ç½‘æ ¼ã€‚ListViewï¼šå°†å°éƒ¨ä»¶å¸ƒç½®ä¸ºå¯æ»šåŠ¨åˆ—è¡¨ã€‚Stackï¼šå°†ä¸€ä¸ªå°éƒ¨ä»¶é‡å åœ¨å¦ä¸€ä¸ªå°éƒ¨ä»¶ä¹‹ä¸Šã€‚ materialå¸ƒå±€å°ç»„ä»¶Cardï¼šå°†ç›¸å…³ä¿¡æ¯ç»„ç»‡åˆ°å¸¦æœ‰åœ†è§’å’Œé˜´å½±çš„æ¡†ä¸­ã€‚ListTileï¼šå°†æœ€å¤š 3 è¡Œæ–‡æœ¬ä»¥åŠå¯é€‰çš„å‰å¯¼å’Œå°¾éšå›¾æ ‡ç»„ç»‡æˆä¸€è¡Œã€‚ çº¦æŸConstraintsUnderstanding constraintsFlutterçš„å¸ƒå±€å¼•æ“è¢«è®¾è®¡ä¸ºä¸€æ¬¡é€šè¿‡çš„è¿‡ç¨‹ã€‚è¿™æ„å‘³ç€Flutterå¯ä»¥éå¸¸æœ‰æ•ˆåœ°å¸ƒå±€å…¶å°éƒ¨ä»¶ï¼Œä½†ä¹Ÿå­˜åœ¨ä¸€äº›é™åˆ¶: å°éƒ¨ä»¶åªèƒ½åœ¨çˆ¶éƒ¨ä»¶ç»™å®ƒçš„çº¦æŸèŒƒå›´å†…å†³å®šè‡ªå·±çš„å¤§å°ã€‚è¿™æ„å‘³ç€ä¸€ä¸ªå°éƒ¨ä»¶é€šå¸¸ä¸èƒ½æœ‰å®ƒæƒ³è¦çš„å¤§å°ã€‚ å°éƒ¨ä»¶ä¸èƒ½çŸ¥é“ä¹Ÿä¸èƒ½å†³å®šå®ƒè‡ªå·±åœ¨å±å¹•ä¸Šçš„ä½ç½®ï¼Œå› ä¸ºå†³å®šå°éƒ¨ä»¶ä½ç½®çš„æ˜¯å°éƒ¨ä»¶çš„çˆ¶ç»„ä»¶ã€‚ å› ä¸ºçˆ¶å…ƒç´ çš„å¤§å°å’Œä½ç½®ä¹Ÿä¾èµ–äºå®ƒè‡ªå·±çš„çˆ¶å…ƒç´ ï¼Œæ‰€ä»¥ä¸è€ƒè™‘æ•´ä¸ªæ ‘ï¼Œå°±ä¸å¯èƒ½ç²¾ç¡®åœ°å®šä¹‰ä»»ä½•å°éƒ¨ä»¶çš„å¤§å°å’Œä½ç½®ã€‚ å¦‚æœå­å…ƒç´ æƒ³è¦ä¸çˆ¶å…ƒç´ ä¸åŒçš„å¤§å°ï¼Œå¹¶ä¸”çˆ¶å…ƒç´ æ²¡æœ‰è¶³å¤Ÿçš„ä¿¡æ¯æ¥å¯¹é½å®ƒï¼Œé‚£ä¹ˆå­å…ƒç´ çš„å¤§å°å¯èƒ½ä¼šè¢«å¿½ç•¥ã€‚åœ¨å®šä¹‰alignmentæ—¶è¦æ˜ç¡®ã€‚ ç‰¹æ€§ è‹¥å±å¹•æ˜¯çˆ¶å¸ƒå±€ï¼Œæ— è®ºè¯¥widgetæ˜¯å¦å®šä¹‰å…¶å¤§å°ã€å®½åº¦ï¼Œè¯¥widgetä¼šå¼ºåˆ¶é“ºæ»¡å±å¹• å¯¹äºAlign, Center, å­widgetçš„å¤§å°ä¸èƒ½è¶…è¿‡çˆ¶widgetçš„æƒ…å†µä¸‹ï¼Œå­widgetå¯ä»¥æ‹¥æœ‰ä»»æ„çš„å¤§å° å¦‚æœçˆ¶widgetæ²¡æœ‰å¤§å°ï¼Œä»–çš„å¤§å°ç”±å­widgetå†³å®š ConstrainedBox å¦‚æœConstrainedBoxï¼ˆå¯ä»¥æŒ‡å®šå­widgetçš„å®½åº¦é«˜åº¦çš„èŒƒå›´ï¼‰çš„çˆ¶widgetæ˜¯å±å¹•ã€‚ å±å¹•ä¼šçº¦æŸwidgetå¤§å°æ­£å¥½ç­‰äºå±å¹• ConstrainedBoxåªèƒ½ä»çˆ¶widgetçš„çº¦æŸä¸­æ–½åŠ çº¦æŸã€‚ä¹Ÿå°±æ˜¯å¦‚æœå­widgetçš„çº¦æŸä¸åœ¨çˆ¶widgetçš„çº¦æŸèŒƒå›´å†…ï¼Œé‚£ä¹ˆå°±åªèƒ½ä¾ç…§çˆ¶widgetçš„çº¦æŸ å¦‚æœå­widgetè¦æ±‚çš„å¤§å°è¶…è¿‡äº†ConstrainedBoxçš„é™åˆ¶ï¼Œåªèƒ½å–é™åˆ¶çš„æœ€å¤§å€¼ï¼Œè‹¥å°äºæœ€ä½é™åˆ¶ï¼Œåˆ™åªèƒ½æ˜¯æœ€å°å€¼ UnconstrainedBox å…è®¸å­widgetæ‹¥æœ‰ä»»ä½•å¤§å°ï¼Œå¦‚æœå­widgetå¤§å°è¶…è¿‡UnconstrainedBoxï¼Œåˆ™ä¼šåœ¨å±å¹•ä¸Šæ˜¾ç¤ºâ€overflow warningâ€ å¦‚æœå­widgetè¦æ±‚å¤§å°ä¸ºdouble.infinityï¼Œåˆ™ä¸ä¼šæ˜¾ç¤ºä»»ä½•å†…å®¹ï¼Œä¸”ä¼šåœ¨consoleä¸­æç¤ºerrorä¿¡æ¯ OverflowBox å…è®¸å­widgetæ‹¥æœ‰ä»»ä½•å¤§å°ï¼Œå¦‚æœå­widgetå¤§å°è¶…è¿‡UnconstrainedBoxï¼Œåˆ™ä¼šå°½é‡æ˜¾ç¤ºå­widgetçš„å†…å®¹ï¼Œä¸ä¼šå‡ºç°â€overflow warningâ€ LimitedBox é™åˆ¶å­widgetçš„å¤§å°èŒƒå›´ï¼Œä½†ä»…åœ¨å­widgetè®¾ç½®ä¸ºdouble.infinityæ—¶ç”Ÿæ•ˆï¼Œå¦‚æœè®¾ç½®ä¸æ˜¯double.infinityä¹Ÿä¸åœ¨LimitedBoxé™åˆ¶çš„èŒƒå›´å†…ï¼Œåˆ™æ˜¾ç¤ºå­widgetè¦æ±‚çš„å¤§å°è€Œä¸åº”ç”¨LimitedBoxçš„é™åˆ¶ FittedBox çˆ¶widgetæ˜¯screen,å­widgetæ˜¯Text Textæ ¹æ®å­—ä½“å¤§å°ï¼Œå­—ç¬¦ï¼Œé•¿åº¦è®¡ç®—å‡ºå®½åº¦(intrinsic)åï¼Œæ ¹æ®è‡ªèº«å®½åº¦ç¼©æ”¾Textå¡«å……ç©ºç™½ï¼Œè¶…è¿‡åˆ™ç¼©å° çˆ¶widgetæ˜¯Centerï¼ˆå…è®¸å­widgetæœ‰è‡ªå·±çš„å¤§å°ï¼‰,å­widgetæ˜¯Text Textæ ¹æ®å­—ä½“å¤§å°ï¼Œå­—ç¬¦ï¼Œé•¿åº¦è®¡ç®—å‡ºå®½åº¦(intrinsic)åï¼Œå¦‚æœå¯ä»¥ï¼ŒFittedBoxå…ˆè®©è‡ªå·±çš„å¤§å°é€‚åº”Textï¼Œè‹¥ä¸è¡Œï¼Œåˆ™ç¼©æ”¾Text åªèƒ½ç¼©æ”¾æœ‰è¾¹ç•Œçš„ï¼Œé•¿å®½ä¸æ˜¯æ— ç©·çš„widgetï¼Œå¦åˆ™ä»€ä¹ˆéƒ½ä¸ä¼šæ˜¾ç¤ºï¼Œä¸”åœ¨consoleä¸­æŠ¥å‘Šé”™è¯¯ã€‚ Center+Text ä¸ç¼©æ”¾ï¼Œæ–‡å­—å¤ªé•¿å°±break line Row ç±»ä¼¼äºUnconstrainedBox widgetç”±ExpandedåŒ…è£¹ï¼Œåˆ™ä¸å…è®¸å­widgetè‡ªå®šä¹‰å®½åº¦ï¼Œç”±å…¶ä»–childrenå†³å®šå®½åº¦ å¦‚æœæ‰€æœ‰childrenéƒ½è¢«ExpandedåŒ…è£¹ï¼Œé‚£ä¹ˆå¤§å®¶éƒ½æŒ‰ç…§Expandä¸­åˆ†é…çš„æ¯”ä¾‹å†³å®šå…¶å®½åº¦ Flexibleå…è®¸å®ƒçš„å­æ§ä»¶å…·æœ‰ä¸Flexibleç›¸åŒæˆ–æ›´å°çš„å®½åº¦ï¼Œè€ŒExpandedåˆ™å¼ºåˆ¶å®ƒçš„å­æ§ä»¶å…·æœ‰ä¸Expandedå®Œå…¨ç›¸åŒçš„å®½åº¦ Scaffold é€šè¿‡SizedBox.expandåŒ…è£¹å­widgetï¼Œå¯ä»¥è®©å­widgetä¸Scaffoldæœ‰ç›¸åŒçš„å¤§å° æ¾ç´§çº¦æŸ(Tight Loose Constraints) Tight Constraints æœ€å¤§å®½åº¦=æœ€å°å®½åº¦, æœ€å¤§é•¿åº¦=æœ€å°é•¿åº¦ Losse Constraints æœ€å°å®½åº¦ = 0, æœ€å°é•¿åº¦ = 0 æœ€å¤§å®½åº¦ != 0, æœ€å¤§é•¿åº¦ != 0 Centerå°±æ˜¯æŠŠæ”¶åˆ°çš„tightçº¦æŸè½¬æ¢æˆlooseçº¦æŸ æ— é™çº¦æŸ(unbounded constraint) æœ€å¤§å®½åº¦ = double.infinite, æœ€å¤§é•¿åº¦ = double.infinite ä¸€èˆ¬æƒ…å†µä¸‹ä¼šå¯¼è‡´consoleä¸­å‡ºç°error ç”¨äºListViewç­‰ScrollViewçš„å­ç±» æ»‘åŠ¨æ–¹å‘ä¸Šçš„é•¿/å®½æ— é™ Flex Flex Box(Row æˆ– Column) è‹¥ä¸»è½´ä¸Šæ‹¥æœ‰æœ‰é™çº¦æŸï¼Œåˆ™ç»å¯èƒ½çš„å¤§ è‹¥ä¸»è½´ä¸Šæ‹¥æœ‰æ— é™çº¦æŸï¼Œæ¯ä¸ªå­©å­çš„flexå€¼å¿…é¡»ä¸º0ï¼Œä¹Ÿå°±æ˜¯ä¸èƒ½åœ¨å¯æ»‘åŠ¨widgetæˆ–flex boxä¸­ä½¿ç”¨Expand äº¤å‰è½´æ–¹å‘ä¸èƒ½æ— é™ï¼Œå¦åˆ™æ— æ³•align children Stack å¸¸è§å±æ€§ alignment ä¼ å…¥åæ ‡å€¼ åŸç‚¹åœ¨widgetä¸­å¿ƒ æ°´å¹³å‘å³ä¸ºxè½´ï¼Œx=[-1, 1] ä»å·¦åˆ°å³ ç«–ç›´å‘ä¸‹ä¸ºyè½´ï¼Œy=[-1, 1] ä»ä¸Šåˆ°ä¸‹ fit ä¼ å…¥StackFit å€¼æœ‰: loose, expand, passthrough overflow ç©ºé—´æº¢å‡ºçš„æ“ä½œ: clip / visible position ä¸€ä¸ªwidget, å’Œstackæ­é…ä½¿ç”¨ ç¡®å®šstackä¸­å­widgetçš„ä½ç½® ContaineråŒ…æ‹¬äº†: SizedBox, Center, Padding, DecoratedBox, ConstrainedBoxçš„åŠŸèƒ½ StateFull/StateLess didUpdatedWidget widgetå‚æ•°å‘ç”Ÿæ”¹å˜æ—¶è§¦å‘ AnimationInheritedWidget ofæ–¹æ³•ï¼Œä»å½“å‰widgetå‘ä¸ŠæŸ¥æ‰¾ï¼Œç›´åˆ°æ‰¾åˆ°è¯¥ç±»å‹çš„ä¸ªWidget ä¸å…è®¸åœ¨initStateè°ƒç”¨ofæ–¹æ³• è‡ªä¸Šè€Œä¸‹ä¼ é€’çŠ¶æ€åœ¨çˆ¶widgetä¸­ updateShouldNotify æ˜¯å¦å‘ä¸‹ä¼ é€’å˜åŒ– åœ¨å­widgetä¸­ didChangeDepandencies çŠ¶æ€åŒæ­¥ è‹¥ä¸€ä¸ªå­widgeté€šè¿‡ofè·å–è¿‡æˆ‘çš„å±æ€§ï¼Œé‚£ä¹ˆæˆ‘çš„å±æ€§å˜åŒ–æ—¶ï¼Œéƒ½ä¼šé‡æ–°buildè¿™äº›å­widget åœ¨é‡æ–°buildä¹‹å‰ï¼Œä¼šè§¦å‘didChangeDepandencies initStateåä¹Ÿä¼šè°ƒç”¨ä¸€æ¬¡didChangeDepandencies è‡ªä¸‹è€Œä¸Šçš„æ¶ˆæ¯ä¼ é€’çˆ¶widgetç”¨NotificationListener&lt;XXXNotification&gt;åŒ…è£…å­widgetä¸­éœ€è¦ä¼ é€’æ¶ˆæ¯æ—¶ï¼Œåˆ›å»ºä¸€ä¸ªXXXNotificationï¼Œå¹¶è°ƒç”¨dispatch é¡µé¢è·³è½¬Navigator push(Widget) widgetæ ˆä¸­åŠ å…¥ä¸€ä¸ªwidget pop å¼¹å‡ºä¸€ä¸ªwidget","link":"/home/2024/04/24/Android%E9%AB%98%E7%BA%A7/flutter%E5%85%A5%E9%97%A8/01-Flutter-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98/"},{"title":"åŸºç¡€01-Context","text":"å¤§çº² Contextç±» æ³¨è§£ ç”¨äºæ ‡æ³¨æ–‡ä»¶ã€SharedPreferencesã€æ•°æ®åº“çš„æ‰“å¼€æ–¹å¼çš„æ³¨è§£ ç”¨äºæ ‡æ³¨bindServiceæ—¶ï¼Œserviceçš„flagsçš„æ³¨è§£ ç”¨äºæ ‡æ³¨registerReceiveræ—¶ï¼Œreceiverçš„flagsçš„æ³¨è§£ ç”¨äºæ ‡æ³¨getServiceæ—¶ï¼ŒservicesNameçš„æ³¨è§£ ç”¨äºæ ‡æ³¨createPackageContextã€createPackageContextAsUserã€createContextAsUserã€createApplicationContextæ—¶çš„flagsçš„æ³¨è§£ å¸¸é‡å®šä¹‰ å¯¹åº”ä¸Šé¢æ³¨è§£ä¸­é™åˆ¶çš„å¸¸é‡ WAL Contextç±»Contextæ˜¯æŠ½è±¡ç±»ï¼Œå…·ä½“å®ç°åœ¨ContextImplï¼ŒApplicationï¼ŒServiceï¼ŒActivityéƒ½ç›´æ¥æˆ–é—´æ¥ç»§æ‰¿è‡ªContextWrapperï¼ŒContextWrapperé€šè¿‡ä»£ç†çš„æ–¹å¼è°ƒç”¨çœŸæ­£çš„ContextImplã€‚ æ³¨è§£123456789101112131415161718192021222324252627282930/** @hide */@IntDef(flag = true, prefix = { &quot;MODE_&quot; }, value = { MODE_PRIVATE, MODE_WORLD_READABLE, MODE_WORLD_WRITEABLE, MODE_APPEND,})@Retention(RetentionPolicy.SOURCE)public @interface FileMode {}/** @hide */@IntDef(flag = true, prefix = { &quot;MODE_&quot; }, value = { MODE_PRIVATE, MODE_WORLD_READABLE, MODE_WORLD_WRITEABLE, MODE_MULTI_PROCESS,})@Retention(RetentionPolicy.SOURCE)public @interface PreferencesMode {}/** @hide */@IntDef(flag = true, prefix = { &quot;MODE_&quot; }, value = { MODE_PRIVATE, MODE_WORLD_READABLE, MODE_WORLD_WRITEABLE, MODE_ENABLE_WRITE_AHEAD_LOGGING, MODE_NO_LOCALIZED_COLLATORS,})@Retention(RetentionPolicy.SOURCE)public @interface DatabaseMode {} 123456789101112131415/** @hide */@IntDef(flag = true, prefix = { &quot;BIND_&quot; }, value = { BIND_AUTO_CREATE, BIND_DEBUG_UNBIND, BIND_NOT_FOREGROUND, BIND_ABOVE_CLIENT, BIND_ALLOW_OOM_MANAGEMENT, BIND_WAIVE_PRIORITY, BIND_IMPORTANT, BIND_ADJUST_WITH_ACTIVITY, BIND_NOT_PERCEPTIBLE, BIND_INCLUDE_CAPABILITIES})@Retention(RetentionPolicy.SOURCE)public @interface BindServiceFlags {} 123456/** @hide */@IntDef(flag = true, prefix = { &quot;RECEIVER_VISIBLE_&quot; }, value = { RECEIVER_VISIBLE_TO_INSTANT_APPS})@Retention(RetentionPolicy.SOURCE)public @interface RegisterReceiverFlags {} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/** @hide */@StringDef(suffix = { &quot;_SERVICE&quot; }, value = { POWER_SERVICE, //@hide: POWER_STATS_SERVICE, WINDOW_SERVICE, LAYOUT_INFLATER_SERVICE, ACCOUNT_SERVICE, ACTIVITY_SERVICE, ALARM_SERVICE, NOTIFICATION_SERVICE, ACCESSIBILITY_SERVICE, CAPTIONING_SERVICE, KEYGUARD_SERVICE, LOCATION_SERVICE, //@hide: COUNTRY_DETECTOR, SEARCH_SERVICE, SENSOR_SERVICE, SENSOR_PRIVACY_SERVICE, STORAGE_SERVICE, STORAGE_STATS_SERVICE, WALLPAPER_SERVICE, TIME_ZONE_RULES_MANAGER_SERVICE, VIBRATOR_MANAGER_SERVICE, VIBRATOR_SERVICE, //@hide: STATUS_BAR_SERVICE, CONNECTIVITY_SERVICE, PAC_PROXY_SERVICE, VCN_MANAGEMENT_SERVICE, //@hide: IP_MEMORY_STORE_SERVICE, IPSEC_SERVICE, VPN_MANAGEMENT_SERVICE, TEST_NETWORK_SERVICE, //@hide: UPDATE_LOCK_SERVICE, //@hide: NETWORKMANAGEMENT_SERVICE, NETWORK_STATS_SERVICE, //@hide: NETWORK_POLICY_SERVICE, WIFI_SERVICE, WIFI_AWARE_SERVICE, WIFI_P2P_SERVICE, WIFI_SCANNING_SERVICE, //@hide: LOWPAN_SERVICE, //@hide: WIFI_RTT_SERVICE, //@hide: ETHERNET_SERVICE, WIFI_RTT_RANGING_SERVICE, NSD_SERVICE, AUDIO_SERVICE, AUTH_SERVICE, FINGERPRINT_SERVICE, //@hide: FACE_SERVICE, BIOMETRIC_SERVICE, MEDIA_ROUTER_SERVICE, TELEPHONY_SERVICE, TELEPHONY_SUBSCRIPTION_SERVICE, CARRIER_CONFIG_SERVICE, EUICC_SERVICE, //@hide: MMS_SERVICE, TELECOM_SERVICE, CLIPBOARD_SERVICE, INPUT_METHOD_SERVICE, TEXT_SERVICES_MANAGER_SERVICE, TEXT_CLASSIFICATION_SERVICE, APPWIDGET_SERVICE, //@hide: VOICE_INTERACTION_MANAGER_SERVICE, //@hide: BACKUP_SERVICE, REBOOT_READINESS_SERVICE, ROLLBACK_SERVICE, DROPBOX_SERVICE, //@hide: DEVICE_IDLE_CONTROLLER, //@hide: POWER_WHITELIST_MANAGER, DEVICE_POLICY_SERVICE, UI_MODE_SERVICE, DOWNLOAD_SERVICE, NFC_SERVICE, BLUETOOTH_SERVICE, //@hide: SIP_SERVICE, USB_SERVICE, LAUNCHER_APPS_SERVICE, //@hide: SERIAL_SERVICE, //@hide: HDMI_CONTROL_SERVICE, INPUT_SERVICE, DISPLAY_SERVICE, //@hide COLOR_DISPLAY_SERVICE, USER_SERVICE, RESTRICTIONS_SERVICE, APP_OPS_SERVICE, ROLE_SERVICE, //@hide ROLE_CONTROLLER_SERVICE, CAMERA_SERVICE, //@hide: PLATFORM_COMPAT_SERVICE, //@hide: PLATFORM_COMPAT_NATIVE_SERVICE, PRINT_SERVICE, CONSUMER_IR_SERVICE, //@hide: TRUST_SERVICE, TV_INPUT_SERVICE, //@hide: TV_TUNER_RESOURCE_MGR_SERVICE, //@hide: NETWORK_SCORE_SERVICE, USAGE_STATS_SERVICE, MEDIA_SESSION_SERVICE, MEDIA_COMMUNICATION_SERVICE, BATTERY_SERVICE, JOB_SCHEDULER_SERVICE, //@hide: PERSISTENT_DATA_BLOCK_SERVICE, //@hide: OEM_LOCK_SERVICE, MEDIA_PROJECTION_SERVICE, MIDI_SERVICE, RADIO_SERVICE, HARDWARE_PROPERTIES_SERVICE, //@hide: SOUND_TRIGGER_SERVICE, SHORTCUT_SERVICE, //@hide: CONTEXTHUB_SERVICE, SYSTEM_HEALTH_SERVICE, //@hide: INCIDENT_SERVICE, //@hide: INCIDENT_COMPANION_SERVICE, //@hide: STATS_COMPANION_SERVICE, COMPANION_DEVICE_SERVICE, CROSS_PROFILE_APPS_SERVICE, //@hide: SYSTEM_UPDATE_SERVICE, //@hide: TIME_DETECTOR_SERVICE, //@hide: TIME_ZONE_DETECTOR_SERVICE, PERMISSION_SERVICE, LIGHTS_SERVICE, //@hide: PEOPLE_SERVICE, //@hide: DEVICE_STATE_SERVICE, //@hide: SPEECH_RECOGNITION_SERVICE, UWB_SERVICE, MEDIA_METRICS_SERVICE,})@Retention(RetentionPolicy.SOURCE)public @interface ServiceName {} 1234567891011/** @hide */@IntDef(flag = true, prefix = { &quot;CONTEXT_&quot; }, value = { CONTEXT_INCLUDE_CODE, CONTEXT_IGNORE_SECURITY, CONTEXT_RESTRICTED, CONTEXT_DEVICE_PROTECTED_STORAGE, CONTEXT_CREDENTIAL_PROTECTED_STORAGE, CONTEXT_REGISTER_PACKAGE,})@Retention(RetentionPolicy.SOURCE)public @interface CreatePackageOptions {} å¸¸é‡å®šä¹‰æ–‡ä»¶åˆ›å»ºã€SPã€æ•°æ®åº“å…±äº«çš„çš„flags 1234567891011// é»˜è®¤å€¼ï¼Œåªèƒ½å¯¹å½“å‰app(ç›¸åŒuser-idçš„è¿›ç¨‹)å¯è§public static final int MODE_PRIVATE = 0x0000;// å…è®¸å…¶ä»–appè¯»ï¼Œå·²å¼ƒç”¨ï¼Œå¼ºåˆ¶ä½¿ç”¨ä¼šæŠ›å‡ºSecurityException@Deprecatedpublic static final int MODE_WORLD_READABLE = 0x0001;// å…è®¸å…¶ä»–appå†™ï¼Œå·²å¼ƒç”¨ï¼Œå¼ºåˆ¶ä½¿ç”¨ä¼šæŠ›å‡ºSecurityException@Deprecatedpublic static final int MODE_WORLD_WRITEABLE = 0x0002; æ–‡ä»¶åˆ›å»ºçš„flag 12// appendï¼Œè€Œä¸æ˜¯è¦†ç›–public static final int MODE_APPEND = 0x8000; SPåŠ è½½çš„flag 12345// ä¸å»ºè®®ä½¿ç”¨ï¼Œæ²¡æœ‰è¿›ç¨‹åŒæ­¥çš„æœºåˆ¶// ä¸ºäº†ä¸€ä¸ªappæœ‰å¤šä¸ªè¿›ç¨‹æ—¶ä½¿ç”¨// è·¨è¿›ç¨‹æ•°æ®ç®¡ç†æ–¹æ³•å¯ä»¥ç”¨ContentProvider@Deprecatedpublic static final int MODE_MULTI_PROCESS = 0x0004; æ•°æ®åº“çš„flag 12345678910111213// write-ahead logging, WAL/** * According To: https://www.w3cschool.cn/doc_postgresql_9_4/postgresql_9_4-wal-intro.html * Briefly, WAL's central concept is that changes to data files (where tables and indexes reside) * must be written only after those changes have been logged, * that is, after log records describing the changes have been flushed to permanent storage.*/// åœ¨å¯¹æ•°æ®è¿›è¡Œå†™æ“ä½œå‰ï¼Œå¯¹å†™æ“ä½œçš„logè¦å…ˆå†™å…¥åˆ°æŒä¹…åŒ–å­˜å‚¨è®¾å¤‡// å¯ç”¨WALpublic static final int MODE_ENABLE_WRITE_AHEAD_LOGGING = 0x0008;// å¯ç”¨æœ¬åœ°åŒ–çš„æ“ä½œpublic static final int MODE_NO_LOCALIZED_COLLATORS = 0x0010; bindServiceçš„flags 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248/** * &lt;p&gt;Note that prior to {@link android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH}, * not supplying this flag would also impact how important the system * consider's the target service's process to be. When set, the only way * for it to be raised was by binding from a service in which case it will * only be important when that activity is in the foreground. Now to * achieve this behavior you must explicitly supply the new flag * {@link #BIND_ADJUST_WITH_ACTIVITY}. For compatibility, old applications * that don't specify {@link #BIND_AUTO_CREATE} will automatically have * the flags {@link #BIND_WAIVE_PRIORITY} and * {@link #BIND_ADJUST_WITH_ACTIVITY} set for them in order to achieve * the same result. */// è‡ªåŠ¨åˆ›å»ºservicepublic static final int BIND_AUTO_CREATE = 0x0001;// debugï¼Œæ‰“å°è°ƒç”¨æ ˆpublic static final int BIND_DEBUG_UNBIND = 0x0002;// ä¸å…è®¸å°†serviceè¿›ç¨‹æå‡åˆ°å‰å°ï¼Œç»‘å®šæ—¶åœ¨å‰å°è€Œç›®æ ‡ä¸ºåå°æ—¶æœ‰æ•ˆpublic static final int BIND_NOT_FOREGROUND = 0x0004;// Serviceçš„é‡è¦ç¨‹åº¦é«˜äºå®¢æˆ·ç«¯ï¼ŒOOMæ—¶æœ‰é™æ€æ‰appè€Œä¸æ˜¯servicepublic static final int BIND_ABOVE_CLIENT = 0x0008;/** * Flag for {@link #bindService}: allow the process hosting the bound * service to go through its normal memory management. It will be * treated more like a running service, allowing the system to * (temporarily) expunge the process if low on memory or for some other * whim it may have, and being more aggressive about making it a candidate * to be killed (and restarted) if running for a long time. */public static final int BIND_ALLOW_OOM_MANAGEMENT = 0x0010;/** * Flag for {@link #bindService}: don't impact the scheduling or * memory management priority of the target service's hosting process. * Allows the service's process to be managed on the background LRU list * just like a regular application process in the background. */public static final int BIND_WAIVE_PRIORITY = 0x0020;/** * Flag for {@link #bindService}: this service is very important to * the client, so should be brought to the foreground process level * when the client is. Normally a process can only be raised to the * visibility level by a client, even if that client is in the foreground. */public static final int BIND_IMPORTANT = 0x0040;/** * Flag for {@link #bindService}: If binding from an activity, allow the * target service's process importance to be raised based on whether the * activity is visible to the user, regardless whether another flag is * used to reduce the amount that the client process's overall importance * is used to impact it. */public static final int BIND_ADJUST_WITH_ACTIVITY = 0x0080;/** * Flag for {@link #bindService}: If binding from an app that is visible or user-perceptible, * lower the target service's importance to below the perceptible level. This allows * the system to (temporarily) expunge the bound process from memory to make room for more * important user-perceptible processes. */public static final int BIND_NOT_PERCEPTIBLE = 0x00000100;/** * Flag for {@link #bindService}: If binding from an app that has specific capabilities * due to its foreground state such as an activity or foreground service, then this flag will * allow the bound app to get the same capabilities, as long as it has the required permissions * as well. * * If binding from a top app and its target SDK version is at or above * {@link android.os.Build.VERSION_CODES#R}, the app needs to * explicitly use BIND_INCLUDE_CAPABILITIES flag to pass all capabilities to the service so the * other app can have while-use-use access such as location, camera, microphone from background. * If binding from a top app and its target SDK version is below * {@link android.os.Build.VERSION_CODES#R}, BIND_INCLUDE_CAPABILITIES is implicit. */public static final int BIND_INCLUDE_CAPABILITIES = 0x000001000;/*********** Public flags above this line ***********//*********** Hidden flags below this line ***********//** * Flag for {@link #bindService}: This flag is only intended to be used by the system to * indicate that a service binding is not considered as real package component usage and should * not generate a {@link android.app.usage.UsageEvents.Event#APP_COMPONENT_USED} event in usage * stats. * @hide */public static final int BIND_NOT_APP_COMPONENT_USAGE = 0x00008000;/** * Flag for {@link #bindService}: allow the process hosting the target service to be treated * as if it's as important as a perceptible app to the user and avoid the oom killer killing * this process in low memory situations until there aren't any other processes left but the * ones which are user-perceptible. * * @hide */public static final int BIND_ALMOST_PERCEPTIBLE = 0x000010000;/** * Flag for {@link #bindService}: allow the process hosting the target service to gain * {@link ActivityManager#PROCESS_CAPABILITY_NETWORK}, which allows it be able * to access network regardless of any power saving restrictions. * * @hide */public static final int BIND_BYPASS_POWER_NETWORK_RESTRICTIONS = 0x00020000;/** * Do not use. This flag is no longer needed nor used. * @hide */@SystemApipublic static final int BIND_ALLOW_FOREGROUND_SERVICE_STARTS_FROM_BACKGROUND = 0x00040000;/** * Flag for {@link #bindService}: This flag is intended to be used only by the system to adjust * the scheduling policy for IMEs (and any other out-of-process user-visible components that * work closely with the top app) so that UI hosted in such services can have the same * scheduling policy (e.g. SCHED_FIFO when it is enabled and TOP_APP_PRIORITY_BOOST otherwise) * as the actual top-app. * @hide */public static final int BIND_SCHEDULE_LIKE_TOP_APP = 0x00080000;/** * Flag for {@link #bindService}: allow background activity starts from the bound service's * process. * This flag is only respected if the caller is holding * {@link android.Manifest.permission#START_ACTIVITIES_FROM_BACKGROUND}. * @hide */@SystemApipublic static final int BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS = 0x00100000;/** * @hide Flag for {@link #bindService}: the service being bound to represents a * protected system component, so must have association restrictions applied to it. * That is, a system config must have one or more allow-association tags limiting * which packages it can interact with. If it does not have any such association * restrictions, a default empty set will be created. */public static final int BIND_RESTRICT_ASSOCIATIONS = 0x00200000;/** * @hide Flag for {@link #bindService}: allows binding to a service provided * by an instant app. Note that the caller may not have access to the instant * app providing the service which is a violation of the instant app sandbox. * This flag is intended ONLY for development/testing and should be used with * great care. Only the system is allowed to use this flag. */public static final int BIND_ALLOW_INSTANT = 0x00400000;/** * @hide Flag for {@link #bindService}: like {@link #BIND_NOT_FOREGROUND}, but puts it * up in to the important background state (instead of transient). */public static final int BIND_IMPORTANT_BACKGROUND = 0x00800000;/** * @hide Flag for {@link #bindService}: allows application hosting service to manage whitelists * such as temporary allowing a {@code PendingIntent} to bypass Power Save mode. */public static final int BIND_ALLOW_WHITELIST_MANAGEMENT = 0x01000000;/** * @hide Flag for {@link #bindService}: Like {@link #BIND_FOREGROUND_SERVICE}, * but only applies while the device is awake. */public static final int BIND_FOREGROUND_SERVICE_WHILE_AWAKE = 0x02000000;/** * @hide Flag for {@link #bindService}: For only the case where the binding * is coming from the system, set the process state to FOREGROUND_SERVICE * instead of the normal maximum of IMPORTANT_FOREGROUND. That is, this is * saying that the process shouldn't participate in the normal power reduction * modes (removing network access etc). */public static final int BIND_FOREGROUND_SERVICE = 0x04000000;/** * @hide Flag for {@link #bindService}: Treat the binding as hosting * an activity, an unbinding as the activity going in the background. * That is, when unbinding, the process when empty will go on the activity * LRU list instead of the regular one, keeping it around more aggressively * than it otherwise would be. This is intended for use with IMEs to try * to keep IME processes around for faster keyboard switching. */public static final int BIND_TREAT_LIKE_ACTIVITY = 0x08000000;/** * @hide An idea that is not yet implemented. * Flag for {@link #bindService}: If binding from an activity, consider * this service to be visible like the binding activity is. That is, * it will be treated as something more important to keep around than * invisible background activities. This will impact the number of * recent activities the user can switch between without having them * restart. There is no guarantee this will be respected, as the system * tries to balance such requests from one app vs. the importance of * keeping other apps around. */public static final int BIND_VISIBLE = 0x10000000;/** * @hide * Flag for {@link #bindService}: Consider this binding to be causing the target * process to be showing UI, so it will be do a UI_HIDDEN memory trim when it goes * away. */public static final int BIND_SHOWING_UI = 0x20000000;/** * Flag for {@link #bindService}: Don't consider the bound service to be * visible, even if the caller is visible. * @hide */public static final int BIND_NOT_VISIBLE = 0x40000000;/** * Flag for {@link #bindService}: The service being bound is an * {@link android.R.attr#isolatedProcess isolated}, * {@link android.R.attr#externalService external} service. This binds the service into the * calling application's package, rather than the package in which the service is declared. * &lt;p&gt; * When using this flag, the code for the service being bound will execute under the calling * application's package name and user ID. Because the service must be an isolated process, * it will not have direct access to the application's data, though. * * The purpose of this flag is to allow applications to provide services that are attributed * to the app using the service, rather than the application providing the service. * &lt;/p&gt; */public static final int BIND_EXTERNAL_SERVICE = 0x80000000;/** * These bind flags reduce the strength of the binding such that we shouldn't * consider it as pulling the process up to the level of the one that is bound to it. * @hide */public static final int BIND_REDUCTION_FLAGS = Context.BIND_ALLOW_OOM_MANAGEMENT | Context.BIND_WAIVE_PRIORITY | Context.BIND_NOT_PERCEPTIBLE | Context.BIND_NOT_VISIBLE; registerReceiverçš„flags 12345/** * Flag for {@link #registerReceiver}: The receiver can receive broadcasts from Instant Apps. */// æ˜¯å¦å¯ä»¥è¢«Instant Appsæ¥æ”¶åˆ°ï¼ˆgoogleçš„å°ç¨‹åºå§ï¼‰public static final int RECEIVER_VISIBLE_TO_INSTANT_APPS = 0x1; getServiceçš„serviceName 1 æ–¹æ³•éƒ¨åˆ†getæ–¹æ³•1234567891011121314151617181920212223public abstract AssetManager getAssets();public abstract Resources getResources();public abstract PackageManager getPackageManager();public abstract ContentResolver getContentResolver();public abstract Looper getMainLooper();public abstract Context getApplicationContext();public Executor getMainExecutor() { // This is pretty inefficient, which is why ContextImpl overrides it return new HandlerExecutor(new Handler(getMainLooper()));}public abstract ClassLoader getClassLoader();public abstract String getPackageName();public abstract String getBasePackageName();@NonNullpublic String getOpPackageName() { throw new RuntimeException(&quot;Not implemented. Must override in a subclass.&quot;);}public abstract ApplicationInfo getApplicationInfo();public abstract String getPackageResourcePath();// è¿”å›åº”ç”¨åŒ…çš„å®Œæ•´è·¯å¾„public abstract String getPackageCodePath(); systemService123456public abstract @Nullable String getSystemServiceName(@NonNull Class&lt;?&gt; serviceClass);public abstract @Nullable Object getSystemService(@ServiceName @NonNull String name);public final @Nullable &lt;T&gt; T getSystemService(@NonNull Class&lt;T&gt; serviceClass) { // ä¹Ÿå¯ä»¥é€šè¿‡Classå¯¹è±¡è·å– String serviceName = getSystemServiceName(serviceClass); return serviceName != null ? (T)getSystemService(serviceName) : null;} Viewç›¸å…³123456789// è¿”å›è¿›ç¨‹ä¸­å”¯ä¸€çš„View IDpublic int getNextAutofillId() { if (sLastAutofillId == View.LAST_APP_AUTOFILL_ID - 1) { sLastAutofillId = View.NO_ID; } sLastAutofillId++; return sLastAutofillId;}// ä¼šæœ‰å¹¶å‘é—®é¢˜å—ï¼Ÿï¼Ÿ ComponentCallbacks123456789public void registerComponentCallbacks(ComponentCallbacks callback) { getApplicationContext().registerComponentCallbacks(callback);}public void unregisterComponentCallbacks(ComponentCallbacks callback) { getApplicationContext().unregisterComponentCallbacks(callback);}// CallbackåŒ…æ‹¬:// onConfigurationChanged// onLowMemory: è°ƒç”¨æ—¶æœºæ²¡æœ‰æ˜ç¡®å®šä¹‰ï¼Œä¸€èˆ¬åœ¨å†…å­˜ä¸è¶³ï¼Œæ‰€æœ‰åå°è¿›ç¨‹è¢«killä¹‹åï¼Œprocesses hosting serviceå’Œå‰å°ç”¨æˆ·ç•Œé¢è¢«killä¹‹å‰ã€‚ èµ„æºç›¸å…³1234567891011121314151617181920212223242526272829@NonNullpublic final CharSequence getText(@StringRes int resId) { return getResources().getText(resId);}@NonNullpublic final String getString(@StringRes int resId) { return getResources().getString(resId);}@NonNullpublic final String getString(@StringRes int resId, Object... formatArgs) { return getResources().getString(resId, formatArgs);}@ColorIntpublic final int getColor(@ColorRes int id) { return getResources().getColor(id, getTheme());}@Nullablepublic final Drawable getDrawable(@DrawableRes int id) { return getResources().getDrawable(id, getTheme());}@NonNullpublic final ColorStateList getColorStateList(@ColorRes int id) { return getResources().getColorStateList(id, getTheme());} ä¸»é¢˜ç›¸å…³123456789101112131415161718192021222324252627282930313233343536public abstract void setTheme(@StyleRes int resid);/** @hide Needed for some internal implementation... not public because * you can't assume this actually means anything. */@UnsupportedAppUsagepublic int getThemeResId() { return 0;}@ViewDebug.ExportedProperty(deepExport = true)public abstract Resources.Theme getTheme();@NonNullpublic final TypedArray obtainStyledAttributes(@NonNull @StyleableRes int[] attrs) { return getTheme().obtainStyledAttributes(attrs);}@NonNullpublic final TypedArray obtainStyledAttributes(@StyleRes int resid, @NonNull @StyleableRes int[] attrs) throws Resources.NotFoundException { return getTheme().obtainStyledAttributes(resid, attrs);}@NonNullpublic final TypedArray obtainStyledAttributes( @Nullable AttributeSet set, @NonNull @StyleableRes int[] attrs) { return getTheme().obtainStyledAttributes(set, attrs, 0, 0);}@NonNullpublic final TypedArray obtainStyledAttributes(@Nullable AttributeSet set, @NonNull @StyleableRes int[] attrs, @AttrRes int defStyleAttr, @StyleRes int defStyleRes) { return getTheme().obtainStyledAttributes( set, attrs, defStyleAttr, defStyleRes);} SP12345public abstract SharedPreferences getSharedPreferences(String name, @PreferencesMode int mode);@SuppressWarnings(&quot;HiddenAbstractMethod&quot;)public abstract SharedPreferences getSharedPreferences(File file, @PreferencesMode int mode);public abstract boolean moveSharedPreferencesFrom(Context sourceContext, String name); // å°†ä¸€ä¸ªcontextä¸­çš„spç§»åŠ¨åˆ°å½“å‰contextä¸­public abstract boolean deleteSharedPreferences(String name); æ–‡ä»¶123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// æ‰“å¼€ç§æœ‰æ–‡ä»¶çš„æµpublic abstract FileInputStream openFileInput(String name) throws FileNotFoundException;// è¯»å†™è¯¥æ–‡ä»¶ä¸éœ€è¦é¢å¤–çš„æƒé™public abstract FileOutputStream openFileOutput(String name, @FileMode int mode) throws FileNotFoundException;// è¿”å›ï¼Œæ˜¯å¦æˆåŠŸåˆ é™¤public abstract boolean deleteFile(String name);// è¿”å›æ–‡ä»¶çš„ç»å¯¹è·¯å¾„ï¼ˆé€šè¿‡openFileOutputåˆ›å»ºçš„ï¼‰public abstract File getFileStreamPath(String name);// è¿”å›spçš„è·¯å¾„@SuppressWarnings(&quot;HiddenAbstractMethod&quot;)public abstract File getSharedPreferencesPath(String name);// è¿”å›appç§æœ‰æ–‡ä»¶çš„å­˜å‚¨ä½ç½®public abstract File getDataDir();// è¿”å›openFileOutputåˆ›å»ºæ–‡ä»¶çš„ç›®å½•// å¸è½½åä¼šåˆ é™¤public abstract File getFilesDir();@NonNull@TestApipublic File getCrateDir(@NonNull String crateId) { throw new RuntimeException(&quot;Not implemented. Must override in a subclass.&quot;);}// è¿”å›ç›®å½•ï¼Œè¯¥ç›®å½•ä¸‹çš„æ–‡ä»¶ä¸ä¼šè¢«å¤‡ä»½public abstract File getNoBackupFilesDir();// è¿”å›å…±äº«å­˜å‚¨ç›®å½•// æ¯ä¸ªç”¨æˆ·éƒ½æœ‰ç‹¬ç«‹çš„å…±äº«å­˜å‚¨ç›®å½•// åº”ç”¨å¸è½½åä¹Ÿä¼šåˆ é™¤ï¼Œå±äºè¯¥app// android.os.Environment#getExternalStoragePublicDirectory æä¾›çš„ç›®å½•æ˜¯æ‰€æœ‰appå…±äº«çš„ï¼Œ// å…¶ä»–åº”ç”¨å¦‚æœæœ‰æƒé™WRITE_EXTERNAL_STORAGEï¼Œä¹Ÿå¯ä»¥å¯¹æ–‡ä»¶è¿›è¡Œè¯»å†™// MediaScanner// These files are internal to the application, and not typically visible to the user as media.// å‚æ•°æ˜¯ç›®å½•ç±»å‹ï¼Œandroid.os.Environment#DIRECTORY_XXX// è¿”å›çš„ç›®å½•ä¼šè¢«è‡ªåŠ¨åˆ›å»º// ä¸è¦ä½¿ç”¨ç»å¯¹è·¯å¾„ï¼Œæ–‡ä»¶æ‰€åœ¨ä½ç½®å¯èƒ½ä¼šæ”¹å˜@Nullablepublic abstract File getExternalFilesDir(@Nullable String type);// ç±»ä¼¼äºgetExternalFilesDirï¼Œè¿”å›æ‰€æœ‰shared/external storage devicesçš„ç»å¯¹è·¯å¾„public abstract File[] getExternalFilesDirs(String type);// å®‰å“Nä¹‹å‰ï¼Œéœ€è¦æƒé™READ_EXTERNAL_STORAGE// è¿”å›OBBæ–‡ä»¶çš„ä½ç½®ï¼Œå¦‚æœæ²¡æœ‰OBBï¼Œè¿”å›ç›®å½•å¯èƒ½ä¸å­˜åœ¨// OBB: å®‰å“æ¸¸æˆé€šç”¨æ•°æ®åŒ…public abstract File getObbDir();public abstract File[] getObbDirs();// è¿”å›ç¼“å­˜ç›®å½•// ç³»ç»Ÿä¼šåœ¨éœ€è¦æ—¶åˆ é™¤è¯¥ç›®å½•ä¸‹çš„æ–‡ä»¶// é€šè¿‡StorageManager#getCacheQuotaByteså¯ä»¥è·å–cacheçš„é…é¢ï¼ˆå¯èƒ½éšæ—¶é—´å˜åŒ–ï¼‰ï¼Œå¦‚æœè¶…è¿‡é…é¢ï¼Œå¯èƒ½ä¼šè¢«ä¼˜å…ˆåˆ é™¤// é€šè¿‡StorageManager#setCacheBehaviorGroup StorageManager#setCacheBehaviorTombstoneå¯ä»¥è®¾ç½®ç¼“å­˜çš„åˆ é™¤ç­–ç•¥// è¯»å†™ä¸éœ€è¦æƒé™public abstract File getCacheDir();// è¿”å›ä»£ç ç¼“å­˜ç›®å½•// åº”ç”¨å‡çº§ï¼Œå¹³å°å‡çº§ä¼šåˆ é™¤// å­˜å‚¨ç¼–è¯‘çš„æˆ–ç”Ÿæˆçš„ä¼˜åŒ–çš„ä»£ç public abstract File getCodeCacheDir();/** * If a shared storage device is emulated (as determined by * {@link Environment#isExternalStorageEmulated(File)}), its contents are * backed by a private user data partition, which means there is little * benefit to storing data here instead of the private directory returned by * {@link #getCacheDir()}. */// å¸è½½ååˆ é™¤// ä¸ä¼šè¢«è‡ªåŠ¨åˆ é™¤ï¼Œé™¤éç³»ç»Ÿåœ¨JELLY_BEAN_MR1åŠä»¥åï¼Œä¸”Environment#isExternalStorageEmulated(File)è¿”å›true@Nullablepublic abstract File getExternalCacheDir();/** * Returns absolute path to application-specific directory in the preloaded cache. * &lt;p&gt;Files stored in the cache directory can be deleted when the device runs low on storage. * There is no guarantee when these files will be deleted. * @hide */@SuppressWarnings(&quot;HiddenAbstractMethod&quot;)@Nullable@SystemApipublic abstract File getPreloadsFileCache();public abstract File[] getExternalCacheDirs();// å­˜å‚¨åª’ä½“æ–‡ä»¶çš„ä½ç½®ï¼Œä¼šè‡ªåŠ¨è¢«æ‰«æï¼Œä»¤å…¶ä»–appå¯è§// å¼ƒç”¨ï¼šä»å®‰å“Qå¼€å§‹ï¼Œå¯ä»¥ç›´æ¥é€šè¿‡MediaStoreæ’å…¥å†…å®¹ï¼Œä¸éœ€è¦æƒé™// å¸è½½åä¼šè¢«åˆ é™¤@Deprecatedpublic abstract File[] getExternalMediaDirs();// è¿”å›appä¸­è¯¥Contextå¯¹åº”çš„æ‰€æœ‰ç§æœ‰æ–‡ä»¶çš„åå­—public abstract String[] fileList();// å¯»æ‰¾/åˆ›å»ºä¸€ä¸ªæ–°çš„ç§æœ‰æ–‡ä»¶ç›®å½•public abstract File getDir(String name, @FileMode int mode);","link":"/home/2024/07/01/Android%E9%AB%98%E7%BA%A7/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E5%9F%BA%E7%A1%8001-Context/"},{"title":"22-Gradle","text":"æ ¸å¿ƒæ¦‚å¿µ é¡¹ç›® Gradleé¡¹ç›®æ˜¯ä¸€ä¸ªå¯ä»¥æ„å»ºçš„è½¯ä»¶ï¼Œä¾‹å¦‚åº”ç”¨ç¨‹åºæˆ–åº“ã€‚ åŒ…æ‹¬ä¸€ä¸ªæ ¹é¡¹ç›®å’Œä»»æ„æ•°é‡çš„å­é¡¹ç›®ã€‚ æ„å»ºè„šæœ¬ æ„å»ºè„šæœ¬å‘ Gradle è¯¦ç»†ä»‹ç»äº†æ„å»ºé¡¹ç›®æ‰€éœ€é‡‡å–çš„æ­¥éª¤ã€‚ æ¯ä¸ªé¡¹ç›®å¯ä»¥åŒ…å«ä¸€ä¸ªæˆ–å¤šä¸ªæ„å»ºè„šæœ¬ã€‚ ä¾èµ–ç®¡ç† ä¾èµ–ç®¡ç†æ˜¯ä¸€ç§ç”¨äºå£°æ˜å’Œè§£æé¡¹ç›®æ‰€éœ€çš„å¤–éƒ¨èµ„æºçš„è‡ªåŠ¨åŒ–æŠ€æœ¯ã€‚ æ¯ä¸ªé¡¹ç›®é€šå¸¸éƒ½åŒ…å«è®¸å¤šå¤–éƒ¨ä¾èµ–é¡¹ï¼ŒGradle å°†åœ¨æ„å»ºè¿‡ç¨‹ä¸­è§£å†³è¿™äº›ä¾èµ–é¡¹ã€‚ ä»»åŠ¡ ä»»åŠ¡æ˜¯åŸºæœ¬çš„å·¥ä½œå•å…ƒï¼Œä¾‹å¦‚ç¼–è¯‘ä»£ç æˆ–è¿è¡Œæµ‹è¯•ã€‚ æ¯ä¸ªé¡¹ç›®éƒ½åŒ…å«åœ¨æ„å»ºè„šæœ¬æˆ–æ’ä»¶ä¸­å®šä¹‰çš„ä¸€ä¸ªæˆ–å¤šä¸ªä»»åŠ¡ã€‚ æ’ä»¶ æ’ä»¶ç”¨äºæ‰©å±• Gradle çš„åŠŸèƒ½ï¼Œå¹¶å¯é€‰æ‹©å‘é¡¹ç›®è´¡çŒ®ä»»åŠ¡ã€‚ Gradle é¡¹ç›®ç»“æ„ æ–‡ä»¶/ç›®å½•åç§° ä½œç”¨ gradlew/gradlew.bat Gradle åŒ…è£…è„šæœ¬ build.gradle(.kts) é¡¹ç›®çš„ Gradle æ„å»ºè„šæœ¬ settings.gradle(.kts) Gradle è®¾ç½®æ–‡ä»¶ç”¨äºå®šä¹‰æ ¹é¡¹ç›®åç§°å’Œå­é¡¹ç›® src é¡¹ç›®/å­é¡¹ç›®çš„æºç ã€èµ„æº ä½¿ç”¨gradle/gradlewç¼–è¯‘ ç¼–è¯‘ 1./gradlew build ç¼–è¯‘å•ä¸ªä»»åŠ¡ 12./gradlew :taskname./gradlew taskname ç¼–è¯‘å•ä¸ªä»»åŠ¡ä»¥åŠå…¨éƒ¨ä¾èµ– ç¼–è¯‘å¤šé¡¹ç›®å·¥ç¨‹ä¸­çš„ä»»åŠ¡ 12./gradlew :subproject:taskName./gradlew subproject:taskName :ç›¸å½“äºåˆ†éš”ç¬¦ï¼Œç¬¬ä¸€ä¸ªå†’å·å¯ä»¥çœç•¥ æ¸…ç†äº§ç‰© 1./gradlew clean æ‰§è¡Œå¤šä¸ªä»»åŠ¡ 1./gradlew clean build settings.gradle å•å·¥ç¨‹: optional å¤šå·¥ç¨‹: mandatory è¦å£°æ˜æ‰€æœ‰å­å·¥ç¨‹ 123456rootProject.name = 'root-project' // å®šä¹‰å·¥ç¨‹åinclude('sub-project-a') include('sub-project-b')include('sub-project-c')// å£°æ˜å­å·¥ç¨‹ Settingså¯¹è±¡Settingså¯¹è±¡çš„å±æ€§ buildCache: ç¼–è¯‘ç¼“å­˜é…ç½® plugins: åº”ç”¨è¯¥è®¾ç½®çš„æ’ä»¶ rootDir: ç¼–è¯‘çš„æ ¹ç›®å½•, æ ¹é¡¹ç›®çš„ç›®å½• rootProject: æ ¹é¡¹ç›® settings: å½“å‰Settingså¯¹è±¡ Settingså¯¹è±¡çš„æ–¹æ³• include(): å®šä¹‰è‡ªé¡¹ç›® includeBuild(): çœ‹ä¸æ‡‚","link":"/home/2024/04/23/Android%E9%AB%98%E7%BA%A7/Android%20%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/22Gradle/"},{"title":"21-RxJava","text":"Singlestatic &lt;T&gt; Single.just(T t) ç”Ÿæˆä¸€ä¸ªSingledå¯¹è±¡ return onAssembly(new SingleJust(t)) onAssemblyæ˜¯ä¸€ä¸ªé’©å­å‡½æ•°ï¼Œä¸€èˆ¬æƒ…å†µä¸‹ä¸åšä»»ä½•æ“ä½œï¼Œå°±æ˜¯è°ƒç”¨ä¸€ä¸ªFunction&lt;T, R&gt;.apply() Observer æœ‰åç»­çš„onNext æœ‰å‘¨æœŸçš„Observer.interval()æ¯éš”ä¸€æ®µæ—¶é—´onNextä¸€æ¬¡ Disposable ä»»åŠ¡ä¸¢å¼ƒï¼ˆåªä¼šä¸¢å¼ƒæœªå¼€å§‹çš„ï¼Œæ­£åœ¨è¿›è¡Œçš„ä»»åŠ¡ä¸ä¼šä¸¢å¼ƒï¼‰ çº¿ç¨‹åˆ‡æ¢ subscribOn(schedualer): é€šè¿‡schedualeråˆ›å»ºä¸€ä¸ªæœ‰ä¸Šæ¸¸çš„observableï¼Œåœ¨ä¸Šçº§é€šè¿‡observerè¿”å›è§‚å¯Ÿç»“æœæ—¶åˆ‡æ¢çº¿ç¨‹ observeOn(schedualer): é€šè¿‡schedualeråˆ›å»ºä¸€ä¸ªæœ‰ä¸Šæ¸¸çš„observableï¼Œåœ¨subscribeæ—¶åˆ‡æ¢çº¿ç¨‹ï¼Œå¹¶æ‰§è¡Œä¸Šæ¸¸çš„subscribe è®¾è®¡æ¨¡å¼ è§‚å¯Ÿè€…æ¨¡å¼ Rxjavaã€kotlinçš„ observerä»£ç† LiveDataï¼ŒTextWatcher å„ç§listener å·¥å‚æ¨¡å¼ ThreadFactoryï¼ŒOkHttpçš„RequestFactory Builder OkHttpï¼ŒRetrofit å•ä¾‹æ¨¡å¼ Handlerçš„mainLooper Application Toast LayoutInflator SharedPrefrence ActivityManager é€‚é…å™¨æ¨¡å¼ å„ç§Adatorï¼š ArrayAdaptorï¼ŒBaseAdaptorï¼ŒRecyclerView.Adaptor Okhttpçš„CallAdapter ä»£ç†æ¨¡å¼ Androidæä¾›çš„å„ç§Service åŠ¨æ€ä»£ç†ï¼šRetrofit ContentResolverï¼ŒContentProvider","link":"/home/2024/03/10/Android%E9%AB%98%E7%BA%A7/Android%20%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/21RxJava/"},{"title":"åŸºç¡€05-Navigation","text":"ç®€ä»‹NavControlleræ˜¯ä¸­å¤®å¯¼èˆª APIã€‚å®ƒä¼šè·Ÿè¸ªç”¨æˆ·è®¿é—®è¿‡çš„ç›®çš„åœ°ï¼Œå¹¶å…è®¸ç”¨æˆ·åœ¨ç›®çš„åœ°ä¹‹é—´ç§»åŠ¨ã€‚ è·å–NavController fragment å¦‚æœæ˜¯NavHostFragment 1val navController = this.navController å¦‚æœæ˜¯æ™®é€šFragment 1val navController = this.findNavController() compose 1val navController = rememberNavController() NavHostFragmentå®ç°äº†NavHostæ¥å£ï¼Œå¯ä»¥ç›´æ¥è·å–NavControllerã€‚ view 12val navController = view.findNavController()// è¿™ä¸ªviewå¿…é¡»åœ¨ä¸€ä¸ªNavHostä¹‹ä¸­ activity å…ˆè·å–Activityä¸­çš„NavHostFragmentï¼Œå†è·å–NavControllerã€‚ 123val navHostFragment = supportFragmentManager.findFragmentById(R.id.nav_host_fragment) as NavHostFragmentval navController = navHostFragment.navController ä½¿ç”¨Activityçš„æ‰©å±•å‡½æ•°findNavControllerï¼Œå¯ä»¥è·å–NavControllerã€‚ 12val navController = activity.findNavController(R.id.view_within_navhost)// R.id.view_within_navhostè¿™ä¸ªviewå¿…é¡»åœ¨ä¸€ä¸ªNavHostä¹‹ä¸­ Fragment.findNavController12public fun Fragment.findNavController(): NavController = NavHostFragment.findNavController(this) 12345678910111213141516171819202122232425262728@JvmStaticpublic fun findNavController(fragment: Fragment): NavController { var findFragment: Fragment? = fragment while (findFragment != null) { if (findFragment is NavHostFragment) { return findFragment.navHostController } val primaryNavFragment = findFragment.parentFragmentManager .primaryNavigationFragment if (primaryNavFragment is NavHostFragment) { return primaryNavFragment.navHostController } findFragment = findFragment.parentFragment } // Try looking for one associated with the view instead, if applicable val view = fragment.view if (view != null) { return Navigation.findNavController(view) } // For DialogFragments, look at the dialog's decor view val dialogDecorView = (fragment as? DialogFragment)?.dialog?.window?.decorView if (dialogDecorView != null) { return Navigation.findNavController(dialogDecorView) } throw IllegalStateException(&quot;Fragment $fragment does not have a NavController set&quot;)} ä»å½“å‰fragmentå¼€å§‹å¯»æ‰¾ å¦‚æœæœ‰NavHostFragmentï¼Œå°±è¿”å›ä»–çš„NavController å¦‚æœæ²¡æœ‰ï¼Œå°±æ‰¾parentFragmentManagerçš„primaryNavigationFragment å¦‚æœæ˜¯NavHostFragmentï¼Œå°±è¿”å›ä»–çš„NavController å¦‚æœä¸æ˜¯ï¼Œå°±æŠŠå½“å‰fragmentè®¾ç½®ä¸ºparentFragmentï¼Œé‡å¤ä¸Šé¢è¿‡ç¨‹ï¼Œç›´åˆ°æ‰¾åˆ°ä¸€ä¸ªNavHostFragmentæˆ–æ²¡æœ‰parentFragmentä¸ºæ­¢ å¦‚æœå½“å‰fragmentåŠçˆ¶fragmentä¸­æ‰¾ä¸åˆ°NavHostFragmentï¼Œå°±å°è¯•ä»å½“å‰fragmentçš„viewä¸­å¯»æ‰¾ å¦‚æœè¿˜æ˜¯æ‰¾ä¸åˆ°ï¼Œå°è¯•åˆ¤æ–­å½“å‰fragmentæ˜¯å¦ä¸ºDialogFragmentï¼Œå¦‚æœæ˜¯ï¼Œåˆ™ä»DialogFragmentçš„decorViewä¸­æŸ¥æ‰¾ å¦‚æœè¿˜æ˜¯æ‰¾ä¸åˆ°ï¼Œå°±æŠ›å‡ºå¼‚å¸¸ View.findNavController12public fun View.findNavController(): NavController = Navigation.findNavController(this) Activity.findNavController123public fun Activity.findNavController( @IdRes viewId: Int): NavController = Navigation.findNavController(this, viewId) 12345678@JvmStaticpublic fun findNavController(activity: Activity, @IdRes viewId: Int): NavController { val view = ActivityCompat.requireViewById&lt;View&gt;(activity, viewId) return findViewNavController(view) ?: throw IllegalStateException( &quot;Activity $activity does not have a NavController set on $viewId&quot; )} Activityå°±æ˜¯æ¯”Viewå¤šäº†ä¸€æ­¥findViewById findViewNavController(view: View)123456private fun findViewNavController(view: View): NavController? = generateSequence(view) { it.parent as? View? }.mapNotNull { getViewNavController(it) }.firstOrNull() å…¶å®å°±æ˜¯ä»å½“å‰viewå¼€å§‹ï¼Œä¸€ç›´æ‰¾åˆ°æ ¹viewï¼Œå¦‚æœè¿‡ç¨‹ä¸­æœ‰NavControllerï¼Œå°±è¿”å› å…¶ä¸­ä¸€ä¸ªè®¾ç½®nav_controller_view_tagçš„åœ°æ–¹å¯ä»¥çœ‹NavHostFragment#onviewcreated 1234567891011@Suppress(&quot;UNCHECKED_CAST&quot;)private fun getViewNavController(view: View): NavController? { val tag = view.getTag(R.id.nav_controller_view_tag) var controller: NavController? = null if (tag is WeakReference&lt;*&gt;) { controller = (tag as WeakReference&lt;NavController&gt;).get() } else if (tag is NavController) { controller = tag } return controller} 123456@kotlin.internal.LowPriorityInOverloadResolutionpublic fun &lt;T : Any&gt; generateSequence(seed: T?, nextFunction: (T) -&gt; T?): Sequence&lt;T&gt; = if (seed == null) EmptySequence else GeneratorSequence({ seed }, nextFunction) å¯¼èˆªå›¾ä½¿ç”¨kotlin DSL12345public inline fun NavController.createGraph( startDestination: String, route: String? = null, builder: NavGraphBuilder.() -&gt; Unit): NavGraph = navigatorProvider.navigation(startDestination, route, builder) xmlé¦–å…ˆï¼Œåˆ›å»ºä¸€ä¸ª NavHostFragmentã€‚å®ƒå……å½“åŒ…å«å®é™…å¯¼èˆªå›¾çš„å¯¼èˆªå®¿ä¸»ã€‚ NavHostFragment çš„æœ€å°å®ç°ï¼š 12345678910111213&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;androidx.fragment.app.FragmentContainerView android:id=&quot;@+id/nav_host_fragment&quot; android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:navGraph=&quot;@navigation/nav_graph&quot; /&gt;&lt;/FrameLayout&gt; NavHostFragment åŒ…å« app:navGraph å±æ€§ã€‚ä½¿ç”¨æ­¤å±æ€§å¯å°†å¯¼èˆªå›¾è¿æ¥åˆ°å¯¼èˆªå®¿ä¸»ã€‚ä»¥ä¸‹ç¤ºä¾‹å±•ç¤ºäº†å¦‚ä½•å®ç°è¯¥å›¾ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;navigation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/nav_graph&quot; app:startDestination=&quot;@id/profile&quot;&gt; &lt;!-- Action back to destination which launched into this profile --&gt; &lt;action android:id=&quot;@+id/action_global_profile&quot; app:popUpTo=&quot;@id/profile&quot; app:popUpToInclusive=&quot;true&quot; /&gt; &lt;fragment android:id=&quot;@+id/profile&quot; android:name=&quot;com.example.ProfileFragment&quot; android:label=&quot;Profile&quot;&gt; &lt;!-- Action to navigate from Profile to Friends List. --&gt; &lt;action android:id=&quot;@+id/action_profile_to_friendslist&quot; app:destination=&quot;@id/friendslist&quot; /&gt; &lt;/fragment&gt; &lt;fragment android:id=&quot;@+id/friendslist&quot; android:name=&quot;com.example.FriendsListFragment&quot; android:label=&quot;Friends List&quot;&gt; &lt;!-- æ·±å±‚é“¾æ¥ --&gt; &lt;!-- https://developer.android.com/guide/navigation/design/deep-link?hl=zh-cn --&gt; &lt;deepLink app:uri=&quot;www.example.com&quot; app:action=&quot;android.intent.action.MY_ACTION&quot; app:mimeType=&quot;type/subtype&quot;/&gt; &lt;/fragment&gt; &lt;!-- Add other fragment destinations similarly. --&gt; &lt;!-- å¯¹è¯æ¡†ç›®çš„åœ° --&gt; &lt;dialog android:id=&quot;@+id/my_dialog_fragment&quot; android:name=&quot;androidx.navigation.myapp.MyDialogFragment&quot;&gt; &lt;argument android:name=&quot;myarg&quot; android:defaultValue=&quot;@null&quot; /&gt; &lt;action android:id=&quot;@+id/myaction&quot; app:destination=&quot;@+id/another_destination&quot;/&gt; &lt;/dialog&gt; &lt;!-- Activityç›®çš„åœ° --&gt; &lt;activity android:id=&quot;@+id/sampleActivityDestination&quot; android:name=&quot;com.example.android.navigation.activity.DestinationActivity&quot; android:label=&quot;@string/sampleActivityTitle&quot; /&gt; &lt;!-- åµŒå¥—å›¾ --&gt; &lt;!-- åº”ç”¨ä¸­çš„ç™»å½•æµç¨‹ã€å‘å¯¼æˆ–å…¶ä»–å­æµç¨‹é€šå¸¸æ˜¯åµŒå¥—å¯¼èˆªå›¾çš„æœ€ä½³è¡¨ç¤ºå½¢å¼ã€‚é€šè¿‡ä»¥è¿™ç§æ–¹å¼åµŒå¥—ç‹¬ç«‹çš„å­å¯¼èˆªæµç¨‹ï¼Œæ‚¨å¯ä»¥æ›´è½»æ¾åœ°ç†è§£å’Œç®¡ç†åº”ç”¨ç•Œé¢çš„ä¸»æµç¨‹ã€‚ --&gt; &lt;navigation android:id=&quot;@+id/sendMoneyGraph&quot; app:startDestination=&quot;@id/chooseRecipient&quot;&gt; &lt;fragment android:id=&quot;@+id/chooseRecipient&quot; android:name=&quot;com.example.cashdog.cashdog.ChooseRecipient&quot; android:label=&quot;fragment_choose_recipient&quot; tools:layout=&quot;@layout/fragment_choose_recipient&quot;&gt; &lt;action android:id=&quot;@+id/action_chooseRecipient_to_chooseAmountFragment&quot; app:destination=&quot;@id/chooseAmountFragment&quot; /&gt; &lt;/fragment&gt; &lt;fragment android:id=&quot;@+id/chooseAmountFragment&quot; android:name=&quot;com.example.cashdog.cashdog.ChooseAmountFragment&quot; android:label=&quot;fragment_choose_amount&quot; tools:layout=&quot;@layout/fragment_choose_amount&quot; /&gt; &lt;/navigation&gt;&lt;/navigation&gt; NavHostFragment123public open class NavHostFragment : Fragment(), NavHost { // ...} å®ç°äº†navHostæ¥å£ï¼Œä¹Ÿå°±æ˜¯æœ‰äº†ä¸€ä¸ªnavHostControllerå±æ€§ navHostController1234567891011121314151617181920212223242526272829303132333435363738394041final override val navController: NavController get() = navHostControllerinternal val navHostController: NavHostController by lazy { // 1: lazy val context = checkNotNull(context) { // 2: è·å–contextå¹¶åˆ¤ç©º &quot;NavController cannot be created before the fragment is attached&quot; } NavHostController(context).apply { // 3: ç”Ÿæˆå®ä¾‹ setLifecycleOwner(this@NavHostFragment) // 4: ä¼ é€’fragmentä¸ºlifecycleOwner setViewModelStore(viewModelStore) // 5: ä¼ é€’fragmentçš„viewModelStore onCreateNavHostController(this) // 6: å›è°ƒé€šçŸ¥fragment savedStateRegistry.consumeRestoredStateForKey(KEY_NAV_CONTROLLER_STATE)?.let { restoreState(it) } savedStateRegistry.registerSavedStateProvider(KEY_NAV_CONTROLLER_STATE) { saveState() ?: Bundle.EMPTY } savedStateRegistry.consumeRestoredStateForKey(KEY_GRAPH_ID)?.let { bundle -&gt; graphId = bundle.getInt(KEY_GRAPH_ID) } savedStateRegistry.registerSavedStateProvider(KEY_GRAPH_ID) { if (graphId != 0) { bundleOf(KEY_GRAPH_ID to graphId) } else { Bundle.EMPTY } } // 7: savedStateç›¸å…³çš„çœ‹ä¸æ‡‚ï¼Œtodo: ä»¥åå†çœ‹ if (graphId != 0) { // // 8: setGraph // Set from onInflate() setGraph(graphId) // 8.1: å¯¼èˆªå›¾idä¸ä¸º0ï¼Œæœ‰æ•ˆï¼Œè®¾ç½®å¯¼èˆªå›¾ } else { // See if it was set by NavHostFragment.create() val args = arguments val graphId = args?.getInt(KEY_GRAPH_ID) ?: 0 val startDestinationArgs = args?.getBundle(KEY_START_DESTINATION_ARGS) if (graphId != 0) { // 8.2: å°è¯•ä»fragmentçš„`arguments`è·å–å¯¼èˆªå›¾å’ŒstartDestinationArgs setGraph(graphId, startDestinationArgs) } } }} å°±æ˜¯åˆ›å»ºäº†ä¸€ä¸ªnavHostController,è¯¦ç»†å†…å®¹çœ‹NavHostControllerç±» 1: lazyè¿™ä¸ªæ²¡å•¥è¯´çš„ï¼Œå°±æ˜¯æ‡’åŠ è½½ 2: è·å–contextå¹¶åˆ¤ç©º fragmentçš„getContext 1234@Nullablepublic Context getContext() { return mHost == null ? null : mHost.getContext();} mHostä¼šåœ¨FragmentStateManagerè°ƒç”¨moveToExpectedStateæ—¶ï¼Œå¦‚æœç§»åŠ¨åˆ°Fragment.ATTACHEDçŠ¶æ€ï¼Œè°ƒç”¨attachæ–¹æ³•æ—¶ï¼Œè¿›è¡Œåˆå§‹åŒ– // todo: å†æŒ–ä¸ªå‘ä»¥åå­¦ä¹  6: å›è°ƒé€šçŸ¥fragment è¿™é‡Œè°ƒç”¨çš„æ˜¯NavHostFragmentçš„æ–¹æ³•12345@Suppress(&quot;DEPRECATION&quot;)@CallSuperprotected open fun onCreateNavHostController(navHostController: NavHostController) { onCreateNavController(navHostController)} 123456789101112131415161718192021222324/*** Callback for when the [NavController][getNavController] is created. If you* support any custom destination types, their [Navigator] should be added here to* ensure it is available before the navigation graph is inflated / set.** By default, this adds a [DialogFragmentNavigator] and [FragmentNavigator].** This is only called once when the navController is called. This will be called in [onCreate]* if the navController has not yet been called. This should not be called directly by* subclasses.** @param navController The newly created [NavController].*/@Suppress(&quot;DEPRECATION&quot;)@CallSuper@Deprecated( &quot;&quot;&quot;Override {@link #onCreateNavHostController(NavHostController)} to gain access to the full {@link NavHostController} that is created by this NavHostFragment.&quot;&quot;&quot;)protected open fun onCreateNavController(navController: NavController) { navController.navigatorProvider += DialogFragmentNavigator(requireContext(), childFragmentManager) navController.navigatorProvider.addNavigator(createFragmentNavigator())} åˆ›å»ºgetNavControlleræ—¶çš„å›è°ƒå‡½æ•°ã€‚å¦‚æœæ‚¨æ”¯æŒä»»ä½•è‡ªå®šä¹‰ç›®æ ‡ç±»å‹ï¼Œåˆ™åº”å°†å…¶å¯¼èˆªå™¨æ·»åŠ åˆ°æ­¤å¤„ï¼Œä»¥ç¡®ä¿åœ¨å¯¼èˆªå›¾inflate/setä¹‹å‰å¯ç”¨ã€‚ é»˜è®¤æƒ…å†µä¸‹ï¼Œè¿™ä¼šæ·»åŠ ä¸€ä¸ªDialogFragmentNavigatorå’ŒFragmentNavigatorã€‚ å®ƒåªåœ¨navControllerè¢«è°ƒç”¨æ—¶è¢«è°ƒç”¨ä¸€æ¬¡ã€‚å¦‚æœnavControllerè¿˜æ²¡æœ‰è¢«è°ƒç”¨ï¼Œè¿™ä¸ªå‡½æ•°ä¼šåœ¨onCreateä¸­è¢«è°ƒç”¨ã€‚å­ç±»ä¸åº”è¯¥ç›´æ¥è°ƒç”¨è¿™ä¸ªæ–¹æ³•ã€‚ ç¿»è¯‘ä¸€ä¸‹è¿™ä¸ªå‡½æ•°çš„æ³¨é‡Š ç¬¬ä¸€å¥æ˜¯è¯´å­ç±»å¯ä»¥é‡å†™è¿™ä¸ªæ–¹æ³•ï¼Œæ·»åŠ è‡ªå®šä¹‰çš„Navigator ç¬¬äºŒå¥æ˜¯è¯´é»˜è®¤ä¼šæ·»åŠ DialogFragmentNavigatorå’ŒFragmentNavigator è¦ç†è§£ç¬¬ä¸‰å¥å…ˆçœ‹ä¸‹é¢ä»£ç ï¼ŒnavHostControlleræ—¶lazyï¼Œä½†æ˜¯åœ¨Fragment#onCreateæ—¶ä¼šä¸»åŠ¨å‡ºå‘ä»–çš„åˆ›å»ºè¿‡ç¨‹123456789101112131415161718@CallSuperpublic override fun onCreate(savedInstanceState: Bundle?) { // We are accessing the NavController here to ensure that it is always created by this point navHostController if (savedInstanceState != null) { if (savedInstanceState.getBoolean(KEY_DEFAULT_NAV_HOST, false)) { defaultNavHost = true parentFragmentManager.beginTransaction() .setPrimaryNavigationFragment(this) .commit() } } // We purposefully run this last as this will trigger the onCreate() of // child fragments, which may be relying on having the NavController already // created and having its state restored by that point. super.onCreate(savedInstanceState)} 7: savedStateç›¸å…³çš„çœ‹ä¸æ‡‚ï¼Œtodo: ä»¥åå†çœ‹// todo: å å‘ï¼Œä»¥åå†çœ‹ 8: setGraph å¯¼èˆªå›¾idä¸ä¸º0ï¼Œæœ‰æ•ˆï¼Œè®¾ç½®å¯¼èˆªå›¾ å¯¼èˆªå›¾idä¸º0, å°è¯•ä»fragmentçš„argumentsè·å–å¯¼èˆªå›¾idå’ŒstartDestinationArgs setArgumentsæ˜¯çˆ¶ç±»Fragmentçš„ä¸€ä¸ªæ–¹æ³•ï¼ŒmArgumentså°±æ˜¯ä¸€ä¸ªBundle 123456public void setArguments(@Nullable Bundle args) { if (mFragmentManager != null &amp;&amp; isStateSaved()) { throw new IllegalStateException(&quot;Fragment already added and state has been saved&quot;); } mArguments = args;} åˆ›å»ºNavHostFragment1234567891011121314151617181920212223@JvmOverloads@JvmStaticpublic fun create( @NavigationRes graphResId: Int, startDestinationArgs: Bundle? = null): NavHostFragment { var b: Bundle? = null if (graphResId != 0) { b = Bundle() b.putInt(KEY_GRAPH_ID, graphResId) } if (startDestinationArgs != null) { if (b == null) { b = Bundle() } b.putBundle(KEY_START_DESTINATION_ARGS, startDestinationArgs) } val result = NavHostFragment() if (b != null) { result.arguments = b } return result} å¯ä»¥çœ‹åˆ°, KEY_GRAPH_IDå’ŒKEY_START_DESTINATION_ARGS å‡ ä¸ªkeyçš„å®šä¹‰123456789101112131415public companion object { /** */ @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public const val KEY_GRAPH_ID: String = &quot;android-support-nav:fragment:graphId&quot; /** */ @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public const val KEY_START_DESTINATION_ARGS: String = &quot;android-support-nav:fragment:startDestinationArgs&quot; private const val KEY_NAV_CONTROLLER_STATE = &quot;android-support-nav:fragment:navControllerState&quot; private const val KEY_DEFAULT_NAV_HOST = &quot;android-support-nav:fragment:defaultHost&quot;} KEY_GRAPH_IDå’ŒKEY_START_DESTINATION_ARGSè¢«é™åˆ¶åœ¨åŒç»„libä¸­ä½¿ç”¨ï¼Œä¹Ÿå°±æ˜¯ä¸æ¨èæˆ‘ä»¬è‡ªå·±æ‰‹åŠ¨é€šè¿‡è¿™ä¸¤ä¸ªkeyæ¥è®¾ç½®å¯¼èˆªå›¾idå’Œargs 1private var graphId = 0 graphIdä¹Ÿæ˜¯privateçš„ï¼Œä¹Ÿæ— æ³•é€šè¿‡ç»§æ‰¿çš„æ–¹å¼ä¿®æ”¹ä»–çš„å€¼ onInflate12345678910111213141516171819202122232425@CallSuperpublic override fun onInflate( context: Context, attrs: AttributeSet, savedInstanceState: Bundle?) { super.onInflate(context, attrs, savedInstanceState) context.obtainStyledAttributes( attrs, androidx.navigation.R.styleable.NavHost ).use { navHost -&gt; val graphId = navHost.getResourceId( androidx.navigation.R.styleable.NavHost_navGraph, 0 ) if (graphId != 0) { this.graphId = graphId } } context.obtainStyledAttributes(attrs, R.styleable.NavHostFragment).use { array -&gt; val defaultHost = array.getBoolean(R.styleable.NavHostFragment_defaultNavHost, false) if (defaultHost) { defaultNavHost = true } }} å¯¼èˆªå›¾å’ŒdefaultNavHostå¯ä»¥åœ¨FragmentContainerViewçš„xmlä¸­ä½¿ç”¨navGraphå’ŒdefaultNavHostå®šä¹‰ onSaveInstanceState onSaveInstanceStateæ—¶å¦‚æœdefaultNavHostæ˜¯trueä¼šæŠŠè¿™ä¸ªçŠ¶æ€å­˜èµ·æ¥ï¼ŒonCreateæ—¶æ¢å¤1234567@CallSuperpublic override fun onSaveInstanceState(outState: Bundle) { super.onSaveInstanceState(outState) if (defaultNavHost) { outState.putBoolean(KEY_DEFAULT_NAV_HOST, true) }} onCreate123456789101112131415161718@CallSuperpublic override fun onCreate(savedInstanceState: Bundle?) { // We are accessing the NavController here to ensure that it is always created by this point navHostController if (savedInstanceState != null) { if (savedInstanceState.getBoolean(KEY_DEFAULT_NAV_HOST, false)) { defaultNavHost = true parentFragmentManager.beginTransaction() .setPrimaryNavigationFragment(this) .commit() } } // We purposefully run this last as this will trigger the onCreate() of // child fragments, which may be relying on having the NavController already // created and having its state restored by that point. super.onCreate(savedInstanceState)} onViewCreated ä¼šç»™viewè®¾ç½®navHostController12345678910111213public override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) check(view is ViewGroup) { &quot;created host view $view is not a ViewGroup&quot; } Navigation.setViewNavController(view, navHostController) // When added programmatically, we need to set the NavController on the parent - i.e., // the View that has the ID matching this NavHostFragment. if (view.getParent() != null) { viewParent = view.getParent() as View if (viewParent!!.id == id) { Navigation.setViewNavController(viewParent!!, navHostController) } }} é€šè¿‡viewçš„setTagè®¾ç½®1234@JvmStaticpublic fun setViewNavController(view: View, controller: NavController?) { view.setTag(R.id.nav_controller_view_tag, controller)} onDestroyView éå¸¸å¯¹ç§°çš„ï¼Œåœ¨onDestroyViewæ—¶ï¼Œä¼šæŠŠviewParentä¸­çš„navHostControllerè®¾ç½®ä¸ºnull123456789public override fun onDestroyView() { super.onDestroyView() viewParent?.let { it -&gt; if (Navigation.findNavController(it) === navHostController) { Navigation.setViewNavController(it, null) } } viewParent = null} defaultNavHostå¦‚æœåœ¨attachæ—¶å‘ç°æ˜¯defaultNavHostï¼Œä¼šæäº¤ä¸€ä¸ªsetPrimaryNavigationFragmentçš„transactionï¼Œè¿½è¸ªè¿™ä¸ªæ“ä½œï¼Œä»–å…·ä½“åšäº†ä»¥ä¸‹å†…å®¹ 12345678910111213141516void setPrimaryNavigationFragment(@Nullable Fragment f) { if (f != null &amp;&amp; (!f.equals(findActiveFragment(f.mWho)) || (f.mHost != null &amp;&amp; f.mFragmentManager != this))) { throw new IllegalArgumentException(&quot;Fragment &quot; + f + &quot; is not an active fragment of FragmentManager &quot; + this); } Fragment previousPrimaryNav = mPrimaryNav; mPrimaryNav = f; dispatchParentPrimaryNavigationFragmentChanged(previousPrimaryNav); dispatchParentPrimaryNavigationFragmentChanged(mPrimaryNav);}private void dispatchParentPrimaryNavigationFragmentChanged(@Nullable Fragment f) { if (f != null &amp;&amp; f.equals(findActiveFragment(f.mWho))) { f.performPrimaryNavigationFragmentChanged(); }} æ‰¾åˆ°å‰ä¸€ä¸ªprimaryNavigationFragmentï¼Œå’Œå°†è¦è®¾ç½®ä¸ºdefaultNavçš„fragment,è°ƒç”¨å…¶performPrimaryNavigationFragmentChangedæ“ä½œ12345678910void performPrimaryNavigationFragmentChanged() { boolean isPrimaryNavigationFragment = mFragmentManager.isPrimaryNavigation(this); // Only send out the callback / dispatch if the state has changed if (mIsPrimaryNavigationFragment == null || mIsPrimaryNavigationFragment != isPrimaryNavigationFragment) { mIsPrimaryNavigationFragment = isPrimaryNavigationFragment; onPrimaryNavigationFragmentChanged(isPrimaryNavigationFragment); mChildFragmentManager.dispatchPrimaryNavigationFragmentChanged(); }} æ›´æ–°Fragmentä¸­çš„mIsPrimaryNavigationFragmentè¿™ä¸ªflagï¼Œå¹¶ä¸”æ‰¾åˆ°å­fragmentï¼Œä¹Ÿå»æ›´æ–°å…¶çŠ¶æ€ è°ƒç”¨é’©å­å‡½æ•°onPrimaryNavigationFragmentChanged 12public void onPrimaryNavigationFragmentChanged(boolean isPrimaryNavigationFragment) {} ä»–æ˜¯ä¸€ä¸ªç©ºçš„æ–¹æ³•ï¼Œå­ç±»å¯ä»¥é‡å†™ï¼ŒNavHostFragmentä¹Ÿæ²¡æœ‰å®ç°å®ƒï¼Œçœ‹æ¥æ˜¯ç»™ç¨‹åºå‘˜è‡ªç”±å‘æŒ¥çš„ã€‚ å®˜æ–¹æ–‡æ¡£ä¸­åˆ›å»º NavHostFragment æåˆ°è¿™ä¸ªæ“ä½œä¼š&quot;å…è®¸æ‚¨çš„ NavHost æˆªè·å¯¹ç³»ç»Ÿâ€œè¿”å›â€æŒ‰é’®çš„æŒ‰ä¸‹æ“ä½œ&quot;ã€‚ä¸Šé¢çš„ä»£ç å¥½åƒå¹¶æ²¡æœ‰ä½“ç°å‡ºæ¥ã€‚ NavHostControllerç±» NavHostControllerç»§æ‰¿è‡ªNavControllerï¼Œå…¶ä¸­æ²¡æœ‰ä»€ä¹ˆä»£ç ï¼Œå…¶æœ¬èº«æ˜¯opençš„ï¼Œä½†å®ƒæŠŠçˆ¶ç±»çš„å‡ ä¸ªæ–¹æ³•è®¾ç½®ä¸ºfinalï¼ŒåŒ…æ‹¬ï¼š setLifecycleOwner setOnBackPressedDispatcher enableOnBackPressed setViewModelStore NavController3: ç”Ÿæˆå®ä¾‹NavHostControlleræ„é€ å‡½æ•° 1234public open class NavHostController(context: Context) : NavController(context) { // ...} 123456789101112public open class NavController( /** @suppress */ @get:RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public val context: Context) { // ... init { _navigatorProvider.addNavigator(NavGraphNavigator(_navigatorProvider)) _navigatorProvider.addNavigator(ActivityNavigator(context)) } // ...} ä¼ é€’contextå°±æ˜¯å­˜èµ·æ¥ä»¥åä¼šç”¨ é€šè¿‡contextåˆ›å»ºActivityNavigator å¯ä»¥å…ˆå‰§é€ä¸€ä¸‹ï¼ŒNavigatorå°±æ˜¯ä¸€ä¸ªå…·ä½“å®æ–½è·³è½¬ç­‰æ“ä½œçš„ç±» æ¯”å¦‚ActivityNavigatorå°±ä¼šè°ƒç”¨startActivity FragmentNavigatorå°±ä¼šæ„é€ FragmentTransactionæ¥è·³è½¬fragment 4: ä¼ é€’fragmentä¸ºlifecycleOwner123public final override fun setLifecycleOwner(owner: LifecycleOwner) { super.setLifecycleOwner(owner)} 123456789@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)public open fun setLifecycleOwner(owner: LifecycleOwner) { if (owner == lifecycleOwner) { return } lifecycleOwner?.lifecycle?.removeObserver(lifecycleObserver) lifecycleOwner = owner owner.lifecycle.addObserver(lifecycleObserver)} å»æ‰åŸæ¥çš„ownerï¼Œæ·»åŠ æ–°çš„ownerï¼Œå¹¶æ·»åŠ è§‚å¯Ÿè€…12345678private val lifecycleObserver: LifecycleObserver = LifecycleEventObserver { _, event -&gt; hostLifecycleState = event.targetState if (_graph != null) { for (entry in backQueue) { entry.handleLifecycleEvent(event) } }} hostLifecycleStateå°±æ˜¯å­˜å¯¹åº”çš„ç”Ÿå‘½å‘¨æœŸçŠ¶æ€ _graphæ˜¯ä¸€ä¸ªNavGraph, åœ¨setGraphä¸­åˆå§‹åŒ– backQueueæ˜¯å­˜æ”¾NavBackStackEntryçš„åŒç«¯é˜Ÿåˆ— 5: ä¼ é€’fragmentçš„viewModelStore123public final override fun setViewModelStore(viewModelStore: ViewModelStore) { super.setViewModelStore(viewModelStore)} 12345678@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)public open fun setViewModelStore(viewModelStore: ViewModelStore) { if (viewModel == NavControllerViewModel.getInstance(viewModelStore)) { return } check(backQueue.isEmpty()) { &quot;ViewModelStore should be set before setGraph call&quot; } viewModel = NavControllerViewModel.getInstance(viewModelStore)} å°±æ˜¯åˆ›å»ºäº†ä¸€ä¸ªviewModelï¼Œä»¥åä¼šç”¨ 8: setGraph å¦‚æœå¯¼èˆªå›¾idä¸ä¸º0ï¼Œæœ‰æ•ˆï¼Œè®¾ç½®å¯¼èˆªå›¾ 123public open fun setGraph(@NavigationRes graphResId: Int) { setGraph(navInflater.inflate(graphResId), null)} å¦‚æœå¯¼èˆªå›¾ä¸º0ï¼Œåˆ™å°è¯•ä»fragmentçš„argumentsä¸­è·å–å¯¼èˆªå›¾idå’ŒstartDestinationArgs 12345@MainThread@CallSuperpublic open fun setGraph(@NavigationRes graphResId: Int, startDestinationArgs: Bundle?) { setGraph(navInflater.inflate(graphResId), startDestinationArgs)} æœ€ç»ˆéƒ½è°ƒç”¨äº†setGraph(graph: NavGraph, startDestinationArgs: Bundle?) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*** Sets the [navigation graph][NavGraph] to the specified graph.* Any current navigation graph data (including back stack) will be replaced.** The graph can be retrieved later via [graph].** @param graph graph to set* @see NavController.setGraph* @see NavController.graph*/@MainThread@CallSuperpublic open fun setGraph(graph: NavGraph, startDestinationArgs: Bundle?) { if (_graph != graph) { _graph?.let { previousGraph -&gt; // Clear all saved back stacks by iterating through a copy of the saved keys, // thus avoiding any concurrent modification exceptions val savedBackStackIds = ArrayList(backStackMap.keys) savedBackStackIds.forEach { id -&gt; clearBackStackInternal(id) } // Pop everything from the old graph off the back stack NavControllerInternal(previousGraph.id, true) } _graph = graph onGraphCreated(startDestinationArgs) } else { // first we update _graph with new instances from graph for (i in 0 until graph.nodes.size()) { val newDestination = graph.nodes.valueAt(i) val key = _graph!!.nodes.keyAt(i) _graph!!.nodes.replace(key, newDestination) } // then we update backstack with the new instances backQueue.forEach { entry -&gt; // we will trace this hierarchy in new graph to get new destination instance val hierarchy = entry.destination.hierarchy.toList().asReversed() val newDestination = hierarchy.fold(_graph!!) { newDest: NavDestination, oldDest: NavDestination -&gt; if (oldDest == _graph &amp;&amp; newDest == graph) { // if root graph, it is already the node that matches with oldDest newDest } else if (newDest is NavGraph) { // otherwise we walk down the hierarchy to the next child newDest.findNode(oldDest.id)!! } else { // final leaf node found newDest } } entry.destination = newDestination } }} è€ƒè™‘äº†ä¸¤ç§æƒ…å†µï¼ŒsetGraphå‰å_graphå’Œgraphæ˜¯å¦ç›¸ç­‰ æ³¨æ„ktä»£ç æœ‰è¿ç®—ç¬¦é‡è½½ï¼Œå®é™…ä¸Šè°ƒç”¨çš„æ˜¯NavGraphçš„equals 12345678override fun equals(other: Any?): Boolean { if (this === other) return true if (other == null || other !is NavGraph) return false return super.equals(other) &amp;&amp; nodes.size == other.nodes.size &amp;&amp; startDestinationId == other.startDestinationId &amp;&amp; nodes.valueIterator().asSequence().all { it == other.nodes.get(it.id) }} navigateé€šè¿‡actionçš„èµ„æºidè·³è½¬çš„123456789101112131415161718192021// id1: public open fun navigate(@IdRes resId: Int) { navigate(resId, null)}// id2: public open fun navigate(@IdRes resId: Int, args: Bundle?) { navigate(resId, args, null)}// id3: public open fun navigate(@IdRes resId: Int, args: Bundle?, navOptions: NavOptions?) { navigate(resId, args, navOptions, null)}// id4: public open fun navigate( @IdRes resId: Int, args: Bundle?, navOptions: NavOptions?, navigatorExtras: Navigator.Extras?) { // ...} ä¸€ä¸ªå‚æ•°çš„è°ƒä¸¤ä¸ªå‚æ•°çš„ï¼Œä¸¤ä¸ªå‚æ•°çš„è°ƒä¸‰ä¸ªå‚æ•°çš„å››ä¸ªå‚æ•°çš„å·¨é•¿ä½†ä¹Ÿä¸æ˜¯æ ¸å¿ƒçš„æ–¹æ³•ï¼Œè¿˜ä¼šè°ƒç”¨æ ¸å¿ƒçš„navigateæ–¹æ³• 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// id4:public open fun navigate( @IdRes resId: Int, args: Bundle?, navOptions: NavOptions?, navigatorExtras: Navigator.Extras?) { var finalNavOptions = navOptions // 1: navOptions val currentNode = ( if (backQueue.isEmpty()) _graph else backQueue.last().destination ) ?: throw IllegalStateException( &quot;No current destination found. Ensure a navigation graph has been set for &quot; + &quot;NavController $this.&quot; ) @IdRes var destId = resId val navAction = currentNode.getAction(resId) var combinedArgs: Bundle? = null if (navAction != null) { if (finalNavOptions == null) { // 1.2: navOptionsç©ºçš„æƒ…å†µ finalNavOptions = navAction.navOptions } destId = navAction.destinationId // 3: destId val navActionArgs = navAction.defaultArguments if (navActionArgs != null) { combinedArgs = Bundle() combinedArgs.putAll(navActionArgs) } } if (args != null) { if (combinedArgs == null) { combinedArgs = Bundle() } combinedArgs.putAll(args) // 2: åˆå¹¶args } if (destId == 0 &amp;&amp; finalNavOptions != null &amp;&amp; (finalNavOptions.popUpToId != -1 || finalNavOptions.popUpToRoute != null) ) { when { // 5: popUpTo finalNavOptions.popUpToRoute != null -&gt; NavController( finalNavOptions.popUpToRoute!!, finalNavOptions.isPopUpToInclusive() ) finalNavOptions.popUpToId != -1 -&gt; NavController( finalNavOptions.popUpToId, finalNavOptions.isPopUpToInclusive() ) } return } require(destId != 0) { &quot;Destination id == 0 can only be used in conjunction with a valid navOptions.popUpTo&quot; } val node = findDestination(destId) // 4: æ‰¾åˆ°destinationçš„node if (node == null) { val dest = NavDestination.getDisplayName(context, destId) require(navAction == null) { &quot;Navigation destination $dest referenced from action &quot; + &quot;${NavDestination.getDisplayName(context, resId)} cannot be found from &quot; + &quot;the current destination $currentNode&quot; } throw IllegalArgumentException( &quot;Navigation action/destination $dest cannot be found from the current &quot; + &quot;destination $currentNode&quot; ) } navigate(node, combinedArgs, finalNavOptions, navigatorExtras) // 6:} å¤§æ¦‚åšäº†ä¸‹é¢å‡ ä»¶äº‹ 1: å¦‚æœè°ƒç”¨navigateæ—¶ 1.1: NavOptionså‚æ•°ä¸ç©ºï¼Œåˆ™å¿½ç•¥å½“å‰nodeçš„actionä¸­å­˜å‚¨çš„NavOptions 1.2: å¦‚æœç©ºï¼Œåˆ™ä½¿ç”¨å½“å‰nodeçš„actionä¸­å­˜å‚¨çš„NavOptions 2: å°†actionçš„defaultArgumentså’Œå‚æ•°ä¸­çš„argsåˆå¹¶ï¼Œå¹¶ä¼ é€’ç»™æ ¸å¿ƒçš„navigate 3: ä»actionä¸­è·å–destinationId 4: ä»å½“å‰å›¾ä¸­æ‰¾åˆ°destinationIdå¯¹åº”çš„node 5: å¼¹å‡ºå¯¼èˆªæ ˆï¼Œç›´åˆ°é‡åˆ°å¯¹åº”çš„routeæˆ–id 6: å°†nodeå’Œåˆå¹¶çš„args, NavOptions, è¿˜æœ‰navigatorExtrasä¼ é€’ç»™æ ¸å¿ƒçš„navigateæ–¹æ³• é€šè¿‡NavDirectionsè·³è½¬çš„123456789101112131415// NavDirections1:@MainThreadpublic open fun navigate(directions: NavDirections) { navigate(directions.actionId, directions.arguments, null)}// NavDirections2:@MainThreadpublic open fun navigate(directions: NavDirections, navOptions: NavOptions?) { navigate(directions.actionId, directions.arguments, navOptions)}// NavDirections3:@MainThreadpublic open fun navigate(directions: NavDirections, navigatorExtras: Navigator.Extras) { navigate(directions.actionId, directions.arguments, null, navigatorExtras)} å…ˆçœ‹ä¸€ä¸‹NavDirectionsæ˜¯å•¥ 12345public interface NavDirections { @get:IdRes public val actionId: Int public val arguments: Bundle} å…¶å®å°±æ˜¯æŠŠaction-idå’ŒargumentsåŒ…è£…äº†ä¸€ä¸‹ï¼Œæœ€ç»ˆä¹Ÿä¼šè°ƒç”¨id4 é€šè¿‡Uriç±»å‹çš„DeepLinkè·³è½¬çš„12345678910111213141516171819// uri1:@MainThreadpublic open fun navigate(deepLink: Uri) { navigate(NavDeepLinkRequest(deepLink, null, null))}// uri2:@MainThreadpublic open fun navigate(deepLink: Uri, navOptions: NavOptions?) { navigate(NavDeepLinkRequest(deepLink, null, null), navOptions, null)}// uri3:@MainThreadpublic open fun navigate( deepLink: Uri, navOptions: NavOptions?, navigatorExtras: Navigator.Extras?) { navigate(NavDeepLinkRequest(deepLink, null, null), navOptions, navigatorExtras)} ä»–ä»¬éƒ½ä¼šæ„é€ NavDeepLinkRequestå¯¹è±¡ç„¶åè°ƒç”¨NavDeepLinkRequest3 é€šè¿‡routeè·³è½¬çš„1234567891011121314// route1:public fun navigate(route: String, builder: NavOptionsBuilder.() -&gt; Unit) { navigate(route, navOptions(builder))}public fun navigate( route: String, navOptions: NavOptions? = null, navigatorExtras: Navigator.Extras? = null) { navigate( NavDeepLinkRequest.Builder.fromUri(createRoute(route).toUri()).build(), navOptions, navigatorExtras )} é€šè¿‡routeè·³è½¬çš„ï¼Œæœ€åä¹Ÿä¼šå˜æˆdeeplink é€šè¿‡NavDeepLinkRequestè·³è½¬çš„12345678910111213141516171819// NavDeepLinkRequest1:@MainThreadpublic open fun navigate(request: NavDeepLinkRequest) { navigate(request, null)}// NavDeepLinkRequest2:@MainThreadpublic open fun navigate(request: NavDeepLinkRequest, navOptions: NavOptions?) { navigate(request, navOptions, null)}// NavDeepLinkRequest3:@MainThreadpublic open fun navigate( request: NavDeepLinkRequest, navOptions: NavOptions?, navigatorExtras: Navigator.Extras?) { // ...} 123456789101112131415161718192021222324252627public open fun navigate( request: NavDeepLinkRequest, navOptions: NavOptions?, navigatorExtras: Navigator.Extras?) { requireNotNull(_graph) { &quot;Cannot navigate to $request. Navigation graph has not been set for &quot; + &quot;NavController $this.&quot; } val deepLinkMatch = _graph!!.matchDeepLink(request) if (deepLinkMatch != null) { val destination = deepLinkMatch.destination val args = destination.addInDefaultArgs(deepLinkMatch.matchingArgs) ?: Bundle() val node = deepLinkMatch.destination val intent = Intent().apply { setDataAndType(request.uri, request.mimeType) action = request.action } args.putParcelable(KEY_DEEP_LINK_INTENT, intent) navigate(node, args, navOptions, navigatorExtras) } else { throw IllegalArgumentException( &quot;Navigation destination that matches request $request cannot be found in the &quot; + &quot;navigation graph $_graph&quot; ) }} é€šè¿‡matchDeepLinkæ–¹æ³•æ‰¾åˆ°matchå¯¹è±¡ å¦‚æœæ²¡æœ‰matchï¼ŒæŠ›å‡ºå¼‚å¸¸ å¦‚æœæœ‰matchï¼Œä»matchå¯¹è±¡ä¸­å–å‡ºdestinationï¼Œå’Œid4æ–¹æ³•ä¸€æ ·ï¼Œæœ€ç»ˆéƒ½ä¼šè°ƒç”¨æ ¸å¿ƒçš„navigateæ–¹æ³•ï¼ŒåŒæ ·éœ€è¦æ‰¾åˆ°æ ¸å¿ƒnavigateæ–¹æ³•æ‰€éœ€çš„å‡ ä¸ªå‚æ•° node: ä»destinationå¯¹è±¡ä¸­è·å¾— args: ä»destinationå¯¹è±¡ä¸­è·å¾— navOptions: å‡½æ•°å‚æ•° navigatorExtras: å‡½æ•°å‚æ•° è°ƒç”¨æ ¸å¿ƒçš„navigateæ–¹æ³• æ ¸å¿ƒçš„navigateæ–¹æ³•123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private fun navigate( node: NavDestination, args: Bundle?, navOptions: NavOptions?, navigatorExtras: Navigator.Extras?) { navigatorState.values.forEach { state -&gt; state.isNavigating = true } var popped = false var launchSingleTop = false var navigated = false if (navOptions != null) { when { // 1: æ ¹æ®navOptionsçš„ä¸åŒæƒ…å†µï¼Œpopæ ˆ navOptions.popUpToRoute != null -&gt; popped = NavControllerInternal( navOptions.popUpToRoute!!, navOptions.isPopUpToInclusive(), navOptions.shouldPopUpToSaveState() ) navOptions.popUpToId != -1 -&gt; popped = NavControllerInternal( navOptions.popUpToId, navOptions.isPopUpToInclusive(), navOptions.shouldPopUpToSaveState() ) } } val finalArgs = node.addInDefaultArgs(args) // Now determine what new destinations we need to add to the back stack if (navOptions?.shouldRestoreState() == true &amp;&amp; backStackMap.containsKey(node.id)) { navigated = restoreStateInternal(node.id, finalArgs, navOptions, navigatorExtras) // 2: éœ€è¦æ¢å¤çŠ¶æ€ï¼Œä¸”backStackMapä¸­å­˜åœ¨å¯¹åº”çš„nodeçš„æƒ…å†µ } else { launchSingleTop = navOptions?.shouldLaunchSingleTop() == true &amp;&amp; launchSingleTopInternal(node, args) //3: singleTopçš„æƒ…å†µ if (!launchSingleTop) { // ä¸éœ€è¦singleTopçš„æƒ…å†µ // Not a single top operation, so we're looking to add the node to the back stack val backStackEntry = NavBackStackEntry.create( context, node, finalArgs, hostLifecycleState, viewModel ) val navigator = _navigatorProvider.getNavigator&lt;Navigator&lt;NavDestination&gt;&gt;( node.navigatorName ) navigator.navigateInternal(listOf(backStackEntry), navOptions, navigatorExtras) { navigated = true addEntryToBackStack(node, finalArgs, it) } } } updateOnBackPressedCallbackEnabled() // 4: çœ‹èµ·æ¥æ˜¯è®¾ç½®ä¸€ä¸ªflag navigatorState.values.forEach { state -&gt; state.isNavigating = false // 5: åˆè®¾ç½®ä¸€ä¸ªflag } if (popped || navigated || launchSingleTop) { dispatchOnDestinationChanged() // 6: è°ƒç”¨å›è°ƒ } else { updateBackStackLifecycle() // 7: æ›´æ–°å¯¼èˆªæ ˆçš„ç”Ÿå‘½å‘¨æœŸ }} æ ¹æ®ä¸Šé¢çš„æ³¨é‡Šï¼Œä¸€å…±åšäº†7ä»¶äº‹ 2: éœ€è¦æ¢å¤çŠ¶æ€ï¼Œä¸”backStackMapä¸­å­˜åœ¨å¯¹åº”çš„nodeçš„æƒ…å†µ12345678910111213141516171819public class NavOptions internal constructor( private val singleTop: Boolean, private val restoreState: Boolean, // ...) { public fun shouldRestoreState(): Boolean { return restoreState } // ... public class Builder { private var singleTop = false private var restoreState = false // ... public fun setRestoreState(restoreState: Boolean): Builder { this.restoreState = restoreState return this } }} shouldRestoreStateè¿”å›çš„æ˜¯restoreStateï¼Œæ˜¯åœ¨æ„é€ æ—¶ç¡®å®šçš„ 1234567891011121314151617private fun restoreStateInternal( id: Int, args: Bundle?, navOptions: NavOptions?, navigatorExtras: Navigator.Extras?): Boolean { if (!backStackMap.containsKey(id)) { return false // 1: é¦–å…ˆæ˜¯é˜²æ­¢backStackMapä¸­æ²¡æœ‰å¯¹åº”çš„node } val backStackId = backStackMap[id] // Clear out the state we're going to restore so that it isn't restored a second time backStackMap.values.removeAll { it == backStackId } // 2: åˆ é™¤mapä¸­æ‰€æœ‰å’ŒbackStackIdç›¸ç­‰çš„entry val backStackState = backStackStates.remove(backStackId) // 3: åˆ é™¤backStackStatesä¸­å¯¹åº”çš„entry // Now restore the back stack from its saved state val entries = instantiateBackStack(backStackState) // 4: æ›´æ–°backStackStateä¸­çš„NavBackStackEntryState return executeRestoreState(entries, args, navOptions, navigatorExtras) // 5: æ‰¾åˆ°Navigatorï¼Œå¯¼èˆªåˆ°å¯¹åº”ä½ç½®} 3: åˆ é™¤backStackStatesä¸­å¯¹åº”çš„entryçœ‹ä¸€ä¸‹backStackStatesçš„æ•°æ®ç»“æ„ 1private val backStackStates = mutableMapOf&lt;String, ArrayDeque&lt;NavBackStackEntryState&gt;&gt;() 4: æ›´æ–°backStackStateä¸­çš„12345678910111213141516171819private fun instantiateBackStack( backStackState: ArrayDeque&lt;NavBackStackEntryState&gt;?): List&lt;NavBackStackEntry&gt; { val backStack = mutableListOf&lt;NavBackStackEntry&gt;() var currentDestination = backQueue.lastOrNull()?.destination ?: graph backStackState?.forEach { state -&gt; val node = currentDestination.findDestination(state.destinationId) checkNotNull(node) { val dest = NavDestination.getDisplayName( context, state.destinationId ) &quot;Restore State failed: destination $dest cannot be found from the current &quot; + &quot;destination $currentDestination&quot; } backStack += state.instantiate(context, node, hostLifecycleState, viewModel) currentDestination = node } return backStack} åˆ›å»ºä¸€ä¸ªç©ºçš„backStackï¼Œç„¶åéå†backStackState æ‰¾åˆ°å½“å‰æ ˆæœ€åä¸€ä¸ªentryçš„destination ä»currentDestinationä¸­æ‰¾åˆ°state.destinationIdå¯¹åº”çš„node æ ¹æ®nodeé‡æ–°åˆ›å»ºstateå¯¹è±¡ï¼Œæ·»åŠ åˆ°backStackä¸­ï¼Œè¿”å›è¯¥backStack 5: æ‰¾åˆ°Navigatorï¼Œå¯¼èˆªåˆ°å¯¹åº”ä½ç½®1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private fun executeRestoreState( entries: List&lt;NavBackStackEntry&gt;, args: Bundle?, navOptions: NavOptions?, navigatorExtras: Navigator.Extras?): Boolean { // Split up the entries by Navigator so we can restore them as an atomic operation val entriesGroupedByNavigator = mutableListOf&lt;MutableList&lt;NavBackStackEntry&gt;&gt;() entries.filterNot { entry -&gt; // Skip navigation graphs - they'll be added by addEntryToBackStack() entry.destination is NavGraph }.forEach { entry -&gt; val previousEntryList = entriesGroupedByNavigator.lastOrNull() val previousNavigatorName = previousEntryList?.last()?.destination?.navigatorName if (previousNavigatorName == entry.destination.navigatorName) { // Group back to back entries associated with the same Navigator together previousEntryList += entry } else { // Create a new group for the new Navigator entriesGroupedByNavigator += mutableListOf(entry) } // 1: å¦‚æœ navigatorNameå’Œå‰ä¸€ä¸ªçš„ç›¸ç­‰ï¼Œåˆ™æ·»åŠ åˆ°å‰ä¸€ä¸ªçš„listä¸­ï¼Œå¦åˆ™æ·»åŠ åˆ°æ–°å»ºä¸€ä¸ªlistä¸­ï¼Œæœ€åä¼šå¾—åˆ°ä¸€ä¸ªäºŒç»´æ•°ç»„ï¼Œæ¯ä¸ªæ•°ç»„ä¸­çš„å…ƒç´ éƒ½æ˜¯å…·æœ‰ç›¸åŒNavigatorNameçš„ } var navigated = false // Now actually navigate to each set of entries for (entryList in entriesGroupedByNavigator) { val navigator = _navigatorProvider.getNavigator&lt;Navigator&lt;NavDestination&gt;&gt;( entryList.first().destination.navigatorName ) // 2: æ¯ä¸ªentryListéƒ½å…·æœ‰ç›¸åŒçš„navigatorNameï¼Œæ‰¾åˆ°å¯¹åº”çš„Navigator var lastNavigatedIndex = 0 navigator.navigateInternal(entryList, navOptions, navigatorExtras) { entry -&gt; navigated = true // If this destination is part of the restored back stack, // pass all destinations between the last navigated entry and this one // to ensure that any navigation graphs are properly restored as well val entryIndex = entries.indexOf(entry) val restoredEntries = if (entryIndex != -1) { entries.subList(lastNavigatedIndex, entryIndex + 1).also { lastNavigatedIndex = entryIndex + 1 } } else { emptyList() } addEntryToBackStack(entry.destination, args, entry, restoredEntries) } // æ‰§è¡Œå¯¼èˆªæ“ä½œ } return navigated} 12345678910 private fun Navigator&lt;out NavDestination&gt;.navigateInternal( entries: List&lt;NavBackStackEntry&gt;, navOptions: NavOptions?, navigatorExtras: Navigator.Extras?, handler: (backStackEntry: NavBackStackEntry) -&gt; Unit = {}) { addToBackStackHandler = handler // å…ˆæŠŠå›è°ƒæ”¾åˆ°ä¸€è¾¹ï¼Œç¨åç”±NavControllerNavigatorStateçš„pushæ–¹æ³•è°ƒç”¨ navigate(entries, navOptions, navigatorExtras) // æ‰§è¡Œå¯¼èˆªæ“ä½œ addToBackStackHandler = null} 123456789101112131415161718192021222324public open fun navigate( entries: List&lt;NavBackStackEntry&gt;, navOptions: NavOptions?, navigatorExtras: Extras?) { entries.asSequence().map { backStackEntry -&gt; // éå†entriesï¼ŒæŠŠä»–è¿›è¡Œå˜æ¢ val destination = backStackEntry.destination as? D ?: return@map null val navigatedToDestination = navigate( destination, backStackEntry.arguments, navOptions, navigatorExtras ) // ç”±å­ç±»å®ç°ï¼Œæ‰§è¡ŒçœŸæ­£çš„å¯¼èˆªæ“ä½œ when (navigatedToDestination) { null -&gt; null // è¿”å›nullï¼Œå½“å‰backStackEntryå˜æˆnull destination -&gt; backStackEntry // è¿”å›å¯¼èˆªç»“æœä¸destinationç›¸åŒï¼ŒbackStackEntryä¹Ÿä¸å˜ else -&gt; { state.createBackStackEntry( navigatedToDestination, navigatedToDestination.addInDefaultArgs(backStackEntry.arguments) ) // å¦åˆ™åˆ›å»ºæ–°çš„backStackEntry } } }.filterNotNull().forEach { backStackEntry -&gt; state.push(backStackEntry) } // 1: å¯¹äºä¸ä¸ºnullçš„ï¼Œé‡æ–°æ”¾å…¥stateä¸­,æ³¨æ„è¿™é‡Œè°ƒç”¨çš„pushæ–¹æ³•} è¿™é‡Œé¢çš„stateå®šä¹‰å¦‚ä¸‹ 12345678910protected val state: NavigatorState get() = checkNotNull(_state) { &quot;You cannot access the Navigator's state until the Navigator is attached&quot; }private var _state: NavigatorState? = null@CallSuperpublic open fun onAttach(state: NavigatorState) { // åœ¨onAttachæ—¶ä¼šåˆå§‹åŒ– _state = state isAttached = true} åœ¨NavControllerçš„onGraphCreatedæ–¹æ³•ä¸­æœ‰ 12345678910111213141516171819val navigatorBackStack = navigatorState.getOrPut(navigator) { NavControllerNavigatorState(navigator)}navigator.onAttach(navigatorBackStack)// å…¶ä¸­navigatorStateæ˜¯ä»navigatoråˆ°NavControllerNavigatorStateçš„mapprivate val navigatorState = mutableMapOf&lt;Navigator&lt;out NavDestination&gt;, NavControllerNavigatorState&gt;()// getOrPutæ–¹æ³•å°±æ˜¯å½“æ²¡æœ‰keyæ—¶ï¼Œè°ƒç”¨åé¢çš„å‡½æ•°æ’å…¥åˆ°mapä¸­å¹¶è¿”å›ï¼Œæœ‰keyæ—¶åˆ™è¿”å›æŸ¥è¯¢åˆ°çš„valuepublic inline fun &lt;K, V&gt; MutableMap&lt;K, V&gt;.getOrPut(key: K, defaultValue: () -&gt; V): V { val value = get(key) return if (value == null) { val answer = defaultValue() put(key, answer) answer } else { value }} æ‰€ä»¥ä¸Šé¢1:å‡ºè°ƒç”¨çš„pushæ–¹æ³•ï¼Œå°±æ˜¯NavControllerNavigatorStateçš„pushæ–¹æ³• 123456789101112131415161718192021222324override fun push(backStackEntry: NavBackStackEntry) { val destinationNavigator: Navigator&lt;out NavDestination&gt; = _navigatorProvider[backStackEntry.destination.navigatorName] if (destinationNavigator == navigator) { val handler = addToBackStackHandler // è¿˜è®°å¾—å‰é¢å­˜èµ·æ¥çš„å›è°ƒå—ï¼Œå°±ä¼šåœ¨è¿™é‡Œè°ƒç”¨ if (handler != null) { handler(backStackEntry) addInternal(backStackEntry) } else { // TODO handle the Navigator calling add() outside of a call to navigate() Log.i( TAG, &quot;Ignoring add of destination ${backStackEntry.destination} &quot; + &quot;outside of the call to navigate(). &quot; ) } } else { val navigatorBackStack = checkNotNull(navigatorState[destinationNavigator]) { &quot;NavigatorBackStack for ${backStackEntry.destination.navigatorName} should &quot; + &quot;already be created&quot; } navigatorBackStack.push(backStackEntry) }} ç–‘é—®ï¼Œä»–è·³è½¬é‚£ä¹ˆå¤šå¹²ä»€ä¹ˆï¼Ÿ 3: singleTopçš„æƒ…å†µ123456789public class NavOptions internal constructor( private val singleTop: Boolean, // ...) { public fun shouldLaunchSingleTop(): Boolean { return singleTop } // ...} shouldLaunchSingleTopè¿”å›çš„å€¼æ˜¯å…¶æ„é€ æ—¶çš„ä¸€ä¸ªæ ‡å¿—ä½ åœ¨åˆ†ælaunchSingleTopInternalæ–¹æ³•å‰ï¼Œå…ˆçœ‹ä¸€ä¸‹NavControllerä¸­ç»´æŠ¤çš„ä¸€ä¸ªçˆ¶å­å…³ç³» 12private val childToParentEntries = mutableMapOf&lt;NavBackStackEntry, NavBackStackEntry&gt;()private val parentToChildCount = mutableMapOf&lt;NavBackStackEntry, AtomicInteger&gt;() çœ‹èµ·æ¥NavBackStackEntryä¹‹é—´å­˜åœ¨ä¸€ä¸ªçˆ¶å­å…³ç³»ï¼Œå¯èƒ½æ˜¯ä¸€å¼ å›¾çš„å½¢å¼ï¼Œä¸€ä¸ªmapå­˜å‚¨è¿™ç§çˆ¶å­å…³ç³»ï¼Œä¸€ä¸ªmapå­˜å‚¨å­èŠ‚ç‚¹çš„ä¸ªæ•° åé¢çœ‹äº†NavDestinationå’ŒNavBackStackEntryåå°±çŸ¥é“ï¼Œè¿™é‡Œç»´æŠ¤çš„å°±æ˜¯NavDestinationä¹‹é—´çš„çˆ¶å­å…³ç³»ã€‚ 12345678910111213141516171819private fun linkChildToParent(child: NavBackStackEntry, parent: NavBackStackEntry) { childToParentEntries[child] = parent if (parentToChildCount[parent] == null) { parentToChildCount[parent] = AtomicInteger(0) } parentToChildCount[parent]!!.incrementAndGet()}internal fun unlinkChildFromParent(child: NavBackStackEntry): NavBackStackEntry? { val parent = childToParentEntries.remove(child) ?: return null val count = parentToChildCount[parent]?.decrementAndGet() if (count == 0) { val navGraphNavigator: Navigator&lt;out NavGraph&gt; = _navigatorProvider[parent.destination.navigatorName] navigatorState[navGraphNavigator]?.markTransitionComplete(parent) parentToChildCount.remove(parent) } return parent} è¿™ä¸¤ä¸ªå‡½æ•°ç”¨äºç»´æŠ¤NavBackStackEntryä¹‹é—´çš„çˆ¶å­å…³ç³»å½“ä¸€ä¸ªNavBackStackEntryçš„childä¸ªæ•°ä¸º0æ—¶ï¼Œä¼šè°ƒç”¨markTransitionCompleteï¼Œå…·ä½“å¹²å•¥çš„ç»§ç»­æŒ–å‘å§ï¼// todo : markTransitionComplete 123456789101112131415161718192021222324252627282930313233343536373839404142private fun launchSingleTopInternal( node: NavDestination, args: Bundle?): Boolean { val currentBackStackEntry = currentBackStackEntry val nodeId = if (node is NavGraph) node.findStartDestination().id else node.id if (nodeId != currentBackStackEntry?.destination?.id) return false val tempBackQueue: ArrayDeque&lt;NavBackStackEntry&gt; = ArrayDeque() // pop from startDestination back to original node and create a new entry for each backQueue.indexOfLast { it.destination === node }.let { nodeIndex -&gt; // æ‰¾åˆ°queueä¸­æœ€åä¸€ä¸ªdestinationå’Œnodeç›¸ç­‰çš„index while (backQueue.lastIndex &gt;= nodeIndex) { // å¦‚æœqueueä¸­æœ€åä¸€ä¸ªindexå¤§äºnodeIndexï¼Œå°±åˆ æ‰ä»–ï¼Œå¹¶åˆ›å»ºä¸€ä¸ªæ–°çš„entryï¼Œæ”¾åˆ°tempBackQueueä¸­ï¼Œç›´åˆ°lastIndexå°äºnodeIndexä¸ºæ­¢ val oldEntry = backQueue.removeLast() unlinkChildFromParent(oldEntry) // åˆ é™¤çˆ¶å­å…³ç³» val newEntry = NavBackStackEntry( oldEntry, oldEntry.destination.addInDefaultArgs(args) ) // åˆ›å»ºæ–°çš„entry tempBackQueue.addFirst(newEntry) // æ·»åŠ åˆ°tempBackQueueä¸­ } } // add each new entry to backQueue starting from original node to startDestination tempBackQueue.forEach { newEntry -&gt; val parent = newEntry.destination.parent if (parent != null) { val newParent = getBackStackEntry(parent.id) linkChildToParent(newEntry, newParent) // æ›´æ–°entryä¹‹é—´çš„çˆ¶å­å…³ç³» } backQueue.add(newEntry) } // we replace NavState entries here only after backQueue has been finalized tempBackQueue.forEach { newEntry -&gt; val navigator = _navigatorProvider.getNavigator&lt;Navigator&lt;*&gt;&gt;( newEntry.destination.navigatorName ) navigator.onLaunchSingleTop(newEntry) // æ‹¿åˆ°å¯¹åº”çš„Navigatorï¼Œæ‰§è¡ŒonLaunchSingleTop } return true} 123456@Suppress(&quot;UNCHECKED_CAST&quot;)public open fun onLaunchSingleTop(backStackEntry: NavBackStackEntry) { val destination = backStackEntry.destination as? D ?: return navigate(destination, null, navOptions { launchSingleTop = true }, null) // è¿™ä¸ªnavigateæ‰§è¡ŒçœŸæ­£çš„å¯¼èˆªæ“ä½œï¼Œè€æ¼”å‘˜äº†ï¼Œä¸Šé¢è§è¿‡å°±ä¸è¯´äº† state.onLaunchSingleTop(backStackEntry) // è¿™ä¸ªstateåœ¨å‰é¢ä¹Ÿä»‹ç»è¿‡ï¼Œä¸‹é¢çœ‹çœ‹ä»–çš„onLaunchSingleTopæ–¹æ³•å¹²äº†ä»€ä¹ˆ} 1234567891011public open fun onLaunchSingleTop(backStackEntry: NavBackStackEntry) { // We update the back stack here because we don't want to leave it to the navigator since // it might be using transitions. backStackLock.withLock { val tempStack = backStack.value.toMutableList() tempStack.indexOfLast { it.id == backStackEntry.id }.let { idx -&gt; tempStack[idx] = backStackEntry } _backStack.value = tempStack }} å…¶å®å°±æ˜¯æ›´æ–°å½“å‰çš„è¿”å›æ ˆæ‰¾åˆ°æœ€åä¸€ä¸ªidä¸backStackEntryçš„idç›¸ç­‰çš„indexï¼Œå°†è¿™ä¸ªä½ç½®çš„entryæ›¿æ¢ä¸ºbackStackEntry å…¶ä»–æƒ…å†µåœ¨æ²¡æœ‰å¼€å¯LaunchSingleTopçš„æƒ…å†µï¼Œæˆ–launchSingleTopInternalæ²¡æœ‰æˆåŠŸçš„æƒ…å†µé‚£ï¼Œå°±ä¼šèµ°åˆ°è¿™ä¸ªä»£ç åˆ†æ”¯ 12345678910111213if (!launchSingleTop) { // Not a single top operation, so we're looking to add the node to the back stack val backStackEntry = NavBackStackEntry.create( context, node, finalArgs, hostLifecycleState, viewModel ) val navigator = _navigatorProvider.getNavigator&lt;Navigator&lt;NavDestination&gt;&gt;( node.navigatorName ) navigator.navigateInternal(listOf(backStackEntry), navOptions, navigatorExtras) { navigated = true addEntryToBackStack(node, finalArgs, it) }} åˆ›å»ºæ–°çš„backStackEntryæ¡ç›®ï¼Œæ‰¾åˆ°å¯¹åº”çš„Navigatorï¼Œæ‰§è¡Œå¯¼èˆªæ“ä½œï¼Œå¦‚æœæˆåŠŸäº†ï¼Œå°±å°†å…¶åŠ å…¥åˆ°è¿”å›æ ˆä¸­ NavigatorProvideræ•°æ®ç»“æ„1234private val _navigators: MutableMap&lt;String, Navigator&lt;out NavDestination&gt;&gt; = mutableMapOf()@get:RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)public val navigators: Map&lt;String, Navigator&lt;out NavDestination&gt;&gt; get() = _navigators.toMap() ä»¥ä¸Šå°±æ˜¯NavigatorProviderçš„å…¨éƒ¨æ•°æ®ç»“æ„äº†ï¼Œå°±æ˜¯ä¸€ä¸ªString to Navigatorçš„Map å›æƒ³æ ¸å¿ƒçš„navigateæ–¹æ³•ä¸­å¤šæ¬¡ä½¿ç”¨NavDestination#navigatorNameä»NavigatorProviderä¸­è·å–Navigatorï¼Œæ‰€ä»¥NavigatorProviderçš„å°±æ˜¯ä¸€ä¸ªç”¨æ¥ä¿å­˜navigatorNameåˆ°Navigatorå®ä¾‹çš„Map è·å–Navigator1234567891011121314151617181920212223242526public fun &lt;T : Navigator&lt;*&gt;&gt; getNavigator(navigatorClass: Class&lt;T&gt;): T { val name = getNameForNavigator(navigatorClass) return getNavigator(name)}/*** Retrieves a registered [Navigator] by name.** @param name name of the navigator to return* @return the registered navigator with the given name** @throws IllegalStateException if the Navigator has not been added** @see NavigatorProvider.addNavigator*/@Suppress(&quot;UNCHECKED_CAST&quot;)@CallSuperpublic open fun &lt;T : Navigator&lt;*&gt;&gt; getNavigator(name: String): T { require(validateName(name)) { &quot;navigator name cannot be an empty string&quot; } val navigator = _navigators[name] ?: throw IllegalStateException( &quot;Could not find Navigator with name \\&quot;$name\\&quot;. You must call &quot; + &quot;NavController.addNavigator() for each navigation type.&quot; ) return navigator as T} getNameForNavigator12345678910111213141516171819202122internal companion object { private val annotationNames = mutableMapOf&lt;Class&lt;*&gt;, String?&gt;() internal fun validateName(name: String?): Boolean { return name != null &amp;&amp; name.isNotEmpty() } @JvmStatic internal fun getNameForNavigator(navigatorClass: Class&lt;out Navigator&lt;*&gt;&gt;): String { var name = annotationNames[navigatorClass] if (name == null) { val annotation = navigatorClass.getAnnotation( Navigator.Name::class.java ) name = annotation?.value require(validateName(name)) { &quot;No @Navigator.Name annotation found for ${navigatorClass.simpleName}&quot; } annotationNames[navigatorClass] = name } return name!! }} å‘ç°è·å–çš„nameæ˜¯ä¸€ä¸ªè¿è¡Œæ—¶æ³¨è§£ï¼Œæ‰€ä»¥éœ€è¦å…ˆçœ‹çœ‹Navigator.Nameè¿™ä¸ªæ³¨è§£ Navigator.Nameæ˜¯Navigatorä¸­çš„ä¸€ä¸ªè¿è¡Œæ—¶æ³¨è§£123@kotlin.annotation.Retention(AnnotationRetention.RUNTIME)@Target(AnnotationTarget.ANNOTATION_CLASS, AnnotationTarget.CLASS)public annotation class Name(val value: String) æˆ‘ä»¬è§‚å¯Ÿå‡ ä¸ªNavigatorï¼Œå‘ç°ä»–ä»¬éƒ½æœ‰@Navigator.Nameæ³¨è§£ï¼Œå¹¶ä¼ å…¥äº†å¯¹åº”çš„å‚æ•°123456789101112131415161718192021222324252627// 1. FragmentNavigator@Navigator.Name(&quot;fragment&quot;)public open class FragmentNavigator( private val context: Context, private val fragmentManager: FragmentManager, private val containerId: Int) : Navigator&lt;Destination&gt;() { // ...}// 2. ActivityNavigator@Navigator.Name(&quot;activity&quot;)public open class ActivityNavigator( /** @suppress */ @get:RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public val context: Context) : Navigator&lt;ActivityNavigator.Destination&gt;() { // ...}// 3. NavGraphNavigator@Navigator.Name(&quot;navigation&quot;)public open class NavGraphNavigator( private val navigatorProvider: NavigatorProvider) : Navigator&lt;NavGraph&gt;() { // ...} è¿™æ ·å°±å¯ä»¥æ˜ç¡®äº†ï¼ŒNavigatorçš„nameå°±æ˜¯æ³¨è§£æ—¶çš„value FragmentNavigatorçš„nameæ˜¯&quot;fragment&quot; ActivityNavigatorçš„nameæ˜¯&quot;activity&quot; â€¦ addNavigator123456789101112131415161718192021222324252627282930313233public fun addNavigator( navigator: Navigator&lt;out NavDestination&gt;): Navigator&lt;out NavDestination&gt;? { return addNavigator(getNameForNavigator(navigator.javaClass), navigator)}/*** Register a navigator by name. [destinations][NavDestination] may refer to any* registered navigator by name for inflation. If a navigator by this name is already* registered, this new navigator will replace it.** @param name name for this navigator* @param navigator navigator to add* @return the previously added Navigator for the given name, if any*/@CallSuperpublic open fun addNavigator( name: String, navigator: Navigator&lt;out NavDestination&gt;): Navigator&lt;out NavDestination&gt;? { require(validateName(name)) { &quot;navigator name cannot be an empty string&quot; } val previousNavigator = _navigators[name] if (previousNavigator == navigator) { return navigator } check(previousNavigator?.isAttached != true) { &quot;Navigator $navigator is replacing an already attached $previousNavigator&quot; } check(!navigator.isAttached) { &quot;Navigator $navigator is already attached to another NavController&quot; } return _navigators.put(name, navigator)} addNavigatoræ—¶ï¼Œé¦–å…ˆå–å‡ºå¯¹åº”nameçš„Navigator å¦‚æœNavigatorå’Œè¦æ”¾å…¥çš„Navigatorç›¸åŒï¼Œåˆ™ç›´æ¥è¿”å› å¦‚æœå‰ä¸€ä¸ªNavigatorä¸ç©ºä¸”æ²¡æœ‰è¢«attachï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸ è¿™é‡Œåˆ¤æ–­æ–¹æ³•ä¸ºpreviousNavigator?.isAttached != true, nullæˆ–è€…boolå’Œtrueæ¯”è¾ƒï¼Œååˆ†ç®€æ´ï¼Œå€¼å¾—å­¦ä¹ ï¼ æ£€æŸ¥ç¡®è®¤è¦æ”¾å…¥çš„Navigatoræ²¡æœ‰è¢«attachï¼Œå¦åˆ™æŠ›å‡ºå¼‚å¸¸ æœ€åå°†Navigatoræ”¾å…¥_navigatorsä¸­ï¼Œå¹¶è¿”å›å‰ä¸€ä¸ªNavigator è¢«æ›¿æ¢çš„Navigatorå¦‚æœä¸ç©ºçš„è¯ï¼Œä¸èƒ½æ˜¯å·²ç»Attachçš„ æƒ³è¦æ”¾å…¥çš„Navigatorä¹Ÿä¸èƒ½è¢«attach æ‰©å±•getå’Œsetæ–¹æ³•123456789101112131415@Suppress(&quot;NOTHING_TO_INLINE&quot;)public inline operator fun &lt;T : Navigator&lt;out NavDestination&gt;&gt; NavigatorProvider.get( name: String): T = getNavigator(name)@Suppress(&quot;NOTHING_TO_INLINE&quot;)public inline operator fun &lt;T : Navigator&lt;out NavDestination&gt;&gt; NavigatorProvider.get( clazz: KClass&lt;T&gt;): T = getNavigator(clazz.java)@Suppress(&quot;NOTHING_TO_INLINE&quot;)public inline operator fun NavigatorProvider.set( name: String, navigator: Navigator&lt;out NavDestination&gt;): Navigator&lt;out NavDestination&gt;? = addNavigator(name, navigator) å¾ˆç®€å• æ‰©å±•çš„+=è¿ç®—ç¬¦1234@Suppress(&quot;NOTHING_TO_INLINE&quot;)public inline operator fun NavigatorProvider.plusAssign(navigator: Navigator&lt;out NavDestination&gt;) { addNavigator(navigator)} ä¹Ÿå¾ˆç®€å• NavBackStackEntryå…ˆçœ‹æ³¨é‡Š12Representation of an entry in the back stack of a androidx.navigation.NavController.The Lifecycle, ViewModelStore, and SavedStateRegistry provided via this object are valid for the lifetime of this destination on the back stack: when this destination is popped off the back stack, the lifecycle will be destroyed, state will no longer be saved, and ViewModels will be cleared. ä»‹ç»äº†ä¸¤ä»¶äº‹æƒ… è¿™ä¸ªç±»ä»£è¡¨çš„æ˜¯NavControllerä¸­è¿”å›æ ˆçš„ä¸€ä¸ªentry ä»–èƒ½æä¾›Lifecycle, ViewModelStore, and SavedStateRegistry å½“è¿™ä¸ªNavBackStackEntryå­˜åœ¨äºè¿”å›æ ˆæ—¶ï¼Œä»–ä»¬çš„ç”Ÿå‘½å‘¨æœŸæ—¶æœ‰æ•ˆçš„ï¼Œå½“è¿™ä¸ªNavBackStackEntryè¢«popæ‰æ—¶ï¼Œä»–ä»¬çš„ç”Ÿå‘½å‘¨æœŸä¼šè¢«é”€æ¯ï¼ŒçŠ¶æ€ä¼šè¢«æ¸…é™¤ï¼ŒViewModelä¼šè¢«æ¸…é™¤ ç±»å®šä¹‰å’Œæ•°æ®ç»“æ„lifeCycleéƒ¨åˆ†123456789101112131415161718192021222324252627282930313233343536public class NavBackStackEntry private constructor( private val context: Context?, /** * The destination associated with this entry * @return The destination that is currently visible to users */ @set:RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public var destination: NavDestination, private val immutableArgs: Bundle? = null, private var hostLifecycleState: Lifecycle.State = Lifecycle.State.CREATED, private val viewModelStoreProvider: NavViewModelStoreProvider? = null, /** * The unique ID that serves as the identity of this entry * @return the unique ID of this entry */ public val id: String = UUID.randomUUID().toString(), private val savedState: Bundle? = null) : LifecycleOwner, ViewModelStoreOwner, HasDefaultViewModelProviderFactory, SavedStateRegistryOwner { private var _lifecycle = LifecycleRegistry(this) override val lifecycle: Lifecycle get() = _lifecycle @get:RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) @set:RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public var maxLifecycle: Lifecycle.State = Lifecycle.State.INITIALIZED set(maxState) { field = maxState updateState() } // ...} å¾ˆç®€å•å®ç°äº†lifeCycle maxLifecycleæ˜¯Lifecycle.Stateï¼Œä¿å­˜å½“å‰çš„çŠ¶æ€ï¼Œé»˜è®¤æ˜¯Lifecycle.State.INITIALIZED è°ƒç”¨maxLifecycleçš„setå±æ€§æ—¶ï¼Œä¼šè°ƒç”¨updateStateæ–¹æ³•123456789101112131415161718@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)public fun updateState() { if (!savedStateRegistryAttached) { savedStateRegistryController.performAttach() savedStateRegistryAttached = true if (viewModelStoreProvider != null) { enableSavedStateHandles() } // Perform the restore just once, the first time updateState() is called // and specifically *before* we move up the Lifecycle savedStateRegistryController.performRestore(savedState) } if (hostLifecycleState.ordinal &lt; maxLifecycle.ordinal) { _lifecycle.currentState = hostLifecycleState } else { _lifecycle.currentState = maxLifecycle }} é¦–å…ˆåˆ¤æ–­savedStateRegistryæ˜¯å¦è¢«attach, å¦‚æœæ²¡æœ‰ï¼Œå°±æ‰§è¡Œattach,å¹¶å›å¤çŠ¶æ€ ç„¶åå°±æ˜¯æ›´æ–°lifeCycleçš„çŠ¶æ€ï¼Œå–hostLifecycleStateå’ŒmaxLifecycleä¹‹ä¸­è¾ƒå°çš„é‚£ä¸€ä¸ª è¿™é‡Œçœ‹åˆ°ä¸€ä¸ªordinalä¸å¤ªç†Ÿæ‚‰ï¼Œè¿™ä¸ªå±äºjavaåŸºç¡€ ç»§ç»­æŒ–å‘// todo: enum, ordinal ViewModeléƒ¨åˆ†12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class NavBackStackEntry private constructor( private val context: Context?, /** * The destination associated with this entry * @return The destination that is currently visible to users */ @set:RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public var destination: NavDestination, private val immutableArgs: Bundle? = null, private var hostLifecycleState: Lifecycle.State = Lifecycle.State.CREATED, private val viewModelStoreProvider: NavViewModelStoreProvider? = null, /** * The unique ID that serves as the identity of this entry * @return the unique ID of this entry */ public val id: String = UUID.randomUUID().toString(), private val savedState: Bundle? = null) : LifecycleOwner, ViewModelStoreOwner, HasDefaultViewModelProviderFactory, SavedStateRegistryOwner { private val defaultFactory by lazy { SavedStateViewModelFactory((context?.applicationContext as? Application), this, arguments) } /** * The [SavedStateHandle] for this entry. */ public val savedStateHandle: SavedStateHandle by lazy { check(savedStateRegistryAttached) { &quot;You cannot access the NavBackStackEntry's SavedStateHandle until it is added to &quot; + &quot;the NavController's back stack (i.e., the Lifecycle of the NavBackStackEntry &quot; + &quot;reaches the CREATED state).&quot; } check(lifecycle.currentState != Lifecycle.State.DESTROYED) { &quot;You cannot access the NavBackStackEntry's SavedStateHandle after the &quot; + &quot;NavBackStackEntry is destroyed.&quot; } ViewModelProvider( this, NavResultSavedStateFactory(this) ).get(SavedStateViewModel::class.java).handle } override val defaultViewModelProviderFactory: ViewModelProvider.Factory = defaultFactory override val defaultViewModelCreationExtras: CreationExtras get() { val extras = MutableCreationExtras() (context?.applicationContext as? Application)?.let { application -&gt; extras[ViewModelProvider.AndroidViewModelFactory.APPLICATION_KEY] = application } extras[SAVED_STATE_REGISTRY_OWNER_KEY] = this extras[VIEW_MODEL_STORE_OWNER_KEY] = this arguments?.let { args -&gt; extras[DEFAULT_ARGS_KEY] = args } return extras } override val savedStateRegistry: SavedStateRegistry get() = savedStateRegistryController.savedStateRegistry private class NavResultSavedStateFactory( owner: SavedStateRegistryOwner ) : AbstractSavedStateViewModelFactory(owner, null) { @Suppress(&quot;UNCHECKED_CAST&quot;) override fun &lt;T : ViewModel&gt; create( key: String, modelClass: Class&lt;T&gt;, handle: SavedStateHandle ): T { return SavedStateViewModel(handle) as T } } private class SavedStateViewModel(val handle: SavedStateHandle) : ViewModel() // ...} è¿™é‡Œä¿ç•™äº†savedStateHandleï¼Œå’ŒviewModelæœ‰ä¸€å®šçš„è€¦åˆ æˆ‘ä»¬ä½¿ç”¨çš„viewModelå°±å­˜äº†ä¸€ä¸ªSavedStateHandle æä¾›äº†é»˜è®¤çš„ViewModelProvider.Factoryå’ŒExtras åŸºæœ¬éƒ½æ˜¯å’ŒsavedStateç›¸å…³çš„ï¼Œæ‰€ä»¥å…ˆä¸çœ‹äº† viewModelçš„ä½œç”¨ æä¾›handle æä¾›viewModelStore(å°±æ˜¯viewModelNameåˆ°viewModelçš„map) // todo: å­¦ä¹ saveStateåå†çœ‹ // ç–‘é—®ï¼Œä¸ºå•¥éè¦é€šè¿‡viewModelæ¥è·å–handleå‘¢ï¼Ÿ savedStateéƒ¨åˆ†12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class NavBackStackEntry private constructor( private val context: Context?, /** * The destination associated with this entry * @return The destination that is currently visible to users */ @set:RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public var destination: NavDestination, private val immutableArgs: Bundle? = null, private var hostLifecycleState: Lifecycle.State = Lifecycle.State.CREATED, private val viewModelStoreProvider: NavViewModelStoreProvider? = null, /** * The unique ID that serves as the identity of this entry * @return the unique ID of this entry */ public val id: String = UUID.randomUUID().toString(), private val savedState: Bundle? = null) : LifecycleOwner, ViewModelStoreOwner, HasDefaultViewModelProviderFactory, SavedStateRegistryOwner { private val savedStateRegistryController = SavedStateRegistryController.create(this) private var savedStateRegistryAttached = false /** * The [SavedStateHandle] for this entry. */ public val savedStateHandle: SavedStateHandle by lazy { check(savedStateRegistryAttached) { &quot;You cannot access the NavBackStackEntry's SavedStateHandle until it is added to &quot; + &quot;the NavController's back stack (i.e., the Lifecycle of the NavBackStackEntry &quot; + &quot;reaches the CREATED state).&quot; } check(lifecycle.currentState != Lifecycle.State.DESTROYED) { &quot;You cannot access the NavBackStackEntry's SavedStateHandle after the &quot; + &quot;NavBackStackEntry is destroyed.&quot; } ViewModelProvider( this, NavResultSavedStateFactory(this) ).get(SavedStateViewModel::class.java).handle } override val savedStateRegistry: SavedStateRegistry get() = savedStateRegistryController.savedStateRegistry // ...} // todo: å­¦ä¹ saveStateåå†çœ‹ å…¶ä»–éƒ¨åˆ†12345678910111213141516171819202122232425262728public class NavBackStackEntry private constructor( private val context: Context?, /** * The destination associated with this entry * @return The destination that is currently visible to users */ @set:RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public var destination: NavDestination, private val immutableArgs: Bundle? = null, private var hostLifecycleState: Lifecycle.State = Lifecycle.State.CREATED, private val viewModelStoreProvider: NavViewModelStoreProvider? = null, /** * The unique ID that serves as the identity of this entry * @return the unique ID of this entry */ public val id: String = UUID.randomUUID().toString(), private val savedState: Bundle? = null) : LifecycleOwner, ViewModelStoreOwner, HasDefaultViewModelProviderFactory, SavedStateRegistryOwner { public val arguments: Bundle? get() = if (immutableArgs == null) { null } else { Bundle(immutableArgs) }} id: publicçš„ä¸€ä¸ªéšæœºuniqueçš„idï¼Œåº”è¯¥æ˜¯ç”¨äºæ ‡è¯†ä¸€ä¸ªNavBackStackEntry arguments: åœ¨å‰é¢çš„defaultViewModelCreationExtraså’ŒdefaultFactoryä¸­æœ‰ä½¿ç”¨ï¼Œå°†argsæä¾›ç»™extraså’Œfactory æ„é€ å‡½æ•°12345678910111213@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)constructor(entry: NavBackStackEntry, arguments: Bundle? = entry.arguments) : this( entry.context, entry.destination, arguments, entry.hostLifecycleState, entry.viewModelStoreProvider, entry.id, entry.savedState) { hostLifecycleState = entry.hostLifecycleState maxLifecycle = entry.maxLifecycle} å¯¹å¤–æš´éœ²çš„æ„é€ å‡½æ•°ä»…è¿™ä¸€ä¸ªï¼Œé™¤äº†argumentså…¶ä»–éƒ½æ˜¯ä»å¦ä¸€ä¸ªNavBackStackEntryä¸­è·å–çš„ 123456789101112131415public companion object { @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public fun create( context: Context?, destination: NavDestination, arguments: Bundle? = null, hostLifecycleState: Lifecycle.State = Lifecycle.State.CREATED, viewModelStoreProvider: NavViewModelStoreProvider? = null, id: String = UUID.randomUUID().toString(), savedState: Bundle? = null ): NavBackStackEntry = NavBackStackEntry( context, destination, arguments, hostLifecycleState, viewModelStoreProvider, id, savedState )} é€šè¿‡createæ–¹æ³•æš´éœ²äº†å¦å¤–ä¸€ä¸ªç§æœ‰çš„æ„é€ å‡½æ•°ï¼ŒçŒœæµ‹è¿™ä¹ˆåšçš„ç›®çš„æ˜¯ä¸ºäº†é™åˆ¶è¯¥æ„é€ å‡½æ•°ä»…åœ¨navigationåº“çš„èŒƒå›´å†…ä½¿ç”¨å§ï¼Ÿ æ€»ç»“ æ€»çš„æ¥è¯´ï¼Œè¿™ä¸ªç±»ä½œä¸ºNavControllerè¿”å›æ ˆçš„ä¸€ä¸ªentryï¼ŒåŒæ—¶æä¾›äº†ä¸€äº›å˜é‡ destination id arguments savedStateHandle maxLifecycle viewModelStore NavDestinationå…ˆçœ‹æ³¨é‡Š12345NavDestination represents one node within an overall navigation graph.Each destination is associated with a Navigator which knows how to navigate to this particular destination.Destinations declare a set of actions that they support. These actions form a navigation API for the destination; the same actions declared on different destinations that fill similar roles allow application code to navigate based on semantic intent.Each destination has a set of arguments that will be applied when navigating to that destination. Any default values for those arguments can be overridden at the time of navigation.NavDestinations should be created via Navigator.createDestination. NavDestinationä»£è¡¨ä¸€ä¸ªå¯¼èˆªå›¾ä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹ æ¯ä¸ªNavDestinationéƒ½å…³è”ä¸€ä¸ªNavigatorï¼ŒNavigatorçŸ¥é“å¦‚ä½•å¯¼èˆªåˆ°è¿™ä¸ªNavDestination ä¿å­˜ä¸€ç»„action ååŠå¥æœ‰ç‚¹éš¾æ‡‚ï¼Œä¸åŒdestinationsä¸­ç›¸åŒçš„actionå‘æŒ¥ç›¸åŒçš„ä½œç”¨ï¼Œå¯ä»¥å…è®¸åº”ç”¨ä»£ç åŸºäºè¯­ä¹‰intentå¯¼èˆª æ¯ä¸ªdestinationéƒ½æœ‰ä¸€ç»„argsï¼Œåœ¨å¯¼èˆªåˆ°è¿™ä¸ªdestinationæ—¶å¯èƒ½ä¼šè¢«è¦†ç›– NavDestinationsåº”è¯¥é€šè¿‡Navigator.createDestinationåˆ›å»º ç±»å®šä¹‰å’Œæ•°æ®ç»“æ„12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public open class NavDestination( /** * The name associated with this destination's [Navigator]. */ public val navigatorName: String) { @kotlin.annotation.Retention(AnnotationRetention.BINARY) @Target(AnnotationTarget.ANNOTATION_CLASS, AnnotationTarget.CLASS) public annotation class ClassType(val value: KClass&lt;*&gt;) // 1. æ³¨è§£ public var parent: NavGraph? = null // 2. partent /** @suppress */ @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public set private var idName: String? = null public var label: CharSequence? = null private val deepLinks = mutableListOf&lt;NavDeepLink&gt;() // 3. deepLinks private val actions: SparseArrayCompat&lt;NavAction&gt; = SparseArrayCompat() // 4. actions private var _arguments: MutableMap&lt;String, NavArgument&gt; = mutableMapOf() // 5. args public val arguments: Map&lt;String, NavArgument&gt; get() = _arguments.toMap() @get:IdRes public var id: Int = 0 // 6. id set(@IdRes id) { field = id idName = null } public var route: String? = null // 7. route set(route) { if (route == null) { id = 0 } else { require(route.isNotBlank()) { &quot;Cannot have an empty route&quot; } val internalRoute = createRoute(route) id = internalRoute.hashCode() addDeepLink(internalRoute) } deepLinks.remove(deepLinks.firstOrNull { it.uriPattern == createRoute(field) }) field = route } public open val displayName: String @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) get() = idName ?: id.toString() public companion object { @JvmStatic public val NavDestination.hierarchy: Sequence&lt;NavDestination&gt; // 8. hierarchy get() = generateSequence(this) { it.parent } // ... } // ... 1. æ³¨è§£åœ¨å­ç±»ä¸­ä½¿ç”¨ï¼Œåœ¨XXXNavigatorä¸­ä¼šæœ‰å†…éƒ¨ç±»Destinationç»§æ‰¿NavDestinationï¼Œå¹¶ä½¿ç”¨è¯¥æ³¨è§£æ ‡æ³¨å…¶å¯¼èˆªçš„class å¦‚ï¼Œåœ¨FragmentNavigatorä¸­ 123456@NavDestination.ClassType(Fragment::class)public open class Destinationpublic constructor(fragmentNavigator: Navigator&lt;out Destination&gt;) : NavDestination(fragmentNavigator) { // ...} æš‚æ—¶æ²¡æœ‰æ‰¾åˆ°è·å–å¹¶ä½¿ç”¨è¿™ä¸ªæ³¨è§£çš„ä»£ç  1This optional annotation allows tooling to offer auto-complete for the android:name attribute. This should match the class type passed to parseClassFromName when parsing the android:name attribute. çœ‹èµ·æ¥æ˜¯xmlè‡ªåŠ¨è¡¥å…¨çš„æ—¶å€™ä¼šç”¨åˆ° 2. parentparentæ˜¯NavGraphï¼Œè¡¨ç¤ºå½“å‰NavDestinationçš„çˆ¶èŠ‚ç‚¹ï¼ŒåŒæ—¶å‰§é€ä¸€ä¸‹, NavGraphæ˜¯NavDestinationçš„å­ç±» 8. hierarchyhierarchyæ˜¯ä¸€ä¸ªæ‰©å±•å±æ€§ï¼Œä»å½“å‰NavDestinationå¼€å§‹ï¼Œç”Ÿæˆä¸€ä¸ªçˆ¶èŠ‚ç‚¹çš„sequence 3. deepLinksdeepLinksæ˜¯ä¸€ä¸ªlist, åœ¨matchDeepLinkæ—¶ä¼šéå†è¯¥listï¼Œå¯»æ‰¾åˆ°æœ€ä½³matchçš„NavDeepLink 4. actionsactionæ˜¯ä¸€ä¸ªSparseArrayCompatï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªIntåˆ°Objectçš„Map 7. routeä»£è¡¨å½“å‰Destinationçš„routeå­—ç¬¦ä¸²ï¼Œå¯ä»¥çœ‹åˆ°ä»–ä¹Ÿè°ƒç”¨äº†addDeepLink addDeepLink123456789101112131415public fun addDeepLink(uriPattern: String) { addDeepLink(NavDeepLink.Builder().setUriPattern(uriPattern).build())}public fun addDeepLink(navDeepLink: NavDeepLink) { val missingRequiredArguments = _arguments.missingRequiredArguments { key -&gt; key !in navDeepLink.argumentsNames } require(missingRequiredArguments.isEmpty()) { &quot;Deep link ${navDeepLink.uriPattern} can't be used to open destination $this.\\n&quot; + &quot;Following required arguments are missing: $missingRequiredArguments&quot; } deepLinks.add(navDeepLink)} ç¬¬ä¸€ä¸ªå‡½æ•°æ˜¯ç»™routeä½¿ç”¨çš„ï¼Œå°†routeå­—ç¬¦ä¸²å˜æˆä¸€ä¸ªNavDeepLinkç¬¬äºŒä¸ªå‡½æ•°å¾ˆç®€å•ï¼Œå°±æ˜¯å°†NavDeepLinkæ·»åŠ åˆ°deepLinksä¸­ï¼Œåœ¨æ”¾å…¥ä¹‹å‰ä¼šæ£€æŸ¥ä¸€ä¸‹ï¼Œä¿è¯_argumentsä¸­çš„keyå…¨éƒ¨å­˜åœ¨äºdeepLinkçš„argumentsNamesä¸­ routeè½¬æ¢æˆNavDeepLinkRequest12345678@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)public fun createRoute(route: String?): String = if (route != null) &quot;android-app://androidx.navigation/$route&quot; else &quot;&quot;// NavDeepLinkRequest.Builder#buildpublic fun build(): NavDeepLinkRequest { return NavDeepLinkRequest(uri, action, mimeType)} å°±æ˜¯æŠŠrouteæ ¹æ®ç‰¹å®šæ ¼å¼è½¬æ¢æˆä¸€ä¸ªuriï¼Œå­˜åˆ°NavDeepLinkRequestè¿™ä¸ªç±»ä¸­ï¼Œè¿™ä¸ªç±»ä¹Ÿå¾ˆç®€å• 123456public open class NavDeepLinkRequest { public open val uri: Uri? public open val action: String? public open val mimeType: String? // ...} å°±æ˜¯ç”¨æ¥å­˜è¿™ä¸‰ä¸ªä¸œè¥¿çš„ matchDeepLink12345678910@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)public fun matchDeepLink(route: String): DeepLinkMatch? { val request = NavDeepLinkRequest.Builder.fromUri(createRoute(route).toUri()).build() val matchingDeepLink = if (this is NavGraph) { matchDeepLinkExcludingChildren(request) } else { matchDeepLink(request) } return matchingDeepLink} è¿™ä¸ªå‡½æ•°æ˜¯ç”¨æ¥é€šè¿‡routeæ¥åŒ¹é…DeepLinkçš„ï¼Œå¦‚æœå½“å‰NavDestinationæ˜¯å­ç±»NavGraphï¼Œåˆ™ä¼šè°ƒç”¨å­ç±»çš„å‡½æ•°matchDeepLinkExcludingChildrenï¼Œå¦åˆ™è°ƒç”¨matchDeepLinkã€‚matchDeepLinkExcludingChildrenåœ¨åé¢ä»‹ç» 123456789101112131415161718192021222324252627282930313233@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)public open fun matchDeepLink(navDeepLinkRequest: NavDeepLinkRequest): DeepLinkMatch? { if (deepLinks.isEmpty()) { return null } var bestMatch: DeepLinkMatch? = null for (deepLink in deepLinks) { val uri = navDeepLinkRequest.uri // includes matching args for path, query, and fragment val matchingArguments = if (uri != null) deepLink.getMatchingArguments(uri, _arguments) else null val matchingPathSegments = deepLink.calculateMatchingPathSegments(uri) val requestAction = navDeepLinkRequest.action val matchingAction = requestAction != null &amp;&amp; requestAction == deepLink.action val mimeType = navDeepLinkRequest.mimeType val mimeTypeMatchLevel = if (mimeType != null) deepLink.getMimeTypeMatchRating(mimeType) else -1 if (matchingArguments != null || ((matchingAction || mimeTypeMatchLevel &gt; -1) &amp;&amp; hasRequiredArguments(deepLink, uri, _arguments)) ) { // 2. matchçš„æ¡ä»¶ val newMatch = DeepLinkMatch( this, matchingArguments, deepLink.isExactDeepLink, matchingPathSegments, matchingAction, mimeTypeMatchLevel ) if (bestMatch == null || newMatch &gt; bestMatch) { // 1. æ¯”è¾ƒmatch, é€‰æ‹©æœ€å¥½çš„ä¸€ä¸ªmatch bestMatch = newMatch } } } return bestMatch} å°±æ˜¯éå†æ‰€æœ‰deepLinksæ•°ç»„ï¼Œæ‰¾åˆ°æœ€matchçš„ä¸€ä¸ª // todo: 2. matchçš„æ¡ä»¶ id1234567// æ¯ä¸ªdestinationçš„å”¯ä¸€idï¼Œå¿…é¡»æ˜¯èµ„æºid@get:IdRespublic var id: Int = 0 set(@IdRes id) { field = id idName = null } è¿™é‡Œå°±æœ‰ç–‘é—®äº†ï¼Œè¿™é‡Œçš„idåº”è¯¥æ˜¯å¯¼èˆªå›¾xmlçš„idï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼Œidåœ¨onInflateçš„æ—¶å€™è¢«èµ‹å€¼ã€‚ 123456789101112@CallSuperpublic open fun onInflate(context: Context, attrs: AttributeSet) { context.resources.obtainAttributes(attrs, R.styleable.Navigator).use { array -&gt; route = array.getString(R.styleable.Navigator_route) if (array.hasValue(R.styleable.Navigator_android_id)) { id = array.getResourceId(R.styleable.Navigator_android_id, 0) idName = getDisplayName(context, id) } label = array.getText(R.styleable.Navigator_android_label) }} ä½†åœ¨Composeä¸­ï¼Œå¹¶ä¸ä½¿ç”¨xmlçš„å¯¼èˆªå›¾ï¼Œå¦‚ä½•åˆå§‹åŒ–è¿™ä¸ªidå‘¢ï¼Ÿ 12345678910111213public var route: String? = null set(route) { if (route == null) { id = 0 } else { require(route.isNotBlank()) { &quot;Cannot have an empty route&quot; } val internalRoute = createRoute(route) id = internalRoute.hashCode() addDeepLink(internalRoute) } deepLinks.remove(deepLinks.firstOrNull { it.uriPattern == createRoute(field) }) field = route } å¯ä»¥çœ‹åˆ°è¿™é‡Œï¼Œå¦‚æœæ˜¯composeçš„routeå­—ç¬¦ä¸²ï¼ŒcreateRouteåï¼Œä¼šä½¿ç”¨hashCodeä¸ºidèµ‹å€¼ addInDefaultArgsæ€»ç»“å¤§æ¦‚ä½œç”¨å°±æ˜¯ ä¿å­˜actionå¯¹è±¡ï¼Œç»´æŠ¤äº†ä¸€ä¸ªmapï¼Œä¿å­˜actionçš„resIdåˆ°actionå¯¹è±¡ æä¾›navigatorNameï¼Œæ–¹ä¾¿NavControlleræ ¹æ®nameæ‰¾åˆ°å¯¹åº”çš„Navigator ç»´æŠ¤deeplinkåˆ—è¡¨ï¼Œæä¾›deeplinkåŒ¹é…çš„æ–¹æ³• æä¾›parentå’Œhierarchyï¼Œæä¾›åµŒå¥—å›¾çš„æ”¯æŒ æä¾›routeåˆ°deeplinkRequestçš„è½¬æ¢ NavGraphå…ˆçœ‹æ³¨é‡Š12345NavGraph is a collection of NavDestination nodes fetchable by ID.A NavGraph serves as a 'virtual' destination: while the NavGraph itself will not appear on the back stack, navigating to the NavGraph will cause the starting destination to be added to the back stack.Construct a new NavGraph. This NavGraph is not valid until you add a destination and set the starting destination.Params:navGraphNavigator - The NavGraphNavigator which this destination will be associated with. Generally retrieved via a NavController'sNavigatorProvider.getNavigator method. å­˜å‚¨äº†å›¾ä¸­æ‰€æœ‰çš„èŠ‚ç‚¹ï¼Œå¯ä»¥é€šè¿‡idè·å–å„ä¸ªèŠ‚ç‚¹ è¿™é‡Œçš„èŠ‚ç‚¹å°±æ˜¯ä¸Šé¢ä»‹ç»çš„NavDestination å¯¼èˆªå›¾æœ¬èº«æ˜¯ä¸€ä¸ªè™šæ‹Ÿçš„destinationï¼Œä½†æ˜¯ä»–ä¸ä¼šå‡ºç°åœ¨æ ˆä¸­ï¼Œå¦‚æœè¯•å›¾å¯¼èˆªåˆ°NavGraphï¼Œå°†ä¼šå¯¼èˆªåˆ°è¿™ä¸ªå¯¼èˆªå›¾çš„startDestä¸­ æ•°æ®ç»“æ„12345678910111213141516171819202122232425262728293031323334353637public open class NavGraph(navGraphNavigator: Navigator&lt;out NavGraph&gt;) : NavDestination(navGraphNavigator), Iterable&lt;NavDestination&gt; { public val nodes: SparseArrayCompat&lt;NavDestination&gt; = SparseArrayCompat&lt;NavDestination&gt;() /** @suppress */ @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) get private var startDestId = 0 @get:IdRes public var startDestinationId: Int get() = startDestId private set(startDestId) { require(startDestId != id) { &quot;Start destination $startDestId cannot use the same id as the graph $this&quot; } if (startDestinationRoute != null) { startDestinationRoute = null } this.startDestId = startDestId startDestIdName = null } public var startDestinationRoute: String? = null private set(startDestRoute) { startDestId = if (startDestRoute == null) { 0 } else { require(startDestRoute != route) { &quot;Start destination $startDestRoute cannot use the same route as the graph $this&quot; } require(startDestRoute.isNotBlank()) { &quot;Cannot have an empty start destination route&quot; } val internalRoute = createRoute(startDestRoute) internalRoute.hashCode() } field = startDestRoute }} nodesï¼Œå­˜å‚¨æ‰€æœ‰destinationçš„mapï¼Œkeyæ—¶destinationçš„id startDestIdï¼ŒstartDestinationRouteèµ·å§‹destinationçš„idã€route å¦‚æœstartDestinationRouteä¸ç©ºï¼Œå’Œidçš„æƒ…å†µç›¸åŒï¼ŒcreateRouteåï¼Œä½¿ç”¨hashCodeä½œä¸ºstartDestId onInflate12345678910override fun onInflate(context: Context, attrs: AttributeSet) { super.onInflate(context, attrs) context.resources.obtainAttributes( attrs, R.styleable.NavGraphNavigator ).use { startDestinationId = it.getResourceId(R.styleable.NavGraphNavigator_startDestination, 0) startDestIdName = getDisplayName(context, startDestId) }} è§£æxmlæ—¶ï¼Œä»xmlä¸­è·å–startDestinationçš„id matchDeepLink12345678910111213141516@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)public override fun matchDeepLink(navDeepLinkRequest: NavDeepLinkRequest): DeepLinkMatch? { // First search through any deep links directly added to this NavGraph val bestMatch = super.matchDeepLink(navDeepLinkRequest) // Then search through all child destinations for a matching deep link val bestChildMatch = mapNotNull { child -&gt; child.matchDeepLink(navDeepLinkRequest) }.maxOrNull() return listOfNotNull(bestMatch, bestChildMatch).maxOrNull()}@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)public fun matchDeepLinkExcludingChildren(request: NavDeepLinkRequest): DeepLinkMatch? = super.matchDeepLink(request) navGraphæœ¬èº«ä¹Ÿå¯ä»¥ä½œä¸ºä¸€ä¸ªdestinationï¼Œæ‹¥æœ‰deeplinkï¼Œæ‰€ä»¥å…ˆæœç´¢ä»–è‡ªèº«çš„matchï¼Œç„¶åæœç´¢æ‰€æœ‰å­èŠ‚ç‚¹çš„matchï¼Œæœ€åè¿”å›æœ€matchçš„ä¸€ä¸ª è¿™ä¸ªå‡½æ•°åªæœ‰åœ¨ä½¿ç”¨routeå­—ç¬¦ä¸²åŒ¹é…æ—¶ä¼šä½¿ç”¨ï¼Œé€šè¿‡routeåŒ¹é…æ—¶å°±ä¸è€ƒè™‘å­èŠ‚ç‚¹ï¼Œä¸ºä»€ä¹ˆå‘¢ï¼Ÿ æ€»ç»“ å…¶å®æœ¬è´¨ä¸Šä¹Ÿæ˜¯ä¸€ä¸ªä¿å­˜å­èŠ‚ç‚¹çš„map æä¾›matchDeepLinkæ–¹æ³•ï¼Œç”¨äºåŒ¹é…å­å­èŠ‚ç‚¹å’Œè‡ªå·±æœ¬èº«deeplink NavigatorStateNavControllerNavigatorStateNavControllerViewModelFragmentNavigatorActivityNavigatoræ€»ç»“ä¸­çš„æ€»ç»“éœ€è¦ä¸€ä¸ªNavHostFragmentæƒ³è¦ä½¿ç”¨navigationåº“ï¼Œéœ€è¦æœ‰ä¸€ä¸ªNavHostFragmentã€‚navigationåº“ä¸ºFragment, View, Acivityéƒ½æ·»åŠ äº†æ‰©å±•å‡½æ•°findNavControllerï¼Œç”¨æ¥æ‰¾åˆ°navControllerï¼ŒæŸ¥æ‰¾æ—¶éƒ½éœ€è¦ä¸€ä¸ªNavHostFragmentçš„å­˜åœ¨ã€‚ å¯¹äºFragmentæ¥è¯´ï¼Œéœ€è¦å®ƒæœ¬èº«ï¼Œæˆ–è€…æ‰€æœ‰ä¸Šçº§Fragmentä¸­å­˜åœ¨ä¸€ä¸ªNavHostFragment å¯¹äºViewæ¥è¯´ï¼Œéœ€è¦ä»–æœ¬èº«ï¼Œæˆ–è€…æ‰€æœ‰ä¸Šçº§viewçš„tagä¸­ï¼Œå­˜åœ¨R.id.nav_controller_view_tag,è¿™ä¸ªtagä¸‹å¯ä»¥è·å¾—NavControllerã€‚NavHostFragmentçš„onViewCreatedæ–¹æ³•ä¸­,ä¼šå¯¹Fragmentçš„rootViewè®¾ç½®è¿™ä¸ªtag å¯¹äºactivityæ¥è¯´ï¼Œéœ€è¦æŒ‡å®šä¸€ä¸ªviewIdï¼Œé€šè¿‡findViewæ‰¾åˆ°è¿™ä¸ªviewåï¼Œå¯»æ‰¾è¿‡ç¨‹å’ŒViewç›¸åŒ è¿™ä¸ªNavHostFragmentçš„graphIdä¸èƒ½é€šè¿‡ç”¨æˆ·ä¼ å…¥ï¼Œå› ä¸ºè¿™ä¸ªå˜é‡æ˜¯privateçš„ã€‚NavHostFragmenté€šè¿‡xmlè·å–è¿™ä¸ªå¯¼èˆªå›¾çš„idï¼Œæˆ–è€…ä½¿ç”¨KEY_GRAPH_IDä»savedStateæˆ–Fragmentçš„mArgumentsä¸­è·å–ï¼Œè€Œè¿™ä¸ªKEY_GRAPH_IDä¹Ÿæ˜¯ä»…åœ¨navigationåº“ä¸­å¯ç”¨çš„ã€‚ NavHostFragmentå®ç°äº†NavHostï¼Œæ‹¥æœ‰äº†ä¸€ä¸ªNavControllerï¼Œé€šè¿‡å®ƒçš„navigateæ–¹æ³•å¯ä»¥è¿›è¡Œè·³è½¬ã€‚NavHostFragmentå®ç°NavControllerçš„å®ç°ç±»æ˜¯NavHostController,è¿™ä¸ªç±»ä¸­æ²¡æœ‰ä»»ä½•å‡½æ•°å®ç°ï¼Œåªæ˜¯å°†çˆ¶ç±»çš„å‡ ä¸ªå‡½æ•°å˜æˆfinalçš„ å¯¼èˆªå›¾ å¯¼èˆªå›¾å¯ä»¥é€šè¿‡xmlå’Œkotlin DSLæè¿°ã€‚ å¯¼èˆªå›¾å¯ä»¥åŒ…å«å¤šä¸ªå­èŠ‚ç‚¹ï¼Œæ¯ä¸ªå­èŠ‚ç‚¹éƒ½æ˜¯ä¸€ä¸ªdestinationã€‚ æ¯ä¸ªdestinationå¯ä»¥æ˜¯fragmentï¼Œactivityï¼Œdialogï¼Œæˆ–è€…ä¸€ä¸ªNavGraphä½œä¸ºå­å›¾ã€‚æ¯ä¸ªdestinationå¯ä»¥åŒ…å«å¤šä¸ªaction æ¯ä¸ªactionåŒ…å«å®ƒæœ¬èº«çš„idå’Œå¯¼èˆªç›®çš„åœ°çš„destinationIdï¼Œç”¨äºç¡®å®šå¯¼èˆªçš„ç›®çš„åœ°ã€‚ æ¯ä¸ªdestinationä¹Ÿå¯ä»¥åŒ…å«å¤šä¸ªdeeplink NavControlleré€šè¿‡deeplinkè¿›è¡Œå¯¼èˆªæ—¶ï¼Œä¼šæœç´¢å¯¼èˆªå›¾ï¼Œä»¥åŠå¯¼èˆªå›¾ä¸­çš„destinationçš„deeplinkï¼Œæ‰¾åˆ°åŒ¹é…åº¦æœ€é«˜çš„ä¸€ä¸ªï¼Œè¿›è¡Œå¯¼èˆªã€‚ åœ¨Composeä¸­ä½¿ç”¨routeå­—ç¬¦ä¸²è¿›è¡Œå¯¼èˆªæ—¶ï¼Œå®é™…ä¸Šä¼šå°†å…¶åŒ…è£…ä¸ºä¸€ä¸ªuriç±»å‹çš„deeplinkï¼Œç„¶åè¿›è¡ŒåŒ¹é…ã€‚ æ¯ä¸ªdeeplinkåŒ…å«å…¶uriï¼Œactionå­—ç¬¦ä¸²ï¼ŒmimeTypeå­—ç¬¦ä¸²ï¼Œç”¨äºåŒ¹é…ã€‚ å¯¼èˆªå›¾æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªdestinationï¼Œå¯¼èˆªåˆ°ä¸€ä¸ªNavGraphæ˜¯ï¼Œä¼šå¯¼èˆªåˆ°startDestinationã€‚ åœ¨xmlä¸­ï¼Œç»™æ ¹èŠ‚ç‚¹&lt;navigation&gt;æ·»åŠ startDestinationå‚æ•°ï¼Œå¡«å†™ä¸€ä¸ªdestinationIdï¼Œä½œä¸ºstartDestinationã€‚ åœ¨kotlin DSLä¸­ï¼Œé€šè¿‡startDestinationæŒ‡å®šä¸€ä¸ªrouteå­—ç¬¦ä¸²ï¼Œä½œä¸ºstartDestination NavController è¿™ä¸ªç±»æ˜¯æ•´ä¸ªnavigationåº“çš„æ ¸å¿ƒ æä¾›å¤šç§navigateæ–¹æ³•ï¼Œå¯ä»¥é€šè¿‡destinationçš„resIdï¼Œrouteå­—ç¬¦ä¸²å’ŒdeepLinkè¿›è¡Œå¯¼èˆª è¿™ä¸ªç±»ç»´æŠ¤äº†å¯¼èˆªå›¾NavGraphï¼Œè¿”å›æ ˆ_currentBackStackç­‰æ•°æ®ç»“æ„ è¿™ä¸ªç±»å¹¶æ‰¿æ‹…å…·ä½“çš„è·³è½¬ä»»åŠ¡ï¼Œå…·ä½“çš„è·³è½¬ä»»åŠ¡ç”±Navigatorçš„å„ä¸ªå­ç±»å®Œæˆ ä¸Šé¢è¯´åˆ°å¯¼èˆªç›®çš„åœ°æœ‰å¾ˆå¤šç§ç±»ï¼ŒNavControllerä¼šæ ¹æ®å¯¼èˆªç›®çš„åœ°çš„ç±»å‹ï¼Œé€‰æ‹©ä¸åŒçš„Navigatoræ¥å®Œæˆè·³è½¬ä»»åŠ¡ï¼Œæ¯”å¦‚FragmentNavigatorï¼ŒActivityNavigatorï¼ŒDialogNavigator æ¯ä¸ªNavigatoréƒ½æœ‰nameï¼Œæ˜¯é€šè¿‡ä¸€ä¸ªæ³¨è§£Navigator.NameæŒ‡å®šçš„ã€‚ NavControllerä¸­å› æ­¤ä¹Ÿç»´æŠ¤äº†_navigatorProviderï¼Œä»–çš„ä½œç”¨ç±»ä¼¼äºä¸€ä¸ªmap,å­˜å‚¨Navigatorçš„nameå’ŒNavigatorçš„æ˜ å°„å…³ç³»ã€‚","link":"/home/2024/08/07/Android%E9%AB%98%E7%BA%A7/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E5%9F%BA%E7%A1%8005-Navigation/"},{"title":"åŸºç¡€03-Lifecycle","text":"lifeCycleçš„Observer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public interface LifecycleObserverpublic interface DefaultLifecycleObserver : LifecycleObserver { /** * Notifies that `ON_CREATE` event occurred. * * * This method will be called after the [LifecycleOwner]'s `onCreate` * method returns. * * @param owner the component, whose state was changed */ public fun onCreate(owner: LifecycleOwner) {} /** * Notifies that `ON_START` event occurred. * * * This method will be called after the [LifecycleOwner]'s `onStart` method returns. * * @param owner the component, whose state was changed */ public fun onStart(owner: LifecycleOwner) {} /** * Notifies that `ON_RESUME` event occurred. * * * This method will be called after the [LifecycleOwner]'s `onResume` * method returns. * * @param owner the component, whose state was changed */ public fun onResume(owner: LifecycleOwner) {} /** * Notifies that `ON_PAUSE` event occurred. * * * This method will be called before the [LifecycleOwner]'s `onPause` method * is called. * * @param owner the component, whose state was changed */ public fun onPause(owner: LifecycleOwner) {} /** * Notifies that `ON_STOP` event occurred. * * * This method will be called before the [LifecycleOwner]'s `onStop` method * is called. * * @param owner the component, whose state was changed */ public fun onStop(owner: LifecycleOwner) {} /** * Notifies that `ON_DESTROY` event occurred. * * * This method will be called before the [LifecycleOwner]'s `onDestroy` method * is called. * * @param owner the component, whose state was changed */ public fun onDestroy(owner: LifecycleOwner) {}}public fun interface LifecycleEventObserver : LifecycleObserver { /** * Called when a state transition event happens. * * @param source The source of the event * @param event The event */ public fun onStateChanged(source: LifecycleOwner, event: Lifecycle.Event)} å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬åœ¨ä½¿ç”¨lifecycle.addObserver()æ—¶ï¼Œå¯ä»¥ä¼ å…¥LifecycleEventObserveræˆ–DefaultLifecycleObserverï¼Œä¸€ä¸ªé€šè¿‡eventè·å–å½“å‰çŠ¶æ€ï¼Œä¸€ä¸ªé€šè¿‡ä¸åŒçš„å›è°ƒå‡½æ•°è·å–å½“å‰çŠ¶æ€ Activityæ ‘1234567891011Activity -- AccountAuthenticatorActivity |- ActivityGroup -- TabActivity |- ExpandableListActivity |- LauncherActivity |- ListActivity -- PreferenceActivity |- NativeActivity |- androidx.core.app.ComponentActivity -- androidx.activity.ComponentActivity -- FragmentActivity -- AppCompatActivity |- PreviewActivity |- BootstrapActivity |- EmptyActivity |- EmptyFloatingActivity LifecycleOwner12345678public interface LifecycleOwner { /** * Returns the Lifecycle of the provider. * * @return The lifecycle of the provider. */ public val lifecycle: Lifecycle} androidx.core.app.ComponentActivityå’Œandroidx.activity.ComponentActivityéƒ½å£°æ˜äº†å¯¹LifecycleOwnerçš„å®ç° å¯ä»¥æ‹¿åˆ°lifecycleçš„Activityæœ‰ androidx.core.app.ComponentActivity androidx.activity.ComponentActivity FragmentActivity AppCompatActivity PreviewActivity androidx.core.app.ComponentActivityä¸­çš„lifecycle123456789@Suppress(&quot;LeakingThis&quot;)private val lifecycleRegistry = LifecycleRegistry(this)override val lifecycle: Lifecycle get() = lifecycleRegistry@CallSuperoverride fun onSaveInstanceState(outState: Bundle) { lifecycleRegistry.currentState = Lifecycle.State.CREATED super.onSaveInstanceState(outState)} å¾ˆæ„å¤–çš„æ˜¯ComponentActivityå¹¶ä¸æ˜¯åœ¨æ¯ä¸ªç”Ÿå‘½å‘¨æœŸå›è°ƒå‡½æ•°ä¸­è°ƒç”¨lifecycleRegistryçš„setCurrentStateï¼Œä»è€Œåˆ†å‘ç”Ÿå‘½å‘¨æœŸ LifecycleRegistryaddObserver123456789101112131415161718192021222324252627282930override fun addObserver(observer: LifecycleObserver) { enforceMainThreadIfNeeded(&quot;addObserver&quot;) val initialState = if (state == State.DESTROYED) State.DESTROYED else State.INITIALIZED val statefulObserver = ObserverWithState(observer, initialState) val previous = observerMap.putIfAbsent(observer, statefulObserver) if (previous != null) { return } val lifecycleOwner = lifecycleOwner.get() ?: // it is null we should be destroyed. Fallback quickly return val isReentrance = addingObserverCounter != 0 || handlingEvent var targetState = calculateTargetState(observer) addingObserverCounter++ while (statefulObserver.state &lt; targetState &amp;&amp; observerMap.contains(observer) ) { pushParentState(statefulObserver.state) val event = Event.upFrom(statefulObserver.state) ?: throw IllegalStateException(&quot;no event up from ${statefulObserver.state}&quot;) statefulObserver.dispatchEvent(lifecycleOwner, event) popParentState() // mState / subling may have been changed recalculate targetState = calculateTargetState(observer) } if (!isReentrance) { // we do sync only on the top level. sync() } addingObserverCounter--} è¿™é‡Œçœ‹åˆ°addObserveré¦–å…ˆå°†observeråŒ…è£…æˆObserverWithStateï¼Œå¹¶å°†å…¶åŠ å…¥åˆ°observerMap åŠ å…¥åç«‹åˆ»è°ƒç”¨dispatchEventå°†æœ€æ–°çš„çŠ¶æ€ä¼ é€’å‡ºå» 123456789101112131415161718private fun sync() { val lifecycleOwner = lifecycleOwner.get() ?: throw IllegalStateException( &quot;LifecycleOwner of this LifecycleRegistry is already &quot; + &quot;garbage collected. It is too late to change lifecycle state.&quot; ) while (!isSynced) { newEventOccurred = false if (state &lt; observerMap.eldest()!!.value.state) { backwardPass(lifecycleOwner) } val newest = observerMap.newest() if (!newEventOccurred &amp;&amp; newest != null &amp;&amp; state &gt; newest.value.state) { forwardPass(lifecycleOwner) } } newEventOccurred = false} è¿™é‡Œçœ‹åˆ°syncä¼šè°ƒç”¨backwardPasså’ŒforwardPass 12345678910111213141516171819202122232425262728293031private fun forwardPass(lifecycleOwner: LifecycleOwner) { @Suppress() val ascendingIterator: Iterator&lt;Map.Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; = observerMap.iteratorWithAdditions() while (ascendingIterator.hasNext() &amp;&amp; !newEventOccurred) { val (key, observer) = ascendingIterator.next() while (observer.state &lt; state &amp;&amp; !newEventOccurred &amp;&amp; observerMap.contains(key) ) { pushParentState(observer.state) val event = Event.upFrom(observer.state) ?: throw IllegalStateException(&quot;no event up from ${observer.state}&quot;) observer.dispatchEvent(lifecycleOwner, event) popParentState() } }}private fun backwardPass(lifecycleOwner: LifecycleOwner) { val descendingIterator = observerMap.descendingIterator() while (descendingIterator.hasNext() &amp;&amp; !newEventOccurred) { val (key, observer) = descendingIterator.next() while (observer.state &gt; state &amp;&amp; !newEventOccurred &amp;&amp; observerMap.contains(key) ) { val event = Event.downFrom(observer.state) ?: throw IllegalStateException(&quot;no event down from ${observer.state}&quot;) pushParentState(event.targetState) observer.dispatchEvent(lifecycleOwner, event) popParentState() } }} è¿™é‡Œçœ‹åˆ°syncè¢«è°ƒç”¨åï¼Œå°±ä¼šæ ¹æ®observerçš„æƒ…å†µå’Œstateçš„ä¸åŒï¼ŒæŒ‰ç…§éœ€è¦å°†stateçš„å˜åŒ–ä¼ é€’ç»™observer ObserverWithState12345678910111213141516internal class ObserverWithState(observer: LifecycleObserver?, initialState: State) { var state: State var lifecycleObserver: LifecycleEventObserver init { lifecycleObserver = Lifecycling.lifecycleEventObserver(observer!!) state = initialState } fun dispatchEvent(owner: LifecycleOwner?, event: Event) { val newState = event.targetState state = min(state, newState) lifecycleObserver.onStateChanged(owner!!, event) state = newState }} é¦–å…ˆè¿™é‡Œçœ‹åˆ°ä¸€ä¸ªå…³é”®çš„å‡½æ•°è°ƒç”¨onStateChangedï¼Œä¹Ÿå°±æ˜¯å½“dispatchEventè¢«è°ƒç”¨æ—¶ï¼Œstateçš„æ”¹å˜å°±ä¼šä¼ é€’ç»™observer setCurrentStateä½œç”¨1234567891011override var currentState: State get() = state /** * Moves the Lifecycle to the given state and dispatches necessary events to the observers. * * @param state new state */ set(state) { enforceMainThreadIfNeeded(&quot;setCurrentState&quot;) moveToState(state) } 1234567891011121314151617181920private fun moveToState(next: State) { if (state == next) { return } check(!(state == State.INITIALIZED &amp;&amp; next == State.DESTROYED)) { &quot;no event down from $state in component ${lifecycleOwner.get()}&quot; } state = next if (handlingEvent || addingObserverCounter != 0) { newEventOccurred = true // we will figure out what to do on upper level. return } handlingEvent = true sync() handlingEvent = false if (state == State.DESTROYED) { observerMap = FastSafeIterableMap() }} å¯ä»¥çœ‹åˆ°è¿™é‡Œå¯¹stateè¿›è¡Œä¸€å®šé€»è¾‘åˆ¤æ–­åï¼Œè°ƒç”¨äº†syncï¼Œä¹Ÿå°±æ˜¯å½“å‰stateçš„æ”¹å˜ä¼šä¼ é€’ç»™observer activityä¼ é€’stateçš„æ–¹å¼çœ‹èµ·æ¥è¿˜æ˜¯é€šè¿‡setCurrentStateï¼Œä½†æ˜¯å¹¶æ²¡æœ‰åœ¨CompinentActivityä¸­çš„å„ä¸ªç”Ÿå‘½å‘¨æœŸå‡½æ•°ä¸­è°ƒç”¨ ObserverWithStateå¦‚ä½•å¤„ç†ä¸¤ç§LifecycleObserver1234init { lifecycleObserver = Lifecycling.lifecycleEventObserver(observer!!) state = initialState} å¯ä»¥çœ‹åˆ°æ„é€ å‡½æ•°ä¸­å°†observeré€šè¿‡Lifecycling.lifecycleEventObserverå¯¹observerè¿›è¡Œäº†åŒ…è£… 1234567891011121314151617181920212223242526272829303132public fun lifecycleEventObserver(`object`: Any): LifecycleEventObserver { val isLifecycleEventObserver = `object` is LifecycleEventObserver val isDefaultLifecycleObserver = `object` is DefaultLifecycleObserver if (isLifecycleEventObserver &amp;&amp; isDefaultLifecycleObserver) { return DefaultLifecycleObserverAdapter( `object` as DefaultLifecycleObserver, `object` as LifecycleEventObserver ) } if (isDefaultLifecycleObserver) { return DefaultLifecycleObserverAdapter(`object` as DefaultLifecycleObserver, null) } if (isLifecycleEventObserver) { return `object` as LifecycleEventObserver } val klass: Class&lt;*&gt; = `object`.javaClass val type = getObserverConstructorType(klass) if (type == GENERATED_CALLBACK) { val constructors = classToAdapters[klass]!! if (constructors.size == 1) { val generatedAdapter = createGeneratedAdapter( constructors[0], `object` ) return SingleGeneratedAdapterObserver(generatedAdapter) } val adapters: Array&lt;GeneratedAdapter&gt; = Array(constructors.size) { i -&gt; createGeneratedAdapter(constructors[i], `object`) } return CompositeGeneratedAdaptersObserver(adapters) } return ReflectiveGenericLifecycleObserver(`object`)} å¯ä»¥çœ‹åˆ°è¿™é‡Œä¼šåˆ¤æ–­observerçš„ç±»å‹ï¼Œå¦‚æœæ˜¯DefaultLifecycleObserverï¼Œåˆ™ä¼šä½¿ç”¨DefaultLifecycleObserverAdapterå¯¹observerè¿›è¡Œé€‚é… è¿™é‡Œå¯ä»¥çœ‹åˆ°ï¼Œé€‚é…å™¨è€ƒè™‘åˆ°äº†Observerå³æ˜¯LifecycleEventObserveråˆæ˜¯DefaultLifecycleObserverçš„æƒ…å†µ DefaultLifecycleObserverAdapter123456789101112131415161718internal class DefaultLifecycleObserverAdapter( private val defaultLifecycleObserver: DefaultLifecycleObserver, private val lifecycleEventObserver: LifecycleEventObserver?) : LifecycleEventObserver { override fun onStateChanged(source: LifecycleOwner, event: Lifecycle.Event) { when (event) { Lifecycle.Event.ON_CREATE -&gt; defaultLifecycleObserver.onCreate(source) Lifecycle.Event.ON_START -&gt; defaultLifecycleObserver.onStart(source) Lifecycle.Event.ON_RESUME -&gt; defaultLifecycleObserver.onResume(source) Lifecycle.Event.ON_PAUSE -&gt; defaultLifecycleObserver.onPause(source) Lifecycle.Event.ON_STOP -&gt; defaultLifecycleObserver.onStop(source) Lifecycle.Event.ON_DESTROY -&gt; defaultLifecycleObserver.onDestroy(source) Lifecycle.Event.ON_ANY -&gt; throw IllegalArgumentException(&quot;ON_ANY must not been send by anybody&quot;) } lifecycleEventObserver?.onStateChanged(source, event) }} è¿™é‡Œå°±å¾ˆæ¸…æ™°äº†ï¼ŒDefaultLifecycleObserverAdapteræ ¹æ®å½“å‰çš„stateè°ƒç”¨DefaultLifecycleObserverçš„å„ä¸ªå›è°ƒ handleLifecycleEvent123456789101112/** * Sets the current state and notifies the observers. * * Note that if the `currentState` is the same state as the last call to this method, * calling this method has no effect. * * @param event The event that was received */open fun handleLifecycleEvent(event: Event) { enforceMainThreadIfNeeded(&quot;handleLifecycleEvent&quot;) moveToState(event.targetState)} è¿™é‡Œçœ‹åˆ°handleLifecycleEventä¹Ÿæœ‰è®¾ç½®stateçš„ä½œç”¨ Activityç”Ÿå‘½å‘¨æœŸç›¸å…³å‡½æ•°å›è°ƒç»“æ„å®šä¹‰12private final ArrayList&lt;Application.ActivityLifecycleCallbacks&gt; mActivityLifecycleCallbacks = new ArrayList&lt;Application.ActivityLifecycleCallbacks&gt;(); æ­¤å¤„å®šä¹‰äº†ä¸€ä¸ªå›è°ƒçš„æ¥å£List æ³¨å†Œä¸åˆ é™¤12345678910111213public void registerActivityLifecycleCallbacks( @NonNull Application.ActivityLifecycleCallbacks callback) { synchronized (mActivityLifecycleCallbacks) { mActivityLifecycleCallbacks.add(callback); }}public void unregisterActivityLifecycleCallbacks( @NonNull Application.ActivityLifecycleCallbacks callback) { synchronized (mActivityLifecycleCallbacks) { mActivityLifecycleCallbacks.remove(callback); }} å›è°ƒlistè½¬æ•°ç»„123456789private Object[] collectActivityLifecycleCallbacks() { Object[] callbacks = null; synchronized (mActivityLifecycleCallbacks) { if (mActivityLifecycleCallbacks.size() &gt; 0) { callbacks = mActivityLifecycleCallbacks.toArray(); } } return callbacks;} ä¸‹é¢ä»‹ç»çš„dispatchActivityXXXå‡½æ•°å°†è°ƒç”¨collectActivityLifecycleCallbacksè·å–æ‰€æœ‰callbacksï¼Œç„¶åè°ƒç”¨callbacksçš„onActivityXXXå‡½æ•° dispatchActivityPreCreated12345678910private void dispatchActivityPreCreated(@Nullable Bundle savedInstanceState) { getApplication().dispatchActivityPreCreated(this, savedInstanceState); Object[] callbacks = collectActivityLifecycleCallbacks(); if (callbacks != null) { for (int i = 0; i &lt; callbacks.length; i++) { ((Application.ActivityLifecycleCallbacks) callbacks[i]).onActivityPreCreated(this, savedInstanceState); } }} dispatchActivityCreated12345678910private void dispatchActivityCreated(@Nullable Bundle savedInstanceState) { getApplication().dispatchActivityCreated(this, savedInstanceState); Object[] callbacks = collectActivityLifecycleCallbacks(); if (callbacks != null) { for (int i = 0; i &lt; callbacks.length; i++) { ((Application.ActivityLifecycleCallbacks) callbacks[i]).onActivityCreated(this, savedInstanceState); } }} dispatchActivityPostCreated12345678910private void dispatchActivityPostCreated(@Nullable Bundle savedInstanceState) { Object[] callbacks = collectActivityLifecycleCallbacks(); if (callbacks != null) { for (int i = 0; i &lt; callbacks.length; i++) { ((Application.ActivityLifecycleCallbacks) callbacks[i]).onActivityPostCreated(this, savedInstanceState); } } getApplication().dispatchActivityPostCreated(this, savedInstanceState);} æ¯æ®µä»£ç å‡ ä¹æ˜¯ä¸€æ ·çš„ï¼Œå°±ä¸å…¨è´´ä¸Šæ¥äº† æ²¡è´´ä¸Šæ¥çš„è¿˜æœ‰ dispatchActivityPreStarted, dispatchActivityStarted, dispatchActivityPostStarted dispatchActivityPreResumed, dispatchActivityResumed, dispatchActivityPostResumed dispatchActivityPrePaused, dispatchActivityPaused, dispatchActivityPostPaused dispatchActivitySaveInstanceState, dispatchActivitySaveInstanceState, dispatchActivityPostSaveInstanceState dispatchActivityPreDestroyed, dispatchActivityDestroyed, dispatchActivityPostDestroyed dispatchActivityConfigurationChanged ReportFragment reportFragmentè´Ÿè´£ä¼ é€’Activityçš„ç”Ÿå‘½å‘¨æœŸ ReportFragmentçš„åˆå§‹åŒ–1234override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) ReportFragment.injectIfNeededIn(this)} 12345678910111213141516fun injectIfNeededIn(activity: Activity) { if (Build.VERSION.SDK_INT &gt;= 29) { // On API 29+, we can register for the correct Lifecycle callbacks directly LifecycleCallbacks.registerIn(activity) } // Prior to API 29 and to maintain compatibility with older versions of // ProcessLifecycleOwner (which may not be updated when lifecycle-runtime is updated and // need to support activities that don't extend from FragmentActivity from support lib), // use a framework fragment to get the correct timing of Lifecycle events val manager = activity.fragmentManager if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) { manager.beginTransaction().add(ReportFragment(), REPORT_FRAGMENT_TAG).commit() // Hopefully, we are the first to make a transaction. manager.executePendingTransactions() }} api29ä¹‹åï¼Œä¼šä½¿ç”¨LifecycleCallbacks.registerIn å¦å¤–è¿˜ä¼šä½¿ç”¨ReportFragmentæ¥æŠ¥å‘Šactivityçš„ç”Ÿå‘½å‘¨æœŸ ReportFragmentåˆ†å‘ç”Ÿå‘½å‘¨æœŸ(API 29ä¹‹å‰)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private var processListener: ActivityInitializationListener? = nullprivate fun dispatchCreate(listener: ActivityInitializationListener?) { listener?.onCreate()}private fun dispatchStart(listener: ActivityInitializationListener?) { listener?.onStart()}private fun dispatchResume(listener: ActivityInitializationListener?) { listener?.onResume()}override fun onActivityCreated(savedInstanceState: Bundle?) { super.onActivityCreated(savedInstanceState) dispatchCreate(processListener) dispatch(Lifecycle.Event.ON_CREATE)}override fun onStart() { super.onStart() dispatchStart(processListener) dispatch(Lifecycle.Event.ON_START)}override fun onResume() { super.onResume() dispatchResume(processListener) dispatch(Lifecycle.Event.ON_RESUME)}override fun onPause() { super.onPause() dispatch(Lifecycle.Event.ON_PAUSE)}override fun onStop() { super.onStop() dispatch(Lifecycle.Event.ON_STOP)}override fun onDestroy() { super.onDestroy() dispatch(Lifecycle.Event.ON_DESTROY) // just want to be sure that we won't leak reference to an activity processListener = null} å¯ä»¥çœ‹åˆ°ï¼Œå½“Fragmentçš„å£°æ˜å‘¨æœŸå‡½æ•°è¢«è°ƒç”¨æ—¶ï¼Œä¼šè°ƒç”¨dispatchï¼Œå°†activityçš„ç”Ÿå‘½å‘¨æœŸè¿›è¡Œä¼ é€’ dispatch123456789101112131415161718192021private fun dispatch(event: Lifecycle.Event) { if (Build.VERSION.SDK_INT &lt; 29) { // Only dispatch events from ReportFragment on API levels prior // to API 29. On API 29+, this is handled by the ActivityLifecycleCallbacks // added in ReportFragment.injectIfNeededIn dispatch(activity, event) }}internal fun dispatch(activity: Activity, event: Lifecycle.Event) { if (activity is LifecycleRegistryOwner) { activity.lifecycle.handleLifecycleEvent(event) return } if (activity is LifecycleOwner) { val lifecycle = (activity as LifecycleOwner).lifecycle if (lifecycle is LifecycleRegistry) { lifecycle.handleLifecycleEvent(event) } }} ä»…åœ¨api 29ä¹‹å‰é€šè¿‡ReportFragmentæ¥è¿›è¡Œactivityçš„ç”Ÿå‘½å‘¨æœŸä¼ é€’ è¿™é‡Œå°±å¯ä»¥çœ‹åˆ°ä¸Šé¢åˆ†æçš„LifecycleRegistryç±»äº†ï¼Œè·å–activityä¸­çš„lifecycleå†è°ƒç”¨handleLifecycleEventæ¥æ›´æ–°activityçš„ç”Ÿå‘½å‘¨æœŸï¼Œè¿›è€Œå°†ç”Ÿå‘½å‘¨æœŸæ”¹å˜ä¼ é€’ç»™listener API 29åŠä»¥åActivityåˆ†å‘ç”Ÿå‘½å‘¨æœŸå›åˆ°ReportFragment1234567fun injectIfNeededIn(activity: Activity) { if (Build.VERSION.SDK_INT &gt;= 29) { // On API 29+, we can register for the correct Lifecycle callbacks directly LifecycleCallbacks.registerIn(activity) } // ...} å¤§äºç­‰äºApi 29æ—¶ï¼Œä¼šè°ƒç”¨registerIn registerIn1234@JvmStaticfun registerIn(activity: Activity) { activity.registerActivityLifecycleCallbacks(LifecycleCallbacks())} è¿™é‡Œçœ‹åˆ°ï¼Œè°ƒç”¨äº†activityçš„registerActivityLifecycleCallbacksï¼Œactivityä¼šåœ¨å‘ç”Ÿç”Ÿå‘½å‘¨æœŸæ”¹å˜æ—¶è°ƒç”¨å›è°ƒLifecycleCallbacks LifecycleCallbacks12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455internal class LifecycleCallbacks : Application.ActivityLifecycleCallbacks { override fun onActivityCreated( activity: Activity, bundle: Bundle? ) {} override fun onActivityPostCreated( activity: Activity, savedInstanceState: Bundle? ) { dispatch(activity, Lifecycle.Event.ON_CREATE) } override fun onActivityStarted(activity: Activity) {} override fun onActivityPostStarted(activity: Activity) { dispatch(activity, Lifecycle.Event.ON_START) } override fun onActivityResumed(activity: Activity) {} override fun onActivityPostResumed(activity: Activity) { dispatch(activity, Lifecycle.Event.ON_RESUME) } override fun onActivityPrePaused(activity: Activity) { dispatch(activity, Lifecycle.Event.ON_PAUSE) } override fun onActivityPaused(activity: Activity) {} override fun onActivityPreStopped(activity: Activity) { dispatch(activity, Lifecycle.Event.ON_STOP) } override fun onActivityStopped(activity: Activity) {} override fun onActivitySaveInstanceState( activity: Activity, bundle: Bundle ) {} override fun onActivityPreDestroyed(activity: Activity) { dispatch(activity, Lifecycle.Event.ON_DESTROY) } override fun onActivityDestroyed(activity: Activity) {} companion object { @JvmStatic fun registerIn(activity: Activity) { activity.registerActivityLifecycleCallbacks(LifecycleCallbacks()) } }} è¿™é‡Œçœ‹åˆ°LifecycleCallbacksè°ƒç”¨äº†dispatch()å‡½æ•°ï¼Œå°†activityçš„ç”Ÿå‘½å‘¨æœŸè¿›è¡Œäº†åˆ†å‘ Fragmentçš„lifecycleå®ç°LifecycleOwner12345678public class Fragment implements ComponentCallbacks, OnCreateContextMenuListener, LifecycleOwner, ViewModelStoreOwner, HasDefaultViewModelProviderFactory, SavedStateRegistryOwner, ActivityResultCaller { @Override @NonNull public Lifecycle getLifecycle() { return mLifecycleRegistry; } åˆå§‹åŒ–Lifecycle12345678910111213public Fragment() { initLifecycle();}private void initLifecycle() { mLifecycleRegistry = new LifecycleRegistry(this); mSavedStateRegistryController = SavedStateRegistryController.create(this); // The default factory depends on the SavedStateRegistry so it // needs to be reset when the SavedStateRegistry is reset mDefaultFactory = null; if (!mOnPreAttachedListeners.contains(mSavedStateAttachListener)) { registerOnPreAttachListener(mSavedStateAttachListener); }} ä¼ é€’äº‹ä»¶fragmentçš„ç”Ÿå‘½å‘¨æœŸä¼ é€’æ¯”è¾ƒç®€å•ï¼Œå°±æ˜¯åœ¨fragmentå„ä¸ªç”Ÿå‘½å‘¨æœŸæ—¶è°ƒç”¨handleLifecycleEvent 1234567891011121314151617181920212223void performCreate(Bundle savedInstanceState) { mChildFragmentManager.noteStateNotSaved(); mState = CREATED; mCalled = false; mLifecycleRegistry.addObserver(new LifecycleEventObserver() { @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) { if (event == Lifecycle.Event.ON_STOP) { if (mView != null) { mView.cancelPendingInputEvents(); } } } }); onCreate(savedInstanceState); mIsCreated = true; if (!mCalled) { throw new SuperNotCalledException(&quot;Fragment &quot; + this + &quot; did not call through to super.onCreate()&quot;); } mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);} 12345678910111213141516void performStart() { mChildFragmentManager.noteStateNotSaved(); mChildFragmentManager.execPendingActions(true); mState = STARTED; mCalled = false; onStart(); if (!mCalled) { throw new SuperNotCalledException(&quot;Fragment &quot; + this + &quot; did not call through to super.onStart()&quot;); } mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START); if (mView != null) { mViewLifecycleOwner.handleLifecycleEvent(Lifecycle.Event.ON_START); } mChildFragmentManager.dispatchStart();} 12345678910111213141516void performResume() { mChildFragmentManager.noteStateNotSaved(); mChildFragmentManager.execPendingActions(true); mState = RESUMED; mCalled = false; onResume(); if (!mCalled) { throw new SuperNotCalledException(&quot;Fragment &quot; + this + &quot; did not call through to super.onResume()&quot;); } mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME); if (mView != null) { mViewLifecycleOwner.handleLifecycleEvent(Lifecycle.Event.ON_RESUME); } mChildFragmentManager.dispatchResume();} 1234567891011121314void performPause() { mChildFragmentManager.dispatchPause(); if (mView != null) { mViewLifecycleOwner.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE); } mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE); mState = AWAITING_ENTER_EFFECTS; mCalled = false; onPause(); if (!mCalled) { throw new SuperNotCalledException(&quot;Fragment &quot; + this + &quot; did not call through to super.onPause()&quot;); }} 1234567891011121314void performStop() { mChildFragmentManager.dispatchStop(); if (mView != null) { mViewLifecycleOwner.handleLifecycleEvent(Lifecycle.Event.ON_STOP); } mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP); mState = ACTIVITY_CREATED; mCalled = false; onStop(); if (!mCalled) { throw new SuperNotCalledException(&quot;Fragment &quot; + this + &quot; did not call through to super.onStop()&quot;); }} 123456789101112void performDestroy() { mChildFragmentManager.dispatchDestroy(); mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY); mState = ATTACHED; mCalled = false; mIsCreated = false; onDestroy(); if (!mCalled) { throw new SuperNotCalledException(&quot;Fragment &quot; + this + &quot; did not call through to super.onDestroy()&quot;); }}","link":"/home/2024/07/31/Android%E9%AB%98%E7%BA%A7/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E5%9F%BA%E7%A1%8003-Lifecycle/"},{"title":"åŸºç¡€04-LiveData","text":"LiveDataLiveDataçš„è§‚å¯Ÿè€…1234567fun interface Observer&lt;T&gt; { /** * Called when the data is changed to [value]. */ fun onChanged(value: T)} é€šè¿‡onChangedå‡½æ•°åˆ†æ´¾æ•°æ®å˜åŒ– æˆå‘˜123456789101112131415161718192021222324252627282930313233343536@SuppressWarnings(&quot;WeakerAccess&quot;) /* synthetic access */final Object mDataLock = new Object();static final int START_VERSION = -1;@SuppressWarnings(&quot;WeakerAccess&quot;) /* synthetic access */static final Object NOT_SET = new Object();private SafeIterableMap&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt; mObservers = new SafeIterableMap&lt;&gt;();// how many observers are in active state@SuppressWarnings(&quot;WeakerAccess&quot;) /* synthetic access */int mActiveCount = 0;// to handle active/inactive reentry, we guard with this booleanprivate boolean mChangingActiveState;private volatile Object mData; // 1ï¸âƒ£ï¼šå½“å‰çš„data// when setData is called, we set the pending data and actual data swap happens on the main// thread@SuppressWarnings(&quot;WeakerAccess&quot;) /* synthetic access */volatile Object mPendingData = NOT_SET; // 2ï¸âƒ£ï¼šç»™å¤šçº¿ç¨‹ä½¿ç”¨çš„ï¼Œåœ¨4ï¸âƒ£mPostValueRunnableä¸­ä½¿ç”¨private int mVersion; // 3ï¸âƒ£ï¼šmVersionæ˜¯æ•°æ®ç‰ˆæœ¬private boolean mDispatchingValue;@SuppressWarnings(&quot;FieldCanBeLocal&quot;)private boolean mDispatchInvalidated;private final Runnable mPostValueRunnable = new Runnable() {// 4ï¸âƒ£mPostValueRunnableï¼Œåœ¨ä¸»çº¿ç¨‹ä¸­å°†mPendingDataè®¾ç½®ä¸ºå½“å‰å€¼ @SuppressWarnings(&quot;unchecked&quot;) @Override public void run() { Object newValue; synchronized (mDataLock) { newValue = mPendingData; mPendingData = NOT_SET; } setValue((T) newValue); }}; æ•°æ®å­˜åœ¨mDataä¸­ mPendingDataç»™å¤šçº¿ç¨‹ä½¿ç”¨çš„ï¼Œåœ¨mPostValueRunnableæ—¶è®¾ç½®ä¸ºå½“å‰å€¼ mVersionæ˜¯æ•°æ®ç‰ˆæœ¬ mPostValueRunnableï¼Œåœ¨ä¸»çº¿ç¨‹ä¸­å°†mPendingDataè®¾ç½®ä¸ºå½“å‰å€¼ æ„é€ 123456789public LiveData(T value) { mData = value; mVersion = START_VERSION + 1;}public LiveData() { mData = NOT_SET; mVersion = START_VERSION;} get å’Œ set1234567891011121314151617181920212223242526272829@MainThreadprotected void setValue(T value) { assertMainThread(&quot;setValue&quot;); mVersion++; mData = value; dispatchingValue(null);}@SuppressWarnings(&quot;unchecked&quot;)@Nullablepublic T getValue() { Object data = mData; if (data != NOT_SET) { return (T) data; } return null;}protected void postValue(T value) { boolean postTask; synchronized (mDataLock) { postTask = mPendingData == NOT_SET; mPendingData = value; } if (!postTask) { return; } ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);} æ¯æ¬¡set,mVersionéƒ½ä¼šè‡ªå¢1ï¼Œå¹¶è°ƒç”¨dispatchingValue éä¸»çº¿ç¨‹ä¸­è°ƒç”¨postValueåœ¨ä¸»çº¿ç¨‹ä¸­æ›´æ–°å€¼, mPendingDataæ˜¯è¢«å¼‚æ­¥æ›´æ–°çš„ï¼Œä½†æœ€ç»ˆmDataéƒ½åœ¨ä¸»çº¿ç¨‹ä¸­è¢«set postValueå’ŒmPostValueRunnableæ›´æ–°mPendingDataæ—¶å…ˆè·å–mDataLockå¯¹è±¡çš„é”ï¼Œrunnableæ‰§è¡Œåä¼šå°†mPendingDataè®¾ç½®ä¸ºNOT_SETã€‚å¦‚æœpostValueæ—¶mPendingDataä¸æ˜¯NOT_SETï¼Œå°±ä¸ä¼šé‡å¤post runnable åˆ†æ´¾äº‹ä»¶dispatchingValue123456789101112131415161718192021222324@SuppressWarnings(&quot;WeakerAccess&quot;) /* synthetic access */void dispatchingValue(@Nullable ObserverWrapper initiator) { if (mDispatchingValue) { mDispatchInvalidated = true; return; } mDispatchingValue = true; do { mDispatchInvalidated = false; if (initiator != null) { considerNotify(initiator); initiator = null; } else { for (Iterator&lt;Map.Entry&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt;&gt; iterator = mObservers.iteratorWithAdditions(); iterator.hasNext(); ) { considerNotify(iterator.next().getValue()); if (mDispatchInvalidated) { break; } } } } while (mDispatchInvalidated); mDispatchingValue = false;} å¦‚æœå½“å‰æ­£åœ¨åˆ†æ´¾ï¼Œåˆ™é€€å‡ºï¼Œå¹¶é€šè¿‡mDispatchInvalidatedæ‰“æ–­åç»­åˆ†æ´¾ å¦‚æœå‚æ•°ä¸ç©ºï¼Œåˆ™åªåˆ†æ´¾ç»™å‚æ•°ï¼Œå¦åˆ™åˆ†æ´¾ç»™æ‰€æœ‰observer considerNotify12345678910111213141516171819private void considerNotify(ObserverWrapper observer) { if (!observer.mActive) { return; } // Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet. // // we still first check observer.active to keep it as the entrance for events. So even if // the observer moved to an active state, if we've not received that event, we better not // notify for a more predictable notification order. if (!observer.shouldBeActive()) { observer.activeStateChanged(false); return; } if (observer.mLastVersion &gt;= mVersion) { return; } observer.mLastVersion = mVersion; observer.mObserver.onChanged((T) mData);} å¦‚æœobserveréactiveçŠ¶æ€ï¼Œä¸åˆ†æ´¾ å¦‚æœobserverä¸Šæ¬¡çš„æ•°æ®ç‰ˆæœ¬å¤§äºå½“å‰ç‰ˆæœ¬ï¼Œä¸åˆ†æ´¾ æ›´æ–°observerçš„æ•°æ®ç‰ˆæœ¬ è°ƒç”¨observerçš„onChangedåˆ†æ´¾æ•°æ®å˜åŒ– ObserverWrapper12345678910111213141516171819202122232425262728293031private abstract class ObserverWrapper { final Observer&lt;? super T&gt; mObserver; boolean mActive; int mLastVersion = START_VERSION; ObserverWrapper(Observer&lt;? super T&gt; observer) { mObserver = observer; } abstract boolean shouldBeActive(); boolean isAttachedTo(LifecycleOwner owner) { return false; } void detachObserver() { } void activeStateChanged(boolean newActive) { if (newActive == mActive) { return; } // immediately set active state, so we'd never dispatch anything to inactive // owner mActive = newActive; changeActiveCounter(mActive ? 1 : -1); if (mActive) { dispatchingValue(this); } }} å¯¹Observerè¿›è¡ŒåŒ…è£…ï¼Œè®°å½•äº†å½“å‰çš„æ•°æ®versionå’ŒactiveçŠ¶æ€ å½“activeStateChangedè¢«è°ƒç”¨æ—¶ï¼Œé¦–å…ˆåˆ¤æ–­ä¸åŸæ¥çš„activeçŠ¶æ€æ˜¯å¦ä¸€è‡´ï¼Œå¦‚æœä¸€è‡´ï¼Œåˆ™ç›´æ¥è¿”å› å¦‚æœä¸ä¸€è‡´ï¼Œåˆ™æ›´æ–°activeçŠ¶æ€ï¼Œå¹¶è°ƒç”¨å¤–éƒ¨ç±»(LiveData)çš„changeActiveCounter å¦‚æœå½“å‰activeçŠ¶æ€ä»falseå˜ä¸ºtrueï¼Œåˆ™è°ƒç”¨dispatchingValueï¼Œç«‹åˆ»å‘è§‚å¯Ÿè€…ä¼ é€’æœ€æ–°çš„æ•°æ®çŠ¶æ€ changeActiveCounter1234567891011121314151617181920212223@MainThreadvoid changeActiveCounter(int change) { int previousActiveCount = mActiveCount; mActiveCount += change; if (mChangingActiveState) { return; } mChangingActiveState = true; try { while (previousActiveCount != mActiveCount) { boolean needToCallActive = previousActiveCount == 0 &amp;&amp; mActiveCount &gt; 0; boolean needToCallInactive = previousActiveCount &gt; 0 &amp;&amp; mActiveCount == 0; previousActiveCount = mActiveCount; if (needToCallActive) { onActive(); } else if (needToCallInactive) { onInactive(); } } } finally { mChangingActiveState = false; }} ä¼šä¿å­˜å½“å‰çŠ¶æ€ä¸ºactiveçš„observerçš„æ•°é‡ è¿™ä¸ªå‡½æ•°ä¼šæ›´æ–°å…¶å€¼ å¦‚æœåŸæ¥activeçš„ä¸ªæ•°ä¸º0ï¼Œç°åœ¨å¤§äº0ï¼Œé‚£ä¹ˆè°ƒç”¨onActive å¦‚æœåŸæ¥activeçš„ä¸ªæ•°å¤§äº0ï¼Œç°åœ¨ä¸º0ï¼Œé‚£ä¹ˆè°ƒç”¨onInactive onActiveå’ŒonInactive123456protected void onInactive() {}protected void onActive() {} ç»™å­ç±»ç”¨çš„é’©å­æ–¹æ³•ï¼Œç”¨äºé€šçŸ¥å½“å‰æ˜¯å¦æœ‰activeçš„observer AlwaysActiveObserver1234567891011private class AlwaysActiveObserver extends ObserverWrapper { AlwaysActiveObserver(Observer&lt;? super T&gt; observer) { super(observer); } @Override boolean shouldBeActive() { return true; }} è¿™ç±»Observerä¼šä¸€ç›´å¤„äºactiveçŠ¶æ€ observeForeverä¼šåˆ›å»ºAlwaysActiveObserverï¼Œåˆ›å»ºåç«‹åˆ»è°ƒç”¨activeStateChanged(true)æ›´æ–°activeçŠ¶æ€ï¼Œactiveæ€»æ•° æ·»åŠ AlwaysActiveObserver12345678910111213public void observeForever(@NonNull Observer&lt;? super T&gt; observer) { assertMainThread(&quot;observeForever&quot;); AlwaysActiveObserver wrapper = new AlwaysActiveObserver(observer); ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); if (existing instanceof LiveData.LifecycleBoundObserver) { throw new IllegalArgumentException(&quot;Cannot add the same observer&quot; + &quot; with different lifecycles&quot;); } if (existing != null) { return; } wrapper.activeStateChanged(true);} LifecycleBoundObserver12345678910111213141516171819202122232425262728293031323334353637383940class LifecycleBoundObserver extends ObserverWrapper implements LifecycleEventObserver { @NonNull final LifecycleOwner mOwner; LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer&lt;? super T&gt; observer) { super(observer); mOwner = owner; } @Override boolean shouldBeActive() { return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED); } @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) { Lifecycle.State currentState = mOwner.getLifecycle().getCurrentState(); if (currentState == DESTROYED) { removeObserver(mObserver); return; } Lifecycle.State prevState = null; while (prevState != currentState) { prevState = currentState; activeStateChanged(shouldBeActive()); currentState = mOwner.getLifecycle().getCurrentState(); } } @Override boolean isAttachedTo(LifecycleOwner owner) { return mOwner == owner; } @Override void detachObserver() { mOwner.getLifecycle().removeObserver(this); }} åŒæ—¶å®ç°äº†LifecycleEventObserverï¼Œå¯ä»¥è§‚å¯Ÿlifecycle ä¿å­˜å¯¹åº”çš„lifecycleOwner æ ¹æ®shouldBeActiveï¼Œå½“å…³è”çš„Lifecycleåˆ°è¾¾äº†startedåŠä»¥åçš„çŠ¶æ€ï¼Œå°±æ˜¯activeçš„äº† å½“lifecycleçŠ¶æ€å˜åŒ–æ—¶ å¦‚æœåˆ°äº†destroyed,åˆ™è°ƒç”¨å¤–éƒ¨ç±»çš„removeObserverç§»é™¤å½“å‰observer ç„¶åè¿›ä¸€ä¸ªå¾ªç¯ï¼Œè°ƒç”¨activeStateChangedæ›´æ–°å½“å‰çš„activeçŠ¶æ€ï¼Œç›´åˆ°ä¸¤æ¬¡è·å–lifecycleçš„å½“å‰çŠ¶æ€éƒ½ç›¸åŒæ—¶ï¼Œé€€å‡ºå¾ªç¯ æ·»åŠ ä¸€ä¸ªLifecycleBoundObserver123456789101112131415161718@MainThreadpublic void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) { assertMainThread(&quot;observe&quot;); if (owner.getLifecycle().getCurrentState() == DESTROYED) { // ignore return; } LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer); ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); if (existing != null &amp;&amp; !existing.isAttachedTo(owner)) { throw new IllegalArgumentException(&quot;Cannot add the same observer&quot; + &quot; with different lifecycles&quot;); } if (existing != null) { return; } owner.getLifecycle().addObserver(wrapper);} åˆ›å»ºLifecycleBoundObserverï¼Œå¹¶ç«‹åˆ»å°†å…¶æ³¨å†Œåˆ°lifecycleçš„observerä¸­ lifecycleæ·»åŠ observeråï¼Œä¼šç«‹åˆ»ä¼ é€’çŠ¶æ€ï¼Œè¿™é‡Œä¹Ÿå¯ä»¥ç«‹åˆ»æ ¹æ®lifecycleçš„çŠ¶æ€æ›´æ–°activeçŠ¶æ€ï¼Œè¿›è€Œå‘è§‚å¯Ÿè€…åˆ†æ´¾å½“å‰å€¼ ç§»é™¤observer1234567891011121314151617181920212223242526@MainThreadpublic void removeObserver(@NonNull final Observer&lt;? super T&gt; observer) { assertMainThread(&quot;removeObserver&quot;); ObserverWrapper removed = mObservers.remove(observer); if (removed == null) { return; } removed.detachObserver(); removed.activeStateChanged(false);}/** * Removes all observers that are tied to the given {@link LifecycleOwner}. * * @param owner The {@code LifecycleOwner} scope for the observers to be removed. */@SuppressWarnings(&quot;WeakerAccess&quot;)@MainThreadpublic void removeObservers(@NonNull final LifecycleOwner owner) { assertMainThread(&quot;removeObservers&quot;); for (Map.Entry&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt; entry : mObservers) { if (entry.getValue().isAttachedTo(owner)) { removeObserver(entry.getKey()); } }} ä»mapä¸­åˆ é™¤observer è°ƒç”¨activeStateChanged(false), å°†å…¶activeçŠ¶æ€å˜æˆfalseï¼Œå‡å°‘æ´»è·ƒçŠ¶æ€çš„æ•°é‡ï¼ŒæŒ‰éœ€è°ƒç”¨onInactive(), è°ƒç”¨detachObserverï¼Œå¦‚æœæ˜¯LifecycleBoundObserverï¼Œå°±åœæ­¢ä»lifecycleä¸­è§‚å¯ŸçŠ¶æ€ã€‚ MutableLiveData1234567891011121314151617181920212223242526272829@SuppressWarnings(&quot;WeakerAccess&quot;)public class MutableLiveData&lt;T&gt; extends LiveData&lt;T&gt; { /** * Creates a MutableLiveData initialized with the given {@code value}. * * @param value initial value */ public MutableLiveData(T value) { super(value); } /** * Creates a MutableLiveData with no value assigned to it. */ public MutableLiveData() { super(); } @Override public void postValue(T value) { super.postValue(value); } @Override public void setValue(T value) { super.setValue(value); }} å¥½çŒ«çŒ«ç®€æ´ postValueå’ŒsetValueå‡çº§æˆpublicäº† MediatorLiveData é…ç½®å¤šä¸ªæ›´æ–°æºLiveDataï¼Œå½“è§‚å¯Ÿåˆ°ä¸€ä¸ªLiveDataå‘ç”Ÿæ”¹å˜ï¼Œåˆ™æ‰§è¡Œç›¸åº”çš„åŠ¨ä½œ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107public class MediatorLiveData&lt;T&gt; extends MutableLiveData&lt;T&gt; { private SafeIterableMap&lt;LiveData&lt;?&gt;, Source&lt;?&gt;&gt; mSources = new SafeIterableMap&lt;&gt;(); /** * Creates a MediatorLiveData with no value assigned to it. */ public MediatorLiveData() { super(); } /** * Creates a MediatorLiveData initialized with the given {@code value}. * * @param value initial value */ public MediatorLiveData(T value) { super(value); } /** * Starts to listen to the given {@code source} LiveData, {@code onChanged} observer will be * called when {@code source} value was changed. * &lt;p&gt; * {@code onChanged} callback will be called only when this {@code MediatorLiveData} is active. * &lt;p&gt; If the given LiveData is already added as a source but with a different Observer, * {@link IllegalArgumentException} will be thrown. * * @param source the {@code LiveData} to listen to * @param onChanged The observer that will receive the events * @param &lt;S&gt; The type of data hold by {@code source} LiveData */ @MainThread public &lt;S&gt; void addSource(@NonNull LiveData&lt;S&gt; source, @NonNull Observer&lt;? super S&gt; onChanged) { if (source == null) { throw new NullPointerException(&quot;source cannot be null&quot;); } Source&lt;S&gt; e = new Source&lt;&gt;(source, onChanged); Source&lt;?&gt; existing = mSources.putIfAbsent(source, e); if (existing != null &amp;&amp; existing.mObserver != onChanged) { throw new IllegalArgumentException( &quot;This source was already added with the different observer&quot;); } if (existing != null) { return; } if (hasActiveObservers()) { e.plug(); } } /** * Stops to listen the given {@code LiveData}. * * @param toRemote {@code LiveData} to stop to listen * @param &lt;S&gt; the type of data hold by {@code source} LiveData */ @MainThread public &lt;S&gt; void removeSource(@NonNull LiveData&lt;S&gt; toRemote) { Source&lt;?&gt; source = mSources.remove(toRemote); if (source != null) { source.unplug(); } } @CallSuper @Override protected void onActive() { for (Map.Entry&lt;LiveData&lt;?&gt;, Source&lt;?&gt;&gt; source : mSources) { source.getValue().plug(); } } @CallSuper @Override protected void onInactive() { for (Map.Entry&lt;LiveData&lt;?&gt;, Source&lt;?&gt;&gt; source : mSources) { source.getValue().unplug(); } } private static class Source&lt;V&gt; implements Observer&lt;V&gt; { final LiveData&lt;V&gt; mLiveData; final Observer&lt;? super V&gt; mObserver; int mVersion = START_VERSION; Source(LiveData&lt;V&gt; liveData, final Observer&lt;? super V&gt; observer) { mLiveData = liveData; mObserver = observer; } void plug() { mLiveData.observeForever(this); } void unplug() { mLiveData.removeObserver(this); } @Override public void onChanged(@Nullable V v) { if (mVersion != mLiveData.getVersion()) { mVersion = mLiveData.getVersion(); mObserver.onChanged(v); } } }} æ„Ÿè§‰å°±æ˜¯å¸®æˆ‘ä»¬observeForeverï¼Œæ²¡ä»€ä¹ˆç‰¹æ®Šçš„ CoroutineLiveData è¿™ç§livedataæä¾›ç»™ä¸€ä¸ªæ‰§è¡Œå¼‚æ­¥çš„åç¨‹ï¼Œåœ¨æºç¨‹ä¸­è¿›è¡Œè€—æ—¶æ“ä½œï¼Œé€šè¿‡emit, emitSourceå‘é€æ•°æ®ï¼Œç»™è§‚å¯Ÿè€…è¿›è¡Œè§‚å¯Ÿ å…¶ä»–çš„ä½¿ç”¨æ–¹æ³•å’ŒLiveDataä¸€æ ·ï¼Œå¯¹å…¶è¿›è¡Œè§‚å¯Ÿï¼Œå½“æ•°æ®å˜åŒ–æ—¶ï¼Œæ¥æ”¶åˆ°æ•°æ®å˜åŒ– ä½¿ç”¨æ–¹æ³• emit: 1234567891011121314// a LiveData that tries to load the `User` from local cache first and then tries to fetch// from the server and also yields the updated valueval user = liveData { // check local storage val cached = cache.loadUser(id) if (cached != null) { emit(cached) } if (cached == null || cached.isStale()) { val fresh = api.fetch(id) // errors are ignored for brevity cache.save(fresh) emit(fresh) }} è¿™é‡ŒliveDataå‡½æ•°äº§ç”Ÿäº†ä¸€ä¸ªLiveDataï¼Œå¹¶æä¾›äº†ä¸€ä¸ªä»£ç å—ï¼Œè¿™ä¸ªä»£ç å—å›è¿›è¡Œè€—æ—¶æ“ä½œï¼Œé€šè¿‡emitå‡½æ•°æ›´æ–°LiveDataçš„æ•°æ® å‡ ä¸ªé—®é¢˜ ä»£ç å—ä½•æ—¶æ‰§è¡Œï¼Ÿ emitå¦‚ä½•æ›´æ–°æ•°æ®ï¼Ÿ 12345678// a LiveData that immediately receives a LiveData&lt;User&gt; from the database and yields it as a// source but also tries to back-fill the database from the serverval user = liveData { val fromDb: LiveData&lt;User&gt; = roomDatabase.loadUser(id) emitSource(fromDb) val updated = api.fetch(id) // errors are ignored for brevity roomDatabase.insert(updated)} ä»æ•°æ®åº“è¯»å–Userç±»å‹çš„æ•°æ®ï¼Œè¿”å›fromDbï¼Œç„¶åé€šè¿‡emitSourceè§‚å¯Ÿè¯¥fromDbï¼Œå½“fromDbæ›´æ–°æ—¶ï¼Œæ›´æ–°user åŒæ—¶æ‰§è¡Œå…¶ä»–ç›¸å…³çš„ï¼Œæ•°æ®åº“æ›´æ–°æ“ä½œ 123456789101112131415161718192021public fun &lt;T&gt; liveData( context: CoroutineContext = EmptyCoroutineContext, timeoutInMs: Long = DEFAULT_TIMEOUT, block: suspend LiveDataScope&lt;T&gt;.() -&gt; Unit): LiveData&lt;T&gt; = CoroutineLiveData(context, timeoutInMs, block)// æ”¯æŒDurationçš„Api@RequiresApi(Build.VERSION_CODES.O)@JvmOverloadspublic fun &lt;T&gt; liveData( timeout: Duration, context: CoroutineContext = EmptyCoroutineContext, block: suspend LiveDataScope&lt;T&gt;.() -&gt; Unit): LiveData&lt;T&gt; = CoroutineLiveData(context, Api26Impl.toMillis(timeout), block)@RequiresApi(26)internal object Api26Impl { fun toMillis(timeout: Duration): Long { return timeout.toMillis() }} å¯ä»¥ä¼ å…¥ä¸€ä¸ªCoroutineContextï¼Œç”¨äºæŒ‡å®šåç¨‹çš„æ‰§è¡Œç¯å¢ƒï¼Œé»˜è®¤æ˜¯EmptyCoroutineContext å¯ä»¥ä¼ å…¥ä¸€ä¸ªtimeoutInMsï¼Œå…·ä½“ä½œç”¨ä¸‹é¢å†è¯´ CoroutineLiveData1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950internal class CoroutineLiveData&lt;T&gt;( context: CoroutineContext = EmptyCoroutineContext, timeoutInMs: Long = DEFAULT_TIMEOUT, block: Block&lt;T&gt;) : MediatorLiveData&lt;T&gt;() { private var blockRunner: BlockRunner&lt;T&gt;? private var emittedSource: EmittedSource? = null init { // use an intermediate supervisor job so that if we cancel individual block runs due to losing // observers, it won't cancel the given context as we only cancel w/ the intention of possibly // relaunching using the same parent context. val supervisorJob = SupervisorJob(context[Job]) // The scope for this LiveData where we launch every block Job. // We default to Main dispatcher but developer can override it. // The supervisor job is added last to isolate block runs. val scope = CoroutineScope(Dispatchers.Main.immediate + context + supervisorJob) blockRunner = BlockRunner( liveData = this, block = block, timeoutInMs = timeoutInMs, scope = scope ) { blockRunner = null } } internal suspend fun emitSource(source: LiveData&lt;T&gt;): DisposableHandle { clearSource() val newSource = addDisposableSource(source) emittedSource = newSource return newSource } internal suspend fun clearSource() { emittedSource?.disposeNow() emittedSource = null } override fun onActive() { super.onActive() blockRunner?.maybeRun() } override fun onInactive() { super.onInactive() blockRunner?.cancel() }} onActiveå’ŒonInactiveä¸¤ä¸ªå‡½æ•°çš„å†…å®¹æ ‡æ˜ï¼Œä»£ç å—ä¼šåœ¨æ´»è·ƒè§‚å¯Ÿè€…æ•°é‡å¤§äº1æ—¶å¼€å§‹æ‰§è¡Œï¼Œæ²¡æœ‰æ´»è·ƒè§‚å¯Ÿè€…æ—¶è¢«cancel æ³¨æ„åˆ°CoroutineLiveDataæ˜¯ä¸€ä¸ªMediatorLiveDataï¼Œä¸‹é¢è¦è€ƒ Blockçš„è¿è¡Œå’Œå–æ¶ˆ12345678910111213141516171819202122232425262728293031323334353637383940414243internal class BlockRunner&lt;T&gt;( private val liveData: CoroutineLiveData&lt;T&gt;, private val block: Block&lt;T&gt;, private val timeoutInMs: Long, private val scope: CoroutineScope, private val onDone: () -&gt; Unit) { // currently running block job. private var runningJob: Job? = null // cancelation job created in cancel. private var cancellationJob: Job? = null @MainThread fun maybeRun() { cancellationJob?.cancel() cancellationJob = null if (runningJob != null) { return } runningJob = scope.launch { val liveDataScope = LiveDataScopeImpl(liveData, coroutineContext) block(liveDataScope) onDone() } } @MainThread fun cancel() { if (cancellationJob != null) { error(&quot;Cancel call cannot happen without a maybeRun&quot;) } cancellationJob = scope.launch(Dispatchers.Main.immediate) { delay(timeoutInMs) if (!liveData.hasActiveObservers()) { // one last check on active observers to avoid any race condition between starting // a running coroutine and cancelation runningJob?.cancel() runningJob = null } } }} maybeRunå¾ˆç®€å•ï¼Œå°±æ˜¯åœ¨æŒ‡å®šçš„scopeä¸­å¯åŠ¨ä¸€ä¸ªåç¨‹ï¼Œæ‰§è¡Œblock cancelä¹Ÿå¾ˆç®€å•ï¼Œå°±æ˜¯åœ¨åç¨‹ä¸­å…ˆç­‰å¾…ä¸€æ®µæ—¶é—´ï¼Œç„¶ååˆ¤æ–­æ˜¯å¦æœ‰æ´»è·ƒçš„è§‚å¯Ÿè€…ï¼Œå¦‚æœæ²¡æœ‰ï¼Œåˆ™å–æ¶ˆrunningJob æˆ‘ä»¬è§‚å¯Ÿåˆ°blockæ˜¯LiveDataScopeçš„æ‰©å±•å‡½æ•°ï¼Œå¯¹åº”çš„å…·ä½“å®ç°ç±»æ˜¯LiveDataScopeImpl LiveDataScope12345678910111213141516171819202122232425262728293031323334353637public interface LiveDataScope&lt;T&gt; { /** * Set's the [LiveData]'s value to the given [value]. If you've called [emitSource] previously, * calling [emit] will remove that source. * * Note that this function suspends until the value is set on the [LiveData]. * * @param value The new value for the [LiveData] * * @see emitSource */ public suspend fun emit(value: T) /** * Add the given [LiveData] as a source, similar to [MediatorLiveData.addSource]. Calling this * method will remove any source that was yielded before via [emitSource]. * * @param source The [LiveData] instance whose values will be dispatched from the current * [LiveData]. * * @see emit * @see MediatorLiveData.addSource * @see MediatorLiveData.removeSource */ public suspend fun emitSource(source: LiveData&lt;T&gt;): DisposableHandle /** * References the current value of the [LiveData]. * * If the block never `emit`ed a value, [latestValue] will be `null`. You can use this * value to check what was then latest value `emit`ed by your `block` before it got cancelled. * * Note that if the block called [emitSource], then `latestValue` will be last value * dispatched by the `source` [LiveData]. */ public val latestValue: T?} å®šä¹‰äº†emitå‡½æ•°å’ŒemitSourceå‡½æ•° LiveDataScopeImpl1234567891011121314151617181920212223internal class LiveDataScopeImpl&lt;T&gt;( internal var target: CoroutineLiveData&lt;T&gt;, context: CoroutineContext) : LiveDataScope&lt;T&gt; { override val latestValue: T? get() = target.value // use `liveData` provided context + main dispatcher to communicate with the target // LiveData. This gives us main thread safety as well as cancellation cooperation private val coroutineContext = context + Dispatchers.Main.immediate override suspend fun emitSource(source: LiveData&lt;T&gt;): DisposableHandle = withContext(coroutineContext) { return@withContext target.emitSource(source) } @SuppressLint(&quot;NullSafeMutableLiveData&quot;) override suspend fun emit(value: T) = withContext(coroutineContext) { target.clearSource() target.value = value }} emitå‡½æ•°çš„å®ç°æ˜¯è°ƒç”¨CoroutineLiveDataçš„clearSource,å¹¶æ›´æ–°LiveDataå€¼ emitSourceçš„å®ç°æ˜¯åœ¨åç¨‹ä¸Šä¸‹æ–‡ä¸­æ‰§è¡ŒCoroutineLiveDataçš„emitSource CoroutineLiveDataçš„emitSource12345678910internal suspend fun clearSource() { emittedSource?.disposeNow() emittedSource = null}internal suspend fun emitSource(source: LiveData&lt;T&gt;): DisposableHandle { clearSource() val newSource = addDisposableSource(source) emittedSource = newSource return newSource} emitSourceé¦–å…ˆè°ƒç”¨clearSource å°†å·²å‘å°„çš„sourceè¿›è¡Œdispose åˆ›å»ºæ–°çš„emittedSource addDisposableSource1234567891011internal suspend fun &lt;T&gt; MediatorLiveData&lt;T&gt;.addDisposableSource( source: LiveData&lt;T&gt;): EmittedSource = withContext(Dispatchers.Main.immediate) { addSource(source) { value = it } EmittedSource( source = source, mediator = this@addDisposableSource )} CoroutineLiveDataæœ¬èº«å°±æ˜¯ä¸€ä¸ªMediatorLiveData addDisposableSourceæ—¶é¦–å…ˆé€šè¿‡addSourceä¸ºè‡ªèº«æ·»åŠ ä¸€ä¸ªsource åœ¨è¯¥sourceå˜åŒ–æ—¶ï¼Œæ›´æ–°è‡ªèº«çš„å€¼ åˆ›å»ºä¸€ä¸ªEmittedSourceï¼Œå¹¶è¿”å› CoroutineLiveDataçš„clearSource1234internal suspend fun clearSource() { emittedSource?.disposeNow() emittedSource = null} EmittedSource12345678910111213141516171819202122232425262728internal class EmittedSource( private val source: LiveData&lt;*&gt;, private val mediator: MediatorLiveData&lt;*&gt;) : DisposableHandle { // @MainThread private var disposed = false /** * Unlike [dispose] which cannot be sync because it not a coroutine (and we do not want to * lock), this version is a suspend function and does not return until source is removed. */ suspend fun disposeNow() = withContext(Dispatchers.Main.immediate) { removeSource() } override fun dispose() { CoroutineScope(Dispatchers.Main.immediate).launch { removeSource() } } @MainThread private fun removeSource() { if (!disposed) { mediator.removeSource(source) disposed = true } }} emittedSourceå°±æ˜¯ä¸ºäº†æ–¹ä¾¿disposeè€Œåˆ›å»ºçš„ï¼Œdisposeå°±æ˜¯æŠŠsourceç§»é™¤ åœ¨blockä¸­ï¼Œå¦‚æœæˆ‘ä»¬emitSourceäº†ï¼Œå¦‚æœåœ¨æœªæ¥æŸæ—¶åˆ»ï¼Œæˆ‘ä»¬ä¸å†éœ€è¦è¿™ä¸ªsourceäº†ï¼Œå¯ä»¥è°ƒç”¨emitSourceè¿”å›çš„EmittedSourceå¯¹è±¡çš„disposeæ–¹æ³•æ¥ç§»é™¤ emitå’ŒemitSourceå­˜åœ¨äº’æ–¥æ€§ï¼Œä½¿ç”¨emitåï¼Œä¹‹å‰çš„sourceå°±ä¼šå¤±æ•ˆ PublisherLiveData rxjavaå…¼å®¹çš„livedataï¼Œä½¿ç”¨rxjavaçš„Publisherä½œä¸ºæ•°æ®æº","link":"/home/2024/08/06/Android%E9%AB%98%E7%BA%A7/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E5%9F%BA%E7%A1%8004-LiveData/"},{"title":"åŸºç¡€02-viewModel","text":"ViewModelç®€ä»‹åœ¨äº†è§£ViewModelä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆæ¥äº†è§£ä¸€ä¸‹MVC, MVP, MVVMçš„å‘å±•Difference Between MVC, MVP and MVVM Architecture Pattern in Android ViewModelStoreOwner1234567interface ViewModelStoreOwner { /** * The owned [ViewModelStore] */ val viewModelStore: ViewModelStore} å®ç°äº†ViewModelStoreOwnerçš„ç±»ä¼šæœ‰ä¸€ä¸ªviewModelStoreå±æ€§ åœ¨åˆ›å»ºViewModelæ—¶ä¼šä¼ é€’è¿™ä¸ªå˜é‡ï¼Œå…·ä½“ä¼ é€’æ–¹å¼åœ¨è§by viewModels() å®ç°äº†ViewModelStoreOwnerçš„ç›´æ¥å­ç±»æœ‰ï¼š ComponentActivity, Fragment å’Œ NavBackStackEntry ViewModelStoreå®é™…ä¸Šå°±æ˜¯ç»´æŠ¤äº†ä¸€ä¸ªMutableMap&lt;String, ViewModel&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142open class ViewModelStore { private val map = mutableMapOf&lt;String, ViewModel&gt;() /** * @hide */ @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) fun put(key: String, viewModel: ViewModel) { val oldViewModel = map.put(key, viewModel) oldViewModel?.onCleared() } /** * Returns the `ViewModel` mapped to the given `key` or null if none exists. */ /** * @hide */ @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) operator fun get(key: String): ViewModel? { return map[key] } /** * @hide */ @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) fun keys(): Set&lt;String&gt; { return HashSet(map.keys) } /** * Clears internal storage and notifies `ViewModel`s that they are no longer used. */ fun clear() { for (vm in map.values) { vm.clear() } map.clear() }} å‘ç°å°±æ˜¯åœ¨å¯¹mapè¯»å†™ï¼Œæ³¨æ„åˆ°putæ–¹æ³•ä¼šè°ƒç”¨åŒkeyå€¼çš„æ—§ViewModelçš„onCleared onClearedå¹¶ä¸æ‰§è¡Œä»»ä½•æ“ä½œï¼Œæ˜¯æä¾›ç»™å­ç±»è¿›è¡Œå›æ”¶èµ„æºçš„å›è°ƒã€‚ViewModelçœŸæ­£è¿›è¡Œèµ„æºå›æ”¶ï¼ˆè°ƒç”¨Closeableçš„closeæ–¹æ³•ï¼‰çš„å‡½æ•°æ˜¯clearï¼Œputä¸­å¹¶æ²¡æœ‰è°ƒç”¨ï¼Œè¿™æ˜¯ä¸€ä¸ªå¾ˆå¥‡æ€ªçš„é—®é¢˜ï¼Œå…·ä½“çš„åŸå› åœ¨ä¸‹é¢ä¼šè§£é‡Š é‚£ä¹ˆè¿™ä¸ªkeyæ˜¯ä»€ä¹ˆå‘¢ï¼Œä¸‹é¢å†çœ‹å§ by viewModels()ComponentActivityçš„viewModels()12345678910111213141516@MainThreadpublic inline fun &lt;reified VM : ViewModel&gt; ComponentActivity.viewModels( noinline extrasProducer: (() -&gt; CreationExtras)? = null, noinline factoryProducer: (() -&gt; Factory)? = null): Lazy&lt;VM&gt; { val factoryPromise = factoryProducer ?: { defaultViewModelProviderFactory } return ViewModelLazy( VM::class, { viewModelStore }, // 1ï¸âƒ£ viewModelStoreçš„ä¼ é€’åœ¨è¿™é‡Œ factoryPromise, { extrasProducer?.invoke() ?: this.defaultViewModelCreationExtras } )} å¯ä»¥çœ‹åˆ°viewModels()å®é™…ä¸Šæ˜¯ComponentActivityçš„ä¸€ä¸ªæ‰©å±•æ–¹æ³•ï¼Œè¿”å›äº†ViewModelLazyå¯¹ViewModelçš„å±æ€§è¿›è¡Œä»£ç† ViewModelLazy12345678910111213141516171819202122232425262728public class ViewModelLazy&lt;VM : ViewModel&gt; @JvmOverloads constructor( private val viewModelClass: KClass&lt;VM&gt;, private val storeProducer: () -&gt; ViewModelStore, private val factoryProducer: () -&gt; ViewModelProvider.Factory, private val extrasProducer: () -&gt; CreationExtras = { CreationExtras.Empty }) : Lazy&lt;VM&gt; { private var cached: VM? = null override val value: VM get() { val viewModel = cached return if (viewModel == null) { val factory = factoryProducer() val store = storeProducer() ViewModelProvider( store, factory, extrasProducer() ).get(viewModelClass.java).also { cached = it } } else { viewModel } } override fun isInitialized(): Boolean = cached != null} å¯ä»¥çœ‹åˆ°å½“å±æ€§é¦–æ¬¡getæ—¶ä¼šæ„é€ ViewModelProviderå¹¶è°ƒç”¨getæ–¹æ³•è·å–viewModelå¯¹è±¡ ViewModelProviderViewModelProviderçš„getæ–¹æ³•12345678910111213141516171819202122232425262728@MainThreadpublic open operator fun &lt;T : ViewModel&gt; get(modelClass: Class&lt;T&gt;): T { val canonicalName = modelClass.canonicalName ?: throw IllegalArgumentException(&quot;Local and anonymous classes can not be ViewModels&quot;) return get(&quot;$DEFAULT_KEY:$canonicalName&quot;, modelClass)}public open operator fun &lt;T : ViewModel&gt; get(key: String, modelClass: Class&lt;T&gt;): T { val viewModel = store[key] // 1ï¸âƒ£ ä»storeä¸­å–viewModel if (modelClass.isInstance(viewModel)) { // 2ï¸âƒ£ åˆ¤æ–­åˆæ³•æ€§ (factory as? OnRequeryFactory)?.onRequery(viewModel!!) return viewModel as T } else { @Suppress(&quot;ControlFlowWithEmptyBody&quot;) if (viewModel != null) { // TODO: log a warning. } } val extras = MutableCreationExtras(defaultCreationExtras) extras[VIEW_MODEL_KEY] = key // AGP has some desugaring issues associated with compileOnly dependencies so we need to // fall back to the other create method to keep from crashing. return try { factory.create(modelClass, extras) // 3ï¸âƒ£ é€šè¿‡factoryåˆ›å»ºViewModel } catch (e: AbstractMethodError) { // 3ï¸âƒ£ é€šè¿‡factoryåˆ›å»ºViewModel factory.create(modelClass) }.also { store.put(key, it) } // 4ï¸âƒ£ å­˜å…¥store} 1ï¸âƒ£ ä»storeä¸­å–viewModelï¼Œè¿™ä¸ªstoreå°±æ˜¯ä¸Šé¢æåˆ°çš„ViewModelStore, è¿™é‡Œå¯ä»¥çœ‹åˆ°å…¶keyå°±æ˜¯ç±»å 2ï¸âƒ£ åˆ¤æ–­åˆæ³•æ€§ï¼ŒisInstanceå‡½æ•°é¦–å…ˆåˆ¤ç©ºï¼Œå…¶æ¬¡åˆ¤æ–­æ˜¯å¦ä¸ºå¯¹åº”çš„ç±»å‹ï¼Œè¿™ä¸€æ­¥çš„åˆ¤ç©ºæ˜¯ä¸ºäº†åˆ¤æ–­æ˜¯å¦éœ€è¦æ„é€ ViewModelå®ä¾‹ï¼Œé¿å…è¿”å›ç©ºï¼›è¿™ä¸€æ­¥çš„åˆ¤æ–­ç±»å‹åˆ™æ˜¯ä¸ºäº†æé«˜å®‰å…¨æ€§ï¼Œè¿”å›æ—¶å¼ºè½¬ä¸ä¼šå¼ºè½¬å¤±è´¥ 3ï¸âƒ£ é€šè¿‡factoryåˆ›å»ºï¼Œè¿™ä¸€æ­¥æ˜¾è€Œæ˜“è§ï¼Œåˆ›å»ºæ–°çš„å®ä¾‹ã€‚è¿™é‡Œçš„factoryé»˜è®¤å€¼æ˜¯é€šè¿‡ComponentActivityæ„é€ çš„SavedStateViewModelFactory 4ï¸âƒ£ å­˜å…¥storeï¼Œåœ¨åˆ›å»ºåå­˜å…¥storeä¸­ A: ViewModelStore.put()é—®é¢˜ è¿™é‡Œå¯ä»¥æ¨æµ‹ï¼Œå¦‚æœåŒä¸€ä¸ªViewModelStoreOwnerä¸­å£°æ˜äº†å¤šä¸ªåŒç±»å‹çš„ViewModelï¼Œæ ¹æ®2ï¸âƒ£çš„åˆ¤æ–­ï¼Œä»–ä»¬ä¼šæ˜¯åŒä¸€ä¸ªå®ä¾‹ã€‚ViewModelStore.putæ—¶ä¸€èˆ¬ä¸ä¼šå­˜åœ¨åŒkeyå€¼çš„ViewModelå¯¹è±¡ï¼Œæ‰€ä»¥é‚£é‡Œæ˜¯å¦è°ƒç”¨clearè¿›è¡Œèµ„æºå›æ”¶ä¹Ÿå°±ä¸æ˜¯å¾ˆé‡è¦äº†ã€‚ ViewModelViewModelç±»å®é™…ä¸Šä¸æ˜¯å®é™…å®ç°ï¼ŒæŒæœ‰ViewModelImplçš„å®ä¾‹ï¼Œå¯¹å…¶æ–¹æ³•è¿›è¡Œä»£ç† ç±»å®šä¹‰1public actual abstract class ViewModel å‡ ä¸ªæ³¨æ„çš„ç‚¹ï¼š actual: ä»‹ç»çœ‹è¿™é‡Œ, å¤§æ¦‚æ˜¯å’Œè·¨ç«¯ç›¸å…³çš„ã€‚ abstract clearæ–¹æ³•1234567protected actual open fun onCleared() {}@MainThreadinternal actual fun clear() { impl?.clear() onCleared()} è¿™é‡Œå¯ä»¥çœ‹åˆ°ç¨æœ‰ä¸åŒçš„æ˜¯ï¼Œé™¤äº†ä»£ç†è°ƒç”¨ViewModelImplçš„clearæ–¹æ³•ï¼Œè¿˜è°ƒç”¨äº†é’©å­æ–¹æ³•onCleared å¦å¤–å¾ˆæœ‰è¶£çš„æ˜¯ViewModelImplå’ŒViewModelå¹¶æ²¡æœ‰ç»§æ‰¿å…³ç³»ï¼Œä¹Ÿæ²¡æœ‰ç»§æ‰¿ç›¸åŒçš„æ¥å£ ViewModelImplå…³é”®çš„å±æ€§123456private val keyToCloseables = mutableMapOf&lt;String, AutoCloseable&gt;()/** * @see [keyToCloseables] */private val closeables = mutableSetOf&lt;AutoCloseable&gt;() å¯ä»¥çœ‹åˆ°ç»´æŠ¤äº†ä¸€ä¸ªmapå’Œä¸€ä¸ªsetï¼Œä¿å­˜AutoCloseable addCloseable12345678910111213141516171819202122232425fun addCloseable(key: String, closeable: AutoCloseable) { // Although no logic should be done after user calls onCleared(), we will // ensure that if it has already been called, the closeable attempting to // be added will be closed immediately to ensure there will be no leaks. if (isCleared) { closeWithRuntimeException(closeable) return } val oldCloseable = synchronized(lock) { keyToCloseables.put(key, closeable) } closeWithRuntimeException(oldCloseable)}/** @see [ViewModel.addCloseable] */fun addCloseable(closeable: AutoCloseable) { // Although no logic should be done after user calls onCleared(), we will // ensure that if it has already been called, the closeable attempting to // be added will be closed immediately to ensure there will be no leaks. if (isCleared) { closeWithRuntimeException(closeable) return } synchronized(lock) { closeables += closeable }} å¯ä»¥çœ‹åˆ°ä¸¤ä¸ªå‡½æ•°ï¼Œä¸€ä¸ªæ˜¯æ·»åŠ åˆ°mapä¸­ï¼Œä¸€ä¸ªæ˜¯æ·»åŠ åˆ°setä¸­ å¦‚æœå½“å‰ViewModelå·²ç»è¢«clearäº†ï¼Œé‚£ä¹ˆä¼šè°ƒç”¨closeWithRuntimeExceptionï¼Œè¿™ä¸ªæ–¹æ³•ä¼šè°ƒç”¨å…¶closeæ–¹æ³•ï¼Œå¹¶å°†closeæ—¶å‡ºç°çš„å¼‚å¸¸è½¬æ¢ä¸ºRuntimeExceptionæŠ›å‡º å¦‚æœmapä¸­æœ‰åŒkeyå€¼çš„closeableï¼Œé‚£ä¹ˆä¹Ÿä¼šè°ƒç”¨closeWithRuntimeExceptionå°†å…¶å…³é—­ è¿™ä¸¤ä¸ªå‡½æ•°ä¹Ÿå¯ä»¥æä¾›ç»™ç”¨æˆ·ä½¿ç”¨ æ„é€ æ–¹æ³•1234567891011121314constructor()constructor(viewModelScope: CoroutineScope) { addCloseable(VIEW_MODEL_SCOPE_KEY, viewModelScope.asCloseable())}constructor(vararg closeables: AutoCloseable) { this.closeables += closeables}constructor(viewModelScope: CoroutineScope, vararg closeables: AutoCloseable) { addCloseable(VIEW_MODEL_SCOPE_KEY, viewModelScope.asCloseable()) this.closeables += closeables} å¯ä»¥çœ‹åˆ°ï¼Œåªå…è®¸ä¼ é€’ä¸€ä¸ªCoroutineScopeï¼Œä¼šå°†å…¶è½¬åŒ–ä¸ºcloseableï¼Œå­˜åˆ°mapä¸­ çœ‹ä¸Šå»åªå…è®¸ä¼ é€’ä¸€ä¸ªCoroutineScopeï¼Œä½†æ˜¯è¿˜æ˜¯å¯ä»¥é€šè¿‡ç›¸åŒçš„æ–¹æ³•ä¼ é€’å¤šä¸ªç”¨CloseableCoroutineScopeåŒ…è£…è¿‡çš„Scopeå¯¹è±¡ è¿™ä¸ªæ„é€ å…è®¸ä¼ é€’ä¸€ä¸ªCoroutineScopeå®Œå…¨æ˜¯ä¸ºäº†å°†å…¶è½¬åŒ–ä¸ºCloseableå¯¹è±¡ï¼Œæ²¡æœ‰åˆ«çš„æ„ä¹‰ï¼Œæ„Ÿè§‰å¾ˆå¤šä½™ã€‚ clear1234567891011121314151617@MainThreadfun clear() { if (isCleared) return // 1ï¸âƒ£ isCleared = true // 2ï¸âƒ£ synchronized(lock) { for (closeable in keyToCloseables.values) { closeWithRuntimeException(closeable) } for (closeable in closeables) { closeWithRuntimeException(closeable) } // Clear only resources without keys to prevent accidental recreation of resources. // For example, `viewModelScope` would be recreated leading to unexpected behaviour. closeables.clear() }} @MainThreadæ ‡æ˜è¯¥æ–¹æ³•åº”è¯¥è¢«åœ¨ä¸»çº¿ç¨‹è°ƒç”¨ æ–¹æ³•å…¶å®å°±æ˜¯æŠŠæ‰€æœ‰closeableå…³æ‰ï¼Œå†æŠŠsetæ¸…ç©ºï¼Œä½†æ˜¯mapå´æ²¡æœ‰æ¸…ç©ºï¼Ÿ å¯ä»¥çœ‹åˆ°1ï¸âƒ£å’Œ2ï¸âƒ£å¹¶ä¸æ˜¯åŸå­çš„ï¼Œå¦‚æœclearè¢«å¤šä¸ªçº¿ç¨‹åŒæ—¶è°ƒç”¨ï¼Œæœ‰å¯èƒ½å­˜åœ¨mapé‡Œçš„closeableè¢«closeä¸¤æ¬¡çš„æƒ…å†µã€‚ SavedStateViewModelFactorycreateæ–¹æ³•12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;, extras: CreationExtras): T { // 1ï¸âƒ£ val key = extras[ViewModelProvider.NewInstanceFactory.VIEW_MODEL_KEY] ?: throw IllegalStateException( &quot;VIEW_MODEL_KEY must always be provided by ViewModelProvider&quot; ) return if (extras[SAVED_STATE_REGISTRY_OWNER_KEY] != null &amp;&amp; extras[VIEW_MODEL_STORE_OWNER_KEY] != null) { val application = extras[ViewModelProvider.AndroidViewModelFactory.APPLICATION_KEY] val isAndroidViewModel = AndroidViewModel::class.java.isAssignableFrom(modelClass) val constructor: Constructor&lt;T&gt;? = if (isAndroidViewModel &amp;&amp; application != null) { findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE) } else { findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE) } // doesn't need SavedStateHandle if (constructor == null) { return factory.create(modelClass, extras) } val viewModel = if (isAndroidViewModel &amp;&amp; application != null) { newInstance(modelClass, constructor, application, extras.createSavedStateHandle()) } else { newInstance(modelClass, constructor, extras.createSavedStateHandle()) } viewModel } else { val viewModel = if (lifecycle != null) { create(key, modelClass) } else { throw IllegalStateException(&quot;SAVED_STATE_REGISTRY_OWNER_KEY and&quot; + &quot;VIEW_MODEL_STORE_OWNER_KEY must be provided in the creation extras to&quot; + &quot;successfully create a ViewModel.&quot;) } viewModel }}/** * Creates a new instance of the given `Class`. * * @param key a key associated with the requested ViewModel * @param modelClass a `Class` whose instance is requested * @return a newly created ViewModel * * @throws UnsupportedOperationException if the there is no lifecycle */fun &lt;T : ViewModel&gt; create(key: String, modelClass: Class&lt;T&gt;): T { // 2ï¸âƒ£ // empty constructor was called. val lifecycle = lifecycle ?: throw UnsupportedOperationException( &quot;SavedStateViewModelFactory constructed with empty constructor supports only &quot; + &quot;calls to create(modelClass: Class&lt;T&gt;, extras: CreationExtras).&quot; ) val isAndroidViewModel = AndroidViewModel::class.java.isAssignableFrom(modelClass) val constructor: Constructor&lt;T&gt;? = if (isAndroidViewModel &amp;&amp; application != null) { findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE) } else { findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE) } // doesn't need SavedStateHandle constructor ?: // If you are using a stateful constructor and no application is available, we // use an instance factory instead. return if (application != null) factory.create(modelClass) else instance.create(modelClass) val controller = LegacySavedStateHandleController.create( savedStateRegistry!!, lifecycle, key, defaultArgs ) val viewModel: T = if (isAndroidViewModel &amp;&amp; application != null) { newInstance(modelClass, constructor, application!!, controller.handle) } else { newInstance(modelClass, constructor, controller.handle) } viewModel.setTagIfAbsent( AbstractSavedStateViewModelFactory.TAG_SAVED_STATE_HANDLE_CONTROLLER, controller ) return viewModel} 1ï¸âƒ£å’Œ2ï¸âƒ£å¤§ä½“æµç¨‹ä¸Šéƒ½æ˜¯è·å–æ„é€ å‡½æ•°ï¼Œåˆ›å»ºå®ä¾‹å¯¹è±¡ åŒºåˆ«åœ¨äºnewInstanceçš„ç¬¬å››ä¸ªå‚æ•°ä¸åŒï¼Œä¸€ä¸ªé€šè¿‡extrasè·å–ï¼Œä¸€ä¸ªé€šè¿‡LegacySavedStateHandleControllerè·å¾—ï¼Œçœ‹èµ·æ¥å¾ˆå¤æ‚ï¼Œä½†æ˜¯çœ‹ä¸€ä¸‹è¿™ä¸ªnewInstanceçš„å®ç°å°±ä¼šå‘ç°ï¼Œç¬¬å››ä¸ªå‚æ•°å®é™…ä¸Šå°±æ˜¯æ„é€ å‡½æ•°çš„å‚æ•° 1234567891011121314151617internal fun &lt;T : ViewModel?&gt; newInstance( modelClass: Class&lt;T&gt;, constructor: Constructor&lt;T&gt;, vararg params: Any): T { return try { constructor.newInstance(*params) } catch (e: IllegalAccessException) { throw RuntimeException(&quot;Failed to access $modelClass&quot;, e) } catch (e: InstantiationException) { throw RuntimeException(&quot;A $modelClass cannot be instantiated.&quot;, e) } catch (e: InvocationTargetException) { throw RuntimeException( &quot;An exception happened in constructor of $modelClass&quot;, e.cause ) }} viewModelStoreä½•æ—¶è¢«clearåœ¨ComponentActivtyçš„åˆå§‹åŒ–æ—¶ï¼Œä¼šçœ‹åˆ°ä¸‹é¢è¿™æ®µä»£ç  1234567891011lifecycle.addObserver(LifecycleEventObserver { _, event -&gt; if (event == Lifecycle.Event.ON_DESTROY) { // Clear out the available context contextAwareHelper.clearAvailableContext() // And clear the ViewModelStore if (!isChangingConfigurations) { viewModelStore.clear() } reportFullyDrawnExecutor.activityDestroyed() }}) å¦‚æœActivityç”Ÿå‘½å‘¨æœŸåˆ°äº†ON_DESTROYï¼Œä¸”ä¸æ˜¯å¤œé—´æ¨¡å¼æ”¹å˜ç­‰æƒ…å†µï¼Œå°±ä¼šå°†viewModelæ¸…ç©ºï¼Œåšåˆ°äº†ç•Œé¢å’Œæ•°æ®åˆ†ç¦»ã€‚ CoroutineScopeæ˜¯å¦‚ä½•å˜æˆCloseableçš„1234567891011121314internal fun CoroutineScope.asCloseable() = CloseableCoroutineScope(coroutineScope = this)/** * [CoroutineScope] that provides a method to [close] it, causing the rejection of any new tasks and * cleanup of all underlying resources associated with the scope. */internal class CloseableCoroutineScope( override val coroutineContext: CoroutineContext,) : AutoCloseable, CoroutineScope { constructor(coroutineScope: CoroutineScope) : this(coroutineScope.coroutineContext) override fun close() = coroutineContext.cancel()} CloseableCoroutineScopeå®ç°äº†AutoCloseable, åœ¨closeæ–¹æ³•ä¸­å°†åç¨‹cancelæ‰ CreationExtrasåœ¨SavedStateViewModelFactoryçš„createæ–¹æ³•ä¸­ï¼Œå¯ä»¥çœ‹åˆ°factoryä¼šæ‹¿åˆ°ä¸€ä¸ªCreationExtrasåœ¨by viewModels()æ—¶ï¼Œä¼šä¼ é€’ä¸€ä¸ªæ„é€ CreationExtrasçš„å‡½æ•°ï¼Œå¦‚æœæ²¡æä¾›ï¼Œå°±ä½¿ç”¨é»˜è®¤ComponentActivityæä¾›çš„defaultViewModelCreationExtras é»˜è®¤çš„CreationExtras123456789101112131415161718192021override val defaultViewModelCreationExtras: CreationExtras /** * {@inheritDoc} * * The extras of [getIntent] when this is first called will be used as * the defaults to any [androidx.lifecycle.SavedStateHandle] passed to a view model * created using this extra. */ get() { val extras = MutableCreationExtras() if (application != null) { extras[APPLICATION_KEY] = application } extras[SAVED_STATE_REGISTRY_OWNER_KEY] = this extras[VIEW_MODEL_STORE_OWNER_KEY] = this val intentExtras = intent?.extras if (intentExtras != null) { extras[DEFAULT_ARGS_KEY] = intentExtras } return extras } å¯ä»¥çœ‹åˆ°é‡Œé¢å­˜äº†å½“å‰çš„Applicationå¯¹è±¡ï¼Œè¿˜æœ‰ä¸¤ä¸ªthisï¼Œè¿˜ä¼šå°†intent.extraæ”¾è¿›å» MutableCreationExtraså…¶å®ä¹Ÿæ˜¯ç»´æŠ¤äº†ä¸€ä¸ªmap ç»™ViewModelä¼ å‚ å‰é¢æåˆ°æˆ‘ä»¬å¯ä»¥æŒ‡å®šFactoryå’ŒCreationExtras å¯ä»¥è‡ªå·±ç¼–å†™Factoryï¼Œä»CreationExtrasä¸­è·å–å‚æ•°ï¼Œä¸‹é¢æ˜¯ç¤ºä¾‹ä»£ç 12345678910111213141516class MainViewModel( private val coroutineScope: CoroutineScope = CloseableCoroutineScope(), param1: String, param2: Int) : ViewModel(coroutineScope) { companion object { override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;, extras: CreationExtras): T { val param1 = extras[MY_PARAM_KEY1]!! val param2 = extras[MY_PARAM_KEY2]!! return MainViewModel(param1 = param1, param2 = param2) as T } val MY_PARAM_KEY1 = object : CreationExtras.Key&lt;String&gt; {} val MY_PARAM_KEY2 = object : CreationExtras.Key&lt;Int&gt; {} }} 12345678910class MyActivity : AppCompatActivity() { private val viewModel : MainViewModel by viewModels({ return@viewModels MutableCreationExtras().apply { set(MainViewModel.MY_PARAM_KEY1, &quot;1&quot;) set(MainViewModel.MY_PARAM_KEY2, 2) } }){ return@viewModels MainViewModel.Factory }} Fragment.viewModels1234567891011121314151617181920@MainThreadpublic inline fun &lt;reified VM : ViewModel&gt; Fragment.viewModels( noinline ownerProducer: () -&gt; ViewModelStoreOwner = { this }, noinline extrasProducer: (() -&gt; CreationExtras)? = null, noinline factoryProducer: (() -&gt; Factory)? = null): Lazy&lt;VM&gt; { val owner by lazy(LazyThreadSafetyMode.NONE) { ownerProducer() } return createViewModelLazy( VM::class, { owner.viewModelStore }, { extrasProducer?.invoke() ?: (owner as? HasDefaultViewModelProviderFactory)?.defaultViewModelCreationExtras ?: CreationExtras.Empty }, factoryProducer ?: { (owner as? HasDefaultViewModelProviderFactory)?.defaultViewModelProviderFactory ?: defaultViewModelProviderFactory })} æ”¯æŒåˆ›å»º/è·å–å…¶ä»–ownerçš„ViewModel å’ŒComponentActivityä¸€æ ·ï¼ŒcreateViewModelLazyçš„è¿”å›çš„ä¹Ÿæ˜¯ViewModelLazyç±» Fragment.activityViewModels12345678910@MainThreadpublic inline fun &lt;reified VM : ViewModel&gt; Fragment.activityViewModels( noinline extrasProducer: (() -&gt; CreationExtras)? = null, noinline factoryProducer: (() -&gt; Factory)? = null): Lazy&lt;VM&gt; = createViewModelLazy( VM::class, { requireActivity().viewModelStore }, { extrasProducer?.invoke() ?: requireActivity().defaultViewModelCreationExtras }, factoryProducer ?: { requireActivity().defaultViewModelProviderFactory }) è·å–activityçš„viewModelStore è·å–çˆ¶fragmentçš„viewModel1val parentFragmentViewModel:XXXViewModel by viewModels(ownerProducer = { requireParentFragment() }) navigationå›¾çš„viewModel12val naviViewModel : MainViewModel by navGraphViewModels(R.id.xxx)val naviViewModel1 : MainViewModel by viewModels(ownerProducer = { findNavController().getBackStackEntry(R.id.xxx) }) 123456789101112131415161718@MainThreadpublic inline fun &lt;reified VM : ViewModel&gt; Fragment.navGraphViewModels( @IdRes navGraphId: Int, noinline extrasProducer: (() -&gt; CreationExtras)? = null, noinline factoryProducer: (() -&gt; ViewModelProvider.Factory)? = null): Lazy&lt;VM&gt; { val backStackEntry by lazy { findNavController().getBackStackEntry(navGraphId) } val storeProducer: () -&gt; ViewModelStore = { backStackEntry.viewModelStore } return createViewModelLazy( VM::class, storeProducer, { extrasProducer?.invoke() ?: backStackEntry.defaultViewModelCreationExtras }, factoryProducer ?: { backStackEntry.defaultViewModelProviderFactory } )} navGraphViewModelså…¶å®å°±æ˜¯è°ƒç”¨äº†findNavController().getBackStackEntry(navGraphId)ï¼Œç„¶åè·å–å…¶viewModelStore élazyè·å–çš„viewModel12345val viewModel = ViewModelProvider(this.viewModelStore, ViewModelProvider.NewInstanceFactory.instance)[MainViewModel::class.java]val viewModel = ViewModelProvider(this.viewModelStore, MainViewModel.Factory, MutableCreationExtras().apply { set(MainViewModel.MY_PARAM_KEY1, &quot;1&quot;) set(MainViewModel.MY_PARAM_KEY2, 2)})[MainViewModel::class.java] Composeè·å–viewModel1234567@Composablefun Greeting(string: String, modifier: Modifier = Modifier, vm : MainViewModel = viewModel()) { Text( text = string, modifier = modifier )} 12345678910111213@Composablepublic inline fun &lt;reified VM : ViewModel&gt; viewModel( viewModelStoreOwner: ViewModelStoreOwner = checkNotNull(LocalViewModelStoreOwner.current) { &quot;No ViewModelStoreOwner was provided via LocalViewModelStoreOwner&quot; }, key: String? = null, factory: ViewModelProvider.Factory? = null, extras: CreationExtras = if (viewModelStoreOwner is HasDefaultViewModelProviderFactory) { viewModelStoreOwner.defaultViewModelCreationExtras } else { CreationExtras.Empty }): VM = viewModel(VM::class, viewModelStoreOwner, key, factory, extras) 123456789101112131415@Suppress(&quot;MissingJvmstatic&quot;)@Composablepublic fun &lt;VM : ViewModel&gt; viewModel( modelClass: KClass&lt;VM&gt;, viewModelStoreOwner: ViewModelStoreOwner = checkNotNull(LocalViewModelStoreOwner.current) { &quot;No ViewModelStoreOwner was provided via LocalViewModelStoreOwner&quot; }, key: String? = null, factory: ViewModelProvider.Factory? = null, extras: CreationExtras = if (viewModelStoreOwner is HasDefaultViewModelProviderFactory) { viewModelStoreOwner.defaultViewModelCreationExtras } else { CreationExtras.Empty }): VM = viewModelStoreOwner.get(modelClass, key, factory, extras) 1234567891011121314151617181920212223internal fun &lt;VM : ViewModel&gt; ViewModelStoreOwner.get( modelClass: KClass&lt;VM&gt;, key: String? = null, factory: ViewModelProvider.Factory? = null, extras: CreationExtras = if (this is HasDefaultViewModelProviderFactory) { this.defaultViewModelCreationExtras } else { CreationExtras.Empty }): VM { val provider = if (factory != null) { ViewModelProvider.create(this.viewModelStore, factory, extras) } else if (this is HasDefaultViewModelProviderFactory) { ViewModelProvider.create(this.viewModelStore, this.defaultViewModelProviderFactory, extras) } else { ViewModelProvider.create(this) } return if (key != null) { provider[key, modelClass] } else { provider[modelClass] }} 12345678910111213141516interface HasDefaultViewModelProviderFactory { /** * Returns the default [ViewModelProvider.Factory] that should be * used when no custom `Factory` is provided to the * [ViewModelProvider] constructors. */ val defaultViewModelProviderFactory: ViewModelProvider.Factory /** * Returns the default [CreationExtras] that should be passed into * [ViewModelProvider.Factory.create] when no overriding * [CreationExtras] were passed to the [ViewModelProvider] constructors. */ val defaultViewModelCreationExtras: CreationExtras get() = CreationExtras.Empty} storeæ¥è‡ªLocalViewModelStoreOwner.current factoryå’Œextrasæ¥è‡ªHasDefaultViewModelProviderFactory å¤‡å¿˜å•","link":"/home/2024/07/31/Android%E9%AB%98%E7%BA%A7/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E5%9F%BA%E7%A1%8002-viewModel/"},{"title":"fabric-1.fabricç¯å¢ƒé…ç½®ä¸æ­å»º","text":"å‚è€ƒæ–‡æ¡£-getting start å‡†å¤‡å·¥ä½œ éœ€è¦å®‰è£…gitï¼Œcurlï¼Œdockerï¼Œdocker compose1sudo apt install docker-compose ç»™å½“å‰ç”¨æˆ·è¿è¡Œdockerçš„æƒé™12345678## åˆ›å»ºdockerç»„sudo groupadd docker## å°†å½“å‰ç”¨æˆ·åŠ å…¥dockerç»„sudo usermod -aG docker tt## é‡å¯æœåŠ¡sudo service docker restart## åˆ·æ–°dockeræˆå‘˜newgrp docker goç¯å¢ƒçš„å®‰è£…12345678910wget https://golang.google.cn/dl/go1.19.linux-amd64.tar.gztar -zxvf go1.19.linux-amd64.tar.gzsudo mv go /usr/local/sudo tee -a ~/.bachrc &lt;&lt;-'EOF'export GOROOT=/usr/local/go## export GOPATH=/home/go/goProjectexport GOPROXY=https://goproxy.cnexport PATH=$PATH:$GOROOT/binEOFsource /etc/profile fabricçš„å®‰è£… fabricæä¾›äº†ä¸€ä¸ªè„šæœ¬ï¼Œç”¨äºå®‰è£…äºŒè¿›åˆ¶æ–‡ä»¶å’Œé•œåƒ12345## å®‰è£…æœ€æ–°ç‰ˆæœ¬curl -sSL https://bit.ly/2ysbOFE | bash -s## å®‰è£…æŒ‡å®šç‰ˆæœ¬curl -sSL https://bit.ly/2ysbOFE | bash -s -- &lt;fabric_version&gt; &lt;fabric-ca_version&gt;curl -sSL https://bit.ly/2ysbOFE | bash -s -- 2.2.8 1.5.3 é—®é¢˜1â€“dockeræƒé™ æˆ‘çš„ç¯å¢ƒä¸­docker pullå¿…é¡»ä½¿ç”¨sudoï¼Œè€Œcurlå¹¶ä¸æ¨èä½¿ç”¨sudo è§£å†³æ–¹æ¡ˆï¼šå…ˆä¸‹è½½scriptï¼Œå¹¶ä¿®æ”¹ï¼Œå°†ç¬¬14è¡ŒCONTAINER_CLIä¿®æ”¹ä¸ºsudo docker123curl -sSL https://bit.ly/2ysbOFE -o script.shchmod +x script.shvim script.sh 1: ${CONTAINER_CLI:=&quot;docker&quot;} ## æ”¹ä¸ºsudo docker è§£å†³æ–¹æ¡ˆ2ï¼šé‡æ–°å®‰è£…dockerï¼Œå‘ç°è„šæœ¬ç»“æŸåï¼Œæœ‰å…rootè¿è¡Œçš„è„šæœ¬ é—®é¢˜2â€“pullç¼“æ…¢ æ›´æ¢é•œåƒ123456789101112131415sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'{ &quot;registry-mirrors&quot; : [ &quot;https://registry.docker-cn.com&quot;, &quot;http://hub-mirror.c.163.com&quot;, &quot;https://docker.mirrors.ustc.edu.cn&quot;, &quot;https://cr.console.aliyun.com&quot;, &quot;https://mirror.ccs.tencentyun.com&quot; ]}EOFsudo systemctl daemon-reloadsudo systemctl restart dockersudo docker info éƒ¨ç½²ä¸€ä¸ªæµ‹è¯•ç½‘ç»œ å‚è€ƒæ–‡æ¡£-Using the Fabric test network test-networkåœ¨fabric-samples/test-networkä¸‹ æŸ¥çœ‹å¸®åŠ©æ–‡æœ¬1./network.sh -h 12345678910111213141516171819202122232425262728293031323334353637383940414243Using docker and docker-composeUsage: network.sh &lt;Mode&gt; [Flags] Modes: up - Bring up Fabric orderer and peer nodes. No channel is created up createChannel - Bring up fabric network with one channel createChannel - Create and join a channel after the network is created deployCC - Deploy a chaincode to a channel (defaults to asset-transfer-basic) down - Bring down the network Flags: Used with network.sh up, network.sh createChannel: -ca &lt;use CAs&gt; - Use Certificate Authorities to generate network crypto material -c &lt;channel name&gt; - Name of channel to create (defaults to &quot;mychannel&quot;) -s &lt;dbtype&gt; - Peer state database to deploy: goleveldb (default) or couchdb -r &lt;max retry&gt; - CLI times out after certain number of attempts (defaults to 5) -d &lt;delay&gt; - CLI delays for a certain number of seconds (defaults to 3) -verbose - Verbose mode Used with network.sh deployCC -c &lt;channel name&gt; - Name of channel to deploy chaincode to -ccn &lt;name&gt; - Chaincode name. -ccl &lt;language&gt; - Programming language of the chaincode to deploy: go, java, javascript, typescript -ccv &lt;version&gt; - Chaincode version. 1.0 (default), v2, version3.x, etc -ccs &lt;sequence&gt; - Chaincode definition sequence. Must be an integer, 1 (default), 2, 3, etc -ccp &lt;path&gt; - File path to the chaincode. -ccep &lt;policy&gt; - (Optional) Chaincode endorsement policy using signature policy syntax. The default policy requires an endorsement from Org1 and Org2 -cccg &lt;collection-config&gt; - (Optional) File path to private data collections configuration file -cci &lt;fcn name&gt; - (Optional) Name of chaincode initialization function. When a function is provided, the execution of init will be requested and the function will be invoked. -h - Print this message Possible Mode and flag combinations up -ca -r -d -s -verbose up createChannel -ca -c -r -d -s -verbose createChannel -c -r -d -verbose deployCC -ccn -ccl -ccv -ccs -ccp -cci -r -d -verbose Examples: network.sh up createChannel -ca -c mychannel -s couchdb network.sh createChannel -c channelName network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-javascript/ -ccl javascript network.sh deployCC -ccn mychaincode -ccp ./user/mychaincode -ccv 1 -ccl javascript å¯åŠ¨æµ‹è¯•ç½‘ç»œ1./network.sh up åˆ›å»ºChannel channelæ˜¯ç‰¹å®šç½‘ç»œæˆå‘˜ä¹‹é—´ç§æœ‰é€šä¿¡å±‚ï¼Œchannelåªèƒ½ç”±é‚€è¯·åŠ å…¥è¯¥channelçš„ç»„ç»‡ä½¿ç”¨ï¼Œå¹¶ä¸”å¯¹ç½‘ç»œä¸­çš„å…¶ä»–æˆå‘˜æ˜¯ä¸å¯è§çš„ã€‚ æ¯ä¸ªchanneléƒ½æœ‰ä¸€ä¸ªç‹¬ç«‹çš„åŒºå—é“¾è´¦æœ¬ã€‚è¢«é‚€è¯·â€œåŠ å…¥â€å…¶åŒè¡Œçš„ç»„ç»‡åˆ°channelæ¥å­˜å‚¨channelè´¦æœ¬å¹¶éªŒè¯channelä¸Šçš„äº¤æ˜“ã€‚1./network.sh createChannel -c channel1 è¿è¡Œæ™ºèƒ½åˆçº¦ åœ¨fabricä¸­ï¼Œæ™ºèƒ½åˆçº¦æ˜¯chainCode Chaincodeå®‰è£…åœ¨ç»„ç»‡çš„å¯¹ç­‰ç«¯ï¼Œç„¶åéƒ¨ç½²åˆ°ä¸€ä¸ªé€šé“ï¼Œç„¶åå¯ä»¥ä½¿ç”¨å®ƒæ¥æ‰¹å‡†äº¤æ˜“ï¼Œå¹¶ä¸åŒºå—é“¾è´¦æœ¬äº¤äº’ã€‚ 1./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-go -ccl go è¿™é‡Œä½¿ç”¨äº†goè¯­è¨€çš„ç¯å¢ƒ -cclæŒ‡å®šäº†å®‰è£…é“¾ç çš„è¯­è¨€ï¼Œgo/typescript/javascript -ccpæŒ‡å®šäº†chainCode é”€æ¯ç½‘ç»œ1./network.sh down æ€»ç»“ æµ‹è¯•æ—¶è¿˜æœ‰ä¸€éƒ¨åˆ†æ˜¯ä¸ç½‘ç»œäº¤äº’ï¼Œä½¿ç”¨peerå‘½ä»¤ä¿®æ”¹èµ„äº§æ‰€æœ‰è€…ç­‰å‘½ä»¤ï¼Œæµ‹è¯•ç½‘ç»œæœ‰äº›å†…å®¹è¿˜æ˜¯ä¸å¤ªæ¸…æ¥šï¼Œè¿è¡Œæš‚æ—¶æ²¡æœ‰å‡ºé”™ Fabricæ¦‚è¦ å‚è€ƒè§†é¢‘ å‚è€ƒåšå®¢ å‚è€ƒç¬”è®° å¯ä»¥å‚è€ƒç¬”è®°ä¸­çš„ä¸€ä¸ªæ€ç»´å¯¼å›¾è¿›è¡Œå­¦ä¹  Overview Server/Backend/API Network Chain Code Ca Ledger Development process Client/Frontend/App SDK Development process Samples ServerNetworkæ˜¯ä¸€ä¸ªp2pç½‘ç»œï¼Œç”±ä¸¤éƒ¨åˆ†ç»„æˆ Peer Containerï¼Œå¯¹ç­‰èŠ‚ç‚¹ Endorserï¼ŒèƒŒä¹¦èŠ‚ç‚¹ï¼Œæ ¹æ®èƒŒä¹¦ç­–ç•¥å¯¹äº¤æ˜“è¿›è¡ŒéªŒè¯ Committerï¼Œæäº¤èŠ‚ç‚¹ï¼ŒchainCodeä¸ä¼šéƒ¨ç½²åœ¨Endorserä¹‹ä¸Šï¼Œè€Œæ˜¯Committerä¸Š é›†ç¾¤ç®¡ç† Kubernates Orderer Containerï¼Œæ’åºèŠ‚ç‚¹ Caå®¢æˆ·ç«¯æœåŠ¡ç«¯é…åˆå®ç°åŠ¨æ€æˆäºˆè¯ä¹¦ï¼Œæ”¯æŒå®æ—¶æ·»åŠ å¯¹ç­‰èŠ‚ç‚¹æ•°é‡ Ledger BlockChainï¼šTXè®°å½•ï¼Œå­˜å‚¨äº¤æ˜“ channelï¼ŒåŒä¸€é€šé“å…·æœ‰ï¼ˆå¯è§ï¼‰åŒä¸€ä¸ªå…¬å…±è´¦æœ¬ Hash pointerï¼Œæ”¯æŒå“ˆå¸ŒæŒ‡é’ˆ Hashed linkListï¼Œæ”¯æŒå“ˆå¸Œé“¾è¡¨ State DBï¼šWorld/Current Stateï¼ŒçŠ¶æ€æ•°æ®åº“ A peerï¼ŒA DB å­˜å‚¨äº¤æ˜“çš„Index Single/No-SQL â€“ key valueå­˜å‚¨ï¼ŒHTTP Apiï¼Œé€šè¿‡httpè¯·æ±‚è·å¾—æ•°æ®ï¼Œæ®µåº·åº·5984 level DBï¼Œé»˜è®¤å¼•æ“ï¼Œk-vå­˜å‚¨ Couch DBï¼Œæ•°æ®åº“å¼•æ“ï¼Œk-vå­˜å‚¨ï¼Œjsonå­˜å‚¨ é¡ºåºè¯»å†™èƒ½åŠ›å¼ºï¼Œéšæœºè¯»å–èƒ½åŠ›è‹¥ Chain Code System Chain Code åŒ…æ‹¬CSCCç­‰ï¼Œå¯ä»¥è‡ªå®šä¹‰ åˆ›å»ºæ—¶éšpeerä¸€èµ·å¯åŠ¨ï¼Œç”¨äºpeerèŠ‚ç‚¹ï¼ˆè€Œä¸æ˜¯channelï¼‰ä¸Šï¼Œåªæ”¯æŒgo User Chain Code ç”¨äºæ“çºµèµ„äº§ï¼Œæä¾›æ“çºµèµ„äº§çš„æ¥å£ å…·æœ‰ç”Ÿå‘½å‘¨æœŸï¼Œåˆå§‹åŒ–-éƒ¨ç½²-å®ä¾‹åŒ–-è°ƒç”¨ è¿è¡Œäºpeerä¸Šçš„å®¹å™¨ä¸­ æ”¯æŒè¯­è¨€ Golangè¯­è¨€å±‚é¢æ”¯æŒå¹¶å‘ï¼Œé€‚åˆæœåŠ¡ç«¯åº”ç”¨å¼€å‘ Node Java Client/Frontend/App æ“ä½œåŒºå—é“¾ç½‘ç»œï¼Œéƒ¨ç½²ã€æ‰§è¡Œ Chain code æä¾›çš„æ¥å£å‡½æ•°ï¼Œç›‘å¬ç½‘ç»œäº‹ä»¶ï¼Œæ¥æ”¶åŒºå—ä¿¡æ¯ï¼Œå†™å…¥äº¤æ˜“ç­‰ç­‰ SDK Node(æ¨èä½¿ç”¨) TypeScript Golang Python Java Architecture çŸ¥è¯†è¡¥å……â€“Node.js ç®€å•çš„è¯´ Node.js å°±æ˜¯è¿è¡Œåœ¨æœåŠ¡ç«¯çš„ JavaScriptã€‚ åˆ›å»ºNode.jsåº”ç”¨123456789101112131415var http = require('http');http.createServer(function (request, response) { // å‘é€ HTTP å¤´éƒ¨ // HTTP çŠ¶æ€å€¼: 200 : OK // å†…å®¹ç±»å‹: text/plain response.writeHead(200, {'Content-Type': 'text/plain'}); // å‘é€å“åº”æ•°æ® &quot;Hello World&quot; response.end('Hello World\\n');}).listen(8888);// ç»ˆç«¯æ‰“å°å¦‚ä¸‹ä¿¡æ¯console.log('Server running at http://127.0.0.1:8888/'); requireå‡½æ•°è½½å…¥httpæ¨¡å— createServeråˆ›å»ºæœåŠ¡å™¨ listenæŒ‡å®šç›‘å¬ç«¯å£ ä½¿ç”¨nodeå‘½ä»¤è¿è¡Œï¼Œè®¿é—®8888ç«¯å£ ä½¿ç”¨nodeå‘½ä»¤è¿è¡Œ1node server.js npmå‘½ä»¤ npmå®‰è£…æ¨¡å—1npm install xxxx å®‰è£…å¥½ä¹‹åï¼Œexpress åŒ…å°±æ”¾åœ¨äº†å·¥ç¨‹ç›®å½•ä¸‹çš„ node_modules ç›®å½•ä¸­ï¼Œå› æ­¤åœ¨ä»£ç ä¸­åªéœ€è¦é€šè¿‡ require(â€˜expressâ€™) çš„æ–¹å¼å°±å¥½ï¼Œæ— éœ€æŒ‡å®šç¬¬ä¸‰æ–¹åŒ…è·¯å¾„ã€‚ -gå‚æ•°æŒ‡å®šå…¨å±€å®‰è£…ï¼Œå³å°†å®‰è£…åŒ…æ”¾åœ¨ /usr/local ä¸‹æˆ–è€…ä½  node çš„å®‰è£…ç›®å½•ã€‚ pacjage.json ç”¨äºå®šä¹‰åŒ…çš„å±æ€§ name - åŒ…åã€‚ version - åŒ…çš„ç‰ˆæœ¬å·ã€‚ description - åŒ…çš„æè¿°ã€‚ homepage - åŒ…çš„å®˜ç½‘ url ã€‚ author - åŒ…çš„ä½œè€…å§“åã€‚ contributors - åŒ…çš„å…¶ä»–è´¡çŒ®è€…å§“åã€‚ dependencies - ä¾èµ–åŒ…åˆ—è¡¨ã€‚å¦‚æœä¾èµ–åŒ…æ²¡æœ‰å®‰è£…ï¼Œnpm ä¼šè‡ªåŠ¨å°†ä¾èµ–åŒ…å®‰è£…åœ¨ node_module ç›®å½•ä¸‹ã€‚ repository - åŒ…ä»£ç å­˜æ”¾çš„åœ°æ–¹çš„ç±»å‹ï¼Œå¯ä»¥æ˜¯ git æˆ– svnï¼Œgit å¯åœ¨ Github ä¸Šã€‚ main - main å­—æ®µæŒ‡å®šäº†ç¨‹åºçš„ä¸»å…¥å£æ–‡ä»¶ï¼Œrequire(â€˜moduleNameâ€™) å°±ä¼šåŠ è½½è¿™ä¸ªæ–‡ä»¶ã€‚è¿™ä¸ªå­—æ®µçš„é»˜è®¤å€¼æ˜¯æ¨¡å—æ ¹ç›®å½•ä¸‹é¢çš„ index.jsã€‚ keywords - å…³é”®å­— è¿˜å¯ä»¥ä½¿ç”¨npm init npm adduser npm publishå‘å¸ƒè‡ªå·±çš„æ¨¡å—ï¼Œä½¿ç”¨npm unpublishå–æ¶ˆå‘å¸ƒæ¨¡å— REPL Read Eval Print Loopï¼Œäº¤äº’å¼è§£é‡Šå™¨ï¼Œç±»ä¼¼pythonçš„IDLEï¼Œå¯ä»¥è¾“å…¥ä»£ç å¹¶è·å¾—æ‰§è¡Œç»“æœ é€šè¿‡nodeå‘½ä»¤è¿›å…¥ï¼Œå¿«æ·é”®ctrl cé€€å‡ºã€‚ Hellow World å‚è€ƒæ•™ç¨‹ç¼–å†™ä½ çš„ç¬¬ä¸€ä¸ªåº”ç”¨ å…·ä½“å†…å®¹ å¯åŠ¨ç½‘ç»œ ä½¿ç”¨Nodeç™»è®°ç®¡ç†å‘˜ç”¨æˆ·ï¼Œæ³¨å†Œå’Œç™»è®°åº”ç”¨ç¨‹åºç”¨æˆ·ï¼ŒæŸ¥è¯¢è´¦æœ¬ï¼Œæ›´æ–°è´¦æœ¬ æ¸…é™¤æ•°æ® startFabric.sh12345pushd ../test-network./network.sh down./network.sh up createChannel -ca -s couchdb./network.sh deployCC -ccn fabcar -ccv 1 -cci initLedger -ccl ${CC_SRC_LANGUAGE} -ccp ${CC_SRC_PATH}popd äº‹å®ä¸Šå°±æ˜¯å¯åŠ¨test-networkï¼Œåˆ›å»ºä¸¤ä¸ªpeerèŠ‚ç‚¹å’Œchannelï¼Œå†éƒ¨ç½²é“¾ç  chaincode api sdkæœ‰goï¼Œjavaå’Œæœªæ­£å¼å‘å¸ƒçš„python å¼€å‘ä¸€ä¸ªChainCodeï¼ˆgoï¼‰åˆ›å»ºstruct123456789101112package mainimport ( &quot;fmt&quot; &quot;github.com/hyperledger/fabric-chaincode-go/shim&quot; &quot;github.com/hyperledger/fabric-protos-go/peer&quot;)// SimpleAsset implements a simple chaincode to manage an assettype SimpleAsset struct {} å®ç°initæ–¹æ³•1234567891011121314151617181920// Init is called during chaincode instantiation to initialize any// data. Note that chaincode upgrade also calls this function to reset// or to migrate data, so be careful to avoid a scenario where you// inadvertently clobber your ledger's data!func (t *SimpleAsset) Init(stub shim.ChaincodeStubInterface) peer.Response { // Get the args from the transaction proposal args := stub.GetStringArgs() if len(args) != 2 { return shim.Error(&quot;Incorrect arguments. Expecting a key and a value&quot;) } // Set up any variables or assets here by calling stub.PutState() // We store the key and the value on the ledger err := stub.PutState(args[0], []byte(args[1])) if err != nil { return shim.Error(fmt.Sprintf(&quot;Failed to create asset: %s&quot;, args[0])) } return shim.Success(nil)} éªŒè¯ initæ–¹æ³•å¯ä»¥æ˜¯ç©º å®ç°invokeå‡½æ•°123456789101112131415161718192021// Invoke is called per transaction on the chaincode. Each transaction is// either a 'get' or a 'set' on the asset created by Init function. The Set// method may create a new asset by specifying a new key-value pair.func (t *SimpleAsset) Invoke(stub shim.ChaincodeStubInterface) peer.Response { // Extract the function and args from the transaction proposal fn, args := stub.GetFunctionAndParameters() var result string var err error if fn == &quot;set&quot; { result, err = set(stub, args) } else { result, err = get(stub, args) } if err != nil { return shim.Error(err.Error()) } // Return the result as success payload return shim.Success([]byte(result))} æ ¹æ®stubä¸­çš„å‚æ•°ï¼Œè°ƒç”¨getæˆ–setæ–¹æ³•ï¼Œå¹¶è¿”å›ç»“æœ å®ç°getå’Œset1234567891011121314151617181920212223242526272829// Set stores the asset (both key and value) on the ledger. If the key exists,// it will override the value with the new onefunc set(stub shim.ChaincodeStubInterface, args []string) (string, error) { if len(args) != 2 { return &quot;&quot;, fmt.Errorf(&quot;Incorrect arguments. Expecting a key and a value&quot;) } err := stub.PutState(args[0], []byte(args[1])) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;Failed to set asset: %s&quot;, args[0]) } return args[1], nil}// Get returns the value of the specified asset keyfunc get(stub shim.ChaincodeStubInterface, args []string) (string, error) { if len(args) != 1 { return &quot;&quot;, fmt.Errorf(&quot;Incorrect arguments. Expecting a key&quot;) } value, err := stub.GetState(args[0]) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;Failed to get asset: %s with error: %s&quot;, args[0], err) } if value == nil { return &quot;&quot;, fmt.Errorf(&quot;Asset not found: %s&quot;, args[0]) } return string(value), nil} ä»ledgerè´¦æœ¬ä¸­è¯»å†™æ•°æ® å®ç°mainæ–¹æ³•12345func main() { if err := shim.Start(new(SimpleAsset)); err != nil { fmt.Printf(&quot;Error starting SimpleAsset chaincode: %s&quot;, err) }} åœ¨ä»¥ä¸Šæ­¥éª¤çš„åŸºç¡€ä¸Šï¼Œç»“åˆshim apiåº”è¯¥å¯ä»¥å¼€å‘å‡ºå…¶ä»–åŠŸèƒ½","link":"/home/2022/10/22/fedfab/fabric/1.fabric%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%90%AD%E5%BB%BA/"},{"title":"åŸºç¡€06-ViewGroup","text":"testgraph TD A[å¼€å§‹] --> B{æ¡ä»¶åˆ¤æ–­} B -->|æ˜¯| C[æ‰§è¡Œæ“ä½œ] B -->|å¦| D[ç»“æŸ]","link":"/home/2025/05/09/Android%E9%AB%98%E7%BA%A7/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E5%9F%BA%E7%A1%8006-ViewGroup/"},{"title":"01-layout","text":"IDåˆ›å»º RelativeLayout æ—¶ï¼Œè¯·åŠ¡å¿…ä¸ºè§†å›¾å¯¹è±¡å®šä¹‰ IDã€‚åœ¨ç›¸å¯¹å¸ƒå±€ä¸­ï¼ŒåŒçº§è§†å›¾å¯ä»¥å®šä¹‰å…¶ç›¸å¯¹äºé€šè¿‡å”¯ä¸€ ID å¼•ç”¨çš„å¦ä¸€ä¸ªåŒçº§è§†å›¾çš„å¸ƒå±€ã€‚ findViewByIdID ä¸å¿…åœ¨æ•´ä¸ªæ ‘çŠ¶ç»“æ„ä¸­å…·æœ‰å”¯ä¸€æ€§ï¼Œä½†åœ¨æ‚¨æœç´¢çš„æ ‘çŠ¶ç»“æ„éƒ¨åˆ†ä¸­å¿…é¡»æ˜¯å”¯ä¸€çš„ã€‚å®ƒé€šå¸¸å¯èƒ½æ˜¯æ•´ä¸ªæ ‘ï¼Œå› æ­¤æœ€å¥½å°½å¯èƒ½ä½¿å…¶å…·æœ‰å”¯ä¸€æ€§ã€‚ findViewByIdæ˜¯Viewçš„æ–¹æ³• 123456789101112131415161718192021/** * Finds the first descendant view with the given ID, the view itself if * the ID matches {@link #getId()}, or {@code null} if the ID is invalid * (&lt; 0) or there is no matching view in the hierarchy. * &lt;p&gt; * &lt;strong&gt;Note:&lt;/strong&gt; In most cases -- depending on compiler support -- * the resulting view is automatically cast to the target class type. If * the target class type is unconstrained, an explicit cast may be * necessary. * * @param id the ID to search for * @return a view with given ID if found, or {@code null} otherwise * @see View#requireViewById(int) */@Nullablepublic final &lt;T extends View&gt; T findViewById(@IdRes int id) { if (id == NO_ID) { return null; } return findViewTraversal(id);} åœ¨Activityä¸­ï¼ŒfindViewByIdæ˜¯è°ƒç”¨windowçš„findViewById 123456789101112131415161718/** * Finds a view that was identified by the {@code android:id} XML attribute * that was processed in {@link #onCreate}. * &lt;p&gt; * &lt;strong&gt;Note:&lt;/strong&gt; In most cases -- depending on compiler support -- * the resulting view is automatically cast to the target class type. If * the target class type is unconstrained, an explicit cast may be * necessary. * * @param id the ID to search for * @return a view with given ID if found, or {@code null} otherwise * @see View#findViewById(int) * @see Activity#requireViewById(int) */@Nullablepublic &lt;T extends View&gt; T findViewById(@IdRes int id) { return getWindow().findViewById(id);} Windowè°ƒç”¨DecorView 1234567891011121314151617181920/** * Finds a view that was identified by the {@code android:id} XML attribute * that was processed in {@link android.app.Activity#onCreate}. * &lt;p&gt; * This will implicitly call {@link #getDecorView} with all of the associated side-effects. * &lt;p&gt; * &lt;strong&gt;Note:&lt;/strong&gt; In most cases -- depending on compiler support -- * the resulting view is automatically cast to the target class type. If * the target class type is unconstrained, an explicit cast may be * necessary. * * @param id the ID to search for * @return a view with given ID if found, or {@code null} otherwise * @see View#findViewById(int) * @see Window#requireViewById(int) */@Nullablepublic &lt;T extends View&gt; T findViewById(@IdRes int id) { return getDecorView().findViewById(id);} å¸ƒå±€å‚æ•°æ¯ä¸ª ViewGroup ç±»éƒ½ä¼šå®ç°ä¸€ä¸ªæ‰©å±• ViewGroup.LayoutParams çš„åµŒå¥—ç±»ã€‚æ­¤å­ç±»åŒ…å«çš„å±æ€§ç±»å‹ä¼šæ ¹æ®éœ€è¦ä¸ºè§†å›¾ç»„å®šä¹‰æ¯ä¸ªå­è§†å›¾çš„å°ºå¯¸å’Œä½ç½®ã€‚å¦‚å›¾ 2 æ‰€ç¤ºï¼Œçˆ¶è§†å›¾ç»„ä¼šä¸ºæ¯ä¸ªå­è§†å›¾ï¼ˆåŒ…æ‹¬å­è§†å›¾ç»„ï¼‰å®šä¹‰å¸ƒå±€å‚æ•°ã€‚ æ‰€æœ‰è§†å›¾ç»„éƒ½ä½¿ç”¨ layout_width å’Œ layout_height åŒ…å«å®½åº¦å’Œé«˜åº¦ï¼Œå¹¶ä¸”æ¯ä¸ªè§†å›¾éƒ½å¿…é¡»å®šä¹‰å®ƒä»¬ã€‚è®¸å¤š LayoutParams åŒ…å«å¯é€‰çš„å¤–è¾¹è·å’Œè¾¹æ¡†ã€‚ æ‚¨å¯ä»¥æŒ‡å®šå…·æœ‰ç¡®åˆ‡å°ºå¯¸çš„å®½åº¦å’Œé«˜åº¦ï¼Œä½†æ‚¨å¯èƒ½ä¸å¸Œæœ›ç»å¸¸è¿™æ ·åšã€‚æ›´å¸¸è§çš„æƒ…å†µæ˜¯ï¼Œæ‚¨ä¼šä½¿ç”¨ä»¥ä¸‹æŸä¸ªå¸¸é‡æ¥è®¾ç½®å®½åº¦æˆ–é«˜åº¦ï¼š wrap_contentï¼šå‘ŠçŸ¥è§†å›¾å°†å…¶å¤§å°è°ƒæ•´ä¸ºå†…å®¹æ‰€éœ€çš„å°ºå¯¸ã€‚ match_parentï¼šå‘ŠçŸ¥è§†å›¾å°½å¯èƒ½é‡‡ç”¨å…¶çˆ¶è§†å›¾ç»„å…è®¸çš„æœ€å¤§å°ºå¯¸ã€‚ æœ€å¥½ä½¿ç”¨dpï¼Œå¯†åº¦æ— å…³åƒç´  å¸ƒå±€ä½ç½®getLeft(), getTop(), getRight(), getBottom()è¡¨ç¤ºè·å–ç›¸å¯¹äºå…¶çˆ¶viewçš„ä½ç½®åæ ‡ getRight() - getLeft() == getWidth()getBottom() - getTop() == getHeight() å°ºå¯¸, å†…å¤–è¾¹è·margin(å¤–è¾¹è·)å’Œpadding(å†…è¾¹è·)çš„åŒºåˆ« marginæŒ‡çš„æ˜¯åœ¨viewçš„è¾¹ç•Œä¹‹å¤–çš„é¢å¤–ç©ºé—´ï¼Œç”¨äºåˆ†éš”çˆ¶å¸ƒå±€ï¼Œæˆ–çˆ¶å¸ƒå±€ä¸­å…¶ä»–ç›¸é‚»view marginçš„é¢œè‰²ä¸å—viewçš„å½±å“ paddingæ˜¯åœ¨viewè¾¹ç•Œå†…éƒ¨çš„é¢å¤–ç©ºé—´ paddingçš„é¢œè‰²å—viewçš„èƒŒæ™¯çš„å½±å“ è‡ªé€‚åº”å¸ƒå±€ ä½¿ç”¨ConstraintLayout å¯¹åˆ—è¡¨-è¯¦æƒ…ç•Œé¢ä½¿ç”¨ SlidingPaneLayout æ ¹æ®è®¾å¤‡å°ºå¯¸è‡ªåŠ¨å†³å®šèœå•å’Œcontentæ˜¯å¹¶æ’æ˜¾ç¤ºè¿˜æ˜¯å±‚å æ˜¾ç¤º å¤‡ç”¨èµ„æºå¯¹èµ„æºç›®å½•/å¸ƒå±€æ–‡ä»¶çš„æ–‡ä»¶ååæ·»åŠ é™å®šç¬¦ï¼Œå¯è§„å®šè‡ªæ„¿é™åˆ¶åº”ç”¨çš„å±å¹•å°ºå¯¸ï¼Œè¯­è¨€ï¼Œå±å¹•æ–¹å‘ï¼Œå¦‚æœ‰å¤šç§é™åˆ¶ï¼Œéœ€è¦æŒ‰ç…§è¡¨æ ¼ä¸­çš„é¡ºåºç»™å‡ºã€‚ åœ¨è¡¨æ ¼ä¸­è¶Šé å‰çš„ä¼˜å…ˆçº§è¶Šé«˜ ç³»ç»Ÿé€‰æ‹©åˆé€‚çš„èµ„æºæ—¶ï¼Œé¦–å…ˆæ’é™¤ä¸è®¾å¤‡é…ç½®ç›¸å†²çªçš„èµ„æºæ–‡ä»¶ï¼ˆå¦‚è¯­è¨€ã€åƒç´ å¯†åº¦ï¼‰ï¼Œç„¶åæŒ‰ç…§è¡¨æ ¼çš„é¡ºåºä¾æ¬¡å¯»æ‰¾æ˜¯å¦æœ‰ç›®å½•åŒ…å«è¯¥é™å®šç¬¦ï¼Œå¦‚æœæœ‰ï¼Œåˆ™æŠŠä¸å«æœ‰é™å®šç¬¦çš„ç›®å½•æ’é™¤ fragmentä½¿ç”¨ fragment å°†ç•Œé¢ç»„ä»¶æ¨¡å—åŒ– å¯¹äºæŠ˜å å±ã€å¤§å°ºå¯¸è®¾å¤‡ï¼Œå¯ä»¥ç”¨fragmentå°†uiæ¨¡å—åŒ–ï¼Œé¿å…é‡å¤çš„uiåŠ è½½ activity åµŒå…¥ä½¿ç”¨ActivityåµŒå…¥ï¼Œå¯åœ¨å¤§å°ºå¯¸è®¾å¤‡ä¸Šåœ¨å±å¹•ä¸Šå¹¶æ’æ˜¾ç¤ºActivityï¼Œåœ¨å°å°ºå¯¸å±å¹•ä¸Šå±‚å æ˜¾ç¤º çº¿æ€§å¸ƒå±€å‡ç­‰åˆ†å¸ƒè‹¥è¦åˆ›å»ºçº¿æ€§å¸ƒå±€ï¼Œè®©æ¯ä¸ªå­é¡¹åœ¨å±å¹•ä¸Šå æ®ç›¸åŒå¤§å°çš„ç©ºé—´ android:layout_height=&quot;0dp&quot; or android:layout_width=&quot;0dp&quot; android:layout_weight=&quot;1&quot; ä¸ç­‰åˆ†å¸ƒ weightä¸º0,åˆ™åªå æ®æ‰€éœ€çš„å¤§å° ä¸ä¸º0ï¼Œæ¯ä¸ªå æ®å‰©ä½™ç©ºé—´çš„ $ weight_i / \\sum_{j=1}^{N}{weight_j} $ ä¼˜åŒ–å¸ƒå±€ å‡å°‘å¸ƒå±€å±‚æ¬¡ åˆå¹¶ ä½¿ç”¨ConstraintLayout é€šè¿‡includeæ ‡ç­¾é‡å¤ä½¿ç”¨å¸ƒå±€ å­å¸ƒå±€çš„æ ¹å¸ƒå±€å¯ä»¥ä½¿ç”¨mergeæ ‡ç­¾ï¼Œä¸çˆ¶å¸ƒå±€åˆå¹¶ ä½¿ç”¨ViewStub åŠ¨æ€å°†ViewStubæ›¿æ¢ä¸ºå¯¹åº”çš„view é€šè¿‡ViewStub.inflateæ›¿æ¢view è‡ªå®šä¹‰ç»„ä»¶è‡ªå®šä¹‰å±æ€§ åˆ›å»ºres/values/attrs.xml æè¿°å±æ€§ä»¥åŠå±æ€§çš„å–å€¼ è·å–å±æ€§å€¼1234567891011121314init { context.theme.obtainStyledAttributes( attrs, R.styleable.PieChart, 0, 0).apply { try { mShowText = getBoolean(R.styleable.PieChart_showText, false) textPos = getInteger(R.styleable.PieChart_labelPosition, 0) } finally { recycle() } }} onMeasure è·å–parenté™åˆ¶çš„å¤§å° 1234int widthMode = MeasureSpec.getMode(widthMeasureSpec);int widthSize = MeasureSpec.getSize(widthMeasureSpec);int heightMode = MeasureSpec.getMode(heightMeasureSpec);int heightSize = MeasureSpec.getSize(heightMeasureSpec); Modeæ˜¯MeasureSpec è°ƒç”¨childçš„measure, å‚æ•°è¡¨ç¤ºå¯¹childå¤§å°çš„é™åˆ¶ 123456789101112131415161718192021/** * &lt;p&gt; * This is called to find out how big a view should be. The parent * supplies constraint information in the width and height parameters. * &lt;/p&gt; * * &lt;p&gt; * The actual measurement work of a view is performed in * {@link #onMeasure(int, int)}, called by this method. Therefore, only * {@link #onMeasure(int, int)} can and must be overridden by subclasses. * &lt;/p&gt; * * * @param widthMeasureSpec Horizontal space requirements as imposed by the * parent * @param heightMeasureSpec Vertical space requirements as imposed by the * parent * * @see #onMeasure(int, int) */public final void measure(int widthMeasureSpec, int heightMeasureSpec) { onLayoutéå†childï¼Œè°ƒç”¨childçš„layoutæ–¹æ³•ï¼Œå‚æ•°è¡¨ç¤ºå…¶å¸ƒå±€ç›¸å¯¹äºçˆ¶å¸ƒå±€çš„ä½ç½® 12345678910111213141516171819202122/** * Assign a size and position to a view and all of its * descendants * * &lt;p&gt;This is the second phase of the layout mechanism. * (The first is measuring). In this phase, each parent calls * layout on all of its children to position them. * This is typically done using the child measurements * that were stored in the measure pass().&lt;/p&gt; * * &lt;p&gt;Derived classes should not override this method. * Derived classes with children should override * onLayout. In that method, they should * call layout on each of their children.&lt;/p&gt; * * @param l Left position, relative to parent * @param t Top position, relative to parent * @param r Right position, relative to parent * @param b Bottom position, relative to parent */@SuppressWarnings({&quot;unchecked&quot;})public void layout(int l, int t, int r, int b) { onDrawç»™ä½ Canvaså»ç»˜å›¾ æ²‰æµ¸æ¨¡å¼ç³»ç»Ÿè¾¹è¡¬åŒº ç³»ç»Ÿæ è¾¹è¡¬åŒºï¼šçŠ¶æ€æ +å¯¼èˆªæ¡/æŒ‰é’® ç³»ç»Ÿæ‰‹åŠ¿è¾¹è¡¬åŒºï¼šæ‰‹åŠ¿å¯¼èˆªåŒº åœ†è§’ è·å–è®¾å¤‡åœ†è§’çš„åœ†å¿ƒå’ŒåŠå¾„12345// åœ¨ä¸€ä¸ªviewä¸­val insets = rootWindowInsetsval topRight = insets.getRoundedCorner(RoundedCorner.POSITION_TOP_RIGHT) ?: return// åœ¨activityä¸­val rootWindowInsets = rootView.rootWindowInsets","link":"/home/2024/05/20/Android%E9%AB%98%E7%BA%A7/%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB/01-layout/"},{"title":"fabric-3.é“¾ç è¿è¡Œä¸Apiè°ƒç”¨","text":"ä¸­å›½ç¤¾åŒºæ–‡æ¡£ é“¾ç çš„æ‰“åŒ… ä¹‹å‰å·²ç»å®Œæˆäº†é“¾ç modçš„åˆå§‹åŒ–å’Œç¼–è¯‘ï¼Œç›´æ¥è¿›è¡Œæ‰“åŒ…1234peer lifecycle chaincode package fedfab.tar.gz \\ --path ../../fabric-cluster/chaincode/go/fedfab \\ --label fedfab_1 \\ --lang golang åœ¨å½“å‰ç›®å½•ç”Ÿæˆäº†fedfab.tar.gzæ–‡ä»¶ å°†æ‰“åŒ…å¥½çš„æ–‡ä»¶å¤åˆ¶åˆ°å…¶ä»–cliä¸­1234docker cp cli0:/opt/gopath/src/github.com/hyperledger/fabric/peer/fedfab.tar.gz ./docker cp ./fedfab.tar.gz cli1:/opt/gopath/src/github.com/hyperledger/fabric/peer/docker cp ./fedfab.tar.gz cli2:/opt/gopath/src/github.com/hyperledger/fabric/peer/docker cp ./fedfab.tar.gz cli3:/opt/gopath/src/github.com/hyperledger/fabric/peer/ é“¾ç å®‰è£… åœ¨æ¯ä¸ªcliä¸Šå¯¹é“¾ç è¿›è¡Œå®‰è£…1peer lifecycle chaincode install fedfab.tar.gz 122022-09-28 11:00:07.102 UTC 0001 INFO [cli.lifecycle.chaincode] submitInstallProposal -&gt; Installed remotely: response:&lt;status:200 payload:&quot;\\nIfedfab_1:705f9bef5195eff92ab7dd43ad1bcc2a7cb35defbb5c984b5197081f5b768d2e\\022\\010fedfab_1&quot; &gt; 2022-09-28 11:00:07.102 UTC 0002 INFO [cli.lifecycle.chaincode] submitInstallProposal -&gt; Chaincode code package identifier: fedfab_1:705f9bef5195eff92ab7dd43ad1bcc2a7cb35defbb5c984b5197081f5b768d2e ç»„ç»‡orgæ‰¹å‡†é“¾ç 1peer lifecycle chaincode approveformyorg --channelID channel2 --name fedfab --version 1.0 --package-id fedfab_1:705f9bef5195eff92ab7dd43ad1bcc2a7cb35defbb5c984b5197081f5b768d2e --sequence 1 --init-required --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem org1è¾“å‡º122022-09-03 11:12:26.988 UTC 0001 INFO [cli.lifecycle.chaincode] setOrdererClient -&gt; Retrieved channel (channel2) orderer endpoint: orderer.fedfab.com:70512022-09-03 11:12:29.067 UTC 0002 INFO [chaincodeCmd] ClientWait -&gt; txid [fcf3b9e351cae89503b256ce5dde76080432eac3b065ad8108be9ce8fbe2443a] committed with status (VALID) at peer0.org1.fedfab.com:8051 org2è¾“å‡º122022-09-03 11:12:29.057 UTC 0001 INFO [cli.lifecycle.chaincode] setOrdererClient -&gt; Retrieved channel (channel2) orderer endpoint: orderer.fedfab.com:70512022-09-03 11:12:31.110 UTC 0002 INFO [chaincodeCmd] ClientWait -&gt; txid [24e460abf242c2fd86b0a56e6ee045c76c08cd9b77d2bccb66bcd4e315806deb] committed with status (VALID) at peer0.org2.fedfab.com:9051 æ¯ä¸ªorgæäº¤ä¸€æ¬¡å³å¯ éªŒè¯æ˜¯å¦æ‰¹å‡†æˆåŠŸ1peer lifecycle chaincode queryapproved --channelID channel2 --name fedfab --sequence 1 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --output json 12345678910111213141516{ &quot;sequence&quot;: 1, &quot;version&quot;: &quot;1.0&quot;, &quot;endorsement_plugin&quot;: &quot;escc&quot;, &quot;validation_plugin&quot;: &quot;vscc&quot;, &quot;validation_parameter&quot;: &quot;EiAvQ2hhbm5lbC9BcHBsaWNhdGlvbi9FbmRvcnNlbWVudA==&quot;, &quot;collections&quot;: {}, &quot;init_required&quot;: true, &quot;source&quot;: { &quot;Type&quot;: { &quot;LocalPackage&quot;: { &quot;package_id&quot;: &quot;09dc77ee99925c9ffd623cdcf6009c125c25bfec709a0986a62a883ef28d1ae4&quot; } } }} 1peer lifecycle chaincode checkcommitreadiness --channelID channel2 --name fedfab --version 1.0 --init-required --sequence 1 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --output json 123456{ &quot;approvals&quot;: { &quot;Org1MSP&quot;: true, &quot;Org2MSP&quot;: true }} æäº¤123456peer lifecycle chaincode commit -o orderer.fedfab.com:7050 --channelID channel2 --name fedfab --version 1.0 --sequence 1 --tls true --init-required --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt 12342022-09-03 22:04:17.335 UTC 0001 INFO [chaincodeCmd] ClientWait -&gt; txid [2468ffb8850ef91b0e3643cdc347fead1e9c39e8c0de8e5528b687b06d4e8ddb] committed with status (VALID) at peer1.org1.fedfab.com:80532022-09-03 22:04:17.338 UTC 0002 INFO [chaincodeCmd] ClientWait -&gt; txid [2468ffb8850ef91b0e3643cdc347fead1e9c39e8c0de8e5528b687b06d4e8ddb] committed with status (VALID) at peer2.org1.fedfab.com:80552022-09-03 22:04:17.338 UTC 0003 INFO [chaincodeCmd] ClientWait -&gt; txid [2468ffb8850ef91b0e3643cdc347fead1e9c39e8c0de8e5528b687b06d4e8ddb] committed with status (VALID) at peer0.org1.fedfab.com:80512022-09-03 22:04:17.338 UTC 0004 INFO [chaincodeCmd] ClientWait -&gt; txid [2468ffb8850ef91b0e3643cdc347fead1e9c39e8c0de8e5528b687b06d4e8ddb] committed with status (VALID) at peer0.org2.fedfab.com:9051 é“¾ç çš„è°ƒç”¨è¾“å…¥ä¸€ä¸ªé”®å€¼å¯¹a:bb1234567peer chaincode invoke -o orderer.fedfab.com:7050 --isInit --ordererTLSHostnameOverride orderer.fedfab.com --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;a&quot;, &quot;bb&quot;]}' 12022-09-03 22:32:26.926 UTC 0001 INFO [chaincodeCmd] chaincodeInvokeOrQuery -&gt; Chaincode invoke successful. result: status:200 è¿™ä¸ªåœ°æ–¹å‡ºé”™å¤±è´¥äº†å¾ˆå¤šæ¬¡ï¼ŒåŸå› æ˜¯ä¹‹å‰approve chaincodeæ—¶ï¼ŒæŒ‡å®šçš„package-idä¸æ­£ç¡®ï¼Œåœ¨approveçš„å‰ä¸€æ­¥installçš„è¾“å‡ºä¸­ï¼Œè¾“å‡ºçš„package-idæ˜¯ï¼š Chaincode code package identifier: fedfab_2:cf7c1115e177f200ee6383d455b563e1df20721e0dccb6bb9cbf43e95d008739 chaincodeçš„package-idæ˜¯lable:ä¸€ä¸²æ•°å­—ï¼Œåœ¨approveæ—¶æŒ‡å®špkgidæ—¶å¿…é¡»å®Œæ•´ï¼Œä¸èƒ½åªæŒ‡å®šåé¢çš„ä¸€ä¸²æ•°å­—ï¼Œé‡æ–°åœ¨orgä¸­è¿›è¡Œapproveæ“ä½œï¼Œåˆ™å¯ä»¥æ­£ç¡®æ‰§è¡Œé“¾ç  è¿™ä¸ªå›ç­”çš„referenceæ˜¯å®˜ç½‘çš„æ–‡æ¡£deploy_chaincodeä¸­çš„å†…å®¹ æŸ¥è¯¢açš„å€¼1peer chaincode query -C channel2 -n fedfab -c '{&quot;Args&quot;:[&quot;query&quot;, &quot;a&quot;]}' 1bb ä¿®æ”¹açš„å€¼ä¸ºccï¼Œå¹¶æŸ¥è¯¢éªŒè¯1234567peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;set&quot;, &quot;a&quot;, &quot;cc&quot;]}'peer chaincode query -C channel2 -n fedfab -c '{&quot;Args&quot;:[&quot;query&quot;, &quot;a&quot;]}' 122022-09-04 07:48:30.012 UTC 0001 INFO [chaincodeCmd] chaincodeInvokeOrQuery -&gt; Chaincode invoke successful. result: status:200 payload:&quot;cc&quot; cc ä¹‹å‰å¤±è´¥äº†å‡ æ¬¡ï¼Œè¯•å›¾é‡æ–°æ­å»ºç½‘ç»œï¼Œä½†æ˜¯å³ä½¿æ‰€æœ‰å®¹å™¨éƒ½åˆ é™¤åï¼Œç½‘ç»œä¼¼ä¹è¿˜æœ‰ä¸€å®šçš„â€œè®°å¿†â€ã€‚å¹¶ä¸”ä¸èƒ½ä½¿ç”¨æ–°ç”Ÿæˆçš„è¯ä¹¦æ–‡ä»¶ï¼ˆå¦åˆ™ä¼šæŠ¥é”™ï¼‰ï¼Œåªèƒ½ä½¿ç”¨ç¬¬ä¸€æ¬¡ç”Ÿæˆçš„è¯ä¹¦æ–‡ä»¶ã€‚(å·²è§£å†³) docker network åœ¨ç¼–å†™docker composeæ–‡ä»¶æ—¶ï¼Œä¼šé…ç½®ä¸€ä¸ªnetworkï¼Œèµ·åˆè®¤ä¸ºè¿™æ˜¯å®šä¹‰fabricç½‘ç»œç‰¹æœ‰çš„ï¼Œåæ¥å‘ç°æ˜¯dockerçš„åŠŸèƒ½ã€‚ å‚è€ƒèµ„æ–™ å®¹å™¨ç½‘ç»œæ¨¡å‹ï¼ˆContainer Network Modelï¼Œç®€ç§°CNMï¼‰ï¼Œåªè¦ç¬¦åˆè¿™ä¸ªæ¨¡å‹çš„ç½‘ç»œæ¥å£å°±èƒ½è¢«ç”¨äºå®¹å™¨ä¹‹é—´é€šä¿¡ï¼Œè€Œé€šä¿¡çš„è¿‡ç¨‹å’Œç»†èŠ‚å¯ä»¥å®Œå…¨ç”±ç½‘ç»œæ¥å£æ¥å®ç°ã€‚ å‚è€ƒä¸­è¯¦ç»†è®²è§£äº†docker compose ä¸­ä½¿ç”¨networkså®šä¹‰ç½‘ç»œ fedmlä¸fabricäº¤äº’ ç¼–å†™applicationï¼Œä¸ºäº†è®©fabricä¸fedmlç»“åˆï¼Œéœ€è¦æœ‰è°ƒç”¨fabricçš„apiï¼Œåœ¨fabricè®­ç»ƒçš„ä¸åŒé˜¶æ®µè°ƒç”¨fabricçš„apiè¾¾åˆ°äº¤äº’çš„ç›®çš„ã€‚ä½†æ˜¯fedmlæ˜¯pythonä»£ç ï¼Œapiæä¾›äº†jså’Œjavaï¼Œè°ƒç”¨èµ·æ¥ç›¸å¯¹éº»çƒ¦ä¸€äº› ä½¿ç”¨ä¸hyperledger fabricåŒåçš„ä¸€ä¸ªpythonåº“fabricï¼Œè¿œç¨‹è¿æ¥cliçš„dockeræ‰§è¡Œå‘½ä»¤ï¼Œæ„Ÿè§‰è¿™æ ·å®‰å…¨æ€§è¾ƒå·® ç›´æ¥ä½¿ç”¨python sdk fabricçš„jira python sdk sdkæ–‡æ¡£ sdkçš„pypié“¾æ¥ é€šè¿‡pypiæŸ¥è¯¢ï¼Œå®ƒæœ€åä¸€æ¬¡æ›´æ–°åœ¨2020å¹´8æœˆï¼Œä¸»è¦æ”¯æŒfabric 1.4.xç‰ˆæœ¬ ä½¿ç”¨node ä½¿ç”¨nodeç¼–å†™jsä»£ç ï¼Œå¦‚å®ç°invokeç­‰åŠŸèƒ½ï¼Œå†ä¸ºæ¯ä¸ªåŠŸèƒ½æŒ‡å®šä¸€ä¸ªç«¯å£ï¼Œä½¿ç”¨nodeä¸ºæ¯ä¸ªåŠŸèƒ½å»ºç«‹httpæœåŠ¡ã€‚åœ¨fedmlè®­ç»ƒè¿‡ç¨‹ä¸­ï¼ŒæŒ‰ç…§éœ€è¦è°ƒç”¨è¿™äº›æ¥å£ï¼Œå³å¯ä»¥å®ç°ä¸Šè¿°åŠŸèƒ½ nodeå®ç°getã€postè¯·æ±‚çš„æ•™ç¨‹ node sdk ç®€ä»‹ å‚è€ƒ æ­¤ API ç›®å‰ä¸æä¾›ç®¡ç†åŠŸèƒ½ï¼Œä¾‹å¦‚å®‰è£…å’Œå¯åŠ¨æ™ºèƒ½åˆçº¦ã€‚å¯¹äºç‰¹å®šçš„é«˜çº§ç”¨æ³•ï¼Œå¯ä»¥ä½¿ç”¨è¾ƒä½çº§åˆ«çš„fabric-common APIã€‚ ç”¨äºä¸ Hyperledger Fabric åŒºå—é“¾ç½‘ç»œäº¤äº’çš„å…¥å£ç‚¹æ˜¯ Gatewayç±»ã€‚ä¸€æ—¦å®ä¾‹åŒ–ï¼Œè¿™ä¸ªé•¿æœŸå­˜åœ¨çš„å¯¹è±¡æä¾›äº†ä¸åŒºå—é“¾ç½‘ç»œä¸­çš„å¯¹ç­‰ç‚¹çš„å¯é‡ç”¨è¿æ¥ï¼Œå¹¶å…è®¸è®¿é—®è¯¥å¯¹ç­‰ç‚¹æ‰€å±çš„ä»»ä½•åŒºå—é“¾ ç½‘ç»œï¼ˆé€šé“ï¼‰ã€‚æä¾›äº†å¯¹è¯¥åŒºå—é“¾ç½‘ç»œä¸­è¿è¡Œçš„æ™ºèƒ½åˆçº¦ï¼ˆé“¾ç ï¼‰çš„è®¿é—®ï¼Œå¹¶ä¸”å¯ä»¥å‘å…¶ æäº¤äº¤æ˜“æˆ– è¯„ä¼°æŸ¥è¯¢ã€‚ fabric-gatewayç®€ä»‹å‚è€ƒ- fabric gatewayæ˜¯fabric v2.4 å¼•å…¥çš„ä¸€é¡¹æœåŠ¡ï¼Œå®ƒæä¾›ç”¨äºå°†äº‹åŠ¡æäº¤åˆ°fabricç½‘ç»œçš„æœ€ç®€åŒ–çš„APIç¤ºä¾‹ä»£ç 1234567891011121314151617181920212223242526272829303132333435import * as grpc from '@grpc/grpc-js';import * as crypto from 'crypto';import { connect, Identity, signers } from '@hyperledger/fabric-gateway';import { promises as fs } from 'fs';import { TextDecoder } from 'util';const utf8Decoder = new TextDecoder();async function main(): Promise&lt;void&gt; { const credentials = await fs.readFile('path/to/certificate.pem'); const identity: Identity = { mspId: 'myorg', credentials }; const privateKeyPem = await fs.readFile('path/to/privateKey.pem'); const privateKey = crypto.createPrivateKey(privateKeyPem); const signer = signers.newPrivateKeySigner(privateKey); const client = new grpc.Client('gateway.example.org:1337', grpc.credentials.createInsecure()); const gateway = connect({ identity, signer, client }); try { const network = gateway.getNetwork('channelName'); const contract = network.getContract('chaincodeName'); const putResult = await contract.submitTransaction('put', 'time', new Date().toISOString()); console.log('Put result:', utf8Decoder.decode(putResult)); const getResult = await contract.evaluateTransaction('get', 'time'); console.log('Get result:', utf8Decoder.decode(getResult)); } finally { gateway.close(); client.close() }}main().catch(console.error); è¿è¡Œtsæ–‡ä»¶ å‚è€ƒ å‚è€ƒä»£ç  å®‰è£…ä¾èµ–12npm install @hyperledger/fabric-gatewaynpm install @grpc/grpc-js å®‰è£…ts 12345678910tar -zxvf node-v16.17.0-linux-x64.tar.xzsudo mv node-v16.17.0-linux-x64 /usr/local/nodevim tee -a /etc/profile &lt;&lt;-'EOF'export NODE_HONE=/usr/local/nodeexport PATH=$PATH:$NODE_HONE/binEOFsource /etc/profilenpm install -g typescriptnpm install ts-node -Dtsc -v è¿è¡Œtsæ–‡ä»¶ 1npx ts-node src/app.ts å¯¹açš„getï¼Œsetï¼Œgetï¼Œå†å¯¹bï¼ˆåŸæ¥æ²¡æœ‰çš„keyï¼‰ setï¼Œget12345678910111213141516171819202122232425/home/tt/Desktop/fabric/my-network/nodes/crypto-config/peerOrganizations/org1.fedfab.comchannelName: channel2chaincodeName: fedfabmspId: Org1MSPcryptoPath: /home/tt/Desktop/fabric/my-network/nodes/crypto-config/peerOrganizations/org1.fedfab.comkeyDirectoryPath: /home/tt/Desktop/fabric/my-network/nodes/crypto-config/peerOrganizations/org1.fedfab.com/users/User1@org1.fedfab.com/msp/keystorecertPath: /home/tt/Desktop/fabric/my-network/nodes/crypto-config/peerOrganizations/org1.fedfab.com/users/User1@org1.fedfab.com/msp/signcerts/User1@org1.fedfab.com-cert.pemtlsCertPath: /home/tt/Desktop/fabric/my-network/nodes/crypto-config/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crtpeerEndpoint: localhost:8051peerHostAlias: peer0.org1.fedfab.com--&gt; Evaluate Transaction: Invoke, function returns all the current assets on the ledger*** Result: bb--&gt; Evaluate Transaction: Invoke, function returns all the current assets on the ledger*** Result: dd--&gt; Evaluate Transaction: Invoke, function returns all the current assets on the ledger*** Result: dd--&gt; Evaluate Transaction: Invoke, function returns all the current assets on the ledger*** Result: cc--&gt; Evaluate Transaction: Invoke, function returns all the current assets on the ledger*** Result: cc åˆ›å»ºhttpæœåŠ¡ä½¿ç”¨node-httpç­‰åº“ï¼Œå»ºç«‹httpæœåŠ¡ï¼Œå°±å¯ä»¥é€šè¿‡ç½‘ç»œè¯·æ±‚çš„æ–¹å¼è®¿é—®åŒºå—é“¾ 123456789http://10.128.196.184:3000/invokeChaincodebody:json{ &quot;peer&quot;: 0, &quot;org&quot;: 2, &quot;function&quot;: &quot;set&quot;, &quot;key&quot;: &quot;a&quot;, &quot;val&quot;: &quot;bb&quot;} 12345678http://10.128.196.184:3000/invokeChaincodebody:json{ &quot;peer&quot;: 0, &quot;org&quot;: 2, &quot;function&quot;: &quot;get&quot;, &quot;key&quot;: &quot;a&quot;} ä»£ç ","link":"/home/2022/10/22/fedfab/fabric/3.%E9%93%BE%E7%A0%81%E8%BF%90%E8%A1%8C%E4%B8%8EApi%E8%B0%83%E7%94%A8/"},{"title":"fabric-5.è®ºæ–‡","text":"éœ€è¦å®ç° è®ºæ–‡ä¸­çš„æ–°çš„å½’ä¸€åŒ–ç®—æ³• é˜²æ­¢æ¶æ„æ¨¡å‹æ›´æ–° å®¢æˆ·ä½¿ç”¨ç§é’¥ç­¾åæ¨¡å‹ fedmlçš„èŠ‚ç‚¹ä½œä¸ºmecæœåŠ¡å™¨èµ·è®­ç»ƒä½œç”¨ï¼Œå†å¯¹åŸå§‹æ•°æ®è¿›è¡Œå¤„ç†ï¼Œæ¨¡æ‹Ÿç§»åŠ¨è®¾å¤‡å¯¹æ•°æ®æ·»åŠ å™ªå£° æ™ºèƒ½åˆçº¦ä¸­è®°å½•ç”¨æˆ·çš„æœ‰æ•ˆäº¤æ˜“ï¼Œç”¨äºç”¨æˆ·è·å–å¥–åŠ± å¦‚ä½•æ§åˆ¶fabricçš„å‡ºå—ï¼Ÿ å®ç°IPFS peerèŠ‚ç‚¹å’Œfedmlè®­ç»ƒèŠ‚ç‚¹ä¹‹é—´å¦‚ä½•è·å–å¯¹æ–¹çš„å…¬é’¥ï¼Œå¦‚ä½•é¿å…ä¸­é—´äººæ”»å‡» ç¬”è®°IPFS is a peer-to-peer distributed file system that enables distributed computing devices to connect with the same file system. åœ¨IPFSä¸Šè¿›è¡Œå­˜å‚¨ï¼ŒåŒºå—é“¾ä¸Šå­˜å‚¨HashæŒ‡é’ˆï¼Œç”¨äºæ‰¾åˆ°æ–‡ä»¶ï¼ˆå—å¤§å°é™åˆ¶ï¼‰ åœ¨ç¥ç»ç½‘ç»œçš„ä¸­é—´å±‚æ·»åŠ å™ªå£°(Îµ, Î´)-differentialï¼Œcnnå…¨è¿æ¥å±‚ä½œä¸ºå™ªå£°æå–å™¨ å…±è¯†æ–¹æ¡ˆæ˜¯åŸºäºè‚¡ä»½è¯æ˜ï¼ˆPOSï¼‰å’Œæ‹œå åº­å¼å®¹é”™ï¼ˆBFTï¼‰ leaderæ˜¯å¸å æ¯”æœ€é«˜çš„èŠ‚ç‚¹ï¼Œå‡ºå—éœ€æ±‚committeeèŠ‚ç‚¹è¶…è¿‡2/3éªŒè¯åŒæ„ï¼ŒcommitteeèŠ‚ç‚¹å¹¿æ’­å—ã€‚ ä¸Šä¼ æ–°æ¨¡å‹çš„è¿‡ç¨‹ çŸ¿å·¥éªŒè¯ä¸Šè½½æ¨¡å‹çš„æœ‰æ•ˆæ€§ï¼šçŸ¿å·¥éªŒè¯ä¸Šä¼ æ¨¡å‹çš„ç­¾åï¼Œæœ‰æ•ˆåˆ™å°†äº¤æ˜“æ”¾å…¥äº¤æ˜“æ± ã€‚çŸ¿å·¥ç»„æˆçš„Committee ä½¿ç”¨Multi-KruméªŒè¯æ± ä¸­çš„æ‰€æœ‰äº¤æ˜“ï¼Œå¹¶æ¥å—åˆæ³•çš„æ›´æ–°ã€‚é¢†å¯¼è€…ç”ŸæˆåŒ…å«æ–°æ¨¡å‹ï¼ˆæ¨¡å‹hash/ifpsåœ°å€ï¼‰çš„æ–°å—ã€‚ leaderæ›´æ–°æ¨¡å‹ æ¿€åŠ±æœºåˆ¶å½’ä¸€åŒ–æ–¹æ³•","link":"/home/2022/10/22/fedfab/fabric/5.%E8%AE%BA%E6%96%87/"},{"title":"fabric-4.åˆ›å»ºca","text":"å®˜æ–¹æ•™ç¨‹åˆ›å»ºcaèŠ‚ç‚¹ å‚è€ƒæ•™ç¨‹ ç¬¬ä¸€æ¬¡å¯åŠ¨CAæ—¶ï¼Œå®ƒæŸ¥æ‰¾fabric-ca-server-config.yamlæ–‡ä»¶ï¼Œå…¶ä¸­åŒ…å«CAé…ç½®å‚æ•°ã€‚ ç¼–å†™åˆ›å»ºcaçš„docker-composeæ–‡ä»¶1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586version: '3.7'networks: fed_fab: name: fabric_fedmlservices: ca_org1: image: hyperledger/fabric-ca:latest labels: service: hyperledger-fabric environment: - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server - FABRIC_CA_SERVER_CA_NAME=ca-org1 - FABRIC_CA_SERVER_TLS_ENABLED=true - FABRIC_CA_SERVER_PORT=8050 - FABRIC_CA_SERVER_OPERATIONS_LISTENADDRESS=0.0.0.0:18050 ports: - &quot;8050:8050&quot; - &quot;18050:18050&quot; command: sh -c 'fabric-ca-server start -b admin:adminpw -d' volumes: - ../crypto-config/fabric-ca/org1:/etc/hyperledger/fabric-ca-server container_name: ca_org1 networks: - fed_fab ca_org2: image: hyperledger/fabric-ca:latest labels: service: hyperledger-fabric environment: - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server - FABRIC_CA_SERVER_CA_NAME=ca-org2 - FABRIC_CA_SERVER_TLS_ENABLED=true - FABRIC_CA_SERVER_PORT=9050 - FABRIC_CA_SERVER_OPERATIONS_LISTENADDRESS=0.0.0.0:19050 ports: - &quot;9050:9050&quot; - &quot;19050:19050&quot; command: sh -c 'fabric-ca-server start -b admin:adminpw -d' volumes: - ../crypto-config/fabric-ca/org2:/etc/hyperledger/fabric-ca-server container_name: ca_org2 networks: - fed_fab ca_orderer: image: hyperledger/fabric-ca:latest labels: service: hyperledger-fabric environment: - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server - FABRIC_CA_SERVER_CA_NAME=ca-orderer - FABRIC_CA_SERVER_TLS_ENABLED=true - FABRIC_CA_SERVER_PORT=7051 - FABRIC_CA_SERVER_OPERATIONS_LISTENADDRESS=0.0.0.0:17051 ports: - &quot;7051:7051&quot; - &quot;17051:17051&quot; command: sh -c 'fabric-ca-server start -b admin:adminpw -d' volumes: - ../crypto-config/fabric-ca/ordererOrg:/etc/hyperledger/fabric-ca-server container_name: ca_orderer networks: - fed_fab ca_tls: image: hyperledger/fabric-ca:latest labels: service: hyperledger-fabric environment: - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server - FABRIC_CA_SERVER_CA_NAME=ca-orderer - FABRIC_CA_SERVER_TLS_ENABLED=true - FABRIC_CA_SERVER_PORT=7054 - FABRIC_CA_SERVER_OPERATIONS_LISTENADDRESS=0.0.0.0:17054 ports: - &quot;7054:7054&quot; - &quot;17054:17054&quot; command: sh -c 'fabric-ca-server start -b admin:adminpw -d' volumes: - ../crypto-config/fabric-ca/tls-ca:/etc/hyperledger/fabric-ca-server container_name: ca_tls networks: - fed_fab å¯åŠ¨caèŠ‚ç‚¹1docker-compose -f compose/compose-ca.yaml up -d å¯ä»¥çœ‹åˆ°å®ƒç”Ÿæˆäº†å®¹å™¨ï¼Œå¹¶åœ¨../crypto-configæ–‡ä»¶å¤¹ä¸‹ç”Ÿæˆäº†å„ä¸ªèŠ‚ç‚¹çš„è¯ä¹¦ç­‰æ–‡ä»¶ ä¿®æ”¹test-networkä¸­çš„registerEnroll.shå¹¶æ‰§è¡Œ1234. ./crypto-config/fabric-ca/registerEnroll.shcreateOrg1createOrg2createOrderer å…¶ä»–æ­¥éª¤åˆ›å»ºå¥½caåï¼Œå°±å¯ä»¥éƒ¨ç½²ç½‘ç»œèŠ‚ç‚¹ï¼Œchaincodeï¼Œå¹¶ä½¿ç”¨apiè°ƒç”¨é“¾ç ï¼Œå‚è€ƒtest-networkä¸­çš„æ“ä½œï¼Œå°†networkåˆ é™¤å¹²å‡€ï¼Œå°†ç”Ÿæˆç½‘ç»œå’Œé”€æ¯ç½‘ç»œæ•´ç†æˆè„šæœ¬/scripts/networkup.shå’Œ/scripts/networkdown.sh","link":"/home/2022/10/22/fedfab/fabric/4.%E5%88%9B%E5%BB%BAca/"},{"title":"fabric-8.yaml-requests","text":"Yaml-Requests åœ°å€","link":"/home/2022/10/22/fedfab/fabric/8.yaml-requests/"},{"title":"fabric-9.æœåŠ¡å™¨é…ç½®","text":"centos yumé”™è¯¯1é”™è¯¯ï¼šä¸º repo 'appstream' ä¸‹è½½å…ƒæ•°æ®å¤±è´¥ : Cannot prepare internal mirrorlist: No URLs in mirrorlist å‚è€ƒ12sudo sed -i -e &quot;s|mirrorlist=|#mirrorlist=|g&quot; /etc/yum.repos.d/CentOS-*sudo sed -i -e &quot;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&quot; /etc/yum.repos.d/CentOS-* æŸ¥çœ‹æ˜¾å¡1lspci | grep -i vga æ²¡æœ‰æ‰¾åˆ°åˆé€‚çš„æ˜¾å¡é©±åŠ¨ ä½¿ç”¨å‘½ä»¤ç™»å½•æ ¡å›­ç½‘1curl --data ./pwd http://10.3.8.211/login pwdç”¨url-encodingç¼–å†™ä»¥ä¸‹å†…å®¹12user: 'å­¦å·'pass: 'å¯†ç ' hostsæ–‡ä»¶é…ç½®123456789101112131410.112.242.228 lab.server210.112.144.78 lab.server110.128.196.184 tt-HP10.128.196.184 orderer.fedfab.com10.128.196.184 peer0.org2.fedfab.com10.112.144.78 peer0.org1.fedfab.com10.112.144.78 peer1.org1.fedfab.com10.112.144.78 peer2.org1.fedfab.com10.128.196.184 fedml.server10.112.144.78 fedml.worker110.112.144.78 fedml.worker210.112.144.78 fedml.worker3 åœ¨æ‰€æœ‰ä¸»æœºï¼Œfabricçš„dockerä¸­éƒ½é…ç½®ä¸€é fabricå¤šæœºæ­å»ºå‚è€ƒ docker composeæ–‡ä»¶ä¸­å»æ‰å…¶ä»–æœºå™¨çš„çš„volumesï¼Œpeerï¼Œcliï¼Œorderer ä½¿ç”¨scpä¼ é€è¯ä¹¦ï¼Œ*.blockï¼Œæ‰“åŒ…å¥½çš„é“¾ç ç­‰æ–‡ä»¶ 1scp fedfab.tar.gz tt@tt-HP:/home/tt/Desktop/fabric/my-network/nodes/mtemp éœ€è¦ä½¿ç”¨CouchDB org1çš„serviceèŠ‚ç‚¹ä¸‹å¢åŠ  123456789services: couchdb0.org1.fedfab.com: container_name: couchdb0.org1.fedfab.com image: couchdb:3.1 environment: - COUCHDB_USER=admin - COUCHDB_PASSWORD=adminpw ports: - 5984:5984 org2çš„serviceèŠ‚ç‚¹ä¸‹å¢åŠ  123456789services: couchdb0.org2.fedfab.com: container_name: couchdb0.org2.fedfab.com image: couchdb:3.1 environment: - COUCHDB_USER=admin - COUCHDB_PASSWORD=adminpw ports: - 5984:5984 peerçš„environmentsä¸‹å¢åŠ  12345- CORE_LEDGER_STATE_STATEDATABASE=CouchDB- CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=couchdb0.org1.fedfab.com:5984 ## org1 peer- CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=couchdb0.org2.fedfab.com:5984 ## org2 peer- CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME=admin- CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD=adminpw peerçš„depends_onä¸‹å¢åŠ  12- couchdb0.org1.fedfab.com ## org1 peer- couchdb0.org2.fedfab.com ## org2 peer ä¸ä½¿ç”¨networksï¼Œä½¿ç”¨extra-hosts123456extra_hosts: - &quot;orderer.fedfab.com:10.128.196.184&quot; - &quot;peer0.org1.fedfab.com:10.112.144.78&quot; - &quot;peer1.org1.fedfab.com:10.112.144.78&quot; - &quot;peer2.org1.fedfab.com:10.112.144.78&quot; - &quot;peer0.org2.fedfab.com:10.128.196.184&quot; fedmlæ˜¯å¦éœ€è¦ï¼Ÿ debugè®°å½•è°ƒç”¨chaincodeå¤±è´¥ chaincode çš„containerå¯åŠ¨æ—¶ï¼Œä¸å¯¹åº”peerå»ºç«‹tcpè¿æ¥å¤±è´¥ docker-composeçš„peerèŠ‚ç‚¹ä¸Šï¼Œå»ºç«‹tcpçš„ç«¯å£ä¸å®é™…ç«¯å£çš„æ˜ å°„","link":"/home/2022/10/22/fedfab/fabric/9.%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"title":"fabric-6.IPFSçš„å®‰è£…ä¸ä½¿ç”¨","text":"IPFS å®‰è£…ä¸‹è½½åœ°å€å®‰è£…æ•™ç¨‹ipfsæ­å»ºç§æœ‰ç½‘ç»œ Kubo CLIKubo RPC API","link":"/home/2022/10/22/fedfab/fabric/6.IPFS%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"title":"fabric-7.ä½¿ç”¨neståç«¯æ¡†æ¶","text":"æ•™ç¨‹","link":"/home/2022/10/22/fedfab/fabric/7.%E4%BD%BF%E7%94%A8nest%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"title":"fedml-1.é…ç½®ï¼†è¿è¡Œ&amp;è‡ªå®šä¹‰","text":"å®˜æ–¹æ–‡æ¡£ repo å…‹éš†fedmlåº“1git clone https://github.com/FedML-AI/FedML.git å‚é˜…æºç  å‚è€ƒæ ·ä¾‹ï¼Œæµ‹è¯•ç¯å¢ƒ FedML/iot/anomaly_detection_for_cybersecurity FedML/python/setup.py wsl - cuda å‚è€ƒ å®‰è£…æ”¯æŒwslçš„Nvidiaé©±åŠ¨ ä¸‹è½½åœ°å€ ä¸‹è½½å®‰è£…cuda ä¸è¦ä¸‹è½½æœ€æ–°ç‰ˆ11.7ï¼Œpytorchç›®å‰ä¸æ”¯æŒ1234sudo apt updatesudo apt install build-essential #å®‰è£…c++ makeç­‰ç¯å¢ƒwget https://developer.download.nvidia.com/compute/cuda/11.6.2/local_installers/cuda_11.6.2_510.47.03_linux.runsudo bash cuda_11.6.2_510.47.03_linux.run ç¯å¢ƒå˜é‡ åœ¨ç›®å½•~/.bashrcä¸‹ è¿½åŠ 123export CUDA_HOME=/usr/local/cudaexport PATH=$PATH:$CUDA_HOME/binexport LD_LIBRARY_PATH=/usr/local/cuda-11.7/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}} ç”Ÿæ•ˆï¼Œå¹¶å®‰è£…éœ€è¦çš„åº“12source ~/.bashrcsudo apt-get install freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev libgl1-mesa-glx libglu1-mesa libglu1-mesa-dev æ£€æŸ¥æ˜¯å¦æˆåŠŸ1nvcc -V 12345nvcc: NVIDIA (R) Cuda compiler driverCopyright (c) 2005-2022 NVIDIA CorporationBuilt on Tue_May__3_18:49:52_PDT_2022Cuda compilation tools, release 11.7, V11.7.64Build cuda_11.7.r11.7/compiler.31294372_0 å®‰è£… cudnnä¸‹è½½å®‰è£… å‚è€ƒ 123456sudo apt-get install zlib1ghttps://developer.nvidia.com/rdp/cudnn-downloadtar -xvf cudnn-linux-x86_64-8.4.1.50_cuda11.6-archive.tar.xzsudo cp cudnn-*-archive/include/cudnn*.h /usr/local/cuda/includesudo cp -P cudnn-*-archive/lib/libcudnn* /usr/local/cuda/lib64sudo chmod a+r /usr/local/cuda/include/cudnn*.h /usr/local/cuda/lib64/libcudnn* åæ¥å‘ç°è¿™ç§æ–¹å¼ä½¿ç”¨cnnæ—¶ä¼šæŠ¥é”™ï¼Œæ‰¾ä¸åˆ°cudnn cnnçš„åŠ¨æ€é“¾æ¥åº“ï¼Œæ”¹ç”¨ä»¥ä¸‹æ–¹æ³• 1conda install -c nvidia cudnn Table 1. Supported NVIDIA Hardware and CUDA Version cuDNN Package Supported NVIDIA Hardware CUDA Toolkit Version CUDA Compute Capability Supports static linking?1 cuDNN 8.4.1 for CUDA 11.x2 NVIDIA Ampere Architecture NVIDIA Turingâ„¢ NVIDIA Voltaâ„¢ NVIDIA Pascalâ„¢ NVIDIA MaxwellÂ® NVIDIA Keplerâ„¢ 11.7 SM 3.5 and later Yes 11.6 11.5 11.4 11.3 11.2 No 11.1 11.0 cuDNN 8.4.1 for CUDA 10.2 NVIDIA Turing NVIDIA Volta Xavierâ„¢ NVIDIA Pascal NVIDIA Maxwell NVIDIA Kepler 10.2 SM 3.0 and later Yes å®‰è£…é…ç½®fedml å‚è€ƒ-ï¼ˆbilibiliè§†é¢‘çš„æ–¹æ³•å·²ç»è¿‡æ—¶ï¼‰ å®‰è£…Miniconda12345wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh./Miniconda3-latest-Linux-x86_64.sh## æœ€åä¸€æ­¥é€‰yesï¼Œè®©è„šæœ¬è‡ªåŠ¨é…ç½®ç¯å¢ƒå˜é‡## æ ¹æ®è¾“å‡ºçš„å†…å®¹å†³å®šä¸‹é¢sourceçš„æ–‡ä»¶source /root/.bashrc æ·»åŠ Minicondaæº123456conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forgeconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/conda config --set show_channel_urls yes #è®¾ç½®æœç´¢æ—¶æ˜¾ç¤ºé€šé“åœ°å€ å®‰è£…fedml1234conda create --name fedml python=3.7conda activate fedmlconda install --name fedml pippip install fedml -i https://pypi.douban.com/simple å¤‡å¿˜123456å¸¸ç”¨pipæºï¼šè±†ç“£ï¼šhttps://pypi.douban.com/simpleé˜¿é‡Œï¼šhttps://mirrors.aliyun.com/pypi/simpleä¸­å›½ç§‘æŠ€å¤§å­¦ ï¼šhttps://pypi.mirrors.ustc.edu.cn/simple/æ¸…åå¤§å­¦ï¼š https://pypi.tuna.tsinghua.edu.cn/simple/ä¸­å›½ç§‘å­¦æŠ€æœ¯å¤§å­¦ ï¼šhttps://pypi.mirrors.ustc.edu.cn/simple/ pythonåŒ…ï¼šwasabi-æ§åˆ¶å°æ‰“å°å’Œæ ¼å¼åŒ–å·¥å…·åŒ… å®‰è£…fedmlç¯å¢ƒ è¿›å…¥FEDMLä»“åº“ï¼ŒFedML/pythonï¼Œè¿è¡Œsetup.py pytorchå®‰è£…åœ°å€ï¼Œæ ¹æ®cudaç‰ˆæœ¬é€‰æ‹©å‘½ä»¤ï¼Œå»æ‰ -c forgeï¼ˆä¸ä»å®˜ç½‘ä¸‹è½½ï¼‰1python3 setup.py install å¸è½½pytorchï¼Œé‡æ–°æŒ‰ç…§cudaç‰ˆæœ¬è¿›è¡Œå®‰è£… 12conda uninstall *torch* cudatoolkitconda install pytorch torchvision torchaudio cudatoolkit=11.6 è¿è¡Œdemoiot è¿è¡Œiotç‰©è”ç½‘demo server12conda activate fedmlbash run_server.sh client-112conda activate fedmlbash run_client.sh 1 client-212conda activate fedmlbash run_client.sh 2 åæ¥å‘ç°è¿™ä¸ªdemoé€‚ç”¨äºæ ‘è“æ´¾ã€Jeston Nanoè®¾å¤‡ï¼Œéœ€è¦è¿›è¡Œä¸€å®šçš„é…ç½® è¿™ä¸ªæ ·ä¾‹ä¸­æœ‰è‡ªå®šä¹‰data loaderå’Œtrainerï¼Œæ¯”è¾ƒæœ‰å‚è€ƒä»·å€¼ mpi_torch_fedopt_mnist_lr_example é…ç½®æ–‡ä»¶ä¸­ï¼Œä»¥simulationæ¨¡å¼è¿è¡Œçš„ ä½ç½®ï¼Œä»¥simulationæ¨¡å¼è¿è¡Œï¼Œå•è¿›ç¨‹ 1bash run_step_by_step_example.sh 2 å‚æ•°ä¸º2æ—¶å¯ä»¥å®Œæˆè®­ç»ƒï¼Œå‚æ•°ï¼ˆå³workerï¼‰è¿‡å¤§ï¼Œä¼šå‡ºç°ä»¥ä¸‹æç¤ºï¼Œæ€€ç–‘æ˜¯å†…å­˜ä¸å¤Ÿ12345678910==================================================================================== BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES= PID 5218 RUNNING AT tt= EXIT CODE: 9= CLEANING UP REMAINING PROCESSES= YOU CAN IGNORE THE BELOW CLEANUP MESSAGES===================================================================================YOUR APPLICATION TERMINATED WITH THE EXIT STRING: Killed (signal 9)This typically refers to a problem with your application.Please see the FAQ page for debugging suggestions è®­ç»ƒå®Œæˆåä¼šåœ¨ç›®å½•./tmp/ä¸‹ç”Ÿæˆä¸€ä¸ªæ¨¡å‹æ–‡ä»¶fedmlï¼Œæ‰§è¡Œcat1cat fedml è¾“å‡ºä¸º12training is finished!&lt;fedml.arguments.Arguments object at 0x7ff03c13b210&gt; ä½¿ç”¨GPUè¿›è¡Œè®­ç»ƒä¿®æ”¹é…ç½®æ–‡ä»¶ ä¿®æ”¹config/fedml_config.yamlæ–‡ä»¶device_argsæ ‡ç­¾ä¸‹çš„å†…å®¹12345device_args: worker_num: 3 using_gpu: true gpu_mapping_file: config/gpu_mapping.yaml #mappingæ–‡ä»¶ä½ç½® gpu_mapping_key: mapping_tt #ä½¿ç”¨çš„mapping ä¿®æ”¹mappingæ–‡ä»¶ åœ¨æ–‡ä»¶config/gpu_mapping.yamlä¸‹å¢åŠ èŠ‚ç‚¹mapping_tt 12mapping_tt: tt: [4] #åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹ttï¼Œä¸€ä¸ªgpu å¢åŠ èŠ‚ç‚¹çš„æ ¼å¼å¦‚ä¸‹ï¼Œä¸ºæ¯ä¸ªhostnameæŒ‡å®šåœ¨æ¯ä¸ªgpuä¸‹æœ‰å¤šå°‘è¿›ç¨‹ 12345## config_cluster0:## host_name_node0: [num_of_processes_on_GPU0, num_of_processes_on_GPU1, num_of_processes_on_GPU2, num_of_processes_on_GPU3, ..., num_of_processes_on_GPU_n]## host_name_node1: [num_of_processes_on_GPU0, num_of_processes_on_GPU1, num_of_processes_on_GPU2, num_of_processes_on_GPU3, ..., num_of_processes_on_GPU_n]## ......## host_name_node_m: [num_of_processes_on_GPU0, num_of_processes_on_GPU1, num_of_processes_on_GPU2, num_of_processes_on_GPU3, ..., num_of_processes_on_GPU_n] è¿è¡Œï¼Œå‰é¢é…ç½®äº†4ä¸ªè¿›ç¨‹ï¼Œworker_numé…ç½®ä¸º3ï¼Œè¿™é‡Œå‚æ•°å°±å†™3ï¼Œ 3ä¸ªworker + 1ä¸ªserver 1bash run_step_by_step_example.sh 3 è¿‡ç¨‹ä¸­åœ¨bashä¸­çœ‹åˆ°è¾“å‡º 12[FedML-Server(0) @device-id-0] [Thu, 28 Jul 2022 20:54:06] [INFO] [gpu_mapping_mpi.py:51:mapping_processes_to_gpu_device_from_yaml_file_mpi] process_id = 2, GPU device = cuda:0[FedML-Server(0) @device-id-0] [Thu, 28 Jul 2022 20:54:06] [INFO] [device.py:78:get_device] device = cuda:0 taskmgrä¸­æŸ¥çœ‹ç‹¬æ˜¾å ç”¨æƒ…å†µ è¯´æ˜ç¡®å®ä½¿ç”¨äº†gpu cross_silo è¿è¡Œ éå•è¿›ç¨‹æ¨¡æ‹Ÿï¼Œå¤šä¸ªè®¾å¤‡è¿è¡Œ config/fedml_config.yaml é…ç½®èŠ‚ç‚¹comm_args123comm_args: backend: &quot;GRPC&quot; grpc_ipconfig_path: config/grpc_ipconfig.csv grpc_ipconfig.csv å®‰è£…pip install grpcioï¼Œä½¿ç”¨grpcåè®®è¿›è¡Œé€šä¿¡ åœ¨/configä¸‹åˆ›å»ºè¯¥æ–‡ä»¶ï¼Œå†™å…¥ç¼–å·-ipï¼Œ0ä¸ºserverï¼Œ1...nä¸ºworker receiver_id ip 0 127.0.0.1 1 127.0.0.1 2 127.0.0.1 ç»“æœ æ²¡æœ‰æ‰¾åˆ°è¾“å‡ºçš„æ¨¡å‹æ–‡ä»¶ï¼Œåªåœ¨æœ€åä¸€è½®ç»“æŸåæ‰¾åˆ°äº†ä»¥ä¸‹è¾“å‡º123[FedML-Server(0) @device-id-0] [Fri, 29 Jul 2022 22:54:08] [INFO] [fedml_aggregator.py:195:test_on_server_for_all_clients] ################test_on_server_for_all_clients : 49[FedML-Server(0) @device-id-0] [Fri, 29 Jul 2022 22:54:12] [INFO] [fedml_aggregator.py:225:test_on_server_for_all_clients] {'training_acc': 0.796526336274001, 'training_loss': 1.8660167525693983}[FedML-Server(0) @device-id-0] [Fri, 29 Jul 2022 22:54:13] [INFO] [fedml_aggregator.py:257:test_on_server_for_all_clients] {'test_acc': 0.8005698005698005, 'test_loss': 1.8635211240936371} fedmlè‡ªå®šä¹‰fedmlè¿è¡Œå‚æ•° fedmlè¿è¡Œæ—¶éœ€è¦å‡ ä¸ªå‚æ•° å‚æ•° å«ä¹‰ å¯é€‰å€¼ â€“cf é…ç½®æ–‡ä»¶ / â€“rank åºå·ï¼Œserverä¸º0 0,1,2,3 â€“role server æˆ– client server, client fedmlè¿è¡Œæµç¨‹1234567891011121314args = fedml.init()## init devicedevice = fedml.device.get_device(args)## load datadataset, output_dim = fedml.data.load(args)## load modelmodel = fedml.model.create(args, output_dim)## start trainingfedml_runner = FedMLRunner(args, device, dataset, model)fedml_runner.run() DataLoader, Model, Traineréƒ½æ˜¯å¯ä»¥è‡ªå®šä¹‰çš„ å‚è€ƒ DataLoaderçš„è‡ªå®šä¹‰ æ”¯æŒMNNï¼Œpytorchçš„DataLoader è¾“å‡ºæ•°æ®é›†å’Œè¾“å‡ºçš„ç»´æ•° æ¨¡å‹çš„è‡ªå®šä¹‰ æ”¯æŒpytorchçš„ç¥ç»ç½‘ç»œæ¨¡å‹ï¼Œtorch.nn Trainerçš„è‡ªå®šä¹‰1234567891011121314151617181920from fedml.core import ClientTrainerclass MyModelTrainer(ClientTrainer): #ç»§æ‰¿ClientTrainer def get_model_params(self): return self.model.cpu().state_dict() def set_model_params(self, model_parameters): self.model.load_state_dict(model_parameters) def train(self, train_data, device, args): #å®ç°æ¨¡å‹çš„è®­ç»ƒ pass def test(self, test_data, device, args): pass def test_on_the_server( self, train_data_local_dict, test_data_local_dict, device, args=None ) -&gt; bool: #å®ç°å¯¹æ¨¡å‹çš„è¯„ä¼° return True ç”¨qemuè™šæ‹Ÿæœºæ¨¡æ‹Ÿå¤šå°æœºå™¨ï¼ˆæœªå®Œæˆï¼‰å®‰è£… å‚è€ƒè¿æ¥ Ninjaçš„å®‰è£…1sudo apt install ninja-build pkg-config1 12345wget https://download.qemu.org/qemu-7.1.0-rc0.tar.xztar xvJf qemu-7.1.0-rc0.tar.xzcd qemu-7.1.0-rc0./configuremake ä½¿ç”¨è™šæ‹Ÿæœºç¯å¢ƒï¼Œéœ€è¦å¯¹qemué…ç½®æ˜¾å¡ç›´é€š","link":"/home/2022/10/22/fedfab/fedml/1.%E9%85%8D%E7%BD%AE%EF%BC%86%E8%BF%90%E8%A1%8C&%E8%87%AA%E5%AE%9A%E4%B9%89/"},{"title":"fedml-2.Dockerå¤šå®¹å™¨é…ç½®","text":"Dockerå®‰è£…1curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun ä¸­é—´é‡åˆ°è¾“å‡ºï¼Œæç¤ºå»ºè®®ä½¿ç”¨for windows12WSL DETECTED: We recommend using Docker Desktop for Windows.Please get Docker Desktop from https://www.docker.com/products/docker-desktop åˆ›å»ºå®¹å™¨å¹¶é…ç½®ç¯å¢ƒéªŒè¯æ˜¯å¦å¯ä»¥ä½¿ç”¨gpu å®˜æ–¹å‚è€ƒ1docker run --gpus all nvcr.io/nvidia/k8s/cuda-sample:nbody nbody -gpu -benchmark pull fedmlé•œåƒ1docker pull fedml/fedml:cuda-11.4.0-devel-ubuntu20.04 ç¼–å†™è¿è¡Œè„šæœ¬å¹¶è¿è¡Œ1234567891011121314151617181920212223FEDML_DOCKER_IMAGE=fedml/fedml:cuda-11.4.0-devel-ubuntu20.04WORKSPACE=~/Desktop/docker_workspaceFEDML_REPO=~/Desktop/FedMLDATA=~/fedml_dataID=$1IP=$2NUM=$3HOSTNAME=$4sudo docker run -itd -v $WORKSPACE:/home/workspace -v $FEDML_REPO:/home/fedml_repo -v $DATA:/root/fedml_data \\--shm-size=64g --ulimit nofile=65535 --ulimit memlock=-1 --privileged \\--env FEDML_NODE_INDEX=$ID \\--env WORKSPACE=$WORKSPACE \\--env FEDML_NUM_NODES=$NUM \\--env FEDML_MAIN_NODE_INDEX=0 \\--env FEDML_RUN_ID=$ID \\--env FEDML_MAIN_NODE_PRIVATE_IPV4_ADDRESS=$IP \\--gpus all \\--hostname $HOSTNAME \\-u fedml --net=host \\$FEDML_DOCKER_IMAGE \\/bin/bash åˆ›å»ºä¸¤ä¸ªå®¹å™¨12bash run_fedml_docker.sh 1 2 127.0.0.1 worker1bash run_fedml_docker.sh 2 2 127.0.0.1 worker2 ä¿®æ”¹GPU MAPPING1234mapping_default: tt: [1] worker1: [1] worker2: [1] åˆå§‹åŒ–fedml åˆ†åˆ«åœ¨ä¸¤ä¸ªdockerå†…è¿è¡Œ1sudo /home/code/setup_docker.sh æ›´æ–°fedml è‡ªå¸¦çš„pytorchæ”¯æŒçš„gpuç®—åŠ›ç­‰çº§å¤ªä½ï¼Œéœ€è¦æ›´æ–° åœ¨ä¸»èŠ‚ç‚¹ä¸‹å¯åŠ¨server1bash run_server.sh åœ¨å®¹å™¨ä¸­å¯åŠ¨client12bash run_client.sh 1bash run_client.sh 2 å¯ä»¥æ­£å¸¸è¿è¡Œï¼Œä¹Ÿå¯ä»¥æ­£å¸¸è°ƒç”¨gpu ä½¿ç”¨Dockerfileé¿å…setup_docker.sh èŠ‚çœç©ºé—´ é¿å…é‡å¤ä¸‹è½½ç¯å¢ƒ æ–°å»ºä¸€ä¸ªç©ºç›®å½•ï¼Œåœ¨å…¶ä¸­åˆ›å»ºæ–‡ä»¶Dockerfile1234FROM fedml/fedml:cuda-11.4.0-devel-ubuntu20.04RUN python -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade pipRUN pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simpleRUN pip3 install --upgrade fedml å¯¹äºç®—åŠ›è¾ƒé«˜çš„gpuï¼Œæ›´æ–°pytorch 12345678FROM fedml/fedml:cuda-11.4.0-devel-ubuntu20.04RUN python -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade pipRUN pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simpleRUN pip3 install --upgrade fedmlRUN pip3 uninstall -y torchRUN pip3 uninstall -y torchaudioRUN pip3 uninstall -y torchvisionRUN pip3 install torch torchvision torchaudio --extra-index-url https://download.pytorch.org/whl/cu116 #3050TI åœ¨è¯¥ç›®å½•ä¸‹æ‰§è¡Œ1sudo docker build -t fedml:tt . ä½¿ç”¨fedml:ttåˆ›å»ºcontainer1234567891011121314151617181920212223FEDML_DOCKER_IMAGE=fedml:tt ### è¿™é‡ŒWORKSPACE=~/Desktop/docker_workspaceFEDML_REPO=~/Desktop/FedMLDATA=~/fedml_dataID=$1IP=$2NUM=$3HOSTNAME=$4sudo docker run -itd -v $WORKSPACE:/home/workspace -v $FEDML_REPO:/home/fedml_repo -v $DATA:/root/fedml_data \\--shm-size=64g --ulimit nofile=65535 --ulimit memlock=-1 --privileged \\--env FEDML_NODE_INDEX=$ID \\--env WORKSPACE=$WORKSPACE \\--env FEDML_NUM_NODES=$NUM \\--env FEDML_MAIN_NODE_INDEX=0 \\--env FEDML_RUN_ID=$ID \\--env FEDML_MAIN_NODE_PRIVATE_IPV4_ADDRESS=$IP \\--gpus all \\--hostname $HOSTNAME \\-u fedml --net=host \\$FEDML_DOCKER_IMAGE \\/bin/bash å®¹å™¨åˆ›å»ºè„šæœ¬ åˆ›å»ºå®¹å™¨å¹¶å¼€å§‹è§‚æµ‹gpuä½¿ç”¨ç‡123456789sudo docker stop $(sudo docker ps -a | awk '{ print $1}' | tail -n +2)sudo docker container pruneread -n1 -p &quot;Press any key to create containers...&quot;./run_fedml_docker.sh 0 127.0.0.1 3 server./run_fedml_docker.sh 1 127.0.0.1 3 worker1./run_fedml_docker.sh 2 127.0.0.1 3 worker2docker ps -aread -n1 -p &quot;Press any key to continue...&quot;watch -n 1 nvidia-smi","link":"/home/2022/10/22/fedfab/fedml/2.Docker%E5%A4%9A%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"title":"fedml-3.Runneræºç é˜…è¯»","text":"wandb çš„ä½¿ç”¨ åœ¨wandbå®˜ç½‘projecté¡µé¢åˆ›å»ºå·¥ç¨‹ è·å–wandb_key é…ç½®config.yaml enable - true wandb key priject name123456tracking_args: log_file_dir: ./log enable_wandb: true #enable wandb_key: e3be1b9a8ab45f14a6ff454009bc7ca07b8792ba #key wandb_project: fedml_mnist_test #project name wandb_name: fedml_torch_fedavg_mnist_lr è¿è¡Œ è¿è¡Œæ—¶é€‰æ‹©2ï¼Œå°†keyå†è¾“å…¥ä¸€æ¬¡1234567wandb: (1) Create a W&amp;B accountwandb: (2) Use an existing W&amp;B accountwandb: (3) Dont visualize my resultswandb: Enter your choice: 2wandb: You chose 'Use an existing W&amp;B account'wandb: You can find your API key in your browser here: https://wandb.ai/authorizewandb: Paste an API key from your profile and hit enter, or press ctrl+c to quit: wandbç»“æœ åœ¨ç»ˆç«¯è¾“å‡ºäº†1234567891011121314151617181920212223242526272829303132333435363738394041424344wandb: Waiting for W&amp;B process to finish... (success).wandb: wandb: wandb: Run history:wandb: AggregationTime â–‚â–ƒâ–ƒâ–‚â–‚â–ƒâ–ƒâ–ƒâ–ƒâ–‚â–ƒâ–ƒâ–â–ƒâ–ƒâ–‚â–ƒâ–‡â–ƒâ–ƒâ–ƒâ–‡â–‚â–ƒâ–ƒâ–‚â–ƒâ–ƒâ–ˆâ–ƒâ–‚â–‚â–‚â–ƒâ–ƒâ–ƒâ–ƒâ–â–‚â–‚wandb: BenchmarkStart â–wandb: BusyTime â–â–„â–„â–„â–„â–ƒâ–…â–ƒâ–‚â–„â–†â–ƒâ–ƒâ–‡â–„â–ƒâ–…â–ˆâ–ƒâ–†â–„â–…â–…â–…â–ƒâ–‚â–„â–…â–„â–ƒâ–„â–ƒâ–„â–„â–ƒâ–‚â–„â–ƒâ–ƒâ–ˆwandb: Comm/recieve_delay_s3 â–ƒâ–â–‚â–â–‚â–‚â–â–‚â–‚â–‚â–â–‚â–‚â–â–ƒâ–„â–‚â–„â–‚â–‚â–â–ˆâ–‚â–‚â–‚â–‚â–„â–‚â–â–‚â–‚â–‚â–ƒâ–‚â–ƒâ–â–â–‚â–‚â–ƒwandb: Comm/send_delay â–ˆâ–ƒâ–‚â–â–â–â–ƒâ–‚â–‚â–â–‚â–†â–â–„â–‚â–ƒâ–…â–‚â–‚â–‚â–‚â–â–â–â–‚â–â–â–â–â–â–â–ƒâ–â–â–‚â–‚â–â–â–‚â–wandb: Comm/send_delay_mqtt â–ƒâ–†â–†â–‡â–†â–†â–‡â–†â–†â–†â–†â–†â–†â–†â–‚â–†â–†â–†â–†â–†â–†â–†â–†â–â–ˆâ–†â–†â–†â–†â–†â–â–†â–†â–â–â–†â–†â–†â–ˆâ–wandb: Communiaction/Send_Total â–ˆâ–ƒâ–‚â–â–â–â–ƒâ–‚â–‚â–â–‚â–†â–â–„â–‚â–ƒâ–…â–‚â–‚â–‚â–‚â–â–â–â–‚â–â–â–â–â–â–â–ƒâ–â–â–‚â–‚â–â–â–‚â–wandb: ListenStart â–wandb: MessageReceiveTime â–â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–„â–„â–„â–„â–„â–„â–„â–„â–…â–…â–…â–…â–…â–…â–…â–…â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–ˆâ–ˆwandb: PickleDumpsTime â–ˆâ–â–…â–â–â–â–‚â–†â–ƒâ–…â–‚â–ƒâ–…â–â–â–â–…â–â–†â–…â–â–â–…â–…â–â–„â–…â–…â–â–…â–…â–…â–â–â–…â–…â–…â–‚â–…â–wandb: Test/Acc â–â–„â–„â–…â–†â–†â–†â–ˆâ–ˆâ–ˆâ–ˆwandb: Test/Loss â–ˆâ–†â–…â–ƒâ–ƒâ–‚â–‚â–â–â–â–wandb: TotalTime â–wandb: Train/Acc â–â–„â–„â–…â–†â–†â–†â–ˆâ–ˆâ–ˆâ–ˆwandb: Train/Loss â–ˆâ–†â–…â–„â–ƒâ–‚â–‚â–â–â–â–wandb: UnpickleTime â–ˆâ–„â–„â–ƒâ–ˆâ–„â–„â–„â–„â–„â–‡â–‡â–„â–‡â–„â–â–„â–‡â–„â–â–„â–‡â–‡â–„â–‡â–‚â–„â–‡â–„â–„â–„â–„â–„â–„â–‡â–„â–„â–‚â–â–„wandb: round â–â–â–â–â–‚â–‚â–‚â–‚â–‚â–‚â–ƒâ–ƒâ–ƒâ–ƒâ–ƒâ–„â–„â–„â–„â–…â–…â–…â–…â–…â–…â–…â–†â–†â–†â–†â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–ˆâ–ˆâ–ˆwandb: wandb: Run summary:wandb: AggregationTime 0.00103wandb: BenchmarkStart 1660014268.494wandb: BusyTime 8.49421wandb: Comm/recieve_delay_s3 3.13148wandb: Comm/send_delay 0.40766wandb: Comm/send_delay_mqtt 4e-05wandb: Communiaction/Send_Total 0.40971wandb: ListenStart 1660014198.82541wandb: MessageReceiveTime 1660014798.21999wandb: PickleDumpsTime 0.00032wandb: Test/Acc 0.80057wandb: Test/Loss 1.86352wandb: TotalTime 607.89401wandb: Train/Acc 0.79653wandb: Train/Loss 1.86602wandb: UnpickleTime 0.00087wandb: round 49wandb: wandb: Synced exalted-eon-1: https://wandb.ai/tt_blockchain/fedml_mnist_test/runs/3850zs40wandb: Synced 5 W&amp;B file(s), 0 media file(s), 0 artifact file(s) and 0 other file(s)wandb: Find logs at: ./wandb/run-20220809_030244-3850zs40/logs åœ¨ç½‘é¡µä¸­è¾“å‡ºæƒ…å†µreport.pdf FedMLRunner è¯¥Runneræ˜¯é€šç”¨çš„runner æ ¹æ®args.training_typeè¿›è¡Œåˆå§‹åŒ– simulation cross silo cross device _init_simulation_runner æ ¹æ®argsä¸­çš„backendæ„é€ runner SP -&gt; SimulatorSingleProcess MPI -&gt; SimulatorMPI NCCL -&gt; SimulatorNCCL _init_cross_silo_runner æ ¹æ®args.roleä¸º clientorserveræ„é€ runner client -&gt; Client server -&gt; Sever _init_cross_device_runner args.role ä¸º severï¼Œæ„é€ ServerMNNï¼Œå¦åˆ™raise Exception Sever FedMLCrossSiloServer è‹¥federated_optimizerä¸ºFedAvgï¼Œtrainer = server_initializer.init_server è‹¥federated_optimizerä¸ºLSAï¼Œtrainer=FedML_LSA_Horizontal server_initializer.init_server åˆ›å»ºAggregator - èšé›†å™¨ï¼Œå¤„ç†è®­ç»ƒç›¸å…³çš„ä»»åŠ¡ï¼Œå°†Clientçš„æ¨¡å‹èšé›†å¹¶æ›´æ–°å…¨å±€æ¨¡å‹ åˆ›å»ºFedMLServerManager - æ”¶å‘ç½‘ç»œè¯·æ±‚ FedML_LSA_Horizontal æ ¹æ®client rank init serveræˆ–client init serverä¼šåˆ›å»ºAggregatorå’ŒServerManager init clientä¼šåˆ›å»ºTrainerå’ŒClientManagerï¼Œä¸€èˆ¬roleä¸ºserverï¼Œrankä¹Ÿæ˜¯0ï¼Œè¿™ä¸€æ­¥åº”è¯¥ä¸ä¼šèµ°åˆ° Client FedMLCrossSiloClient è‹¥federated_optimizerä¸ºFedAvgï¼Œtrainer = client_initializer.init_client è‹¥federated_optimizerä¸ºLSAï¼Œtrainer=FedML_LSA_Horizontal Aggregator FedMLAggregator é€šè¿‡cross siloæ‰¾åˆ°çš„ è¿˜æœ‰FedSegAggregatorã€BaseLocalAggregatorã€RobustAggregatorç­‰ å‡½æ•° add_local_trained_resultå’Œcheck_whether_all_receive add_local_trained_resultè´Ÿè´£è®°å½•localçš„è®­ç»ƒç»“æœ check_whether_all_receiveè´Ÿè´£æ£€æŸ¥æ˜¯å¦å…¨éƒ¨ä¸Šä¼ æœ¬åœ°æ¨¡å‹ï¼Œè‹¥æ˜¯ï¼Œåˆ™å°†å…¨éƒ¨flagç½®ä¸ºFalse aggregate è®¡ç®—å‡ºæ€»çš„è®­ç»ƒæ ·æœ¬æ•°ç›®ï¼ˆæ‰€æœ‰clientè®­ç»ƒçš„æ ·æœ¬æ•°ä¹‹å’Œï¼‰ æ ¹æ®æœ¬åœ°æ ·æœ¬æ•°/æ€»è®­ç»ƒæ•°è®¡ç®—æƒå€¼w æ ¹æ®æƒå€¼ç®—å‡ºæ¨¡å‹å‚æ•°çš„åŠ æƒå¹³å‡ æ›´æ–°å…¨å±€æ¨¡å‹ data_silo_selection è‹¥æ¯è½®è®­ç»ƒæ•°å’Œæ€»clientæ•°ç›¸åŒï¼Œåˆ™è¿”å›0...n-1ï¼Œå¦åˆ™éšæœºä»ä¸­éšæœºå¯»æ‰¾ä¸€éƒ¨åˆ† client_selection ä¹Ÿæ˜¯ä¸€ä¸ªéšæœºé€‰æ‹©ï¼Œå’Œä¸Šä¸€ä¸ªå·®ä¸å¤š client_sampling çœ‹èµ·æ¥å’Œdata_silo_selectionä¸€æ¨¡ä¸€æ · test_on_server_for_all_clients if self.trainer.test_on_the_server : return æ¯éš”nè½®ä¸€æ¬¡test æˆ– æœ€åä¸€è½®æ—¶è¿›è¡Œtest(å¯¹è®­ç»ƒé›†) å¯¹äºæ¯ä¸€ä¸ªclientï¼Œè®¡ç®—TP+TNï¼Œè®­ç»ƒä¸ªæ•°ï¼Œlossï¼Œå¹¶ä¿å­˜ è®¡ç®—æ€»çš„accå’Œlossï¼Œæ‰“logï¼Œè‹¥å¯ç”¨äº†wandbï¼Œåˆ™ä½¿ç”¨wandb apiè®°å½• å¯¹æµ‹è¯•é›†è¿›è¡Œæµ‹è¯•ï¼Œlogï¼Œwandbè®°å½• FedMLServerManagerçˆ¶ç±» ServerManagerå‡½æ•° __init__ æ ¹æ®backendå…·ä½“æŒ‡å®šçš„åè®®åç§°æ„é€ å¯¹åº”çš„CommunicationManager run æ‰§è¡Œregister_message_receive_handlersï¼ˆå­ç±»å®ç°ï¼‰ï¼Œç”¨äºæ³¨å†Œå­ç±»å®šä¹‰çš„å‡ ç§æ¶ˆæ¯å’Œæ¶ˆæ¯å¯¹åº”çš„callbackå‡½æ•°ï¼Œå½“æ”¶åˆ°å¯¹åº”æ¶ˆæ¯ç±»å‹æ—¶è°ƒç”¨ç›¸åº”å‡½æ•° æ‰§è¡Œå…·ä½“åè®®å¯¹åº”çš„CommunicationManagerçš„handle_receive_message receive_message å‚æ•°ï¼Œmsg_typeï¼Œmsg_params ä»ä¸€ä¸ªå­—å…¸ä¸­æ ¹æ®msgTypeè·å–callbackï¼Œå¹¶è°ƒç”¨ï¼Œä¼ é€’msg_params send_message é€šè¿‡CommunicationManagerå‘é€ register_message_receive_handler ç»´æŠ¤message_handler_dictï¼Œå³å‰é¢æåˆ°çš„callbackå­—å…¸ æ³¨å†Œæ–°çš„msg_typeå’Œä»–çš„callback finish å°†CommunicationManager stopæ‰ FedMLServerManagerçš„å‡½æ•° run super().run() send_init_msg å‘é€åˆå§‹åŒ–ä¿¡æ¯ å¯¹äºæœ¬è½®ä¸­çš„æ¯ä¸€ä¸ªå‚ä¸çš„clientï¼Œå‘é€åˆå§‹æ¨¡å‹å‚æ•°ï¼Œé€šè¿‡å‡½æ•°send_message_init_config send_message_init_configé€šè¿‡çˆ¶ç±»çš„send_messageå®ç° register_message_receive_handlers æ³¨å†Œä¸‰ç±»ä¿¡æ¯çš„å¤„ç†å‡½æ•°ï¼Œé€šè¿‡çˆ¶ç±»çš„register_message_receive_handlerå®ç° clientçš„connection ready clientçš„status change å½“æ‰€æœ‰çš„clientéƒ½onlineï¼Œè°ƒç”¨send_init_msg clientçš„modelå‘é€ é€šè¿‡Aggregatorçš„add_local_trained_resultå°†å‚æ•°ä¸­çš„æ¨¡å‹å‚æ•°ï¼Œè®­ç»ƒæ ·æœ¬æ•°ç­‰ä¿¡æ¯èšé›†èµ·æ¥ å¦‚æœå…¨éƒ¨å‘é€äº†æ¨¡å‹ä¿¡æ¯ è°ƒç”¨Aggregatorçš„aggregateå‡½æ•°æ›´æ–°å…¨å±€æ¨¡å‹ï¼Œtest_on_server_for_all_clientså‡½æ•°è¿›è¡Œæ¨¡å‹çš„æµ‹è¯•ã€‚ è¿›è¡Œä¸‹ä¸€è½®è®­ç»ƒï¼Œå…¨å±€æ¨¡å‹å‘é€è‡³ä¸‹ä¸€è½®çš„æœºå™¨ä¸­ï¼Œé€šè¿‡send_message_sync_model_to_clientå‡½æ•° è½®æ•°+=1ï¼Œè‹¥è½®æ•°è¾¾åˆ°é¢„å®šçš„æ€»è½®æ•°ï¼Œè°ƒç”¨cleanupå‡½æ•° cleanup- å‘æ‰€æœ‰clientå‘é€finisä¿¡æ¯- å»¶è¿Ÿ3sï¼Œè°ƒç”¨finishç»“æŸè‡ªå·±ï¼ˆçˆ¶ç±»çš„finishï¼‰ ä¸‰ä¸ªhandle_* register_message_receive_handlersä¸­æ³¨å†Œçš„ä¸‰ä¸ªå‡½æ•°ï¼Œç”¨äºå¤„ç†å®¢æˆ·ç«¯çš„æ¶ˆæ¯ å‡ ä¸ªsend_* åœ¨å‰é¢éƒ½æœ‰æåˆ°ï¼Œå‘å®¢æˆ·ç«¯å‘é€ä¿¡æ¯ FedMLCrossSiloClient å¦‚æœargs.scenario HIERARCHICALï¼Œåˆ™æ ¹æ®rankï¼Œè‹¥rankä¸º0ï¼Œæ„é€ ClientMasterManagerï¼Œå¦åˆ™æ„é€ ClientSlaveManager HORIZONTALï¼Œæ„é€ ClientMasterManager Masterå®¢æˆ·ç«¯çš„çˆ¶ç±»â€“ClientManager ä¸ServerManagerç±»ä¼¼ï¼Œæ ¹æ®åè®®æ„é€ CommunicationManagerï¼Œæä¾›æ¶ˆæ¯ç±»å‹ä¸å›è°ƒçš„æ³¨å†Œå‡½æ•°ï¼Œæä¾›send_messageå‡½æ•° ä¸åŒç‚¹åœ¨äºServerçš„Hostå’ŒPortå›ºå®šï¼ŒClientä»é…ç½®ä¸­è¯»å– ClientMasterManager å’ŒServerManagerç±»ä¼¼ï¼Œå¤„ç†ç½‘ç»œæ¶ˆæ¯ï¼Œç»™serverå‘é€ä¿¡æ¯ï¼ˆå¦‚æœ¬åœ°æ¨¡å‹ä¿¡æ¯ç­‰ï¼‰ è®­ç»ƒæœ¬åœ°æ¨¡å‹ ClientSlaveManager å¤„ç†æœ¬åœ°è®­ç»ƒ Observer å®šä¹‰æŠ½è±¡å‡½æ•°receive_messageï¼ŒcommunicationManagerä¼šè°ƒç”¨observerçš„è¿™ä¸ªå‡½æ•°ï¼Œå°†å—åˆ°çš„æ¶ˆæ¯ç±»å‹ï¼Œå‚æ•°ä¼ é€’ç»™å­ç±»ï¼Œä¸Šé¢çš„ä¾‹å­ä¸­éƒ½æ˜¯ä½¿ç”¨æ¶ˆæ¯ç±»å‹-handleå‡½æ•°çš„dictå®ç°å¯¹ä¸åŒç±»å‹çš„æ¶ˆæ¯è¿›è¡Œå¤„ç† ç»“è®º æ ¹æ®FedML+BlockChainçš„å®šä¹‰åŒæ–¹ä¹‹é—´çš„é€šä¿¡æµç¨‹ï¼Œæ ¹æ®é€šä¿¡æµç¨‹åˆ†åˆ«ç½®é¡¶S-Cçš„é€šä¿¡æ¶ˆæ¯ï¼Œç›´æ¥åŸºäºClientManagerå’ŒServerManagerï¼Œè‡ªå®šä¹‰ä¸€ä¸ªFedMLBlockChainServerå’ŒFedMLBlockChainServerï¼Œå®ç°è¿™ä¸ªé€šä¿¡è¿‡ç¨‹ã€‚","link":"/home/2022/10/22/fedfab/fedml/3.Runner%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"title":"fabric-2.fabricè‡ªå®šä¹‰ä¸å®è·µ","text":"æ‰‹åŠ¨æ­å»ºhyperledger fabric v2.xï¼Œå…¶ä¸­ç¬¬äºŒä¸ªè§†é¢‘ä¸­ï¼Œåˆ›å»ºç»„ç»‡çš„é”šèŠ‚ç‚¹æ–‡ä»¶å·²ç»è¢«å¼ƒç”¨ å‘½ä»¤å‚è€ƒ è®¡åˆ’é…ç½®ä¸€ä¸ª4ä¸ªèŠ‚ç‚¹çš„ç½‘ç»œï¼Œä¸‰ä¸ªèŠ‚ç‚¹æ¨¡æ‹ŸIOTè®¾å¤‡ï¼Œä¸€ä¸ªä»£è¡¨å…¬å¸èŠ‚ç‚¹ ä¸»è¦å·¥ä½œ åˆ›å»ºäº†ä¸€ä¸ªæ‹¥æœ‰ä¸¤ä¸ªorgçš„é€šé“ è‡ªå®šä¹‰äº†ä¸€ä¸ªç½‘ç»œï¼Œorg1æ‹¥æœ‰ä¸‰ä¸ªèŠ‚ç‚¹ï¼Œorg2æ‹¥æœ‰1ä¸ªèŠ‚ç‚¹ ç”¨goè¯­è¨€è‡ªå®šä¹‰äº†chaincodeå¹¶ç¼–è¯‘ åœ¨ç½‘ç»œä¸Šå®‰è£…é€šé“ï¼Œæ‰§è¡Œé“¾ç  fabricç¯å¢ƒå˜é‡ ä¸ºäº†ä½¿ç”¨cryptogenç­‰å·¥å…·123cd fabric-samples/binsudo echo export PATH=\\$PATH:$(pwd) &gt;&gt; ~/.bashrcsource ~/.bashrc åˆ›å»ºèŠ‚ç‚¹ç›®å½•ï¼Œä½¿ç”¨cryptogenå‘½ä»¤cryptogen æœ‰å¦‚ä¸‹äº”ä¸ªå­å‘½ä»¤: help generate showtemplate extend version åˆ›å»ºæ¨¡æ¿æ–‡ä»¶1cryptogen showtemplate &gt; crypto-config.yaml ä¿®æ”¹æ¨¡æ¿æ’åºèŠ‚ç‚¹12345678910111213141516## ---------------------------------------------------------------------------## &quot;OrdererOrgs&quot; - Definition of organizations managing orderer nodes## ---------------------------------------------------------------------------OrdererOrgs: ## --------------------------------------------------------------------------- ## Orderer ## --------------------------------------------------------------------------- - Name: Orderer Domain: fedfab.com EnableNodeOUs: false ## --------------------------------------------------------------------------- ## &quot;Specs&quot; - See PeerOrgs below for complete description ## --------------------------------------------------------------------------- Specs: - Hostname: orderer EnableNodeOUsï¼Œå³æ˜¯å¦å¯ç”¨Organization Unit peerèŠ‚ç‚¹ï¼ˆç»„ç»‡1ï¼‰123456789101112131415PeerOrgs: ## --------------------------------------------------------------------------- ## Org1 ## --------------------------------------------------------------------------- - Name: Org1 Domain: org1.fedfab.com EnableNodeOUs: false #è¿™é‡Œæ”¹ä¸ºtrue Template: Count: 1 ## è¿™é‡Œæ”¹ä¸º3. ## Start: 5 ## Hostname: {{.Prefix}}{{.Index}} ## default ## SANS: ## - &quot;{{.Hostname}}.alt.{{.Domain}}&quot; Users: Count: 1 #è¿™é‡Œä¹Ÿæ”¹ä¸º3 UseræŒ‡æ“çºµç»ˆç«¯çš„äººï¼Œåœ¨ç»ˆç«¯æ“çºµçš„äºº peerèŠ‚ç‚¹ï¼ˆç»„ç»‡2ï¼‰12345678910#---------------------------------------------------------------------------## Org2: See &quot;Org1&quot; for full specification## ---------------------------------------------------------------------------- Name: Org2 Domain: org2.fedfab.com EnableNodeOUs: false #æ”¹æˆtrue Template: Count: 1 Users: Count: 1 ç”Ÿæˆè¯ä¹¦æ–‡ä»¶1cryptogen generate --config=crypto-config.yaml è¾“å‡ºï¼Œå¹¶åˆ›å»ºäº†è¯ä¹¦æ–‡ä»¶12org1.fedfab.comorg2.fedfab.com è¿›å…¥ä¸€ä¸ªç»„ç»‡æŸ¥çœ‹12tt@tt-HP:~/Desktop/fabric/my-network/nodes/crypto-config/peerOrganizations/org1.fedfab.com$ lsca msp peers tlsca users åˆ›å»ºé€šé“ ç¼–å†™configtx.yamlé…ç½®æ–‡ä»¶ ä½¿ç”¨configtxgenå‘½ä»¤åˆ›å»ºé€šé“ configtxgençš„ä½¿ç”¨ configtxgen å·¥å…·æ²¡æœ‰å­å‘½ä»¤ï¼Œä½†æ˜¯æ”¯æŒflagï¼Œé€šè¿‡è®¾ç½®flagå¯ä»¥å®Œæˆä¸åŒçš„ä»»åŠ¡ã€‚12345678910111213141516171819202122232425Usage of configtxgen: -asOrg string ä»¥ç‰¹å®šç»„ç»‡ï¼ˆæŒ‰åç§°ï¼‰æ‰§è¡Œé…ç½®ç”Ÿæˆï¼Œä»…åŒ…æ‹¬ç»„ç»‡ï¼ˆå¯èƒ½ï¼‰æœ‰æƒè®¾ç½®çš„å†™é›†ä¸­çš„å€¼ã€‚ -channelCreateTxBaseProfile string æŒ‡å®šè¦è§†ä¸ºæ’åºç³»ç»Ÿé€šé“å½“å‰çŠ¶æ€çš„è½®å»“ï¼ˆprofileï¼‰ï¼Œä»¥å…è®¸åœ¨é€šé“åˆ›å»ºäº¤æ˜“ç”ŸæˆæœŸé—´ä¿®æ”¹éåº”ç”¨ç¨‹åºå‚æ•°ã€‚ä»…åœ¨ä¸ â€œoutputCreateChannelTXâ€ ç»“åˆæ—¶æœ‰æ•ˆã€‚ -channelID string é…ç½®äº¤æ˜“ä¸­ä½¿ç”¨çš„é€šé“ IDã€‚ -configPath string åŒ…å«æ‰€ç”¨çš„é…ç½®çš„è·¯å¾„ã€‚ï¼ˆå¦‚æœè®¾ç½®çš„è¯ï¼‰ -inspectBlock string æ‰“å°æŒ‡å®šè·¯å¾„çš„åŒºå—ä¸­åŒ…å«çš„é…ç½®ã€‚ -inspectChannelCreateTx string æ‰“å°æŒ‡å®šè·¯å¾„çš„äº¤æ˜“ä¸­åŒ…å«çš„é…ç½®ã€‚ -outputAnchorPeersUpdate string åˆ›å»ºä¸€ä¸ªæ›´æ–°é”šèŠ‚ç‚¹çš„é…ç½®æ›´æ–°ï¼ˆä»…åœ¨é»˜è®¤é€šé“åˆ›å»ºæ—¶æœ‰æ•ˆï¼Œå¹¶ä»…ç”¨äºç¬¬ä¸€æ¬¡æ›´æ–°ï¼‰ã€‚ -outputBlock string å†™å…¥åˆ›ä¸–åŒºå—çš„è·¯å¾„ã€‚ï¼ˆå¦‚æœè®¾ç½®çš„è¯ï¼‰ -outputCreateChannelTx string å†™å…¥é€šé“åˆ›å»ºäº¤æ˜“çš„è·¯å¾„ã€‚ï¼ˆå¦‚æœè®¾ç½®çš„è¯ï¼‰ -printOrg string ä»¥ JSON æ–¹å¼æ‰“å°ç»„ç»‡çš„å®šä¹‰ã€‚ï¼ˆæ‰‹åŠ¨å‘é€šé“ä¸­æ·»åŠ ç»„ç»‡æ—¶å¾ˆæœ‰ç”¨ï¼‰ -profile string configtx.yaml ä¸­ç”¨äºç”Ÿæˆçš„è½®å»“ã€‚ -version æ˜¾ç¤ºç‰ˆæœ¬ä¿¡æ¯ã€‚ configtx.yamlçš„ç¼–å†™å®˜æ–¹æ–‡æ¡£åœ¨åˆ›å»ºæ–°é€šé“ä¸­è¯¦ç»†ä»‹ç»äº†configtx.yamlçš„å†™æ³• è¿™é‡Œæˆ‘ç›´æ¥å¤åˆ¶test-networkä¸­çš„é…ç½®æ–‡ä»¶å¹¶è¿›è¡Œç›¸åº”ä¿®æ”¹ åˆ›å»ºconfigtxæ–‡ä»¶å¤¹1mkdir configtx ä¿®æ”¹é…ç½®æ–‡ä»¶ ä¿®æ”¹mspæ–‡ä»¶åœ°å€å°†é…ç½®æ–‡ä»¶ä¸­çš„MSPDir-mspåœ°å€ä¿®æ”¹ä¸ºåœ¨ç”Ÿæˆè¯ä¹¦æ–‡ä»¶æ­¥éª¤ä¸­ç”Ÿæˆçš„æ–‡ä»¶çš„ç›®å½• ä¿®æ”¹è¯ä¹¦åœ°å€å°†é…ç½®æ–‡ä»¶ä¸­çš„ClientTLSCertå’ŒServerTLSCertä¿®æ”¹ä¸ºåœ¨ç”Ÿæˆè¯ä¹¦æ–‡ä»¶æ­¥éª¤ä¸­ç”Ÿæˆçš„æ–‡ä»¶çš„ç›®å½• å†™å…¥åˆ›ä¸–å—çš„é…ç½®æ–‡ä»¶ 12345678910111213TwoOrgsOrdererGenesis: &lt;&lt;: *ChannelDefaults Orderer: &lt;&lt;: *OrdererDefaults Organizations: - *OrdererOrg Capabilities: &lt;&lt;: *OrdererCapabilities Consortiums: SampleConsortium: Organizations: - *Org1 - *Org2 ç¼–å†™yamlæ–‡ä»¶æ—¶è¦æ³¨æ„ç¼©è¿›ï¼Œå¦åˆ™å°†å¯¼è‡´æ‰§è¡Œå¤±è´¥ å†™å…¥åˆ›å»ºåº”ç”¨é€šé“çš„é…ç½® 12345678910TwoOrgsChannel: Consortium: SampleConsortium &lt;&lt;: *ChannelDefaults Application: &lt;&lt;: *ApplicationDefaults Organizations: - *Org1 - *Org2 Capabilities: &lt;&lt;: ***ApplicationCapabilities** åˆ›å»ºç¯å¢ƒå˜é‡1export FABRIC_CFG_PATH=${PWD}/configtx åˆ›å»ºåˆ›ä¸–å—1configtxgen -profile TwoOrgsOrdererGenesis -channelID system-channel -outputBlock ./system-genesis-block/genesis.block å¾—åˆ°è¾“å‡º 12345672022-08-27 20:52:53.432 CST 0001 INFO [common.tools.configtxgen] main -&gt; Loading configuration2022-08-27 20:52:53.441 CST 0002 INFO [common.tools.configtxgen.localconfig] completeInitialization -&gt; orderer type: etcdraft2022-08-27 20:52:53.441 CST 0003 INFO [common.tools.configtxgen.localconfig] completeInitialization -&gt; Orderer.EtcdRaft.Options unset, setting to tick_interval:&quot;500ms&quot; election_tick:10 heartbeat_tick:1 max_inflight_blocks:5 snapshot_interval_size:16777216 2022-08-27 20:52:53.441 CST 0004 INFO [common.tools.configtxgen.localconfig] Load -&gt; Loaded configuration: /home/tt/Desktop/fabric/my-network/nodes/configtx/configtx.yaml2022-08-27 20:52:53.443 CST 0005 INFO [common.tools.configtxgen] doOutputBlock -&gt; Generating genesis block2022-08-27 20:52:53.443 CST 0006 INFO [common.tools.configtxgen] doOutputBlock -&gt; Creating system channel genesis block2022-08-27 20:52:53.443 CST 0007 INFO [common.tools.configtxgen] doOutputBlock -&gt; Writing genesis block åˆ›å»ºåº”ç”¨é€šé“123configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel2.tx -channelID channel2configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID channel2 -asOrg Org1MSPconfigtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID channel2 -asOrg Org2MSP å¾—åˆ°è¾“å‡º 12342022-08-27 21:01:01.223 CST 0001 INFO [common.tools.configtxgen] main -&gt; Loading configuration2022-08-27 21:01:01.233 CST 0002 INFO [common.tools.configtxgen.localconfig] Load -&gt; Loaded configuration: /home/tt/Desktop/fabric/my-network/nodes/configtx/configtx.yaml2022-08-27 21:01:01.233 CST 0003 INFO [common.tools.configtxgen] doOutputChannelCreateTx -&gt; Generating new channel configtx2022-08-27 21:01:01.235 CST 0004 INFO [common.tools.configtxgen] doOutputChannelCreateTx -&gt; Writing new channel tx åˆ›å»ºpeerèŠ‚ç‚¹å’ŒorderèŠ‚ç‚¹ ä½¿ç”¨docker composeå¯¹èŠ‚ç‚¹å®¹å™¨è¿›è¡Œå®šä¹‰ åœ¨test-networkçš„åŸºç¡€ä¸Šè¿›è¡Œä¿®æ”¹ ä¿®æ”¹orderèŠ‚ç‚¹1234567891011121314151617181920212223242526272829303132333435363738394041424344orderer.fedfab.com: container_name: orderer.fedfab.com image: hyperledger/fabric-orderer:latest labels: service: hyperledger-fabric environment: - FABRIC_LOGGING_SPEC=INFO - ORDERER_GENERAL_LISTENADDRESS=0.0.0.0 - ORDERER_GENERAL_LISTENPORT=7050 - ORDERER_GENERAL_LOCALMSPID=OrdererMSP - ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/msp ## enabled TLS - ORDERER_GENERAL_TLS_ENABLED=true - ORDERER_GENERAL_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key - ORDERER_GENERAL_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt - ORDERER_GENERAL_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt] - ORDERER_GENERAL_CLUSTER_CLIENTCERTIFICATE=/var/hyperledger/orderer/tls/server.crt - ORDERER_GENERAL_CLUSTER_CLIENTPRIVATEKEY=/var/hyperledger/orderer/tls/server.key - ORDERER_GENERAL_CLUSTER_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt] ## - ORDERER_GENERAL_BOOTSTRAPMETHOD=none #å»æ‰ - ORDERER_GENERAL_GENESISMETHOD=file #å¢åŠ  - ORDERER_GENERAL_GENESISFILE=/var/hyperledger/orderer/system-genesis-block/genesis.block #å¢åŠ  - ORDERER_CHANNELPARTICIPATION_ENABLED=true - ORDERER_ADMIN_TLS_ENABLED=true - ORDERER_ADMIN_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt - ORDERER_ADMIN_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key - ORDERER_ADMIN_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt] - ORDERER_ADMIN_TLS_CLIENTROOTCAS=[/var/hyperledger/orderer/tls/ca.crt] - ORDERER_ADMIN_LISTENADDRESS=0.0.0.0:7053 - ORDERER_OPERATIONS_LISTENADDRESS=orderer.fedfab.com:9443 - ORDERER_METRICS_PROVIDER=prometheus working_dir: /root command: orderer volumes: - ../crypto-config/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp:/var/hyperledger/orderer/msp - ../crypto-config/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/tls/:/var/hyperledger/orderer/tls - ../system-genesis-block/:/var/hyperledger/orderer/system-genesis-block #å¢åŠ  - orderer.fedfab.com:/var/hyperledger/production/orderer ports: - 7050:7050 - 7053:7053 - 9443:9443 networks: - test åç»­ä¼šæ‰‹åŠ¨ç”Ÿæˆåˆ›ä¸–å—ï¼Œéœ€è¦åœ¨composeä¸­æŒ‡å®šç”Ÿæˆçš„åˆ›ä¸–å— å¢åŠ èŠ‚ç‚¹ä¸ªæ•° test-networkä¸­åªæœ‰ä¸‰ä¸ªèŠ‚ç‚¹ï¼ˆæ’åºå’Œä¸¤ä¸ªpeerèŠ‚ç‚¹ï¼‰ï¼Œç°åœ¨ä¿®æ”¹ä¸º1æ’åº+3org1+1org2 123456volumes: orderer.fedfab.com: peer0.org1.fedfab.com: peer1.org1.fedfab.com: peer2.org1.fedfab.com: peer0.org2.fedfab.com: å¢åŠ org1ä¸­çš„èŠ‚ç‚¹é…ç½®ï¼Œä»¥ä¸‹é¢çš„é…ç½®æ–‡ä»¶ä¸ºæ¨¡æ¿1234567891011121314151617181920212223242526272829303132333435363738peer0.org1.fedfab.com: #ä¿®æ”¹ container_name: peer0.org1.fedfab.com #ä¿®æ”¹ image: hyperledger/fabric-peer:latest labels: service: hyperledger-fabric environment: - FABRIC_CFG_PATH=/etc/hyperledger/peercfg - FABRIC_LOGGING_SPEC=INFO #- FABRIC_LOGGING_SPEC=DEBUG - CORE_PEER_TLS_ENABLED=true - CORE_PEER_PROFILE_ENABLED=false - CORE_PEER_TLS_CERT_FILE=/etc/hyperledger/fabric/tls/server.crt - CORE_PEER_TLS_KEY_FILE=/etc/hyperledger/fabric/tls/server.key - CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/tls/ca.crt ## Peer specific variables - CORE_PEER_ID=peer0.org1.fedfab.com #ä¿®æ”¹ - CORE_PEER_ADDRESS=peer0.org1.fedfab.com:7051 #ä¿®æ”¹ - CORE_PEER_LISTENADDRESS=0.0.0.0:7051 - CORE_PEER_CHAINCODEADDRESS=peer0.org1.fedfab.com:7052 #ä¿®æ”¹ - CORE_PEER_CHAINCODELISTENADDRESS=0.0.0.0:7052 - CORE_PEER_GOSSIP_BOOTSTRAP=peer0.org1.fedfab.com:7051 #ä¿®æ”¹ - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org1.fedfab.com:7051 - CORE_PEER_LOCALMSPID=Org1MSP - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/fabric/msp - CORE_OPERATIONS_LISTENADDRESS=peer0.org1.fedfab.com:9444 #ä¿®æ”¹ - CORE_METRICS_PROVIDER=prometheus - CHAINCODE_AS_A_SERVICE_BUILDER_CONFIG={&quot;peername&quot;:&quot;peer0org1&quot;} #ä¿®æ”¹ - CORE_CHAINCODE_EXECUTETIMEOUT=300s volumes: - ../organizations/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com:/etc/hyperledger/fabric #ä¿®æ”¹ - peer0.org1.fedfab.com:/var/hyperledger/production #ä¿®æ”¹ working_dir: /root command: peer node start ports: - 7051:7051 #ä¿®æ”¹ - 9444:9444 #ä¿®æ”¹ networks: - test ä¿®æ”¹å®¹å™¨çš„æ–‡ä»¶å¤¹æ˜ å°„ å°†tlsï¼Œmseç­‰è·¯å¾„ï¼ŒåŸŸååç§°ä¿®æ”¹æ­£ç¡® ä¿®æ”¹ç«¯å£å· ç¼–å· ç«¯å£é…ç½® orderer.fedfab.com 7050:7050, 7053:7053, 9443:9443 peer0.org1.fedfab.com 8051:7051, 9444:9444 peer1.org1.fedfab.com 8052:7051, 9445:9444 peer2.org1.fedfab.com 8053:7051, 9446:9444 peer0.org2.fedfab.com 9051:7051, 9447:9444 CLIï¼ˆå‘½ä»¤è¡Œæ¥å£ï¼‰é…ç½® ä¸ºæ¯ä¸ªèŠ‚ç‚¹åˆ›å»ºä¸€ä¸ªcli å‚è€ƒå®˜æ–¹çš„clié…ç½®æ•™ç¨‹ï¼Œcliéœ€è¦ä»¥ä¸‹ç¯å¢ƒå˜é‡123456export FABRIC_CFG_PATH=$PWD/../config/export CORE_PEER_TLS_ENABLED=trueexport CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crtexport CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.fedfab.com/users/Admin@org1.fedfab.com/mspexport CORE_PEER_ADDRESS=localhost:7051 æ ¹æ®ä¸Šè¿°ç¯å¢ƒå˜é‡å’Œtest-networkä¸­çš„clié…ç½®ï¼Œç¼–å†™å››ä¸ªèŠ‚ç‚¹çš„cli123456789101112131415161718192021222324252627282930313233cli1: #ä¿®æ”¹ container_name: cli1 #ä¿®æ”¹ image: hyperledger/fabric-tools:latest labels: service: hyperledger-fabric tty: true stdin_open: true environment: - GOPATH=/opt/gopath - FABRIC_LOGGING_SPEC=INFO - FABRIC_CFG_PATH=/etc/hyperledger/peercfg #- FABRIC_LOGGING_SPEC=DEBUG - CORE_PEER_ID=cli1 #ä¿®æ”¹ - CORE_PEER_TLS_ENABLED=true - CORE_PEER_LOCALMSPID=Org1MSP #ä¿®æ”¹ - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/server.crt #ä¿®æ”¹ - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/server.key #ä¿®æ”¹ - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt #ä¿®æ”¹ - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/users/Admin@org1.fedfab.com/msp #ä¿®æ”¹ - CORE_PEER_ADDRESS=peer0.org1.fedfab.com:8051 #ä¿®æ”¹ working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer command: /bin/bash volumes: - ../crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto - ../scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/ - /var/run/:/host/var/run/ - ../chaincode/go/:/opt/gopath/src/github.com/hyperledger/fabric-cluster/chaincode/go - ../channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts - ./docker/peercfg:/etc/hyperledger/peercfg depends_on: - peer0.org1.fedfab.com #ä¿®æ”¹ networks: - test è¿è¡Œ1docker-compose up -d å¾—åˆ°è¾“å‡º 123456789101112131415Creating network &quot;fabric_test&quot; with the default driverCreating volume &quot;compose_orderer.fedfab.com&quot; with default driverCreating volume &quot;compose_peer0.org1.fedfab.com&quot; with default driverCreating volume &quot;compose_peer1.org1.fedfab.com&quot; with default driverCreating volume &quot;compose_peer2.org1.fedfab.com&quot; with default driverCreating volume &quot;compose_peer0.org2.fedfab.com&quot; with default driverCreating peer0.org1.fedfab.com ... doneCreating peer0.org2.fedfab.com ... doneCreating peer1.org1.fedfab.com ... doneCreating peer2.org1.fedfab.com ... doneCreating orderer.fedfab.com ... doneCreating cli0 ... doneCreating cli3 ... doneCreating cli1 ... doneCreating cli2 ... done éªŒè¯å®¹å™¨æ˜¯å¦å¯åŠ¨1docker ps -a 12345678910CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd6a76f883fff hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 3 seconds ago Up 2 seconds cli377b3a4f45dd7 hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 3 seconds ago Up 2 seconds cli1cc967bbbffbc hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 3 seconds ago Up 2 seconds cli24cac839a509e hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 4 seconds ago Up 2 seconds cli0dd8fb44841ed hyperledger/fabric-peer:latest &quot;peer node start&quot; 4 seconds ago Exited (1) 2 seconds ago peer1.org1.fedfab.com37d044dc815b hyperledger/fabric-peer:latest &quot;peer node start&quot; 4 seconds ago Exited (1) 3 seconds ago peer2.org1.fedfab.comc5d9572fd1b0 hyperledger/fabric-peer:latest &quot;peer node start&quot; 4 seconds ago Exited (1) 2 seconds ago peer0.org2.fedfab.comfa43da3532d7 hyperledger/fabric-orderer:latest &quot;orderer&quot; 4 seconds ago Up 3 seconds 0.0.0.0:7050-&gt;7050/tcp, :::7050-&gt;7050/tcp, 0.0.0.0:7053-&gt;7053/tcp, :::7053-&gt;7053/tcp, 0.0.0.0:9443-&gt;9443/tcp, :::9443-&gt;9443/tcp orderer.fedfab.com45b71846f669 hyperledger/fabric-peer:latest &quot;peer node start&quot; 4 seconds ago Exited (1) 3 seconds ago peer0.org1.fedfab.com ä½¿ç”¨logså‘½ä»¤æŸ¥çœ‹æ—¥å¿— 12docker logs peer0.org1.fedfab.com2022-08-28 11:18:05.811 UTC 0001 ERRO [main] InitCmd -&gt; Fatal error when initializing core config : FABRIC_CFG_PATH /etc/hyperledger/peercfg does not exist æ ¹æ®docker hub - fabric-peerçš„æè¿°ï¼Œåœ¨FABRIC_CFG_PATHä¸‹éœ€è¦æœ‰core.yamlæ–‡ä»¶ å¤åˆ¶ä¸€ä»½test-networkçš„core.yamlåˆ°composeæ–‡ä»¶å¤¹ä¸‹ åœ¨peerèŠ‚ç‚¹ä¸­æ·»åŠ æ˜ å°„ 1- ./docker/peercfg:/etc/hyperledger/peercfg å†æ¬¡å°è¯•åˆ›å»ºå®¹å™¨ï¼Œå¹¶ä½¿ç”¨pså‘½ä»¤éªŒè¯ 12345678910CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESeaa7a6ad0dc4 hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 4 seconds ago Up 3 seconds cli36cfcf59846eb hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 5 seconds ago Up 3 seconds cli229fe65400204 hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 5 seconds ago Up 3 seconds cli14ac9037d3c2c hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 5 seconds ago Up 4 seconds cli0a5e90a5b170a hyperledger/fabric-peer:latest &quot;peer node start&quot; 5 seconds ago Up 4 seconds 7051/tcp, 0.0.0.0:9051-&gt;9051/tcp, :::9051-&gt;9051/tcp, 0.0.0.0:9447-&gt;9445/tcp, :::9447-&gt;9445/tcp peer0.org2.fedfab.com9b3b0f6445d2 hyperledger/fabric-peer:latest &quot;peer node start&quot; 5 seconds ago Up 4 seconds 0.0.0.0:9444-&gt;9444/tcp, :::9444-&gt;9444/tcp, 0.0.0.0:8051-&gt;7051/tcp, :::8051-&gt;7051/tcp peer0.org1.fedfab.com5d75a82337c8 hyperledger/fabric-peer:latest &quot;peer node start&quot; 5 seconds ago Up 4 seconds 0.0.0.0:8052-&gt;7051/tcp, :::8052-&gt;7051/tcp, 0.0.0.0:9445-&gt;9444/tcp, :::9445-&gt;9444/tcp peer1.org1.fedfab.com5eb7a92eb4e0 hyperledger/fabric-orderer:latest &quot;orderer&quot; 5 seconds ago Up 4 seconds 0.0.0.0:7050-&gt;7050/tcp, :::7050-&gt;7050/tcp, 0.0.0.0:7053-&gt;7053/tcp, :::7053-&gt;7053/tcp, 0.0.0.0:9443-&gt;9443/tcp, :::9443-&gt;9443/tcp orderer.fedfab.com17c6798b2dc9 hyperledger/fabric-peer:latest &quot;peer node start&quot; 5 seconds ago Up 4 seconds 0.0.0.0:8053-&gt;7051/tcp, :::8053-&gt;7051/tcp, 0.0.0.0:9446-&gt;9444/tcp, :::9446-&gt;9444/tcp peer2.org1.fedfab.com å…¨éƒ¨å®¹å™¨éƒ½å·²ç»å¯åŠ¨æˆåŠŸï¼ è¡¥å…… åœ¨test-networkçš„network.shè„šæœ¬ä¸­ä»”ç»†è§‚å¯Ÿdocker-composeçš„ä»£ç å‘ç°ï¼Œtest-networkä¸­ä½¿ç”¨äº†å¤šä¸ªymlæ–‡ä»¶è¿›è¡Œé…ç½® 123456789101112131415161718192021function networkUp() { checkPrereqs ## generate artifacts if they don't exist if [ ! -d &quot;organizations/peerOrganizations&quot; ]; then createOrgs fi COMPOSE_FILES=&quot;-f compose/${COMPOSE_FILE_BASE} -f compose/${CONTAINER_CLI}/${CONTAINER_CLI}-${COMPOSE_FILE_BASE}&quot; #æ­¤å¤„ if [ &quot;${DATABASE}&quot; == &quot;couchdb&quot; ]; then COMPOSE_FILES=&quot;${COMPOSE_FILES} -f compose/${COMPOSE_FILE_COUCH} -f compose/${CONTAINER_CLI}/${CONTAINER_CLI}-${COMPOSE_FILE_COUCH}&quot; fi DOCKER_SOCK=&quot;${DOCKER_SOCK}&quot; ${CONTAINER_CLI_COMPOSE} ${COMPOSE_FILES} up -d 2&gt;&amp;1 $CONTAINER_CLI ps -a if [ $? -ne 0 ]; then fatalln &quot;Unable to start network&quot; fi} æ•…æ‰¾åˆ°ç›¸åº”æ–‡ä»¶ï¼Œå°†å…¶ä¸­çš„é…ç½®æ·»åŠ åˆ°èŠ‚ç‚¹ä¸­ï¼ˆè¿™ä¹Ÿå°±æ˜¯ä¹‹å‰peerèŠ‚ç‚¹åˆ›å»ºåå¯åŠ¨å¤±è´¥çš„åŸå› ï¼‰ 123456789101112131415161718192021222324252627282930313233version: '3.7'services: peer0.org1.fedfab.com: container_name: peer0.org1.fedfab.com image: hyperledger/fabric-peer:latest labels: service: hyperledger-fabric environment: #Generic peer variables - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=fabric_test volumes: - ./docker/peercfg:/etc/hyperledger/peercfg - ${DOCKER_SOCK}:/host/var/run/docker.sock peer0.org2.fedfab.com: container_name: peer0.org2.fedfab.com image: hyperledger/fabric-peer:latest labels: service: hyperledger-fabric environment: #Generic peer variables - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=fabric_test volumes: - ./docker/peercfg:/etc/hyperledger/peercfg - ${DOCKER_SOCK}:/host/var/run/docker.sock cli: container_name: cli image: hyperledger/fabric-tools:latest volumes: - ./docker/peercfg:/etc/hyperledger/peercfg ä½¿ç”¨docer-composeå‘½ä»¤åˆ›å»ºå®¹å™¨(æ·»åŠ DOCKER_SOCK)ç¯å¢ƒå˜é‡123SOCK=&quot;${DOCKER_HOST:-/var/run/docker.sock}&quot;export DOCKER_SOCK=&quot;${SOCK##unix://}&quot;docker-compose up -d dockerå®¹å™¨å»ºç«‹äº†ï¼Œä½†æ˜¯docker-composeçš„é…ç½®æ–‡ä»¶ä¸­çš„å¾ˆå¤šç»†èŠ‚å¹¶ä¸æ¸…æ¥š ä¿®æ”¹hostæ–‡ä»¶12345678sudo tee -a /etc/hosts &lt;&lt;-'EOF'127.0.0.1 orderer.fedfab.com127.0.0.1 peer0.org1.fedfab.com127.0.0.1 peer1.org1.fedfab.com127.0.0.1 peer2.org1.fedfab.com127.0.0.1 peer0.org2.fedfab.comEOFcat /etc/hosts å®‰è£…é“¾ç  å‚è€ƒ Housekeepingåˆå§‹åŒ–modï¼Œè·å–fabricæ¨¡å— 12go mod init github.com/hyperledger/fabric-samples/chaincode/mycontractgo get -u github.com/hyperledger/fabric-contract-api-go ç¼–å†™é“¾ç ï¼Œç¼–è¯‘ç¼–å†™å¥½chaincode.goï¼Œä¸‹è½½ä¾èµ–åŒ…ï¼Œç¼–è¯‘ 12go mod vendorgo build é…ç½®é€šé“ peerå‘½ä»¤ä»‹ç» è¿›å…¥cliå®¹å™¨1234docker exec -it cli0 shdocker exec -it cli1 shdocker exec -it cli2 shdocker exec -it cli3 sh å®‰è£…é€šé“1peer channel create -o orderer.fedfab.com:7050 -c channel2 -f ./channel-artifacts/channel2.tx --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem 12345678910111213142022-08-29 08:31:23.202 UTC 0001 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:31:23.211 UTC 0002 INFO [cli.common] readBlock -&gt; Expect block, but got status: &amp;{NOT_FOUND}2022-08-29 08:31:23.214 UTC 0003 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:31:23.415 UTC 0004 INFO [cli.common] readBlock -&gt; Expect block, but got status: &amp;{SERVICE_UNAVAILABLE}2022-08-29 08:31:23.417 UTC 0005 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:31:23.619 UTC 0006 INFO [cli.common] readBlock -&gt; Expect block, but got status: &amp;{SERVICE_UNAVAILABLE}2022-08-29 08:31:23.621 UTC 0007 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:31:23.822 UTC 0008 INFO [cli.common] readBlock -&gt; Expect block, but got status: &amp;{SERVICE_UNAVAILABLE}2022-08-29 08:31:23.824 UTC 0009 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:31:24.026 UTC 000a INFO [cli.common] readBlock -&gt; Expect block, but got status: &amp;{SERVICE_UNAVAILABLE}2022-08-29 08:31:24.028 UTC 000b INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:31:24.229 UTC 000c INFO [cli.common] readBlock -&gt; Expect block, but got status: &amp;{SERVICE_UNAVAILABLE}2022-08-29 08:31:24.231 UTC 000d INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:31:24.434 UTC 000e INFO [cli.common] readBlock -&gt; Received block: 0 å°†ç”Ÿæˆçš„channel2.blockå¤åˆ¶åˆ°å…¶ä»–cliä¸­1234docker cp cli0:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel2.block ./docker cp ./channel2.block cli1:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel2.blockdocker cp ./channel2.block cli2:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel2.blockdocker cp ./channel2.block cli3:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel2.block åŠ å…¥channelåˆ†åˆ«è¿›å…¥å››ä¸ªcliï¼Œæ‰§è¡Œä»¥ä¸‹å‘½ä»¤ 1peer channel join -b ./channel2.block 122022-08-29 08:55:24.659 UTC 0001 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:55:24.695 UTC 0002 INFO [channelCmd] executeJoin -&gt; Successfully submitted proposal to join channel ç¬¬ä¸€æ¬¡æ‰§è¡Œæ—¶ï¼Œcli0-cli2å‡ºç°äº†connection refuseçš„æƒ…å†µï¼Œå¯¹docker composeæ–‡ä»¶è¿›è¡Œä¿®æ”¹ï¼Œé‡æ–°è¿›è¡Œç«¯å£æ˜ å°„ï¼Œåˆ™æ­£å¸¸ã€‚è¿™é‡Œå‡ºç°è¿™ä¸ªé—®é¢˜çš„åŸå› ä¸è¯¦ï¼Œå®¹å™¨å†…çš„ç«¯å£å·å¿…é¡»å’Œå¤–é¢åŒ¹é…æ‰è¡Œ ç¼–å· ç«¯å£é…ç½® orderer.fedfab.com 7050:7050, 7053:7053, 9443:9443 peer0.org1.fedfab.com 8051:8051, 9444:9444 peer1.org1.fedfab.com 8053:8053, 9445:9444 peer2.org1.fedfab.com 8055:8055, 9446:9444 peer0.org2.fedfab.com 9051:7051, 9447:9444 éªŒè¯æ˜¯å¦åŠ å…¥é€šé“1peer channel getinfo -c channel2 122022-08-29 09:28:21.265 UTC 0001 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initializedBlockchain info: {&quot;height&quot;:1,&quot;currentBlockHash&quot;:&quot;xHaVldOzr0XQgw20tyMdri5No9dZuSQMez7jUOew/TU=&quot;} é…ç½®é”šèŠ‚ç‚¹ è·å–é€šé“é…ç½®12peer channel fetch config channel-artifacts/config_block.pb -o orderer.fedfab.com:7050 -c channel2 --tls --cafile ${PWD}/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pemcd channel-artifacts pbæ–‡ä»¶è½¬ä¸ºjsonæ–‡ä»¶123configtxlator proto_decode --input config_block.pb --type common.Block --output config_block.jsonjq .data.data[0].payload.data.config config_block.json &gt; config.jsoncp config.json config_copy.json ä½¿ç”¨jqå·¥å…·å°†Org1çš„Peeré”šèŠ‚ç‚¹æ·»åŠ åˆ°é€šé“é…ç½®ä¸­ 1jq '.channel_group.groups.Application.groups.Org2MSP.values += {&quot;AnchorPeers&quot;:{&quot;mod_policy&quot;: &quot;Admins&quot;,&quot;value&quot;:{&quot;anchor_peers&quot;: [{&quot;host&quot;: &quot;peer0.org2.fedfab.com&quot;,&quot;port&quot;: 9051}]},&quot;version&quot;: &quot;0&quot;}}' config_copy.json &gt; modified_config.json å®Œæˆæ­¤æ­¥éª¤åï¼Œæˆ‘ä»¬åœ¨modified_config.jsonæ–‡ä»¶ä¸­ä»¥JSONæ ¼å¼è·å–äº†é€šé“é…ç½®çš„æ›´æ–°ç‰ˆæœ¬ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥å°†åŸå§‹å’Œä¿®æ”¹çš„é€šé“é…ç½®éƒ½è½¬æ¢å›protobufæ ¼å¼ï¼Œå¹¶è®¡ç®—å®ƒä»¬ä¹‹é—´çš„å·®å¼‚ã€‚ 123configtxlator proto_encode --input config.json --type common.Config --output config.pbconfigtxlator proto_encode --input modified_config.json --type common.Config --output modified_config.pbconfigtxlator compute_update --channel_id channel2 --original config.pb --updated modified_config.pb --output config_update.pb åä¸ºchannel_update.pbçš„æ–°çš„protobufåŒ…å«æˆ‘ä»¬éœ€è¦åº”ç”¨äºé€šé“é…ç½®çš„Peeré”šèŠ‚ç‚¹æ›´æ–°ã€‚æˆ‘ä»¬å¯ä»¥å°†é…ç½®æ›´æ–°åŒ…è£…åœ¨äº¤æ˜“Envelopeä¸­ï¼Œä»¥åˆ›å»ºé€šé“é…ç½®æ›´æ–°äº¤æ˜“ã€‚ 123configtxlator proto_decode --input config_update.pb --type common.ConfigUpdate --output config_update.jsonecho '{&quot;payload&quot;:{&quot;header&quot;:{&quot;channel_header&quot;:{&quot;channel_id&quot;:&quot;channel2&quot;, &quot;type&quot;:2}},&quot;data&quot;:{&quot;config_update&quot;:'$(cat config_update.json)'}}}' | jq . &gt; config_update_in_envelope.jsonconfigtxlator proto_encode --input config_update_in_envelope.json --type common.Envelope --output config_update_in_envelope.pb æˆ‘ä»¬å¯ä»¥é€šè¿‡å‘peer channel updateå‘½ä»¤æä¾›æ–°çš„é€šé“é…ç½®æ¥æ·»åŠ Peeré”šèŠ‚ç‚¹ã€‚å› ä¸ºæˆ‘ä»¬æ­£åœ¨æ›´æ–°ä»…å½±å“Org1çš„éƒ¨åˆ†é€šé“é…ç½®ï¼Œæ‰€ä»¥å…¶ä»–é€šé“æˆå‘˜ä¸éœ€è¦æ‰¹å‡†é€šé“æ›´æ–°ã€‚ 12cd ..peer channel update -f channel-artifacts/config_update_in_envelope.pb -c channel2 -o orderer.fedfab.com:7050 --tls --cafile ${PWD}/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem 122022-08-29 09:47:17.178 UTC 0001 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 09:47:17.185 UTC 0002 INFO [channelCmd] update -&gt; Successfully submitted channel update è¿›å…¥org2çš„cliï¼Œæ‰§è¡Œä¸Šé¢çš„ç±»ä¼¼æ“ä½œ éªŒè¯å·²ç»æ›´æ–° 1peer channel getinfo -c channel2 1Blockchain info: {&quot;height&quot;:3,&quot;currentBlockHash&quot;:&quot;ScjYWX32DW8yvtDZ+DnLOljrFnHIjlCT2WbM2s19lF0=&quot;,&quot;previousBlockHash&quot;:&quot;hTNOb9vIRm2sm8XPgrEsz33w/Ivc28MINV4Kn6ICXyU=&quot;} å·²ç»æœ‰ä¸‰ä¸ªå—äº†","link":"/home/2022/10/22/fedfab/fabric/2.fabric%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9E%E8%B7%B5/"},{"title":"cha13.æ–‡ä»¶I&#x2F;Oç¼“å†²","text":"13.1ä½¿ç”¨shellå†…åµŒçš„timeå‘½ä»¤ï¼Œæµ‹ç®—ç¨‹åºæ¸…å•4-1(copy.c)åœ¨å½“å‰ç¯å¢ƒä¸‹çš„ç”¨æ—¶ã€‚aï¼‰ä½¿ç”¨ä¸åŒçš„æ–‡ä»¶å’Œç¼“å†²åŒºå¤§å°è¿›è¡Œè¯•éªŒã€‚ç¼–è¯‘åº”ç”¨ç¨‹åºæ—¶ä½¿ç”¨-DBUF_SIZE=nbytesé€‰é¡¹å¯è®¾ç½®ç¼“å†²åŒºå¤§å°ã€‚b) å¯¹open()çš„ç³»ç»Ÿè°ƒç”¨åŠ å…¥O_SYNCæ ‡è¯†ï¼Œé’ˆå¯¹ä¸åŒå¤§å°çš„ç¼“å†²åŒºï¼Œé€Ÿåº¦å­˜åœ¨å¤šå¤§å·®å¼‚?c) åœ¨ä¸€ç³»åˆ—æ–‡ä»¶ç³»ç»Ÿï¼ˆæ¯”å¦‚ï¼Œext3ã€XFSã€Btrfså’Œ JFSï¼‰ä¸­æ‰§è¡Œè¿™äº›è®¡æ—¶æµ‹è¯•ã€‚ç»“æœç›¸ä¼¼å—?å½“ç¼“å†²åŒºå¤§å°ä»å°å˜å¤§æ—¶ï¼Œç”¨æ—¶è¶‹åŠ¿ç›¸åŒå—? 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdarg.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#ifndef BUF_SIZE#define BUF_SIZE 1024#endif#define ERR(code, format, ...) do { \\ if(!(code)) { \\ fprintf(stderr, (char*)format, ##__VA_ARGS__); \\ exit(code); \\ } \\} while(0)int main(int argc, char *argv[]) { char buf[BUF_SIZE]; ssize_t readsize = 0; int openflag = O_RDONLY;#ifdef SYNC openflag |= O_SYNC;#endif int inputfd = open(argv[1], openflag); ERR(inputfd != -1, &quot;fail to open %s, err:%s\\n&quot;, argv[1], strerror(errno)); int outputfd = open(argv[2], O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH); ERR(outputfd != -1, &quot;fail to open %s, err:%s\\n&quot;, argv[2], strerror(errno)); while((readsize = read(inputfd, buf, BUF_SIZE)) &gt; 0) { ERR(write(outputfd, buf, readsize) == readsize, &quot;could not write whole buffer, err:%s\\n&quot;, strerror(errno)); } ERR(readsize != -1, &quot;read fail, err:%s&quot;, strerror(errno)); ERR(close(inputfd) != -1, &quot;fail to close input, err:%s\\n&quot;, strerror(errno)); ERR(close(outputfd) != -1, &quot;fail to close output, err:%s\\n&quot;, strerror(errno)); return 0;} æµ‹è¯•æ—¶é—´1234567891011121314151617BUFSIZE=1cat /dev/null &gt; log13.1.logfor i in `seq 15`; do echo round $i, BUFSIZE=$BUFSIZE &gt;&gt; log13.1.log gcc practice13_1.c -DBUF_SIZE=$BUFSIZE -o practice13_1 /usr/bin/time -f &quot;real = %e\\nuser = %U\\nsystem = %S&quot; -o log13.1.log -a ./practice13_1 big big.copy BUFSIZE=`expr $BUFSIZE \\* 2`doneBUFSIZE=1cat /dev/null &gt; log13.1_sync.logfor i in `seq 15`; do echo round $i, BUFSIZE=$BUFSIZE &gt;&gt; log13.1_sync.log gcc practice13_1.c -DBUF_SIZE=$BUFSIZE -DSYNC -o practice13_1 /usr/bin/time -f &quot;real = %e\\nuser = %U\\nsystem = %S&quot; -o log13.1_sync.log -a ./practice13_1 big big.copy BUFSIZE=`expr $BUFSIZE \\* 2`done ç”Ÿæˆmd1234567891011121314151617181920file=$1tee awk_script.awk 2&gt;&amp;1 &gt; /dev/null &lt;&lt;-'EOF'{ print &quot;|round|bufsize|real|user|system|&quot;; print &quot;|-|-|-|-|-|&quot;;len=split($0, a, &quot;\\n&quot;)-1; for(i = 0; i &lt; len/4; i++) { split(a[i*4+1], line1, &quot;,&quot;); split(line1[1], line11, &quot; &quot;); round=line11[2];split(line1[2], line12, &quot;=&quot;); bufsize=line12[2]; printf(&quot;|%s|%s|&quot;, round, bufsize); for(j = 2; j &lt;= 4; j++) { split(a[i*4+j], linej, &quot; &quot;); printf(&quot;%s|&quot;, linej[3]); } printf(&quot;\\n&quot;); }}EOFcat $file | awk -v RS='EOF' -f awk_script.awk æµ‹è¯•ç»“æœ æµ‹è¯•äºext4ï¼Œæ­å»ºå…¶ä»–æ–‡ä»¶ç³»ç»Ÿå¤ªè€—æ—¶äº†ï¼Œå°±ä¸å¼„äº† æ²¡æœ‰O_SYNC round bufsize real user system 1 1 322.64 86.14 236.38 2 2 160.22 43.23 116.92 3 4 80.88 21.85 58.97 4 8 40.21 10.77 29.41 5 16 19.97 5.23 14.73 6 32 10.13 2.72 7.37 7 64 5.06 1.42 3.63 8 128 2.52 0.57 1.94 9 256 1.27 0.26 1.00 10 512 0.71 0.14 0.56 11 1024 0.37 0.11 0.26 12 2048 0.21 0.03 0.17 13 4096 0.14 0.03 0.10 14 8192 0.10 0.02 0.07 15 16384 0.10 0.00 0.09 æœ‰O_SYNC round bufsize real user system 1 1 370.43 99.46 270.89 2 2 202.32 53.13 149.09 3 4 95.62 25.74 69.80 4 8 49.08 12.88 36.17 5 16 23.94 6.48 17.45 6 32 11.96 3.65 8.31 7 64 6.05 1.55 4.49 8 128 3.26 0.82 2.43 9 256 1.61 0.38 1.22 10 512 0.78 0.23 0.55 11 1024 0.45 0.06 0.39 12 2048 0.31 0.08 0.16 13 4096 0.24 0.04 0.14 14 8192 0.19 0.00 0.12 15 16384 0.19 0.02 0.12 13.2æ‡’å¾—æ 13.3å¦‚ä¸‹è¯­å¥çš„æ‰§è¡Œæ•ˆæœæ˜¯ä»€ä¹ˆ? 12fflush(fp);fsync(fileno(fp)); å…ˆå°†æ–‡ä»¶æŒ‡é’ˆfpçš„stdioåº“çš„ç¼“å­˜è°ƒç”¨writeç³»ç»Ÿè°ƒç”¨ï¼Œå†è·å–fdçš„æ–‡ä»¶æè¿°ç¬¦ï¼Œå°†è¯¥æ–‡ä»¶æè¿°ç¬¦çš„ç³»ç»ŸIOç¼“å†²åŒºçš„æ•°æ®ä»¥åŠæ–‡ä»¶å…ƒæ•°æ®å¼ºåˆ¶å†™å…¥å­˜å‚¨è®¾å¤‡ 13.4è¯•è§£é‡Šå–å†³äºå°†æ ‡å‡†è¾“å‡ºé‡å®šå‘åˆ°ç»ˆç«¯è¿˜æ˜¯ç£ç›˜æ–‡ä»¶,ä¸ºä»€ä¹ˆå¦‚ä¸‹ä»£ç çš„è¾“å‡ºç»“æœä¸åŒã€‚ 12printf(&quot;If I had more time,\\n&quot;);write(STDOUT_FILENO, &quot;I would have written you a shorter letter.\\n&quot;,43); ä»£ç 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;int main() { printf(&quot;If I had more time,\\n&quot;); write(STDOUT_FILENO, &quot;I would have written you a shorter letter.\\n&quot;,43); FILE* file = freopen(&quot;tmp13.4&quot;, &quot;w&quot;, stdout); if(file == NULL) { return 1; } printf(&quot;If I had more time,\\n&quot;); write(STDOUT_FILENO, &quot;I would have written you a shorter letter.\\n&quot;,43); fclose(file); return 0;} ç»“æœ ç»ˆç«¯ ç”±äºç»ˆç«¯çš„ç¼“å­˜modé»˜è®¤ä¸º_IOLBUFï¼Œè¡Œç¼“å†²ioï¼Œä¹Ÿå°±æ˜¯å½“é‡åˆ°ä¸€è¡Œç»“æŸæˆ–ç¼“å­˜æ»¡æ—¶ï¼Œå°±å†™å…¥ç»ˆç«¯ï¼Œæ‰€ä»¥ä¼šæŒ‰ç…§ä»£ç çš„é¡ºåºè¾“å‡º æ–‡ä»¶ æ™®é€šç£ç›˜æ–‡ä»¶çš„ç¼“å­˜modä¸º_IOFBUFï¼Œå…¨ç¼“å†²ioï¼Œprintfä¼šå…ˆå†™å…¥stdioåº“çš„ç¼“å†²åŒºï¼Œwriteç›´æ¥å†™å…¥ç³»ç»ŸIOç¼“å†²åŒºï¼Œä¸€èˆ¬æƒ…å†µä¸‹ï¼Œwriteä¼šå…ˆäºstdioè¿›å…¥ç³»ç»Ÿç¼“å†²åŒºï¼Œå¯¼è‡´æœ€ç»ˆå†™å…¥æ–‡ä»¶çš„é¡ºåºä¸ä»£ç ä¸­çš„é¡ºåºç›¸å 13.5å®ç°tail 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216#define _XOPEN_SOURCE 600#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdarg.h&gt;#define INFO(msg, ...) fprintf(stderr, &quot;INFO: &quot;);\\ fprintf(stderr, msg, ##__VA_ARGS__)#define CHECK(flag, msg, ...) do { \\ if(!(flag)) {\\ fprintf(stderr, &quot;FATAL: &quot;); \\ fprintf(stderr, msg, ##__VA_ARGS__); \\ fprintf(stderr, &quot; ERROR: %s\\n&quot;, strerror(errno)); \\ exit(2); \\ } \\ } while(0)#define streq(str1, str2) (strcmp(str1, str2)==0)#ifndef BUFSIZE//#define BUFSIZE 0x1000//#define BUFSIZE 2#define BUFSIZE 1#endifbool str2int(const char *num, int *ret) { errno = 0; char *end; *ret = strtol(num, &amp;end, 10); CHECK(!(end == num || *end != '\\0' || errno != 0), &quot;%s is not a integer!\\n&quot;, num); return true;}void print(const char *str, ...) { va_list list; va_start(list, str); for(const char *s = str; s != NULL; (s = va_arg(list, const char *))) { size_t slen = va_arg(list, size_t); ssize_t wsize = write(STDOUT_FILENO, s, slen); CHECK(wsize == slen, &quot;fail to print %s\\n&quot;, s); } va_end(list);}char *str_alloc_reverse_cat(char * str1, const char *str2, int *len1, int len2) { char *str = realloc(strdup(str2), (*len1+len2+1) * sizeof(char)); str[len2] = 0; strncat(str, str1, *len1); *len1 += len2; return str;}void tail(int fd, const int line, off_t end) { int num = line; char *buf = (char*)malloc((BUFSIZE+1)*sizeof(char)); char **output = (char **)malloc(num *sizeof(char *)); int *output_len = (int *) malloc(num * sizeof(int)); memset(output, 0, num *sizeof(char *)); memset(output_len, 0, num *sizeof(int)); while(end &gt; 0 &amp;&amp; num) { size_t bufsize = BUFSIZE &gt; end ? end : BUFSIZE; posix_fadvise(fd, end-bufsize, bufsize, POSIX_FADV_WILLNEED); CHECK(end != -1, &quot;end = %ld, fail to lseek fd%d&quot;, end, fd); ssize_t readsize = pread(fd, buf, bufsize, end-bufsize); CHECK(readsize &gt;= 0, &quot;readsize = %ld, fail to read fd%d&quot;, readsize, fd); buf[readsize] = 0; end -= bufsize; CHECK(end != -1, &quot;end = %ld, fail to lseek fd%d&quot;, end, fd); while(readsize &gt;= 0 &amp;&amp; num) { ssize_t move = readsize-1; while(move &gt;=0 &amp;&amp; buf[move] != '\\n') move--; size_t size = readsize - move - 1; if(move &gt;= 0 || end == 0) { num--; output[num] = str_alloc_reverse_cat(output[num], buf+move+1, &amp;output_len[num], size); } else { output[num-1] = str_alloc_reverse_cat(output[num-1], buf+move+1, &amp;output_len[num-1], size); } readsize = move; } } size_t outbufsize = 1; for(int i = num; i &lt; line; i++) { outbufsize += output_len[i]+1; } char *outbuf = (char *) malloc(outbufsize*sizeof(char)); outbuf[0] = 0; for(int i = num; i &lt; line; i++) { strcat(outbuf, output[i]); strcat(outbuf, &quot;\\n&quot;); free(output[i]); } print(outbuf, outbufsize - 1, NULL); free(outbuf); free(buf); free(output);}char *str_alloc_cat(char * str1, const char *str2, int *len1, int len2) { char *str = NULL; if(str1 == NULL) { str = malloc((*len1+len2+1) * sizeof(char)); *len1 = 0; } else { str = realloc(str1, (*len1 + len2 + 1) * sizeof(char)); } str[*len1] = 0; strncat(str + *len1, str2, len2); *len1 += len2; return str;}void tailsafe(int fd, const int num) { // for file that do not support SEEK_END int line = 0; char *buf = (char*)malloc((BUFSIZE+1)*sizeof(char)); char **output = (char **)malloc(num *sizeof(char *)); int *output_len = (int *) malloc(num * sizeof(int)); memset(output, 0, num *sizeof(char *)); memset(output_len, 0, num *sizeof(int)); size_t readsize = 0, prev_readsize = 0; int i,j; while((readsize = read(fd, buf, BUFSIZE)) != 0) { prev_readsize = readsize; CHECK(readsize &gt;= 0, &quot;readsize = %ld, fail to read fd%d&quot;, readsize, fd); buf[readsize] = 0; for(i = 0; i &lt; readsize; i=j+1) { j = i; while(j &lt; readsize &amp;&amp; buf[j] != '\\n')j++; if(output[line] != NULL &amp;&amp; output[line][output_len[line]] == '\\n') { free(output[line]); output[line]= NULL; } if(j &lt; readsize) { output[line] = str_alloc_cat(output[line], buf+i, &amp;output_len[line], j - i); output[line][output_len[line]] = '\\n'; line = (line+1)%num; } else {// size_t end = lseek(fd, i - j, SEEK_CUR); output[line] = str_alloc_cat(output[line], buf+i, &amp;output_len[line], j - i); break; } } } if(i &lt; prev_readsize) { output[line][output_len[line]] = 0; line = (line+1)%num; } if(output[line] == NULL) { line = 0; } size_t outbufsize = 1; for(int i = 0; i &lt; num; i++) { outbufsize += output_len[i]+1; if(output[i] != NULL) output[i][output_len[i]] = 0; } char *outbuf = (char *) malloc(outbufsize*sizeof(char)); outbuf[0] = 0; for(int i = 0; i &lt; num &amp;&amp; output[(i+line)%num] != NULL; i++) { strcat(outbuf, output[(i+line)%num]); strcat(outbuf, &quot;\\n&quot;); free(output[(i+line)%num]); } print(outbuf, outbufsize - 1, NULL); free(outbuf); free(output_len); free(output); free(buf);}int main(int argc, char ** argv) { char **filename = (char **)malloc(argc * sizeof(char *)); int filecount = 0; int num = 10; bool safe = false; for(int i = 1; i &lt; argc; i++) { if(argv[i][0] == '-') { if(streq(argv[i], &quot;--help&quot;) || streq(argv[i], &quot;-h&quot;)) { INFO(&quot;Usage: %s [-h|--help] [-n num] filename&quot;, argv[0]); } else if(streq(argv[i], &quot;-n&quot;)) { str2int(argv[++i], &amp;num); } else if(streq(argv[i], &quot;--safe&quot;)) { safe = true; } } else { filename[filecount++] = strdup(argv[i]); } } CHECK(num &gt;= 0, &quot;num should be non-negative, num = %d\\n&quot;, num); if(filecount == 0) { INFO(&quot;Usage: %s [-h|--help] [-n num] filename&quot;, argv[0]); } for(int i = 0; i &lt; filecount; i++) { int fd = open(filename[i], O_RDONLY); CHECK(fd != -1, &quot;fail to open %s, fd = %d&quot;, filename[i], fd); if (filecount &gt; 1) print(&quot;==&gt; &quot;, 4, filename[i], strlen(filename[i]), &quot; &lt;==&quot;, 4, &quot;\\n&quot;, 1, NULL); if(!safe) { off_t pos = lseek(fd, 0, SEEK_END); CHECK(pos != -1, &quot;fail to lseek %s, pos = %ld&quot;, filename[i], pos); tail(fd, num, pos); } else { tailsafe(fd, num); } close(fd); free(filename[i]); } free(filename); return 0;} ä¸¤ç§æ–¹å¼ï¼Œæ­£ç€è¯»å’Œå€’ç€è¯»æœ‰äº›æ–‡ä»¶ä¸æ”¯æŒSEEK_ENDï¼Œç”¨--safeé€‰é¡¹æ­£ç€è¯»","link":"/home/2023/04/26/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha13/"},{"title":"fedml-4.ä¸fabricé€šä¿¡","text":"ç›´æ¥é‡‡ç”¨â€œå·æ¢æ¢æŸ±â€çš„æ¨¡å¼,æŠŠä¿®æ”¹åçš„ä»£ç å¤åˆ¶åˆ°pipå®‰è£…çš„ä½ç½® pip installçš„ä½ç½®é€šè¿‡python -m siteå‘½ä»¤æŸ¥æ‰¾åŒ…çš„å®‰è£…è·¯å¾„ 123456789101112sys.path = [ '/usr/share/python3', '/usr/lib/python310.zip', '/usr/lib/python3.10', '/usr/lib/python3.10/lib-dynload', '/home/tt/.local/lib/python3.10/site-packages', '/usr/local/lib/python3.10/dist-packages', '/usr/lib/python3/dist-packages',]USER_BASE: '/home/tt/.local' (exists)USER_SITE: '/home/tt/.local/lib/python3.10/site-packages' (exists)ENABLE_USER_SITE: True æ€è€ƒï¼šéœ€è¦ä¿®æ”¹å“ªäº›ä»£ç ï¼Ÿ ä¿®æ”¹Aggregatorã€‚Aggregatorçš„ä½œç”¨æ˜¯ï¼ˆ1ï¼‰ä¿å­˜å„ä¸ªèŠ‚ç‚¹ä¸Šä¼ çš„æœ¬åœ°æ¨¡å‹ï¼›ï¼ˆ2ï¼‰å¯¹æœ¬åœ°æ¨¡å‹è¿›è¡Œaggregateæ“ä½œã€‚ åˆ†ç¦»aggregatorçš„åŠŸèƒ½,åˆ†ä¸ºæœ¬åœ°Aggregatorå’Œé“¾ä¸ŠAggregator,æœ¬åœ°Aggregatorä¸ä¿å­˜æ¨¡å‹,å°†æ”¶åˆ°çš„æ¨¡å‹è½¬å‘ç»™åŒºå—é“¾,èšé›†æ“ä½œæ—¶å…ˆå‘åŒºå—é“¾å–æ¨¡å‹,å†è¿›è¡Œèšé›†æ“ä½œ ä¿®æ”¹FedMLServerManager åœ¨é€‚å½“ä½ç½®è°ƒç”¨httpæ¥å£,é€‚å½“æ ¹æ®é€»è¾‘éœ€è¦ä¿®æ”¹å…¶å®ƒä»£ç  ä¿®æ”¹ClientMasterManager åœ¨é€‚å½“ä½ç½®è°ƒç”¨httpæ¥å£,é€‚å½“æ ¹æ®é€»è¾‘éœ€è¦ä¿®æ”¹å…¶å®ƒä»£ç  ä¿®æ”¹message_define,æ–‡ä»¶ä¸­å®šä¹‰äº†C/Sä¹‹é—´ç›¸äº’é€šä¿¡çš„åç§°,å‚æ•°åç§° å¯¹å…¶é€‚å½“å¢åˆ ,è¾¾åˆ°C/Sé—´ååŒçš„ç›®çš„ ä¿®æ”¹FedMLAggregator model_dict: ç”¨äºä¿å­˜æ”¶åˆ°çš„æœ¬åœ°æ¨¡å‹,ä¸ä»–ç›¸å…³çš„sample_num_dict,ä¿å­˜æ”¶åˆ°çš„æœ¬åœ°æ¨¡å‹çš„æ ·æœ¬ä¸ªæ•°,flag_client_model_uploaded_dictç”¨äºä¿å­˜æ˜¯å¦æ”¶åˆ°æ¨¡å‹ã€‚åŒºå—é“¾ç«¯çš„Aggregatoréœ€è¦ç»´æŠ¤è¿™ä¸‰ä¸ªæ•°ç»„ add_local_trained_result,è¿™ä¸ªå‡½æ•°é€šè¿‡ml_engine_adapter.model_params_to_deviceè·å¾—æœ¬åœ°æ¨¡å‹,å°†è¿™ä¸ªå‡½æ•°æ³¨é‡Šæ‰ check_whether_all_receive,è¿™ä¸ªå‡½æ•°é€šè¿‡æ£€æŸ¥flag_client_model_uploaded_dictæ˜¯å¦å…¨æ˜¯trueæ¥åˆ¤æ–­æ˜¯å¦å…¨éƒ¨æ”¶åˆ°ã€‚è¿™é‡Œæ”¹æˆä»åŒºå—é“¾è·å– aggregate,è¿™ä¸ªå‡½æ•°ä½¿ç”¨äº†sample_num_dictå’Œmodel_dict,ä¹Ÿå…¨éƒ½æ”¹æˆä»åŒºå—é“¾è·å– å…¶ä»–å‡½æ•°æœªæ¶‰åŠè¿™ä¸‰ä¸ªdict,æš‚ä¸åšä¿®æ”¹ã€‚ ä¿®æ”¹FedMLServerManager handle_message_receive_model_from_client,è¿™ä¸ªå‡½æ•°å¤„ç†èŠ‚ç‚¹å‘é€æ¥çš„æ¨¡å‹,ä»æ¶ˆæ¯ä¸­è¯»å–æ¨¡å‹å‚æ•°å’Œæ ·æœ¬ä¸ªæ•°ã€‚ä¸ä»æ¶ˆæ¯ä¸­è·å–è¿™ä¸¤ä¸ªå‚æ•°ï¼ˆåç»­ä¿®æ”¹Client,ä¹Ÿä¸å‘é€è¿™ä¸¤ä¸ªå‚æ•°ï¼‰,ä½†æ˜¯ä»ç„¶å‘Serverå‘é€è¿™ä¸ªæ¶ˆæ¯ã€‚æ”¶åˆ°æ¶ˆæ¯åå»¶è¿Ÿä¸€å®šæ—¶é—´å‘åŒºå—é“¾æŸ¥è¯¢æ˜¯å¦å…¨éƒ¨æ”¶åˆ°ï¼ˆè°ƒç”¨æœ¬åœ°aggregatorçš„check_whether_all_receiveï¼‰ å½“æŸ¥è¯¢åˆ°å…¨éƒ¨éƒ½æ”¶åˆ°å,ä¼šè¿›è¡Œèšé›†æ“ä½œ,èšé›†æ“ä½œåäº§ç”Ÿæ›´æ–°åçš„æ¨¡å‹,è¿™ä¸ªæ¨¡å‹ä¼šå‘é€ç»™client,åœ¨å‘é€ç»™clientçš„åŒæ—¶å‘é€ä¸€ä»½ç»™åŒºå—é“¾å­˜å‚¨ ä¿®æ”¹ClientMasterManager send_model_to_server,å¯¹åº”Serverçš„handle_message_receive_model_from_clientã€‚ä¸å‘é€æ¨¡å‹å’Œæ ·æœ¬æ•°ç»™server,è€Œæ˜¯å‘é€ç»™åŒºå—é“¾ ç»Ÿä¸€å‘é€æ¨¡å‹çš„æ ¼å¼ ml_engine_adapterä¸­çš„å‡½æ•°model_params_to_deviceç”¨äºå¤„ç†æ”¶åˆ°çš„æ¨¡å‹,æ ¹æ®ml_engineçš„ç±»å‹å¯¹æ¨¡å‹è¿›è¡Œå¤„ç†,å¸Œæœ›åœ¨å‘é€ä¹‹å‰åœ¨Clientç«¯å°±è¿›è¡Œå¤„ç† é€šè¿‡æµ‹è¯•,è¾“å‡ºtype(ml_engine_adapter.model_params_to_device(self.args, weights, self.trainer_dist_adapter.device)),å¾—åˆ°å…¶ç±»å‹æ˜¯collections.OrderedDictå®ƒä¹Ÿæ˜¯ä¸€ç§dict, å­˜å‚¨çš„æ˜¯model_params(string) to Tensorå¯¹ä»–è¿›è¡Œå¤„ç†,å˜æˆpythonåŸç”Ÿçš„dict,å¯¹Tensorå¤„ç†,å˜æˆpythonåŸç”Ÿçš„list,ç›®çš„æ˜¯ä½¿å…¶å¯ä»¥å˜æˆjsonä¸²serveræ”¶åˆ°å,å¯¹å…¶dumps, å†å°†listè½¬æ¢æˆTensor 1234567from ...ml.engine import ml_engine_adaptermodel_params = ml_engine_adapter.model_params_to_device(self.args, weights, self.trainer_dist_adapter.device)model_params = {k:v.tolist() for k,v in model_params.items()}logging.info(&quot;Jingtian: type of model_params: %s&quot; % type(model_params))import jsonmodel_params_json = json.dumps(model_params)logging.info(&quot;Jingtian: model_params: &quot; + (model_params_json)) ç¼–å†™ChainCodeé“¾ä¸ŠAggregatorå®ç°æ€è·¯ChainCodeè¦å®ç°å­˜å‚¨æ¨¡å‹,å¹¶æ£€æµ‹æ¯è½®æ¨¡å‹æ˜¯å¦ä¸Šä¼ å®Œæ¯•,å‚è€ƒfabcarç¤ºä¾‹ä¸­é˜ŸCarçš„å®šä¹‰ä»¥åŠå¯¹Carçš„å¢æ”¹æŸ¥çš„ä»£ç ,è®¾è®¡Roundç»“æ„ 12345type Round struct { Models map[string]string // ClientID to Model RoundID string ClientNum int64} åªéœ€è¦æ£€æŸ¥Roundä¸­len(Model)ä¸ClientNumæ˜¯å¦ç›¸ç­‰å³å¯ ChainCodeåˆçº¦å®šä¹‰æ ¹æ®ä¸Šé¢çš„åˆ†æ,éœ€è¦ä¸€ä¸‹å‡ ä¸ªå‡½æ•° AddModel æ¥å—å¹¶å­˜å‚¨æœ¬åœ°æ¨¡å‹ ä¿å­˜ï¼š model-key model-weight model-sample-num params: RoundID string ClientID string model string(åŸå§‹jsonä¸²) QueryWetherAllReceived æ£€æŸ¥æ˜¯å¦å…¨éƒ¨æ”¶åˆ°,æ£€æŸ¥æ˜¯å¦å…¨éƒ¨æ”¶åˆ°,è¿”å›True or False params: RoundID string QueryAllReceived è‹¥å…¨éƒ¨æ”¶åˆ°,è¿”å›æ¨¡å‹,æ¨¡å‹æƒé‡å’Œæ¨¡å‹æ ·æœ¬æ•°ç›®,å¦åˆ™è¿”å›ç©º params: RoundID string UpdateGlobal æ¥å—Serverèšé›†åçš„,æ›´æ–°åçš„æ¨¡å‹,å¯¹åŒºå—é“¾å†…çš„å†…å®¹è¿›è¡Œæ›´æ–° params: ServerID string model-weight string NewRound æ–°å¢ä¸€ä¸ªRound,æ¯è½®å¼€å§‹æ—¶åˆ›å»º params: RoundID string ClientNum int64 æ ¹æ®ä»¥ä¸Šåˆ†æ,éœ€è¦åœ¨fedmlèŠ‚ç‚¹è¿è¡Œæ—¶ç”Ÿæˆä¸€ä¸ªid,serverçš„idè‡ªç„¶æˆä¸ºserver-id,clientçš„idè‡ªç„¶æˆä¸ºClientIDã€‚åœ¨æ¯è½®è®­ç»ƒå¼€å§‹å‰,éœ€è¦ç”ŸæˆRoundID,å¹¶ä¸”è°ƒç”¨NewRoundé€šçŸ¥åŒºå—é“¾ã€‚RoundIDçš„å‰nä¸ºä¸ServerIDç›¸åŒ,å†æ‹¼æ¥éšæœºç”Ÿæˆçš„ånä½ã€‚ é€šè¿‡ä»¥ä¸‹å‘½ä»¤è¿›è¡Œå¯¹ChainCodeçš„æµ‹è¯•ä¸Debug123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960## RoundID = &quot;ri&quot;## ServerID = &quot;si&quot;## ClientID = &quot;ci&quot;peer chaincode invoke -o orderer.fedfab.com:7050 --isInit --ordererTLSHostnameOverride orderer.fedfab.com --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;initialize&quot;, &quot;Initializing chaincode&quot;]}'## chaincode åˆå§‹åŒ–peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;NewRound&quot;, &quot;r1&quot;, &quot;2&quot;]}'peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;AddModel&quot;, &quot;r1&quot;, &quot;c1&quot;, &quot;{\\&quot;a\\&quot;:[1,2,3], \\&quot;b\\&quot;:[2,3,4], \\&quot;c\\&quot;:[3,4,5]}&quot;]}'peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;QueryWetherAllReceived&quot;, &quot;r1&quot;]}'peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;AddModel&quot;, &quot;r1&quot;, &quot;c2&quot;, &quot;{\\&quot;a\\&quot;:[1,2,3], \\&quot;b\\&quot;:[2,3,4], \\&quot;c\\&quot;:[3,4,5]}&quot;]}'peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;QueryWetherAllReceived&quot;, &quot;r1&quot;]}'peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;QueryAllReceived&quot;, &quot;r1&quot;]}'peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;UpdateGlobal&quot;, &quot;s1&quot;, &quot;{\\&quot;a\\&quot;:[1,2,3], \\&quot;b\\&quot;:[2,3,4], \\&quot;c\\&quot;:[3,4,5]}&quot;]}' fedmlæ‹¿åˆ°è¿”å›å€¼åå¯èƒ½è¦è¿›è¡Œä¸¤æ¬¡jsonè§£ææŠŠæ¨¡å‹å˜æˆjsonå,å½“ä½œæ™®é€šå­—ç¬¦ä¸²ä½œä¸ºè¯·æ±‚å‘é€,å‘é€è¯·æ±‚æ—¶æœ‰è¿›è¡Œäº†ä¾æ¬¡jsonç¼–ç å¢åŠ äº†jsonçš„è½¬ä¹‰å­—ç¬¦,å¢åŠ äº†å†—ä½™å­—ç¬¦å‡å°‘äº†ChainCodeç¼–å†™çš„å¤æ‚åº¦ Serveréœ€è¦çŸ¥é“Clientçš„idï¼Ÿ â€“ä¸éœ€è¦,QueryAllåå¯¹æ¯ä¸ªæ¨¡å‹æ±‚å¹³å‡å°±å¥½,ä¸éœ€è¦å‘é€ç»™Client æ›´æ–°åŒåçš„ChainCodeæ—¶,labelè¦æœ‰å˜åŒ–,å‘½ä»¤ä¸­çš„sequenceå‚æ•°è¦æ¯”ä¸Šä¸€æ¬¡é€’å¢ã€‚ ç¼–å†™ts APIä¸HTTP Server æ ¹æ®ä¸Šå‘¨çš„ttsaccçš„apiå’ŒHttp Server,ç›¸åŒçš„æ–¹æ³•å®ç°ä¸Šé¢5ä¸ªåŠŸèƒ½å¯¹åº”çš„apiå’Œæ¥å£ ä½¿ç”¨postManè¿›è¡Œæµ‹è¯• newRoundè°ƒç”¨æ—¶,client_numä½¿ç”¨string ç¼–å†™å¹¶æµ‹è¯•Yaml-Requestsçš„yamlé…ç½®æ–‡ä»¶123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263url: '10.128.196.184'port: '3000'methods: AddModel: type: 'post' async: false res-type: 'json' path: '/invokeChainCode/AddModel' params: peer: 0 org: 2 body: content-type: 'json' content: cid: 'c1' QueryWetherAllReceived: type: 'post' async: false res-type: 'json' path: '/invokeChainCode/QueryWetherAllReceived' params: peer: 0 org: 2 body: content-type: 'json' QueryAllReceived: type: 'post' async: false res-type: 'json' path: '/invokeChainCode/QueryAllReceived' params: peer: 0 org: 2 body: content-type: 'json' UpdateGlobal: type: 'post' async: false res-type: 'json' path: '/invokeChainCode/UpdateGlobal' params: peer: 0 org: 2 body: content-type: 'json' content: sid: 's1' NewRound: type: 'post' async: false res-type: 'json' path: '/invokeChainCode/NewRound' params: peer: 0 org: 2 body: content-type: 'json' content: client_num: '3' fedmlä¸­è°ƒç”¨api æ ¹æ®ä¹‹å‰çš„åˆ†æï¼Œåœ¨å¯¹åº”ä½ç½®è¿›è¡Œè°ƒç”¨ï¼Œå¹¶å¤„ç†è¿”å›å€¼ ç¼–å†™dockerfile åˆ›å»ºè‡ªå®šä¹‰é•œåƒ,ä¿®æ”¹é•œåƒä¸­çš„fedmlä»£ç  ä½¿ç”¨é•œåƒåˆ›å»ºcontainer,åœ¨containerä¸­è¿è¡Œä¿®æ”¹åçš„ä»£ç è¿›è¡Œæµ‹è¯•ä¿®æ”¹è¿‡çš„æ–‡ä»¶æœ‰ï¼š123456/home/tt/.local/lib/python3.10/site-packages/fedml/cross_silo/client/fedml_client_master_manager.py/home/tt/.local/lib/python3.10/site-packages/fedml/cross_silo/server/fedml_aggregator.py/home/tt/.local/lib/python3.10/site-packages/fedml/cross_silo/server/fedml_server_manager.py/home/tt/.local/lib/python3.10/site-packages/fedml/cross_silo/server/fedml_server_manager.py/home/tt/.local/lib/python3.10/site-packages/fedml/cross_silo/client/message_define.py/home/tt/.local/lib/python3.10/site-packages/fedml/cross_silo/server/message_define.py docker COPYCOPY éµå¾ªçš„è§„åˆ™ srcè·¯å¾„å¿…é¡»åœ¨æ„å»ºçš„ä¸Šä¸‹æ–‡ä¸­ srcæ˜¯ç›®å½• åˆ™å¤åˆ¶ç›®å½•çš„å…¨éƒ¨å†…å®¹,åŒ…æ‹¬æ–‡ä»¶ç³»ç»Ÿå…ƒæ•°æ® ä¸ä¼šå¤åˆ¶ç›®å½•æœ¬èº«,åªä¼šå¤åˆ¶å…¶å†…å®¹ srcæ˜¯ä»»ä½•å…¶ä»–ç±»å‹çš„æ–‡ä»¶ åˆ™å°†å…¶ä¸å…¶å…ƒæ•°æ®ä¸€èµ·å•ç‹¬å¤åˆ¶ dest ä»¥æ–œæ  / ç»“å°¾,å®ƒå°†è¢«è§†ä¸ºä¸€ä¸ªç›®å½•,å¹¶ä¸” src çš„å†…å®¹å°†å†™å…¥ dest/base(src) æŒ‡å®šäº†å¤šä¸ª src èµ„æº,æˆ–è€…ç”±äºä½¿ç”¨äº†é€šé…ç¬¦ åˆ™ dest å¿…é¡»æ˜¯ä¸€ä¸ªç›®å½•,å¹¶ä¸”å¿…é¡»ä»¥æ–œæ  / ç»“å°¾ dest ä¸ä»¥æ–œæ ç»“å°¾ å®ƒå°†è¢«è§†ä¸ºå¸¸è§„æ–‡ä»¶,å¹¶ä¸” src çš„å†…å®¹å°†å†™å…¥ dest dest ä¸å­˜åœ¨ è·¯å¾„ä¸­æ‰€æœ‰ç¼ºå¤±çš„ç›®å½•éƒ½ä¼šè‡ªåŠ¨åˆ›å»º docker é”™è¯¯è®°å½•1Error response from daemon: could not select device driver &quot;&quot; with capabilities: [[gpu]] è§£å†³æ–¹æ³• 12345678curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | \\ sudo apt-key add -distribution=$(. /etc/os-release;echo $ID$VERSION_ID)curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | \\ sudo tee /etc/apt/sources.list.d/nvidia-docker.listsudo apt-get updatesudo apt-get install -y nvidia-container-toolkitsudo systemctl restart docker å¦‚æœä¸Šé¢å‡ºé”™äº†,å…ˆä½¿ç”¨ä¸‹é¢çš„å‘½ä»¤ 1sudo rm -f $(grep -l &quot;nvidia.github.io&quot; /etc/apt/sources.list.d/* | grep -vE &quot;/nvidia-container-toolkit.list\\$&quot;) dockerfile æ–‡ä»¶1234567891011FROM fedml/fedml:cuda-11.4.0-devel-ubuntu20.04## RUN sudo apt upgrade python3RUN python -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade pipRUN pip3 config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simpleRUN pip3 install updateRUN pip3 install --upgrade fedmlCOPY ./fedml_files/fedml_client_master_manager.py /usr/local/lib/python3.8/dist-packages/fedml/cross_silo/client/COPY ./fedml_files/fedml_aggregator.py /usr/local/lib/python3.8/dist-packages/fedml/cross_silo/server/COPY ./fedml_files/fedml_server_manager.py /usr/local/lib/python3.8/dist-packages/fedml/cross_silo/server/COPY ./fedml_files/message_define.py /usr/local/lib/python3.8/dist-packages/fedml/cross_silo/server/COPY ./fedml_files/message_define.py /usr/local/lib/python3.8/dist-packages/fedml/cross_silo/client/ ç¼–è¯‘dockerfileçš„è„šæœ¬ 123456## docker image rm fedml:ttcp ~/.local/lib/python3.10/site-packages/fedml/cross_silo/client/fedml_client_master_manager.py ../fedml_dockerfile_context/fedml_files/cp ~/.local/lib/python3.10/site-packages/fedml/cross_silo/server/fedml_aggregator.py ../fedml_dockerfile_context/fedml_files/cp ~/.local/lib/python3.10/site-packages/fedml/cross_silo/server/fedml_server_manager.py ../fedml_dockerfile_context/fedml_files/cp ~/.local/lib/python3.10/site-packages/fedml/cross_silo/server/message_define.py ../fedml_dockerfile_context/fedml_files/docker build -t fedml:tt ../fedml_dockerfile_context è¿è¡Œæµ‹è¯•é—®é¢˜ï¼š ä¼šéšæœºæœ‰å‡ ä¸ªè¯·æ±‚è¢«æ‹’ç»è¿æ¥ å‡å°‘å‡ºå—æ—¶é—´åˆ°50ms ä¾ç„¶æ²¡æœ‰è§£å†³ä¿®æ”¹configtx.yamlä¸­çš„ä¸€ä¸ªå‚æ•° 1BatchTimeout: 50ms ç»™invokeå‡½æ•°åŠ Mutexäº’æ–¥é”,è®©å…¶åªèƒ½æŒ‰é¡ºåºæ‰§è¡Œ,é”è§£é™¤ååœ¨sleep 65ms ä¾ç„¶æ²¡æœ‰è§£å†³ è§‚å¯Ÿåˆ°è§‚å¯Ÿåˆ°MVCC_READ_CONFLICTæ€»æ˜¯åœ¨AddModelæ€»æ˜¯åœ¨AddModel, æ—¶å‡ºç° åœ¨Clientå‘é€Modelå‰,sleep(1*client_real_id),æ’é˜Ÿä¾æ¬¡ä¸Šä¼ ,ç»™åŒºå—é“¾ååº”çš„æ—¶é—´ï¼ˆå‡è®¾æ¨¡å‹è®­ç»ƒæ—¶é—´éƒ½å·®ä¸å¤šï¼‰ è¿˜æ˜¯æ²¡æœ‰è§£å†³ æ€»ç»“ ç»è¿‡å¤šå¤©çš„debugä¸è°ƒè¯•,æœ€ç»ˆåŸºæœ¬å¯ä»¥æ­£å¸¸è®­ç»ƒ,å­˜å‚¨åˆ°åŒºå—é“¾ä¸Š,ä½†æ˜¯æœ€å¤šåªè®­ç»ƒäº†44è½®,è¿˜æ˜¯åœ¨AddModelç¯èŠ‚å‡ºç°äº†MVCC_READ_CONFLICTã€‚ å¾ˆå¤šåœ°æ–¹è¦å¢åŠ sleepæ“ä½œ,å¢åŠ äº†è¿è¡Œæ—¶é—´ éœ€è¦ä¸€ä¸ªåè°ƒæ–¹å¼,é¿å…åŒæ—¶AddModelé€ æˆBlockChainå´©æºƒã€‚ å¯ä»¥å°è¯•ç”¨Serverè°ƒç”¨AddModel,Clientçš„æœ¬åœ°Modelè¿˜æ˜¯é€šè¿‡MQTTåè®®ä¼ é€ç»™Server,ç”±Serverç»Ÿä¸€ä¸Šé“¾ æˆ–è€…å¯ä»¥æ•è·å¼‚å¸¸,ä¿è¯serveræŒç»­è¿è¡Œ,Clientå‘ç°Addå¤±è´¥åˆ™é‡æ–°Add å¯»æ‰¾æ–¹æ³•å°†è¯·æ±‚ä¸²è¡ŒåŒ– æœ€æ–°è¿›å±• è§£å†³äº†MVCC_READ_CONFLICT,fedmlå’Œfabricå¯ä»¥ç›¸äº’é…åˆå®Œæˆæ•´ä¸ªè®­ç»ƒè¿‡ç¨‹,å¹¶ä¸”ä¸å‘ç”ŸMVCC_READ_CONFLICTç­‰é—®é¢˜ æ–°å®šä¹‰ä¸‰ä¸ªmqttæ¶ˆæ¯1234## tt defineMSG_TYPE_C2S_ADD_MODEL_READY = 8MSG_TYPE_C2S_ADD_MODEL_SEND = 9MSG_TYPE_S2C_START_ADD_MODEL = 10 è§£é‡Šï¼š MSG_TYPE_C2S_ADD_MODEL_READY, Client to Server,è®­ç»ƒå®Œæ¯•,å¯ä»¥å‘åŒºå—é“¾å‘é€AddModelã€‚çŸ¥ä¼šServer,serverçš„Aggregatoræ”¶é›†è¿™ä¸ªä¿¡æ¯ MSG_TYPE_S2C_START_ADD_MODEL, Server to Client, å½“å…¨éƒ¨readyæ—¶,ä¼šå‘Clientå¼€å§‹ä¾æ¬¡å‘é€è¿™ä¸ªæ¶ˆæ¯ã€‚ MSG_TYPE_C2S_ADD_MODEL_SEND, Client to Server,å½“ä¸€ä¸ªClientå°†Modelå‘é€åˆ°Chainå,å‘é€è¿™ä¸ªæ¶ˆæ¯åˆ°Server,Serveræ”¶åˆ°åå‘ä¸‹ä¸€ä¸ªClientå‘é€MSG_TYPE_S2C_START_ADD_MODELæ¶ˆæ¯,è®©ä¸‹ä¸€ä¸ªClientå¼€å§‹ä¸Šä¼ æ¨¡å‹ æ–¹æ³•å¸¦æ¥çš„é—®é¢˜ä¸æ€è€ƒï¼š ç”±äºinvokeå‡½æ•°çš„mutexé”å’Œåˆ»æ„çš„å»¶è¿Ÿ,ä»¥åŠä¸Šé¢é€šè¿‡ä¸‰ä¸ªä¿¡å·å®ç°çš„æ’é˜Ÿå‘ChainCodeå‘é€æ¨¡å‹,å¯¼è‡´æ•´ä¸ªç³»ç»Ÿè¿è¡Œçš„é€Ÿåº¦éå¸¸æ…¢ æœ‰äº›èŠ‚ç‚¹ç®—åŠ›å¼º,è®­ç»ƒå¿«,æœ‰äº›ç®—åŠ›ä½è®­ç»ƒæ…¢ã€‚ åªæœ‰è®­ç»ƒé€Ÿåº¦ç›¸ä¼¼çš„èŠ‚ç‚¹ä¼šç«äº‰AddModelçš„æƒåˆ©,è€Œç°åœ¨è¦è®©æ‰€æœ‰çš„Clientéƒ½è®­ç»ƒå®Œæˆåæ‰å¼€å§‹ä¸Šä¼ åŒºå—é“¾,è¿™æ ·ä¸€å®šç¨‹åº¦ä¸Šé™ä½äº†ç³»ç»Ÿçš„æ•ˆç‡ è§£å†³æ–¹æ³•ï¼ˆè®¾æƒ³ï¼‰ï¼š ç»´æŠ¤ä¸€ä¸ªé˜Ÿåˆ—ready,ä¸€ä¸ªå˜é‡sending,ä¸€ä¸ªå­—å…¸send readyè¡¨ç¤ºç›®å‰æ”¶åˆ°readyçš„Client sendingè¡¨ç¤ºå½“å‰æ­£åœ¨å‘é€ä½†æ²¡æ”¶åˆ°sendæ¶ˆæ¯çš„Client dictä¸­å­˜å‚¨ClientID to Bool,è¡¨ç¤ºClientIDæ˜¯å¦å·²ç»å‘é€,å³æ˜¯å¦ä¸ºsendçŠ¶æ€,å°†å­—å…¸åˆå§‹åŒ–å…¨ä¸ºFalse æ”¶åˆ°Ciçš„readyæ¶ˆæ¯å è‹¥sendingä¸ºNone,åˆ™è®©Ciå¼€å§‹å‘é€æ¨¡å‹,å°†sendingè®¾ä¸ºCi è‹¥sendingä¸ä¸ºNone,åŠ å…¥readyé˜Ÿåˆ— æ”¶åˆ°Ciçš„sendæ¶ˆæ¯å,å°†sendingè®¾ä¸ºNone,send[Ci]å˜æˆTrue,æ£€æµ‹sendå­—å…¸æ˜¯å¦å…¨ä¸ºTrue è‹¥å…¨ä¸ºTrue,è¿›è¡Œä¸‹ä¸€è½® è‹¥ä¸å…¨ä¸ºTrue è‹¥readyé˜Ÿåˆ—ä¸ä¸ºç©º,åˆ™ä»é˜Ÿåˆ—ä¸­å–å‡ºä¸‹ä¸€ä¸ªClient Cjè®©å…¶å‘é€æ¨¡å‹,sendingè®¾ä¸ºCj è‹¥readyé˜Ÿåˆ—ä¸ºç©º,åˆ™ç»§ç»­ç­‰å¾…readyæ¶ˆæ¯","link":"/home/2022/10/22/fedfab/fedml/4.%E4%B8%8Efabric%E9%80%9A%E4%BF%A1/"},{"title":"cha14.ç³»ç»Ÿç¼–ç¨‹æ¦‚å¿µ","text":"14.1ç¼–å†™ä¸€ç¨‹åºï¼Œè¯•å¯¹åœ¨å•ç›®å½•ä¸‹åˆ›å»ºå’Œåˆ é™¤å¤§é‡1å­—èŠ‚æ–‡ä»¶æ‰€éœ€çš„æ—¶é—´è¿›è¡Œåº¦é‡ã€‚è¯¥ç¨‹åºåº”ä»¥xNNNNNNå‘½åæ ¼å¼æ¥åˆ›å»ºæ–‡ä»¶ï¼Œå…¶ä¸­ NNNNNNä¸ºéšæœºçš„6ä½æ•°å­—ã€‚æ–‡ä»¶çš„åˆ›å»ºé¡ºåºä¸ç”Ÿæˆæ–‡ä»¶åç›¸åŒï¼Œä¸ºéšæœºæ–¹å¼ï¼Œåˆ é™¤æ–‡ä»¶åˆ™æŒ‰æ•°å­—å‡åºæ“ä½œï¼ˆåˆ é™¤ä¸åˆ›å»ºçš„é¡ºåºä¸åŒ)ã€‚æ–‡ä»¶çš„æ•°é‡(FN)å’Œæ–‡ä»¶æ‰€åœ¨ç›®å½•åº”ç”±å‘½ä»¤è¡ŒæŒ‡å®šã€‚é’ˆå¯¹ä¸åŒçš„NFå€¼ï¼ˆæ¯”å¦‚ï¼Œåœ¨1000å’Œ20000ä¹‹é—´å–å€¼ï¼‰å’Œä¸åŒçš„æ–‡ä»¶ç³»ç»Ÿï¼ˆæ¯”å¦‚ ext2ã€ext3å’Œ XFS)æ¥æµ‹é‡æ—¶é—´ã€‚éšç€NFçš„é€’å¢,æ¯ä¸ªæ–‡ä»¶ç³»ç»Ÿä¸‹è€—æ—¶çš„å˜åŒ–æ¨¡å¼å¦‚ä½•?ä¸åŒæ–‡ä»¶ç³»ç»Ÿä¹‹é—´ï¼Œæƒ…å†µåˆæ˜¯å¦‚ä½•å‘¢?å¦‚æœæŒ‰æ•°å­—å‡åºæ¥åˆ›å»ºæ–‡ä»¶ï¼ˆx000001ã€x000001ã€x0000002ç­‰)ï¼Œç„¶åä»¥ç›¸åŒé¡ºåºåŠ ä»¥åˆ é™¤ï¼Œç»“æœä¼šæ”¹å˜å—?å¦‚æœä¼šï¼ŒåŸå› ä½•åœ¨?æ­¤å¤–ï¼Œä¸Šè¿°ç»“æœä¼šéšæ–‡ä»¶ç³»ç»Ÿç±»å‹çš„ä¸åŒè€Œæ”¹å˜å—? c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include &lt;stdio.h&gt;#include &lt;limits.h&gt;#include &lt;string.h&gt;#include &lt;stdbool.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/times.h&gt;#include &lt;sys/time.h&gt;#define CHECK(flag, msg, ...) do { \\ if(!(flag)) {\\ fprintf(stderr, &quot;FATAL: &quot;); \\ fprintf(stderr, msg, ##__VA_ARGS__); \\ fprintf(stderr, &quot; ERROR: %s\\n&quot;, strerror(errno)); \\ exit(2); \\ } \\ } while(0)bool str2int(const char *num, int *ret) { errno = 0; char *end; *ret = strtol(num, &amp;end, 10); return !(end == num || *end != '\\0' || errno != 0);}int *seqArr(int len) { int *nums = malloc(len * sizeof(int)); for(int i = 0; i &lt; len; i++) { nums[i] = i; } return nums;}int* randArr(int len) { int *visited = malloc(len * sizeof(int)); int *nums = malloc(len * sizeof(int)); memset(visited, 0, len * sizeof(int)); for(int i = 0; i &lt; len; i++) { int uniq; while(visited[(uniq = rand() % len)]); visited[uniq] = 1; nums[i] = uniq; } free(visited); return nums;}char *path = NULL;void creatFiles(int *arr, int fn) { char *filename = (char *) malloc((9 + strlen(path))*sizeof(char)); for(int i = 0; i &lt; fn; i++) { sprintf(filename, &quot;%s/x%06d&quot;, path, arr[i]); int fd = open(filename, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH); CHECK(fd != -1, &quot;fail to open file %s, fd = %d&quot;, filename, fd); CHECK(write(fd, &quot; &quot;, 1) == 1, &quot;fail to write&quot;);// fsync(fd); // Synchronized I/O file integrity completionï¼Œèƒ½å¦ä¿è¯æ–‡ä»¶åˆ›å»ºï¼Ÿ close(fd); } free(filename);}struct RmFilesArgs { int *arr; int fn;};void rmFiles(void *args) { int *arr = ((struct RmFilesArgs*)args)-&gt;arr; int fn = ((struct RmFilesArgs*)args)-&gt;fn; char filename[8] = {0}; for(int i = 0; i &lt; fn; i++) { sprintf(filename, &quot;x%06d&quot;, arr[i]); unlink(filename); }}long clockTic = 0;// clock_t long int// time_t long int#define FIX_MINUS(x, max) ((x) &lt; 0 ? ((x)) : (x))void timeIt(void (*test)(void *args), void *args, double *system, double *user, double *process, double *real) { clock_t processStart, processEnd; struct timeval realStart, realEnd; struct tms start, end; CHECK((processStart = clock()) != (clock_t)-1, &quot;fail to get clock, ERROR: %s&quot;, strerror(errno)); CHECK(gettimeofday(&amp;realStart, NULL) != -1, &quot;fail to get timeofday, ERROR: %s&quot;, strerror(errno)); CHECK(times(&amp;start) != (clock_t)-1, &quot;fail to get times, ERROR: %s&quot;, strerror(errno)); test(args); CHECK(times(&amp;end) != (clock_t)-1, &quot;fail to get times, ERROR: %s&quot;, strerror(errno)); CHECK(gettimeofday(&amp;realEnd, NULL) != -1, &quot;fail to get timeofday, ERROR: %s&quot;, strerror(errno)); CHECK((processEnd = clock()) != (clock_t)-1, &quot;fail to get clock, ERROR: %s&quot;, strerror(errno)); *process = (double)(FIX_MINUS((processEnd - processStart), LONG_MAX)) / CLOCKS_PER_SEC; *real = (double)(FIX_MINUS((realEnd.tv_usec - realStart.tv_usec), LONG_MAX)) / 1000; *user = (double)(FIX_MINUS((end.tms_utime - start.tms_utime), LONG_MAX)) / clockTic; *system = (double)(FIX_MINUS((end.tms_stime - start.tms_stime), LONG_MAX)) / clockTic;#ifdef DEBUG char *format = &quot;system = %lfs, user = %lfs, process = %lfs, real = %lfms\\n&quot;; printf(format, *system, *user, *process, *real);#endif}int NOP(const char * command) { return 0;}int main(int argc, char **argv) { srand(time(NULL)); int fn = 0; char *format = &quot;system = %.4lfms, user = %.4lfms, process = %.4lfms, real = %.4lfms\\n&quot;; int (*bash)(const char *) = system;#ifndef COMMAND bash = NOP;#endif double system, user, process, real; for(int i = 1; i &lt; argc; i++) { if(strcmp(argv[i], &quot;-fn&quot;) == 0) { CHECK(i + 1 &lt; argc, &quot;no enough args\\n&quot;); const char *num = argv[++i]; CHECK(str2int(num, &amp;fn), &quot;%s is not a integer!\\n&quot;, num); } else if(strcmp(argv[i], &quot;-path&quot;) == 0) { CHECK(i + 1 &lt; argc, &quot;no enough args\\n&quot;); path = argv[++i]; } } clockTic = sysconf(_SC_CLK_TCK); CHECK(clockTic != -1, &quot;fail to get sysconf: _SC_CLK_TCK, ERROR:%s&quot;, strerror(errno)); int *randIntArr = randArr(fn); int *seqIntArr = seqArr(fn); creatFiles(randIntArr, fn);bash(&quot;ls -lh&quot;); timeIt(rmFiles, &amp;(struct RmFilesArgs){ .arr=seqIntArr, .fn=fn }, &amp;system, &amp;user, &amp;process, &amp;real);bash(&quot;ls -lh&quot;); printf(format, system * 1000, user * 1000, process * 1000, real); creatFiles(seqIntArr, fn);bash(&quot;ls -lh&quot;); timeIt(rmFiles, &amp;(struct RmFilesArgs){ .arr=seqIntArr, .fn=fn }, &amp;system, &amp;user, &amp;process, &amp;real);bash(&quot;ls -lh&quot;); printf(format, system * 1000, user * 1000, process * 1000, real); free(seqIntArr); free(randIntArr); return 0;} æ²¡æœ‰åˆ»æ„å¤æ‚åŒ–ï¼Œè¢«æµ‹å‡½æ•°æ‰§è¡Œç›¸åŒçš„å‡½æ•°ä¿è¯æµ‹è¯•çš„ç›¸å¯¹å‡†ç¡®æ€§ ç»“æœ1234gcc -O3 practice14.1.c -o practice14.1 ./practice14.1 -fn 1000 -path .system = 20.0000ms, user = 0.0000ms, process = 18.7450ms, real = 18.7320mssystem = 20.0000ms, user = 0.0000ms, process = 37.0100ms, real = 38.6430ms O3ä¼˜åŒ–æ‰CHECKå¤šä½™çš„while(0)å¾ªç¯ï¼Œè®¡æ—¶æ›´ç²¾ç¡®å¤§éƒ¨åˆ†æ—¶å€™ç¬¬äºŒæ¬¡å¤§äºç¬¬ä¸€æ¬¡reealå¶å°”ä¸ºè´Ÿæ•°ï¼Œå¾ˆå¥‡æ€ª è§£é‡Šç£ç›˜åˆ†åŒºçš„ç»“æ„ä¸ºï¼šå¼•å¯¼å— è¶…çº§å— ièŠ‚ç‚¹è¡¨ æ•°æ®å— å‡è®¾ièŠ‚ç‚¹è¡¨ä½¿ç”¨æ•°ç»„ç®¡ç†ï¼Œåˆ é™¤æ–‡ä»¶æ—¶éœ€è¦åˆ é™¤i-nodeã€‚å¦‚æœæŒ‰ç…§ä¸åˆ›å»ºé¡ºåºç›¸åŒçš„é¡ºåºåˆ é™¤æ–‡ä»¶ï¼Œé‚£ä¹ˆæ•°ç»„åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­éœ€è¦ç§»åŠ¨ $ \\sum_{i=0}^{n-1}i $ æ¬¡ã€‚ å¦‚æœéšæœºåˆ é™¤ï¼Œåˆ™ç§»åŠ¨æ¬¡æ•°ä¸€å®šå°äº$ \\sum_{i=0}^{n-1}i $ æ¬¡ã€‚","link":"/home/2023/04/28/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha14/"},{"title":"cha19.ç›‘æ§æ–‡ä»¶äº‹ä»¶","text":"19.1ç›‘æ§æŸä¸ªç›®å½•åŠå…¶æ‰€æœ‰å­ç›®å½•çš„ï¼Œåˆ›å»ºï¼Œåˆ é™¤æ”¹å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222//// Created by root on 5/22/23.//#define _XOPEN_SOURCE 600#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;limits.h&gt;#include &lt;sys/inotify.h&gt;#include &lt;stddef.h&gt;#include &lt;sys/stat.h&gt;#include &lt;ftw.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;alloca.h&gt;#include &lt;stdbool.h&gt;// å¯¹rootåŠå…¶å­ç›®å½•ä¸‹æ‰€æœ‰æ–‡ä»¶çš„åˆ›å»ºã€åˆ é™¤æ”¹åæ“ä½œç›‘æ§ï¼Œå¹¶æ”¯æŒç›‘æ§æ–°å»ºçš„å­ç›®å½•struct listNode { int wd; char *name; struct listNode *next;} *head;int len() { int l = 0; struct listNode *next = head-&gt;next; while (next) { l++; next = next-&gt;next; } return l;}struct listNode *newListNode(int wd, const char *name, struct listNode *next) { struct listNode *node = malloc(sizeof(struct listNode)); node-&gt;wd = wd; node-&gt;name = strdup(name); node-&gt;next = next; return node;}struct listNode *searchWD(const char *name) { struct listNode *next = head-&gt;next; while (next) { if(strcmp(next-&gt;name, name) == 0) { return next; } next = next-&gt;next; } return NULL;}struct listNode *search(int wd) { struct listNode *next = head-&gt;next; while (next) { if(next-&gt;wd == wd) { return next; } next = next-&gt;next; } return NULL;}bool delete(int wd) { struct listNode *next = head; while (next-&gt;next) { if(next-&gt;next-&gt;wd == wd) { struct listNode *del = next-&gt;next; next-&gt;next = next-&gt;next-&gt;next; free(del); return true; } next = next-&gt;next; } return false;}const uint32_t watch_mask = IN_CREATE|IN_DELETE|IN_DELETE_SELF|IN_MOVED_TO|IN_MOVED_FROM;int fd = -1;size_t read_event(void *ievent) { size_t numRead = read(fd, ievent, 10 * (sizeof(struct inotify_event) + NAME_MAX + 1)); if(numRead == -1) { fprintf(stderr, &quot;read1: %s\\n&quot;, strerror(errno)); return -1; } printf(&quot;readNum = %lu\\n&quot;, numRead); return numRead;}int addwatch(const char *path) { int wd; if((wd = inotify_add_watch(fd, path, watch_mask)) != -1) { struct listNode *e = NULL; if((e = search(wd)) == NULL) { head-&gt;next = newListNode(wd, path, head-&gt;next); } else { free(e-&gt;name); e-&gt;name = strdup(path); } fprintf(stderr, &quot;watching: %s\\n&quot;, path); return 0; } else { fprintf(stderr, &quot;fail to watch: %s, %s\\n&quot;, path, strerror(errno)); return -1; }}int nftw_read(const char *path, const struct stat *sbuf, int type, struct FTW *ftwb) { switch (sbuf-&gt;st_mode &amp; S_IFMT) { case S_IFDIR: break; default: return 0; } addwatch(path); return 0;}void update_monitor(struct inotify_event *ievent) { struct listNode *node = search(ievent-&gt;wd); char *new_path = malloc(strlen(node-&gt;name) + strlen(ievent-&gt;name) + 1 + 1); sprintf(new_path, &quot;%s/%s&quot;, node-&gt;name, ievent-&gt;name); struct stat stat1; if(stat(new_path, &amp;stat1) != -1) { if((stat1.st_mode &amp; S_IFMT) == S_IFDIR) {// addwatch(new_path); if(nftw(new_path, nftw_read, 10, FTW_PHYS) == -1) { fprintf(stderr, &quot;fail to traverse: %s, %s\\n&quot;, new_path, strerror(errno)); } } } free(new_path);}int nftw_del(const char *path, const struct stat *sbuf, int type, struct FTW *ftwb) { switch (sbuf-&gt;st_mode &amp; S_IFMT) { case S_IFDIR: break; default: return 0; }// addwatch(path); int wd = searchWD(path)-&gt;wd; inotify_rm_watch(fd,wd); delete(wd); return 0;}void rm_monitor(struct inotify_event *ievent, bool recursive) { if(recursive) { struct listNode *node = search(ievent-&gt;wd); char *new_path = malloc(strlen(node-&gt;name) + strlen(ievent-&gt;name) + 1 + 1); sprintf(new_path, &quot;%s/%s&quot;, node-&gt;name, ievent-&gt;name); if (nftw(new_path, nftw_del, 10, FTW_PHYS) == -1) { fprintf(stderr, &quot;fail to traverse: %s, %s\\n&quot;, new_path, strerror(errno)); } free(new_path); } else {// int wd = searchWD(new_path)-&gt;wd; inotify_rm_watch(fd,ievent-&gt;wd); delete(ievent-&gt;wd); }}void process_event(struct inotify_event *ievent) {// IN_CREATE|IN_DELETE|IN_DELETE_SELF|IN_MOVE printf(&quot;mask = %x\\n&quot;, ievent-&gt;mask); if(ievent-&gt;mask &amp; IN_CREATE) { printf(&quot;Monitor: File Creation: %s/%s\\n&quot;, search(ievent-&gt;wd)-&gt;name, ievent-&gt;name); update_monitor(ievent); } if(ievent-&gt;mask &amp; IN_DELETE) { printf(&quot;Monitor: File Deletion: %s, wd = %s\\n&quot;, ievent-&gt;name, search(ievent-&gt;wd)-&gt;name); } if(ievent-&gt;mask &amp; IN_DELETE_SELF) { printf(&quot;Monitor: File Deletion: %s, stop monitoring, wd = %s\\n&quot;, search(ievent-&gt;wd)-&gt;name, search(ievent-&gt;wd)-&gt;name); rm_monitor(ievent, false); } if(ievent-&gt;mask &amp; IN_MOVED_FROM) { printf(&quot;Monitor: File Move in, from: %s/%s\\n&quot;, search(ievent-&gt;wd)-&gt;name, ievent-&gt;name); rm_monitor(ievent, true); } if(ievent-&gt;mask &amp; IN_MOVED_TO) { printf(&quot;Monitor: File Move out, to: %s/%s\\n&quot;, search(ievent-&gt;wd)-&gt;name, ievent-&gt;name); update_monitor(ievent); }}int main(int argc, char *argv[]) { char *monitor_root = (argc &gt; 1) ? argv[1] : &quot;.&quot;; fd = inotify_init(); if(fd == -1) { fprintf(stderr, &quot;fail to init inotify: %s\\n&quot;, strerror(errno)); return 1; } head = newListNode(0, &quot;&quot;, NULL); if(head == NULL) { fprintf(stderr, &quot;fail to malloc head, %s\\n&quot;, strerror(errno)); return 2; } if(nftw(monitor_root, nftw_read, 10, FTW_PHYS) == -1) { fprintf(stderr, &quot;fail to traverse: %s, %s\\n&quot;, monitor_root, strerror(errno)); } void *ievent = malloc(10 * (sizeof(struct inotify_event) + NAME_MAX + 1)); for(;len()&gt;0;) { size_t numread = -1; if((numread = read_event(ievent)) == -1) { fprintf(stderr, &quot;read fail, sleep\\n&quot;); usleep(500000); continue; } for(void *p = ievent; p &lt; ievent + numread;) { struct inotify_event* e = (struct inotify_event *)p; p += e-&gt;len + sizeof(struct inotify_event); process_event(e); } } free(ievent);} todo:å¦‚æœreadäº†åŠä¸ªeventæ€ä¹ˆåŠ","link":"/home/2023/05/22/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha19/"},{"title":"cha12.ç³»ç»Ÿå’Œè¿›ç¨‹ä¿¡æ¯","text":"12.1ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œä»¥ç”¨æˆ·åä½œä¸ºå‘½ä»¤è¡Œå‚æ•°ï¼Œåˆ—è¡¨æ˜¾ç¤ºè¯¥ç”¨æˆ·ä¸‹æ‰€æœ‰æ­£åœ¨è¿è¡Œçš„è¿›ç¨‹IDå’Œå‘½ä»¤åã€‚ï¼ˆç¨‹åºæ¸…å•8-1ä¸­çš„userldFromName()å‡½æ•°å¯¹æœ¬é¢˜ç¨‹åºçš„ç¼–å†™å¯èƒ½ä¼šæœ‰æ‰€å¸®åŠ©ã€‚ï¼‰é€šè¿‡åˆ†æç³»ç»Ÿä¸­/proc/PID/statusæ–‡ä»¶çš„ Name:å’Œ Uid:å„è¡Œä¿¡æ¯ï¼Œå¯ä»¥å®ç°æ­¤åŠŸèƒ½ã€‚éå†ç³»ç»Ÿçš„æ‰€æœ‰/proc/PIDç›®å½•éœ€è¦ä½¿ç”¨readdir(3)å‡½æ•°ï¼Œ18.8èŠ‚å¯¹å…¶è¿›è¡Œäº†æè¿°ã€‚ç¨‹åºå¿…é¡»èƒ½å¤Ÿæ­£ç¡®å¤„ç†å¦‚ä¸‹å¯èƒ½æ€§:åœ¨ç¡®å®šç›®å½•å­˜åœ¨ä¸ç¨‹åºå°è¯•æ‰“å¼€ç›¸åº”/proc/PID/statusæ–‡ä»¶ä¹‹é—´ï¼Œ/proc/PIDç›®å½•æ¶ˆå¤±äº†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;unistd.h&gt;#include &lt;dirent.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;pwd.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt; #include &lt;unistd.h&gt;#include &lt;limits.h&gt;uid_t getUid(const char * user) { errno = 0; struct passwd *ret = getpwnam(user); if(ret == NULL) { fprintf(stderr, &quot;ERROR: fail to get uid of user '%s'\\n&quot;, user); exit(1); } return ret-&gt;pw_uid;}int get_pid_max() { FILE *pid_max = fopen(&quot;/proc/sys/kernel/pid_max&quot;, &quot;r&quot;); int ret = -1; fscanf(pid_max, &quot;%d&quot;, &amp;ret); fclose(pid_max); if(ret == -1) { fprintf(stderr, &quot;Error: fail to read /proc/sys/kernel/pid_max\\n&quot;); exit(3); } return ret;}int main(int argc, char **argv) { if(argc &lt; 2 || strcmp(argv[1], &quot;-help&quot;) == 0) { fprintf(stderr, &quot;Usage: user list [-help]\\n&quot;); exit(0); } pid_t pid_max = get_pid_max(); uid_t *uidlist = (uid_t *)alloca(argc * sizeof(uid_t)); pid_t **uid2pids = (pid_t **)alloca(argc * sizeof(pid_t*)); for(int i = 1; i &lt; argc; i++) { uidlist[i] = getUid(argv[i]); uid2pids[i] = (pid_t *)alloca((pid_max + 1) * sizeof(pid_t)); uid2pids[i][0] = 0; } DIR *proc = opendir(&quot;/proc&quot;); if(proc == NULL) { fprintf(stderr, &quot;ERROR: fail to read /proc: %s\\n&quot;, strerror(errno)); exit(1); } struct dirent *proc_rent = NULL; while((proc_rent = readdir(proc)) != NULL) { const char *spid = proc_rent-&gt;d_name; char *end; errno = 0; pid_t pid = strtol(spid, &amp;end, 10); if(end == spid || *end != '\\0' || errno != 0) { fprintf(stderr, &quot;INFO: %s/%s is not a pid\\n&quot;, &quot;/proc&quot;, spid); continue; } char filename[128] = {0}; sprintf(filename, &quot;/proc/%s/status&quot;, spid); FILE *status = fopen(filename, &quot;r&quot;); if(status == NULL) { fprintf(stderr, &quot;ERROR: fail to open %s\\n&quot;, filename); exit(4); } uid_t realUid = -1; char buffer[1024] = {0}; fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*s %u&quot;, &amp;realUid); //å¿½ç•¥å‰8è¡Œ if(realUid == -1) { fprintf(stderr, &quot;ERROR: fail to read Uid in %s/%s/status\\n&quot;, &quot;/proc&quot;, spid); exit(2); } for(int i = 1; i &lt; argc; i++) { if(realUid == uidlist[i]) { uid2pids[i][++uid2pids[i][0]] = pid; break; } } fclose(status); } for(int i = 1; i &lt; argc; i++) { printf(&quot;---------------Process of User: %s, uid = %u---------------\\n&quot;, argv[i], uidlist[i]); for(int j = 1; j &lt; uid2pids[i][0]; j++) { printf(&quot;\\tâ”œ %d\\n&quot;, uid2pids[i][j]); } if(uid2pids[i][0] == 0) { printf(&quot;\\t(nil)\\n&quot;); } else { printf(&quot;\\tâ”” %d\\n&quot;, uid2pids[i][uid2pids[i][0]]); } } closedir(proc);} /proc/PIDç›®å½•æ¶ˆå¤±æˆ‘è§‰å¾—ä¸è¦å»è¯»/proc/PIDç›®å½•å°±å¥½äº†ï¼Œç›´æ¥è¯»/proc/PID/statusï¼Œä¸å­˜åœ¨å°±è¿”å›NULLï¼Œ ç„¶åè¯»å–ä¸‹ä¸€ä¸ªpid 12.2å®ç°ä¸€ä¸ªpstree 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#include &lt;unistd.h&gt;#include &lt;dirent.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt; #include &lt;unistd.h&gt;#include &lt;limits.h&gt;int get_pid_max() { FILE *pid_max = fopen(&quot;/proc/sys/kernel/pid_max&quot;, &quot;r&quot;); int ret = -1; fscanf(pid_max, &quot;%d&quot;, &amp;ret); fclose(pid_max); if(ret == -1) { fprintf(stderr, &quot;Error: fail to read /proc/sys/kernel/pid_max\\n&quot;); exit(1); } return ret;}struct process { char *name; char *cmd; pid_t parent; pid_t pid; struct process *children; struct process *sibling;};char *append(char * str, const char *cat) { int len = strlen(str) + strlen(cat) + 1; char *ret = malloc(len*sizeof(char)); ret[0] = 0; strcat(ret, str); strcat(ret, cat); return ret;}int max(int a, int b) { return a&gt;b?a:b;}void prettyPrint(struct process *root, char *preffix, int last) { const char * tab = last ? &quot;â””&quot; : &quot;â”œ&quot;; printf(&quot;%sâ”‚â€¢Name=%s\\n&quot;, preffix, root-&gt;name); printf(&quot;%sâ”‚ pid=%d\\n&quot;, preffix, root-&gt;pid); printf(&quot;%sâ”‚ cmd=%s\\n&quot;, preffix, root-&gt;cmd); printf(&quot;%sâ”‚ ppid=%d\\n&quot;, preffix, root-&gt;parent); printf(&quot;%s%s&quot;, preffix, tab); struct process *move = root-&gt;children; if(move != NULL) { printf(&quot;â”¬&quot;); } else { printf(&quot;â”€&quot;); } int suff = max(max(strlen(root-&gt;name)+5, strlen(root-&gt;cmd)+4), 10); while(suff) {printf(&quot;â”€&quot;); suff--;} printf(&quot;\\n&quot;); preffix = append(preffix, (!last ? &quot;â”‚&quot; : &quot; &quot;)); while(move != NULL &amp;&amp; move-&gt;sibling != NULL) { prettyPrint(move, preffix, 0); move = move-&gt;sibling; } if(move != NULL) prettyPrint(move, preffix, 1);}int main(int argc, char **argv) {#ifndef DEBUG freopen(&quot;/dev/null&quot;, &quot;w&quot;, stderr);#endif long lim_filename = pathconf(&quot;/proc&quot;,_PC_NAME_MAX); long lim_argmax = sysconf(_SC_ARG_MAX); int pid_max = get_pid_max(); struct process **pidlist = (struct process **)malloc(pid_max * sizeof(struct process *)); pid_t *pids = (pid_t *)malloc(pid_max * sizeof(pid_t)); int pidscount = 0; pids[pidscount++] = 0; memset(pidlist, 0, pid_max * sizeof(struct process *)); pidlist[0] = malloc(sizeof(struct process)); memcpy(pidlist[0], &amp;(struct process) { .name=NULL, //filename ? .cmd=NULL, .parent=-1, .pid=0, .children=NULL, .sibling=NULL }, sizeof(struct process)); char *filename = malloc((14 + lim_filename+1)*sizeof(char)); DIR *proc = opendir(&quot;/proc&quot;); struct dirent *proc_rent = NULL; while((proc_rent = readdir(proc)) != NULL) { const char *spid = proc_rent-&gt;d_name; char *end; errno = 0; pid_t pid = strtol(spid, &amp;end, 10); if(end == spid || *end != '\\0' || errno != 0) { fprintf(stderr, &quot;INFO: %s/%s is not a pid\\n&quot;, &quot;/proc&quot;, spid); continue; } // if(pid == selfpid || pid == selfppid) continue; fprintf(stderr, &quot;INFO: current pid = %d\\n&quot;, pid); pidlist[pid] = malloc(sizeof(struct process)); memcpy(pidlist[pid], &amp;(struct process) { .name=malloc((lim_filename+1)*sizeof(char)), //filename ? .cmd=malloc((lim_argmax+1)*sizeof(char)), .parent=-1, .pid=pid, .children=NULL, .sibling=NULL }, sizeof(struct process)); pidlist[pid]-&gt;name[0] = 0; pidlist[pid]-&gt;cmd[0] = 0; sprintf(filename, &quot;/proc/%s/status&quot;, spid); FILE *status = fopen(filename, &quot;r&quot;); if(status == NULL) { fprintf(stderr, &quot;ERROR: fail to open %s\\n&quot;, filename); exit(4); } uid_t realUid = -1; char buffer[1024] = {0}; fscanf(status, &quot;%*s %s\\n&quot;, pidlist[pid]-&gt;name); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*s %d\\n&quot;, &amp;pidlist[pid]-&gt;parent); if(strcmp(pidlist[pid]-&gt;name, &quot;&quot;) == 0 || pidlist[pid]-&gt;parent == -1) { fprintf(stderr, &quot;ERROR: fail to read name or ppid in %s/%s/status\\n&quot;, &quot;/proc&quot;, spid); exit(2); } // printf(&quot;read /proc/%s/status, name = %s, ppid = %d\\n&quot;, spid,pidlist[pid]-&gt;name, pidlist[pid]-&gt;parent); sprintf(filename, &quot;/proc/%s/cmdline&quot;, spid); FILE *cmdline = fopen(filename, &quot;r&quot;); if(cmdline == NULL) { fprintf(stderr, &quot;ERROR: fail to open %s\\n&quot;, filename); exit(4); } fscanf(cmdline, &quot;%s&quot;, pidlist[pid]-&gt;cmd); // printf(&quot;read cmdline = %s\\n&quot;, pidlist[pid]-&gt;cmd); fclose(cmdline); fclose(status); pids[pidscount++] = pid; // pid_t ppid = pidlist[pid]-&gt;parent; // pidlist[pid]-&gt;sibling = pidlist[ppid]-&gt;children; // pidlist[ppid]-&gt;children = pidlist[pid]; // ä¸èƒ½åœ¨è¿™é‡Œæ‰¾çˆ¶èŠ‚ç‚¹ï¼Œçˆ¶èŠ‚ç‚¹å¯èƒ½è¿˜æ²¡è¯»å‡ºæ¥ã€‚ } for(int i = 1; i &lt; pidscount; i++) { pid_t pid = pids[i]; pid_t ppid = pidlist[pid]-&gt;parent; pidlist[pid]-&gt;sibling = pidlist[ppid]-&gt;children; pidlist[ppid]-&gt;children = pidlist[pid]; } closedir(proc); prettyPrint(pidlist[1], memset(malloc(sizeof(char)), 0, sizeof(char)), 1); for(int i = 0; i &lt; pidscount; i++) { free(pidlist[pids[i]]-&gt;name); free(pidlist[pids[i]]-&gt;cmd); free(pidlist[pids[i]]); } free(filename); free(pids); free(pidlist); return 0;} 12.3ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œåˆ—è¡¨å±•ç¤ºæ‰“å¼€åŒä¸€ç‰¹å®šè·¯å¾„åæ–‡ä»¶çš„æ‰€æœ‰è¿›ç¨‹ã€‚å¯ä»¥é€šè¿‡åˆ†ææ‰€æœ‰/proc/PID/fd/*ç¬¦å·é“¾æ¥çš„å†…å®¹æ¥å®ç°æ­¤åŠŸèƒ½ã€‚è¿™éœ€è¦åˆ©ç”¨readdir(3)å‡½æ•°æ¥åµŒå¥—å¾ªç¯ï¼Œæ‰«ææ‰€æœ‰/proc/PIDç›®å½•ä»¥åŠæ¯ä¸ª/proc/PIDç›®å½•ä¸‹æ‰€æœ‰/proc/PID/fdçš„æ¡ç›®å†…å®¹ã€‚è¯»å–/proc/PID/fd/nç¬¦å·é“¾æ¥çš„å†…å®¹ï¼Œéœ€è¦ä½¿ç”¨readlink(),18.5èŠ‚å¯¹å…¶è¿›è¡Œäº†æè¿°ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;unistd.h&gt;#include &lt;dirent.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt; #include &lt;unistd.h&gt;#include &lt;limits.h&gt;int get_pid_max() { FILE *pid_max = fopen(&quot;/proc/sys/kernel/pid_max&quot;, &quot;r&quot;); int ret = -1; fscanf(pid_max, &quot;%d&quot;, &amp;ret); fclose(pid_max); if(ret == -1) { fprintf(stderr, &quot;Error: fail to read /proc/sys/kernel/pid_max\\n&quot;); exit(1); } return ret;}int main(int argc, char **argv) { if(argc != 2) { fprintf(stderr, &quot;Usage: %s filename\\n&quot;, argv[0]); exit(0); }#ifndef DEBUG freopen(&quot;/dev/null&quot;, &quot;w&quot;, stderr);#endif int pid_max = get_pid_max(); long lim_argmax = sysconf(_SC_ARG_MAX); long lim_pathmax = pathconf(&quot;/proc&quot;,_PC_PATH_MAX); pid_t *pids = malloc(pid_max * sizeof(pid_t)); int pidscount = 0; DIR *proc = opendir(&quot;/proc&quot;); if(proc == NULL) { fprintf(stderr, &quot;ERROR: fail to read /proc: %s\\n&quot;, strerror(errno)); exit(1); } struct dirent *proc_rent = NULL; char *fdname = alloca((lim_pathmax+1) * sizeof(char)); char *fdlink = alloca((lim_pathmax+1) * sizeof(char)); char *fdbuf = alloca((BUFSIZ + 1) * sizeof(char)); while((proc_rent = readdir(proc)) != NULL) { const char *spid = proc_rent-&gt;d_name; char *end; errno = 0; pid_t pid = strtol(spid, &amp;end, 10); if(end == spid || *end != '\\0' || errno != 0) { fprintf(stderr, &quot;INFO: %s/%s is not a pid\\n&quot;, &quot;/proc&quot;, spid); continue; } sprintf(fdname, &quot;/proc/%s/fd&quot;, spid); DIR *fd = opendir(fdname); struct dirent *fd_rent = NULL; while((fd_rent = readdir(fd)) != NULL) { errno = 0; int filedes = strtol(fd_rent-&gt;d_name, &amp;end, 10); if(end == fd_rent-&gt;d_name || *end != '\\0' || errno != 0) { fprintf(stderr, &quot;INFO: %s/%s is not a fd\\n&quot;, fdname, fd_rent-&gt;d_name); continue; } sprintf(fdlink, &quot;%s/%s&quot;, fdname, fd_rent-&gt;d_name); ssize_t readsize = readlink(fdlink, fdbuf, BUFSIZ); if(readsize == -1) { fprintf(stderr, &quot;ERROR: fail to read link: %s, %s\\n&quot;, fdlink, strerror(errno)); } fdbuf[readsize] = 0;#ifdef DEBUG fprintf(stderr, &quot;fdbuf = %s\\n&quot;, fdbuf);#endif if(strcmp(fdbuf, argv[1]) == 0) { pids[pidscount++] = pid;#ifndef DEBUG break;#endif } } closedir(fd); } closedir(proc); char *command = alloca((lim_argmax+1) * sizeof(char)); if(pidscount &gt; 0) { strcpy(command, &quot;ps -f -p&quot;); for(int i = 0; i &lt; pidscount; i++) { sprintf(command, &quot;%s %d&quot;, command, pids[i]); } } else { char *command = alloca((lim_argmax+1) * sizeof(char)); sprintf(command, &quot;ps -f -p %d&quot;, pid_max); } #ifdef DEBUG fprintf(stderr, &quot;command = %s\\n&quot;, command); #endif system(command); return 0;}","link":"/home/2023/04/24/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha12/"},{"title":"cha15.æ–‡ä»¶å±æ€§","text":"15.1 15.4èŠ‚ä¸­æè¿°äº†é’ˆå¯¹å„ç§æ–‡ä»¶ç³»ç»Ÿæ“ä½œæ‰€éœ€çš„æƒé™ã€‚è¯·ä½¿ç”¨shellå‘½ä»¤æˆ–ç¼–å†™ç¨‹åºæ¥å›ç­”æˆ–éªŒè¯ä»¥ä¸‹è¯´æ³•ã€‚aï¼‰å°†æ–‡ä»¶å±ä¸»çš„æ‰€æœ‰æƒé™â€œå‰¥å¤ºâ€åï¼Œå³ä½¿â€œæœ¬ç»„â€å’Œâ€œå…¶ä»–â€ç”¨æˆ·ä»æœ‰è®¿é—®æƒ,å±ä¸»ä¹Ÿæ— æ³•è®¿é—®æ–‡ä»¶ã€‚bï¼‰åœ¨ä¸€ä¸ªå¯è¯»ä½†æ— å¯æ‰§è¡Œæƒé™çš„ç›®å½•ä¸‹ï¼Œå¯åˆ—å‡ºå…¶ä¸­çš„æ–‡ä»¶åï¼Œä½†æ— è®ºæ–‡ä»¶æœ¬èº«çš„æƒé™å¦‚ä½•ï¼Œä¹Ÿä¸èƒ½è®¿é—®å…¶å†…å®¹ã€‚cï¼‰è¦åˆ›å»ºä¸€ä¸ªæ–°æ–‡ä»¶ï¼Œæ‰“å¼€ä¸€ä¸ªæ–‡ä»¶è¿›è¡Œè¯»æ“ä½œï¼Œæ‰“å¼€åŠåˆ é™¤ä¸€ä¸ªæ–‡ä»¶,çˆ¶ç›®å½•å’Œæ–‡ä»¶æœ¬èº«åˆ†åˆ«éœ€è¦å…·å¤‡ä½•ç§æƒé™?å¯¹æ–‡ä»¶æ‰§è¡Œé‡å‘½åæ“ä½œæ—¶ï¼ŒæºåŠç›®æ ‡ç›®å½•åˆ†åˆ«éœ€è¦å…·å¤‡ä½•ç§æƒé™?è‹¥é‡å‘½åæ“ä½œçš„ç›®æ ‡æ–‡ä»¶å·²å­˜åœ¨ï¼Œè¯¥æ–‡ä»¶éœ€è¦å…·å¤‡ä½•ç§æƒé™?ä¸ºç›®å½•è®¾ç½®stickyä½(chmod +t)ï¼Œå°†å¦‚ä½•å½±å“é‡å‘½åå’Œåˆ é™¤æ“ä½œ? aç”±æ£€æŸ¥æƒé™çš„æ–¹å¼å¯çŸ¥ï¼Œå…ˆæ£€æŸ¥æœ‰æ•ˆç”¨æˆ·idä¸å±ä¸»idæ˜¯å¦ç›¸åŒï¼Œä¸ç›¸åŒåˆ™æ£€éªŒæœ‰æ•ˆç»„idä¸å±ç»„gidæ˜¯å¦ç›¸åŒï¼Œä»ä¸ç›¸åŒåˆ™æŒ‰ç…§å…¶ä»–ç”¨æˆ·çš„æƒé™è®¿é—®ã€‚ä½†ç”±äºrootç”¨æˆ·ç”¨äºæ‰€æœ‰èƒ½åŠ›ï¼Œæ‰€ä»¥è¯¥å‘½é¢˜åœ¨æ²¡æœ‰å‰ææ¡ä»¶å±ä¸»ä¸ä¸ºrootæ—¶è¯¥å‘½é¢˜ä¸ºå‡ï¼Œè‹¥æœ‰è¯¥å‰ææ¡ä»¶ï¼Œåˆ™å¯çŸ¥a)ä¸ºçœŸã€‚ 123touch tmpchmod 066 tmpecho aaa &gt; tmp # Permission Denied bæ–‡ä»¶å¤¹æ˜¯ä¸€ä¸ªç‰¹æ®Šæ–‡ä»¶ï¼Œç”±readdir, opendirç³»ç»Ÿè°ƒç”¨å¯çŸ¥ï¼Œå…¶ä¸­çš„å†…å®¹å°±æ˜¯æ–‡ä»¶ç›¸å…³çš„ä¿¡æ¯ã€‚æœ‰è¯»æƒé™ï¼Œåˆ™å¯çŸ¥ç›®å½•ä¸‹å­˜åœ¨å“ªäº›æ–‡ä»¶ï¼›æœ‰å†™æƒé™ï¼Œåˆ™å¯ä»¥å¯¹æ–‡ä»¶å…ƒæ•°æ®ä¿®æ”¹ï¼›æœ‰æœç´¢æƒé™åˆ™å¯å¯¹å…¶ä¸­æ–‡ä»¶è¿›è¡Œè®¿é—®ã€‚æ•…båœ¨ä¸è€ƒè™‘rootç”¨æˆ·çš„æƒ…å†µä¸‹ï¼Œä¹Ÿæ˜¯æ­£ç¡®çš„ 1234567mkdir dirtouch dir/tmpecho aaa &gt; dir/tmpchmod +r,-w,-x dircat dir/tmp # Permission Denied æ²¡æœ‰æœç´¢æƒmv dir/tmp dir/temp # Permission Denied æ²¡æœ‰å†™å…¥æƒls dir # Success æœ‰è¯»å–æƒ cè‡³å°‘éœ€è¦ä»¥ä¸‹æƒé™ æ“ä½œ çˆ¶ç›®å½•æƒé™ æ–‡ä»¶æƒé™ æ‰“å¼€+è¯» æœç´¢(+x) è¯»(+r) æ‰“å¼€+åˆ é™¤ æœç´¢(+x) å†™(+w) æ— éœ€æƒé™ æ“ä½œ æºç›®å½• ç›®æ ‡ç›®å½• ç›®æ ‡æ–‡ä»¶(è‹¥å·²å­˜åœ¨) é‡å‘½å å†™(+w) æœç´¢(+x) å†™(+w) æœç´¢(+x) æ— éœ€æƒé™ é‡å‘½å(æº sticky) å†™(+w) æœç´¢(+x) å†™(+w) æœç´¢(+x) æ— éœ€æƒé™ é‡å‘½å(ç›®æ ‡ sticky) é‡å‘½å(æº+ç›®æ ‡ sticky) åœ¨æ‹¥æœ‰stickyæ ‡å¿—çš„ç›®å½•ä¸‹åˆ é™¤å…¶ä»–ç”¨æˆ·çš„æ–‡ä»¶ï¼Œä¾ç„¶èƒ½åˆ ï¼Œåªæ˜¯ä¼šåœ¨åˆ é™¤æ—¶æŠ¥é”™rm: remove write-protected regular file 'tmp'? ï¼Œè¾“å…¥yå³å¯ 15.2ä½ è®¤ä¸ºç³»ç»Ÿè°ƒç”¨stat()ä¼šæ”¹å˜æ–‡ä»¶3ä¸ªæ—¶é—´æˆ³ä¸­çš„ä»»æ„ä¹‹ä¸€å—?è¯·è§£é‡ŠåŸå› ã€‚ statåªè·å–çš„æ˜¯æ–‡ä»¶çš„ä¿¡æ¯ï¼Œè€Œä¸æ˜¯å»è®¿é—®æ–‡ä»¶ï¼Œå¯¹äºè½¯è¿æ¥ï¼Œå…¶å†…å®¹å°±æ˜¯å¦ä¸€ä¸ªæ–‡ä»¶çš„â€œåœ°å€â€ï¼Œå¯¹å…¶è§£å¼•ç”¨çš„è¿‡ç¨‹å°±æ˜¯å¯¹æ–‡ä»¶çš„è®¿é—®ï¼ˆä½†ç»è¿‡å®éªŒï¼Œå¹¶éè¿™æ ·ï¼‰ 15.3åœ¨è¿è¡ŒLinux 2.6çš„ç³»ç»Ÿä¸Šä¿®æ”¹ç¨‹åºæ¸…å•15-1(t_stat.c)ï¼Œä»¤å…¶å¯ä»¥çº³ç§’çº§ç²¾åº¦æ¥æ˜¾ç¤ºæ–‡ä»¶æ—¶é—´æˆ³ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//// Created by root on 5/17/23.//#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;sys/time.h&gt;void showlstat(const char *file) { struct stat stat1; if(lstat(file, &amp;stat1) == -1) { exit(1); } char accesstime[1024] = {0}; strftime(accesstime, 1024, &quot;%Y-%b-%a %H:%M:%S&quot;, localtime(&amp;stat1.st_atime)); char modifitime[1024] = {0}; strftime(modifitime, 1024, &quot;%Y-%b-%a %H:%M:%S&quot;, localtime(&amp;stat1.st_mtime)); char statustime[1024] = {0}; strftime(statustime, 1024, &quot;%Y-%b-%a %H:%M:%S&quot;, localtime(&amp;stat1.st_ctime)); printf(&quot;device-id\\t : %lu\\n&quot;, stat1.st_dev); printf(&quot;inode \\t : %lu\\n&quot;, stat1.st_ino); printf(&quot;file-type\\t : %o\\n&quot;, stat1.st_mode); printf(&quot;hard-link\\t : %lu\\n&quot;, stat1.st_nlink); printf(&quot;owner-uid\\t : %u\\n&quot;, stat1.st_uid); printf(&quot;owner-gid\\t : %u\\n&quot;, stat1.st_gid); printf(&quot;st_rdev \\t : %lu\\n&quot;, stat1.st_rdev); printf(&quot;file-size\\t : %ld\\n&quot;, stat1.st_size); printf(&quot;block-size\\t : %ld\\n&quot;, stat1.st_blksize); printf(&quot;block-number\\t : %ld\\n&quot;, stat1.st_blocks); printf(&quot;last-access\\t : %s.%ld\\n&quot;, accesstime, stat1.st_atim.tv_nsec); printf(&quot;last-modify\\t : %s.%ld\\n&quot;, modifitime, stat1.st_mtim.tv_nsec); printf(&quot;last-stat\\t : %s.%ld\\n&quot;, statustime, stat1.st_ctim.tv_nsec);}void showstat(const char *file) { struct stat stat1; if(stat(file, &amp;stat1) == -1) { exit(1); } char accesstime[1024] = {0}; strftime(accesstime, 1024, &quot;%Y-%b-%a %H:%M:%S&quot;, localtime(&amp;stat1.st_atim)); char modifitime[1024] = {0}; strftime(modifitime, 1024, &quot;%Y-%b-%a %H:%M:%S&quot;, localtime(&amp;stat1.st_mtim)); char statustime[1024] = {0}; strftime(statustime, 1024, &quot;%Y-%b-%a %H:%M:%S&quot;, localtime(&amp;stat1.st_ctim)); printf(&quot;device-id\\t : %lu\\n&quot;, stat1.st_dev); printf(&quot;inode \\t : %lu\\n&quot;, stat1.st_ino); printf(&quot;file-type\\t : %o\\n&quot;, stat1.st_mode); printf(&quot;hard-link\\t : %lu\\n&quot;, stat1.st_nlink); printf(&quot;owner-uid\\t : %u\\n&quot;, stat1.st_uid); printf(&quot;owner-gid\\t : %u\\n&quot;, stat1.st_gid); printf(&quot;st_rdev \\t : %lu\\n&quot;, stat1.st_rdev); printf(&quot;file-size\\t : %ld\\n&quot;, stat1.st_size); printf(&quot;block-size\\t : %ld\\n&quot;, stat1.st_blksize); printf(&quot;block-number\\t : %ld\\n&quot;, stat1.st_blocks); printf(&quot;last-access\\t : %s\\n&quot;, accesstime); printf(&quot;last-modify\\t : %s\\n&quot;, modifitime); printf(&quot;last-stat\\t : %s\\n&quot;, statustime);}int main(int argc, char **argv) { for(int i = 1; i &lt; argc; i++) { showstat(argv[i]); showlstat(argv[i]); } return 0;} 15.412345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//// Created by root on 5/17/23.//#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int check_mode(int mask1, int mask2, int mask3, uid_t euid, gid_t egid, struct stat *stat1) { int granted = 0; if(stat1-&gt;st_uid == euid) { if(stat1-&gt;st_mode&amp;mask1) { granted++; } } else if (stat1-&gt;st_gid == egid) { if(stat1-&gt;st_mode&amp;mask2) { granted++; } } else { if(stat1-&gt;st_mode&amp;mask3) { granted++; } } return granted &gt; 0;}int eaccess(const char *pathname, int mode) {// if(mode&amp;F_OK) {// if(access(pathname, F_OK) == -1) {// return -1;// }// }// F_OKä¸º0 struct stat stat1; if(stat(pathname, &amp;stat1) == -1) { return -1; } uid_t euid = geteuid(); gid_t egid = getegid(); if(mode&amp;R_OK) { if(!check_mode(0400, 040, 04, euid, egid, &amp;stat1)) { return -1; } } if(mode&amp;W_OK) { if(!check_mode(0200, 020, 02, euid, egid, &amp;stat1)) { return -1; } } if(mode&amp;X_OK) { if(!check_mode(0100, 010, 01, euid, egid, &amp;stat1)) { return -1; } } return 0;}int main(int argc, char **argv) { if(argc != 3) return -1; int mode = *argv[2] - '0'; char *ok = &quot;ok&quot;; char smode[1024] = {0}; if(eaccess(argv[1], mode) == -1) { ok = &quot;fail&quot;; } if(mode&amp;R_OK) { strcat(smode, &quot;r&quot;); } if(mode&amp;W_OK) { strcat(smode, &quot;w&quot;); } if(mode&amp;X_OK) { strcat(smode, &quot;x&quot;); } printf(&quot;access for %s : %s\\n&quot;, smode ,ok); return 0;} 15.5linuxå†…æ ¸æä¾›äº†current_umask()å‡½æ•°ï¼Œåœ¨å¤´æ–‡ä»¶#include &lt;linux/fs.h&gt;ä¸­ 15.6å®ç°chmodçš„XåŠŸèƒ½ chmodchmodçš„å¤§å†™Xè¡¨ç¤º: execute/search only if the file is a directory or already has execute permission for some user (X) ä¹Ÿå°±æ˜¯è‹¥æŸäº›ç”¨æˆ·å·²ç»æœ‰äº†æ‰§è¡Œæƒé™æ—¶ï¼Œä¸ºå…¶èµ‹äºˆæ‰§è¡Œ/æœç´¢æƒé™ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;string.h&gt;#include &lt;stdbool.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;mode_t MODE = 0;mode_t UMASK = 0;int operation = 0; // bits from high to low represents, -/+/= ugobool flag_X = false;void step41(char *arg) { if(arg == NULL || *arg == 0) return; if(*arg == 'r') { if(operation&amp;01) { MODE |= 04; } if(operation&amp;02) { MODE |= 040; } if(operation&amp;04) { MODE |= 0400; } step41(arg+1); } else if(*arg == 'w') { if(operation&amp;01) { MODE |= 02; } if(operation&amp;02) { MODE |= 020; } if(operation&amp;04) { MODE |= 0200; } step41(arg+1); } else if(*arg == 'x') { if(operation&amp;01) { MODE |= 01; } if(operation&amp;02) { MODE |= 010; } if(operation&amp;04) { MODE |= 0100; } step41(arg+1); } else if(*arg == 'X') { flag_X = true; step41(arg+1); } else if(*arg == 's') { // u+s, g+s if(operation&amp;02) { MODE |= 02000; } if(operation&amp;04) { MODE |= 04000; } step41(arg+1); } else if(*arg == 't') { MODE |= 01000; step41(arg+1); } else { // undefined behavior }}void step42(char *arg) { if(arg == NULL || *arg == 0) return; int flag = *arg - '0'; if(operation&amp;01) { MODE |= flag; } if(operation&amp;02) { MODE |= flag&lt;&lt;3; } if(operation&amp;04) { MODE |= flag&lt;&lt;6; } step42(arg+1);}// parse: [rwxXst]+|[0-7]+void step3(char * arg) { if(arg == NULL || *arg == 0) return; if(*arg == 'r' || *arg == 'w' || *arg == 'x' || *arg == 'X' || *arg == 's' || *arg == 't') { step41(arg); } else if(*arg &gt;= '0' &amp;&amp; *arg &lt;= '7') { step42(arg); } else { // undefined behavior }}// parse: [-+=]([rwxXst]+|[0-7]+)void step2(char * arg) { if(arg == NULL || *arg == 0) return; if(*arg == '-') { operation |= 010; step3(arg+1); } else if(*arg == '+') { operation |= 020; step3(arg+1); } else if(*arg == '=') { operation |= 030; step3(arg+1); } else { // undefined behavior }}// åŸæœ¬çš„è¡¨è¾¾å¼æ˜¯: [ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+ï¼Œç®€åŒ–ä¸º// parse: [ugoa]*[-+=]([rwxXst]+|[0-7]+)void step1(char * arg) { if(arg == NULL || *arg == 0) return; if(*arg == 'u') { operation = 4; step1(arg+1); } else if(*arg == 'g') { operation = 2; step1(arg+1); } else if(*arg == 'o') { operation = 1; step1(arg+1); } else if(*arg == 'a') { operation = 7; step1(arg+1); } else { if(operation == 0) { operation = 7; } step2(arg); }}mode_t apply_mod(mode_t mode) { fprintf(stderr, &quot;MODE = %o\\n&quot;, MODE); mode_t mask = ((operation&amp;07) == 0) ? UMASK : 0; fprintf(stderr, &quot;op = %o\\n&quot;, operation); MODE = MODE &amp; (~mask); //00 0 //01 0 //10 1 //11 0 // //( a &amp; ~b ) é€»è¾‘å‡æ³• if((operation&amp;00070) == 010) { // - mode = mode &amp; (~MODE); if(flag_X &amp;&amp; (mode&amp;0111)) { mode = (~(0111) &amp; mode); // ä¸‰ä¸ªxxxå…¨éƒ½å˜æˆ0ï¼Œå…¶ä½™ä¸å˜ } } else if ((operation&amp;00070) == 020) { // + mode = mode | MODE; if(flag_X &amp;&amp; (mode&amp;0111)) { if(operation&amp;01) { mode |= 01; } if(operation&amp;02) { mode |= 010; } if(operation&amp;04) { mode |= 0100; } } } else if ((operation&amp;00070) == 030) { // = fprintf(stderr, &quot;flagX = %d, mode = %o\\n&quot;, flag_X, mode); if(flag_X &amp;&amp; (mode&amp;0111)) { if(operation&amp;01) { MODE |= 01; } if(operation&amp;02) { MODE |= 010; } if(operation&amp;04) { MODE |= 0100; //è¿™é‡Œçš„å¤§MODEï¼Œé˜²æ­¢ä¸€ä¼šmodeè¢«MODEè¦†ç›– } } // incase: chmod =X if(operation&amp;01) { mode = (07&amp;MODE) | ((~07)&amp;mode); } if(operation&amp;02) { mode = (070&amp;MODE) | ((~070)&amp;mode); } if(operation&amp;04) { mode = (0700&amp;MODE) | ((~0700)&amp;mode); } mode = (07000&amp;MODE) | ((~07000)&amp;mode); //000 0 //010 0 //100 1 //110 0 //001 0 //011 1 //101 1 //111 1 // //( b &amp; c )|( ~b &amp; a ) // æ ¹æ®æ©ç bç½®ä½ if(flag_X &amp;&amp; (mode&amp;0111)) { if(operation&amp;01) { mode |= 01; } if(operation&amp;02) { mode |= 010; } if(operation&amp;04) { mode |= 0100; } } } else { } operation = 0; MODE = 0; flag_X = false; return mode;}// parse_mod: split by ','mode_t parse_mod(char * arg, mode_t mode) { fprintf(stderr, &quot;old Mode = %o\\n&quot;, mode); char *end = NULL; while((end = strchr(arg, ',')) != NULL) { *end = 0; step1(arg); mode = apply_mod(mode); fprintf(stderr, &quot;new Mode = %o\\n&quot;, mode); arg = end+1; } step1(arg); mode = apply_mod(mode); fprintf(stderr, &quot;new Mode = %o\\n&quot;, mode); return mode;}mode_t current_umask() { mode_t old = umask(0); umask(old); return old;}int main(int argc, char **argv) {#ifndef DEBUG freopen(&quot;/dev/null&quot;, &quot;w&quot;, stderr);#endif int i = 1; UMASK = current_umask(); char *mode = NULL; for(; i &lt; argc-1; i++) { if(argv[i][0] == '-' &amp;&amp; argv[i][1] == '-') { // argument or --reference fprintf(stderr, &quot;unsupported argument: %s\\n&quot;, argv[i]); } else if(argv[i][0] &gt;= '0' &amp;&amp; argv[i][0] &lt;= '9') { // octal-mode while (*argv[i] != NULL) { MODE *= 8; MODE += *argv[i] - '0'; argv[i]++; } i++; break; } else { // mod mode = argv[i];// parse_mod(argv[i]); i++; break; } } fprintf(stderr, &quot;argv[i] = %s\\n&quot;, argv[i]); fprintf(stderr, &quot;mode = %s\\n&quot;, mode); // chmod if(mode == NULL) { for(; i &lt; argc; i++) { chmod(argv[i], MODE); } } else { for(; i &lt; argc; i++) { struct stat filestat; if (stat(argv[i], &amp;filestat) == -1) { fprintf(stderr, &quot;stat, error: %s\\n&quot;, strerror(errno)); } mode_t newMode = parse_mod(mode, filestat.st_mode); if (chmod(argv[i], newMode) == -1) { fprintf(stderr, &quot;chmod, error: %s\\n&quot;, strerror(errno)); } } } return 0;}// chmod u=s,g=s tmp.cçš„è¡Œä¸ºä¸chmodä¸åŒ(ä»…ä¸º=sæ—¶ä¸åŒï¼Œå…¶ä»–å«æœ‰å¤šä¸ªç­‰å·æ—¶ç›¸åŒ) 15.7å®ç°chattrç®€åŒ–ç‰ˆ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//// Created by root on 5/18/23.//// chattr [-+=aAcCdDeijPsStTuFx] [-v version] files...//Aï¼šå³Atimeï¼Œå‘Šè¯‰ç³»ç»Ÿä¸è¦ä¿®æ”¹å¯¹è¿™ä¸ªæ–‡ä»¶çš„æœ€åè®¿é—®æ—¶é—´ã€‚//Sï¼šå³Syncï¼Œä¸€æ—¦åº”ç”¨ç¨‹åºå¯¹è¿™ä¸ªæ–‡ä»¶æ‰§è¡Œäº†å†™æ“ä½œï¼Œä½¿ç³»ç»Ÿç«‹åˆ»æŠŠä¿®æ”¹çš„ç»“æœå†™åˆ°ç£ç›˜ã€‚//aï¼šå³Append Onlyï¼Œç³»ç»Ÿåªå…è®¸åœ¨è¿™ä¸ªæ–‡ä»¶ä¹‹åè¿½åŠ æ•°æ®ï¼Œä¸å…è®¸ä»»ä½•è¿›ç¨‹è¦†ç›–æˆ–æˆªæ–­è¿™ä¸ªæ–‡ä»¶ã€‚å¦‚æœç›®å½•å…·æœ‰è¿™ä¸ªå±æ€§ï¼Œç³»ç»Ÿå°†åªå…è®¸åœ¨è¿™ä¸ªç›®å½•ä¸‹å»ºç«‹å’Œä¿®æ”¹æ–‡ä»¶ï¼Œè€Œä¸å…è®¸åˆ é™¤ä»»ä½•æ–‡ä»¶ã€‚//bï¼šä¸æ›´æ–°æ–‡ä»¶æˆ–ç›®å½•çš„æœ€åå­˜å–æ—¶é—´ã€‚//cï¼šå°†æ–‡ä»¶æˆ–ç›®å½•å‹ç¼©åå­˜æ”¾ã€‚//dï¼šå½“dumpç¨‹åºæ‰§è¡Œæ—¶ï¼Œè¯¥æ–‡ä»¶æˆ–ç›®å½•ä¸ä¼šè¢«dumpå¤‡ä»½ã€‚//D:æ£€æŸ¥å‹ç¼©æ–‡ä»¶ä¸­çš„é”™è¯¯ã€‚//iï¼šå³Immutableï¼Œç³»ç»Ÿä¸å…è®¸å¯¹è¿™ä¸ªæ–‡ä»¶è¿›è¡Œä»»ä½•çš„ä¿®æ”¹ã€‚å¦‚æœç›®å½•å…·æœ‰è¿™ä¸ªå±æ€§ï¼Œé‚£ä¹ˆä»»ä½•çš„è¿›ç¨‹åªèƒ½ä¿®æ”¹ç›®å½•ä¹‹ä¸‹çš„æ–‡ä»¶ï¼Œä¸å…è®¸å»ºç«‹å’Œåˆ é™¤æ–‡ä»¶ã€‚//sï¼šå½»åº•åˆ é™¤æ–‡ä»¶ï¼Œä¸å¯æ¢å¤ï¼Œå› ä¸ºæ˜¯ä»ç£ç›˜ä¸Šåˆ é™¤ï¼Œç„¶åç”¨0å¡«å……æ–‡ä»¶æ‰€åœ¨åŒºåŸŸã€‚//uï¼šå½“ä¸€ä¸ªåº”ç”¨ç¨‹åºè¯·æ±‚åˆ é™¤è¿™ä¸ªæ–‡ä»¶ï¼Œç³»ç»Ÿä¼šä¿ç•™å…¶æ•°æ®å—ä»¥ä¾¿ä»¥åèƒ½å¤Ÿæ¢å¤åˆ é™¤è¿™ä¸ªæ–‡ä»¶ï¼Œç”¨æ¥é˜²æ­¢æ„å¤–åˆ é™¤æ–‡ä»¶æˆ–ç›®å½•ã€‚//t:æ–‡ä»¶ç³»ç»Ÿæ”¯æŒå°¾éƒ¨åˆå¹¶ï¼ˆtail-mergingï¼‰ã€‚//Xï¼šå¯ä»¥ç›´æ¥è®¿é—®å‹ç¼©æ–‡ä»¶çš„å†…å®¹ã€‚#include &lt;unistd.h&gt;#include &lt;linux/fs.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#define SUB 0#define ADD 1#define SET 2int main(int argc, char **argv) { int OP = -1; if(argv[1][0] == '-') { OP = 0; } else if (argv[1][0] == '+') { OP = 1; } else if(argv[1][0] == '=') { OP = 2; } int new_attr = 0; while (*argv[1]) { switch (*argv[1]) { case 'a': new_attr |= FS_APPEND_FL; break; case 'c': new_attr |= FS_COMPR_FL; break; case 'D': new_attr |= FS_DIRSYNC_FL; break; case 'i': new_attr |= FS_IMMUTABLE_FL; break; case 'j': new_attr |= FS_JOURNAL_DATA_FL; break; case 'A': new_attr |= FS_NOATIME_FL; break; case 'd': new_attr |= FS_NODUMP_FL; break; case 't': new_attr |= FS_NOTAIL_FL; break; case 's': new_attr |= FS_SECRM_FL; break; case 'S': new_attr |= FS_SYNC_FL; break; case 'T': new_attr |= FS_TOPDIR_FL; break; case 'u': new_attr |= FS_UNRM_FL; break; case 'C': break; case 'e': break; case 'E': break; case 'F': break; case 'I': break; } argv[1]++; } for(int i = 2; i &lt; argc; i++) { int fd = open(argv[i], O_RDONLY); if (fd == -1) continue; int attr; if (ioctl(fd, FS_IOC_GETFLAGS, &amp;attr) == -1) { continue; } if(OP==SUB) { attr = attr &amp; (~new_attr); }else if(OP == ADD) { attr = attr | new_attr; } else if(OP == SET) { attr = new_attr; } if (ioctl(fd, FS_IOC_SETFLAGS, &amp;attr) == -1) { continue; } close(fd); } return 0;}","link":"/home/2023/05/16/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha15/"},{"title":"cha18.ç›®å½•ä¸é“¾æ¥","text":"18.14.3.2èŠ‚æ›¾æŒ‡å‡ºï¼Œå¦‚æœä¸€ä¸ªæ–‡ä»¶æ­£å¤„äºæ‰§è¡ŒçŠ¶æ€ï¼Œé‚£ä¹ˆè¦å°†å…¶æ‰“å¼€ä»¥æ‰§è¡Œå†™æ“ä½œæ˜¯ä¸å¯èƒ½çš„(open)è°ƒç”¨è¿”å›-1ï¼Œä¸”å°†errnoç½®ä¸ºETXTBSYã€‚ç„¶è€Œï¼Œåœ¨ shell ä¸­æ‰§è¡Œå¦‚ä¸‹æ“ä½œå´æ˜¯å¯èƒ½çš„: 12345gcc -o longrunner longrunner.c$ ./longrunner &amp;# Leave running in backgroundvi longrunner.c# Make some changes to the source codegcc -o longrunner longrunner.c æœ€åä¸€æ¡å‘½ä»¤è¦†ç›–äº†ç°æœ‰çš„åŒåå¯æ‰§è¡Œæ–‡ä»¶ã€‚åŸå› ä½•åœ¨?(æç¤º:åœ¨æ¯æ¬¡ç¼–è¯‘åè°ƒç”¨ls -liå‘½ä»¤æ¥æŸ¥çœ‹å¯æ‰§è¡Œæ–‡ä»¶çš„i-nodeç¼–å·ã€‚) è§£é‡Šå˜å¼‚å‰åä½¿ç”¨ls -liï¼Œinodeç¡®å®å˜äº†ã€‚çŒœæµ‹-oå‚æ•°ä¼šä»¤ç¼–è¯‘ç¨‹åºå°†ä¸´æ—¶æ–‡ä»¶renameä¸ºå¯¹åº”åç§°ï¼Œrenameè‹¥newpathå­˜åœ¨ï¼Œåˆ™ä¼šè¦†ç›–ã€‚ 18.2æµ‹è¯•1234567891011121314151617181920//// Created by root on 5/20/23.//#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;int main() { mkdir(&quot;test&quot;, 0700); chdir(&quot;test&quot;); int fd = open(&quot;file&quot;, O_CREAT | O_RDWR, 0744); symlink(&quot;file&quot;, &quot;../file&quot;); chmod(&quot;../file&quot;, 0111); printf(&quot;errno = %s\\n&quot;, strerror(errno)); return 0;} åˆ†ææ‰“å°å‡ºerrnoï¼Œ ç»“æœä¸ºï¼š Too many levels of symbolic linksã€‚é€šè¿‡readlinkè¯»å–è¯¥é“¾æ¥ï¼Œå…¶å†…å®¹ä¸ºfileã€‚ é€šè¿‡llæ‰“å°ï¼Œè¯¥é“¾æ¥å˜æˆäº†æŒ‡å‘è‡ªå·±çš„é“¾æ¥ã€‚chmodå¯¹å…¶è§£å¼•ç”¨ï¼Œå¾—åˆ°è‡ªèº«ï¼Œå¯¼è‡´è§£å¼•ç”¨æ¬¡æ•°è¾¾åˆ°æœ€å¤§ã€‚ 1lrwxrwxrwx 1 root root 4 May 20 21:24 file -&gt; file 18.3å®ç°realpath 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//// Created by root on 5/20/23.//#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;limits.h&gt;void parse(char *path, char *realpath) { char *end = NULL; while (path != NULL) { end = strchr(path, '/'); if(end) *end = 0; if(path == end) {} else if (strcmp(path, &quot;.&quot;) == 0) { } else if (strcmp(path, &quot;..&quot;) == 0) { char *tmp = strrchr(realpath, '/'); if (tmp) { *tmp = 0; } } else { strcat(realpath, &quot;/&quot;); strcat(realpath, path); } if(end) path = end + 1; else path = NULL; }}int main(int argc, char **argv) { char *realpath = (char *) malloc(PATH_MAX + 1); char *buff = (char *) malloc(PATH_MAX + 1); realpath[0] = 0; buff[0] = 0; char *path = strdup(argv[1]); if(path[0] != '/') getcwd(realpath, NAME_MAX); parse(path, realpath); struct stat stat1; if(lstat(realpath, &amp;stat1) == -1) { fprintf(stderr, &quot;%s\\n&quot;, strerror(errno)); } if(S_ISLNK(stat1.st_mode)) { int readsize = readlink(realpath, buff, NAME_MAX); buff[readsize] = 0; struct stat stat2; if(stat(buff, &amp;stat2) != -1) { char *tmp = strrchr(realpath, '/'); if (tmp) { *tmp = 0; } parse(buff, realpath); } } printf(&quot;%s\\n&quot;, realpath); return 0;} 2023å¹´6æœˆ3æ—¥æ›´æ–°ä¹‹å‰æ²¡æœ‰è€ƒè™‘åˆ°ç›®å½•ä¹Ÿå¯ä»¥æœ‰è½¯é“¾æ¥ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//// Created by root on 5/20/23.//#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;limits.h&gt;void parse(char *path, char *realpath, char *buff) { char *end = NULL; while (path != NULL &amp;&amp; *path) { end = strchr(path, '/'); if(end) *end = 0; if(end == path) { } else if (strcmp(path, &quot;.&quot;) == 0) { } else if (strcmp(path, &quot;..&quot;) == 0) { char *tmp = strrchr(realpath, '/'); if (tmp) { *tmp = 0; } } else { strcat(realpath, &quot;/&quot;); strcat(realpath, path); struct stat stat1; if(lstat(realpath, &amp;stat1) == -1) { fprintf(stderr, &quot;%s:%s\\n&quot;, strerror(errno), realpath); exit(1); } if(S_ISLNK(stat1.st_mode)) { ssize_t readsize = readlink(realpath, buff, NAME_MAX); buff[readsize] = 0;// printf(&quot;%s is link to: %s\\n&quot;, realpath, buff); if(buff[0] == '/') { realpath[0] = 0; } else { char *tmp = strrchr(realpath, '/'); if (tmp) { *tmp = 0; } else { realpath[0] = 0; //ä¸éœ€è¦ï¼Œç›¸å¯¹è·¯å¾„å·²ç»å˜æˆç»å¯¹è·¯å¾„äº† } } parse(buff, realpath, buff); } } if(end) path = end + 1; else path = NULL; }}int main(int argc, char **argv) { char *realpath = (char *) malloc(PATH_MAX + 1); char *buff = (char *) malloc(PATH_MAX + 1); char *cwd = (char *) malloc(PATH_MAX + 1); cwd[0] = 0; realpath[0] = 0; buff[0] = 0; char *argpath = strdup(argv[1]); if(argpath[0] != '/') getcwd(cwd, NAME_MAX); parse(cwd, realpath, buff); parse(argpath, realpath, buff); printf(&quot;%s\\n&quot;, realpath); return 0;} 18.4æŠŠ18.4æ¢æˆreaddir_r ä»£ç æ‡’å¾—å†™ï¼Œæ— èŠ 18.5å®ç°getcwd 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//// Created by root on 5/21/23.//#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;dirent.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#include &lt;string.h&gt;struct list { char name[NAME_MAX+1]; struct list *next;} * head;struct list *new_list(const char *name, struct list *next) { struct list *ret = malloc(sizeof(struct list)); strcpy(ret-&gt;name, name); ret-&gt;next = next; return ret;}bool samestat(struct stat* stat1, struct stat* stat2) { return stat1-&gt;st_ino == stat2-&gt;st_ino &amp;&amp; stat1-&gt;st_dev == stat2-&gt;st_dev;}int main() { head = new_list(&quot;&quot;, NULL); long namemax = pathconf(&quot;.&quot;, _PC_NAME_MAX); char *buff = alloca(namemax + 1); buff[0] = 0; strcat(buff, &quot;../&quot;); while (true) { struct stat pwdstat, parentstat; stat(&quot;.&quot;, &amp;pwdstat); stat(&quot;..&quot;, &amp;parentstat); if (samestat(&amp;pwdstat, &amp;parentstat)) { break; } DIR *parent = opendir(&quot;..&quot;); struct dirent *parent_rent = NULL; while ((parent_rent = readdir(parent)) != NULL) { buff[3] = 0; strcat(buff + 3, parent_rent-&gt;d_name); struct stat readstat; stat(buff, &amp;readstat); if (samestat(&amp;readstat, &amp;pwdstat)) { printf(&quot;match! :%s\\n&quot;, parent_rent-&gt;d_name); head-&gt;next = new_list(parent_rent-&gt;d_name, head-&gt;next); break; } } fchdir(dirfd(parent)); closedir(parent); } struct list *p = head; while (p) { printf(&quot;%s/&quot;, p-&gt;name); p = p-&gt;next; } printf(&quot;\\n&quot;); return 0;} 18.6 18.7 18.8å®ç°nftw æ‡’å¾—å†™ 18.9å¦‚æœç¨‹åºä¸çŸ¥é“å½“å‰å·¥ä½œç›®å½•ï¼Œä¸”åœ¨å½“å‰ç›®å½•å’Œç›®æ ‡ç›®å½•ä¸‹éƒ½æ‰“å¼€äº†æ–‡ä»¶ï¼Œå…¶æ–‡ä»¶fdä¸ºfd1å’Œfd2é‚£ä¹ˆï¼Œfchdiræ•ˆç‡æ›´é«˜ã€‚ chdir: $ pwd=getcwd(), chdir(dir1), chdir(pwd), chdir(dir1), chdir(pwd), â€¦ $ fchdir $ fchdir(fd2), fchdir(fd1), fchdir(fd2), fchdir(fd1), â€¦ $ è·Ÿæ®Flawfinderçš„è¾“å‡ºï¼Œchdir, chownç­‰å‡½æ•°ä¾é è·¯å¾„åï¼Œæ”»å‡»è€…åœ¨è°ƒç”¨å‰å°†æ–‡ä»¶ç§»èµ°ï¼Œä¼šå¯¼è‡´chownï¼Œchdirå¤±è´¥ï¼Œä½¿ç”¨fchownï¼Œfchdirä¼šæ›´å®‰å…¨ã€‚ å³ï¼Œå°‘è°ƒç”¨ä¸€æ¬¡getpwd è‹¥åœ¨å½“å‰ç›®å½•ä¸‹æ‰“å¼€äº†æ–‡ä»¶ï¼Œè€Œæ²¡æœ‰ç›®æ ‡ç›®å½•ä¸‹çš„æ–‡ä»¶ $ chdir(dir1), fchdir(fd), chdir(dir1), fchdir(fd), â€¦ $","link":"/home/2023/05/20/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha18/"},{"title":"cha20.ä¿¡å·:åŸºæœ¬æ¦‚å¿µ","text":"20.2å±•ç¤ºSIG_IGNä¸€å®šä¸ä¼šæ”¶åˆ°ä¿¡å· 123456789101112131415161718192021222324//// Created by root on 5/23/23.//#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;int main() { signal(SIGINT, SIG_IGN); printf(&quot;set SIGINT(%s) as SIG_IGN. always ignore ctrl-c\\n&quot;, strsignal(SIGINT)); for(int i = 16; i &gt;= 0; i--) { sleep(1); printf(&quot;sleep %ds, try press ctrl-c\\n&quot;, i); } signal(SIGINT, SIG_DFL); printf(&quot;set SIGINT(%s) as SIG_DFL. always take default action for ctrl-c\\n&quot;, strsignal(SIGINT)); for(;;) { usleep(500000); printf(&quot;try press ctrl-c\\n&quot;); } return 0;} 20.3å±•ç¤ºsigactionæ—¶ï¼Œsa_nodeferå’Œsa_resethandçš„ä½œç”¨ 123456789101112131415161718192021222324252627282930313233343536373839404142//// Created by root on 5/23/23.//#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;void sigint_handler(int sig) { if(sig != SIGINT) { return; } printf(&quot;å–µï¼\\n&quot;); sleep(1); // sa_nodeferå¤„ç†è¿‡ç¨‹ä¸­ï¼Œä¸é˜»å¡sigint // æ­¤æ—¶è¿ç»­æŒ‰ctrl-cï¼Œå¯ä»¥å–µå¾ˆå¤šæ¬¡ printf(&quot;æ±ªï¼\\n&quot;);}int main() { sigaction(SIGINT, &amp;(struct sigaction){ .sa_handler = sigint_handler, .sa_flags = SA_NODEFER, }, NULL); printf(&quot;set SIGINT(%s) as SA_NODEFER\\n&quot;, strsignal(SIGINT)); for(int i = 16; i &gt;= 0; i--) { sleep(1); printf(&quot;sleep %ds, try press ctrl-c\\n&quot;, i); } sigaction(SIGINT, &amp;(struct sigaction){ .sa_handler = sigint_handler, .sa_flags = SA_RESETHAND, }, NULL); printf(&quot;set SIGINT(%s) as SA_RESETHAND\\n&quot;, strsignal(SIGINT)); for(;;) { usleep(500000); printf(&quot;try press ctrl-c\\n&quot;); } return 0;} sa_nodefersa_nodeferå¤„ç†è¿‡ç¨‹ä¸­ï¼Œä¸é˜»å¡sigintï¼Œæ­¤æ—¶è¿ç»­æŒ‰ctrl-cï¼Œå¯ä»¥å–µå¾ˆå¤šæ¬¡ sleepçš„ä¿¡å·å¥½åƒä¹Ÿè¢«sigintå¹²æ‰°äº† sa_resethandç­‰äºsa_oneshotï¼Œæ‰§è¡Œä¸€æ¬¡ï¼Œæ¢å¤é»˜è®¤ 20.4sigactionå®ç°siginterrupt siginterruptæ¥æº 123456789101112131415161718NAME siginterrupt - å…è®¸ä¿¡å·ä¸­æ–­ç³»ç»Ÿè°ƒç”¨ SYNOPSIS #include &lt;signal.h&gt; int siginterrupt(int sig, int flag);DESCRIPTION å½“ç³»ç»Ÿè°ƒç”¨è¢«ä¿¡å·sigä¸­æ–­æ—¶ï¼Œsiginterruptï¼ˆï¼‰å‡½æ•°å°†æ›´æ”¹é‡æ–°å¯åŠ¨è¡Œä¸ºã€‚ å¦‚æœflagå‚æ•°ä¸ºfalseï¼ˆ0ï¼‰ï¼Œ åˆ™å¦‚æœè¢«æŒ‡å®šçš„ä¿¡å·sigä¸­æ–­ï¼Œåˆ™å°†é‡æ–°å¯åŠ¨ç³»ç»Ÿè°ƒç”¨ã€‚ è¿™æ˜¯Linuxä¸­çš„é»˜è®¤è¡Œä¸ºã€‚ å¦‚æœflagå‚æ•°ä¸ºtrueï¼ˆ1ï¼‰å¹¶ä¸”æœªä¼ è¾“ä»»ä½•æ•°æ®ï¼Œåˆ™è¢«ä¿¡å·sigä¸­æ–­çš„ç³»ç»Ÿè°ƒç”¨å°†è¿”å›-1ï¼Œå¹¶ä¸”errnoå°†è®¾ç½®ä¸ºEINTRã€‚ å¦‚æœflagå‚æ•°ä¸ºtrueï¼ˆ1ï¼‰å¹¶ä¸”æ•°æ®ä¼ è¾“å·²å¼€å§‹ï¼Œåˆ™ç³»ç»Ÿè°ƒç”¨å°†è¢«ä¸­æ–­ï¼Œå¹¶å°†è¿”å›å®é™…ä¼ è¾“çš„æ•°æ®é‡ã€‚ RETURN VALUE siginterruptï¼ˆï¼‰å‡½æ•°æˆåŠŸè¿”å›0ã€‚ å¦‚æœä¿¡å·ç¼–å·sigæ— æ•ˆï¼Œåˆ™è¿”å›-1ï¼Œå¹¶å°†errnoè®¾ç½®ä¸ºæŒ‡ç¤ºé”™è¯¯åŸå› ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//// Created by root on 5/23/23.//#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#define true 1#define false 0#define isTrue(x) ((x) != 0)#define isFalse(x) ((x) == 0)void sigint_handler(int sig) { if(sig != SIGINT) { return; } printf(&quot;å–µï¼\\n&quot;); printf(&quot;æ±ªï¼\\n&quot;);}int __siginterrupt(int __sig, int __interrupt) { struct sigaction sigact, sigact1; sigaction(__sig, &amp;sigact1, &amp;sigact); if(isTrue(__interrupt)) { // add SA_RESTART sigact.sa_flags |= SA_RESTART; } else { // sub SA_RESTART sigact.sa_flags &amp;= ~SA_RESTART; } return sigaction(__sig, &amp;sigact, NULL);}int main() { void *buf[BUFSIZ]; sigaction(SIGINT, &amp;(struct sigaction) { .sa_handler = sigint_handler, .sa_flags = SA_NODEFER, }, NULL); __siginterrupt(SIGINT, false); pid_t pid = fork(); if(pid == 0) { kill(getppid(), SIGINT); } else { int fd = open(&quot;/proc/self/status&quot;, O_RDONLY); size_t read_num = 0, write_num; if ((read_num = read(fd, buf, BUFSIZ)) == -1) { printf(&quot;read_num = %lu\\n&quot;, read_num); printf(&quot;fail to read /proc/self/status, %s\\n&quot;, strerror(errno)); return errno; } if ((write_num = write(STDOUT_FILENO, buf, read_num)) != read_num) { printf(&quot;write_num = %lu\\n&quot;, write_num); printf(&quot;fail to write STDOUT_FILENO, %s\\n&quot;, strerror(errno)); return errno; } } return 0;} éªŒè¯ä¸å¤ªæˆåŠŸï¼Œå¯ä»¥å‚è€ƒè¿™ç¯‡æ–‡ç« ï¼Œåˆ›å»ºå¹¶ç­‰å¾…æ¶ˆæ¯é˜Ÿåˆ—","link":"/home/2023/05/23/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha20/"},{"title":"cha21.ä¿¡å·:ä¿¡å·å¤„ç†å™¨å‡½æ•°","text":"21.1å®ç°abort 123456789101112131415161718192021void __abort(void) { fflush(NULL); // éšä¾¿è¾“å‡ºç‚¹ä»€ä¹ˆå§ void *buff = malloc(BUFSIZ); int cd = open(&quot;coredump&quot;, O_RDWR | O_CREAT, 0644); int mem = open(&quot;/proc/self/stack&quot;, O_RDONLY); size_t readsize; while((readsize = read(mem, buff, BUFSIZ)) &gt; 0) { write(cd, buff, readsize); } close(cd); close(mem); // åé¢è¿™ä¸‰è¡Œ+fflushå°±å¤Ÿäº†å§ printf(&quot;raise SIGABRT\\n&quot;); raise(SIGABRT); printf(&quot;signal SIG_DFL\\n&quot;); signal(SIGABRT, SIG_DFL); printf(&quot;raise SIGABRT\\n&quot;); raise(SIGABRT); printf(&quot;__abort return\\n&quot;);} è¯»åæ„Ÿå¯é‡å…¥é—®é¢˜è¿™ä¸€ç« é¦–å…ˆè®²äº†ä¿¡å·å¤„ç†å™¨å‡½æ•°çš„å¯é‡å…¥é—®é¢˜ã€‚è¿™æ˜¯ç”±äºæ‰§è¡Œä¿¡å·å¤„ç†å™¨å‡½æ•°æ—¶ï¼Œæœ‰å¯èƒ½å†æ¬¡è§¦å‘ä¿¡å·ï¼Œè°ƒç”¨è¯¥å‡½æ•°ã€‚ å¯¹äºCåº“å‡½æ•°ï¼Œå¤§é‡å­˜åœ¨å¯¹é™æ€æ•°æ®çš„ä¿®æ”¹ï¼Œå¦‚printfï¼Œscanf å¯¹éƒ¨åˆ†ç³»ç»Ÿè°ƒç”¨ï¼Œä¹Ÿå­˜åœ¨å¯¹é™æ€æ•°æ®çš„ä¿®æ”¹ï¼Œå¦‚cryptï¼Œgetpwnamç­‰ å¯¹å…¨å±€å˜é‡ï¼Œerrnoï¼Œå¯¹ä»–ä»¬çš„ä¿®æ”¹éƒ½æ˜¯ä¸å®‰å…¨çš„ã€‚æ•…è€Œä¿¡å·å¤„ç†å™¨å‡½æ•°ä¸­ä½¿ç”¨çš„å…¨å±€å˜é‡å¿…é¡»å®šä¹‰ä¸º1volatile sig_atomic __variable_name; ä»–ä»¬éƒ½æ˜¯ä¸å¯é‡å…¥çš„ï¼Œåœ¨ä¿¡å·å¤„ç†å™¨å‡½æ•°ä¸­ä½¿ç”¨éƒ½æ˜¯ä¸å®‰å…¨çš„ã€‚ç”±æ­¤å®šä¹‰äº†å¼‚æ­¥ä¿¡å·å®‰å…¨å‡½æ•°ï¼Œå³ $$ å‡½æ•°æ˜¯å¯é‡å…¥çš„æˆ–æ˜¯ä¿¡å·å¤„ç†å™¨å‡½æ•°æ— æ³•å°†å…¶ä¸­æ–­çš„ $$POSIXï¼ŒSUSæŒ‡å‡ºäº†å“ªäº›å‡½æ•°æ˜¯å¼‚æ­¥ä¿¡å·å®‰å…¨çš„å‡½æ•°ï¼Œé™¤æ­¤ä¹‹å¤–éƒ½æ˜¯ä¸å®‰å…¨çš„ å€¼å¾—æ³¨æ„çš„æ˜¯: abortä¼šå¯¹stdioæµåˆ·æ–°ï¼Œä½†ä¾ç„¶æ˜¯å¼‚æ­¥ä¿¡å·å®‰å…¨çš„ã€‚ exitå‡½æ•°ä¼šå¯¹stdioæµåˆ·æ–°ï¼Œä½†ä¸æ˜¯å¼‚æ­¥ä¿¡å·å®‰å…¨çš„ã€‚ï¼ˆ_exitå®‰å…¨ï¼‰ ç»ˆæ­¢ä¿¡å·å¤„ç†å‡½æ•° _exit kill éæœ¬åœ°è·³è½¬ï¼ˆéœ€è¦ä½¿ç”¨sigsetjmp siglognjmpï¼Œæ¥ä¿å­˜sa_maskï¼‰ abort æ ˆæº¢å‡ºä¿¡å·å¤„ç†æ—¶ï¼Œä¿¡å·å¤„ç†å™¨å‡½æ•°çš„æ ˆçˆ†äº†ï¼Œä¼šäº§ç”ŸSIGSEGVä¿¡å·ï¼Œä¸ºäº†ä¿è¯è¿™ä¸ªä¿¡å·çš„æ­£å¸¸å¤„ç†ï¼Œåˆ†é…ä¸€å—â€å¤‡é€‰ä¿¡å·æ ˆâ€ã€‚ä½¿ç”¨sigaktstack SA_SIGINFOåœ¨ä½¿ç”¨sigactionæ—¶ï¼Œå¦‚æœä½¿ç”¨SA_SIGINFOæ ‡å¿—ï¼Œä¼šä½¿å…¶è¿”å›å¤šä½™ä¿¡æ¯ã€‚struct sigactionä¸­ï¼Œå‡½æ•°æŒ‡é’ˆä½ç½®æ˜¯ä¸€ä¸ªunionï¼Œä¸ºä¸¤ç§å‡½æ•°ç­¾åä¹‹ä¸€ï¼ˆä¸å¸¦å¤šä½™ä¿¡æ¯çš„å’Œå¸¦å¤šä½™ä¿¡æ¯çš„ï¼‰ã€‚ ç³»ç»Ÿè°ƒç”¨çš„ä¸­æ–­ ä½¿ç”¨whileå¾ªç¯æˆ–å® 12345while((cnt = read(xxx,xxx,xxx)) == -1 &amp;&amp; errno == EINTR);// or#include &lt;unistd.h&gt;NO_EINTR(cnt = read(xxx,xxx,xxx)); SA_RESTARTï¼Œä½¿ç”¨è¯¥flagï¼Œéƒ¨åˆ†ç³»ç»Ÿè°ƒç”¨ï¼Œä»¥åŠå»ºç«‹åœ¨å…¶ä¸Šçš„åº“å‡½æ•°ï¼Œæ˜¯å¯é‡å¯çš„ï¼›ä½†æŸäº›ç³»ç»Ÿè°ƒç”¨ï¼Œä»¥åŠå»ºç«‹åœ¨å…¶ä¸Šçš„åº“å‡½æ•°ï¼Œæ˜¯ç»å¯¹ä¸ä¼šé‡å¯çš„ã€‚ æŸäº›Linuxç³»ç»Ÿè°ƒç”¨ï¼Œæœªå¤„ç†çš„åœæ­¢ä¿¡å·ä¼šäº§ç”ŸEINTRé”™è¯¯ã€‚å½“å‘ç”ŸSIGSTOP SIGTSTP SIGTTIN SIGTTOUè€Œè¿›ç¨‹åœæ­¢ï¼Œåæœ‰æ”¶åˆ°SIGCONTæ¢å¤è¿›ç¨‹åï¼Œå°±æ˜¯äº§ç”Ÿè¿™ç§é”™è¯¯ã€‚ å¯¹äºsleepï¼Œä¹Ÿä¼šè¢«ä¸­æ–­ï¼Œä½†ä»–ä¸ä¼šäº§ç”Ÿé”™è¯¯ï¼Œåªæ˜¯è¿”å›å‰©ä½™ç§’æ•°","link":"/home/2023/05/24/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha21/"},{"title":"cha24.è¿›ç¨‹çš„åˆ›å»º","text":"1æ‰§è¡Œä¸‹é¢ä»£ç åä¼šäº§ç”Ÿå¤šå°‘æ–°è¿›ç¨‹ 123fork();fork();fork(); $ 2^3 -1 = 7 $ 123fork(); // Aï¼Œäº§ç”ŸBï¼Œ A+Bfork(); // Aäº§ç”ŸCï¼ŒBäº§ç”ŸDï¼Œ A+B+C+Dfork(); // ABCDäº§ç”ŸEFGHï¼ŒA+B+C+D+E+F+G+H 2ç¼–å†™ä¸€ä¸ªç¨‹åºä»¥ä¾¿éªŒè¯è°ƒç”¨vfork()ä¹‹åï¼Œå­è¿›ç¨‹å¯ä»¥å…³é—­ä¸€æ–‡ä»¶æè¿°ç¬¦ï¼ˆä¾‹å¦‚æè¿°ç¬¦0ï¼‰è€Œä¸å½±å“å¯¹åº”çˆ¶è¿›ç¨‹ä¸­çš„æ–‡ä»¶æè¿°ç¬¦ã€‚ æ— èŠä¸å†™ 3å‡è®¾å¯ä»¥ä¿®æ”¹ç¨‹åºæºä»£ç ï¼Œå¦‚ä½•åœ¨æŸä¸€ç‰¹å®šæ—¶åˆ»ç”Ÿæˆä¸€æ ¸å¿ƒè½¬å‚¨ï¼ˆcore dumpï¼‰æ–‡ä»¶ï¼Œè€ŒåŒæ—¶è¿›ç¨‹å¾—ä»¥ç»§ç»­æ‰§è¡Œ? fork()ï¼Œç„¶åå­è¿›ç¨‹ç«‹åˆ»è°ƒç”¨abort() 4åœ¨å…¶ä»–UNIXå®ç°ä¸Šå®éªŒç¨‹åºæ¸…å•24-5 ( fork_whos_on_first.cï¼‰ä¸­çš„ç¨‹åºï¼Œå¹¶åˆ¤æ–­åœ¨æ‰§è¡Œfork()åè¿™äº›ç³»ç»Ÿæ˜¯å¦‚ä½•è°ƒåº¦çˆ¶å­è¿›ç¨‹çš„ã€‚ ä¸å¼„å¥½éº»çƒ¦ 5å‡å®šåœ¨ç¨‹åºæ¸…å•24-6çš„ç¨‹åºä¸­ï¼Œå­è¿›ç¨‹ä¹Ÿéœ€è¦ç­‰å¾…çˆ¶è¿›ç¨‹å®ŒæˆæŸäº›æ“ä½œã€‚ä¸ºç¡®ä¿è¾¾æˆè¿™ä¸€ç›®çš„,åº”å¦‚ä½•ä¿®æ”¹ç¨‹åº? forkåå­è¿›ç¨‹sigsuspendï¼Œçˆ¶è¿›ç¨‹æ‰§è¡Œå®Œæˆåkillå­è¿›ç¨‹ï¼ˆå‘å­è¿›ç¨‹å‘é€ä¿¡å·ï¼‰","link":"/home/2023/06/19/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha24/"},{"title":"cha22.ä¿¡å·:é«˜çº§ç‰¹æ€§","text":"è¯»ä¹¦ç¬”è®°æ ¸å¿ƒè½¬å‚¨æ–‡ä»¶ ç‰¹å®šä¿¡å·ä¼šå¼•å‘è¿›ç¨‹åˆ›å»ºæ ¸å¿ƒè½¬å‚¨æ–‡ä»¶ï¼ˆå·¥ä½œç›®å½•ï¼‰å¹¶ç»ˆæ­¢ã€‚ æ ¸å¿ƒè½¬å‚¨æ–‡ä»¶(core)æ˜¯å†…å­˜æ˜ åƒçš„ä¸€ä¸ªæ–‡ä»¶ï¼Œåˆ©ç”¨è°ƒè¯•å™¨å¯ä»¥æŸ¥çœ‹åˆ°é€€å‡ºæ—¶çš„ä»£ç ã€æ•°æ®çŠ¶æ€ã€‚ P371å±•ç¤ºäº†ä¸ä¼šäº§ç”Ÿæ ¸å¿ƒè½¬å‚¨æ–‡ä»¶çš„æƒ…å†µï¼Œå¤§è‡´ä¸º æ²¡æœ‰å†™æƒé™ å­˜åœ¨ç¡¬é“¾æ¥å¤§äº1çš„åŒåæ–‡ä»¶ ç›®å½•ä¸å­˜åœ¨ ulimitç­‰é™åˆ¶ä¸º0 äºŒè¿›åˆ¶ç¨‹åºæ²¡æœ‰è¯»æƒé™ å·¥ä½œç›®å½•çš„æŒ‚è½½æ–¹å¼ä¸ºåªè¯» set-user/group-IDç¨‹åºè¿è¡Œè€…ä¸ºéæ–‡ä»¶å±ä¸»ï¼ˆç»„ï¼‰ /proc/sys/kenel/core_patternä¸­å­˜å‚¨äº†æ ¸å¿ƒè½¬å‚¨æ–‡ä»¶çš„å‘½åæ ¼å¼åŒ–å­—ç¬¦ä¸² ä¿¡å·å¤„ç†ã€ä¼ é€’ç‰¹æ®Šæƒ…å†µ SIGKILLå’ŒSIGSTOPçš„é»˜è®¤è¡Œä¸ºæ— æ³•æ”¹å˜ï¼Œæ— æ³•é˜»å¡ã€‚æ€»æ˜¯å¯ä»¥ä½¿ç”¨è¯¥ä¿¡å·å¤„ç†å¤±æ§è¿›ç¨‹ã€‚ å‰é¢è¯»ä¹¦ä¸è®¤çœŸ ä¿¡å·é˜»å¡å³å¯¹è¯¥ä¿¡å·çš„ä¼ é€’å»¶åï¼Œç›´åˆ°è¯¥ä¿¡å·ä»æ©ç ä¸­ç§»é™¤ã€‚ é™¤éæ˜¯å®æ—¶ä¿¡å·ï¼Œå¦åˆ™ä¸å¯¹é˜»å¡ä¿¡å·æ’é˜Ÿï¼Œæ¢å¤ä¿¡å·ååªä¼ é€’è¯¥ä¿¡å·ä¸€æ¬¡ SIGCONTæ¢å¤åœæ­¢çš„è¿›ç¨‹ SIGCONTæ€»ä¼šæ¢å¤è¿è¡Œï¼Œä¸è®ºè¯¥ä¿¡å·æ˜¯å¦è¢«é˜»å¡æˆ–å¿½ç•¥ åœ¨åœæ­¢çš„è¿›ç¨‹æ¢å¤ä¹‹å‰ï¼Œè‹¥æœ‰å…¶ä»–è¿›ç¨‹ä¼ é€’å…¶ä»–ä¿¡å·ï¼Œåˆ™è¯¥ä¿¡å·å¹¶æœªè¢«çœŸå®ä¼ é€’ã€‚ï¼ˆé™¤äº†sigkillï¼‰ æ”¶åˆ°SIGCONTæ—¶ï¼Œå¤„äºç­‰å¾…çŠ¶æ€çš„åœæ­¢ä¿¡å·å°†ä¼šè¢«ä¸¢å¼ƒã€‚åè¿‡æ¥ï¼Œæ”¶åˆ°åœæ­¢ä¿¡å·åï¼Œç­‰å¾…çŠ¶æ€çš„SIGCONTä¹Ÿä¼šè¢«ä¸¢å¼ƒ è‹¥ç”±ç»ˆç«¯äº§ç”Ÿçš„ä¿¡å·ï¼ˆSIGHUP SIGINT SIGQUIT SIGTTIN SIGTTOU SIGTSTPï¼‰è¢«å¿½ç•¥ï¼Œåˆ™ä¸åº”è¯¥æ”¹å˜å…¶ä¿¡å·å¤„ç½®ï¼ˆå¤„ç†å‡½æ•°ï¼‰ è¿™ä¸ªå¾ˆéš¾æ‡‚ï¼Œåé¢34ç« ä¼šè®² sigkillçš„åŠ›æ‰€ä¸èƒ½åŠè¿›ç¨‹ä¼‘çœ æ—¶ï¼Œæœ‰ä¸¤ç§ä¼‘çœ çŠ¶æ€ å¯æ‰“æ–­(TASK_INTERRUPTIBLE)ï¼Œpså‘½ä»¤ä¸­æ ‡è®°ä¸ºSã€‚å¦‚ç­‰å¾…ç»ˆç«¯è¾“å…¥ ä¸å¯æ‰“æ–­(TASK_UNINTERRUPTIBLE)ï¼Œpså‘½ä»¤ä¸­æ ‡è®°ä¸ºDã€‚å¦‚ç­‰å¾…ç£ç›˜IOå®Œæˆ åœ¨ä¸å¯æ‰“æ–­ä¼‘çœ æ—¶ï¼Œç›´åˆ°è„±ç¦»è¿™ç§çŠ¶æ€ï¼Œä»»ä½•ä¿¡å·ï¼ˆåŒ…æ‹¬sigkillï¼‰éƒ½ä¸ä¼šè¢«ä¼ é€’ å¦‚æœç”±äºå„ç§BUGå¯¼è‡´è¿›ç¨‹æŒç»­ä¸å¯æ‰“æ–­çš„æ–¹å¼killï¼Œè¯¥è¿›ç¨‹åªèƒ½é€šè¿‡é‡å¯çš„æ–¹å¼æ¶ˆç­ linux2.6åŠ å…¥äº†TASK_KILLABLEï¼Œç±»ä¼¼äºä¸å¯æ‰“æ–­çŠ¶æ€ï¼Œä½†æ˜¯å¯ä»¥ç”±è‡´å‘½ä¿¡å·å”¤é†’ ç¡¬ä»¶äº§ç”Ÿçš„ä¿¡å·ç¡¬ä»¶å¼‚å¸¸äº§ç”Ÿçš„ä¿¡å·ä¸€èˆ¬ä¸è®¾ç½®èƒ½æ­£å¸¸è¿”å›çš„ä¿¡å·å¤„ç†å™¨å‡½æ•°ï¼Œä¹Ÿä¸å°†å…¶å¿½ç•¥ã€é˜»å¡ã€‚ è‹¥è¿”å›ï¼Œå°†ä¼šé‡å¤è§¦å‘å¼‚å¸¸è‹¥å¿½ç•¥æˆ–é˜»å¡ï¼Œä»¥é™¤0é”™è¯¯ä¸ºä¾‹ï¼Œæ­¤æ—¶è¯¥å¦‚ä½•ç»§ç»­è¿è¡Œå‘¢ ä¸€èˆ¬æ¥å—é»˜è®¤è¡Œä¸ºï¼Œæˆ–ä¿¡å·å¤„ç†å‡½æ•°ä¸­longjmpæˆ–é€€å‡ºï¼ˆä¸è¦æ­£å¸¸è¿”å›ï¼‰ ä¿¡å·çš„åŒæ­¥ç”Ÿæˆå’Œå¼‚æ­¥ç”Ÿæˆä¿¡å·äº§ç”Ÿä¸€èˆ¬æ˜¯å¼‚æ­¥çš„ï¼Œä¹Ÿå°±æ˜¯ä¸ç¡®å®šæ˜¯å¦ä¼šç«‹åˆ»ä¼ é€’ä¿¡å·å¯¹äºï¼š ç¡¬ä»¶äº§ç”Ÿä¿¡å· raise, kill, killpgå‘è‡ªèº«å‘é€çš„ä¿¡å· æ˜¯åŒæ­¥äº§ç”Ÿçš„ï¼Œä¼šç«‹åˆ»ä¼ é€’ ä¿¡å·ä¼ é€’çš„æ—¶æœºä¸é¡ºåºä¼ é€’ åŒæ­¥ä¿¡å· ç¡¬ä»¶äº§ç”Ÿçš„ä¿¡å·ä¼šç«‹å³ä¼ é€’ï¼Œraiseåœ¨è°ƒç”¨è¿”å›ä¹‹å‰å°±ä¼šå‘å‡ºä¿¡å· å¼‚æ­¥ä¿¡å· è¿›ç¨‹å†æ¬¡è·å¾—è°ƒåº¦ï¼Œæ—¶é—´ç‰‡å¼€å§‹æ—¶ å†…æ ¸æ€åˆ°ç”¨æˆ·æ€çš„ä¸‹ä¸€æ¬¡åˆ‡æ¢æ—¶ï¼ˆç³»ç»Ÿè°ƒç”¨çš„å®Œæˆæ—¶ï¼‰ ä¹¦ä¸Šæ­¤å¤„æ ‡æ³¨äº†ä¿¡å·çš„ä¼ é€’å¯èƒ½å¼•èµ·æ­£åœ¨é˜»å¡çš„ç³»ç»Ÿè°ƒç”¨è¿‡æ—©åœ°å®Œæˆã€‚ä¸çŸ¥é“ä¸ºå•¥è¦æåˆ°ä»– è§£é™¤å¤šä¸ªä¿¡å·çš„é˜»å¡æ—¶è§£é™¤æ—¶ï¼Œä¼šç«‹åˆ»ä¼ é€’ç­‰å¾…ä¸­çš„ä¿¡å·ï¼Œå¹¶ä¸”æŒ‰ç…§ä¿¡å·å‡åºä¼ é€’ å½“ä¸€ä¸ªå¤„ç†å™¨å‘ç”Ÿç”¨æˆ·æ€å’Œå†…æ ¸æ€çš„åˆ‡æ¢æ—¶ï¼Œä¼šè½¬å»è°ƒç”¨ç¬¬äºŒä¸ªä¿¡å·çš„å‡½æ•° signalçš„å®ç°æ—©æœŸçš„signalå®ç° è¿›å…¥å¤„ç†å™¨å‡½æ•°ï¼Œä¼šè‡ªåŠ¨æ¢å¤é»˜è®¤è¡Œä¸ºã€‚å¯ä»¥æ‰‹åŠ¨å†æ¬¡è°ƒç”¨signalï¼Œä½†ä¼šå¯¼è‡´å†æ¬¡è®¾ç½®ä¹‹å‰çš„ä¿¡å·ä¾æ—§æ‰§è¡Œé»˜è®¤è¡Œä¸º ä¿¡å·å¤„ç†å™¨æ‰§è¡Œè¿‡ç¨‹ä¸­ä¸é˜»å¡æ–°ä¿¡å·ã€‚è¿‡å¤šä¿¡å·å¯èƒ½å¯¼è‡´å¯¼è‡´æ ˆæº¢å‡º æ—©æœŸçš„å®ç°ä¸æ”¯æŒè‡ªåŠ¨é‡å¯åŠŸèƒ½(SA_RESTART) å½“å‰æä¾›çš„éƒ½æ˜¯å¯é ä¿¡å·ï¼Œä½¿ç”¨OLD_SIGNALæ¡ä»¶æµ‹è¯•å®ç¼–è¯‘å¯å±•ç¤ºæ—©æœŸçš„ä¸å¯é è¯­ä¹‰ æœ€å¥½ä½¿ç”¨sigactionï¼ˆè€ƒè™‘åˆ°å¯ç§»æ¤æ€§é—®é¢˜ï¼‰ å®æ—¶ä¿¡å·å®æ—¶ä¿¡å·åœ¨POSIXçš„ä¿¡å·åŸºç¡€ä¸Šè¿›è¡Œäº†æ‰©å±• ä¿¡å·èŒƒå›´æ›´å¤§ ä½¿ç”¨é˜Ÿåˆ—ç®¡ç†ï¼ˆé•¿åº¦æœ‰ä¸Šé™sysconf(_SC_SIGQUEUE_MAX)ï¼‰ ä¿è¯äº†ä¿¡å·åˆ°è¾¾çš„é¡ºåºï¼Œæ•°é‡ å¯ä»¥åœ¨ä¼ é€’å®æ—¶ä¿¡å·æ—¶åŒæ—¶ä¼ é€’ä¸€ä¸ªæ•´å‹å€¼æˆ–ä¸€ä¸ªæŒ‡é’ˆ ä¸ºä¸€ä¸ªåŒ…å«intå’ŒæŒ‡é’ˆçš„unionï¼Œå¯¹è¯¥unionçš„è§£é‡Šäº¤ç”±ç¨‹åºå¤„ç† å¿…é¡»ä½¿ç”¨SA_SIGINFOä»ä¸­è·å–ä¸Šé¢çš„union é¢˜ç›®22.1éªŒè¯ï¼šå¯¹SIGCONTè®¾ç½®ä¿¡å·å¤„ç†å™¨å¹¶å±è”½ï¼Œæš‚åœè¯¥è¿›ç¨‹ï¼Œå‘é€SIGCONTæ¢å¤è¿›ç¨‹ï¼Œå½“ä¸”ä»…å½“å–å–æ¶ˆå¯¹SIGCONTçš„å±è”½ï¼Œæ‰ä¼šè°ƒç”¨å…¶å¤„ç†å™¨ 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;void handler(int sig) { printf(&quot;handler, received sig:%d, %s\\n&quot;, sig, strsignal(sig));}int main() { sigset_t sigset, osigset; signal(SIGCONT, handler); sigemptyset(&amp;sigset); sigaddset(&amp;sigset, SIGCONT); sigprocmask(SIG_BLOCK, &amp;sigset, &amp;osigset); printf(&quot;block SIGCONT\\npid = %u\\n&quot;, getpid()); for(time_t t = time(NULL); time(NULL) &lt; t + 10;) { } printf(&quot;received SIGCONT\\n&quot;); printf(&quot;unblock SIGCONT\\n&quot;); sigprocmask(SIG_SETMASK, &amp;osigset, NULL); return 0;} 22.2å‡è®¾ä¸€ä¸ªä¿¡å·å’Œä¸€ä¸ªå®æ—¶ä¿¡å·éƒ½è¢«é˜»å¡äº†ï¼Œå½“æ¢å¤é˜»å¡åï¼Œä¼ é€’é¡ºåºæ˜¯æ€æ ·çš„ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;#include &lt;sys/wait.h&gt;void handler(int sig, siginfo_t *siginfo, void *ucontext) { printf(&quot;handler, received sig:%d, %s, &quot;, sig, strsignal(sig)); printf(&quot;sig type = %s\\n&quot;, (siginfo-&gt;si_code == SI_USER) ? &quot;sig&quot; : \\ (siginfo-&gt;si_code == SI_QUEUE) ? &quot;rt-sig&quot; : &quot;other&quot; );}int main() { sigset_t sigset, osigset; sigemptyset(&amp;sigset); for(int i = 1; i &lt; 64; i++) { sigaction(i, &amp;(struct sigaction) { .sa_flags=SA_SIGINFO, .sa_sigaction=handler }, NULL); sigaddset(&amp;sigset, i); } sigprocmask(SIG_BLOCK, &amp;sigset, &amp;osigset); printf(&quot;block\\npid = %u\\n&quot;, getpid()); pid_t pid = fork(); if(!pid) { pid_t ppid = getppid(); int rtsig = SIGRTMIN+1; sigqueue(ppid, rtsig, (union sigval) { .sival_int=1 }); kill(ppid, SIGUSR1); printf(&quot;send rt_sig=%d, sig=%d to parent, ppid = %u\\n&quot;, rtsig, SIGUSR1, ppid); rtsig = SIGRTMIN+2; kill(ppid, SIGUSR2); sigqueue(ppid, rtsig, (union sigval) { .sival_int=1 }); printf(&quot;send rt_sig=%d, sig=%d to parent, ppid = %u\\n&quot;, rtsig, SIGUSR1, ppid); return 0; } for(time_t t = time(NULL); time(NULL) &lt; t + 10;) { } printf(&quot;unblock\\n&quot;); sigprocmask(SIG_SETMASK, &amp;osigset, NULL); wait(NULL); return 0;} ç»“è®ºå…ˆRTï¼Œå†æ™®é€š 12345678910blockpid = 31633send rt_sig=35, sig=10 to parent, ppid = 31633send rt_sig=36, sig=10 to parent, ppid = 31633unblockhandler, received sig:36, Real-time signal 2, sig type = rt-sighandler, received sig:35, Real-time signal 1, sig type = rt-sighandler, received sig:17, Child exited, sig type = otherhandler, received sig:12, User defined signal 2, sig type = sighandler, received sig:10, User defined signal 1, sig type = sig 22.322.10èŠ‚æŒ‡å‡ºï¼Œæ¥æ”¶ä¿¡å·æ—¶ï¼Œåˆ©ç”¨sigwaitinfo()è°ƒç”¨è¦æ¯”ä¿¡å·å¤„ç†å™¨å¤–åŠ sigsuspend()è°ƒç”¨çš„æ–¹æ³•æ¥å¾—å¿«ã€‚éšæœ¬ä¹¦å‘å¸ƒçš„æºç ä¸­æä¾›çš„signals/sig_speed_ sigsuspend.cç¨‹åºä½¿ç”¨sigsuspend()åœ¨çˆ¶ã€å­è¿›ç¨‹ä¹‹é—´äº¤æ›¿å‘é€ä¿¡å·ã€‚è¯·å¯¹ä¸¤è¿›ç¨‹é—´äº¤æ¢ä¸€ç™¾ä¸‡æ¬¡ä¿¡å·æ‰€èŠ±è´¹çš„æ—¶é—´è¿›è¡Œè®¡æ—¶ã€‚(ä¿¡å·äº¤æ¢æ¬¡æ•°å¯é€šè¿‡ç¨‹åºå‘½ä»¤è¡Œå‚æ•°æ¥æä¾›ã€‚ï¼‰ä½¿ç”¨sigwaitinfo()ä½œä¸ºæ›¿ä»£æŠ€æœ¯æ¥å¯¹ç¨‹åºè¿›è¡Œä¿®æ”¹,å¹¶åº¦é‡è¯¥ç‰ˆæœ¬çš„è€—æ—¶ã€‚ä¸¤ä¸ªç¨‹åºé—´çš„é€Ÿåº¦å·®å¼‚åœ¨å“ªé‡Œ? 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdbool.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#ifndef SIGNUM#define SIGNUM 100#endifvoid handler(int sig, siginfo_t *siginfo, void *ucontext) { printf(&quot;\\&quot;%s\\&quot;, handler received sig:%d, from:%u, info:%d\\n&quot;, strsignal(sig), sig, siginfo-&gt;si_pid, siginfo-&gt;si_value.sival_int);}int fork_main(pid_t pid, int sig, sigset_t *oset, sigset_t *sigset) {#ifdef SIGWAITINFO siginfo_t *siginfo = malloc(sizeof(siginfo_t));#endif sigqueue(pid, sig, (union sigval) { .sival_int = 0 }); printf(&quot;pid: %u, send to: %u\\n&quot;, getpid(), pid); for(int i = 1; i &lt; SIGNUM; i++) {#ifdef SIGWAITINFO sigwaitinfo(sigset, siginfo); printf(&quot;\\&quot;%s\\&quot;, sigwaitinfo received sig:%d, from:%u, info:%d\\n&quot;, strsignal(sig), sig, siginfo-&gt;si_pid, siginfo-&gt;si_value.sival_int);#endif#ifdef SIGSUSPEND sigsuspend(oset);#endif sigqueue(pid, sig, (union sigval) { .sival_int = i }); printf(&quot;pid: %u, send to: %u\\n&quot;, getpid(), pid); }#ifdef SIGWAITINFO free(siginfo);#endif}int main() { sigset_t sigset, oset; sigemptyset(&amp;sigset); sigaddset(&amp;sigset, SIGUSR1); sigaddset(&amp;sigset, SIGUSR2); sigprocmask(SIG_BLOCK, &amp;sigset, &amp;oset); sigaction(SIGUSR1, &amp;(struct sigaction) { .sa_flags = SA_SIGINFO, .sa_sigaction = handler }, NULL); sigaction(SIGUSR2, &amp;(struct sigaction) { .sa_flags = SA_SIGINFO, .sa_sigaction = handler }, NULL); pid_t pid = fork(); printf(&quot;pid = %u\\n&quot;, pid); if(!pid) { fork_main(getppid(), SIGUSR2, &amp;oset, &amp;sigset); } else { fork_main(pid, SIGUSR1, &amp;oset, &amp;sigset); wait(NULL); } return 0;} åˆ†æ æµ‹è¯•è„šæœ¬1234gcc -DSIGNUM=1000 -DSIGWAITINFO practice22.3.c -o practice22.3time ./practice22.3 &gt; SIGSUSPENDgcc -DSIGNUM=1000 -DSIGSUSPEND practice22.3.c -o practice22.3time ./practice22.3 &gt; SIGSUSPEND æµ‹è¯•å¾ˆå¤šæ¬¡ï¼Œsigwaitinfoç¡®å®ä¼šå¿«ä¸€ç‚¹ã€‚å¶å°”ç³»ç»Ÿæ—¶é—´å¾ˆå°‘ï¼Œæ€»ä½“ä¸‰ä¸ªæ—¶é—´éƒ½å°äºsigsuspend 12345678910111213141516171819root@tt-surfacepro6:~/linux/cha22# ./practice22.3.sh real 0m0.076suser 0m0.008ssys 0m0.057sreal 0m0.084suser 0m0.000ssys 0m0.069sroot@tt-surfacepro6:~/linux/cha22# ./practice22.3.sh real 0m0.115suser 0m0.000ssys 0m0.076sreal 0m0.126suser 0m0.018ssys 0m0.067s","link":"/home/2023/05/30/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha22/"},{"title":"cha29.çº¿ç¨‹ï¼šä»‹ç»","text":"29.1è‹¥ä¸€çº¿ç¨‹æ‰§è¡Œäº†å¦‚ä¸‹ä»£ç ,å¯èƒ½ä¼šäº§ç”Ÿä»€ä¹ˆç»“æœ?pthread_join(pthread_self()ï¼ŒNULL);åœ¨ Linuxä¸Šç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œè§‚å¯Ÿä¸€ä¸‹å®é™…ä¼šå‘ç”Ÿä»€ä¹ˆæƒ…å†µã€‚å‡è®¾ä»£ç ä¸­æœ‰ä¸€å˜é‡ tid,å…¶ä¸­åŒ…å«äº†æŸä¸ªçº¿ç¨‹IDï¼Œåœ¨è‡ªèº«å‘èµ·pthread_join(tid, NULL)è°ƒç”¨æ—¶ï¼Œè¦é¿å…é€ æˆä¸ä¸Šè¿°è¯­å¥ç›¸åŒçš„åæœï¼Œè¯¥çº¿ç¨‹åº”é‡‡å–ä½•ç§æªæ–½? 123456789101112131415161718192021222324252627#define CHECK(x) do { \\ if(!(x)) { \\ fwritef(STDERR_FILENO, &quot;error: %s\\n&quot;, strerror(errno)); \\ pthread_exit(NULL); \\ } \\ } while(0)void *thread1_fun(void * args) { sleep(1); return NULL;}void *thread_fun(void * args) { void *ret; printf(&quot;thread: before,join-pthread_self()\\n&quot;); CHECK(pthread_join(pthread_self(), &amp;ret) == 0); printf(&quot;thread: after,join-pthread_self()\\n&quot;); return NULL;}int main() { pthread_t thread; CHECK(pthread_create(&amp;thread, NULL, thread_fun, NULL) == 0); CHECK(pthread_detach(thread) == 0); printf(&quot;main: pthread_created.\\n&quot;); sleep(10); return 0;} ç»“æœpthread_joinè¿”å›å€¼é0ï¼Œå‡ºç°é”™è¯¯ï¼Œerrnoè¡¨ç¤ºSUCCESS ä¸ºå•¥æ˜¯successå‘¢ï¼Œerrnoä¸æ˜¯ä¸€ä¸ªçº¿ç¨‹ä¸€ä»½å—ï¼Œè¿˜æ˜¯è¿™ä¸ªå‡½æ•°ä¸ç®—ç³»ç»Ÿè°ƒç”¨ï¼Ÿï¼Ÿå¯èƒ½æ˜¯ä»–è°ƒç”¨äº†waitpidï¼Œä½†æ˜¯å‡ºé”™ä½ç½®ä¸åœ¨waitpid æªæ–½æ£€æŸ¥ä¸€ä¸‹tidä¸pthread_self()å‘—ï¼Œä½¿ç”¨pthread_equal 29.2é™¤äº†ç¼ºå°‘é”™è¯¯æ£€æŸ¥ï¼Œä»¥åŠå¯¹å„ç§å˜é‡å’Œç»“æ„çš„å£°æ˜å¤–ï¼Œä¸‹åˆ—ç¨‹åºè¿˜æœ‰ä»€ä¹ˆé—®é¢˜? 12345678910static void*threadFunc(void *arg){ struct someStruct *pbuf = (struct someStruct *) arg;/* Do some work with structure pointed to by 'pbuf'*/}intmain(int argc,char *argv[]){ struct someStruct buf; pthread_create(&amp;thrï¼ŒNULL,threadFuncï¼Œ(void *) &amp;buf); pthread_exit(NULL);} å›ç­”threadå‡½æ•°é‡Œé¢æœ€åæ²¡æœ‰returnï¼ˆè¿™é‡Œæ„Ÿè°¢Clionçš„æç¤º è¿™é‡Œå±…ç„¶ä¸ä¼šå› ä¸ºmainçš„é€€å‡ºè€Œå¯¼è‡´çº¿ç¨‹çš„é€€å‡ºï¼Œå› ä¸ºåœ¨ä¸»çº¿ç¨‹è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œå…¶ä»–çº¿ç¨‹ä¼šç»§ç»­è¿è¡Œ","link":"/home/2023/06/27/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha29/"},{"title":"cha27.è¿›ç¨‹æ‰§è¡Œ","text":"exec() å¸¦eçš„å¯ä»¥æŒ‡å®šç¯å¢ƒå˜é‡ï¼Œå¦åˆ™ç»§æ‰¿ å¸¦pçš„å…è®¸åªæä¾›æ–‡ä»¶åï¼Œå…è®¸æä¾›ä¸å¸¦&quot;/&quot;çš„è·¯å¾„ï¼Œåœ¨pathä¸­å¯»æ‰¾ è‹¥æ— env PATHé»˜è®¤ä¸º.:/usr/bin/:/bin ä»å·¦å¾€å³æœç´¢ï¼Œç›´åˆ°æ‰¾åˆ°ä¸ºæ­¢ å¸¦lçš„ç”¨ä¸å®šé•¿å‚æ•°ï¼ˆå‚æ•°åˆ—è¡¨ï¼‰ï¼Œä»¥NULLç»“å°¾ execleåœ¨NULLåé¢æ¥envpæ•°ç»„ execæ‰§è¡Œè„šæœ¬å½“execç¬¬ä¸€ä¸ªå‚æ•°æ–‡ä»¶ä»¥&quot;#!&quot;å¼€å§‹ï¼Œåˆ™ä¼šè¯»å–è¯¥è¡Œè¿›è¡Œè§£æ 1#!&lt;interpreter-path&gt; [arg] &lt;script&gt; &lt;script-args...&gt; å¦‚ 1#!/bin/bash --debug è‹¥ 1execl(&quot;xxx.sh&quot;, &quot;argv1&quot;, &quot;argv2&quot;, ..., NULL); åˆ™å®é™…è°ƒç”¨ä¸º 1execl(&quot;/bin/bash&quot;, &quot;--debug&quot;, &quot;xxx.sh&quot;, &quot;argv1&quot;, &quot;argv2&quot;, ..., NULL); 1#!/bin/awk -f ä¿¡å·ä¸execexecæ—¶ï¼Œä¼šå°†è®¾ç½®äº†ä¿¡å·å¤„ç†å™¨å‡½æ•°çš„ä¿¡å·ç½®ä¸ºSIG_DFLï¼Œå°†SA_ONSTACKä½æ¸…é™¤ ä½†æ˜¯å¯¹äºç½®ä¸ºSIG_IGNçš„SIGCHLDæ˜¯å¦ä¼šç½®ä¸ºSIG_DFLï¼Œsusv3å¹¶æœªè§„å®š ä¿¡å·æ©ç ï¼ˆå°±æ˜¯SA_INFOï¼Œ SA_NODEFERé‚£äº›ä¸œè¥¿ï¼‰ä¸æŒ‚èµ·ä¿¡å·çš„è®¾ç½®ä¼šè¢«ä¿å­˜ 27.1123456export PATH=/usr/local/bin:/usr/bin:/bin/:./dir1:./dir2ls -l dir1-rw-r--r-- 1 mtk users 7860 Jun 13 11:55 xyzls -l dir2-rwxr-xr-x 1 mtk users 27860 Jun 13 11:55 xyzxyz # æ‰§è¡Œè¿™é‡Œï¼Œç»“æœå¦‚ä½•ï¼Ÿ æ‰§è¡Œå¤±è´¥ï¼Ÿæœç´¢åˆ°dir1ä¸‹ï¼Œä½†æ˜¯æ²¡æœ‰æ‰§è¡Œæƒé™ï¼Ÿ ç»“æœæ‰§è¡ŒæˆåŠŸï¼Œè®¿é—®åˆ°dir2ä¸‹çš„xyz 27.2ç”¨execveå®ç°execlp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdarg.h&gt;#include &lt;errno.h&gt;#include &lt;stdarg.h&gt;#include &lt;stdlib.h&gt; extern char **environ;#define CHECK(x) do { \\ if(!(x)) { \\ fprintf(stderr, &quot;CHECK: %s\\n&quot;, strerror(errno)); \\ exit(1); \\ } \\ } while(0);int _execlp(const char *file, const char *args, ...) { const int malloc_step = 128; unsigned int args_size = malloc_step; const char **arglist = malloc(sizeof(const char *) * args_size); CHECK(arglist != NULL); const char **arglist_ptr = arglist; const char **arglist_endptr = arglist + args_size; va_list va_args; *(arglist_ptr++) = args; va_start(va_args, args); while((*(arglist_ptr++) = va_arg(va_args, const char *)) != NULL) { if(arglist_ptr == arglist_endptr) { args_size += malloc_step; unsigned offset = arglist_ptr - arglist; arglist = realloc(arglist, args_size); CHECK(arglist != NULL); arglist_ptr = arglist + offset; } } va_end(va_args); char *end; if(strchr(file, '/') != NULL) { execve(file, arglist, environ); free(arglist); CHECK(0); return -1; } char *path = getenv(&quot;PATH&quot;); if(path) { path = strdup(path); } else { path = strdup(&quot;.:/usr/bin:/bin&quot;); } char *path_ptr = path; while((end = strchr(path, ':')) != NULL || (end = strchr(path, '\\0')) != NULL) { if(end == path) { break; } *end = '\\0'; int len = snprintf(NULL, 0, &quot;%s/%s&quot;, path, file); CHECK(len &gt;= 0); char *target = malloc(len+1); snprintf(target, len+1, &quot;%s/%s&quot;, path, file); printf(&quot;try exec: %s\\n&quot;, target); execve(target, arglist, environ); CHECK(errno == ENOENT); // ENOENTè°ƒç”¨å¤±è´¥åªèƒ½æ˜¯ç”±äºæ–‡ä»¶ä¸å­˜åœ¨ path = end+1; free(target); } free(path_ptr); free(arglist); return -1;}int main(int argc, char **argv) { switch(argc) { case 2: _execlp(argv[1], argv[1], NULL); break; case 3: _execlp(argv[1], argv[1], argv[1], argv[2], NULL); break; case 4: _execlp(argv[1], argv[1], argv[1], argv[2], argv[3], NULL); break; case 5: _execlp(argv[1], argv[1], argv[1], argv[2], argv[3], argv[4], NULL); break; case 6: _execlp(argv[1], argv[1], argv[2], argv[3], argv[4], argv[5], NULL); break; default: printf(&quot;not support arg num: %d\\n&quot;, argc); break; } return 0;} 27.327-3.å¦‚æœèµ‹äºˆå¦‚ä¸‹è„šæœ¬å¯æ‰§è¡Œæƒé™å¹¶ä»¥exec()è¿è¡Œï¼Œè¾“å‡ºç»“æœå¦‚ä½•? 12#!/bin/cat -nHello world æ‰“å°æ–‡ä»¶å†…å®¹å¹¶æ˜¾ç¤ºè¡Œå· 27.4ä¸‹åˆ—ä»£ç ä¼šæœ‰ä»€ä¹ˆæ•ˆæœ?åœ¨ä½•ç§æƒ…å†µä¸‹ä¼šèµ·ä½œç”¨? 12345678910111213141516171819childPid = fork();if (childPid == -1) errExit( &quot;fork1&quot;);if (childPid == 0){/* Child*/ switch (fork()){ case -1: errExit(&quot;fork2&quot;); /* Grandchild*/ case 0: /*----- Do real work here ----- */ exit(EXIT_SUCCESS); /* After doing real work*/ default: exit(EXIT_SUCCESS); /*Make grandchild an orphan*/ }}/* Parent falls through to here*/if (waitpid(childPidï¼Œ&amp;status, 0) == -1) errExit(&quot;waitpid&quot;);/* Parent carries on to do other things*/ åˆ›å»ºä¸€ä¸ªå­¤å„¿è¿›ç¨‹ï¼Œæ‰§è¡ŒçœŸæ­£çš„ä»»åŠ¡ ä½œç”¨ï¼šæ¯”å¦‚åˆ›å»ºæœåŠ¡å™¨çš„å®ˆæŠ¤è¿›ç¨‹ 27.527-5.è¿è¡Œå¦‚ä¸‹ç¨‹åºæ—¶æ— è¾“å‡ºã€‚è¯•é—®åŸå› ä½•åœ¨? 12345int main(int argc,char *argv[]){ printf(&quot;Hello world&quot;); execlp(&quot;sleep&quot; , &quot;sleep&quot; ,&quot;o&quot;,(char *) NULL);} è¿˜æ²¡æœ‰fflushï¼Œstdioçš„ç¼“å­˜è¿˜æœªå†™å…¥ç³»ç»Ÿçš„ç¼“å†²ï¼ˆå› ä¸ºprintfæ²¡åŠ '\\n'ï¼‰ï¼Œè¿›ç¨‹å°±è¢«æ›¿æ¢äº†ã€‚ 27.6å‡è®¾çˆ¶è¿›ç¨‹ä¸ºä¿¡å·SIGCHLDåˆ›å»ºäº†ä¸€å¤„ç†å™¨ç¨‹åº,åŒæ—¶é˜»å¡è¯¥ä¿¡å·ã€‚éšåï¼Œå…¶æŸä¸€å­è¿›ç¨‹é€€å‡ºï¼Œçˆ¶è¿›ç¨‹æ¥ç€æ‰§è¡Œ wait)ä»¥è·å–è¯¥å­è¿›ç¨‹çš„çŠ¶æ€ã€‚å½“çˆ¶è¿›ç¨‹è§£é™¤å¯¹SIGCHLDçš„é˜»å¡æ—¶ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆ?ç¼–å†™ä¸€ä¸ªç¨‹åºæ¥éªŒè¯ç­”æ¡ˆã€‚è¿™ä¸€ç»“æœä¸è°ƒç”¨system()å‡½æ•°çš„ç¨‹åºä¹‹é—´æœ‰ä»€ä¹ˆå…³è”? 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;signal.h&gt;#include &lt;stdarg.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;int fwritef(int fd, const char *fmt, ...) { va_list vl; va_start(vl, fmt); int n = vsnprintf(NULL, 0, fmt, vl); va_end(vl); if(n &lt; 0) return -1; char *out = malloc(n+1); if(!out) return -1; va_start(vl, fmt); vsnprintf(out, n+1, fmt, vl); va_end(vl); int ret = 0; if(write(fd, out, n) != n) { ret = -1; } free(out); return ret;}#define CHECK(x) do { \\ if(!(x)) { \\ fwritef(STDERR_FILENO, &quot;error: %s\\n&quot;, strerror(errno)); \\ _exit(1); \\ } \\ } while(0)void sigchld_handler(int sig) { fwritef(STDOUT_FILENO, &quot;sigchld_handler: child exit, sig = %d, %s\\n&quot;, sig, strsignal(sig));}void sigusr1_hander(int sig) { pid_t pid = wait(NULL); fwritef(STDOUT_FILENO, &quot;wait child, %d\\n&quot;, pid); sigset_t sigset; CHECK(sigemptyset(&amp;sigset) == 0); CHECK(sigaddset(&amp;sigset, SIGCHLD) == 0); CHECK(sigprocmask(SIG_UNBLOCK, &amp;sigset, NULL) == 0);}int main() { if(sigaction(SIGCHLD, &amp;(struct sigaction) { .sa_handler=sigchld_handler }, NULL) == -1) return 1; if(sigaction(SIGUSR1, &amp;(struct sigaction) { .sa_handler=sigusr1_hander }, NULL) == -1) return 1; sigset_t sigset; CHECK(sigemptyset(&amp;sigset) == 0); CHECK(sigaddset(&amp;sigset, SIGCHLD) == 0); CHECK(sigprocmask(SIG_BLOCK, &amp;sigset, NULL) == 0); pid_t pid = fork(); if(!pid) { kill(getppid(), SIGUSR1); fwritef(STDOUT_FILENO, &quot;child: exit\\n&quot;); exit(0); } else { sleep(100); } return 0;} æ”¶åˆ°ä¸€ä¸ªéå¸¸æ­£å¸¸çš„ä¿¡å·å’Œsystemçš„å…³è”æ˜¯ï¼Œï¼Œsystemä¹Ÿæ˜¯è¿™ä¹ˆå®ç°çš„ï¼Ÿï¼Ÿ","link":"/home/2023/06/20/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha27/"},{"title":"cha30.çº¿ç¨‹ï¼šçº¿ç¨‹åŒæ­¥","text":"è¯»ä¹¦ç¬”è®°æ¡ä»¶å˜é‡ä¸€èˆ¬æ­é…ä¸€ä¸ªæ¡ä»¶å’Œä¸€ä¸ªäº’æ–¥é‡ä½¿ç”¨ ç»å…¸çš„ä½¿ç”¨æ–¹å¼å¦‚ä¸‹ å¯¹äºéœ€è¦åœ¨æŸæŸæ¡ä»¶ä¸‹è¿è¡Œçš„çº¿ç¨‹ï¼Œå…ˆå¯¹mutexåŠ é”ï¼Œä»¥è¯»å–condition è‹¥æ»¡è¶³ï¼Œåˆ™åœ¨é¢„æœŸçŠ¶æ€ä¸‹æ‰§è¡Œåç»­æ“ä½œï¼Œç»“æŸåå¯¹mutexè§£é” è‹¥ä¸æ»¡è¶³ï¼Œåˆ™pthread_cond_wait æ­¤æ—¶è¯¥å‡½æ•°ä¼šå…ˆè§£é”mutexï¼ˆå…è®¸å…¶ä»–è¿›ç¨‹è·å–mutexä»¥ä¿®æ”¹çŠ¶æ€ï¼‰ é™·å…¥é˜»å¡ï¼Œç›´åˆ°å…¶ä»–çº¿ç¨‹è°ƒç”¨pthread_cond_signalæˆ–pthread_cond_broadcastå”¤é†’ å”¤é†’åï¼Œè·å–mutexé”ï¼Œä»¥æ£€æŸ¥æ¡ä»¶æ˜¯å¦æ»¡è¶³ï¼Œæ»¡è¶³åˆ™æ‰§è¡Œåç»­ï¼Œä¸æ»¡è¶³ç»§ç»­è°ƒç”¨waité˜»å¡ï¼ˆæ•…æ­¤å¤„éœ€è¦ç”¨whileï¼‰ å¯¹äºå¯ä»¥æ”¹å˜æŸæŸæ¡ä»¶çš„çº¿ç¨‹ è·å–mutex æ”¹å˜condition signal/broadcast unlock(unlockä¸ä¸Šä¸€æ­¥é¡ºåºå¯è°ƒæ¢) 123456789101112// one threadpthread_mutex_lock(&amp;mutex);while(!condition) pthread_cond_wait(&amp;cond, &amp;mutex);/* condition matched, execute task */pthread_mutex_unlock(&amp;mutex);// other threadpthread_mutex_lock(&amp;mutex);condition = xxxx; // change conditionpthread_cond_signal(&amp;cond); // or pthread_cond_broadcast(&amp;cond);pthread_mutex_unlock(&amp;mutex); // ä»¥ä¸Šä¸¤è¡Œé¡ºåºä»»æ„ï¼Œ broadcastä¸signalçš„é€‰æ‹© å¦‚æœæ‰€æœ‰çº¿ç¨‹éƒ½éœ€è¦åœ¨åŒä¸€æ¡ä»¶ä¸‹äº’æ–¥çš„æ‰§è¡Œï¼Œé‚£ä¹ˆé€‰æ‹©signalï¼Œbroadcastä¼šå”¤é†’æ‰€æœ‰çº¿ç¨‹ä¸”å¤§å®¶æ¡ä»¶éƒ½ç›¸åŒï¼Œæ‰€æœ‰åªä¼šæœ‰ä¸€ä¸ªçº¿ç¨‹è·å¾—mutex å¦‚æœæ¡ä»¶ä¸åŒï¼Œå¦‚ä¸€ä¸ªçº¿ç¨‹ä¸ºcondition == STAT1ï¼Œå¦ä¸€ä¸ªä¸ºcondition == STAT2ï¼Œé‚£ä¹ˆé€‚åˆbroadcast æ¡ä»¶å˜é‡çš„ä½œç”¨æ˜¯é€šçŸ¥æŸæŸæ¡ä»¶çš„æ”¹å˜ 30.130-1.ä¿®æ”¹ç¨‹åºæ¸…å•30-1 ( thread_incr.cï¼‰ä¸­çš„ç¨‹åºï¼Œä»¥ä¾¿çº¿ç¨‹èµ·å§‹å‡½æ•°åœ¨æ¯æ¬¡å¾ªç¯ä¸­éƒ½èƒ½è¾“å‡º glob çš„å½“å‰å€¼ä»¥åŠèƒ½å¯¹çº¿ç¨‹åšå”¯ä¸€æ ‡è¯†çš„æ ‡è¯†ç¬¦ã€‚å¯å°†çº¿ç¨‹çš„è¿™ä¸€å”¯ä¸€æ ‡è¯†æŒ‡å®šä¸ºåˆ›å»ºçº¿ç¨‹çš„å‡½æ•°pthread_create()çš„è°ƒç”¨å‚æ•°ã€‚å¯¹äºè¿™ä¸€ç¨‹åºï¼Œéœ€è¦å°†çº¿ç¨‹èµ·å§‹å‡½æ•°çš„å‚æ•°æ”¹ä¸ºæŒ‡é’ˆï¼ŒæŒ‡å‘åŒ…å«çº¿ç¨‹å”¯ä¸€æ ‡è¯†å’Œå¾ªç¯æ¬¡æ•°é™åˆ¶çš„æ•°æ®ç»“æ„ã€‚è¿è¡Œè¯¥ç¨‹åºï¼Œå°†è¾“å‡ºé‡å®šå‘è‡³ä¸€æ–‡ä»¶ï¼ŒæŸ¥çœ‹å†…æ ¸åœ¨è°ƒåº¦ä¸¤çº¿ç¨‹äº¤æ›¿æ‰§è¡Œæ—¶glob çš„å˜åŒ–æƒ…å†µã€‚ okï¼Œæ— èŠæ 30.2å®ç°ä¸€ç»„çº¿ç¨‹å®‰å…¨çš„å‡½æ•°ï¼Œä»¥æ›´æ–°å’Œæœç´¢ä¸€ä¸ªä¸å¹³è¡¡äºŒå‰æ ‘ã€‚æ­¤å‡½æ•°åº“åº”è¯¥åŒ…å«å¦‚ä¸‹å½¢å¼çš„å‡½æ•°ï¼ˆç›®çš„æ˜æ˜¾): 1234initialize(tree);add(tree,char *key,void *value);delete(tree,char *key)Boolean lookup(char *key,void**value) ä¸Šè¿°å‡½æ•°åŸå‹ä¸­ï¼Œtreeæ˜¯ä¸€ä¸ªæŒ‡å‘æ ¹èŠ‚ç‚¹çš„ç»“æ„ï¼ˆä¸ºæ­¤éœ€è¦è¶³ä¹‰ä¸€ä¸ªåˆPçš„ç»æ„)ã€‚ä¾‹çš„æ¯ä¸ªèŠ‚ç‚¹ä¿å­˜æœ‰ä¸€ä¸ªé”®-å€¼å¯¹ã€‚è¿˜éœ€ä¸ºæ ‘ä¸­æ¯ä¸ªèŠ‚ç‚¹å®šä¹‰ä¸€æ•°æ®ç»“æ„ï¼Œå…¶ä¸­åº”åŒ…å«äº’æ–¥é‡ï¼Œä»¥ç¡®ä¿åŒæ—¶ä»…æœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥è®¿é—®è¯¥èŠ‚ç‚¹ã€‚initialize()ã€add()å’Œ lookup()å‡½æ•°çš„å®ç°ç›¸å¯¹ç®€å•ã€‚delete()çš„å®ç°éœ€è¦è¾ƒä¸ºæ·±å…¥çš„è€ƒè™‘ã€‚ å®ç°123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324//// Created by root on 6/28/23.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#include &lt;pthread.h&gt;#include &lt;stdarg.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#define CHECK(x, exitline, ...) do { if(!(x)) { \\ fprintf(stderr, &quot;CHECK: &quot;); \\ fprintf(stderr, __VA_ARGS__); \\ fprintf(stderr, &quot;\\n&quot;); \\ exitline; \\ } \\ } while(0)#define CHECKERR(x, exitline) CHECK(x, exitline, &quot;Error: %s\\n&quot;, strerror(errno))typedef int K;typedef int V;typedef struct ConcurrentTreeStruct{ pthread_mutex_t mutex; K *key; V *value; struct ConcurrentTreeStruct *left; struct ConcurrentTreeStruct *right;} *ConcurrentTreeNode;typedef struct ConcurrentTree{ ConcurrentTreeNode dummy; int (*compare)(K *key1, K *key2); void (*destroyKey)(K *key); void (*destroyValue)(V *value);} *ConcurrentTree;ConcurrentTreeNode initCTreeNode(K *key, V *value, ConcurrentTreeNode left, ConcurrentTreeNode right) { ConcurrentTreeNode tree = (ConcurrentTreeNode)malloc(sizeof(struct ConcurrentTreeStruct)); CHECKERR(tree, return NULL); tree-&gt;left = left; tree-&gt;right = right; tree-&gt;key = key; tree-&gt;value = value; CHECKERR(pthread_mutex_init(&amp;tree-&gt;mutex, NULL) == 0, do {free(tree); return NULL; } while(0)); return tree;}ConcurrentTree initCTree( int (*compare)(K *key1, K *key2), void (*destroyKey)(K *key), void (*destroyValue)(V *value)) { ConcurrentTree tree = (ConcurrentTree)malloc(sizeof(struct ConcurrentTree)); CHECKERR(tree, return NULL); tree-&gt;dummy = initCTreeNode(NULL, NULL, NULL, NULL); CHECK(tree-&gt;dummy, do { free(tree); return NULL; } while(0), &quot;&quot;); tree-&gt;compare = compare; tree-&gt;destroyKey = destroyKey; tree-&gt;destroyValue = destroyValue; return tree;}int add(ConcurrentTree tree, K *key, V *value) { CHECK(tree, return -1, &quot;&quot;); CHECKERR(pthread_mutex_lock(&amp;tree-&gt;dummy-&gt;mutex) == 0, return -1); pthread_mutex_t *old = &amp;tree-&gt;dummy-&gt;mutex; ConcurrentTreeNode *treeNode = &amp;tree-&gt;dummy-&gt;left; while(*treeNode){ pthread_mutex_t *lock = &amp;(*treeNode)-&gt;mutex; CHECKERR(pthread_mutex_lock(&amp;(*treeNode)-&gt;mutex) == 0, exit(5)); int cmp = tree-&gt;compare(key, (*treeNode)-&gt;key); if (cmp &lt; 0) { // keyå°äºæ ¹ treeNode = &amp;(*treeNode)-&gt;left; } else { treeNode = &amp;(*treeNode)-&gt;right; } CHECKERR(pthread_mutex_unlock(old) == 0, exit(5)); old = lock; } *treeNode = initCTreeNode(key, value, NULL, NULL); CHECKERR(pthread_mutex_unlock(old) == 0, exit(5)); return 0;}void delCTreeNode(ConcurrentTreeNode tree, void (*destroyKey)(K *key), void (*destroyValue)(V *value)) { if(!tree) return; destroyKey(tree-&gt;key); destroyValue(tree-&gt;value); pthread_mutex_destroy(&amp;tree-&gt;mutex); tree-&gt;key = NULL; tree-&gt;value = NULL;}int del(ConcurrentTree tree, K *key) { CHECK(tree, return -1, &quot;&quot;); if(!tree-&gt;dummy-&gt;left) return -1; CHECKERR(pthread_mutex_lock(&amp;tree-&gt;dummy-&gt;mutex) == 0, return -1); CHECKERR(pthread_mutex_lock(&amp;tree-&gt;dummy-&gt;left-&gt;mutex) == 0, do { pthread_mutex_unlock(&amp;tree-&gt;dummy-&gt;mutex); return -1;} while(0)); pthread_mutex_t *parent_lock = &amp;tree-&gt;dummy-&gt;mutex; pthread_mutex_t *child_lock =&amp;tree-&gt;dummy-&gt;left-&gt;mutex; ConcurrentTreeNode *parentNode = &amp;tree-&gt;dummy-&gt;left; ConcurrentTreeNode treeNode = tree-&gt;dummy-&gt;left; while(treeNode) {// printf(&quot;cmp %d, %d\\n&quot;, *key, *treeNode-&gt;key); int cmp = tree-&gt;compare(key, treeNode-&gt;key); if(cmp == 0) { if(treeNode-&gt;left) CHECKERR(pthread_mutex_lock(&amp;treeNode-&gt;left-&gt;mutex) == 0, exit(5)); if(treeNode-&gt;right) CHECKERR(pthread_mutex_lock(&amp;treeNode-&gt;right-&gt;mutex) == 0, exit(5)); ConcurrentTreeNode left = treeNode-&gt;left; ConcurrentTreeNode right = treeNode-&gt;right; if(!left &amp;&amp; !right) { *parentNode = NULL; } else if(!left) { *parentNode = right; } else if(!right) { *parentNode = left; } else { *parentNode = left; } CHECKERR(pthread_mutex_unlock(parent_lock) == 0, exit(5)); if(left &amp;&amp; right) { while (left-&gt;right) { ConcurrentTreeNode old = left; left = left-&gt;right; if(left) CHECKERR(pthread_mutex_lock(&amp;left-&gt;mutex) == 0, exit(5)); CHECKERR(pthread_mutex_unlock(&amp;old-&gt;mutex) == 0, exit(5)); } left-&gt;right = right; } if(left)CHECKERR(pthread_mutex_unlock(&amp;left-&gt;mutex) == 0, exit(5)); if(right)CHECKERR(pthread_mutex_unlock(&amp;right-&gt;mutex) == 0, exit(5)); CHECKERR(pthread_mutex_unlock(child_lock) == 0, exit(5)); delCTreeNode(treeNode, tree-&gt;destroyKey, tree-&gt;destroyValue); free(treeNode); return 0; } else if(cmp &lt; 0) { CHECKERR(pthread_mutex_unlock(parent_lock) == 0, exit(5)); if(treeNode-&gt;left) CHECKERR(pthread_mutex_lock(&amp;treeNode-&gt;left-&gt;mutex) == 0, exit(5)); parent_lock = &amp;treeNode-&gt;mutex; parentNode = &amp;treeNode-&gt;left; treeNode = treeNode-&gt;left; child_lock = treeNode ? &amp;treeNode-&gt;mutex : NULL; } else { CHECKERR(pthread_mutex_unlock(parent_lock) == 0, exit(5)); if(treeNode-&gt;right) CHECKERR(pthread_mutex_lock(&amp;treeNode-&gt;right-&gt;mutex) == 0, exit(5)); parent_lock = &amp;treeNode-&gt;mutex; parentNode = &amp;treeNode-&gt;right; treeNode = treeNode-&gt;right; child_lock = treeNode ? &amp;treeNode-&gt;mutex : NULL; } } CHECKERR(pthread_mutex_unlock(parent_lock) == 0, exit(5)); if(child_lock) CHECKERR(pthread_mutex_unlock(child_lock) == 0, exit(5)); return -1;}int lookup(ConcurrentTree tree, K *key, V **value) { CHECK(tree, return -1, &quot;tree cannot be null&quot;); CHECK(key, return -1, &quot;key cannot be null&quot;); CHECK(value, return -1, &quot;value cannot be null&quot;); CHECKERR(pthread_mutex_lock(&amp;tree-&gt;dummy-&gt;mutex) == 0, return -1); if(tree-&gt;dummy-&gt;left)CHECKERR(pthread_mutex_lock(&amp;tree-&gt;dummy-&gt;left-&gt;mutex) == 0, do { pthread_mutex_unlock(&amp;tree-&gt;dummy-&gt;mutex); return -1;} while(0)); ConcurrentTreeNode treeNode = tree-&gt;dummy-&gt;left; CHECKERR(pthread_mutex_unlock(&amp;tree-&gt;dummy-&gt;mutex) == 0, exit(5)); while(treeNode) { int cmp = tree-&gt;compare(key, treeNode-&gt;key); if(cmp == 0) { *value = treeNode-&gt;value; CHECKERR(pthread_mutex_unlock(&amp;treeNode-&gt;mutex) == 0, exit(5)); return 0; } else if(cmp &lt; 0) { ConcurrentTreeNode old = treeNode; treeNode = treeNode-&gt;left; if(treeNode) CHECKERR(pthread_mutex_lock(&amp;treeNode-&gt;mutex) == 0, do { pthread_mutex_unlock(&amp;old-&gt;mutex); return -1;} while(0)); //å…ˆè·å–æ–°é”ï¼Œå†æ”¾å¼ƒæ—§é” CHECKERR(pthread_mutex_unlock(&amp;old-&gt;mutex) == 0, exit(5)); } else { ConcurrentTreeNode old = treeNode; treeNode = treeNode-&gt;right; if(treeNode) CHECKERR(pthread_mutex_lock(&amp;treeNode-&gt;mutex) == 0, do { pthread_mutex_unlock(&amp;old-&gt;mutex); return -1;} while(0)); CHECKERR(pthread_mutex_unlock(&amp;old-&gt;mutex) == 0, exit(5)); } } return -1;}void destroyCTreeNode(ConcurrentTreeNode tree, void (*destroyKey)(K *key), void (*destroyValue)(V *value)) { if(!tree) return; destroyCTreeNode(tree-&gt;left, destroyKey, destroyValue); destroyCTreeNode(tree-&gt;right, destroyKey, destroyValue); delCTreeNode(tree, destroyKey, destroyValue); free(tree);}void destroyCTree(ConcurrentTree tree) { CHECK(tree, return, &quot;tree cannot be null\\n&quot;); destroyCTreeNode(tree-&gt;dummy-&gt;left, tree-&gt;destroyKey, tree-&gt;destroyValue); free(tree-&gt;dummy); tree-&gt;dummy = NULL;}struct ThreadRet { int read; int add; int del;};struct ThreadArg { ConcurrentTree tree; int threadID;};int cmpInt(int *a, int *b) { if(*a == *b) { return 0; } else if(*a &gt; *b) { return 1; } else { return -1; }}void destroyInt(int *a) { if(a) { free(a); }}int maxKey = 0;pthread_mutex_t mutex_mk;void *threadfn(void *args) { ConcurrentTree tree = ((struct ThreadArg *)args)-&gt;tree; int tid = ((struct ThreadArg *)args)-&gt;threadID; CHECKERR(tree, return NULL); struct ThreadRet *ret = malloc(sizeof(struct ThreadRet)); CHECKERR(ret, return NULL); ret-&gt;read = ret-&gt;add = ret-&gt;del = 0; int opNum = 1000 + rand() % 1001; int *key = (int *)malloc(sizeof(int)); while (opNum--) { int *val; CHECKERR(key, return ret); switch (rand()%3) { case 0: printf(&quot;Thread-%d, try add\\n&quot;, tid); val = (int *)malloc(sizeof(int)); CHECKERR(val, return ret); *val = rand()%200000; CHECKERR(pthread_mutex_lock(&amp;mutex_mk) == 0,return ret); maxKey++; *key = maxKey; CHECKERR(pthread_mutex_unlock(&amp;mutex_mk) == 0,return ret); add(tree, key, val); ret-&gt;add++; printf(&quot;Thread-%d, add (%d, %d)\\n&quot;, tid, *key, *val); key = (int *)malloc(sizeof(int)); break; case 1: printf(&quot;Thread-%d, try read\\n&quot;, tid); CHECKERR(pthread_mutex_lock(&amp;mutex_mk) == 0,return ret); if(maxKey &gt; 0)*key = rand()%maxKey + 1; else *key = -1; CHECKERR(pthread_mutex_unlock(&amp;mutex_mk) == 0,return ret);// printf(&quot;Thread-%d, try read %d\\n&quot;, tid, *key); if(lookup(tree, key, &amp;val) == 0) printf(&quot;Thread-%d, read (%d, %d)\\n&quot;, tid, *key, *val); else printf(&quot;Thread-%d, fail to read (%d)\\n&quot;, tid, *key); ret-&gt;read++; break; case 2: printf(&quot;Thread-%d, try del\\n&quot;, tid); CHECKERR(pthread_mutex_lock(&amp;mutex_mk) == 0,return ret); if(maxKey &gt; 0) { *key = maxKey; } else *key = -1; CHECKERR(pthread_mutex_unlock(&amp;mutex_mk) == 0,return ret);// printf(&quot;Thread-%d, try del %d\\n&quot;, tid, *key); if(del(tree, key) == 0) { printf(&quot;Thread-%d, del (%d)\\n&quot;, tid, *key); CHECKERR(pthread_mutex_lock(&amp;mutex_mk) == 0,return ret); maxKey--; CHECKERR(pthread_mutex_unlock(&amp;mutex_mk) == 0, return ret); } else printf(&quot;Thread-%d, fail to del (%d)\\n&quot;, tid, *key); ret-&gt;del++; break; } } free(key); free(args); return ret;}int main(int argc, char *argv[]) { CHECK(argc &gt; 1, return 1, &quot;Usage: %s threadCnt&quot;, argv[0]); int threadCnt = atoi(argv[1]); pthread_t *thread = malloc(threadCnt * sizeof(pthread_t)); CHECKERR(thread, return 2); CHECKERR(pthread_mutex_init(&amp;mutex_mk, NULL) == 0,return 3); ConcurrentTree tree = initCTree(cmpInt, destroyInt, destroyInt); for(int i = 0; i &lt; threadCnt; i++) { struct ThreadArg *args = malloc(sizeof(struct ThreadArg)); args-&gt;threadID = i+1; args-&gt;tree = tree; CHECKERR(pthread_create(&amp;thread[i], NULL, threadfn, args) == 0,return 1); } for(int i = 0; i &lt; threadCnt; i++) { struct ThreadRet *ret; CHECKERR(pthread_join(thread[i], (void **)&amp;ret) == 0,return 1); if(!ret) { printf(&quot;Summary: Thread-%d occured error, returned NULL\\n&quot;, i+1); } else { printf(&quot;Summary: Thread-%d add=%d, read=%d, del=%d\\n&quot;, i+1, ret-&gt;add, ret-&gt;read, ret-&gt;del); free(ret); } } CHECKERR(pthread_mutex_destroy(&amp;mutex_mk) == 0,return 3); destroyCTree(tree); free(tree); free(thread); return 0;} ç”¨å››ä¸ªçº¿ç¨‹è·‘äº†å‡ æ¬¡ï¼Œåæ­£éƒ½æ²¡æœ‰æ­»é”è¿‡ã€‚è¿˜æ²¡æœ‰ä»”ç»†çœ‹è¿‡æ­£ç¡®æ€§ valgrindvalgrindè·‘äº†å¾ˆå¤šæ¬¡ï¼Œæ­£å¸¸æƒ…å†µä¸‹å…¨éƒ¨å†…å­˜éƒ½è¢«freeäº†ï¼Œæ²¡æœ‰æ³„æ¼ asanasanè·‘äº†å‡ æ¬¡ï¼Œæ¯æ¬¡éƒ½æœ‰é”™è¯¯ã€‚ç”¨gdbä¹Ÿçœ‹ä¸åˆ°è°ƒç”¨æ ˆï¼Œåæ¥clionå¾ˆç»™åŠ›ï¼Œæ‰“å°å‡ºäº†è°ƒç”¨æ ˆ ä¸æ˜¯å®ç°æœ‰é—®é¢˜ï¼Œæ˜¯åœ¨è¾“å‡ºlogçš„æ—¶å€™å‡ºé”™äº†ï¼ŒåŸç†å¦‚ä¸‹ Açº¿ç¨‹ç»™æ ‘é‡ŒåŠ å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œç„¶åAæ‰“å°ä»–çš„å€¼ã€‚ä½†åœ¨è¿™ä¹‹å‰BåˆæŠŠä»–åˆ é™¤ï¼Œä»–çš„keyï¼Œvalueéƒ½è¢«freeäº†ï¼Œè¿™ä¸ªæ—¶å€™å°±ä¸å¯¹äº†ã€‚","link":"/home/2023/06/29/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha30/"},{"title":"cha31.çº¿ç¨‹å®‰å…¨å’Œæ¯çº¿ç¨‹å­˜å‚¨","text":"è¯»ä¹¦ç¬”è®° pthreadæä¾›äº†ä¸€ç§æ‰€æœ‰çº¿ç¨‹åªæ‰§è¡Œä¸€æ¬¡ï¼ˆç”¨äºæ‰€æœ‰çº¿ç¨‹åªåˆå§‹åŒ–ä¸€æ¬¡ï¼‰çš„æ–¹æ³•pthread_once(pthread_once_t*, void (*)(void)); pthreadæä¾›äº†æ¯çº¿ç¨‹å­˜å‚¨ï¼Œå³æ¯ä¸ªçº¿ç¨‹æœ‰ç‹¬ç«‹ä¸å…¶ä»–çº¿ç¨‹çš„å­˜å‚¨ï¼Œä½¿ç”¨k-vå­˜å‚¨ int pthread_key_create(pthread_key_t *, void (*)(void *));æ¯ä¸ªçº¿ç¨‹éƒ½å­˜å‚¨ä¸€ä»½ï¼Œç¬¬ä¸€ä¸ªå‚æ•°ä¸ºä¸€ä¸ªå…¨å±€å˜é‡çš„æŒ‡é’ˆï¼Œç¬¬äºŒä¸ªå‚æ•°ä¸ºçº¿ç¨‹ç»ˆæ­¢æ—¶è‡ªåŠ¨è°ƒç”¨çš„ææ„å‡½æ•° int pthread_setspecific(pthread_key_t, const void *)æŒ‡å®škeyæ‰€å¯¹åº”çš„å†…å­˜åŒºåŸŸï¼Œè¿›ç¨‹ç»ˆæ­¢æ—¶ä¼šå°†ç¬¬äºŒä¸ªå‚æ•°é€å…¥ææ„å‡½æ•° void * pthread_getspecific(pthread_key_t)è·å–keyæ‰€å¯¹åº”çš„å†…å­˜åŒºåŸŸ 31.1å®ç°pthread_once 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//// Created by root on 6/29/23.//#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void init() { printf(&quot;init\\n&quot;);}typedef struct { pthread_mutex_t mutex; bool call;} _pthread_once_t;_pthread_once_t once = { .mutex=PTHREAD_MUTEX_DEFAULT, .call=false};int _pthread_once(_pthread_once_t *once_ctrl, void (*init)(void)) { bool ok; if(pthread_mutex_lock(&amp;once_ctrl-&gt;mutex) == 0) { ok = !once_ctrl-&gt;call; once_ctrl-&gt;call = true; pthread_mutex_unlock(&amp;once_ctrl-&gt;mutex); } else { return -1; } if(ok) { init(); } return 0;}void *fun(void *arg) { printf(&quot;Thread-%d start\\n&quot;, *(int*)arg); if(_pthread_once(&amp;once, init) == 0){ printf(&quot;Thread-%d _pthread_once Success\\n&quot;, *(int*)arg); } free(arg); return NULL;}int main() { pthread_t t; for(int i = 1; i &lt;= 100; i++) pthread_create(&amp;t, NULL, fun, memcpy(malloc(sizeof(int)), &amp;i, sizeof(int))); pthread_exit(NULL);} 31.2å®ç°çº¿ç¨‹å®‰å…¨ç‰ˆæœ¬çš„dirname,basename 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//// Created by root on 6/29/23.//#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;limits.h&gt;#include &lt;libgen.h&gt;static __thread char dirname_buf[PATH_MAX];static pthread_key_t basename_key;static pthread_once_t basename_once = PTHREAD_ONCE_INIT;char *dirname_r(const char *path) { const char *lastSlash = strrchr(path, '/'); if(!lastSlash) { strncpy(dirname_buf, &quot;.&quot;, 1); } else { strncpy(dirname_buf, path, lastSlash - path); } dirname_buf[PATH_MAX-1] = 0; return dirname_buf;}void destroy_basename(void * buf) { free(buf);}void init_basename() { pthread_key_create(&amp;basename_key, destroy_basename);}char *basename_r(const char *path) { pthread_once(&amp;basename_once, init_basename); char *_basename_buf = (char *)pthread_getspecific(basename_key); if(_basename_buf == NULL) { _basename_buf = malloc(sizeof(char) * PATH_MAX); pthread_setspecific(basename_key, _basename_buf); } const char *lastSlash = strrchr(path, '/'); if(!lastSlash) { lastSlash = path; } else { lastSlash++; } strncpy(_basename_buf, lastSlash, PATH_MAX-1); _basename_buf[PATH_MAX-1] = 0; return _basename_buf;}void *threadfn(void *arg) { if(!arg) return NULL; char *dir = (char *)arg; printf(&quot;dir = %s\\nSAFE :basename = %s, dirname = %s\\n&quot;, dir, basename_r(dir), dirname_r(dir)); printf(&quot;UNSAFE:basename = %s, dirname = %s\\n&quot;, basename(dir), dirname(dir)); return NULL;}int main(int argc, char *argv[]) { for(int i = 1; i &lt; argc; i++) { pthread_t t; pthread_create(&amp;t, NULL, threadfn, argv[i]); } pthread_exit(NULL);}","link":"/home/2023/06/29/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha31/"},{"title":"cha32.çº¿ç¨‹å–æ¶ˆ","text":"è¯»ä¹¦ç¬”è®°å¸¦å‚å®ä»ä½œç”¨åŸŸçš„è§’åº¦ä¸Šçœ‹ï¼Œå¸¦å‚å®å’Œå‡½æ•°çš„åŒºåˆ«ï¼š å‡½æ•°æœ‰æ–°çš„å‡½æ•°æ ˆï¼Œè€Œå¸¦å‚å®æ²¡æœ‰ï¼Œå› è€Œå¸¦å‚å®åœ¨ä¸åŒä½œç”¨åŸŸè°ƒç”¨æ—¶ï¼Œä¼šå—åˆ°ä½œç”¨åŸŸçš„å½±å“ã€‚å¦‚åœ¨å®Aä¸­çš„å®šä¹‰çš„å˜é‡ï¼Œä¹Ÿä¼šå½±å“åç»­ã€‚ å¦‚æœä¸€å¯¹ä½œç”¨ç›¸åçš„å¸¦å‚å®ï¼Œå¦‚æœ¬èŠ‚çš„pthread_cleanup_pushå’Œpthread_cleanup_popï¼Œå¾ˆå¤šå®ç°éƒ½æ˜¯ä½¿ç”¨å¸¦å‚å®ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªå®è°ƒç”¨æ—¶å¿…é¡»å±äºåŒä¸€ä¸ªä»£ç å— ?ï¼Œä¿è¯pushçš„ä½œç”¨åŸŸåŒ…å«popä¸å°±å¥½äº†å— çº¿ç¨‹å–æ¶ˆçº¿ç¨‹å–æ¶ˆçŠ¶æ€å¯è®¾ç½®ä¸ºå¯ç”¨å’Œç¦ç”¨ã€‚ è‹¥å¯ç”¨ï¼Œåˆ™å¯ä»¥å–æ¶ˆï¼Œä½†ä½•æ—¶å“åº”æœªçŸ¥ï¼Œä¾èµ–äºå–æ¶ˆç±»å‹ è‹¥ç¦ç”¨ï¼Œå°†å–æ¶ˆè¯·æ±‚æŒ‚èµ·ï¼Œç›´åˆ°å…è®¸å–æ¶ˆ çº¿ç¨‹å–æ¶ˆç±»å‹ å»¶è¿Ÿå–æ¶ˆï¼Œç›´åˆ°å–æ¶ˆç‚¹ï¼ˆæŸäº›ç‰¹å®šçš„ç³»ç»Ÿè°ƒç”¨æˆ–åº“å‡½æ•°ï¼Œå¦‚cond_waitç­‰ å¼‚æ­¥å–æ¶ˆï¼Œéšæ—¶éƒ½å¯ä»¥å–æ¶ˆ åŒ…æ‹¬mallocï¼Œfreeæ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œè‹¥åœ¨è¿™äº›å‡½æ•°ä¸­å–æ¶ˆï¼Œåˆ™å¾ˆæœ‰å¯èƒ½ä¼šå¯¼è‡´åç»­å†…å­˜åˆ†é…çš„è¿‡ç¨‹å‡ºç°é”™è¯¯ã€‚ å¼‚æ­¥å–æ¶ˆçº¿ç¨‹ä¸åº”è¯¥åˆ†é…èµ„æºï¼Œï¼ˆé‚£ä¹ˆæ˜¯å¦å¯ä»¥åœ¨åˆ†é…ï¼Œé‡Šæ”¾å†…å­˜æ—¶æš‚æ—¶ç¦æ­¢å–æ¶ˆï¼Œæˆ–åœ¨è®¡ç®—å¯†é›†ä»»åŠ¡å¼€å§‹æ—¶è®¾ç½®ä¸ºå¼‚æ­¥ï¼Œç»“æŸåæ¢å¤ï¼Ÿï¼‰ é€‚ç”¨äºè®¡ç®—å¯†é›†å‹ï¼Œé•¿æ—¶é—´æ²¡æœ‰å–æ¶ˆç‚¹çš„æƒ…å†µã€‚ å¯ä»¥æ‰‹åŠ¨äº§ç”Ÿå–æ¶ˆç‚¹pthread_testcancel()ï¼Œè‹¥è°ƒç”¨å‰å·²ç»æœ‰äº†å–æ¶ˆè¯·æ±‚ï¼Œåˆ™çº¿ç¨‹ä¼šç»ˆæ­¢","link":"/home/2023/06/29/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha32/"},{"title":"cha36.è¿›ç¨‹èµ„æº","text":"36.1ç¼–å†™ä¸€ä¸ªç¨‹åºä½¿ç”¨getrusage0 RUSAGE CHILDRENæ ‡è®°è·å–waitè°ƒç”¨æ‰€ç­‰å¾…çš„å­è¿›ç¨‹ç›¸å…³çš„ä¿¡æ¯ã€‚(è®©ç¨‹åºåˆ›å»ºä¸€ä¸ªå­è¿›ç¨‹å¹¶ä½¿å­è¿›ç¨‹æ¶ˆè€—ä¸€äº› CPU æ—¶é—´ï¼Œæ¥ç€è®©çˆ¶è¿›ç¨‹åœ¨è°ƒç”¨wait0å‰åéƒ½è°ƒç”¨getrusage0ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//// Created by root on 7/18/23.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/times.h&gt;#include &lt;unistd.h&gt;#include &lt;limits.h&gt;#include &lt;sys/resource.h&gt;#define CHECK(x) \\ do { \\ if(!(x)) { \\ fprintf(stderr, &quot;%s:%d\\nerror: %s\\n&quot;, __FILE__, __LINE__,strerror(errno)); \\ exit(0); \\ } \\ } while(0)#define rcputime(rusage, xtime) rusage.xtime.tv_sec + rusage.xtime.tv_usec/1000000.0int main(int argc, char **argv) { long tic = sysconf(_SC_CLK_TCK); long tottm = 0; for(int i = 1; i &lt; argc; i++) { char *end = NULL; long sec = strtol(argv[i], &amp;end, 10); tottm += sec; CHECK(end != argv[i] &amp;&amp; errno == 0); if(!fork()) { struct tms tms, start; CHECK(times(&amp;start) != (clock_t) -1); CHECK(times(&amp;tms) != (clock_t) -1); for(; (tms.tms_utime + tms.tms_stime)/tic - (start.tms_utime + start.tms_stime)/tic &lt;= sec;) { CHECK(times(&amp;tms) != (clock_t) -1); } exit(0); } } printf(&quot;total time:%ld\\n&quot;, tottm); struct rusage rusage; CHECK(getrusage(RUSAGE_CHILDREN, &amp;rusage) != -1); printf(&quot;child use:\\n\\tcpu time:%.2lfs (user)\\n\\tcpu time:%.2lfs (system)\\ntotal:%.2lfs\\n&quot;, rcputime(rusage, ru_utime), rcputime(rusage, ru_stime), rcputime(rusage, ru_utime) + rcputime(rusage, ru_stime)); for(;;) if(waitpid(-1, NULL, 0) == -1 &amp;&amp; errno == 10) break; CHECK(getrusage(RUSAGE_CHILDREN, &amp;rusage) != -1); printf(&quot;&quot; &quot;child use:\\n&quot; &quot;\\tcpu time:\\n&quot; &quot;\\t\\tcpu time:%.2lfs (user)\\n&quot; &quot;\\t\\tcpu time:%.2lfs (system)\\n&quot; &quot;\\ttotal:%.2lfs\\n&quot; &quot;\\tMax resident set:%ldKB\\n&quot; &quot;\\tIntegral shared text mem:%ldkB/s\\n&quot; &quot;\\tIntegral shared data mem:%ldkB/s\\n&quot; &quot;\\tIntegral shared stack mem:%ldkB/s\\n&quot; &quot;\\tsoft page fault:%ld\\n&quot; &quot;\\thard page fault:%ld\\n&quot; &quot;\\tswaps out of physical mem:%ld\\n&quot; &quot;\\tfile input block:%ld\\n&quot; &quot;\\tfile output block:%ld\\n&quot; &quot;\\tIPC msg send:%ld\\n&quot; &quot;\\tIPC msg recv:%ld\\n&quot; &quot;\\tsignal recv:%ld\\n&quot; &quot;\\tvoluntary context switch:%ld\\n&quot; &quot;\\tinvoluntary context switch:%ld\\n&quot;, rcputime(rusage, ru_utime), rcputime(rusage, ru_stime), rcputime(rusage, ru_utime) + rcputime(rusage, ru_stime), rusage.ru_maxrss, rusage.ru_ixrss, rusage.ru_idrss, rusage.ru_isrss, rusage.ru_minflt, rusage.ru_majflt, rusage.ru_nswap, rusage.ru_inblock, rusage.ru_oublock, rusage.ru_msgsnd, rusage.ru_msgrcv, rusage.ru_nsignals, rusage.ru_nvcsw, rusage.ru_nivcsw);} 36.2ç¼–å†™ä¸€ä¸ªç¨‹åºæ¥æ‰§è¡Œä¸€ä¸ªå‘½ä»¤ï¼Œæ¥ç€æ˜¾ç¤ºå…¶å½“å‰çš„èµ„æºä½¿ç”¨ã€‚è¿™ä¸ªç¨‹åºä¸ time(1)å‘½ä»¤çš„åŠŸèƒ½ç±»ä¼¼ï¼Œå› æ­¤å¯ä»¥åƒä¸‹é¢è¿™æ ·ä½¿ç”¨è¿™ä¸ªç¨‹åº: 1$ ./rusage command arg... 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//// Created by root on 7/18/23.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/times.h&gt;#include &lt;unistd.h&gt;#include &lt;limits.h&gt;#include &lt;sys/resource.h&gt;#define CHECK(x) \\ do { \\ if(!(x)) { \\ fprintf(stderr, &quot;%s:%d\\nerror: %s\\n&quot;, __FILE__, __LINE__,strerror(errno)); \\ exit(0); \\ } \\ } while(0)#define rcputime(rusage, xtime) rusage.xtime.tv_sec + rusage.xtime.tv_usec/1000000.0int main(int argc, char **argv) { struct rusage rusage; pid_t pid; if((pid = fork()) == 0) { CHECK(execvp(argv[1], &amp;argv[1]) != 0); } CHECK(waitpid(pid, NULL, 0) != -1); CHECK(getrusage(RUSAGE_CHILDREN, &amp;rusage) != -1); printf(&quot;&quot; &quot;child use:\\n&quot; &quot;\\tcpu time:\\n&quot; &quot;\\t\\tcpu time:%.2lfs (user)\\n&quot; &quot;\\t\\tcpu time:%.2lfs (system)\\n&quot; &quot;\\ttotal:%.2lfs\\n&quot; &quot;\\tMax resident set:%ldKB\\n&quot; &quot;\\tIntegral shared mem:(kB/s)\\n&quot; &quot;\\t\\ttext\\tmem:%ldkB/s\\n&quot; &quot;\\t\\tdata\\tmem:%ldkB/s\\n&quot; &quot;\\t\\tstack\\tmem:%ldkB/s\\n&quot; &quot;\\tpage fault:\\n&quot; &quot;\\t\\tsoft:%ld\\n&quot; &quot;\\t\\thard:%ld\\n&quot; &quot;\\tswaps out of physical mem:%ld\\n&quot; &quot;\\tfile input block:%ld\\n&quot; &quot;\\tfile output block:%ld\\n&quot; &quot;\\tIPC msg:\\n&quot; &quot;\\t\\tsend:%ld\\n&quot; &quot;\\t\\trecv:%ld\\n&quot; &quot;\\tsignal recv:%ld\\n&quot; &quot;\\tvoluntary context switch:%ld\\n&quot; &quot;\\tinvoluntary context switch:%ld\\n&quot;, rcputime(rusage, ru_utime), rcputime(rusage, ru_stime), rcputime(rusage, ru_utime) + rcputime(rusage, ru_stime), rusage.ru_maxrss, rusage.ru_ixrss, rusage.ru_idrss, rusage.ru_isrss, rusage.ru_minflt, rusage.ru_majflt, rusage.ru_nswap, rusage.ru_inblock, rusage.ru_oublock, rusage.ru_msgsnd, rusage.ru_msgrcv, rusage.ru_nsignals, rusage.ru_nvcsw, rusage.ru_nivcsw);} 36.3ç¼–å†™ä¸€ä¸ªç¨‹åºæ¥ç¡®å®šå½“è¿›ç¨‹æ‰€æ¶ˆè€—çš„å„ç§èµ„æºè¶…å‡ºé€šè¿‡ setrlimit0è°ƒç”¨è®¾ç½®çš„è½¯é™åˆ¶æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆäº‹æƒ…ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250//// Created by root on 7/18/23.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;signal.h&gt;#include &lt;errno.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sched.h&gt;#include &lt;sys/times.h&gt;#include &lt;unistd.h&gt;#include &lt;limits.h&gt;#include &lt;sys/resource.h&gt;#include &lt;fcntl.h&gt;#define CONDITION(x) \\ do { \\ if(!(x)) { \\ fprintf(stderr, &quot;%s:%d\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__, #x); \\ exit(2); \\ } \\ } while(0)#define CHECK(x) \\ do { \\ if(!(x)) { \\ fprintf(stderr, &quot;%s:%d\\nerror: %s\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__,strerror(errno), #x); \\ exit(1); \\ } \\ } while(0)#define USER 10087void test(__rlimit_resource_t res, const char *name,void (*task)(__rlimit_resource_t res, struct rlimit *)) { printf(&quot;test: %d(%s)\\n&quot;, res, name); pid_t pid; CHECK((pid = fork()) != -1); if(!pid) { struct rlimit lim; CHECK(getrlimit(res, &amp;lim) != -1); printf(&quot;soft=%lu, hard=%lu\\n&quot;, lim.rlim_cur, lim.rlim_max); task(res, &amp;lim); printf(&quot;soft=%lu, hard=%lu\\n&quot;, lim.rlim_cur, lim.rlim_max); exit(0); } int status; CHECK(waitpid(pid, &amp;status, 0) != -1); CONDITION(WEXITSTATUS(status) != 0 || WCOREDUMP(status));}#define invoke_test(res) test(res, #res, f##res)#define fun(name) void f##name(__rlimit_resource_t res, struct rlimit *lim)fun(RLIMIT_AS) { lim-&gt;rlim_cur = 1024; CHECK(setrlimit(res, lim) != -1); CHECK(sbrk(1024 + 1) != (void *) -1);}fun(RLIMIT_CORE) { pid_t pid; CHECK((pid = fork()) != -1); if(!pid) { CONDITION(lim-&gt;rlim_cur != 0); lim-&gt;rlim_cur = 1; CHECK(setrlimit(res, lim) != -1); CHECK(sbrk(lim-&gt;rlim_cur + 1) != (void *) -1); abort(); } int status; CHECK(waitpid(pid, &amp;status, 0) != -1); CONDITION(WCOREDUMP(status)); // è¶…è¿‡limitï¼Œåˆ™ä¸äº§ç”Ÿcore dumpæ–‡ä»¶}void signal_RLIMIT_CPU(int sig) { printf(&quot;pid=%ld, received signal:%d(%s)\\n&quot;, (long)getpid(), sig, strsignal(sig)); exit(1);}fun(RLIMIT_CPU) { CHECK(signal(SIGXCPU, signal_RLIMIT_CPU) != SIG_ERR); lim-&gt;rlim_cur = 1; CHECK(setrlimit(res, lim) != -1); for(;;);}fun(RLIMIT_DATA) { lim-&gt;rlim_cur = 1; CHECK(setrlimit(res, lim) != -1); CHECK(sbrk(lim-&gt;rlim_cur + 1) != (void *)-1);}fun(RLIMIT_FSIZE) { lim-&gt;rlim_cur = 1; char buf[1024]; CHECK(setrlimit(res, lim) != -1); char *file = tmpnam(NULL); CHECK(file != NULL); printf(&quot;create tmp file:%s\\n&quot;, file); int fd = open(file, O_CREAT|O_RDWR, 0611); CHECK(fd != -1); ssize_t writesize; if((writesize = write(fd, buf, 1024)) != 1024) { CHECK(writesize != -1); printf(&quot;incomplete write, write %lu byte\\n&quot;, writesize); } else { printf(&quot;write, write %lu byte\\n&quot;, writesize); } CHECK(close(fd) != -1); CHECK(unlink(file) != -1); CONDITION(writesize == 1024);}fun(RLIMIT_MEMLOCK);fun(RLIMIT_MSGQUEUE);fun(RLIMIT_NICE) {// CHECK(setpriority(PRIO_PROCESS, 0, 0) != -1); CHECK(setuid(10087) != -1); //åˆ‡æ¢åˆ°érootç”¨æˆ· lim-&gt;rlim_cur = 5; lim-&gt;rlim_max = 5; CHECK(setrlimit(res, lim) != -1); errno = 0; int prio = getpriority(PRIO_PROCESS, 0); CHECK(!(prio == -1 &amp;&amp; errno != 0)); printf(&quot;current prio = %d\\n&quot;, prio); CHECK(setpriority(PRIO_PROCESS, 0, 14) != -1); CHECK(setpriority(PRIO_PROCESS, 0, 16) != -1);}fun(RLIMIT_NOFILE) { lim-&gt;rlim_cur = 0; lim-&gt;rlim_max = 0; CHECK(setrlimit(res, lim) != -1); char *file = tmpnam(NULL); CHECK(file != NULL); printf(&quot;create tmp file:%s\\n&quot;, file); int fd = open(file, O_CREAT|O_RDWR, 0611); CHECK(fd != -1); CHECK(close(fd) != -1);}fun(RLIMIT_NPROC) { CHECK(setuid(10087) != -1); //åˆ‡æ¢åˆ°érootç”¨æˆ· lim-&gt;rlim_cur = 0; lim-&gt;rlim_max = 0; CHECK(setrlimit(res, lim) != -1); CHECK(fork() != -1);}fun(RLIMIT_RSS);fun(RLIMIT_RTPRIO) { CHECK(setuid(0) != -1); lim-&gt;rlim_cur = 50; lim-&gt;rlim_max = 50; CHECK(setrlimit(res, lim) != -1); CHECK(setuid(10087) != -1); CHECK(sched_setscheduler(0, SCHED_FIFO, &amp;(struct sched_param) { .sched_priority=50 }) != -1); CHECK(sched_setscheduler(0, SCHED_FIFO, &amp;(struct sched_param) { .sched_priority=51 }) != -1);}fun(RLIMIT_RTTIME) { CHECK(sched_setscheduler(0, SCHED_FIFO, &amp;(struct sched_param) { .sched_priority=sched_get_priority_max(SCHED_FIFO) }) != -1); CHECK(signal(SIGXCPU, signal_RLIMIT_CPU) != SIG_ERR); lim-&gt;rlim_cur = 1; CHECK(setrlimit(res, lim) != -1); for(;;);}fun(RLIMIT_SIGPENDING) { lim-&gt;rlim_cur = 1; char buf[1024] = {0}; sprintf(buf, &quot;/proc/%d/status&quot;, getpid()); if(!fork()) { execlp(&quot;cat&quot;, &quot;cat&quot;, buf, NULL); } wait(NULL); CHECK(setrlimit(res, lim) != -1); sigset_t set; CHECK(sigemptyset(&amp;set) != -1); CHECK(sigaddset(&amp;set, SIGRTMAX-2) != -1); CHECK(sigaddset(&amp;set, SIGRTMAX-1) != -1); CHECK(sigprocmask(SIG_BLOCK, &amp;set, NULL) != -1);// CHECK(sigqueue(getpid(), SIGUSR1, (union sigval){.sival_int=0}) != -1);// CHECK(sigqueue(getpid(), SIGUSR2, (union sigval){.sival_int=0}) != -1); // ä¸æ˜¯è¯´æ ‡å‡†ä¿¡å·å’Œå®æ—¶ä¿¡å·éƒ½è¡Œå—ï¼Ÿ CHECK(sigqueue(getpid(), SIGRTMAX - 1, (union sigval){.sival_int=0}) != -1); CHECK(sigqueue(getpid(), SIGRTMAX - 2, (union sigval){.sival_int=0}) != -1);// CHECK(sigqueue(getpid(), SIGUSR2, (union sigval){.sival_int=0}) != -1); // ä¸æ˜¯è¯´æ ‡å‡†ä¿¡å·å’Œå®æ—¶ä¿¡å·éƒ½è¡Œå—ï¼Ÿ if(!fork()) { execlp(&quot;cat&quot;, &quot;cat&quot;, buf, NULL); } wait(NULL);}void handlerRLIMIT_STACK(int sig) { printf(&quot;pid:%ld received a signal:%d(%s)\\n&quot;, (long) getpid(), sig, strsignal(sig)); exit(1);}void stackoverflow() { char buf[MINSIGSTKSZ*MINSIGSTKSZ] = {0}; // åæ­£è¿™é‡Œè¦è¶³å¤Ÿå¤§ // å‚è€ƒè¿™é‡Œ: https://stackoverflow.com/questions/4118016/set-stack-size-with-setrlimit-and-provoke-a-stack-overflow-segfault buf[MINSIGSTKSZ+1] = 0;}fun(RLIMIT_STACK) {// CHECK(signal(SIGSEGV, handlerRLIMIT_STACK) != SIG_ERR); CHECK(sigaltstack(&amp;(stack_t) { .ss_flags=0, .ss_size=SIGSTKSZ, .ss_sp=malloc(SIGSTKSZ) }, NULL) != -1); sigset_t sigset; CHECK(sigemptyset(&amp;sigset) != -1); CHECK(sigaction(SIGSEGV, &amp;(struct sigaction) { .sa_flags = SA_ONSTACK, // sigaltstackè¦æ­é…è¿™ä¸ªflag .sa_mask = sigset, .sa_handler=handlerRLIMIT_STACK },NULL) != -1); lim-&gt;rlim_cur = MINSIGSTKSZ;// lim-&gt;rlim_max = 0; CHECK(setrlimit(res, lim) != -1); stackoverflow();}int main(int argc, char ** argv) { invoke_test(RLIMIT_AS); invoke_test(RLIMIT_CORE); invoke_test(RLIMIT_CPU); invoke_test(RLIMIT_DATA); invoke_test(RLIMIT_FSIZE);// invoke_test(RLIMIT_MEMLOCK); //è¿˜æ²¡å­¦// invoke_test(RLIMIT_MSGQUEUE); //è¿˜æ²¡å­¦// invoke_test(RLIMIT_NICE); invoke_test(RLIMIT_NOFILE); invoke_test(RLIMIT_NPROC);// invoke_test(RLIMIT_RSS); //linuxæ²¡ä½œç”¨ invoke_test(RLIMIT_RTPRIO); invoke_test(RLIMIT_RTTIME); invoke_test(RLIMIT_SIGPENDING); invoke_test(RLIMIT_STACK);}","link":"/home/2023/07/18/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha36/"},{"title":"cha33.çº¿ç¨‹ï¼šæ›´å¤šç»†èŠ‚","text":"33.1ç¼–å†™ç¨‹åºä»¥ä¾¿è¯æ˜:ä½œä¸ºå‡½æ•°sigpending()çš„è¿”å›å€¼ï¼ŒåŒä¸€ä¸ªè¿›ç¨‹ä¸­çš„çš„ä¸åŒçº¿ç¨‹å¯ä»¥æ‹¥æœ‰ä¸åŒçš„ pendingä¿¡å·ã€‚å¯ä»¥ä½¿ç”¨å‡½æ•°pthread_kill(åˆ†åˆ«å‘é€ä¸åŒçš„ä¿¡å·ç»™é˜»å¡è¿™äº›ä¿¡å·çš„ä¸¤ä¸ªä¸åŒçš„çº¿ç¨‹,æ¥ç€è°ƒç”¨sigpending()æ–¹æ³•å¹¶æ˜¾ç¤ºè¿™äº›pendingä¿¡å·çš„ä¿¡æ¯ã€‚(å¯èƒ½ä¼šå‘ç°ç¨‹åºæ¸…å•20-4ä¸­å‡½æ•°çš„ä½œç”¨ã€‚) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//// Created by root on 7/2/23.//#define _GNU_SOURCE#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#define CHECK(x) do { if(!(x)) { fprintf(stderr, &quot;ERROR: %s\\nfile=%s, line=%d\\n&quot;, strerror(errno), __FILE__, __LINE__); exit(1); } } while(0)#define THREAD_CNT 5pthread_mutex_t sig_mutex;pthread_cond_t sig_cond;int thread_ready_count;void handler(int sig, siginfo_t *info, void *context) { printf(&quot;recv sig = %d: %s, from = %d\\n&quot;, sig, strsignal(sig), info-&gt;si_value.sival_int);}pthread_t tid2pthread[THREAD_CNT];int tid2sig(int tid) { return SIGRTMAX - 1 - tid;}void *fun_thread(void *arg) { int tid = *(int *)arg; free(arg); sigset_t set; CHECK(sigemptyset(&amp;set) == 0); CHECK(sigaddset(&amp;set, tid2sig(tid)) == 0); CHECK(pthread_sigmask(SIG_SETMASK, &amp;set, NULL) == 0); CHECK(sigaction(tid2sig(tid), &amp;(struct sigaction) { .sa_sigaction =handler, .sa_flags = SA_SIGINFO, .sa_mask = 0 }, NULL) == 0); printf(&quot;Thread-%d, sigaction %d\\n&quot;, tid, tid2sig(tid)); CHECK(pthread_mutex_lock(&amp;sig_mutex) == 0); thread_ready_count++; tid2pthread[tid] = pthread_self(); CHECK(pthread_mutex_unlock(&amp;sig_mutex) == 0); CHECK(pthread_cond_broadcast(&amp;sig_cond) == 0); CHECK(pthread_mutex_lock(&amp;sig_mutex) == 0); while(thread_ready_count &lt; THREAD_CNT){ CHECK(pthread_cond_wait(&amp;sig_cond, &amp;sig_mutex) == 0); } CHECK(pthread_mutex_unlock(&amp;sig_mutex) == 0); int sig = tid2sig((tid + 1) % THREAD_CNT); printf(&quot;Thread-%d send %d(%s) to %d\\n&quot;, tid, sig, strsignal(sig), (tid + 1) % THREAD_CNT); CHECK(pthread_sigqueue(tid2pthread[(tid + 1) % THREAD_CNT], sig, (union sigval) { .sival_int=tid }) == 0); do { printf(&quot;Thread-%d sig not pending %d\\n&quot;, tid, tid2sig(tid)); sleep(1); CHECK(sigemptyset(&amp;set) == 0); CHECK(sigpending(&amp;set) == 0); } while(sigismember(&amp;set, tid2sig(tid)) == 0); printf(&quot;Thread-%d sig pending %d\\n&quot;, tid, tid2sig(tid)); CHECK(sigemptyset(&amp;set) == 0); CHECK(pthread_sigmask(SIG_SETMASK, &amp;set, NULL) == 0); CHECK(sigpending(&amp;set) == 0); sig = -1; while(sig != tid2sig(tid)) CHECK(sigwait(&amp;set, &amp;sig) == 0); printf(&quot;Thread-%d exit\\n&quot;, tid); return NULL;}int main(int argc, char *argv[]) { CHECK(pthread_mutex_init(&amp;sig_mutex, NULL) == 0); CHECK(pthread_cond_init(&amp;sig_cond, NULL) == 0); thread_ready_count = 0; for(int i = 0; i &lt; THREAD_CNT; i++) { pthread_t thread; int *data = malloc(sizeof(int)); *data = i; CHECK(pthread_create(&amp;thread, NULL, fun_thread, data) == 0); } pthread_exit(NULL);} 33.2å‡è®¾ä¸€ä¸ªçº¿ç¨‹ä½¿ç”¨fork()åˆ›å»ºäº†ä¸€ä¸ªå­è¿›ç¨‹ã€‚å½“å­è¿›ç¨‹ç»ˆæ­¢æ—¶ï¼Œå¯ä»¥ä¿è¯ç”±æ­¤äº§ç”Ÿçš„SIGCHLDä¿¡å·ä¸€å®šä¼šå‘é€ç»™è°ƒç”¨fork()çš„çº¿ç¨‹å—(å¯ä»¥ç”¨è¿›ç¨‹ä¸­çš„å…¶ä»–çº¿ç¨‹åšå¯¹æ¯”)? 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//// Created by root on 7/2/23.//#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#define CHECK(x) do { if(!(x)) { fprintf(stderr, &quot;ERROR: %s\\nfile=%s, line=%d\\n&quot;, strerror(errno), __FILE__, __LINE__); exit(1); } } while(0)sigset_t set;void handler(int sig, siginfo_t *info, void *context) { printf(&quot;recv sig = %d: %s, my tid is %ld\\n&quot;, sig, strsignal(sig), pthread_self());}void *fn(void *arg) { CHECK(sigaction(SIGCHLD, &amp;(struct sigaction) { .sa_mask = 0, .sa_flags = SA_SIGINFO, .sa_sigaction=handler }, NULL) == 0); if(*(int *)arg) { printf(&quot;I am %ld, I fork\\n&quot;, pthread_self()); if(!fork()) { exit(0); }// wait(NULL); } else { printf(&quot;I am %ld, I sleep\\n&quot;, pthread_self()); sleep(10); } free(arg); return NULL;}int main() { CHECK(sigemptyset(&amp;set) == 0); CHECK(sigaddset(&amp;set, SIGCHLD) == 0); CHECK(sigaction(SIGCHLD, &amp;(struct sigaction) { .sa_mask = 0, .sa_flags = SA_SIGINFO, .sa_sigaction=handler }, NULL) == 0); pthread_t tid; int ok = 0; CHECK(pthread_create(&amp;tid, NULL, fn, memcpy(malloc(sizeof(int)), &amp;ok, sizeof(int))) == 0); ok = 1; CHECK(pthread_create(&amp;tid, NULL, fn, memcpy(malloc(sizeof(int)), &amp;ok, sizeof(int))) == 0); pthread_exit(NULL);} ä¸ä¸€å®šç›¸åŒï¼Œå‰é¢ä¹¦ä¸­æ­£æ–‡ä¹Ÿè¯´è¿‡äº†","link":"/home/2023/07/01/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha33/"},{"title":"cha26.ç›‘æ§å­è¿›ç¨‹","text":"å­¤å„¿ä¸åƒµå°¸ å­¤å„¿ï¼š å­è¿›ç¨‹ç»“æŸå‰çˆ¶è¿›ç¨‹æœªwaitç»“æŸçš„è¿›ç¨‹ã€‚å…¶çˆ¶è¿›ç¨‹ä¼šå˜æˆ1ç”±initæ¥ç®¡è¿›è¡Œwait åƒµå°¸ï¼š çˆ¶è¿›ç¨‹æœªç»“æŸï¼Œå­è¿›ç¨‹å·²ç»ç»“æŸï¼Œä¸”çˆ¶è¿›ç¨‹æœªæ‰§è¡Œwaitã€‚ç³»ç»Ÿä¿ç•™åƒµå°¸çš„è¿›ç¨‹è¡¨è®°å½•ï¼Œä»¥å¤‡æœªæ¥çˆ¶è¿›ç¨‹éœ€è¦waitè·å–å…¶ç»“æŸçŠ¶æ€ æ— æ³•è¢«killï¼Œåªèƒ½killå…¶çˆ¶è¿›ç¨‹ 1ç¼–å†™ä¸€ç¨‹åºä»¥éªŒè¯å½“ä¸€å­è¿›ç¨‹çš„çˆ¶è¿›ç¨‹ç»ˆæ­¢æ—¶ï¼Œè°ƒç”¨getppid()å°†è¿”å›1ï¼ˆè¿›ç¨‹ initçš„è¿›ç¨‹ID)ã€‚ æ— èŠï¼Œä¸å¼„ 2å‡è®¾å­˜åœ¨3ä¸ªç›¸äº’å…³è”çš„è¿›ç¨‹ï¼ˆç¥–çˆ¶ã€çˆ¶åŠå­è¿›ç¨‹)ï¼Œç¥–çˆ¶è¿›ç¨‹æ²¡æœ‰åœ¨çˆ¶è¿›ç¨‹é€€å‡ºä¹‹åç«‹å³æ‰§è¡Œwait()ï¼Œæ‰€ä»¥çˆ¶è¿›ç¨‹å˜æˆåƒµå°¸è¿›ç¨‹ã€‚é‚£ä¹ˆè¯·æŒ‡å‡ºå­™è¿›ç¨‹ä½•æ—¶è¢«initè¿›ç¨‹æ”¶å…»ï¼ˆå³å­™è¿›ç¨‹è°ƒç”¨getppid)å°†è¿”å›1)ï¼Œæ˜¯åœ¨çˆ¶è¿›ç¨‹ç»ˆæ­¢åï¼Œè¿˜æ˜¯ç¥–çˆ¶è¿›ç¨‹è°ƒç”¨wait()å?è¯·ç¼–å†™ç¨‹åºéªŒè¯ç»“æœã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;sys/wait.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#define CHECK(x) do {if(!(x)) {fprintf(stderr, &quot;CHECK: %s\\n&quot;, strerror(errno));} } while(0)void son(pid_t child) { printf(&quot;son: pid = %d, ppid = %d\\n&quot;, getpid(), getppid()); kill(getppid(), SIGUSR2); sleep(1); for(int i = 0; i &lt; 10; i++) { printf(&quot;son: pid = %d, ppid = %d\\n&quot;, getpid(), getppid()); sleep(1); }}void father(pid_t child) { printf(&quot;father: pid = %d, ppid = %d\\n&quot;, getpid(), getppid()); sleep(100);}void grandpa(pid_t child) { printf(&quot;grandpa: pid = %d, ppid = %d\\n&quot;, getpid(), getppid()); sleep(100);}void son_exit(int sig) { if(sig == SIGCHLD) { printf(&quot;gandpa: SIGCHLD\\n&quot;); sleep(5); CHECK(wait(NULL) &gt; 0); printf(&quot;gandpa: wait father\\n&quot;); sleep(100); }}void killme(int sig) { if(sig == SIGUSR2) { printf(&quot;father: SIGUSR2, exit\\n&quot;); _exit(0); }}int main() { sigaction(SIGCHLD, &amp;(struct sigaction){ .sa_handler=son_exit }, NULL); sigaction(SIGUSR2, &amp;(struct sigaction) { .sa_handler=killme }, NULL); pid_t pid = fork(); CHECK(pid &gt;= 0); if(!pid) { pid_t pid1 = fork(); CHECK(pid1 &gt;= 0); if(!pid1) { son(pid1); } else { father(pid1); } } else { grandpa(pid); } return 0;} è¾“å‡ºåˆ†æ12345678910111213141516grandpa: pid = 15308, ppid = 14448father: pid = 15309, ppid = 15308son: pid = 15310, ppid = 15309father: SIGUSR2, exitgandpa: SIGCHLDson: pid = 15310, ppid = 38son: pid = 15310, ppid = 38son: pid = 15310, ppid = 38son: pid = 15310, ppid = 38gandpa: wait fatherson: pid = 15310, ppid = 38son: pid = 15310, ppid = 38son: pid = 15310, ppid = 38son: pid = 15310, ppid = 38son: pid = 15310, ppid = 38son: pid = 15310, ppid = 38 fatheré€€å‡ºåç¼ºå°‘è¢«æ¥ç®¡äº†ï¼Œä½†æ˜¯ä¸æ˜¯init æŸ¥äº†èµ„æ–™åå‘ç°æ˜¯ä½¿ç”¨ä¼ªç»ˆç«¯çš„åŸå›  26.3ä½¿ç”¨waitid()æ›¿æ¢ç¨‹åºæ¸…å•26-3 (child_status.cï¼‰ä¸­çš„ waitpid()ã€‚éœ€è¦å°†å¯¹å‡½æ•°printWaitStatus()çš„è°ƒç”¨æ›¿æ¢ä¸ºæ‰“å° waitid()æ‰€è¿”å›siginfo_tç»“æ„ä¸­ç›¸å…³å­—æ®µçš„ä»£ç ã€‚ æ— èŠï¼Œä¸æ 26.4ç¨‹åºæ¸…å•26-4(make_zombie.cï¼‰è°ƒç”¨äº†sleep()ï¼Œä»¥ä¾¿å…è®¸å­è¿›ç¨‹åœ¨çˆ¶è¿›ç¨‹æ‰§è¡Œå‡½æ•°system()å‰å¾—åˆ°æœºä¼šå»è¿è¡Œå¹¶ç»ˆæ­¢ã€‚è¿™ä¸€æ–¹æ³•ç†è®ºä¸Šå­˜åœ¨äº§ç”Ÿç«äº‰æ¡ä»¶çš„å¯èƒ½ã€‚ä¿®æ”¹æ­¤ç¨‹åºï¼Œä½¿ç”¨ä¿¡å·æ¥åŒæ­¥çˆ¶å­è¿›ç¨‹ä»¥æ¶ˆé™¤è¯¥ç«äº‰æ¡ä»¶ã€‚ forkå‰è®¾ç½®å¤„ç†å™¨å‡½æ•°ï¼Œè¯¥å‡½æ•°longjmpåˆ°å­è¿›ç¨‹æ‰§è¡Œä½ç½®forkåçˆ¶è¿›ç¨‹è¿˜åŸå¤„ç†å™¨å‡½æ•°ï¼Œå‘é€ä¿¡å· å°±é…±","link":"/home/2023/06/19/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha26/"},{"title":"cha34.è¿›ç¨‹ç»„ã€ä¼šè¯å’Œä½œä¸šæ§åˆ¶","text":"è¯»ä¹¦ç¬”è®°34.1å‡è®¾ä¸€ä¸ªçˆ¶è¿›ç¨‹æ‰§è¡Œäº†ä¸‹é¢çš„æ­¥éª¤ã€‚è¿™ä¸ªåº”ç”¨ç¨‹åºè®¾è®¡å¯èƒ½ä¼šç¢°åˆ°ä»€ä¹ˆé—®é¢˜?è€ƒè™‘ shell ç®¡é“ã€‚å¦‚ä½•é¿å…æ­¤ç±»é—®é¢˜çš„å‘ç”Ÿ? 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/wait.h&gt;void handler(int sig){ printf(&quot;%d, received %d(%s)\\n&quot;, getpid(), sig, strsignal(sig));}int main() { sigset_t set; sigemptyset(&amp;set); sigaddset(&amp;set, SIGUSR1); signal(SIGUSR1, handler); for(int i = 0; i &lt; 10; i++) { pid_t pid; if((pid = fork()) == 0) { pause(); return 0; } else { printf(&quot;child-%d: %d\\n&quot;, i, pid); } } signal(SIGUSR1, SIG_IGN); killpg(getpgrp(), SIGUSR1); waitpid(-1, NULL, 0);} å‡è®¾ä¸å‘é€SIGUSERæ—¶ å½“ä¸ä½¿ç®¡é“æ—¶ï¼Œå¯ä»¥çœ‹åˆ°æœ‰å°äºç­‰äº10ä¸ªå­è¿›ç¨‹æ˜¾ç¤ºæ”¶åˆ°SIGUSER1 å¦‚æœä½¿ç”¨ç®¡é“ï¼Œä¼šå‘ç°child-%d: %dè¢«é‡å¤è¾“å‡ºäº†å¤šæ¬¡ï¼Œè¿™æ˜¯ç”±äºstdoutè¢«é‡å®šå‘åå˜æˆäº†å…¨ç¼“å†²ï¼Œforkçš„å­è¿›ç¨‹é€€å‡ºåfflush()æ—¶ä¼šå°†forkå‰æœªflushçš„æ•°æ®æ‰“å°å‡ºæ¥ã€‚ å‡è®¾æ‰§è¡Œè¯¥å‘½ä»¤./practice34.1 | catï¼Œè¾“å‡ºä¼šæ˜¯User defined signal 1ï¼Œå³catä¸ç¨‹åºåŒå±ä¸€ä¸ªè¿›ç¨‹ç»„ï¼Œcatä¹Ÿä¼šæ”¶åˆ°è¯¥ä¿¡å·ï¼Œå¯¼è‡´æ— æ³•æ­£å¸¸æ‰§è¡Œï¼ˆéé¢„æœŸå†…ï¼‰ é¿å…è®°å½•æ¯ä¸ªå­è¿›ç¨‹çš„pidï¼Œä¾æ¬¡ç»™æ¯ä¸ªpidå‘é€ä¿¡å·ï¼Œé¿å…ä½¿ç”¨killpgæˆ–killæ—¶ä½¿ç”¨è´Ÿå€¼pid 34.2ç¼–å†™ä¸€ä¸ªç¨‹åºæ¥éªŒè¯çˆ¶è¿›ç¨‹èƒ½å¤Ÿåœ¨å­è¿›ç¨‹æ‰§è¡Œexec0ä¹‹å‰ä¿®æ”¹å­è¿›ç¨‹çš„è¿›ç¨‹ç»„IDä½†æ— æ³•åœ¨æ‰§è¡Œexec0ä¹‹åä¿®æ”¹å­è¿›ç¨‹çš„è¿›ç¨‹ç»„IDã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//// Created by root on 7/10/23.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/wait.h&gt;#include &lt;errno.h&gt;pid_t pid;void parent_handler(int sig) { printf(&quot;pid = %d, recv sig-%d(%s), setpgid pid=%d, pgid=%d\\n&quot;, getpid(), sig, strsignal(sig), pid, getpgid(getpid())); if(setpgid(pid, getpgid(getpid())) == -1) { printf(&quot;setpgid fail, %dï¼Œ err:%s\\n&quot;, __LINE__, strerror(errno)); } printf(&quot;newpgid pid=%d, pgid=%d\\n&quot;, pid, getpgid(pid)); kill(pid, SIGUSR1);}int main(int argc, char **argv) { if(argc == 1) { printf(&quot;before fork, pgid=%d\\n&quot;, getpgid(getpid())); if((pid = fork()) == 0) { printf(&quot;before exec, pid = %d, gid = %d\\n&quot;, getpid(), getpgrp()); fflush(stdout); int len = snprintf(NULL, 0, &quot;%d&quot;, getppid()); char *spid = malloc(len + 1); sprintf(spid, &quot;%d&quot;, getppid()); if(spid) { fflush(stdout); if(execl(argv[0], argv[0], spid) == -1) { printf(&quot;execl error!\\n&quot;); } } else { printf(&quot;error: malloc, len = %d\\n&quot;, len); } } else { // çˆ¶è¿›ç¨‹å…ˆæ‰§è¡Œ signal(SIGUSR1, parent_handler); setpgid(pid, 0);// kill(pid, SIGUSR1); wait(NULL); } } else { printf(&quot;exec pid = %d, gid = %d\\n&quot;, getpid(), getpgrp()); kill(atoi(argv[1]), SIGUSR1); pause(); }} å¯ä»¥çœ‹åˆ°ï¼Œåœ¨parent_handlerä¸­ï¼Œå¯¹å­è¿›ç¨‹ä¿®æ”¹pgidåå†æ¬¡æŸ¥è¯¢å…¶pgidï¼Œå¹¶æ²¡æœ‰æ”¹å˜æŠ¥é”™ä¸ºPermission denied 34.3ç¼–å†™ä¸€ä¸ªç¨‹åºæ¥éªŒè¯åœ¨è¿›ç¨‹ç»„é¦–è¿›ç¨‹ä¸­è°ƒç”¨setsidä¼šå¤±è´¥ 123456789#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;int main() { if(setsid() == -1) { fprintf(stderr, &quot;error: %s\\n&quot;, strerror(errno)); }} ç»“æœ1error: Operation not permitted 34.4ä¿®æ”¹ç¨‹åºæ¸…å•34-4 (disc_SIGHUP.c)æ¥éªŒè¯å½“æ§åˆ¶è¿›ç¨‹åœ¨æ”¶åˆ° SIGHUP ä¿¡å·è€Œä¸ç»ˆæ­¢æ—¶ï¼Œå†…æ ¸ä¸ä¼šå‘å‰å°è¿›ç¨‹ç»„ä¸­çš„æˆå‘˜å‘é€SIGHUPä¿¡å·ã€‚ 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#define CHECK(x) do { if(!(x)) { fprintf(stderr, &quot;CHECK: %s, %s:%d\\n&quot;, strerror(errno), __FILE__, __LINE__); } } while(0)void handler(int sig) { printf(&quot;PID=%ld received signal: %d(%s)\\n&quot;, (long) getpid(), sig, strsignal(sig));}int main(int argc, char **argv) { setbuf(stdout, NULL); if(argc &lt; 2) { printf(&quot;Usage: exec %s [enable-sighup|disable-sighup] [d|s]...\\n&quot;, argv[0]); } printf(&quot;PID=%ld, PGID=%ld (parent)\\n&quot;, (long)getpid(), (long) getpgrp()); if(argv[1][0] == 'd') { CHECK(signal(SIGHUP, handler) != SIG_ERR); } for(int i = 2; i &lt; argc; i++) { pid_t pid; CHECK((pid = fork()) != -1); if(!pid) { if(argv[i][0] == 'd') { CHECK(setpgid(0, 0) != -1); } CHECK(signal(SIGHUP, handler) != SIG_ERR); break; } } printf(&quot;PID=%ld, PGID=%ld\\n&quot;, (long)getpid(), (long) getpgrp()); alarm(60); for(;;) pause(); getpgid(getpid());} å°ç»“å—¯ï¼Œç¡®å®æ˜¯è¿™æ · å¤ä¹ çŸ¥è¯† alarmåˆ°æœŸå‘é€SIGALARMï¼Œé»˜è®¤è¡Œä¸ºæ˜¯ç»“æŸè¿›ç¨‹ getpgrpæ˜¯è·å–å½“å‰è¿›ç¨‹çš„è¿›ç¨‹ç»„idï¼Œgetpgidæ˜¯è·å¾—å‚æ•°pidæŒ‡å®šè¿›ç¨‹çš„è¿›ç¨‹ç»„id signalå‡½æ•°å¤±è´¥æ—¶çš„è¿”å›å€¼æ˜¯SIG_ERR çŸ¥è¯†è¡¥æ¼ SIGTSTPå’ŒSIGSTOP ä¸¤ä¸ªä¿¡å·çš„ä½œç”¨éƒ½æ˜¯è®©è¿›ç¨‹æš‚åœï¼ŒåŒºåˆ«æ˜¯SIGSTOPä¸å¯ä»¥æ•è·ã€‚ waitå’Œwaitpid waitå½“è¿›ç¨‹åœæ­¢æ—¶è¿”å› waitpidå¯é€šè¿‡optionså‚æ•°ç­‰å¾…åœæ­¢çš„å­è¿›ç¨‹ waitflags.hä¸­çš„éƒ¨åˆ†å®å®šä¹‰ 12345678910111213141516/* Bits in the third argument to `waitpid'. */#define WNOHANG 1 /* Don't block waiting. */#define WUNTRACED 2 /* Report status of stopped children. *//* Bits in the fourth argument to `waitid'. */#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8# define WSTOPPED 2 /* Report stopped child (same as WUNTRACED). */# define WEXITED 4 /* Report dead child. */# define WCONTINUED 8 /* Report continued child. */# define WNOWAIT 0x01000000 /* Don't reap, just poll status. */#endif#define __WNOTHREAD 0x20000000 /* Don't wait on children of other threads in this group */#define __WALL 0x40000000 /* Wait for any child. */#define __WCLONE 0x80000000 /* Wait for cloned process. */ ç­‰å¾…æš‚åœçš„è¿›ç¨‹ 123456789101112131415161718192021222324#include &lt;wait.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#define CHECK(x) do { if(!(x)) { fprintf(stderr, &quot;CHECK: %s, %s:%d\\n&quot;, strerror(errno), __FILE__, __LINE__); } } while(0)int main() { pid_t pid; CHECK((pid = fork()) != -1); if(!pid) {// raise(SIGABRT); raise(SIGSTOP); } else { int status;// CHECK(wait(&amp;status) != (pid_t) -1); CHECK(waitpid(pid, &amp;status, WUNTRACED) != (pid_t) -1); int term_sig = WTERMSIG(status); printf(&quot;PID=%d terminated, terminate signal=%d(%s)\\n&quot;, pid, term_sig, strsignal(term_sig)); kill(pid, SIGKILL); }} 34.5å‡è®¾å°†ç¨‹åºæ¸…å•34-6ä¸­çš„ä¿¡å·å¤„ç†å™¨ä¸­è§£é™¤é˜»å¡SIGTSTPä¿¡å·çš„ä»£ç ç§»åŠ¨åˆ°å¤„ç†å™¨çš„å¼€å¤´éƒ¨åˆ†ã€‚è¿™æ ·åšä¼šå¯¼è‡´ä½•ç§ç«äº‰æ¡ä»¶? å¯èƒ½ä¼šå¯¼è‡´åŒæ—¶æ‰§è¡Œå¤šä¸ªtstphandlerï¼Ÿ 34.6ç¼–å†™ä¸€ä¸ªç¨‹åºæ¥éªŒè¯å½“ä½äºå­¤å„¿è¿›ç¨‹ç»„ä¸­çš„ä¸€ä¸ªè¿›ç¨‹è¯•å›¾ä»æ§åˆ¶ç»ˆç«¯è°ƒç”¨readæ—¶ä¼šå¾—åˆ°EIOçš„é”™è¯¯. 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#define CHECK(file, x) do { if(!(x)) { fprintf(file, &quot;CHECK: error:%d(%s), %s:%d\\n&quot;, errno, strerror(errno), __FILE__, __LINE__); } } while(0)int main() { int pid = fork(); CHECK(stdout, pid != -1); if(!pid) { CHECK(stdout, setpgid(0, 0) == 0); char arr[4096] = {0}; CHECK(stdout, read(STDIN_FILENO, arr, sizeof(arr)) &gt; 0); fprintf(stdout, &quot;EIO=%d\\n&quot;, EIO); }} å—¯ï¼Œç¡®å®æ˜¯è¿™æ · 12CHECK: error:5(Input/output error), /root/linux/cha34/practice34.6.c:20EIO=5 34.7ç¼–å†™ä¸€ä¸ªç¨‹åºæ¥éªŒè¯å½“SIGTTINã€SIGTTOUæˆ–SIGTSTPä¸‰ä¸ªä¿¡å·ä¸­çš„ä¸€ä¸ªä¿¡å·è¢«å‘é€ç»™å­¤å„¿è¿›ç¨‹ç»„ä¸­çš„ä¸€ä¸ªæˆå‘˜æ—¶ï¼Œå¦‚æœè¿™ä¸ªä¿¡å·ä¼šåœæ­¢è¯¥è¿›ç¨‹(å³å¤„ç†æ–¹å¼ä¸ºSIG_DFL)ï¼Œé‚£ä¹ˆè¿™ä¸ªä¿¡å·å°±ä¼šè¢«ä¸¢å¼ƒ(å³ä¸äº§ç”Ÿä»»ä½•æ•ˆæœ)ï¼Œä½†å¦‚æœè¯¥ä¿¡å·å­˜åœ¨å¤„ç†å™¨ï¼Œå°±ä¼šå‘é€è¯¥ä¿¡å·ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//// Created by root on 7/13/23.//#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;wait.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/shm.h&gt;#define CHECK(x) do { if(!(x)) { fprintf(stderr, &quot;CHECK: error:%d(%s), %s:%d\\n&quot;, errno, strerror(errno), __FILE__, __LINE__); } } while(0)void handler(int sig) { int saveerrno = errno; printf(&quot;pid=%d received signal=%d(%s)\\n&quot;, getpid(), sig, strsignal(sig)); CHECK(signal(sig, SIG_DFL) != SIG_ERR); sigset_t set, old; CHECK(sigemptyset(&amp;set) != -1); CHECK(sigaddset(&amp;set, sig) != -1); CHECK(raise(sig) != -1); CHECK(sigprocmask(SIG_UNBLOCK, &amp;set, &amp;old) != -1); printf(&quot;continue\\n&quot;); CHECK(sigprocmask(SIG_SETMASK, &amp;old, NULL) != -1); CHECK(signal(sig, handler) != SIG_ERR); errno = saveerrno;}#define SHM_KEY (key_t)5341int shmid;void ps(char *argpid){ pid_t pspid; if((pspid = fork()) == 0) { CHECK(execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;-f&quot;, argpid, NULL) != -1); _exit(0); } CHECK(pspid != (pid_t)-1); CHECK(waitpid(pspid, NULL, 0) != (pid_t)-1);}int main(int argc, char **argv) { CHECK(argc == 3); CHECK(argv[1][0] == 'e' || argv[1][0] == 'd'); CHECK(argv[2][0] &gt;= '0' || argv[2][0] &lt;= '2'); int sigs[3] = { SIGTTIN, SIGTTOU, SIGTSTP }; if(argv[1][0] == 'e') { CHECK(signal(sigs[argv[2][0] - '0'], handler) != SIG_ERR); } CHECK((shmid = shmget(SHM_KEY, sizeof(pid_t), 0666|IPC_CREAT|IPC_EXCL)) != -1); int pid = fork(); CHECK(pid != -1); pid_t *grandson = shmat(shmid, (void*) 0, 0); CHECK(grandson != (void *)-1); if(!pid) { int pid1 = fork(); CHECK(pid1 != -1); if(!pid1) { CHECK(setpgid(0, 0) != -1); alarm(60); for(;;) {// printf(&quot;alive\\n&quot;);// sleep(1);// pause(); } } else { setpgid(pid1, 0); *grandson = pid1; CHECK(shmdt(grandson) != -1); _exit(0); } } else { CHECK(signal(sigs[argv[2][0] - '0'], SIG_IGN) != SIG_ERR); CHECK(wait(NULL) != (pid_t)-1); printf(&quot;grandson = %d\\n&quot;, *grandson); char argpid[128] = {0}; sprintf(argpid, &quot;%d&quot;, *grandson); ps(argpid); kill(*grandson, sigs[argv[2][0] - '0']); ps(argpid); kill(*grandson, SIGCONT); ps(argpid); kill(*grandson, SIGKILL); ps(argpid); CHECK(shmdt(grandson) != -1); CHECK(shmctl(shmid, IPC_RMID, 0) != -1); }} ä¼¼ä¹è¿˜æ²¡æˆåŠŸï¼Œè¾“å‡ºä¸€ç›´æ˜¯Rï¼ˆè¿è¡Œä¸­çš„åå°è¿›ç¨‹ç»„ï¼‰ 1234567891011/root/linux/practice34.7 e 0grandson = 31406UID PID PPID C STIME TTY STAT TIME CMDroot 31406 15886 0 16:54 pts/5 R 0:00 /root/linux/practice34.7 e 0pid=31406 received signal=21(Stopped (tty input))continueUID PID PPID C STIME TTY STAT TIME CMDroot 31406 15886 0 16:54 pts/5 R 0:00 /root/linux/practice34.7 e 0UID PID PPID C STIME TTY STAT TIME CMDroot 31406 15886 0 16:54 pts/5 R 0:00 /root/linux/practice34.7 e 0UID PID PPID C STIME TTY STAT TIME CMD å¯èƒ½å‘ç°èƒ½è°ƒç”¨handlerå°±å¯ä»¥äº†å§ï¼Ÿ","link":"/home/2023/07/10/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha34/"},{"title":"cha37.DAEMON","text":"37.1ç¼–å†™ä¸€ä¸ªä½¿ç”¨syslog(3)çš„ç¨‹åº(ä¸logger(1)ç±»ä¼¼)æ¥å°†ä»»æ„çš„æ¶ˆæ¯å†™å…¥åˆ°ç³»ç»Ÿæ—¥å¿—æ–‡ä»¶ä¸­ã€‚ç¨‹åºåº”è¯¥æ¥æ”¶åŒ…å«å¦‚è®°å½•åˆ°æ—¥å¿—ä¸­çš„æ¶ˆæ¯çš„å‘½ä»¤è¡Œå‚æ•°ï¼ŒåŒæ—¶åº”è¯¥å…è®¸æŒ‡å®šæ¶ˆæ¯çš„levelã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//// Created by root on 7/24/23.//#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;limits.h&gt;#include &lt;sys/resource.h&gt;#include &lt;syslog.h&gt;volatile int init = 0;void restart(int sig) { if(init) { closelog(); printf(&quot;restart\\n&quot;); } openlog(&quot;meow&quot;, LOG_CONS|LOG_NDELAY|LOG_PID, LOG_USER); init = 1;}#define min(x, y) ((x) &lt; (y) ? (x) : (y))#define CHECK_WITH_RET(x, ret, format, ...) \\ do { \\ if(!(x)) { \\ fprintf(stderr, format, __VA_ARGS__); \\ ret \\ } \\ } while(0)#define CHECK(x) CHECK_WITH_RET(x, return -1;, &quot;%s:%d\\nerror: %s\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__,strerror(errno), #x)#define CONDITION(x) CHECK_WITH_RET(x, exit(2);, &quot;%s:%d\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__, #x)#define CHECKMAIN(x) CHECK_WITH_RET(x, exit(1);, &quot;%s:%d\\nerror: %s\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__,strerror(errno), #x)int makeDaemon() { pid_t pid; switch ((pid = fork())) { case -1: CHECK(0); case 0: break; default: printf(&quot;pid:%ld\\n&quot;, (long)pid); _exit(0); } CHECK(setsid() != -1); CHECK(umask(0) != -1); CHECK(chroot(&quot;/&quot;) != -1); int nullfd = open(&quot;/dev/null&quot;, O_RDWR); CHECK(nullfd != -1); CHECK(dup2(nullfd, STDIN_FILENO) != -1); CHECK(dup2(nullfd, STDOUT_FILENO) != -1); CHECK(dup2(nullfd, STDERR_FILENO) != -1); CHECK(close(nullfd) != -1); long fdmax = sysconf(_SC_OPEN_MAX); struct rlimit rlimit; CHECK(getrlimit(RLIMIT_NOFILE, &amp;rlimit) != -1); for(int fdi = 0; fdi &lt; min(fdmax, rlimit.rlim_cur); fdi++) { close(fdi); } CHECK(signal(SIGHUP, restart) != SIG_ERR); return 0;}struct logmesg { int level; char *str;};int main(int argc, char **argv) { printf(&quot;pid:%ld\\n&quot;, (long)getpid()); CHECKMAIN(makeDaemon() != -1); printf(&quot;pid:%ld\\n&quot;, (long)getpid()); restart(SIGHUP); CHECKMAIN(signal(SIGHUP, restart) != SIG_ERR); CONDITION(argc &gt;= 3); struct logmesg *data = malloc(sizeof(struct logmesg)); data-&gt;level = atoi(argv[1]); CONDITION(data-&gt;level &gt;= 0 &amp;&amp; data-&gt;level &lt;= 7); int strlen = 0; for(char **argvi = &amp;argv[2]; *argvi; argvi++) { strlen += snprintf(NULL, 0, &quot;%s %s&quot;, (char *)NULL, *argvi); } char *str = malloc(strlen + 1); for(char **argvi = &amp;argv[2]; *argvi; argvi++) { strlen += sprintf(str, &quot;%s %s&quot;,str, *argvi); } data-&gt;str = str+1; syslog(data-&gt;level, &quot;%s&quot;, data-&gt;str); printf(&quot;syslog: %s\\n&quot;, data-&gt;str); closelog();} ä¸åŠä¸¢ä¸ºä»€ä¹ˆï¼Œsyslog.confä¸­é…ç½®çš„ä¸œè¥¿æ‰“å°ä¸å‡ºæ¥ 2023å¹´8æœˆ23æ—¥æ›´æ–° wslä¸‹syslogç¡®å®ä¸è¡Œï¼Œæ¢ä¸€ä¸ªç¯å¢ƒï¼Œå®‰è£…syslogåï¼Œé‡æ–°å…è®¸ï¼Œå¯ä»¥æ­£å¸¸æ‰“å°log 12Aug 23 16:13:34 localhost syslogd (GNU inetutils 1.9.4): restartAug 23 16:13:39 localhost meow[6279]: a b c","link":"/home/2023/08/01/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha37/"},{"title":"cha35.è¿›ç¨‹ä¼˜å…ˆçº§å’Œè°ƒåº¦","text":"è¯»ä¹¦ç¬”è®°niceniceå€¼å½¢è±¡çš„è¯´æ˜¯ä¸€ä¸ªè¿›ç¨‹çš„å‹å¥½ï¼ˆniceï¼‰ç¨‹åº¦ï¼Œè¶Šniceï¼ˆniceå€¼æ•°å€¼è¶Šå¤§çš„ï¼‰çš„è¿›ç¨‹è¶Šç¤¼è®©ï¼Œå¤šä¸ªä»»åŠ¡äº‰ç”¨cpuçš„æ—¶å€™è¶Šç¤¼è®©ã€‚ï¼ˆæœ¬ä¹¦ä¸­é«˜niceå€¼è¡¨ç¤ºniceå€¼æ•°å€¼æ›´ä½ï¼Œæ›´ä¸nice å–å€¼èŒƒå›´ä¸º(-20(ä¸å‹å¥½ï¼Œé«˜ä¼˜å…ˆçº§)-19(å‹å¥½ï¼Œä½ä¼˜å…ˆçº§)) forkã€execæ—¶ç»§æ‰¿niceå€¼ RLIMIT_NICEèµ„æºé™åˆ¶ï¼Œç‰¹æƒè¿›ç¨‹æœ€é«˜å¯ä»¥å°†niceå€¼æå‡åˆ°20-RLIMIT_NICE getpriority, setpriorityè·å–/è®¾ç½®niceå€¼ï¼Œgetpriorityå¯èƒ½è¿”å›è´Ÿå€¼ï¼Œè°ƒç”¨å‰å°†errnoç½®0ï¼Œè°ƒç”¨åç»“åˆerrnoåˆ¤æ–­æ˜¯å¦å¤±è´¥ å®æ—¶è°ƒåº¦è¿™é‡Œçš„å®æ—¶è°ƒåº¦å’Œæœ¬ç§‘æ—¶çš„çŸ¥è¯†æœ‰äº›å‡ºå…¥ ä¸ºå¤–éƒ¨è¾“å…¥ä¿è¯æœ€å¤§ç›¸åº”æ—¶é—´ é«˜ä¼˜å…ˆçº§è¿›ç¨‹äº’æ–¥è®¿é—®cpu å®æ—¶åº”ç”¨èƒ½ç²¾ç¡®æ§åˆ¶å…¶ç»„ä»¶è¿›ç¨‹çš„è°ƒåº¦é¡ºåº linuxå†…æ ¸2.617å¼€å§‹ï¼Œæ”¯æŒçš„ç¡¬å®æ—¶ å‡ ç§è°ƒåº¦ç­–ç•¥ ç­–ç•¥ ç‰¹æ€§ SCHED_RR å¤šçº§é˜Ÿåˆ—+æ—¶é—´ç‰‡ SCHED_FIFO å¤šçº§é˜Ÿåˆ—+å…ˆå…¥å…ˆå‡º+æ²¡æœ‰æ—¶é—´ç‰‡ SCHED_OTHER éå®æ—¶è°ƒåº¦ï¼ˆé»˜è®¤ï¼‰ SCHED_BATCH SCHED_IDLE æ„Ÿè§‰è¿™æœ¬ä¹¦æœ‰ç‚¹è€äº†ï¼Œè¿™ç¯‡æ–‡ç« çœ‹èµ·æ¥å’Œæœ¬ç§‘çš„å¾ˆæ¥è¿‘ å®æ—¶api API ä½œç”¨ sched_setscheduler è®¾ç½®pidçš„è°ƒåº¦ç­–ç•¥ï¼Œè§ä¸Šä¸€èŠ‚ sched_setparam å°†pidç§»åŠ¨åˆ°æŒ‡å®šä¼˜å…ˆçº§é˜Ÿåˆ—çš„é˜Ÿå°¾ sched_getscheduler è·å–pidçš„è°ƒåº¦ç­–ç•¥ sched_getparam è·å–pidçš„ä¼˜å…ˆçº§ sched_yield é‡Šæ”¾CPU sched_rr_get_interval è·å–rræ—¶é—´ç‰‡ cpuäº²å’ŒåŠ›å¤šcpuç³»ç»Ÿä¸­ï¼Œä¸ºäº†å‡å°‘å› è¿›ç¨‹åˆ‡æ¢cpuå¯¼è‡´çš„é«˜é€Ÿç¼“å†²å¤±æ•ˆçš„æƒ…å†µï¼Œå°†è¿›ç¨‹ç»‘å®šåˆ°ä¸€ä¸ª/ä¸€ç»„CPUä¸­ API sched_getaffinity sched_setaffinity 35.1å®ç°niceå‘½ä»¤ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//// Created by root on 7/17/23.//#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;sys/resource.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt); exit(1);}#define ERROR(...) error(__FILE__, __LINE__, __VA_ARGS__)int main(int argc, char **argv) { int prio = getpriority(PRIO_PROCESS, 0); if(argc == 1) { printf(&quot;%d\\n&quot;, prio); return 0; } int cmd = 1; int n = 10; for(; cmd &lt; argc; cmd++) { if(argv[cmd][0] == '-') { if(argv[cmd][1] == '-') { if(argv[cmd][2] == 'a') { // adjustment char *end; if((end = strchr(argv[cmd], '=')) != NULL) { n = atoi(end+1); } } else if (argv[cmd][2] == 'h') { // help printf(&quot;Usage: nice [OPTION] [COMMAND [ARG]...]\\n&quot;); } else if (argv[cmd][2] == 'v') { // version printf(&quot;Written by MeowMeow Liu.\\n&quot;); } else { ERROR(&quot;æœªçŸ¥çš„å‚æ•°:%s&quot;, argv[cmd]); } } else { n = atoi(argv[cmd]+1); } } else { break; } } if(cmd &lt; argc) { if(setpriority(PRIO_PROCESS, 0, prio + n) == -1) ERROR(&quot;setpriority&quot;); if(execvp(argv[cmd], &amp;argv[cmd]) == -1) ERROR(&quot;execv&quot;); } else { ERROR(&quot;%s: a command must be given with an adjustment&quot;, argv[0]); } return 0;} 35.2ç¼–å†™ä¸€ä¸ªä¸nice(1)å‘½ä»¤ç±»ä¼¼çš„å®æ—¶è°ƒåº¦ç¨‹åºset-user-ID-rootç¨‹åºã€‚è¿™ä¸ªç¨‹åºçš„å‘½ä»¤è¡Œç•Œé¢å¦‚ä¸‹æ‰€ç¤º: 1# ./rtsched policy priority command arg.. åœ¨ä¸Šé¢çš„å‘½ä»¤ä¸­ï¼Œpolicy ä¸­rè¡¨ç¤ºSCHED RRï¼Œfè¡¨ç¤ºSCHED FIFOã€‚åŸºäºåœ¨9.7.1èŠ‚å’Œ38.3 èŠ‚ä¸­æè¿°çš„åŸå› ï¼Œè¿™ä¸ªç¨‹åºåœ¨æ‰§è¡Œå‘½ä»¤å‰åº”è¯¥ä¸¢å¼ƒè‡ªå·±çš„ç‰¹æƒIDã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//// Created by root on 7/17/23.//#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;sys/resource.h&gt;#include &lt;sched.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt); exit(1);}#define ERROR(...) error(__FILE__, __LINE__, __VA_ARGS__)const char *pol2str(int policy) { return policy == SCHED_RR ? &quot;RR&quot; : policy == SCHED_FIFO ? &quot;FIFO\\n&quot; : #ifdef SCHED_BATCH policy == SCHED_BATCH ? &quot;BATCH&quot; : #endif #ifdef SCHED_IDLE policy == SCHED_IDLE ? &quot;IDLE&quot; : #endif policy == SCHED_OTHER ? &quot;OTHER&quot; : &quot;UNKNOWN&quot;;}int main(int argc, char **argv) { int argi = 1; if (argc &lt; 3){ printf(&quot;policy = %s\\n&quot;, pol2str(sched_getscheduler(getpid()))); printf(&quot;Usage: %s policy priority [--help] command...\\npolicy:\\n&quot; &quot;r\\tRR\\n&quot; &quot;f\\tFIFO\\n&quot;#ifdef SCHED_BATCH &quot;b\\tBATCH\\n&quot;#endif#ifdef SCHED_IDLE &quot;i\\tIDLE\\n&quot;#endif &quot;o\\tOTHER\\n&quot;, argv[0] ); return 0;} int policy = 0; switch (argv[argi][0]) { case 'r': policy = SCHED_RR; break; case 'f': policy = SCHED_FIFO; break;#ifdef SCHED_BATCH case 'b': policy = SCHED_BATCH; break;#endif#ifdef SCHED_IDLE case 'i': policy = SCHED_IDLE; break;#endif case 'o': policy = SCHED_OTHER; break; default: ERROR(&quot;unsupported policy:%s\\n&quot;, argv[argi]); break; } argi++; struct sched_param schedParam; schedParam.sched_priority = atoi(argv[argi]); argi++; if(argv[argi][0] == '-') { // --help -h ERROR(&quot;policy=%s, min=%d, max=%d&quot;, pol2str(policy), sched_get_priority_min(policy), sched_get_priority_max(policy)); argi++; } setuid(getuid()); if(sched_setscheduler(0, policy, &amp;schedParam) == -1) { ERROR(&quot;sched_setscheduler&quot;); } if(execvp(argv[argi], &amp;argv[argi]) == -1) { ERROR(&quot;execvp&quot;); } return 0;} 35.3ç¼–å†™ä¸€ä¸ªè¿è¡ŒäºSCHED FIFOè°ƒåº¦ç­–ç•¥ä¸‹çš„ç¨‹åºï¼Œç„¶ååˆ›å»ºä¸€ä¸ªå­è¿›ç¨‹ã€‚åœ¨ä¸¤ä¸ªè¿›ç¨‹ä¸­éƒ½æ‰§è¡Œä¸€ä¸ªèƒ½å¯¼è‡´è¿›ç¨‹æœ€å¤šæ¶ˆè€—3ç§’CPUæ—¶é—´çš„å‡½æ•°ã€‚(è¿™å¯ä»¥é€šè¿‡ä½¿ç”¨ä¸€ä¸ªå¾ªç¯å¹¶åœ¨å¾ªç¯ä¸­ä¸æ–­ä½¿ç”¨ times()ç³»ç»Ÿè°ƒç”¨æ¥ç¡®å®šç´¯ç§¯æ¶ˆè€—çš„CPUæ—¶é—´æ¥å®Œæˆã€‚æ¯å½“æ¶ˆè€—äº† 1/4ç§’çš„CPUæ—¶é—´ä¹‹åï¼Œå‡½æ•°åº”è¯¥æ‰“å°å‡ºä¸€æ¡æ˜¾ç¤ºè¿›ç¨‹IDå’Œè¿„ä»Šæ¶ˆè€—çš„CPUæ—¶é—´çš„æ¶ˆæ¯ã€‚æ¯å½“æ¶ˆè€—äº†1ç§’çš„CPU æ—¶é—´ä¹‹åï¼Œå‡½æ•°åº”è¯¥è°ƒç”¨sched yield0æ¥å°†CPUé‡Šæ”¾ç»™å…¶ä»–è¿›ç¨‹å¦ä¸€ç§æ–¹æ³•æ˜¯è¿›ç¨‹ä½¿ç”¨sched setparam(æå‡å¯¹æ–¹çš„è°ƒåº¦ç­–ç•¥ã€‚)ä»ç¨‹åºçš„è¾“å‡ºä¸­åº”è¯¥èƒ½å¤Ÿçœ‹å‡ºä¸¤ä¸ªè¿›ç¨‹äº¤æ›¿æ¶ˆè€—äº†1ç§’çš„CPUæ—¶é—´ã€‚(æ³¨æ„åœ¨35.3.2èŠ‚ä¸­ç»™å‡ºçš„æœ‰å…³é˜²æ­¢å¤±æ§å®æ—¶è¿›ç¨‹å ä½CPUçš„å»ºè®®ã€‚) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;sched.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;sys/times.h&gt;#include &lt;stdlib.h&gt;#include &lt;limits.h&gt;#include &lt;signal.h&gt;#include &lt;time.h&gt;#include &lt;sys/wait.h&gt;#define CHECK(x) do { if(!(x)) { fprintf(stderr, &quot;%s:%d\\nerror: %s\\n&quot;, __FILE__, __LINE__, strerror(errno)); } } while(0)void handler(int sig) { printf(&quot;PID:%d received signal:%d(%s)\\n&quot;, getpid(), sig, strsignal(sig)); exit(0);}int main() { CHECK(signal(SIGALRM, handler) != SIG_ERR); timer_t timerid; CHECK(sched_setscheduler(0, SCHED_FIFO, &amp;(struct sched_param){.sched_priority=sched_get_priority_max(SCHED_FIFO)}) != -1); long tck = sysconf (_SC_CLK_TCK) &gt;&gt; 2; pid_t pid; CHECK((pid = fork()) != -1); struct tms *cputm, *oldtm; cputm = malloc(sizeof(struct tms)); oldtm = malloc(sizeof(struct tms)); CHECK(times(oldtm) != (clock_t) -1); CHECK(timer_create(CLOCK_PROCESS_CPUTIME_ID, &amp;(struct sigevent) { .sigev_signo=SIGALRM, .sigev_notify=SIGEV_SIGNAL }, &amp;timerid) != -1); CHECK(timer_settime(timerid, 0, &amp;(struct itimerspec) { .it_interval = {.tv_nsec = 0,.tv_sec = 0}, .it_value = {.tv_sec = 13,.tv_nsec = 0} }, NULL) != -1); for(long i = 0; i &lt; 12;) { CHECK(times(cputm) != (clock_t) -1); long inc = ((cputm-&gt;tms_utime + cputm-&gt;tms_stime) - (oldtm-&gt;tms_utime + oldtm-&gt;tms_stime)) / tck; if(inc &gt;= 1) { struct tms *t = cputm; cputm = oldtm; oldtm = t; i += inc; fprintf(stderr, &quot;PID=%d, CPU=%.2lfs\\n&quot;, getpid(), i/4.0); } if(i % 4 == 0) { CHECK(sched_yield() != -1); } } CHECK(timer_settime(timerid, 0, &amp;(struct itimerspec) { .it_interval = {.tv_nsec = 0,.tv_sec = 0}, .it_value = {.tv_sec = 0,.tv_nsec = 0} }, NULL) != -1); CHECK(timer_delete(timerid) != -1); if(!pid) CHECK(wait(NULL) != -1); return 0;} 35.4å¦‚æœä¸¤ä¸ªè¿›ç¨‹åœ¨ä¸€ä¸ªå¤šå¤„ç†å™¨ç³»ç»Ÿä¸Šä½¿ç”¨ç®¡é“æ¥äº¤æ¢å¤§é‡æ•°æ®ï¼Œé‚£ä¹ˆä¸¤ä¸ªè¿›ç¨‹è¿è¡Œåœ¨åŒä¸€ä¸ªCPUä¸Šçš„é€šä¿¡é€Ÿåº¦åº”è¯¥è¦å¿«äºä¸¤ä¸ªè¿›ç¨‹è¿è¡Œåœ¨ä¸åŒçš„CPUä¸Šå…¶åŸå› æ˜¯å½“ä¸¤ä¸ªè¿›ç¨‹è¿è¡Œåœ¨åŒä¸€ä¸ª CPU ä¸Šæ—¶èƒ½å¤Ÿå¿«é€Ÿåœ°è®¿é—®ç®¡é“æ•°æ®ï¼Œå› ä¸ºç®¡é“æ•°æ®å¯ä»¥ä¿ç•™åœ¨ CPUçš„é«˜é€Ÿç¼“å†²å™¨ä¸­ã€‚ç›¸åï¼Œå½“ä¸¤ä¸ªè¿›ç¨‹è¿è¡Œåœ¨ä¸åŒçš„CPUä¸Šæ—¶å°†æ— æ³•äº«å—CPUé«˜é€Ÿç¼“å†²å™¨å¸¦æ¥çš„ä¼˜åŠ¿ã€‚è¯»è€…å¦‚æœæ‹¥æœ‰å¤šå¤„ç†å™¨ç³»ç»Ÿå¯ä»¥ç¼–å†™ä¸€ä¸ªä½¿ç”¨sched setaffinity0å¼ºåˆ¶å°†ä¸¤ä¸ªè¿›ç¨‹è¿è¡Œåœ¨åŒä¸€ä¸ªCPUä¸Šæˆ–è¿è¡Œåœ¨ä¸¤ä¸ªä¸åŒçš„CPUä¸Šçš„ç¨‹åºæ¥æ¼”ç¤ºè¿™ç§æ•ˆæœã€‚(ç¬¬44 ç« æè¿°äº†ç®¡é“çš„ä½¿ç”¨ã€‚) 12345678910111213141516171819202122232425262728293031//// Created by root on 7/17/23.//#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sched.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#define CHECK(x,...) do { if(!(x)) { fprintf(stderr, &quot;%s:%d\\n&quot;, __FILE__, __LINE__); fprintf(stderr, __VA_ARGS__); exit(2); } } while(0)#define CHECKERR(x) do { if(!(x)) { fprintf(stderr, &quot;%s:%d\\nerror: %s\\n&quot;, __FILE__, __LINE__, strerror(errno)); exit(1); } } while(0)int main(int argc, char **argv) { char buffer[4096]; CHECK(argc == 2, &quot;Usage:%s cpuid\\n&quot;, argv[0]); int cpuid = atoi(argv[1]); cpu_set_t *set = malloc(sizeof(cpu_set_t)); CPU_ZERO(set); CPU_SET(cpuid, set); CHECKERR(sched_setaffinity(0, 1, set) != -1); ssize_t readsize; while((readsize = read(STDIN_FILENO, buffer, 4096)) &gt; 0) { CHECKERR(write(STDOUT_FILENO, buffer, readsize) == readsize); } CHECKERR(readsize == 0); free(set); return 0;} æµ‹è¯•12time `find / | ./practice35.4 1 | ./practice35.4 1`time `find / | ./practice35.4 2 | ./practice35.4 3` ç»è¿‡å‡ æ¬¡æµ‹è¯•ï¼Œç¡®å®åŒä¸€ä¸ªcpuä¼šå¿«ä¸€ç‚¹","link":"/home/2023/07/17/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha35/"},{"title":"cha38.ç¼–å†™å®‰å…¨çš„ç‰¹æƒç¨‹åº","text":"38.1ç”¨ä¸€ä¸ªæ™®é€šçš„éç‰¹æƒç”¨æˆ·ç™»å½•ç³»ç»Ÿï¼Œåˆ›å»ºä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶(æˆ–å¤åˆ¶ä¸€ä¸ªæ—¢æœ‰æ–‡ä»¶å¦‚/bin/sleep)ï¼Œç„¶åå¯ç”¨è¯¥æ–‡ä»¶çš„set-user-IDæƒé™ä½(chmod u+s)ã€‚å°è¯•ä¿®æ”¹è¿™ä¸ªæ–‡ä»¶(å¦‚cat &gt;&gt;fle)ã€‚å½“ä½¿ç”¨(ls -l)æ—¶æ–‡ä»¶çš„æƒé™ä¼šå‘ç”Ÿä»€ä¹ˆæƒ…å†µå‘¢?ä¸ºä½•ä¼šå‘ç”Ÿè¿™ç§æƒ…å†µ? ç°è±¡ï¼šsaved-user-idä¸è§äº†åŸå› ï¼šé€šè¿‡ä¸‹é¢çš„ä¾‹å­ï¼ŒçŒœæµ‹openæ—¶ä¼šæ¸…é™¤set-usr-idæ ‡å¿—ä½ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//// Created by root on 8/1/23.//#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;static int exitcode = 0;#define ERR(str...) do { fprintf(stderr, &quot;%s:%d\\n%s:&quot;, __FILE__, __LINE__, strerror(errno)); fprintf(stderr, str); fprintf(stderr, &quot;\\n&quot;); exit(exitcode++); } while(0)int main(int argc, char **argv) { if(argc &lt; 3) { ERR(&quot;Usage: %s src dst [content..]&quot;, argv[0]); } char *file1 = argv[1]; char *file2 = argv[2]; int fd1 = open(file1, O_RDONLY); if(fd1 == -1) { ERR(&quot;file to open %s&quot;, file1); } struct stat stat1; if(fstat(fd1, &amp;stat1) == -1) { ERR(&quot;fstat(fd1, &amp;stat1)&quot;); } fprintf(stderr, &quot;F_GETFL:%o\\n&quot;, stat1.st_mode); int fd2 = open(file2, O_WRONLY | O_CREAT, stat1.st_mode); if(fd2 == -1) { ERR(&quot;fail to open %s&quot;, file2); } char buffer[4096] = {0}; ssize_t readsize = 0; while ((readsize = read(fd1, buffer, 4096)) &gt; 0) { ssize_t writesize = write(fd2, buffer, readsize); if(writesize != readsize) { ERR(&quot;fail to write %s&quot;, file2); } } if(readsize &lt; 0) { ERR(&quot;fail to read %s&quot;, file1); } for(int i = 3; i &lt; argc; i++) { size_t len = strlen(argv[i]); if(write(fd2, argv[i], len) != len) { ERR(&quot;fail to write %s&quot;, file2); } } return 0;} 38.2ç¼–å†™ä¸€ä¸ªä¸ sudo(8)ç¨‹åºç±»ä¼¼çš„ set-user-ID-root ç¨‹åºã€‚è¿™ä¸ªç¨‹åºåº”è¯¥åƒä¸‹é¢è¿™æ ·æ¥æ”¶å‘½ä»¤è¡Œé€‰é¡¹å’Œå‚æ•°: 1$ ./douser[ -u user ] program-file arg1 arg2 douserç¨‹åºä½¿ç”¨ç»™å®šçš„å‚æ•°æ‰§è¡Œ program-fileï¼Œå°±åƒæ˜¯è¢«user è¿è¡Œä¸€æ ·ã€‚(å¦‚æœçœç•¥äº†-ué€‰é¡¹ï¼Œé‚£ä¹ˆuser é»˜è®¤ä¸ºrootã€‚)åœ¨æ‰§è¡Œ program-fileä¹‹å‰ï¼Œdouser åº”è¯¥è¯·æ±‚ useçš„å¯†ç å¹¶å°†å¯†ç ä¸æ ‡å‡†å¯†ç æ–‡ä»¶è¿›è¡Œæ¯”è¾ƒ(å‚è§ç¨‹åºæ¸…å•8-2)ï¼Œæ¥ç€å°†è¿›ç¨‹çš„ç”¨æˆ·å’Œç»„IDè®¾ç½®ä¸ºä¸è¯¥ç”¨æˆ·å¯¹åº”çš„å€¼ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//// Created by root on 8/2/23.//#include &lt;unistd.h&gt;#include &lt;pwd.h&gt;#include &lt;crypt.h&gt;#include &lt;shadow.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#define COND_RET(x, ret, msg...) \\ do { \\ errno = 0;\\ if(!(x)) { \\ if(errno == 0)fprintf(stderr, &quot;%s:%d\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__, #x); \\ else fprintf(stderr, &quot;%s:%d\\nerror: %s\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__,strerror(errno), #x); \\ fprintf(stderr, msg); \\ fprintf(stderr, &quot;\\n&quot;);\\ ret \\ } \\ } while(0)#define CHECK(x, msg...) COND_RET(x, return -1;, msg)#define CHECK_EXIT(x, msg...) COND_RET(x, exit(1);, msg)int main(int argc, char *argv[]) { char *filename = strrchr(argv[0], '/'); if(filename == NULL) { filename = argv[0]; } else { filename++; } if(!strcmp(filename, &quot;sudo&quot;)) { CHECK_EXIT(argc &gt;= 2, &quot;Usage: %s [-u user] exec [args...]&quot;, argv[0]); uid_t user = 0; char *username = &quot;root&quot;; char **exec = &amp;argv[1]; char *shadow = NULL; if (argv[1][0] == '-') { username = argv[2]; exec = &amp;argv[3]; } struct passwd *usrpwd; CHECK_EXIT((usrpwd = getpwnam(username)) != NULL, &quot;username:%s not found&quot;, username); user = usrpwd-&gt;pw_uid; shadow = usrpwd-&gt;pw_passwd; printf(&quot;shaowd=%s\\n&quot;, shadow); char *pass = getpass(&quot;password:&quot;); CHECK_EXIT(setuid(0) != -1, &quot;execute 'su; sudo chmod u+s %s' may fix this problem&quot;, argv[0]); if(!strcmp(shadow, &quot;x&quot;)) { struct spwd *shadowpwd; CHECK_EXIT((shadowpwd = getspnam(username)) != NULL, &quot;shadowpwd not found&quot;); shadow = shadowpwd-&gt;sp_pwdp; pass = crypt(pass, shadow); } printf(&quot;shaowd=%s, pass=%s\\n&quot;, shadow, pass); CHECK_EXIT(!strcmp(shadow, pass), &quot;password not match!&quot;); CHECK_EXIT(setuid(user) != -1, &quot;&quot;); CHECK_EXIT(execvp(exec[0], exec) != -1, &quot;&quot;); } else { struct passwd *pwd = NULL; uid_t uid = 0; if(argc &gt; 1) { char *end = NULL; uid = strtoul(argv[1], &amp;end, 10); CHECK_EXIT((end != NULL &amp;&amp; end != argv[1]), &quot;%s is not a number\\n&quot;, argv[1]); } else { uid = getuid(); } CHECK_EXIT((pwd = getpwuid(uid)) != NULL, &quot;uid:%u not found&quot;, uid); printf(&quot;uid:%u, user:%s\\n&quot;, pwd-&gt;pw_uid, pwd-&gt;pw_name); } return 0;} å¤ªç¬¨äº†ï¼Œä»¥å‰å­¦çš„éƒ½å¿˜äº†","link":"/home/2023/08/01/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha38/"},{"title":"cha4.æ–‡ä»¶IO:é€šç”¨çš„I&#x2F;Oæ¨¡å‹","text":"å®ç°tee teeå‘½ä»¤æ˜¯ä»æ ‡å‡†è¾“å…¥ä¸­è¯»å–æ•°æ®ï¼Œç›´è‡³æ–‡ä»¶ç»“å°¾ï¼Œéšåå°†æ•°æ®å†™å…¥æ ‡å‡†è¾“å‡ºå’Œå‘½ä»¤è¡Œå‚æ•°æ‰€æŒ‡å®šçš„æ–‡ä»¶ã€‚(44.7èŠ‚è®¨è®ºFIFOæ—¶ï¼Œä¼šå±•ç¤ºä½¿ç”¨teeå‘½ä»¤çš„ä¸€ä¸ªä¾‹å­ã€‚)è¯·ä½¿ç”¨IOç³»ç»Ÿè°ƒç”¨å®ç°teeå‘½ä»¤ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œè‹¥å·²å­˜åœ¨ä¸å‘½ä»¤è¡Œå‚æ•°æŒ‡å®šæ–‡ä»¶åŒåçš„æ–‡ä»¶ï¼Œteeå‘½ä»¤ä¼šå°†å…¶è¦†ç›–ã€‚å¦‚æ–‡ä»¶å·²å­˜åœ¨ï¼Œè¯·å®ç°-aå‘½ä»¤è¡Œé€‰é¡¹tee-a fileåœ¨æ–‡ä»¶ç»“å°¾å¤„è¿½åŠ æ•°æ®ã€‚(è¯·å‚è€ƒé™„å½•Bä¸­å¯¹getopt)å‡½æ•°çš„æè¿°æ¥è§£æå‘½ä»¤è¡Œé€‰é¡¹ã€‚ é¢„å¤„ç†ä¸å‡½æ•°å£°æ˜12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include&lt;errno.h&gt; // ä½¿ç”¨å˜é‡errno#define bool char#define false 0#define true 1#define strcmp(a,b) strcmp(a,b)==0// exit code#define UNSUPPORTED_ARG 1#define FILE_OPEN_FAIL 2#define STDOUT_WRITE_FAIL 3#define STDERR_WRITE_FAIL 4#define STDIN_READ_FAIL 5#define PARTIAL_WRITE_OCCURED 6#define FILE_CLOSE_FAIL 7#define FILE_WRITE_FAIL 8// å‡½æ•°å£°æ˜void printHelp();void printVersion();void writeErr(const char* str);void writeStdout(const char* str);void exitErr(const char * err, int exitcode);void release();// å¸¸é‡#define MAX_FILE_COUNT 100#define READ_BUFFER_SIZE 100// å…¨å±€èµ„æºchar **files = NULL;int *fds = NULL;int fileCount = 0; ä¸å¼•ç”¨cçš„åº“å‡½æ•°ï¼Œç›´æ¥ä½¿ç”¨ç³»ç»Ÿè°ƒç”¨å¯¹æ–‡ä»¶è¿›è¡Œè¯»å†™ï¼Œä¸å¼•å…¥stdio.h å·¥å…·å‡½æ•°123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void release() { // å…³é—­æ–‡ä»¶ for(int i = 0; i &lt; fileCount; i++) { errno = 0; int success = close(fds[i]); if(success == -1) { exitErr(strcat(&quot;can not close file: &quot;, files[i]), FILE_CLOSE_FAIL); } } free(files); free(fds);}void printHelp() { writeStdout(&quot;Usage: tee [-ai][--help][--version][files...]\\n&quot;);}void printVersion() { writeStdout(&quot;Written by Jingtian Meow\\n&quot;);}void exitErr(const char * err, int exitcode) { char *errstr = strerror(errno); writeErr(&quot;Error: &quot;); writeErr(errstr); writeErr(&quot;\\n&quot;); writeErr(err); writeErr(&quot;\\n&quot;); release(); exit(exitcode);}void writeStdout(const char* str) { errno = 0; int writeSize = write(STDOUT_FILENO, str, strlen(str)); if(writeSize == -1) { exitErr(&quot;fail to write to stdout\\n&quot;, STDOUT_WRITE_FAIL); }}void writeErr(const char* str) { errno = 0; int writeSize = write(STDERR_FILENO, str, strlen(str)); if(writeSize == -1) { release(); exit(STDERR_WRITE_FAIL); }} å®ç°é”™è¯¯æ‰“å°ï¼Œæ­£å¸¸è¾“å‡º å¯¹äºé”™è¯¯ï¼Œåˆ©ç”¨ç³»ç»Ÿè°ƒç”¨writeï¼Œå†™å…¥æ–‡ä»¶fdSTDERR_FILENOæŒ‡ä»£çš„æ ‡å‡†é”™è¯¯æµä¸­ ä½¿ç”¨errnoå®å’Œstrerrorè·å–å‡ºé”™åçš„é”™è¯¯å­—ç¬¦ä¸²ï¼Œå¹¶æ‰“å°å…¶ä»–æç¤ºä¿¡æ¯ å®ç°èµ„æºé‡Šæ”¾ èµ„æºåˆ†é…1234// ä¿å­˜æ–‡ä»¶åï¼Œæ‰“å¼€æ–‡ä»¶çš„fdï¼Œæ–‡ä»¶æ€»æ•°files = (char **)malloc(MAX_FILE_COUNT*sizeof(char *));fds = (int *)malloc(MAX_FILE_COUNT*sizeof(int));fileCount = 0; å‚æ•°å¤„ç†123456789101112131415161718192021222324252627282930313233int main(int argc, char **argv) { // å‚æ•°å¤„ç†ç»“æœ bool append = false; bool ignore_int = false; // å¤„ç†å‚æ•° for(int i = 1; i &lt; argc; i++) { if(argv[i][0] == '-') { if(strcmp(argv[i], &quot;-a&quot;)) { append = true; } else if(strcmp(argv[i], &quot;-i&quot;) || strcmp(argv[i], &quot;--ignore-interrupts&quot;)) { ignore_int = true; } else if(strcmp(argv[i], &quot;-ai&quot;) || strcmp(argv[i], &quot;-ia&quot;) ) { append = true; ignore_int = true; } else if(strcmp(argv[i], &quot;--help&quot;)) { printHelp(); } else if(strcmp(argv[i], &quot;--version&quot;)) { printVersion(); } else { writeErr(&quot;Unsupported arg: &quot;); writeErr(argv[i]); writeErr(&quot;\\n&quot;); free(files); free(fds); exit(UNSUPPORTED_ARG); } } else { if(fileCount &lt; MAX_FILE_COUNT-1) files[fileCount++] = argv[i]; } } // other part of code} æ”¯æŒå‚æ•°-a, --help, --versionï¼Œå¤„ç†ç»“æœä¿å­˜è‡³appendå’Œignore_int å¯¹äºä¸æ˜¯ä»¥-å¼€å¤´çš„å‚æ•°ï¼Œè®¤ä¸ºå…¶æ˜¯æ–‡ä»¶åï¼Œå­˜å‚¨åˆ°files æ‰“å¼€æ–‡ä»¶1234567// æ‰“å¼€æ–‡ä»¶ï¼Œä¿å­˜fdfor(int i = 0; i &lt; fileCount; i++) { fds[i] = open(files[i], O_CREAT | O_WRONLY | (append == true ? O_APPEND : O_TRUNC)); if(fds[i] == -1) { exitErr(strcat(&quot;Can not open file: &quot;, argv[i]), FILE_OPEN_FAIL); }} å°†filesä¸­çš„æ–‡ä»¶æ‰“å¼€ï¼Œå­˜å‚¨å…¶fd è¯»å–stdinï¼Œå†™å…¥æ–‡ä»¶123456789101112131415161718192021222324// è¯»å–stdinssize_t readSize = 0;char readBuffer[READ_BUFFER_SIZE+1]; // éœ€è¦æ‰‹åŠ¨æ·»åŠ '\\0'ï¼Œ æ•…+1while(1) { errno = 0; readSize = read(STDIN_FILENO, readBuffer, READ_BUFFER_SIZE); if(readSize == -1) { exitErr(&quot;read stdin fail&quot;, STDIN_READ_FAIL); } if(readSize == 0) { //EOF break; } readBuffer[readSize] = '\\0'; //é˜²æ­¢å†™å…¥è„æ•°æ®ï¼Œä½†æ˜¯writeæ—¶æœ‰readSizeé™åˆ¶ï¼Œæ‰€ä»¥æ²¡å¿…è¦ for(int i = 0; i &lt; fileCount; i++) { errno = 0; ssize_t writeSize = write(fds[i], readBuffer, readSize); if(writeSize == -1) { //å…ˆåˆ¤æ–­-1 exitErr(strcat(&quot;file write failed on file: &quot;, files[i]), FILE_WRITE_FAIL); } if(writeSize &lt; readSize) { // éƒ¨åˆ†å†™ exitErr(strcat(&quot;Partial write occured on file: &quot;, files[i]), PARTIAL_WRITE_OCCURED); } }} å¾ªç¯è¯»å–æ–‡ä»¶ï¼Œåˆ©ç”¨ç³»ç»Ÿè°ƒç”¨readï¼Œè‹¥å…¶è¿”å›0ï¼Œåˆ™æ˜¯é‡åˆ°eofï¼Œè·³å‡ºå¾ªç¯ï¼Œè‹¥è¿”å›-1ï¼Œåˆ™è¯»å–é”™è¯¯ï¼Œå¼‚å¸¸é€€å‡º è¯»å–æ—¶æ³¨æ„è¯¥ç³»ç»Ÿè°ƒç”¨ä¸è®¤ä¸ºè¯»å–çš„æ–‡ä»¶ä¸€å®šæ˜¯æ–‡æœ¬æ–‡ä»¶ï¼Œä¸ä¼šå°†å…¶å¤„ç†æˆå­—ç¬¦ä¸²ï¼Œå³åœ¨æœ«å°¾æ·»åŠ '\\0'ï¼Œéœ€è¦æ‰‹åŠ¨æ·»åŠ  ä»stdinè¯»å–åï¼Œä¸€æ¬¡å†™å…¥å¾…å†™å…¥çš„æ–‡ä»¶ä¸­ï¼Œå¹¶åˆ¤æ–­æ˜¯å¦æˆåŠŸï¼Œæ˜¯å¦å‘ç”Ÿéƒ¨åˆ†å†™ æ”¶å°¾1release(); å®Œæ•´ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include&lt;errno.h&gt; // ä½¿ç”¨å˜é‡errno#define bool char#define false 0#define true 1#define strcmp(a,b) strcmp(a,b)==0// exit code#define UNSUPPORTED_ARG 1#define FILE_OPEN_FAIL 2#define STDOUT_WRITE_FAIL 3#define STDERR_WRITE_FAIL 4#define STDIN_READ_FAIL 5#define PARTIAL_WRITE_OCCURED 6#define FILE_CLOSE_FAIL 7#define FILE_WRITE_FAIL 8// å‡½æ•°å£°æ˜void printHelp();void printVersion();void writeErr(const char* str);void writeStdout(const char* str);void exitErr(const char * err, int exitcode);void release();// å¸¸é‡#define MAX_FILE_COUNT 100#define READ_BUFFER_SIZE 100char **files = NULL;int *fds = NULL;int fileCount = 0;int main(int argc, char **argv) { // å‚æ•°å¤„ç†ç»“æœ bool append = false; bool ignore_int = false; // ä¿å­˜æ–‡ä»¶åï¼Œæ‰“å¼€æ–‡ä»¶çš„fdï¼Œæ–‡ä»¶æ€»æ•° files = (char **)malloc(MAX_FILE_COUNT*sizeof(char *)); fds = (int *)malloc(MAX_FILE_COUNT*sizeof(int)); fileCount = 0; // å¤„ç†å‚æ•° for(int i = 1; i &lt; argc; i++) { if(argv[i][0] == '-') { if(strcmp(argv[i], &quot;-a&quot;)) { append = true; } else if(strcmp(argv[i], &quot;-i&quot;) || strcmp(argv[i], &quot;--ignore-interrupts&quot;)) { ignore_int = true; } else if(strcmp(argv[i], &quot;-ai&quot;) || strcmp(argv[i], &quot;-ia&quot;) ) { append = true; ignore_int = true; } else if(strcmp(argv[i], &quot;--help&quot;)) { printHelp(); } else if(strcmp(argv[i], &quot;--version&quot;)) { printVersion(); } else { writeErr(&quot;Unsupported arg: &quot;); writeErr(argv[i]); writeErr(&quot;\\n&quot;); free(files); free(fds); exit(UNSUPPORTED_ARG); } } else { if(fileCount &lt; MAX_FILE_COUNT-1) files[fileCount++] = argv[i]; } } // æ‰“å¼€æ–‡ä»¶ï¼Œä¿å­˜fd for(int i = 0; i &lt; fileCount; i++) { fds[i] = open(files[i], O_CREAT | O_WRONLY | (append == true ? O_APPEND : O_TRUNC)); if(fds[i] == -1) { exitErr(strcat(&quot;Can not open file: &quot;, argv[i]), FILE_OPEN_FAIL); } } // è¯»å–stdin ssize_t readSize = 0; char readBuffer[READ_BUFFER_SIZE+1]; // éœ€è¦æ‰‹åŠ¨æ·»åŠ '\\0'ï¼Œ æ•…+1 while(1) { errno = 0; readSize = read(STDIN_FILENO, readBuffer, READ_BUFFER_SIZE); if(readSize == -1) { exitErr(&quot;read stdin fail&quot;, STDIN_READ_FAIL); } if(readSize == 0) { //EOF break; } readBuffer[readSize] = '\\0'; //é˜²æ­¢å†™å…¥è„æ•°æ®ï¼Œä½†æ˜¯writeæ—¶æœ‰readSizeé™åˆ¶ï¼Œæ‰€ä»¥æ²¡å¿…è¦ for(int i = 0; i &lt; fileCount; i++) { errno = 0; ssize_t writeSize = write(fds[i], readBuffer, readSize); if(writeSize == -1) { //å…ˆåˆ¤æ–­-1 exitErr(strcat(&quot;file write failed on file: &quot;, files[i]), FILE_WRITE_FAIL); } if(writeSize &lt; readSize) { // éƒ¨åˆ†å†™ exitErr(strcat(&quot;Partial write occured on file: &quot;, files[i]), PARTIAL_WRITE_OCCURED); } } } release(); return 0;}void release() { // å…³é—­æ–‡ä»¶ for(int i = 0; i &lt; fileCount; i++) { errno = 0; int success = close(fds[i]); if(success == -1) { exitErr(strcat(&quot;can not close file: &quot;, files[i]), FILE_CLOSE_FAIL); } } free(files); free(fds);}void printHelp() { writeStdout(&quot;Usage: tee [-ai][--help][--version][files...]\\n&quot;);}void printVersion() { writeStdout(&quot;Written by Jingtian Meow\\n&quot;);}void exitErr(const char * err, int exitcode) { char *errstr = strerror(errno); writeErr(&quot;Error: &quot;); writeErr(errstr); writeErr(&quot;\\n&quot;); writeErr(err); writeErr(&quot;\\n&quot;); release(); exit(exitcode);}void writeStdout(const char* str) { errno = 0; int writeSize = write(STDOUT_FILENO, str, strlen(str)); if(writeSize == -1) { exitErr(&quot;fail to write to stdout\\n&quot;, STDOUT_WRITE_FAIL); }}void writeErr(const char* str) { errno = 0; int writeSize = write(STDERR_FILENO, str, strlen(str)); if(writeSize == -1) { release(); exit(STDERR_WRITE_FAIL); }} å®ç°cp ç¼–å†™ä¸€ä¸ªç±»ä¼¼äºcpå‘½ä»¤çš„ç¨‹åºï¼Œå½“ä½¿ç”¨è¯¥ç¨‹åºå¤åˆ¶ä¸€ä¸ªåŒ…å«ç©ºæ´(è¿ç»­çš„ç©ºå­—èŠ‚)çš„æ™®é€šæ–‡ä»¶æ—¶ï¼Œè¦æ±‚ç›®æ ‡æ–‡ä»¶çš„ç©ºæ´ä¸æºæ–‡ä»¶ä¿æŒä¸€è‡´ã€‚ è¿™é“é¢˜èµ°äº†ä¸€ç‚¹å¼¯è·¯ï¼Œä¸€ç›´åœ¨æ¢ç´¢å¦‚ä½•ä¿å­˜æ–‡ä»¶ç©ºæ´ï¼Œä¸èƒ½å’Œä¸Šé¢ç¨‹åºä¸€æ · ç”±äºç©ºæ´æ˜¯ç¨‹åºåœ¨æ–‡ä»¶ç»“å°¾å¤„lseekäº†ä¸€æ®µå¤§äºç£ç›˜blocksizeçš„è·ç¦»åç»§ç»­å†™å…¥é€ æˆçš„ï¼Œé‚£ä¹ˆéœ€è¦ä¸å…¶è¿›è¡Œç›¸åŒçš„lseekæ“ä½œ å¦‚æœè¯»å–å‡ºçš„å†…å®¹å…¨éƒ¨ä¸º0ï¼Œåˆ™è®°å½•å…¨ä¸º0çš„é•¿åº¦ï¼Œç›´åˆ°è¯»å–å‡ºä¸å…¨ä¸º0çš„æ—¶å€™ï¼Œå…ˆlseekï¼Œå†å†™å…¥ éœ€è¦ä¿è¯bufferçš„å¤§å°å°äºblocksize åˆ›å»ºæ–‡ä»¶ç©ºæ´12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#define BLOCKSIZE 4096void writeContent(int fd, const char * content);int main(int argc, char **argv) { int fd = argc &gt;= 2 ? open(argv[1], O_WRONLY | O_CREAT) : STDOUT_FILENO; int fd1 = argc &gt;= 2 ? open(strcat(argv[1],&quot;.normal&quot;), O_WRONLY | O_CREAT) : STDOUT_FILENO; int holeNum = argc == 3 ? atoi(argv[2]) : 1; if(fd == -1) { return 1; } char *content; char blank[BLOCKSIZE*2] = {0}; memset(blank, ' ', sizeof(blank)); blank[BLOCKSIZE*2-1] = 0; for(int i = 0; i &lt; holeNum; i++) { content = &quot;Content before the file hole!!!!!\\n&quot;; writeContent(fd, content); writeContent(fd1, content); // make a hole lseek(fd, BLOCKSIZE*2, SEEK_CUR); writeContent(fd1, blank); content = &quot;Content after the file hole!!!!!\\n&quot;; writeContent(fd, content); writeContent(fd1, content); } if(close(fd) == -1) { exit(4); } if(close(fd1) == -1) { exit(4); } return 0;}void writeContent(int fd, const char * content) { size_t contentLen = strlen(content) + 1; int writeSize = write(fd, content, contentLen); if(writeSize == -1 || writeSize &lt; contentLen) { exit(2); }} æ‰“å¼€ä¸¤ä¸ªæ–‡ä»¶ç”¨ä½œå¯¹æ¯”ï¼Œfdé€šè¿‡lseekåˆ¶é€ ç©ºæ´ï¼Œfd1å†™å…¥ç›¸åŒå¤§å°çš„ç©ºæ ¼ ä½¿ç”¨å‘½ä»¤statæ¯”è¾ƒç”Ÿæˆçš„ä¸¤ä¸ªæ–‡ä»¶12root@tt-surfacepro6:~/linux# stat -c %b abc16 abcçš„å—æ•°æ˜¯16 12root@tt-surfacepro6:~/linux# stat -c %b abc.normal 24 abc.normalçš„å—æ•°çš„24 é¢„å¤„ç†1234567891011121314151617181920212223242526272829303132333435363738#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include&lt;errno.h&gt;// #define debug#ifdef debug#include&lt;stdio.h&gt;#endif#define bool char#define false 0#define true 1#define strcmp(a,b) strcmp(a,b)==0// exit code#define UNSUPPORTED_ARG 1#define FILE_OPEN_FAIL 2#define STDOUT_WRITE_FAIL 3#define STDERR_WRITE_FAIL 4#define STDIN_READ_FAIL 5#define PARTIAL_WRITE_OCCURED 6#define FILE_CLOSE_FAIL 7#define FILE_WRITE_FAIL 8#define FILE_READ_FAIL 10#define INVALID_ARG 9// å‡½æ•°å£°æ˜void printHelp();void printVersion();void writeErr(const char* str);void writeStdout(const char* str);void fileErrClose(const char * filename, const char *err, int exitCode); #define READ_BUFF_SIZE 1023 å·¥å…·å‡½æ•°123456789101112131415161718192021222324252627282930313233343536373839void fileErrClose(const char * filename, const char *err, int exitCode) { const char *errstr = strerror(errno); writeErr(&quot;Error: &quot;); writeErr(errstr); writeErr(&quot;\\n&quot;); writeErr(err); writeErr(filename); writeErr(&quot;\\n&quot;); exit(exitCode);}void printHelp() { writeStdout(&quot;Usage: cp [--help][--version][src dest]\\n&quot;);}void printVersion() { writeStdout(&quot;Written by Jingtian Meow\\n&quot;);}void writeStdout(const char* str) { errno = 0; int writeSize = write(STDOUT_FILENO, str, strlen(str)); if(writeSize == -1) { char *errstr = strerror(errno); writeErr(&quot;Error: &quot;); writeErr(errstr); writeErr(&quot;\\n&quot;); writeErr(&quot;fail to write to stdout\\n&quot;); exit(STDOUT_WRITE_FAIL); }}void writeErr(const char* str) { errno = 0; int writeSize = write(STDERR_FILENO, str, strlen(str)); if(writeSize == -1) { exit(STDERR_WRITE_FAIL); }} å‚æ•°å¤„ç†1234567891011121314151617181920212223242526272829303132int main(int argc, char **argv) { // srcæ–‡ä»¶ï¼Œdestæ–‡ä»¶ char *filesrc = NULL, *filedest = NULL; // å¤„ç†å‚æ•° for(int i = 1; i &lt; argc; i++) { if(argv[i][0] == '-') { if(strcmp(argv[i], &quot;--help&quot;) || strcmp(argv[i], &quot;-h&quot;)) { printHelp(); } else if(strcmp(argv[i], &quot;--version&quot;) || strcmp(argv[i], &quot;-v&quot;)) { printHelp(); } else { writeErr(&quot;Unsupported arg: &quot;); writeErr(argv[i]); writeErr(&quot;\\n&quot;); exit(UNSUPPORTED_ARG); } } else { if(filesrc == NULL) { filesrc = argv[i]; } else if(filedest == NULL) { filedest = argv[i]; } else { writeErr(&quot;Invalid arguments: &quot;); writeErr(argv[i]); writeErr(&quot;\\n&quot;); exit(INVALID_ARG); } } } // other part ...} ä¸å…è®¸-rç­‰æ“ä½œï¼Œåªå…è®¸å¯¹æ–‡ä»¶è¿›è¡Œå¤åˆ¶ æ–‡ä»¶æ‰“å¼€12345678910errno = 0;int srcFd = open(filesrc, O_RDONLY);if(srcFd == -1) { fileErrClose(filesrc, &quot;Can not open file: &quot;, FILE_OPEN_FAIL);}errno = 0;int descFd = open(filedest, O_WRONLY | O_TRUNC | O_CREAT);if(descFd == -1) { fileErrClose(filedest, &quot;Can not open file: &quot;, FILE_OPEN_FAIL);} åˆ†åˆ«æ‰“å¼€è¾“å…¥å’Œè¾“å‡ºæ–‡ä»¶ æ–‡ä»¶è¯»å†™12345678910111213141516171819202122232425262728293031323334353637char * readBuffer[READ_BUFF_SIZE+1];char allzero[READ_BUFF_SIZE+1] = {0};off_t offdest = 0;while(1) { errno = 0; ssize_t readSize = read(srcFd, readBuffer, READ_BUFF_SIZE); if(readSize == -1) { fileErrClose(filesrc, &quot;Can not read file: &quot;, FILE_READ_FAIL); } #ifdef debug printf(&quot;readsize = %ld\\n&quot;, readSize); #endif if(readSize == 0) { #ifdef debug writeStdout(&quot;Read finish\\n&quot;); #endif break; } readBuffer[readSize] = 0; offdest += readSize; if(memcmp(readBuffer, allzero, readSize) == 0) { #ifdef debug printf(&quot;hole, readsize = %ld, off = %ld\\n&quot;, readSize, offdest); #endif continue; } if(offdest &gt; 0)lseek(descFd, offdest, SEEK_CUR); offdest = 0; errno = 0; int writeSize = write(descFd, readBuffer, readSize); if(writeSize == -1) { fileErrClose(filedest, &quot;Write Fail on file: &quot;, FILE_WRITE_FAIL); } if(writeSize &lt; readSize) { fileErrClose(filedest, &quot;Partial write occured on file: &quot;, PARTIAL_WRITE_OCCURED); }} å½“æŸæ¬¡è¯»å‡ºæ•°æ®å…¨ä¸º0æ—¶ï¼Œåˆ™æ­¤å¤„æ˜¯ç©ºæ´ï¼Œè®°å½•ç©ºæ´çš„ç´¯è®¡é•¿åº¦ ç›´åˆ°æŸæ¬¡è¯»å–ä¸å…¨ä¸º0æ—¶ï¼Œç©ºæ´ç»“æŸï¼Œå…ˆlseekç©ºæ´é•¿åº¦ï¼Œå†å†™å…¥ å–„å12345678910errno = 0;if(close(srcFd) == -1) { fileErrClose(filesrc, &quot;Can not close file: &quot;, FILE_CLOSE_FAIL);}errno = 0;if(close(descFd) == -1) { fileErrClose(filedest, &quot;Can not close file: &quot;, FILE_CLOSE_FAIL);}return 0; å¤åˆ¶æ–‡ä»¶12gcc cp.c -o cp &amp;&amp; ./cp abc abc.cpstat -c %b abc.cp ç¼–è¯‘è¯¥cpå·¥å…·ï¼Œä½¿ç”¨å®ƒå¤åˆ¶å¸¦æœ‰ç©ºæ´æ–‡ä»¶ï¼Œå¯å‘ç°å…¶æˆåŠŸå¤åˆ¶ï¼Œå¹¶è¾“å‡ºå—æ•°ä¹Ÿä¸º16 å®Œæ•´ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include&lt;errno.h&gt;// #define debug#ifdef debug#include&lt;stdio.h&gt;#endif#define bool char#define false 0#define true 1#define strcmp(a,b) strcmp(a,b)==0// exit code#define UNSUPPORTED_ARG 1#define FILE_OPEN_FAIL 2#define STDOUT_WRITE_FAIL 3#define STDERR_WRITE_FAIL 4#define STDIN_READ_FAIL 5#define PARTIAL_WRITE_OCCURED 6#define FILE_CLOSE_FAIL 7#define FILE_WRITE_FAIL 8#define FILE_READ_FAIL 10#define INVALID_ARG 9// å‡½æ•°å£°æ˜void printHelp();void printVersion();void writeErr(const char* str);void writeStdout(const char* str);void fileErrClose(const char * filename, const char *err, int exitCode); #define READ_BUFF_SIZE 1023int main(int argc, char **argv) { // srcæ–‡ä»¶ï¼Œdestæ–‡ä»¶ char *filesrc = NULL, *filedest = NULL; // å¤„ç†å‚æ•° for(int i = 1; i &lt; argc; i++) { if(argv[i][0] == '-') { if(strcmp(argv[i], &quot;--help&quot;) || strcmp(argv[i], &quot;-h&quot;)) { printHelp(); } else if(strcmp(argv[i], &quot;--version&quot;) || strcmp(argv[i], &quot;-v&quot;)) { printHelp(); } else { writeErr(&quot;Unsupported arg: &quot;); writeErr(argv[i]); writeErr(&quot;\\n&quot;); exit(UNSUPPORTED_ARG); } } else { if(filesrc == NULL) { filesrc = argv[i]; } else if(filedest == NULL) { filedest = argv[i]; } else { writeErr(&quot;Invalid arguments: &quot;); writeErr(argv[i]); writeErr(&quot;\\n&quot;); exit(INVALID_ARG); } } } errno = 0; int srcFd = open(filesrc, O_RDONLY); if(srcFd == -1) { fileErrClose(filesrc, &quot;Can not open file: &quot;, FILE_OPEN_FAIL); } errno = 0; int descFd = open(filedest, O_WRONLY | O_TRUNC | O_CREAT); if(descFd == -1) { fileErrClose(filedest, &quot;Can not open file: &quot;, FILE_OPEN_FAIL); } char * readBuffer[READ_BUFF_SIZE+1]; char allzero[READ_BUFF_SIZE+1] = {0}; off_t offdest = 0; while(1) { errno = 0; ssize_t readSize = read(srcFd, readBuffer, READ_BUFF_SIZE); if(readSize == -1) { fileErrClose(filesrc, &quot;Can not read file: &quot;, FILE_READ_FAIL); } #ifdef debug printf(&quot;readsize = %ld\\n&quot;, readSize); #endif if(readSize == 0) { #ifdef debug writeStdout(&quot;Read finish\\n&quot;); #endif break; } readBuffer[readSize] = 0; offdest += readSize; if(memcmp(readBuffer, allzero, readSize) == 0) { #ifdef debug printf(&quot;hole, readsize = %ld, off = %ld\\n&quot;, readSize, offdest); #endif continue; } if(offdest &gt; 0)lseek(descFd, offdest, SEEK_CUR); offdest = 0; errno = 0; int writeSize = write(descFd, readBuffer, readSize); if(writeSize == -1) { fileErrClose(filedest, &quot;Write Fail on file: &quot;, FILE_WRITE_FAIL); } if(writeSize &lt; readSize) { fileErrClose(filedest, &quot;Partial write occured on file: &quot;, PARTIAL_WRITE_OCCURED); } } errno = 0; if(close(srcFd) == -1) { fileErrClose(filesrc, &quot;Can not close file: &quot;, FILE_CLOSE_FAIL); } errno = 0; if(close(descFd) == -1) { fileErrClose(filedest, &quot;Can not close file: &quot;, FILE_CLOSE_FAIL); } return 0;}void fileErrClose(const char * filename, const char *err, int exitCode) { const char *errstr = strerror(errno); writeErr(&quot;Error: &quot;); writeErr(errstr); writeErr(&quot;\\n&quot;); writeErr(err); writeErr(filename); writeErr(&quot;\\n&quot;); exit(exitCode);}void printHelp() { writeStdout(&quot;Usage: cp [--help][--version][src dest]\\n&quot;);}void printVersion() { writeStdout(&quot;Written by Jingtian Meow\\n&quot;);}void writeStdout(const char* str) { errno = 0; int writeSize = write(STDOUT_FILENO, str, strlen(str)); if(writeSize == -1) { char *errstr = strerror(errno); writeErr(&quot;Error: &quot;); writeErr(errstr); writeErr(&quot;\\n&quot;); writeErr(&quot;fail to write to stdout\\n&quot;); exit(STDOUT_WRITE_FAIL); }}void writeErr(const char* str) { errno = 0; int writeSize = write(STDERR_FILENO, str, strlen(str)); if(writeSize == -1) { exit(STDERR_WRITE_FAIL); }}","link":"/home/2023/03/22/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha4/"},{"title":"cha39.èƒ½åŠ›","text":"è¯»ä¹¦ç¬”è®°è¿›ç¨‹èƒ½åŠ›åˆ†ä¸ºï¼š ç±»å‹ è§£é‡Š è®¸å¯é›† è¿›ç¨‹å¯ä½¿ç”¨çš„èƒ½åŠ›ï¼Œåˆ é™¤ä¸€ä¸ªèƒ½åŠ›æ˜¯ä¸å¯é€†çš„ æœ‰æ•ˆé›† è¿›ç¨‹å½“å‰èƒ½ä½¿ç”¨çš„èƒ½åŠ› å¯ç»§æ‰¿é›† execä¹‹åï¼Œå¯ä»¥ç»§æ‰¿ã€è¿›å…¥è®¸å¯é›†çš„èƒ½åŠ›é›†ï¼ˆè§„å®šè¢«execçš„æ–‡ä»¶å¯ä»¥ç»§æ‰¿å“ªäº›èƒ½åŠ›ï¼‰ æ–‡ä»¶èƒ½åŠ›åˆ†ä¸ºï¼š ç±»å‹ è§£é‡Š è®¸å¯é›† execæ—¶æ·»åŠ åˆ°è¿›ç¨‹çš„è®¸å¯é›† æœ‰æ•ˆé›† 1ä½ï¼Œå…³é—­ï¼Œåˆ™execåè¿›ç¨‹æœ‰æ•ˆé›†ä¸ºç©ºï¼›å¼€å¯ï¼Œexecåæœ‰æ•ˆé›†ä¸ºè®¸å¯é›† å¯ç»§æ‰¿é›† æ–‡ä»¶å¯ç»§æ‰¿é›†ä¸è¿›ç¨‹å¯ç»§æ‰¿é›†ç›¸äº¤åï¼Œä½œä¸ºexecåå¯è¢«ç»§æ‰¿ã€è¿›å…¥è®¸å¯é›†çš„èƒ½åŠ›é›†åˆï¼ˆè§„å®šè¢«execçš„æ–‡ä»¶å¯ä»¥ç»§æ‰¿å“ªäº›èƒ½åŠ›ï¼‰ execå‰åè®¡ç®—å…¬å¼ cap_bsetä¸ºèƒ½åŠ›è¾¹ç•Œé›† 39.1ä½¿ç”¨capabilityä¿®æ”¹35-2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;sys/capability.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;sched.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt);}#define ERROR(...) error(__FILE__, __LINE__, __VA_ARGS__); exit(1)#define FAIL(...) error(__FILE__, __LINE__, __VA_ARGS__); return -1int raiseCap(int cap) { cap_value_t caplist[1]; cap_t capability = cap_get_proc(); if(capability == NULL) { FAIL(&quot;&quot;); } caplist[0] = cap; if(cap_set_flag(capability, CAP_EFFECTIVE, 1, caplist, CAP_SET) == -1) { cap_free(capability); FAIL(&quot;&quot;); } if(cap_set_proc(capability) == -1) { cap_free(capability); FAIL(&quot;&quot;); } if(cap_free(capability) == -1) { FAIL(&quot;&quot;); } return 0;}int main(int argc, char *argv[]) { if(raiseCap(CAP_SYS_NICE) == -1) { ERROR(&quot;&quot;);} int j, policy; struct sched_param sp; if(argc &lt; 3 || strrchr(&quot;rfo&quot;, argv[1][0]) == NULL) { ERROR(&quot;usage: %s policy priority pid...\\n&quot; &quot;\\tpolicy is r(RR), f(FIFO), &quot; #ifdef SCHED_BATCH &quot;b(BATCH), &quot; #endif #ifdef SCHED_IDLE &quot;i(IDLE), &quot; #endif &quot;or o(OTHER)&quot; , argv[0]); } switch (argv[1][0]) { case 'r': policy = SCHED_RR; break; case 'f': policy = SCHED_FIFO; break;#ifdef SCHED_BATCH case 'b': policy = SCHED_BATCH; break;#endif#ifdef SCHED_IDLE case 'i': policy = SCHED_IDLE; break;#endif case 'o': policy = SCHED_OTHER; break; default: ERROR(&quot;unsupported policy:%s\\n&quot;, argv[1]); break; } sp.sched_priority = atoi(argv[2]); for(int j = 3; j &lt; argc; j++) { pid_t pid = atoi(argv[j]); if(sched_setscheduler(pid, policy, &amp;sp) == -1) { ERROR(&quot;&quot;); } }} 12gcc practice39.1.c -o practice39.1 -lcapsudo setcap &quot;cap_sys_nice=pe&quot; practice39.1","link":"/home/2023/08/22/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha39/"},{"title":"cha42.å…±äº«åº“é«˜çº§ç‰¹æ€§","text":"42.1 42.2 ç¼–å†™ä¸€ä¸ªç¨‹åºæ¥éªŒè¯å½“ä½¿ç”¨dlclose0å…³é—­ä¸€ä¸ªåº“æ—¶å¦‚æœå…¶ä¸­çš„ç¬¦å·è¿˜åœ¨è¢«å…¶ä»–åº“ä½¿ç”¨çš„è¯å°†ä¸ä¼šå¸è½½è¿™ä¸ªåº“ã€‚ åœ¨ç¨‹åºæ¸…å•42-1ä¸­çš„ç¨‹åº(dynload.c)ä¸­æ·»åŠ ä¸€ä¸ªdladdr0è°ƒç”¨ä»¥è·å–ä¸dlsymè¿”å›çš„åœ°å€æœ‰å…³çš„ä¿¡æ¯ã€‚æ‰“å°å‡ºè¿”å›çš„ DI inf ç»“æ„ä¸­å„ä¸ªå­—æ®µçš„å€¼å¹¶éªŒè¯è¿™äº›å€¼æ˜¯å¦ä¸é¢„æœŸçš„å€¼ä¸€æ ·ã€‚ practice42.1.a.c1234567891011121314151617181920212223//// Created by root on 8/25/23.//#include &lt;stdio.h&gt;int foo(int a, int b) { printf(&quot;foo\\n&quot;); return a+b;}int bar(int a, int b) { printf(&quot;bar\\n&quot;); return a*b;}void __attribute__ ((constructor)) init() { printf(&quot;constructing\\n&quot;);}void __attribute__ ((destructor())) dest() { printf(&quot;destructing\\n&quot;);} practice42.1.b.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//// Created by root on 8/25/23.//#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt);}#define ERROR(...) do { error(__FILE__, __LINE__, __VA_ARGS__); exit(1); } while(0)#define FAIL(...) do { error(__FILE__, __LINE__, __VA_ARGS__); return -1; } while(0)int main(int argc, char **argv) { if(argc &lt; 1) { ERROR(&quot;Usage: %s shared-object&quot;, argv[0]); } void *libhandler = dlopen(argv[1], RTLD_NOW); if(libhandler == NULL) { ERROR(dlerror()); } void *libhandler1 = dlopen(argv[1], RTLD_NOW); if(libhandler1 == NULL) { ERROR(dlerror()); } int (*f)(int, int) = dlsym(libhandler, &quot;foo&quot;); if(f == NULL) { ERROR(dlerror()); } int (*f1)(int, int) = dlsym(libhandler1, &quot;bar&quot;); if(f1 == NULL) { ERROR(dlerror()); } Dl_info info; memset(&amp;info, 0, sizeof(Dl_info)); if(dladdr(f, &amp;info) == 0) { ERROR(dlerror()); } printf(&quot;addr=%p\\n\\tfname=%s\\n\\tfbase=%p\\n\\tsname=%s\\n\\tsaddr=%p\\n&quot;, f, info.dli_fname, info.dli_fbase, info.dli_sname, info.dli_saddr); memset(&amp;info, 0, sizeof(Dl_info)); if(dladdr(f1, &amp;info) == 0) { ERROR(dlerror()); } printf(&quot;addr=%p\\n\\tfname=%s\\n\\tfbase=%p\\n\\tsname=%s\\n\\tsaddr=%p\\n&quot;, f1, info.dli_fname, info.dli_fbase, info.dli_sname, info.dli_saddr); printf(&quot;%d, %d\\n&quot;, f(1,2), f1(2,3)); printf(&quot;dlclose libhandler\\n&quot;); dlclose(libhandler); printf(&quot;dlclose libhandler1\\n&quot;); dlclose(libhandler1);}","link":"/home/2023/08/25/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha42/"},{"title":"cha40.ç™»å½•è®°è´¦","text":"40-1 40-4 å®ç°getlogin0ã€‚åœ¨40.5èŠ‚ä¸­æ›¾æåˆ°è¿‡å½“è¿›ç¨‹è¿è¡Œåœ¨ä¸€äº›è½¯ä»¶ç»ˆç«¯æ¨¡æ‹Ÿå™¨ä¸‹æ—¶getlogin0å¯èƒ½æ— æ³•æ­£ç¡®å·¥ä½œï¼Œåœ¨é‚£ç§æƒ…å†µä¸‹å°±åœ¨è™šæ‹Ÿæ§åˆ¶å°ä¸­è¿›è¡Œæµ‹è¯•ã€‚ å®ç°ä¸€ä¸ªç®€å•çš„who(1)ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//// Created by root on 8/23/23.//#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;utmpx.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;char *__getlogin() { static char login[__UT_NAMESIZE]; char *tty = ttyname(0); if(tty) tty++; tty=strchr(tty, '/'); if(tty) tty++; printf(&quot;tty=%s\\n&quot;, tty); size_t ttylen = strlen(tty); struct utmpx *ut; setutxent(); while((ut = getutxent()) != NULL) { printf(&quot;type:\\t%s\\nline:\\t%s\\nuser:\\t%s\\nhost:\\t%s\\ntime:\\t%s\\n\\n&quot;, ut-&gt;ut_type == EMPTY ? &quot;EMPTY&quot; : ut-&gt;ut_type == RUN_LVL ? &quot;RUN_LVL&quot; : ut-&gt;ut_type == BOOT_TIME ? &quot;BOOT_TIME&quot; : ut-&gt;ut_type == NEW_TIME ? &quot;NEW_TIME&quot; : ut-&gt;ut_type == OLD_TIME ? &quot;OLD_TIME&quot; : ut-&gt;ut_type == INIT_PROCESS ? &quot;INIT_PROCESS&quot; : ut-&gt;ut_type == USER_PROCESS ? &quot;USER_PROCESS&quot; : ut-&gt;ut_type == DEAD_PROCESS ? &quot;DEAD_PROCESS&quot; : ut-&gt;ut_type == LOGIN_PROCESS ? &quot;LOGIN_PROCESS&quot; : &quot;unknown&quot;, ut-&gt;ut_line, ut-&gt;ut_user, ut-&gt;ut_host, ctime((time_t *)&amp;ut-&gt;ut_tv.tv_sec) ); if(!strncmp(tty, ut-&gt;ut_line, ttylen) &amp;&amp; (ut-&gt;ut_type == INIT_PROCESS || ut-&gt;ut_type == USER_PROCESS || ut-&gt;ut_type == LOGIN_PROCESS)) { strcpy(login, ut-&gt;ut_user); } } endutxent(); return login;}int main() { printf(&quot;getlogin=%s\\n&quot;, getlogin()); printf(&quot;getlogin=%s\\n&quot;, __getlogin());} 40-2 40-3 ä¿®æ”¹ç¨‹åºæ¸…å•40-3ä¸­çš„ç¨‹åº(utmpx loginc)ä½¿å®ƒé™¤äº†æ›´æ–°utmpå’Œwtmpæ–‡ä»¶ä¹‹å¤–è¿˜æ›´æ–°lastlogæ–‡ä»¶ã€‚ é˜…è¯»login(3)ã€logout(3)ä»¥åŠlogwtmp(3)çš„æ‰‹å†Œã€‚å®ç°è¿™äº›å‡½æ•° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166//// Created by root on 8/24/23.//#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;utmpx.h&gt;#include &lt;stdarg.h&gt;#include &lt;time.h&gt;#include &lt;paths.h&gt;#include &lt;wait.h&gt;#include &lt;lastlog.h&gt;#include &lt;pwd.h&gt;#include &lt;fcntl.h&gt;#include &lt;pwd.h&gt;#include &lt;crypt.h&gt;#include &lt;shadow.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt);}#define ERROR(...) do { error(__FILE__, __LINE__, __VA_ARGS__); exit(1); } while(0)#define FAIL(...) do { error(__FILE__, __LINE__, __VA_ARGS__); return -1; } while(0)char *alloc_sprintf(const char * __format, ...) { va_list fmt; va_start(fmt, __format); int len = vsnprintf(NULL, 0, __format, fmt); va_end(fmt); char *str = malloc(len+1); if(str == NULL) ERROR(&quot;&quot;); va_start(fmt, __format); vsnprintf(str, 0, __format, fmt); va_end(fmt); return str;}int tmpxlog(struct utmpx *ut, const char *user, const char *ttyName) { memset(ut, 0, sizeof(struct utmpx)); ut-&gt;ut_type = USER_PROCESS; strncpy(ut-&gt;ut_user, user, sizeof(ut-&gt;ut_user)); if(time((time_t *)&amp;ut-&gt;ut_tv.tv_sec) == -1) { ERROR(&quot;&quot;); } ut-&gt;ut_pid = getpid(); strcpy(ut-&gt;ut_line, ttyName + 5); strcpy(ut-&gt;ut_id, ttyName + 8); strcpy(ut-&gt;ut_host, &quot;meow-bash&quot;); setutxent(); if(pututxline(ut) == NULL) ERROR(&quot;&quot;); updwtmpx(_PATH_WTMP, ut); return 0;}int lastlog(uid_t uid, const char *ttyName) { struct lastlog lastlog = { .ll_host=&quot;meow-bash&quot; }; strcpy(lastlog.ll_line, ttyName + 5); if(time((time_t *)&amp;lastlog.ll_time) == -1) { ERROR(&quot;&quot;); } int lstlogfd = open(_PATH_LASTLOG, O_RDWR); if(lseek(lstlogfd, uid * sizeof(struct lastlog), SEEK_SET) == -1) ERROR(&quot;&quot;); if(write(lstlogfd, &amp;lastlog, sizeof(struct lastlog)) != sizeof(struct lastlog)) ERROR(&quot;&quot;); close(lstlogfd); return 0;}int tmpxlogout(struct utmpx *ut) { ut-&gt;ut_type = DEAD_PROCESS; if(time((time_t *)&amp;ut-&gt;ut_tv.tv_sec) == -1) { ERROR(&quot;&quot;); } strncpy(ut-&gt;ut_user, &quot;&quot;, sizeof(ut-&gt;ut_user)); setutxent(); if(pututxline(ut) == NULL) ERROR(&quot;&quot;); updwtmpx(_PATH_WTMP, ut); endutxent(); return 0;}int checkpwd(const char *username) { char *shadow = NULL; struct passwd *usrpwd; if((usrpwd = getpwnam(username)) == NULL) FAIL(&quot;username:%s not found&quot;, username); shadow = usrpwd-&gt;pw_passwd; char *pass = getpass(&quot;Password: &quot;); if(!strcmp(shadow, &quot;x&quot;)) { struct spwd *shadowpwd; if((shadowpwd = getspnam(username)) == NULL) FAIL(&quot;shadowpwd not found&quot;); shadow = shadowpwd-&gt;sp_pwdp; pass = crypt(pass, shadow); } if(strcmp(shadow, pass) == 0) FAIL(&quot;password not match!&quot;); return 0;}char *user = NULL;int init_check(int argc, char *argv[]) { if(argc &lt; 2) { user = malloc(2048); char hostname[2048]; gethostname(hostname, 2048); printf(&quot;%s login: &quot;, hostname); scanf(&quot;%s&quot;, user); } else { user = strdup(argv[1]); } if(getuid() != 0) { ERROR(&quot;uid must be 0\\n&quot;); }}int main(int argc, char *argv[]) { struct utmpx ut; char *homedir = NULL; uid_t uid; struct passwd *passwd = NULL; char *ttyName = ttyname(0); if(ttyName == NULL) { ERROR(&quot;&quot;); } init_check(argc, argv); if(checkpwd(user) == -1) ERROR(&quot;&quot;); passwd = getpwnam(user); uid = passwd-&gt;pw_uid; homedir = alloc_sprintf(&quot;%s/.bashrc&quot;, passwd-&gt;pw_dir); tmpxlog(&amp;ut, user, ttyName); lastlog(uid, ttyName); printf(&quot;meow-meow-bash login\\n&quot;); fflush(NULL); switch (fork()) { case -1: ERROR(&quot;&quot;); break; case 0: setuid(uid); if(execlp(&quot;/bin/bash&quot;, &quot;/bin/bash&quot;, &quot;--init-file&quot;, homedir, NULL) == -1) { ERROR(&quot;&quot;); } break; default: wait(NULL); break; } tmpxlogout(&amp;ut); printf(&quot;meow-meow-bash logout\\n&quot;); free(homedir); free(user);}","link":"/home/2023/08/24/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha40/"},{"title":"cha44.ç®¡é“å’ŒFIFO","text":"ç®¡é“å’ŒFIFO é€šè¿‡pipeè°ƒç”¨è·å–ä¸¤ä¸ªfdï¼Œfd[0]ä¸ºç®¡é“çš„è¾“å…¥ç«¯ï¼Œfd[1]ä¸ºè¾“å‡ºç«¯ï¼Œå…è®¸ç›¸å…³çš„è¿›ç¨‹ä¹‹é—´é€šè¿‡ç®¡é“ç›¸è¿ ç®¡é“çš„ä½¿ç”¨çš„å•é¡¹çš„ï¼Œå¦‚æœæŸäº›è¿›ç¨‹å³è¯»å–ç®¡é“åˆå†™å…¥ç®¡é“ï¼Œå¯èƒ½ä¼šä¸å…¶ä»–è¯»å–/å†™å…¥ç®¡é“çš„è¿›ç¨‹äº§ç”Ÿç«æ€æ¡ä»¶ å¯¹ç®¡é“readæ—¶ï¼Œå¦‚æœç®¡é“å¦ä¸€ç«¯æœ‰è¿›ç¨‹æ‰“å¼€ä¸”ç®¡é“å†…æ²¡æœ‰å†…å®¹ï¼Œåˆ™ä¼šé˜»å¡ï¼Œç›´åˆ°å¦ä¸€ç«¯å†™å…¥ï¼ˆæ­¤æ—¶è¯»å–åˆ°å†™å…¥çš„æ•°æ®ï¼‰ï¼Œæˆ–å¦ä¸€ç«¯å…³é—­ï¼ˆæ­¤æ—¶readè¿”å›EOFï¼‰ åˆ©ç”¨è¿™ä¸€ç‰¹æ€§ï¼Œå¯ä»¥ä½œä¸ºè¿›ç¨‹é—´çš„åŒæ­¥æœºåˆ¶ ä¸€èˆ¬å­è¿›ç¨‹è¦å…³é—­ä¸éœ€è¦çš„å¦ä¸€ç«¯ å½“æ‰€æœ‰å†™å…¥ç«¯éƒ½å…³é—­æ—¶ï¼Œä»ç®¡é“ä¸­è¯»å–ï¼Œä¼šè¿”å›EOFï¼Œå¸®åŠ©ç¨‹åºäº†è§£å½“å‰ç®¡é“çš„ä½¿ç”¨çŠ¶å†µ å½“æ‰€æœ‰è¯»å–ç«¯éƒ½å…³é—­æ—¶ï¼Œå‘ç®¡é“å†…å†™å…¥æ•°æ®ï¼Œç³»ç»Ÿä¼šå‘è¿›ç¨‹å‘é€SIGPIPEï¼Œé»˜è®¤æ€æ­»è¿›ç¨‹ã€‚è‹¥ä¿®æ”¹SIGPIPEé»˜è®¤è¡Œä¸ºï¼Œåˆ™writeå¤±è´¥ï¼Œé”™è¯¯ä¸ºEPIPEã€‚è‹¥å¯¹SIGPIPEä½¿ç”¨äº†SA_RESTARTï¼Œwriteå¦ä¸€ç«¯å·²ç»å…³é—­çš„ç®¡é“ï¼Œwriteä¹Ÿä¸ä¼šé‡å¯ stdioå¯¹ç®¡é“ä½¿ç”¨å—ç¼“å†² FIFOé€šè¿‡mkfifoæˆ–mknodåˆ›å»ºï¼Œç±»ä¼¼äºç®¡é“ï¼ŒåŒºåˆ«åœ¨äº é€šè¿‡æ–‡ä»¶åopenåè·å–fdï¼Œopenæ—¶æŒ‡å®šreadè¿˜æ˜¯write openæ—¶æ²¡æœ‰ä½¿ç”¨O_NONBLOCKæ—¶ï¼Œæ‰“å¼€å¦ä¸€ç«¯å…³é—­çš„FIFOæ—¶ï¼Œä¼šé˜»å¡ openæ—¶ä½¿ç”¨O_NONBLOCK | O_WRONLYæ—¶ï¼Œå‘å¦ä¸€ä¾§å…³é—­çš„FIFOä¸­å†™å…¥æ—¶ï¼Œå¯¼è‡´ENXIOé”™è¯¯ï¼Œä½¿ç”¨O_NONBLOCK | O_RDONLYåˆ™ç«‹åˆ»æˆåŠŸ ä¸ä½¿ç”¨O_NONBLOCKæ—¶readï¼Œæƒ…å†µç­‰äºç®¡é“ï¼Œå¯ç”¨æ—¶ï¼Œå¦‚æœFIFOä¸­æ²¡æœ‰æ•°æ®ï¼Œäº§ç”ŸEAGAINé”™è¯¯ writeæ—¶è¯»å–ç«¯å…³é—­ï¼Œåˆ™äº§ç”ŸSIGPIPEï¼Œè¿”å›EPIPEã€‚å…¶ä»–æƒ…å†µæ¯”è¾ƒå¤æ‚ã€‚ éªŒè¯123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138//// Created by root on 8/29/23.//#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;wait.h&gt;#include &lt;signal.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt);}#define ERROR(...) do { error(__FILE__, __LINE__, __VA_ARGS__); exit(1); } while(0)#define ERROR_PRINT(...) error(__FILE__, __LINE__, __VA_ARGS__)#define FAIL(...) do { error(__FILE__, __LINE__, __VA_ARGS__); return -1; } while(0)char *alloc_sprintf(const char * __format, ...) { va_list fmt; va_start(fmt, __format); int len = vsnprintf(NULL, 0, __format, fmt); va_end(fmt); char *str = malloc(len+1); if(str == NULL) ERROR(&quot;&quot;); va_start(fmt, __format); vsnprintf(str, len+1, __format, fmt); va_end(fmt); return str;}#define safe_free(ptr) do { if(ptr) { free(ptr); ptr = NULL;} } while(0)char *fifo;void cleanup() { safe_free(fifo);}#define test(flag) do { \\ int fd = open(fifo, flag); \\ if(fd == -1) { \\ error(__FILE__, __LINE__, &quot;flag = %s&quot;,#flag); \\ } \\ close(fd); \\} while(0)void pipehandler(int sig) { char *content = alloc_sprintf(&quot;pid:%d, received signal:%d(%s)\\n&quot;, getpid(), sig, strsignal(sig)); write(STDOUT_FILENO, content, strlen(content)); safe_free(content);}int main(int argc, char **argv) { char buf[1024]; atexit(cleanup); fifo = alloc_sprintf(&quot;%s-fifo&quot;, argv[0]); printf(&quot;fifo=%s\\n&quot;, fifo); if(mkfifo(fifo, S_IRUSR | S_IWUSR | S_IWGRP) == -1 &amp;&amp; errno != EEXIST) { ERROR(&quot;&quot;); } // éé˜»å¡ï¼Œæ‰“å¼€æ²¡æœ‰å†™å…¥ç«¯çš„FIFO test(O_RDONLY | O_NONBLOCK); // éé˜»å¡ï¼Œæ‰“å¼€æ²¡æœ‰è¯»å–ç«¯çš„FIFO test(O_WRONLY | O_NONBLOCK); int pipefd[2] = {0}; if(pipe(pipefd) == -1) ERROR(&quot;&quot;); if(sigaction(SIGPIPE, &amp;(struct sigaction) { .sa_flags=0, .sa_handler=pipehandler }, NULL) == -1) ERROR(&quot;&quot;); if(sigaction(SIGUSR1, &amp;(struct sigaction) { .sa_flags=SA_RESTART, .sa_handler=pipehandler }, NULL) == -1) ERROR(&quot;&quot;); if(sigaction(SIGUSR2, &amp;(struct sigaction) { .sa_flags=0, .sa_handler=pipehandler }, NULL) == -1) ERROR(&quot;&quot;); ssize_t readsize = 0; pid_t pid; if((pid = fork()) != 0) { if((readsize = read(pipefd[0], buf, 1024)) &lt; 0) { ERROR_PRINT(&quot;&quot;); } // SIGUSR1ä¸­æ–­readï¼ŒSIGUSR1æœ‰SA_RESTARTï¼Œé‡å¯ï¼ŒæˆåŠŸè¯»å– if(write(STDOUT_FILENO, buf, readsize) != readsize) { ERROR(&quot;&quot;); } kill(pid, SIGUSR1); readsize = 0; if((readsize = read(pipefd[0], buf, 1024)) &lt; 0) { ERROR_PRINT(&quot;&quot;); } // SIGUSR2ä¸­æ–­readï¼ŒSIGUSR2æ²¡æœ‰SA_RESTARTï¼Œä¸é‡å¯ï¼Œæ²¡æœ‰æˆåŠŸè¯»å– if(write(STDOUT_FILENO, buf, readsize) != readsize) { ERROR(&quot;&quot;); } } else { close(pipefd[0]); kill(getppid(), SIGUSR1); sleep(1); write(pipefd[1], &amp;(char[]){'o', 'k', '!', '\\n'}, 4); pause(); sleep(1); kill(getppid(), SIGUSR2); sleep(1); write(pipefd[1], &amp;(char[]){'o', 'j', 'b', 'k', '!', '\\n'}, 6); close(pipefd[1]); exit(0); } wait(NULL); close(pipefd[0]); close(pipefd[1]); if(pipe(pipefd) == -1) ERROR(&quot;&quot;); close(pipefd[1]); if((readsize = read(pipefd[0], buf, 1024)) &lt; 0) { ERROR_PRINT(&quot;&quot;); } // å‘å†™å…¥ç«¯å·²ç»å…³é—­çš„ä¸€ç«¯è¯»å– printf(&quot;å‘å†™å…¥ç«¯å·²ç»å…³é—­çš„ä¸€ç«¯è¯»å–, readsize = %lu\\n&quot;, readsize); close(pipefd[0]); if(pipe(pipefd) == -1) ERROR(&quot;&quot;); close(pipefd[0]); if(write(pipefd[1], &quot;12345&quot;, 5) != 5) { ERROR_PRINT(&quot;&quot;); } // å‘è¯»å–ç«¯å·²ç»å…³é—­çš„ä¸€ç«¯å†™å…¥,SIGPIPEæœ‰SA_RESTARTä½†æ˜¯æ­¤æ—¶ä¸é‡å¯ close(pipefd[1]); return 0;} ä¹¦ä¸Šæœ‰ä¸€äº›ä¸æ¸…æ¥šçš„åœ°æ–¹ï¼Œç”¨è¿™ä¸ªä»£ç å¯ä»¥éªŒè¯ä¸€ä¸‹ 44.1ç¼–å†™ä¸€ä¸ªç¨‹åºä½¿ä¹‹ä½¿ç”¨ä¸¤ä¸ªç®¡é“æ¥å¯ç”¨çˆ¶è¿›ç¨‹å’Œå­è¿›ç¨‹ä¹‹é—´çš„åŒå‘é€šä¿¡ã€‚çˆ¶è¿›ç¨‹åº”è¯¥å¾ªç¯ä»æ ‡å‡†è¾“å…¥ä¸­è¯»å–ä¸€ä¸ªæ–‡æœ¬å—å¹¶ä½¿ç”¨å…¶ä¸­ä¸€ä¸ªç®¡é“å°†æ–‡æœ¬å‘é€ç»™å­è¿›ç¨‹ï¼Œå­è¿›ç¨‹å°†æ–‡æœ¬è½¬æ¢æˆå¤§å†™å¹¶é€šè¿‡å¦ä¸€ä¸ªç®¡é“å°†å…¶ä¼ å›ç»™çˆ¶è¿›ç¨‹ã€‚çˆ¶è¿›ç¨‹è¯»å–ä»å­è¿›ç¨‹è¿‡æ¥çš„æ•°æ®å¹¶åœ¨ç»§ç»­ä¸‹ä¸€ä¸ªå¾ªç¯ä¹‹å‰å°†å…¶åé¦ˆåˆ°æ ‡å‡†è¾“å‡ºä¸Šã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136//// Created by root on 8/29/23.//#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt);}#define ERROR(...) do { error(__FILE__, __LINE__, __VA_ARGS__); exit(1); } while(0)#define ERROR_PRINT(...) error(__FILE__, __LINE__, __VA_ARGS__)#define FAIL(...) do { error(__FILE__, __LINE__, __VA_ARGS__); return -1; } while(0)#define safe_free(ptr) do { if(ptr) { free(ptr); ptr = NULL;} } while(0)void wPrintf(int fd, const char * format, ...) { va_list fmt; va_start(fmt, format); int len = vsnprintf(NULL, 0, format, fmt); char *str = malloc(len+1); va_end(fmt); va_start(fmt, format); if(str == NULL) ERROR(&quot;&quot;); vsnprintf(str, len+1, format, fmt); va_end(fmt); if(write(fd, str, len) != len) { ERROR(&quot;&quot;); } safe_free(str);}pid_t childpid = -1;#define BUFFER_SIZE 2048int main2child[2];int child2main[2];void cleanup() { wPrintf(STDOUT_FILENO, &quot;pid:%d, cleaning up\\n&quot;, getpid()); if(childpid &gt; 1) kill(childpid,SIGKILL);}void child_process() { char buf[BUFFER_SIZE]; ssize_t readsize; if(close(main2child[1]) == -1) ERROR(&quot;&quot;); if(close(child2main[0]) == -1) ERROR(&quot;&quot;); while ((readsize = read(main2child[0], buf, BUFFER_SIZE-1)) &gt; 0) { buf[readsize] = 0; wPrintf(STDOUT_FILENO, &quot;child read: %s\\n&quot;, buf); for(int i = 0; i &lt; readsize; i++) { if((buf[i] &gt;= 'a' &amp;&amp; buf[i] &lt;= 'z') ) { buf[i] += 'A' - 'a'; } else if((buf[i] &gt;= 'A' &amp;&amp; buf[i] &lt;= 'Z')) { buf[i] += 'a' - 'A'; } } if(write(child2main[1], buf, readsize) != readsize) { ERROR(&quot;&quot;); } } if(readsize &lt; 0) { ERROR(&quot;&quot;); } else { wPrintf(STDOUT_FILENO, &quot;main2child closed!\\n&quot;); } if(close(main2child[0]) == -1) ERROR(&quot;&quot;); if(close(child2main[1]) == -1) ERROR(&quot;&quot;);}void main_process() { char buf[BUFFER_SIZE]; ssize_t readsize; if(close(main2child[0]) == -1) ERROR(&quot;&quot;); if(close(child2main[1]) == -1) ERROR(&quot;&quot;); while ((readsize = read(STDIN_FILENO, buf, BUFFER_SIZE-1)) &gt; 0) { buf[readsize] = 0; wPrintf(STDOUT_FILENO, &quot;main read: %s\\n&quot;, buf); if(write(main2child[1], buf, readsize) != readsize) { ERROR(&quot;&quot;); } readsize = read(child2main[0], buf, BUFFER_SIZE-1); buf[readsize] = 0; if(readsize == 0) { wPrintf(STDOUT_FILENO, &quot;child2main closed!\\n&quot;); exit(0); } else if(readsize &lt; 0) { ERROR(&quot;&quot;); } else { wPrintf(STDOUT_FILENO, &quot;main read from child: %s\\n&quot;, buf); } } if(readsize &lt; 0) { ERROR(&quot;&quot;); } if(close(main2child[1]) == -1) ERROR(&quot;&quot;); if(close(child2main[0]) == -1) ERROR(&quot;&quot;);}void handler(int sig) { wPrintf(STDOUT_FILENO, &quot;pid:%d, received sig:%d(%s)\\n&quot;, getpid(), sig, strsignal(sig)); exit(1);}int main(int argc, char *argv[]) { atexit(cleanup); if(pipe(main2child) == -1) ERROR(&quot;&quot;); if(pipe(child2main) == -1) ERROR(&quot;&quot;); switch((childpid = fork())) { case -1: ERROR(&quot;&quot;); break; case 0: child_process(); return 0; break; default: if(signal(SIGINT, handler) == SIG_ERR) ERROR(&quot;&quot;); if(signal(SIGPIPE, handler) == SIG_ERR) ERROR(&quot;&quot;); main_process(); return 0; break; }} 44.2å®ç°popenå’Œpcloseã€‚å°½ç®¡è¿™äº›å‡½æ•°å› æ— éœ€å®Œæˆåœ¨systemå®ç°(å‚è§27.7èŠ‚)ä¸­çš„ä¿¡å·å¤„ç†è€Œå¾—åˆ°äº†ç®€åŒ–ï¼Œä½†éœ€è¦å°å¿ƒåœ°å°†ç®¡é“ä¸¤ç«¯æ­£ç¡®ç»‘å®šåˆ°å„ä¸ªè¿›ç¨‹çš„æ–‡ä»¶æµä¸Šå¹¶ç¡®ä¿å…³é—­æ‰€æœ‰å¼•ç”¨ç®¡é“ä¸¤ç«¯çš„æœªä½¿ç”¨çš„æè¿°ç¬¦ã€‚ç”±äºé€šè¿‡å¤šä¸ª popenè°ƒç”¨åˆ›å»ºçš„å­è¿›ç¨‹å¯èƒ½ä¼šåŒæ—¶è¿è¡Œï¼Œå› æ­¤éœ€è¦éœ€è¦ç»´æŠ¤ä¸€ä¸ªå°† popen0åˆ†é…çš„æ–‡ä»¶æµä¸ç›¸åº”çš„å­è¿›ç¨‹IDå…³è”èµ·æ¥çš„æ•°æ®ç»“æ„ã€‚ä»è¿™ä¸ªç»“æ„ä¸­å–å¾—æ­£ç¡®çš„è¿›ç¨‹IDä½¿å¾—pcloseèƒ½å¤Ÿé€‰æ‹©éœ€ç­‰å¾…çš„å­è¿›ç¨‹ã€‚è¿™ä¸ªç»“æ„è¿˜æ»¡è¶³äº†SUSv3çš„è¦æ±‚ï¼Œå³åœ¨æ–°çš„å­è¿›ç¨‹ä¸­å¿…é¡»è¦å…³é—­æ‰€æœ‰é€šè¿‡ä¹‹å‰çš„popenè°ƒç”¨ä»ç„¶æ‰“å¼€ç€çš„æ–‡ä»¶æµã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//// Created by root on 8/29/23.//#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt);}#define ERROR_EXIT(ret, msg...) do { error(__FILE__, __LINE__, msg); ret } while(0)#define ERROR(msg...) ERROR_EXIT(exit(1);, msg)#define FAIL(val, msg...) ERROR_EXIT(return val;, msg)#define PRINT_ERROR_STR(msg...) FAIL(, msg)#define safe_free(ptr) do { if(ptr) { free(ptr); ptr = NULL;} } while(0)void wPrintf(int fd, const char * format, ...) { va_list fmt; va_start(fmt, format); int len = vsnprintf(NULL, 0, format, fmt); char *str = malloc(len+1); va_end(fmt); va_start(fmt, format); if(str == NULL) ERROR(&quot;&quot;); vsnprintf(str, len+1, format, fmt); va_end(fmt); if(write(fd, str, len) != len) { ERROR(&quot;&quot;); } safe_free(str);}#include &lt;limits.h&gt;#include &lt;wait.h&gt;static pid_t *fd2pid = NULL;int _pclose(FILE *file) { if(fd2pid == NULL) { fd2pid = malloc(INT_MAX * sizeof(pid_t)); return -1; } int fd = fileno(file); if(fclose(file) == -1) FAIL(-1, &quot;&quot;);// if(close(fd) == -1) FAIL(-1, &quot;&quot;); // ä¸éœ€è¦ï¼Œfcloseå°±ä¼šè°ƒç”¨close if(waitpid(fd2pid[fd], NULL, 0) == -1) FAIL(-1, &quot;&quot;); return 0;}FILE *_popen(const char *command, const char *mode) { if(fd2pid == NULL) { fd2pid = malloc(INT_MAX * sizeof(pid_t)); } FILE *ret = NULL; int pipefd[2] = {0}; // retfd, dupfd int replacefd = -1; if(strcmp(&quot;r&quot;, mode) != 0 &amp;&amp; strcmp(&quot;w&quot;, mode) != 0) { FAIL(NULL, &quot;mode: r/w&quot;); } if(pipe(pipefd) == -1) FAIL(NULL, &quot;&quot;); if(mode[0] == 'r') { ret = fdopen(pipefd[0], &quot;r&quot;); if(ret == NULL) FAIL(NULL, &quot;&quot;); replacefd = STDOUT_FILENO; } else { ret = fdopen(pipefd[1], &quot;w&quot;); int fdt = pipefd[0]; pipefd[0] = pipefd[1]; pipefd[1] = fdt; replacefd = STDIN_FILENO; } pid_t pid; switch(pid = fork()) { case -1: FAIL(NULL, &quot;&quot;); break; case 0: if(close(pipefd[0]) == -1) FAIL(NULL, &quot;&quot;); if(dup2(pipefd[1], replacefd) == -1) { ERROR(&quot;&quot;); } system(command); if(close(pipefd[1]) == -1) FAIL(NULL, &quot;&quot;); exit(0); break; default: if(close(pipefd[1]) == -1) FAIL(NULL, &quot;&quot;); break; } fd2pid[pipefd[0]] = pid; return ret;}int main(int argc, char *argv[]) { FILE *f; f = _popen(&quot;tee &gt; abc.txt&quot;, &quot;w&quot;); for(int i = 0; i &lt; argc; i++) { fprintf(f, &quot;%s\\n&quot;, argv[i]); } _pclose(f); f = _popen(&quot;cat abc.txt&quot;, &quot;r&quot;); char buf[2048] = {0}; while (fgets(buf, 2048, f) != NULL) { printf(&quot;%s&quot;, buf); } _pclose(f);} 44.3 44.4 44.6åœ¨44.7çš„åŸºç¡€ä¸Šæ”¹åŠ¨ï¼š åŠ å…¥åŠŸèƒ½ï¼šæ¯æ¬¡ç»™clientèµ‹å€¼æ—¶ï¼Œéƒ½ä¼šä¸ä¸€ä¸ªæ–‡ä»¶åŒæ­¥è®°å½•æœ€æ–°çš„æ•°å€¼ï¼ŒæœåŠ¡å™¨å¯åŠ¨æ—¶è¯»å–è¿™ä¸ªæ•°å€¼ï¼Œå¹¶ä»è¿™ä¸ªæ•°å€¼å¼€å§‹æä¾›æœåŠ¡ åŠ å…¥åŠŸèƒ½ï¼šåœ¨æ”¶åˆ°SIGINT, SIGTERMæ—¶åˆ é™¤æœåŠ¡å™¨å¹¶ç»ˆæ­¢ åŠ å…¥åŠŸèƒ½ï¼šé˜²æ­¢æ¶æ„ç¨‹åºæ”»å‡»ï¼ˆæ¶æ„ç¨‹åºåˆ›å»ºä½†ä¸æ‰“å¼€è‡ªå·±çš„CLIENT_FIFOï¼Œå¯¼è‡´serverå§‹ç»ˆé˜»å¡ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193//// Created by root on 8/29/23.//#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt);}#define ERROR_EXIT(ret, msg...) do { error(__FILE__, __LINE__, msg); ret } while(0)#define ERROR(msg...) ERROR_EXIT(exit(1);, msg)#define FAIL(ret, msg...) ERROR_EXIT(ret, msg)#define PRINT_ERROR_STR(msg...) FAIL(;, msg)#define safe_free(ptr) do { if(ptr) { free(ptr); ptr = NULL;} } while(0)char *alloc_sprintf(const char * __format, ...) { va_list fmt; va_start(fmt, __format); int len = vsnprintf(NULL, 0, __format, fmt); va_end(fmt); char *str = malloc(len+1); if(str == NULL) ERROR(&quot;&quot;); va_start(fmt, __format); vsnprintf(str, len+1, __format, fmt); va_end(fmt); return str;}char *__client_fifo = NULL;void __attribute__((destructor)) cleanup() { // atexitæ›´åˆé€‚ safe_free(__client_fifo);}#define SERVER_FIFO &quot;server-fifo&quot;#define CLIENT_FIFO (__client_fifo == NULL ? (__client_fifo = alloc_sprintf(&quot;client-fifo-%d&quot;, getpid())) : __client_fifo)#define GET_CLIENT_FIFO(pid) alloc_sprintf(&quot;client-fifo-%d&quot;, pid)#define GLOBAL_NUMBER_FILE &quot;global_number_file&quot;struct client_info { pid_t pid; int incr;};unsigned long long int number = 0;void sync_global(unsigned long long int *old, unsigned long long int *new) { unsigned long long int buf; int global_numberfd = open(GLOBAL_NUMBER_FILE, O_RDWR | O_SYNC | O_CREAT, 0666); if(global_numberfd == -1) FAIL(return;,&quot;&quot;); ssize_t readsize = read(global_numberfd, &amp;buf, sizeof(unsigned long long int)); if(readsize &lt; 0) PRINT_ERROR_STR(&quot;&quot;); lseek(global_numberfd, 0, SEEK_SET); if(old) { if(write(global_numberfd, old, sizeof(unsigned long long int)) != sizeof(unsigned long long int)) PRINT_ERROR_STR(&quot;&quot;); } if(readsize &gt; 0 &amp;&amp; new) *new = buf; close(global_numberfd);}int server_fd;int dummy_fd;void on_server_exit() { close(server_fd); close(dummy_fd); unlink(SERVER_FIFO); sync_global(&amp;number, NULL);}void handler(int sig) { printf(&quot;server, sig:%s\\n&quot;, strsignal(sig)); on_server_exit(); signal(sig, SIG_DFL); raise(sig);}void destroy(int sig) { printf(&quot;server, sig:%s\\n&quot;, strsignal(sig)); on_server_exit(); unlink(GLOBAL_NUMBER_FILE); _exit(0);}int server(int argc, char *argv[]) { atexit(on_server_exit); signal(SIGPIPE, handler); signal(SIGINT, destroy); signal(SIGTERM, destroy); signal(SIGHUP, handler); signal(19, handler); if(mkfifo(SERVER_FIFO, 0666) == -1) ERROR(&quot;&quot;); if((server_fd = open(SERVER_FIFO, O_RDONLY)) == -1) ERROR(&quot;&quot;); if((dummy_fd = open(SERVER_FIFO, O_WRONLY)) == -1) ERROR(&quot;&quot;); // dummyå¯ä»¥é˜²æ­¢è¯»å–åˆ°EOFï¼Œé˜²æ­¢cpuç©ºè½¬ struct client_info buf; ssize_t rd_size; sync_global(NULL, &amp;number); printf(&quot;number = %llu\\n&quot;, number); for(int i = 0 ;; i++) { // dummyå¯ä»¥é˜²æ­¢cpuåœ¨è¿™é‡Œç©ºè½¬ printf(&quot;i = %d\\n&quot;, i); while ((rd_size = read(server_fd, &amp;buf, sizeof(struct client_info))) &gt; 0) { printf(&quot;server: handling request from %d,%d\\n&quot;, buf.pid, buf.incr); char *client_fifo = GET_CLIENT_FIFO(buf.pid); if(access(client_fifo, F_OK | W_OK) != 0) ERROR_EXIT(goto cleanup_noaction;, &quot;&quot;); int client_fd; if ((client_fd = open(client_fifo, O_WRONLY | O_NONBLOCK)) == -1) ERROR_EXIT(goto cleanup_noaction;, &quot;&quot;); //é˜²æ­¢é˜»å¡ int flag; if((flag = fcntl(client_fd, F_GETFL)) == -1) ERROR_EXIT(goto cleanup;, &quot;&quot;); flag &amp;= ~O_NONBLOCK; // å»æ‰O_NONBLOCK if(fcntl(client_fd, F_SETFL, flag) == -1) ERROR_EXIT(goto cleanup;, &quot;&quot;); // writeä½¿ç”¨é˜»å¡è¯­ä¹‰ sigset_t sigset, oldset; if(sigemptyset(&amp;sigset) == -1) ERROR_EXIT(goto cleanup_nomask;, &quot;&quot;); if(sigemptyset(&amp;oldset) == -1) ERROR_EXIT(goto cleanup_nomask;, &quot;&quot;); if(sigaddset(&amp;sigset, SIGPIPE) == -1) ERROR_EXIT(goto cleanup_nomask;, &quot;&quot;); if(sigprocmask(SIG_SETMASK, &amp;sigset, &amp;oldset) == -1) ERROR_EXIT(goto cleanup_nomask;, &quot;&quot;); //å†™å…¥ç«¯æ²¡æ‰“å¼€ï¼Œäº§ç”ŸSIGPIPEå’ŒEPIPEï¼Œå±è”½SIGPIPE if (write(client_fd, &amp;(unsigned long long int[1]) {number}, sizeof(unsigned long long int[1])) != sizeof(unsigned long long int[1])) ERROR_EXIT(goto cleanup;, &quot;&quot;); number += buf.incr; cleanup: if(sigprocmask(SIG_SETMASK, &amp;oldset, NULL) == -1) ERROR_EXIT(goto cleanup;, &quot;&quot;); // è¿˜åŸ cleanup_nomask: sync_global(&amp;number, NULL); close(client_fd); cleanup_noaction: safe_free(client_fifo); } if(rd_size &lt; 0) ERROR(&quot;&quot;); } return 0;}int client(int argc, char *argv[]) { int client_fd; if((server_fd = open(SERVER_FIFO, O_WRONLY)) == -1) ERROR(&quot;&quot;); if(mkfifo(CLIENT_FIFO, 0666) == -1) ERROR(&quot;&quot;); struct client_info info = { .incr=atoi(argv[1]), .pid=getpid() }; printf(&quot;client write\\n&quot;); if(write(server_fd, &amp;info, sizeof(struct client_info)) != sizeof(struct client_info)) { ERROR(&quot;&quot;); } unsigned long long int n; printf(&quot;client read\\n&quot;); printf(&quot;client open1\\n&quot;); if((client_fd = open(CLIENT_FIFO, O_RDONLY)) == -1) ERROR(&quot;&quot;); if(read(client_fd, &amp;n, sizeof(unsigned long long int)) != sizeof(unsigned long long int)) { ERROR(&quot;&quot;); } printf(&quot;get id: %llu\\n&quot;, n); close(server_fd); close(client_fd); unlink(CLIENT_FIFO);}int malicious(int argc, char *argv[]) { if((server_fd = open(SERVER_FIFO, O_WRONLY)) == -1) ERROR(&quot;&quot;); if(mkfifo(CLIENT_FIFO, 0666) == -1) ERROR(&quot;&quot;); struct client_info info = { .incr=atoi(argv[1]), .pid=getpid() }; printf(&quot;client write\\n&quot;); if(write(server_fd, &amp;info, sizeof(struct client_info)) != sizeof(struct client_info)) { ERROR(&quot;&quot;); }}int main(int argc, char *argv[]) { argv++; argc--; if(!strcmp(&quot;server&quot;, argv[0])) { server(argc, argv); } else if(!strcmp(&quot;client&quot;, argv[0])) { client(argc, argv); } else if (!strcmp(&quot;malicious&quot;, argv[0])) { malicious(argc, argv); } return 0;} 44.5ç¨‹åºæ¸…å•44-7ä¸­çš„æœåŠ¡å™¨(fifoseqnum_server.c)åœ¨ FIFOä¸Šæ‰§è¡Œç¬¬äºŒæ¬¡å¸¦O_WRONLYæ ‡è®°çš„æ‰“å¼€æ“ä½œä½¿ä¹‹åœ¨ä»FIFOçš„è¯»å–æè¿°ç¬¦(serverFd)ä¸­è¯»å–æ•°æ®æ—¶æ°¸è¿œä¸ä¼šçœ‹åˆ°æ–‡ä»¶ç»“æŸã€‚é™¤äº†è¿™ç§åšæ³•ä¹‹å¤–ï¼Œè¿˜å¯ä»¥å°è¯•å¦ä¸€ç§æ–¹æ³•:å½“æœåŠ¡å™¨åœ¨è¯»å–æè¿°ç¬¦ä¸­çœ‹åˆ°æ–‡ä»¶ç»“æŸæ—¶å…³é—­è¿™ä¸ªæè¿°ç¬¦ï¼Œç„¶åå†æ¬¡æ‰“å¼€ FIFOä»¥ä¾¿è¯»å–æ•°æ®ã€‚(è¿™ä¸ªæ‰“å¼€æ“ä½œå°†ä¼šé˜»å¡ç›´åˆ°ä¸‹ä¸€ä¸ªå®¢æˆ·ç«¯å› å†™å…¥è€Œæ‰“å¼€FIFOä¸ºæ­¢ã€‚è¿™ç§æ–¹æ³•é”™åœ¨å“ªé‡Œäº†? å¢åŠ ä¸å¿…è¦çš„ç³»ç»Ÿè°ƒç”¨ï¼Œå¯¼è‡´é¢å¤–çš„ç³»ç»Ÿå¼€é”€ è‹¥serverçš„ä¼˜å…ˆçº§è¾ƒä½ï¼Œopenå§‹ç»ˆæ— æ³•è°ƒç”¨ï¼Œåˆ™clientä¹Ÿä¼šé˜»å¡åœ¨openä¸Š åœ¨è¯»åˆ°EOFä¸ä¸‹ä¸€æ¬¡openä¹‹é—´ï¼Œå¯èƒ½æœ‰å…¶ä»–è¿›ç¨‹å‘FIFOä¸­å†™å…¥æ•°æ®ï¼Œå¯¼è‡´è¿™äº›è¿›ç¨‹æ— æ³•å¾—åˆ°æœåŠ¡ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191//// Created by root on 8/29/23.//#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt);}#define ERROR_EXIT(ret, msg...) do { error(__FILE__, __LINE__, msg); ret } while(0)#define ERROR(msg...) ERROR_EXIT(exit(1);, msg)#define FAIL(ret, msg...) ERROR_EXIT(ret, msg)#define PRINT_ERROR_STR(msg...) FAIL(;, msg)#define safe_free(ptr) do { if(ptr) { free(ptr); ptr = NULL;} } while(0)char *alloc_sprintf(const char * __format, ...) { va_list fmt; va_start(fmt, __format); int len = vsnprintf(NULL, 0, __format, fmt); va_end(fmt); char *str = malloc(len+1); if(str == NULL) ERROR(&quot;&quot;); va_start(fmt, __format); vsnprintf(str, len+1, __format, fmt); va_end(fmt); return str;}char *__client_fifo = NULL;void __attribute__((destructor)) cleanup() { // atexitæ›´åˆé€‚ safe_free(__client_fifo);}#define SERVER_FIFO &quot;server-fifo&quot;#define CLIENT_FIFO (__client_fifo == NULL ? (__client_fifo = alloc_sprintf(&quot;client-fifo-%d&quot;, getpid())) : __client_fifo)#define GET_CLIENT_FIFO(pid) alloc_sprintf(&quot;client-fifo-%d&quot;, pid)#define GLOBAL_NUMBER_FILE &quot;global_number_file&quot;struct client_info { pid_t pid; int incr;};unsigned long long int number = 0;void sync_global(unsigned long long int *old, unsigned long long int *new) { unsigned long long int buf; int global_numberfd = open(GLOBAL_NUMBER_FILE, O_RDWR | O_SYNC | O_CREAT, 0666); if(global_numberfd == -1) FAIL(return;,&quot;&quot;); ssize_t readsize = read(global_numberfd, &amp;buf, sizeof(unsigned long long int)); if(readsize &lt; 0) PRINT_ERROR_STR(&quot;&quot;); lseek(global_numberfd, 0, SEEK_SET); if(old) { if(write(global_numberfd, old, sizeof(unsigned long long int)) != sizeof(unsigned long long int)) PRINT_ERROR_STR(&quot;&quot;); } if(readsize &gt; 0 &amp;&amp; new) *new = buf; close(global_numberfd);}int server_fd;int dummy_fd;void on_server_exit() { close(server_fd); close(dummy_fd); unlink(SERVER_FIFO); sync_global(&amp;number, NULL);}void handler(int sig) { printf(&quot;server, sig:%s\\n&quot;, strsignal(sig)); on_server_exit(); signal(sig, SIG_DFL); raise(sig);}void destroy(int sig) { printf(&quot;server, sig:%s\\n&quot;, strsignal(sig)); on_server_exit(); unlink(GLOBAL_NUMBER_FILE); _exit(0);}int server(int argc, char *argv[]) { atexit(on_server_exit); signal(SIGPIPE, handler); signal(SIGINT, destroy); signal(SIGTERM, destroy); signal(SIGHUP, handler); signal(19, handler); if(mkfifo(SERVER_FIFO, 0666) == -1) ERROR(&quot;&quot;);// if((server_fd = open(SERVER_FIFO, O_RDONLY)) == -1) ERROR(&quot;&quot;);// if((dummy_fd = open(SERVER_FIFO, O_WRONLY)) == -1) ERROR(&quot;&quot;); // dummyå¯ä»¥é˜²æ­¢è¯»å–åˆ°EOFï¼Œé˜²æ­¢cpuç©ºè½¬ struct client_info buf; ssize_t rd_size; sync_global(NULL, &amp;number); printf(&quot;number = %llu\\n&quot;, number); for(int i = 0 ;; i++) { // dummyå¯ä»¥é˜²æ­¢cpuåœ¨è¿™é‡Œç©ºè½¬ if((server_fd = open(SERVER_FIFO, O_RDONLY)) == -1) ERROR(&quot;&quot;); printf(&quot;i = %d\\n&quot;, i); while ((rd_size = read(server_fd, &amp;buf, sizeof(struct client_info))) &gt; 0) { printf(&quot;server: handling request from %d,%d\\n&quot;, buf.pid, buf.incr); char *client_fifo = GET_CLIENT_FIFO(buf.pid); if(access(client_fifo, F_OK | W_OK) != 0) ERROR_EXIT(goto cleanup_noaction;, &quot;&quot;); int client_fd; if ((client_fd = open(client_fifo, O_WRONLY | O_NONBLOCK)) == -1) ERROR_EXIT(goto cleanup_noaction;, &quot;&quot;); //é˜²æ­¢é˜»å¡ int flag; if((flag = fcntl(client_fd, F_GETFL)) == -1) ERROR_EXIT(goto cleanup;, &quot;&quot;); flag &amp;= ~O_NONBLOCK; // å»æ‰O_NONBLOCK if(fcntl(client_fd, F_SETFL, flag) == -1) ERROR_EXIT(goto cleanup;, &quot;&quot;); // writeä½¿ç”¨é˜»å¡è¯­ä¹‰ sigset_t sigset, oldset; if(sigemptyset(&amp;sigset) == -1) ERROR_EXIT(goto cleanup_nomask;, &quot;&quot;); if(sigemptyset(&amp;oldset) == -1) ERROR_EXIT(goto cleanup_nomask;, &quot;&quot;); if(sigaddset(&amp;sigset, SIGPIPE) == -1) ERROR_EXIT(goto cleanup_nomask;, &quot;&quot;); if(sigprocmask(SIG_SETMASK, &amp;sigset, &amp;oldset) == -1) ERROR_EXIT(goto cleanup_nomask;, &quot;&quot;); //å†™å…¥ç«¯æ²¡æ‰“å¼€ï¼Œäº§ç”ŸSIGPIPEå’ŒEPIPEï¼Œå±è”½SIGPIPE if (write(client_fd, &amp;(unsigned long long int[1]) {number}, sizeof(unsigned long long int[1])) != sizeof(unsigned long long int[1])) ERROR_EXIT(goto cleanup;, &quot;&quot;); number += buf.incr; cleanup: if(sigprocmask(SIG_SETMASK, &amp;oldset, NULL) == -1) ERROR_EXIT(goto cleanup;, &quot;&quot;); // è¿˜åŸ cleanup_nomask: sync_global(&amp;number, NULL); close(client_fd); cleanup_noaction: safe_free(client_fifo); } sleep(1); close(server_fd); if(rd_size &lt; 0) ERROR(&quot;&quot;); } return 0;}void clientdestroy(int sig) { printf(&quot;client %d, sig:%s\\n&quot;, getpid(), strsignal(sig)); unlink(CLIENT_FIFO); signal(sig, SIG_DFL); raise(sig);}int client(int argc, char *argv[]) { int client_fd; signal(SIGHUP, clientdestroy); setbuf(stdout, NULL); printf(&quot;client %d open\\n&quot;, getpid()); if((server_fd = open(SERVER_FIFO, O_WRONLY)) == -1) ERROR(&quot;&quot;); if(mkfifo(CLIENT_FIFO, 0666) == -1) ERROR(&quot;&quot;); struct client_info info = { .incr=atoi(argv[1]), .pid=getpid() }; printf(&quot;client %d write\\n&quot;, getpid()); if(write(server_fd, &amp;info, sizeof(struct client_info)) != sizeof(struct client_info)) { ERROR(&quot;&quot;); } unsigned long long int n; printf(&quot;client %d read\\n&quot;, getpid()); printf(&quot;client %d open1\\n&quot;, getpid()); if((client_fd = open(CLIENT_FIFO, O_RDONLY)) == -1) ERROR(&quot;&quot;); if(read(client_fd, &amp;n, sizeof(unsigned long long int)) != sizeof(unsigned long long int)) { ERROR(&quot;&quot;); } printf(&quot;client %d get id: %llu\\n&quot;, getpid(), n); close(server_fd); close(client_fd); unlink(CLIENT_FIFO);}int main(int argc, char *argv[]) { argv++; argc--; if(!strcmp(&quot;server&quot;, argv[0])) { server(argc, argv); } else if(!strcmp(&quot;client&quot;, argv[0])) { client(argc, argv); } return 0;} 123killall -HUP practice44.5../practice44.5 server &amp; &gt; logfor i in `seq 20`; do ../practice44.5 client $i &amp;&amp; hexdump global_number_file &amp; done &gt; log é€šè¿‡åˆ†ælogå¯ä»¥ç›´åˆ°ï¼Œclientå®¹æ˜“é•¿æœŸé˜»å¡åœ¨å¯¹CLIENT_FIFOçš„openä¸Šï¼Œä¹Ÿå°±æ˜¯serveræ”¶åˆ°è¯·æ±‚ï¼Œä½†æ˜¯clientæ²¡æœ‰æ‰“å¼€è¯»å–ç«¯ï¼Œå¯¼è‡´serveræ²¡æœ‰å†™å…¥è¿”å›æ•°æ®ï¼Œç¨åclienté˜»å¡åœ¨ç¬¬äºŒä¸ªopenä¸Šï¼Œç­‰å¾…serverã€‚","link":"/home/2023/08/30/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha44/"},{"title":"cha45.System V IPC","text":"45.1 45.2 ç¼–å†™ä¸€ä¸ªç¨‹åºæ¥éªŒè¯ftok0æ‰€é‡‡ç”¨çš„ç®—æ³•æ˜¯å¦å¦‚45.2èŠ‚ä¸­æè¿°çš„é‚£æ ·ä½¿ç”¨äº†æ–‡ä»¶çš„i-nodeå·ã€æ¬¡è¦è®¾å¤‡å·ä»¥åŠprojå€¼ã€‚(é€šè¿‡å‡ ä¸ªä¾‹å­æ‰“å°å‡ºæ‰€æœ‰è¿™äº›å€¼ä»¥åŠftokçš„è¿”å›å€¼çš„åå…­è¿›åˆ¶å½¢å¼å³å¯)ã€‚ å®ç°ftok 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//// Created by root on 8/30/23.//#define _GNU_SOURCE /* See feature_test_macros(7) */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/ipc.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt);}#define ERROR_EXIT(ret, msg...) do { error(__FILE__, __LINE__, msg); ret } while(0)#define ERROR(msg...) ERROR_EXIT(exit(1);, msg)#define FAIL(ret, msg...) ERROR_EXIT(ret, msg)#define PRINT_ERROR_STR(msg...) FAIL(;, msg)key_t _ftok(const char *file, int proj) { struct statx filestat; int dirfd = open(&quot;.&quot;, O_RDONLY); if(statx(dirfd, file, 0, 0, &amp;filestat) == -1) FAIL(return -1;, &quot;&quot;); close(dirfd); return ((proj&amp;0xff) &lt;&lt; 24) | ((filestat.stx_dev_minor &amp; 0xff) &lt;&lt; 16) | ((filestat.stx_ino &amp; 0xffff));}int main(int argc, char **argv) { char *file = argv[1]; struct statx filestat; int dirfd = open(&quot;.&quot;, O_RDONLY); if(statx(dirfd, file, 0, 0, &amp;filestat) == -1) ERROR(&quot;&quot;); for(int proj = 1; proj &lt;= 255; proj++) { printf(&quot;proj:%02X, dev:%02X, i-node:%04X, &quot;, proj, filestat.stx_dev_minor &amp; 0xff, filestat.stx_ino &amp; 0xffff); printf(&quot;ftok:%08X\\n&quot;, ftok(file, proj)); printf(&quot;_ftok:%08X\\n&quot;, _ftok(file, proj)); } close(dirfd);} 45.3éªŒè¯(é€šè¿‡å®éªŒ)45.5èŠ‚ä¸­æœ‰å…³ç”¨äºç”ŸæˆSystem VIPCæ ‡è¯†ç¬¦çš„ç®—æ³•çš„å£°æ˜ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738#define _GNU_SOURCE /* See feature_test_macros(7) */#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#define IPCMNI 32768int main(int argc, char *argv[]) { key_t key = ftok(argv[0], 0x6a); int id = msgget(key, IPC_CREAT | 0666), calid; struct msqid_ds msqidDs; msgctl(id, IPC_STAT, &amp;msqidDs); calid = msqidDs.msg_perm.__seq * IPCMNI; FILE *filemsg = fopen(&quot;/proc/sysvipc/msg&quot;, &quot;r&quot;); char msgline[2048]; int index = 0; fgets(msgline, 2048, filemsg); key_t keyi; do { char *nextline = fgets(msgline, 2048, filemsg); if (nextline == NULL) { break; } sscanf(nextline, &quot;%ld&quot;, &amp;keyi); index++; } while (keyi != key); calid += index; if (calid == id) { printf(&quot;true!\\n&quot;); } else { printf(&quot;false?\\n&quot;); } msgctl(id, IPC_RMID, &amp;msqidDs);} indexè·å–çš„ä¸å¯¹ï¼Œæ²¡åŠæ³•ç›´æ¥è¯»å†…æ ¸å†…å­˜ä¸­çš„é‚£ä¸ªæ•°æ® æ›´æ–°è·å–indexçš„æ–¹æ³•,msgctlçš„cmdä½¿ç”¨IPC_INFO 12345678910111213141516171819202122232425#define _GNU_SOURCE /* See feature_test_macros(7) */#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#define IPCMNI 32768int main(int argc, char *argv[]) { key_t key = ftok(argv[0], 0x6a); int id = msgget(key, IPC_CREAT | 0666), calid; struct msqid_ds msqidDs; int index = msgctl(id, IPC_INFO, &amp;msqidDs); msgctl(id, IPC_STAT, &amp;msqidDs); calid = index + msqidDs.msg_perm.__seq * IPCMNI; if (calid == id) { printf(&quot;true!\\n&quot;); } else { printf(&quot;false?\\n&quot;); } msgctl(id, IPC_RMID, &amp;msqidDs);}","link":"/home/2023/08/30/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha45/"},{"title":"cha47.System V ä¿¡å·é‡","text":"47.2 47.3 47.4 ä½¿ç”¨ä¿¡å·é‡ï¼Œå®ç°è¿›ç¨‹é—´çš„åŒæ­¥ éªŒè¯SEM_UNDOæ˜¯å¦ä¼šæ”¹å˜sempid å®ç°P Væ“ä½œï¼Œå®ç°testPï¼ˆåœ¨ç¨‹åºæ¸…å•47-l0ç»™å‡ºçš„ä»£ç (binary_sems.c)ä¸­å¢åŠ ä¸€ä¸ªreserveSemNBOå‡½æ•°æ¥ä½¿ç”¨PC_NOWAITæ ‡è®°å®ç°æœ‰æ¡ä»¶çš„é¢„ç•™æ“ä½œã€‚ï¼‰123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdbool.h&gt;#include &lt;stddef.h&gt;#include &lt;syslog.h&gt;#include &lt;wait.h&gt;#define DEBUG_LEVEL LOG_DEBUG#ifndef DEBUG_LEVEL#define DEBUG_LEVEL LOG_INFO#endifFILE *logfile = NULL;bool syslog_enable = false;#define alloc_sprintf(__alloc_sprintf_str, __format...) do { \\ int __alloc_sprintf_len = snprintf(NULL, 0, __format); \\ (__alloc_sprintf_str) = malloc(__alloc_sprintf_len+1); \\ if(__alloc_sprintf_str != NULL) \\ snprintf(__alloc_sprintf_str, __alloc_sprintf_len+1, __format); \\} while(0)#define logger(level, msg...) do { \\ if(level &lt;= DEBUG_LEVEL) { \\ fprintf(logfile, msg); \\ fprintf(logfile, &quot;\\n&quot;); \\ } \\ if(syslog_enable) { \\ char *data; \\ alloc_sprintf(data, msg); \\ syslog(level, &quot;%s&quot;, data); \\ safe_free(data); \\ } \\} while(0)#define COND_RET(x, ret, msg...) \\ do { \\ if(!(x)) { \\ if(errno == 0)logger(LOG_ERR, &quot;%s:%d\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__, #x); \\ else logger(LOG_ERR, &quot;%s:%d\\nerror: %s\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__,strerror(errno), #x); \\ logger(LOG_ERR, msg); \\ logger(LOG_ERR, &quot;\\n&quot;); \\ ret \\ } \\ } while(0)#define CHECK(x, msg...) COND_RET(x, return -1;, msg)#define CHECK_EXIT(x, msg...) COND_RET(x, exit(EXIT_FAILURE);, msg)#define CHECK_LOG(x, msg...) COND_RET(x, ;, msg)#define safe_free(__safe_free_ptr) do { if(__safe_free_ptr) { free(__safe_free_ptr); (__safe_free_ptr) = NULL;} } while(0)#define BUFFER_SIZE 4096key_t sem_key = 0;int sem_id = 0;void rmsem() { CHECK_LOG(semctl(sem_id, 0, IPC_RMID) != -1, &quot;&quot;);}union semun { int val; struct semid_ds *buf; unsigned short *array;#if defined(__linux__) struct seminfo *__buf;#endif};pid_t taskid = 0;int safe_atoi(const char *num) { const char *ptr = num; while (ptr &amp;&amp; *ptr) { CHECK_EXIT(*ptr &gt;= '0' &amp;&amp; *ptr &lt;= '9', &quot;&quot;); ptr++; } return atoi(num);}int incrsem(int semnum, short incr, short flg) { struct sembuf sembuf; sembuf = (struct sembuf){ .sem_num=semnum, .sem_flg=flg, .sem_op=incr }; return semop(sem_id, &amp;sembuf, 1);}void siginthandler(int sig) { rmsem();}int initAvai(int semnum) { union semun arg; arg.val = 1; if(semctl(sem_id, semnum, SETVAL, arg) == -1) return -1; return incrsem(semnum, 1, 0);}int initInUse(int semnum) { union semun arg; arg.val = 0; if(semctl(sem_id, semnum, SETVAL, arg) == -1) return -1; return incrsem(semnum, 0, 0);}int P(int semnum) { int ret; do { ret = incrsem(semnum, -1, 0); } while (ret == -1 &amp;&amp; errno == EINTR); return ret;}int testP(int semnum) { // return 1 if sem would be blocked, return 0 if sem would not be blocked. int ret = incrsem(semnum, -1, IPC_NOWAIT); if(ret == -1) { if(errno == EAGAIN)return 1; else return ret; } return 0;}int V(int semnum) { return incrsem(semnum, 1, 0);}void init(int argc, char *argv[]) { logfile = stderr; sem_key = ftok(argv[0], 'x');// taskid = safe_atoi(argv[1]); // 1, 2 taskid = fork(); logger(LOG_INFO, &quot;PID = %ld, taskID = %d&quot;, (long)getpid(), taskid); CHECK_EXIT(taskid != -1, &quot;&quot;); union semun arg; if((sem_id = semget(sem_key, 3, IPC_CREAT | IPC_EXCL | 0666)) != -1) { atexit(rmsem); signal(SIGINT, siginthandler); arg.array = (unsigned short *)&amp;(unsigned short[]){0, 0, 0}; // sem[0] = 1, sem[1] = 0 CHECK_EXIT(semctl(sem_id, 0, SETALL, arg) != -1, &quot;&quot;); CHECK_EXIT(initInUse(1) != -1, &quot;&quot;); CHECK_EXIT(initAvai(0) != -1, &quot;&quot;); } else { if(errno != EEXIST) { CHECK_EXIT(false, &quot;&quot;); } sem_id = semget(sem_key, 3, 0666); } struct semid_ds ds; arg.buf = &amp;ds; CHECK_EXIT(semctl(sem_id, 0, IPC_STAT, arg) != -1, &quot;&quot;); while (ds.sem_otime == 0) { logger(LOG_INFO, &quot;waiting for sem init&quot;); sleep(1); CHECK_EXIT(semctl(sem_id, 0, IPC_STAT, arg) != -1, &quot;&quot;); } logger(LOG_INFO, &quot;finish init. PID = %ld, taskID = %d&quot;, (long)getpid(), taskid);}pid_t printsem(int semnum) { pid_t pid; CHECK_EXIT((pid = semctl(sem_id, semnum, GETPID)) != -1, &quot;&quot;); logger(LOG_INFO, &quot;semnum=%d, last semop pid=%ld&quot;, semnum, (long) pid); return pid;}int main(int argc, char *argv[]) { init(argc, argv); switch (taskid) { case 0: CHECK_EXIT(P(2) != -1, &quot;&quot;); CHECK_EXIT(incrsem(0, -1, SEM_UNDO) != -1, &quot;&quot;); CHECK_EXIT(V(1) != -1, &quot;&quot;); CHECK_EXIT(P(2) != -1, &quot;&quot;); break; default: printsem(0); CHECK_EXIT(V(2) != -1, &quot;&quot;); CHECK_EXIT(P(1) != -1, &quot;&quot;); printsem(0); CHECK_EXIT(incrsem(0, 1, 0) != -1, &quot;&quot;); printsem(0); CHECK_EXIT(V(2) != -1, &quot;&quot;); wait(NULL); pid_t lastpid = printsem(0); if(lastpid == taskid) { logger(LOG_INFO, &quot;IPC_UNDO will change last pid&quot;); } else if (lastpid == getpid()) { logger(LOG_INFO, &quot;IPC_UNDO will not change last pid&quot;); } else { logger(LOG_INFO, &quot;other process change sem&quot;); } break; }} 47.6ä½¿ç”¨å‘½åç®¡é“å®ç°ä¸€ä¸ªäºŒå…ƒä¿¡å·é‡åè®®ã€‚æä¾›å‡½æ•°æ¥é¢„ç•™ã€é‡Šæ”¾ä»¥åŠæœ‰æ¡ä»¶åœ°é¢„ç•™ä¿¡å·é‡ã€‚ éœ€è¦å…±äº«fd123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203//// Created by root on 9/13/23.//#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;stdbool.h&gt;#include &lt;stddef.h&gt;#include &lt;syslog.h&gt;#include &lt;wait.h&gt;#include &lt;sys/stat.h&gt;#define DEBUG_LEVEL LOG_DEBUG#ifndef DEBUG_LEVEL#define DEBUG_LEVEL LOG_INFO#endifFILE *logfile = NULL;bool syslog_enable = false;void __attribute__ ((constructor)) init() { logfile = stderr;}#define alloc_sprintf(__alloc_sprintf_str, __format...) do { \\ int __alloc_sprintf_len = snprintf(NULL, 0, __format); \\ (__alloc_sprintf_str) = malloc(__alloc_sprintf_len+1); \\ if(__alloc_sprintf_str != NULL) \\ snprintf(__alloc_sprintf_str, __alloc_sprintf_len+1, __format); \\} while(0)#define logger(level, msg...) do { \\ if(level &lt;= DEBUG_LEVEL) { \\ fprintf(logfile, msg); \\ fprintf(logfile, &quot;\\n&quot;); \\ } \\ if(syslog_enable) { \\ char *data; \\ alloc_sprintf(data, msg); \\ syslog(level, &quot;%s&quot;, data); \\ safe_free(data); \\ } \\} while(0)#define COND_RET(x, ret, msg...) \\ do { \\ if(!(x)) { \\ if(errno == 0)logger(LOG_ERR, &quot;%s:%d\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__, #x); \\ else logger(LOG_ERR, &quot;%s:%d\\nerror: %s\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__,strerror(errno), #x); \\ logger(LOG_ERR, msg); \\ logger(LOG_ERR, &quot;\\n&quot;); \\ ret \\ } \\ } while(0)#define CHECK(x, msg...) COND_RET(x, return -1;, msg)#define CHECK_EXIT(x, msg...) COND_RET(x, exit(EXIT_FAILURE);, msg)#define CHECK_LOG(x, msg...) COND_RET(x, ;, msg)#define safe_free(__safe_free_ptr) do { if(__safe_free_ptr) { free(__safe_free_ptr); (__safe_free_ptr) = NULL;} } while(0)#define BUFFER_SIZE 4096key_t sem_key = 0;int sem_id = 0;pid_t taskid = 0;int safe_atoi(const char *num) { const char *ptr = num; while (ptr &amp;&amp; *ptr) { CHECK_EXIT(*ptr &gt;= '0' &amp;&amp; *ptr &lt;= '9', &quot;&quot;); ptr++; } return atoi(num);}typedef struct { char id[L_tmpnam]; int rfd, wfd;}PvFifo_t;#include &lt;time.h&gt;PvFifo_t *newPvFifo() { PvFifo_t *pvFifo = malloc(sizeof(PvFifo_t)); char *id; alloc_sprintf(id, &quot;PvFifo%d&quot;, rand()); strcpy(pvFifo-&gt;id, id); pvFifo-&gt;rfd = pvFifo-&gt;wfd = -1; if(mkfifo(id, 0666) == -1) { CHECK_LOG(false, &quot;&quot;); return NULL; } logger(LOG_INFO, &quot;new fifo: %s&quot;, id); return pvFifo;}int P(PvFifo_t *pvFifo) { CHECK(pvFifo != NULL, &quot;pvFifo is NULL&quot;); pvFifo-&gt;wfd = open(pvFifo-&gt;id, O_WRONLY); close(pvFifo-&gt;wfd); close(pvFifo-&gt;rfd); pvFifo-&gt;wfd = -1; return 0;}int V(PvFifo_t *pvFifo) { CHECK(pvFifo != NULL, &quot;pvFifo is NULL&quot;); pvFifo-&gt;rfd = open(pvFifo-&gt;id, O_RDONLY | O_NONBLOCK); return 0;}PvFifo_t *initAvai() { PvFifo_t *pvFifo = newPvFifo(); if(!pvFifo) { CHECK_LOG(false, &quot;&quot;); } else if(V(pvFifo) != 0) { CHECK_LOG(false, &quot;&quot;); safe_free(pvFifo); } logger(LOG_INFO, &quot;init :%s&quot;, pvFifo-&gt;id); return pvFifo;}PvFifo_t *initInUse() { return newPvFifo();}int destroy(PvFifo_t *id) { if(id-&gt;rfd != -1) close(id-&gt;rfd); if(id-&gt;wfd != -1) close(id-&gt;wfd); return unlink(id-&gt;id);}#define CRITICAL_LEN 1024int critial_cnt = -1;int criticalArea[CRITICAL_LEN];PvFifo_t *id = NULL;void rmPvFifo() { if(id) destroy(id);}pthread_t producer_t, consumer_t;void exithandler(int sig) { pthread_kill(producer_t, SIGKILL); pthread_kill(consumer_t, SIGKILL); if(sig == SIGHUP)exit(0); else exit(1);}void *consumer(void *args) { while(1) { int n; bool ok = false; CHECK_EXIT(P(id) != -1, &quot;&quot;); if(critial_cnt &gt;= 0) { n = criticalArea[critial_cnt--]; ok = true; } CHECK_EXIT(V(id) != -1, &quot;&quot;); if(ok) logger(LOG_INFO, &quot;consume: %d&quot;, n); else sleep(1); }}void *producer(void *arg) { atexit(rmPvFifo); while(1) { int n; bool ok = false; CHECK_EXIT(P(id) != -1, &quot;&quot;); if(critial_cnt &lt; CRITICAL_LEN - 1) { critial_cnt++; n = critial_cnt; criticalArea[critial_cnt] = n; ok = true; } CHECK_EXIT(V(id) != -1, &quot;&quot;); if(ok) logger(LOG_INFO, &quot;produce: %d&quot;, n); else sleep(1); }}int main(int argc, char **argv) { srand(time(NULL)); logfile = stderr; id = initAvai(); CHECK_EXIT(id != NULL, &quot;&quot;); signal(SIGHUP, exithandler); signal(SIGTERM, exithandler); signal(SIGALRM, exithandler); alarm(10); pthread_create(&amp;producer_t, NULL, producer, NULL); pthread_create(&amp;consumer_t, NULL, consumer, NULL);// pthread_exit(NULL); pthread_join(producer_t, NULL); pthread_join(consumer_t, NULL);} ä¸éœ€è¦å…±äº«fd123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235//// Created by root on 9/13/23.//#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;stdbool.h&gt;#include &lt;stddef.h&gt;#include &lt;syslog.h&gt;#include &lt;wait.h&gt;#include &lt;sys/stat.h&gt;#define DEBUG_LEVEL LOG_DEBUG#ifndef DEBUG_LEVEL#define DEBUG_LEVEL LOG_INFO#endifFILE *logfile = NULL;bool syslog_enable = false;void __attribute__ ((constructor)) init() { logfile = stderr;}#define alloc_sprintf(__alloc_sprintf_str, __format...) do { \\ int __alloc_sprintf_len = snprintf(NULL, 0, __format); \\ (__alloc_sprintf_str) = malloc(__alloc_sprintf_len+1); \\ if(__alloc_sprintf_str != NULL) \\ snprintf(__alloc_sprintf_str, __alloc_sprintf_len+1, __format); \\} while(0)#define logger(level, msg...) do { \\ if(level &lt;= DEBUG_LEVEL) { \\ fprintf(logfile, msg); \\ fprintf(logfile, &quot;\\n&quot;); \\ } \\ if(syslog_enable) { \\ char *__data; \\ alloc_sprintf(__data, msg); \\ syslog(level, &quot;%s&quot;, __data); \\ safe_free(__data); \\ } \\} while(0)#define COND_RET(x, ret, msg...) \\ do { \\ if(!(x)) { \\ if(errno == 0)logger(LOG_ERR, &quot;%s:%d\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__, #x); \\ else logger(LOG_ERR, &quot;%s:%d\\nerror: %s\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__,strerror(errno), #x); \\ logger(LOG_ERR, msg); \\ logger(LOG_ERR, &quot;\\n&quot;); \\ ret \\ } \\ } while(0)#define CHECK(x, msg...) COND_RET(x, return -1;, msg)#define CHECK_EXIT(x, msg...) COND_RET(x, exit(EXIT_FAILURE);, msg)#define CHECK_LOG(x, msg...) COND_RET(x, ;, msg)#define safe_free(__safe_free_ptr) do { if(__safe_free_ptr) { free(__safe_free_ptr); (__safe_free_ptr) = NULL;} } while(0)#define BUFFER_SIZE 4096key_t sem_key = 0;int sem_id = 0;pid_t taskid = 0;int safe_atoi(const char *num) { const char *ptr = num; while (ptr &amp;&amp; *ptr) { CHECK_EXIT(*ptr &gt;= '0' &amp;&amp; *ptr &lt;= '9', &quot;&quot;); ptr++; } return atoi(num);}typedef struct { char id[L_tmpnam]; int rfd, wfd;}PvFifo_t;int openPvfifo(char *id, int rw) { int fd = open(id, rw | O_NONBLOCK); CHECK(fd != -1, &quot;&quot;); int flag; if((flag = fcntl(fd, F_GETFL)) == -1) { CHECK_LOG(false, &quot;&quot;); close(fd); return -1; } flag &amp;= ~O_NONBLOCK; if(fcntl(fd, F_SETFL, flag) == -1) { CHECK_LOG(false, &quot;&quot;); close(fd); return -1; } return fd;}PvFifo_t *newPvFifo(char *id) { PvFifo_t *pvFifo = malloc(sizeof(PvFifo_t)); strcpy(pvFifo-&gt;id, id); if(mkfifo(id, 0666) == -1) { if(errno != EEXIST) { CHECK_LOG(false, &quot;&quot;); return NULL; } } pvFifo-&gt;rfd = openPvfifo(id, O_RDONLY); pvFifo-&gt;wfd = -1; logger(LOG_INFO, &quot;new fifo: %s&quot;, id); return pvFifo;}int P(PvFifo_t *pvFifo) { CHECK(pvFifo != NULL, &quot;pvFifo is NULL&quot;); int ret = 0; bool buf; if((ret = read(pvFifo-&gt;rfd, &amp;buf, sizeof(bool)) != sizeof(bool))) { CHECK_LOG(false, &quot;&quot;); } else ret = 0; return ret;}int V(PvFifo_t *pvFifo) { CHECK(pvFifo != NULL, &quot;pvFifo is NULL&quot;); pvFifo-&gt;wfd = openPvfifo(pvFifo-&gt;id, O_WRONLY); CHECK(pvFifo-&gt;wfd != -1, &quot;&quot;); int ret = 0; if((ret = write(pvFifo-&gt;wfd, &amp;(bool[]){true}, sizeof(bool)) != sizeof(bool))) { CHECK_LOG(false, &quot;&quot;); } else ret = 0; close(pvFifo-&gt;wfd); return ret;}PvFifo_t *initAvai(char *id) { PvFifo_t *pvFifo = newPvFifo(id); if(!pvFifo) { CHECK_LOG(false, &quot;&quot;); } else if(V(pvFifo) != 0) { CHECK_LOG(false, &quot;&quot;); safe_free(pvFifo); } logger(LOG_INFO, &quot;init :%s&quot;, pvFifo-&gt;id); return pvFifo;}PvFifo_t *initInUse(char *id) { return newPvFifo(id);}int destroy(PvFifo_t *id) { if(id-&gt;rfd != -1) close(id-&gt;rfd); if(id-&gt;wfd != -1) close(id-&gt;wfd); return unlink(id-&gt;id);}PvFifo_t *id = NULL;void rmPvFifo() { if(id) destroy(id);}char *fn = NULL;void exithandler(int sig) { if(fn) unlink(fn); if(sig == SIGHUP)exit(0); else exit(1);}int comm_file;#define MAX 65536void *consumer(void *args) { while(1) { CHECK_EXIT(P(id) != -1, &quot;&quot;); int offset; CHECK_EXIT(pread(comm_file, &amp;offset, sizeof(int), 0) == sizeof(int), &quot;&quot;); if(offset &gt; 1) { int data; CHECK_EXIT(pread(comm_file, &amp;data, sizeof(int), (offset - 1) * sizeof(int)) == sizeof(int), &quot;&quot;); logger(LOG_INFO, &quot;consume: %d&quot;, data); offset--; CHECK_EXIT(pwrite(comm_file, &amp;offset, sizeof(int), 0) == sizeof(int), &quot;&quot;); } else sleep(1); CHECK_EXIT(V(id) != -1, &quot;&quot;); }}void *producer(void *arg) { atexit(rmPvFifo); while(1) { int offset; CHECK_EXIT(P(id) != -1, &quot;&quot;); CHECK_EXIT(pread(comm_file, &amp;offset, sizeof(int), 0) == sizeof(int), &quot;&quot;); if(offset &lt; MAX) { int data = offset; CHECK_EXIT(pwrite(comm_file, &amp;data, sizeof(int), offset * sizeof(int)) == sizeof(int), &quot;&quot;); offset++; CHECK_EXIT(pwrite(comm_file, &amp;offset, sizeof(int), 0) == sizeof(int), &quot;&quot;); logger(LOG_INFO, &quot;produce: %d&quot;, data); } else sleep(1); CHECK_EXIT(V(id) != -1, &quot;&quot;); }}int main(int argc, char **argv) { CHECK_EXIT(argc &gt; 1, &quot;&quot;); id = initAvai(&quot;meoww&quot;); CHECK_EXIT(id != NULL, &quot;&quot;); signal(SIGHUP, exithandler); signal(SIGTERM, exithandler); signal(SIGINT, exithandler); signal(SIGALRM, exithandler); alloc_sprintf(fn, &quot;%s-comm&quot;, argv[0]); comm_file = open(fn, O_CREAT | O_EXCL | O_RDWR, 0666); if(comm_file == -1) { if(errno == EEXIST) { comm_file = open(fn, O_RDWR, 0666); } else { CHECK_LOG(false, &quot;&quot;); } } else { CHECK_EXIT(pwrite(comm_file, &amp;(int[]){1}, sizeof(int), 0) == sizeof(int), &quot;&quot;); } if(!strcmp(argv[1], &quot;producer&quot;)) { producer(NULL); } else { consumer(NULL); }} 47.5åœ¨VMSæ“ä½œç³»ç»Ÿä¸Šï¼ŒDigitalæä¾›äº†ä¸€ç§ç±»ä¼¼äºäºŒå…ƒä¿¡å·é‡çš„åŒæ­¥æ–¹æ³•ï¼Œå®ƒè¢«ç§°ä¸ºäº‹ä»¶æ ‡è®°(event flag)ã€‚ä¸€ä¸ªäº‹ä»¶æ ‡è®°å¯ä»¥å–ä¸¤ä¸ªå€¼clearå’Œset,å¹¶ä¸”åœ¨å…¶ä¹‹ä¸Šå¯ä»¥æ‰§è¡Œä¸‹é¢4ç§æ“ä½œï¼šsetEventFlagæ¥è®¾ç½®æ ‡è®°ï¼›clearEventFlagæ¥æ¸…é™¤æ ‡è®°ï¼›waitForEventFlagé˜»å¡ç›´åˆ°æ ‡è®°è¢«è®¾ç½®ï¼›getFlagStateè·å–æ ‡è®°çš„å½“å‰çŠ¶æ€ã€‚ä½¿ç”¨System Vä¿¡å·é‡ä¸ºäº‹ä»¶æ ‡è®°è®¾è®¡ä¸€ç§å®ç°ã€‚è¿™ä¸ªå®ç°è¦æ±‚ä¸Šé¢æ¯ä¸ªå‡½æ•°éƒ½æ¥æ”¶ä¸¤ä¸ªå‚æ•°ï¼šä¸€ä¸ªæ˜¯ä¿¡å·é‡æ ‡è¯†ç¬¦ï¼Œä¸€ä¸ªæ˜¯ä¿¡å·é‡åºå·ã€‚ï¼ˆåœ¨è€ƒè™‘waitForEventFlagæ“ä½œæ—¶å°†ä¼šå‘ç°ä¸ºclearå’ŒsetçŠ¶æ€å–å€¼ä¸æ˜¯ä¸€ä»¶å®¹æ˜“çš„äº‹æƒ…ã€‚) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349//// Created by root on 9/13/23.//#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;stdbool.h&gt;#include &lt;stddef.h&gt;#include &lt;syslog.h&gt;#include &lt;wait.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;#define DEBUG_LEVEL LOG_DEBUG#ifndef DEBUG_LEVEL#define DEBUG_LEVEL LOG_INFO#endif#define STRING_MSG &quot;MSG&quot;FILE *logfile = NULL;bool syslog_enable = false;void __attribute__ ((constructor)) init() { syslog_enable = false; logfile = stderr;}#define alloc_sprintf(__alloc_sprintf_str, __format...) do { \\ int __alloc_sprintf_len = snprintf(NULL, 0, __format); \\ (__alloc_sprintf_str) = malloc(__alloc_sprintf_len+1); \\ if(__alloc_sprintf_str != NULL) \\ snprintf(__alloc_sprintf_str, __alloc_sprintf_len+1, __format); \\} while(0)#define logger(level, msg...) do { \\ if(level &lt;= DEBUG_LEVEL) { \\ fprintf(logfile, &quot;[%ld] &quot;, (long) getpid()); \\ fprintf(logfile, msg); \\ fprintf(logfile, &quot;\\n&quot;); \\ } \\ if(syslog_enable) { \\ char *data; \\ alloc_sprintf(data, msg); \\ syslog(level, &quot;%s&quot;, data); \\ safe_free(data); \\ } \\} while(0)#define COND_RET(x, ret, msg...) \\ do { \\ if(!(x)) { \\ if(errno != 0) logger(LOG_ERR, &quot;Error(%d): %s&quot;, errno, strerror(errno)); \\ logger(LOG_ERR, &quot;%s:%d&quot;, __FILE__, __LINE__); \\ logger(LOG_ERR, &quot;unmet condition:\\&quot;%s\\&quot;&quot;, #x); \\ logger(LOG_ERR, msg); \\ ret; \\ } \\ errno = 0; \\ } while(0)#define CHECK(x, msg...) COND_RET(x, return -1;, msg)#define CHECK_EXIT(x, msg...) COND_RET(x, exit(EXIT_FAILURE);, msg)#define CHECK_LOG(x, msg...) COND_RET(x, ;, msg)#define safe_free(__safe_free_ptr) do { if(__safe_free_ptr) { free(__safe_free_ptr); (__safe_free_ptr) = NULL;} } while(0)#define BUFFER_SIZE 4096union semun { int val; struct semid_ds *buf; unsigned short *array;#if defined(__linux__) struct seminfo *__buf;#endif};typedef struct { int semid;}EventFlag_t;int incrsem(int sem_id, int semnum, short incr, short flg) { struct sembuf sembuf; sembuf = (struct sembuf){ .sem_num=semnum, .sem_flg=flg, .sem_op=incr }; return semop(sem_id, &amp;sembuf, 1);}int P(int sem_id) { return incrsem(sem_id, 0, -1, 0);}int V(int sem_id) { return incrsem(sem_id, 0, 1, 0);}int waitFor(int sem_id) { return incrsem(sem_id, 1, 0, 0);}int getsem(int sem_id, int semnum, short *n) { union semun arg; int ret = semctl(sem_id, semnum, GETVAL, arg); *n = ret; return ret;}int setsem(int sem_id, int semnum, short n) { union semun arg; arg.val = n; return semctl(sem_id, semnum, SETVAL, arg);}int notifyAll(int sem_id) { return setsem(sem_id, 1, 0);}EventFlag_t *newEventFlag(const char *file, char x) { EventFlag_t eventFlag; key_t key = ftok(file, x); eventFlag.semid = semget(key, 4, IPC_CREAT | IPC_EXCL | 0666); // sem[0] as mutex, sem[1] as notifier, sem[2]|sem[3] as flag union semun arg; if(eventFlag.semid == -1) { if(errno == EEXIST) { eventFlag.semid = semget(key, 4, 0666); COND_RET(eventFlag.semid != -1, return NULL, STRING_MSG); struct semid_ds ds; arg.buf = &amp;ds; COND_RET(semctl(eventFlag.semid, 0, IPC_STAT, arg) != -1, return NULL, STRING_MSG); while (ds.sem_otime == 0) { logger(LOG_INFO, &quot;waiting for sem init&quot;); sleep(1); COND_RET(semctl(eventFlag.semid, 0, IPC_STAT, arg) != -1, return NULL, STRING_MSG); } logger(LOG_INFO, &quot;semget get old&quot;); } else { CHECK_LOG(false, STRING_MSG); return NULL; } } else { arg.array = (unsigned short *)&amp;(unsigned short[]){0, 0, 0, 0}; // sem[0] = 1, sem[1] = 0 if(semctl(eventFlag.semid, 0, SETALL, arg) == -1) { CHECK_LOG(false, STRING_MSG); CHECK_LOG(semctl(eventFlag.semid, 0, IPC_RMID) != -1, STRING_MSG); return NULL; } if(incrsem(eventFlag.semid, 0,1,0) == -1) { CHECK_LOG(false, STRING_MSG); CHECK_LOG(semctl(eventFlag.semid, 0, IPC_RMID) != -1, STRING_MSG); return NULL; } logger(LOG_INFO, &quot;semget create new&quot;); } return memcpy(malloc(sizeof(EventFlag_t)), &amp;eventFlag, sizeof(EventFlag_t));}int setEventFlag(EventFlag_t *eventFlag, int flag) { CHECK(P(eventFlag-&gt;semid) != -1, STRING_MSG); short currentFlag; CHECK(getsem(eventFlag-&gt;semid, 2, &amp;currentFlag) != -1, STRING_MSG); CHECK(setsem(eventFlag-&gt;semid, 2, currentFlag | (flag &amp; 0xffff)) != -1, STRING_MSG); CHECK(getsem(eventFlag-&gt;semid, 3, &amp;currentFlag) != -1, STRING_MSG); CHECK(setsem(eventFlag-&gt;semid, 3, currentFlag | ((flag &gt;&gt; 16) &amp; 0xffff)) != -1, STRING_MSG); CHECK(notifyAll(eventFlag-&gt;semid) != -1, STRING_MSG); CHECK(V(eventFlag-&gt;semid) != -1, STRING_MSG); return 0;}int clearEventFlag(EventFlag_t *eventFlag, int flag) { CHECK(P(eventFlag-&gt;semid) != -1, STRING_MSG); short currentFlag; CHECK(getsem(eventFlag-&gt;semid, 2, &amp;currentFlag) != -1, STRING_MSG); CHECK(setsem(eventFlag-&gt;semid, 2, currentFlag &amp; ~(flag &amp; 0xffff)) != -1, STRING_MSG); CHECK(getsem(eventFlag-&gt;semid, 3, &amp;currentFlag) != -1, STRING_MSG); CHECK(setsem(eventFlag-&gt;semid, 3, currentFlag &amp; ~((flag &gt;&gt; 16) &amp; 0xffff)) != -1, STRING_MSG);// CHECK(notifyAll(eventFlag-&gt;semid) != -1, STRING_MSG); CHECK(V(eventFlag-&gt;semid) != -1, STRING_MSG); return 0;}int __getEventFlag(EventFlag_t *eventFlag, int *flag) { if(flag) { short currentFlag = 0; int ret = 0; CHECK(getsem(eventFlag-&gt;semid, 2, &amp;currentFlag) != -1, STRING_MSG); ret |= currentFlag; CHECK(getsem(eventFlag-&gt;semid, 3, &amp;currentFlag) != -1, STRING_MSG); ret |= currentFlag &lt;&lt; 16; *flag = ret; return 0; } return -1;}int getEventFlag(EventFlag_t *eventFlag, int *flag) { CHECK(P(eventFlag-&gt;semid) != -1, STRING_MSG); CHECK_LOG(__getEventFlag(eventFlag, flag) != -1, STRING_MSG); CHECK(V(eventFlag-&gt;semid) != -1, STRING_MSG); return 0;}#define waitForMethod(eventFlag, flag, method) do { \\ int currentFlag;\\ CHECK(P(eventFlag-&gt;semid) != -1, STRING_MSG);\\ __getEventFlag(eventFlag, &amp;currentFlag); \\ while (method) {\\ CHECK(V(eventFlag-&gt;semid) != -1, STRING_MSG);\\ CHECK(waitFor(eventFlag-&gt;semid) != -1, STRING_MSG);\\ CHECK(P(eventFlag-&gt;semid) != -1, STRING_MSG);\\ __getEventFlag(eventFlag, &amp;currentFlag); \\ }\\ CHECK(V(eventFlag-&gt;semid) != -1, STRING_MSG);\\} while(0)int waitForAny(EventFlag_t *eventFlag, int flag) { waitForMethod(eventFlag, flag, (currentFlag &amp; flag) == 0); return 0;}int waitForAll(EventFlag_t *eventFlag, int flag) { waitForMethod(eventFlag, flag, (currentFlag &amp; flag) != flag); return 0;}void destroyEventFlag(EventFlag_t **eventFlag) { if(eventFlag) { if(*eventFlag) { semctl((*eventFlag)-&gt;semid, 0, IPC_RMID); } safe_free(*eventFlag); }}EventFlag_t *eventFlag = NULL;int safe_atoi(const char *str) { if(!str) { CHECK_LOG(false, &quot;safe atoi, str is null&quot;); fflush(NULL); raise(SIGABRT); } const char *p = str; while(*p) { if(*p &gt; '9' || *p &lt; '0') { CHECK_LOG(false, &quot;safe atoi, not valid char: %c&quot;, *p); fflush(NULL); raise(SIGABRT); } p++; } return atoi(str);}void printFlag(int flag) { logger(LOG_INFO, &quot;printFlag&quot;); int mask = 1; if(mask &amp; flag) logger(LOG_INFO, &quot;%d&quot;, 0); for(int cnt = 1; cnt &lt; 32; cnt++) { mask &lt;&lt;= 1; if(mask &amp; flag) logger(LOG_INFO, &quot;%d&quot;, cnt); }}#define printINT(info, x) logger(LOG_INFO, &quot;(&quot;#info&quot;).&quot;#x&quot;: %d&quot;, (info).x)#define printUINT(info, x) logger(LOG_INFO, &quot;(&quot;#info&quot;).&quot;#x&quot;: %ld&quot;, (info).x)#define printTIME(ds, x) logger(LOG_INFO, &quot;(&quot;#ds&quot;).&quot;#x&quot;: %s&quot;, ctime(&amp;(ds).x))int printInfo(int id) { union semun arg; struct seminfo info; struct semid_ds ds; arg.__buf = &amp;info; CHECK(semctl(id, 0, SEM_INFO, arg) != -1, STRING_MSG); printINT(info, semmap); printINT(info, semmni); printINT(info, semmns); printINT(info, semmnu); printINT(info, semmsl); printINT(info, semopm); printINT(info, semume); printINT(info, semusz); printINT(info, semvmx); printINT(info, semaem); arg.buf = &amp;ds; CHECK(semctl(id, 0, IPC_STAT, arg) != -1, STRING_MSG); printUINT(ds, sem_nsems); printTIME(ds, sem_otime); printTIME(ds, sem_ctime); return 0;}int wrapPrintFlag(int flag, int (*func)(EventFlag_t *, int)) { int currentFlag = 0; CHECK_LOG(getEventFlag(eventFlag, &amp;currentFlag) != -1, STRING_MSG); printFlag(currentFlag); CHECK_LOG((*func)(eventFlag, flag) != -1, STRING_MSG); CHECK_LOG(getEventFlag(eventFlag, &amp;currentFlag) != -1, STRING_MSG); printFlag(currentFlag); return 0;}#define FLAG_RANGE(flg) ((16 &lt;= (flg) &amp;&amp; (flg) &lt; 31) || (0 &lt;= (flg) &amp;&amp; (flg) &lt; 15))#define XXSTRING(s) XSTRING(s) //ä¸å±‚æ•°ç›¸å…³#define XSTRING(s) STRING(s)#define STRING(s) #sint main(int argc, char **argv) { CHECK_EXIT(argc &gt; 1, &quot;Usage: %s destroy|waitAny|waitAll|add|clear|get [flag]&quot;, argv[0]); eventFlag = newEventFlag(argv[0], 'x'); CHECK_EXIT(eventFlag != NULL, STRING_MSG); int flag = 0; for(int i = 2; i &lt; argc; i++) { int flg = safe_atoi(argv[i]); if(!FLAG_RANGE(flg)){ CHECK_LOG(false, &quot;Usage: %s&quot;, XXSTRING(FLAG_RANGE(flg))); continue; } flag |= (1 &lt;&lt; flg); } printInfo(eventFlag-&gt;semid); logger(LOG_INFO, &quot;start %s&quot;, argv[1]); if(!strcmp(argv[1], &quot;waitAny&quot;)) { CHECK_LOG(wrapPrintFlag(flag, waitForAny) != -1, STRING_MSG); } else if(!strcmp(argv[1], &quot;waitAll&quot;)) { CHECK_LOG(wrapPrintFlag(flag, waitForAll) != -1, STRING_MSG); } else if(!strcmp(argv[1], &quot;add&quot;)) { CHECK_LOG(wrapPrintFlag(flag, setEventFlag) != -1, STRING_MSG); } else if(!strcmp(argv[1], &quot;clear&quot;)) { CHECK_LOG(wrapPrintFlag(flag, clearEventFlag) != -1, STRING_MSG); } else if(!strcmp(argv[1], &quot;get&quot;)) { CHECK_LOG(getEventFlag(eventFlag, &amp;flag) != -1, STRING_MSG); printFlag(flag); } else if(!strcmp(argv[1], &quot;destroy&quot;)) { destroyEventFlag(&amp;eventFlag); } else { CHECK_EXIT(false, &quot;Usage: %s waitAny|waitAll|add|clear|get [flag]&quot;, argv[0]); } logger(LOG_INFO, &quot;end %s&quot;, argv[1]);}","link":"/home/2023/09/13/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha47/"},{"title":"cha49.å†…å­˜æ˜ å°„","text":"è¯»ä¹¦ç¬”è®° æ–‡ä»¶æ˜ å°„ åŒ¿åæ˜ å°„ ç§æœ‰æ˜ å°„ è€åˆ˜åƒç‹¬é£Ÿ (æ–‡ä»¶), åˆ«äººå¯ä»¥çœ‹ (è¯»å–åŒä¸€å—å†…å­˜åŒºåŸŸ), ä½†æ˜¯æƒ³åƒ (ä¿®æ”¹, å†™æ—¶å¤åˆ¶)éœ€è¦è‡ªå·±åšä¸€ä»½ä¸€æ¨¡ä¸€æ ·çš„(ä¿®æ”¹ä¸ä¼šååº”åˆ°æ–‡ä»¶ä¸Š) è€åˆ˜åƒç©ºæ°” (å…¨0å¤§å—å†…å­˜), ç»™å„¿å­çœ‹, å„¿å­æƒ³åƒéœ€è¦è‡ªå·±åšä¸€ä»½ä¸€æ ·çš„ (å†™æ—¶å¤åˆ¶), ä¸ç»™è€æå®¶çœ‹, ä¸ç»™è€æå®¶åƒ å…±äº«æ˜ å°„ è€åˆ˜åƒé¥­ (æ–‡ä»¶), ç»™å„¿å­åƒ (å­è¿›ç¨‹å¯è®¿é—® ä¿®æ”¹), ä¹Ÿç»™è€æåƒ (éç›¸å…³è¿›ç¨‹ä¹Ÿå¯è®¿é—® ä¿®æ”¹)(ä¿®æ”¹ä¼šååº”åˆ°æ–‡ä»¶ä¸Š) è€åˆ˜åƒç©ºæ°” (å…¨0å†…å­˜), ç»™å„¿å­åƒ (å­è¿›ç¨‹å¯è®¿é—® ä¿®æ”¹), ä¸ç»™è€æå®¶åƒ (éç›¸å…³è¿›ç¨‹ä¸å¯è®¿é—® ä¿®æ”¹) åˆ›å»ºå…¬å…±å¤´æ–‡ä»¶ä¸ºäº†å‡å°‘æ¯ä¸ªç»ƒä¹ ä¸­é‡å¤çš„å®šä¹‰ï¼Œå¦‚logger, safe_freeï¼Œå®šä¹‰ä¸€ä¸ªå¤´æ–‡ä»¶å…±æ‰€æœ‰ç¨‹åºä½¿ç”¨ utils.hinclude/utils.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#ifndef __MEOW_UTILS__#define __MEOW_UTILS__//// Created by root on 9/14/23.//#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;stdbool.h&gt;#include &lt;stddef.h&gt;#include &lt;syslog.h&gt;#include &lt;wait.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/mman.h&gt;extern FILE *logfile;extern bool syslog_enable;#ifndef DEBUG_LEVEL#define DEBUG_LEVEL LOG_DEBUG#endif#define STRING_MSG &quot;ERROR OCCURED!&quot;#define alloc_sprintf(__alloc_sprintf_str, __format...) do { \\ int __alloc_sprintf_len = snprintf(NULL, 0, __format); \\ (__alloc_sprintf_str) = malloc(__alloc_sprintf_len+1); \\ if(__alloc_sprintf_str != NULL) \\ snprintf(__alloc_sprintf_str, __alloc_sprintf_len+1, __format); \\} while(0)#define logger(level, msg...) do { \\ if(level &lt;= DEBUG_LEVEL) { \\ fprintf(logfile, &quot;[%ld] &quot;, (long) getpid()); \\ fprintf(logfile, msg); \\ fprintf(logfile, &quot;\\n&quot;); \\ } \\ if(syslog_enable) { \\ char *__syslog_enable__data; \\ alloc_sprintf(__syslog_enable__data, msg); \\ syslog(level, &quot;%s&quot;, __syslog_enable__data); \\ safe_free(__syslog_enable__data); \\ } \\} while(0)#define CHECK_RET_MSG_IMPL(x, strx, ret, msg...) \\ logger(LOG_DEBUG, &quot;checking: \\&quot;%s\\&quot;&quot;, strx); \\ do { \\ if(!(x)) { \\ if(errno != 0) logger(LOG_ERR, &quot;Error(%d): %s&quot;, errno, strerror(errno)); \\ logger(LOG_ERR, &quot;%s:%d&quot;, __FILE__, __LINE__); \\ logger(LOG_ERR, &quot;unmet condition:\\&quot;%s\\&quot;&quot;, strx); \\ logger(LOG_ERR, msg); \\ ret; \\ } \\ errno = 0; \\ } while(0)#define CHECK_RET_MSG(x, ret, msg...) CHECK_RET_MSG_IMPL(x, #x, ret, msg...)#define CHECK_MSG(x, msg...) CHECK_RET_MSG_IMPL(x, #x, return -1;, msg)#define CHECK_EXIT_MSG(x, msg...) CHECK_RET_MSG_IMPL(x, #x, exit(EXIT_FAILURE);, msg)#define CHECK_LOG_MSG(x, msg...) CHECK_RET_MSG_IMPL(x, #x, ;, msg)#define CHECK_RET(x, ret) CHECK_RET_MSG_IMPL(x, #x, ret;, STRING_MSG)#define CHECK(x) CHECK_RET_MSG_IMPL(x, #x, return -1;, STRING_MSG)#define CHECK_EXIT(x) CHECK_RET_MSG_IMPL(x, #x, exit(EXIT_FAILURE);, STRING_MSG)#define CHECK_LOG(x) CHECK_RET_MSG_IMPL(x, #x, ;, STRING_MSG)int safe_atoi(const char *num, int *ret);#define safe_free(__safe_free_ptr) do { if(__safe_free_ptr) { free(__safe_free_ptr); (__safe_free_ptr) = NULL;} } while(0)#endif utils.cutils/utils.h12345678910111213141516171819#include &quot;utils.h&quot;FILE *logfile = NULL;bool syslog_enable = false;void __attribute__ ((constructor)) init() { syslog_enable = false; logfile = stderr;}int safe_atoi(const char *num, int *ret) { CHECK(ret != NULL); CHECK(num != NULL); const char *ptr = num; while (*ptr) { CHECK(*ptr &gt;= '0' &amp;&amp; *ptr &lt;= '9'); ptr++; } *ret = atoi(num); return 0;} ç”ŸæˆCMakeLists.txtå¹¶ç¼–è¯‘ä»£ç æ–‡ä»¶å…¨éƒ¨æ”¾å…¥ç›®å½•chaXX/srcä¸‹ï¼Œå¹¶ä¸”ä¸€ä¸ªç»ƒä¹ åªç”¨ä¸€ä¸ªæ–‡ä»¶ build.sh12345678910111213141516171819202122OUTPUT=CMakeLists.txtfunction writer() { echo $@ | tee -a $OUTPUT}rm $OUTPUTwriter &quot;cmake_minimum_required(VERSION 3.25.0)&quot;writer &quot;aux_source_directory(../utils SRC_UTILS)&quot;writer &quot;include_directories(../include)&quot;for file in `ls src`; do out=`echo $file | awk ' { len=split($0, arr, &quot;.&quot;); printf arr[1];for(i = 2; i &lt; len; i++) printf &quot;.&quot;arr[i] } '` writer &quot;add_executable($out src/$file \\${SRC_UTILS})&quot;donefor arg in $@; do if [ ${arg:0:2} == &quot;-D&quot; ]; then writer &quot;ADD_DEFINITIONS($arg)&quot; fidonecmake .make 49.1ä½¿ç”¨mmapå’Œmemcpyè°ƒç”¨(ä¸æ˜¯read0æˆ–write0)ç¼–å†™ä¸€ä¸ªç±»ä¼¼äºcpçš„ç¨‹åºæ¥å°†ä¸€ä¸ªæºæ–‡ä»¶å¤åˆ¶åˆ°ç›®æ ‡æ–‡ä»¶ã€‚ä½¿ç”¨ fstatè·å–è¾“å…¥æ–‡ä»¶çš„å¤§å°ï¼Œç„¶åå¯ä»¥ä½¿ç”¨è¿™ä¸ªå¤§å°æ¥è®¾ç½®æ‰€éœ€çš„å†…å­˜æ˜ å°„çš„å¤§å°ï¼Œä½¿ç”¨ fruncateè®¾ç½®è¾“å‡ºæ–‡ä»¶çš„å¤§å°ã€‚ 12345678910111213141516171819202122232425262728//// Created by root on 9/14/23.//#include &quot;utils.h&quot;int main(int argc, char *argv[]) { CHECK_EXIT(argc == 3, &quot;Usage: %s src dest&quot;, argv[0]); int src_fd = open(argv[1], O_RDONLY); CHECK_EXIT(src_fd != -1, STRING_MSG); int dest_fd = open(argv[2], O_RDWR | O_CREAT, 0666); CHECK_EXIT(dest_fd != -1, STRING_MSG); struct stat src_stat; CHECK_EXIT(fstat(src_fd, &amp;src_stat) != -1, STRING_MSG); CHECK_EXIT(ftruncate(dest_fd, src_stat.st_size) != -1, STRING_MSG); void *src_map = mmap(NULL, src_stat.st_size, PROT_READ, MAP_SHARED, src_fd, 0); void *dest_map = mmap(NULL, src_stat.st_size, PROT_WRITE, MAP_SHARED, dest_fd, 0); memcpy(dest_map, src_map, src_stat.st_size); CHECK_EXIT(close(src_fd) != -1, STRING_MSG); CHECK_EXIT(close(dest_fd) != -1, STRING_MSG); CHECK_EXIT(munmap(src_map, src_stat.st_size) != -1, STRING_MSG); CHECK_EXIT(munmap(dest_map, src_stat.st_size) != -1, STRING_MSG); return 0;} 49.2é‡å†™ç¨‹åºæ¸…å•48-2(svshm_xf_writer.c)å’Œç¨‹åºæ¸…å•48-3(svshm xfr_reader.c)ä½¿å®ƒä»¬ä½¿ç”¨å…±äº«å†…å­˜æ˜ å°„æ¥å–ä»£SystemVå…±äº«å†…å­˜ åˆ›å»ºpvutilå·¥å…·include/pvutils.h123456789101112131415161718192021222324252627282930#ifndef __MEOW_PV_UTILS__#define __MEOW_PV_UTILS__#include &lt;sys/sem.h&gt;#include &lt;sys/ipc.h&gt;union semun { int val; struct semid_ds *buf; unsigned short *array;#if defined(__linux__) struct seminfo *__buf;#endif};int P(int semnum);int testP(int semnum);int V(int semnum);int initPVByFile(const char *filename, char x, int semcnt);int initPVByKey(key_t key, int semcnt);int initAvai(int semnum);int initInUse(int semnum);int rmPV();#endif utils/pvutils.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &quot;pvutils.h&quot;#include &quot;utils.h&quot;static key_t __sem_key = -1;static int __sem_id = -1;int rmPV() { int id = __sem_id; __sem_key = -1; __sem_id = -1; return semctl(id, 0, IPC_RMID);}int incrsem(int semnum, short incr, short flg) { struct sembuf sembuf; sembuf = (struct sembuf){ .sem_num=semnum, .sem_flg=flg, .sem_op=incr }; return semop(__sem_id, &amp;sembuf, 1);}int setVal(int n, int semnum) { union semun arg; arg.val = n; CHECK(semctl(__sem_id, semnum, SETVAL, arg) != -1); return 0;}int initAvai(int semnum) { CHECK(setVal(0, semnum) != -1); CHECK(incrsem(semnum, 1, 0) != -1); return 0;}int initInUse(int semnum) { CHECK(setVal(0, semnum) != -1); CHECK(incrsem(semnum, 0, 0) != -1); return 0;}int P(int semnum) { int ret; do { ret = incrsem(semnum, -1, 0); } while (ret == -1 &amp;&amp; errno == EINTR); return ret;}int testP(int semnum) { // return 1 if sem would be blocked, return 0 if sem would not be blocked. int ret = incrsem(semnum, -1, IPC_NOWAIT); if(ret == -1) { if(errno == EAGAIN)return 1; else return ret; } return 0;}int V(int semnum) { return incrsem(semnum, 1, 0);}int setAll(unsigned short *array) { union semun arg; arg.array = array; CHECK(semctl(__sem_id, 0, SETALL, arg) != -1); return 0;}int __initPV(int semcnt) { semcnt++; // sem[0] for waiting init, sem[1...n] for user if((__sem_id = semget(__sem_key, semcnt, IPC_CREAT | IPC_EXCL | 0666)) != -1) { unsigned short *array = malloc(semcnt * sizeof(unsigned short)); memset(array, 0, semcnt * sizeof(unsigned short)); CHECK(array != NULL); CHECK(setAll(array) != -1); CHECK(initInUse(0) != -1); free(array); } else { CHECK(errno == EEXIST); __sem_id = semget(__sem_key, semcnt, 0666); struct semid_ds ds; union semun arg; arg.buf = &amp;ds; CHECK(semctl(__sem_id, 0, IPC_STAT, arg) != -1); while (ds.sem_otime == 0) { logger(LOG_DEBUG, &quot;waiting for sem init&quot;); sleep(1); CHECK(semctl(__sem_id, 0, IPC_STAT, arg) != -1); } } logger(LOG_DEBUG, &quot;finish init. PID = %ld&quot;, (long)getpid());}int initPVByFile(const char *filename, char x, int semcnt) { __sem_key = ftok(filename, x); if(__initPV(semcnt) == -1) { rmPV(); return -1; } return 0;}int initPVByKey(key_t key, int semcnt) { __sem_key = key; if(__initPV(semcnt) == -1) { rmPV(); return -1; } return 0;} ä¸»ç¨‹åº1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &quot;utils.h&quot;#include &quot;pvutils.h&quot;void handler(int sig) { logger(LOG_INFO, &quot;received signal(%d):%s&quot;, sig, strsignal(sig)); exit(0);}#define BUFFER_SIZE 2048struct MmapStruct { ssize_t len; char buf[BUFFER_SIZE];};void cleanupMmap(int status, void *buf) { CHECK_LOG(munmap(buf, sizeof(struct MmapStruct)) != -1);}void cleanupPV(int status, void *buf) { CHECK_LOG(rmPV() != -1);}int main(int argc, char *argv[]) { CHECK_EXIT_MSG(argc == 3, &quot;Usage: %s writer|reader file&quot;, argv[0]); char *outfile = argv[2]; int fd = open(outfile, O_RDWR | O_CREAT, 0666); CHECK_EXIT(ftruncate(fd, sizeof(struct MmapStruct)) != -1); CHECK_EXIT(fd != -1); CHECK_EXIT(initPVByFile(argv[1], 'a', 2) != -1); signal(SIGINT, handler); signal(SIGTERM, handler); signal(SIGHUP, handler); struct MmapStruct *mmapP = mmap(NULL, sizeof(struct MmapStruct), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);; CHECK_EXIT(mmapP != MAP_FAILED); CHECK_EXIT(close(fd) != -1); on_exit(cleanupMmap, mmapP); on_exit(cleanupPV, NULL); CHECK_EXIT(initAvai(1) != -1); if(!strcmp(argv[1], &quot;writer&quot;)) { size_t size = 0; bool stop = false; for(int i = 0; !stop ;i++) { CHECK_EXIT(P(1) != -1); logger(LOG_INFO, &quot;write start&quot;); CHECK_EXIT((mmapP-&gt;len = read(STDIN_FILENO, mmapP-&gt;buf, BUFFER_SIZE - sizeof(int))) &gt;= 0); size += mmapP-&gt;len; if(mmapP-&gt;len == 0) { stop = true; } CHECK_EXIT(V(2) != -1); logger(LOG_INFO, &quot;write end: i = %d, size = %lu&quot;, i, size); } } else { size_t size = 0; bool stop = false; for(int i = 0; !stop ;i++) { CHECK_EXIT(P(2) != -1); logger(LOG_INFO, &quot;read start&quot;); CHECK_EXIT(write(STDOUT_FILENO, mmapP-&gt;buf, mmapP-&gt;len) == mmapP-&gt;len); size += mmapP-&gt;len; if(mmapP-&gt;len == 0) { stop = true; } CHECK_EXIT(V(1) != -1); logger(LOG_INFO, &quot;read end: i = %d, size = %lu&quot;, i, size); } }} 49.3ç¼–å†™ç¨‹åºéªŒè¯åœ¨49.4.3èŠ‚ä¸­æè¿°çš„æƒ…å†µä¸‹ä¼šäº§ç”ŸSIGBUSå’ŒSIGSEGVä¿¡å· 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &quot;utils.h&quot;#define BUFFER_SIZE 2048void handler(int sig) { logger(LOG_INFO, &quot;received: signal(%d):%s&quot;, sig, strsignal(sig)); CHECK_LOG(signal(sig, SIG_DFL) != SIG_ERR); fflush(NULL); raise(sig); return;}void testcase(const char *file, int filesize, int mmapsize, int access) { pid_t pid; CHECK_RET((pid = fork()) != -1, return;); if(!pid) { CHECK_EXIT(signal(SIGBUS, handler) != SIG_ERR); CHECK_EXIT(signal(SIGSEGV, handler) != SIG_ERR); logger(LOG_INFO, &quot;filesize=%d, mmapsize=%d, access=%d&quot;, filesize, mmapsize, access); int fd = open(file, O_RDWR | O_CREAT | O_SYNC, 0666); // CHECK_EXIT(ftruncate(fd, 0) != -1); // CHECK_EXIT(fsync(fd) != -1); CHECK_EXIT(ftruncate(fd, filesize) != -1); CHECK_EXIT(fsync(fd) != -1); CHECK_EXIT(fd != -1); char *mmapP = mmap(NULL, mmapsize, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); CHECK_EXIT(mmapP != MAP_FAILED); CHECK_EXIT(close(fd) != -1); logger(LOG_INFO, &quot;mmapP=%p, access:%p&quot;, mmapP, (mmapP + access)); mmapP[access] = 'b'; CHECK_LOG(munmap(mmapP, mmapsize) != -1); exit(0); } int status; CHECK_RET(waitpid(pid, &amp;status, 0) != -1, return;); logger(LOG_INFO, &quot;exit status=%d, exit sig=(%d)%s&quot;, WEXITSTATUS(status), WSTOPSIG(status), strsignal(WSTOPSIG(status)));}int main(int argc, char *argv[]) { setbuf(stderr, NULL); setbuf(stdout, NULL); if(argc == 2) { long pagesize = sysconf(_SC_PAGESIZE); logger(LOG_INFO, &quot;pagesize = %ld&quot;, pagesize); testcase(argv[1], pagesize*3, pagesize / 2+pagesize, 0); testcase(argv[1], pagesize*3, pagesize / 2+pagesize, pagesize / 2+pagesize); testcase(argv[1], pagesize*3, pagesize / 2+pagesize, pagesize*2); // sigsegv but do not receive it here testcase(argv[1], pagesize/2, pagesize*2, 0); testcase(argv[1], pagesize/2, pagesize*2, pagesize / 2); testcase(argv[1], pagesize/2, pagesize*2, pagesize); // sigbus testcase(argv[1], pagesize/2, pagesize*2, pagesize*2); // sigsegv but do not receive it here testcase(argv[1], pagesize/2, pagesize, pagesize); // sigsegv } else { CHECK_EXIT_MSG(argc == 5, &quot;Usage: %s filename filesize mmapsize access&quot;, argv[0]); int filesize, mmapsize, access; CHECK_EXIT_MSG(safe_atoi(argv[2], &amp;filesize) != -1, &quot;safe_atoi filesize=%s&quot;, argv[2]); CHECK_EXIT_MSG(safe_atoi(argv[3], &amp;mmapsize) != -1, &quot;safe_atoi mmapsize=%s&quot;, argv[3]); CHECK_EXIT_MSG(safe_atoi(argv[4], &amp;access) != -1, &quot;safe_atoi access=%s&quot;, argv[4]); testcase(argv[1], filesize, mmapsize, access); }} ä¸çŸ¥é“ä¸ºä»€ä¹ˆï¼Œæœ¬åº”å‡ºç°sigsegvçš„åœ°æ–¹å¹¶æ²¡æœ‰æ”¶åˆ°ä¿¡å·ï¼Œåªæœ‰åˆ†é…ä¸€ä¸ªé¡µé¢åè¶Šç•Œçš„æƒ…å†µä¼šäº§ç”Ÿsigsegv 2023å¹´9æœˆ18æ—¥æ›´æ–°äº§ç”Ÿsigsegvçš„æ ¹æœ¬åŸå› æ˜¯è¯•å›¾è®¿é—®æ— æ³•è®¿é—®çš„å†…å­˜åœ°å€ï¼Œç°åœ¨çš„mmapå®ç°å¯èƒ½ä¸ºäº†é€Ÿåº¦ä¸å®‰å…¨çš„è€ƒè™‘ï¼Œä¼šå¤šåˆ†é…ä¸€éƒ¨åˆ†å†…å­˜ã€‚åªè¦åˆ†é…æ—¶å¤šåˆ†é…ä¸€é¡µï¼Œå†å°†å¤šåˆ†é…çš„éƒ¨åˆ†å›æ”¶ï¼Œå°±å¯ä»¥è§¦å‘sigsegväº† 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &quot;utils.h&quot;#define BUFFER_SIZE 2048void handler(int sig) { logger(LOG_INFO, &quot;received: signal(%d):%s&quot;, sig, strsignal(sig)); CHECK_LOG(signal(sig, SIG_DFL) != SIG_ERR); fflush(NULL); raise(sig); return;}int offalign(int off, int size) { return (off%size &gt; 0 ? (size - off%size) : 0);} // ä»¤offä¸sizeå¯¹å…¶æ‰€éœ€çš„è°ƒæ•´é‡long pagesize;void testcase(const char *file, int filesize, int mmapsize, int access) { pid_t pid; CHECK_RET((pid = fork()) != -1, return;); if(!pid) { CHECK_EXIT(signal(SIGBUS, handler) != SIG_ERR); CHECK_EXIT(signal(SIGSEGV, handler) != SIG_ERR); logger(LOG_INFO, &quot;filesize=%d, mmapsize=%d, access=%d&quot;, filesize, mmapsize, access); int fd = open(file, O_RDWR | O_CREAT | O_SYNC, 0666); // CHECK_EXIT(ftruncate(fd, 0) != -1); // CHECK_EXIT(fsync(fd) != -1); CHECK_EXIT(ftruncate(fd, filesize) != -1); CHECK_EXIT(fsync(fd) != -1); CHECK_EXIT(fd != -1); char *mmapP = mmap(NULL, mmapsize+pagesize, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if(offalign(mmapsize,pagesize) &gt; 0) CHECK_LOG(munmap(mmapP+offalign(mmapsize,pagesize) + mmapsize, pagesize) != -1); //mmapå¤šåˆ†é…ä¸€é¡µï¼Œç„¶åæŠŠå¤šåˆ†é…çš„éƒ¨åˆ†å»æ‰ CHECK_EXIT(mmapP != MAP_FAILED); CHECK_EXIT(close(fd) != -1); logger(LOG_INFO, &quot;mmapP=%p, access:%p&quot;, mmapP, (mmapP + access)); mmapP[access] = 'b'; CHECK_LOG(munmap(mmapP, mmapsize) != -1); exit(0); } int status; CHECK_RET(waitpid(pid, &amp;status, 0) != -1, return;); logger(LOG_INFO, &quot;exit status=%d, exit sig=(%d)%s&quot;, WEXITSTATUS(status), WSTOPSIG(status), strsignal(WSTOPSIG(status)));}int main(int argc, char *argv[]) { setbuf(stderr, NULL); setbuf(stdout, NULL); pagesize = sysconf(_SC_PAGESIZE); if(argc == 2) { logger(LOG_INFO, &quot;pagesize = %ld&quot;, pagesize); testcase(argv[1], pagesize*3, pagesize / 2+pagesize, 0); testcase(argv[1], pagesize*3, pagesize / 2+pagesize, pagesize / 2+pagesize); testcase(argv[1], pagesize*3, pagesize / 2+pagesize, pagesize*2); // sigsegv but do not receive it here testcase(argv[1], pagesize/2, pagesize*2, 0); testcase(argv[1], pagesize/2, pagesize*2, pagesize / 2); testcase(argv[1], pagesize/2, pagesize*2, pagesize); // sigbus testcase(argv[1], pagesize/2, pagesize*2, pagesize*2); // sigsegv but do not receive it here testcase(argv[1], pagesize/2, pagesize, pagesize); // sigsegv } else { CHECK_EXIT_MSG(argc == 5, &quot;Usage: %s filename filesize mmapsize access&quot;, argv[0]); int filesize, mmapsize, access; CHECK_EXIT_MSG(safe_atoi(argv[2], &amp;filesize) != -1, &quot;safe_atoi filesize=%s&quot;, argv[2]); CHECK_EXIT_MSG(safe_atoi(argv[3], &amp;mmapsize) != -1, &quot;safe_atoi mmapsize=%s&quot;, argv[3]); CHECK_EXIT_MSG(safe_atoi(argv[4], &amp;access) != -1, &quot;safe_atoi access=%s&quot;, argv[4]); testcase(argv[1], filesize, mmapsize, access); }}","link":"/home/2023/09/16/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha49/"},{"title":"cha46.System V æ¶ˆæ¯é˜Ÿåˆ—","text":"46.2æ”¹é€ 44.8èŠ‚ä¸­çš„åºå·å®¢æˆ·ç«¯-æœåŠ¡å™¨åº”ç”¨ç¨‹åºä½¿ä¹‹ä½¿ç”¨System Væ¶ˆæ¯é˜Ÿåˆ—ã€‚ä½¿ç”¨å•ä¸ªæ¶ˆæ¯é˜Ÿåˆ—æ¥ä¼ è¾“å®¢æˆ·ç«¯åˆ°æœåŠ¡å™¨ä»¥åŠæœåŠ¡å™¨åˆ°å®¢æˆ·ç«¯ä¹‹é—´çš„æ¶ˆæ¯ã€‚ä½¿ç”¨ 46.8èŠ‚ä¸­ä»‹ç»çš„æ¶ˆæ¯ç±»å‹è§„èŒƒã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdbool.h&gt;#include &lt;stddef.h&gt;#include &lt;syslog.h&gt;#include &lt;wait.h&gt;//#define DEBUG_LEVEL LOG_DEBUG#ifndef DEBUG_LEVEL#define DEBUG_LEVEL LOG_INFO#endifFILE *logfile = NULL;void logger(int level, const char *msg, ...) { if(level &lt;= DEBUG_LEVEL) { va_list fmt; va_start(fmt, msg); vfprintf(logfile, msg, fmt); va_end(fmt); fprintf(logfile, &quot;\\n&quot;); }}#define COND_RET(x, ret, msg...) \\ do { \\ errno = 0;\\ if(!(x)) { \\ if(errno == 0)logger(LOG_ERR, &quot;%s:%d\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__, #x); \\ else logger(LOG_ERR, &quot;%s:%d\\nerror: %s\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__,strerror(errno), #x); \\ logger(LOG_ERR, msg); \\ logger(LOG_ERR, &quot;\\n&quot;); \\ ret \\ } \\ } while(0)#define CHECK(x, msg...) COND_RET(x, return -1;, msg)#define CHECK_EXIT(x, msg...) COND_RET(x, exit(1);, msg)#define CHECK_LOG(x, msg...) COND_RET(x, ;, msg)#define safe_free(ptr) do { if(ptr) { free(ptr); ptr = NULL;} } while(0)char *alloc_sprintf(const char * __format, ...) { va_list fmt; va_start(fmt, __format); int len = vsnprintf(NULL, 0, __format, fmt); va_end(fmt); char *str = malloc(len+1); COND_RET(str != NULL, return NULL;, &quot;&quot;); va_start(fmt, __format); vsnprintf(str, len+1, __format, fmt); va_end(fmt); return str;}char *MSQ_KEY_FILE = NULL;#define BUFFER_SIZE 4096static pid_t SELF_PID = -1;static int MSG_ID = -1;#define SERVER_MSG_TYPE 1#define CLIENT_MSG_TYPE SELF_PID#define REQ_TOUCH 1#define REQ_RM 2#define REQ_CAT 3#define REQ_LS 4#define REQ_RDLK 5#define RET_MORE 0x0001#define RET_SUCCESS 0x0010struct ServerReturnType { long mtype; int msgType; char mcontent[BUFFER_SIZE];};struct ClientRequestType { long mtype; int msgType; pid_t pid; char mcontent[BUFFER_SIZE];};#define REQ_SIZE (offsetof(struct ClientRequestType, mcontent) - offsetof(struct ClientRequestType, msgType) + BUFFER_SIZE)#define RET_SIZE (offsetof(struct ServerReturnType, mcontent) - offsetof(struct ServerReturnType, msgType) + BUFFER_SIZE)void atexitCloseLogfile(void) { logger(LOG_DEBUG, &quot;SERVER: atexitCloseLogfile&quot;); CHECK_LOG(fclose(logfile) != -1, &quot;&quot;);}void atexitFreeKeyfile(void) { logger(LOG_DEBUG, &quot;SERVER: atexitFreeKeyfile&quot;); safe_free(MSQ_KEY_FILE);}void atexitRMID(void) { logger(LOG_DEBUG, &quot;SERVER: atexitRMID&quot;); CHECK_LOG(msgctl(MSG_ID, IPC_RMID, NULL) != -1, &quot;&quot;);}void client(const char *filename, int msgType) { struct ServerReturnType ret; struct ClientRequestType req; req.mtype = SERVER_MSG_TYPE; req.msgType = msgType; req.pid = SELF_PID; strcpy(req.mcontent, filename); ssize_t send = msgsnd(MSG_ID, &amp;req, REQ_SIZE, 0); CHECK_EXIT(send != -1, &quot;&quot;); do { ssize_t recv = msgrcv(MSG_ID, &amp;ret, RET_SIZE, CLIENT_MSG_TYPE, 0); CHECK_EXIT(recv != -1, &quot;&quot;); if(ret.msgType &amp; RET_SUCCESS) { printf(&quot;oJBk: &quot;); } else { printf(&quot;fail: &quot;); } printf(&quot;%s&quot;, ret.mcontent); } while (ret.msgType &amp; RET_MORE); printf(&quot;\\n&quot;);}void waitChild(int sig, siginfo_t *info, void *buf) { logger(LOG_DEBUG, &quot;SERVER: received sig:%d(%s)&quot;, sig, strsignal(sig)); if(sig == SIGCHLD)CHECK_LOG(waitpid(info-&gt;si_pid, NULL, 0) != -1, &quot;&quot;);}char *execute(char *cmd, bool *success) { *success = false; FILE *f = popen(cmd, &quot;r&quot;); if(!f) { logger(LOG_DEBUG, &quot;SERVER: execute, f is NULL&quot;); free(cmd); return NULL; } char content[BUFFER_SIZE] = {0}; char *ret = strdup(&quot;&quot;); while (fgets(content, BUFFER_SIZE-1, f) != NULL) { char *concat = alloc_sprintf(&quot;%s%s&quot;, ret, content); free(ret); ret = concat; } free(cmd); int status = pclose(f); *success = WIFEXITED(status) &amp;&amp; (WEXITSTATUS(status) == 0); logger(LOG_DEBUG, &quot;SERVER: execute success=%d, ret = %s&quot;, *success, ret); return ret;}char *touch(char *filename, bool *success) { char *cmd = alloc_sprintf(&quot;touch %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}char *rm(char *filename, bool *success) { char *cmd = alloc_sprintf(&quot;rm -rf %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}char *ls(char *filename, bool *success) { char *cmd = alloc_sprintf(&quot;ls %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}char *rdlk(char *filename, bool *success) { char *cmd = alloc_sprintf(&quot;readlink %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}char *cat(char *filename, bool *success) { char *cmd = alloc_sprintf(&quot;cat %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}void server_exit(int sig) { exit(0);}char *splitby(char *mcontent, const char *sep) { while (*sep) { char *ptr = strchr(mcontent, *sep); if(ptr) *ptr = '\\0'; sep++; } return mcontent;}void server() { struct sigaction action; struct ClientRequestType req; action.sa_flags = SA_RESTART; CHECK_EXIT(sigemptyset(&amp;action.sa_mask) != -1, &quot;&quot;); action.sa_sigaction = waitChild; CHECK_EXIT(sigaction(SIGCHLD, &amp;action, NULL) != -1, &quot;&quot;); CHECK_EXIT(atexit(atexitRMID) != -1, &quot;&quot;); CHECK_EXIT(signal(SIGHUP, server_exit) != SIG_ERR, &quot;&quot;); CHECK_EXIT(signal(SIGINT, server_exit) != SIG_ERR, &quot;&quot;); ssize_t msg_len; for(;;) { memset(&amp;req, 0, sizeof(struct ClientRequestType)); msg_len = msgrcv(MSG_ID, &amp;req, REQ_SIZE, SERVER_MSG_TYPE, 0); if(msg_len == -1) { if(errno == EINTR) continue; CHECK_EXIT(true, &quot;&quot;); } logger(LOG_DEBUG, &quot;read msg&quot;); struct ServerReturnType ret; sigset_t sigset; sigemptyset(&amp;sigset); sigaddset(&amp;sigset, SIGCHLD); switch (fork()) { case -1: CHECK_EXIT(false, &quot;&quot;); break; case 0: sigprocmask(SIG_SETMASK, &amp;sigset, NULL); // é˜²æ­¢pcloseåˆ é™¤æ¶ˆæ¯é˜Ÿåˆ— memset(&amp;ret, 0, sizeof(struct ServerReturnType)); ret.mtype = req.pid; char *mcontent; bool success; splitby(req.mcontent, &quot;; |&gt;&amp;&quot;); switch (req.msgType) { case REQ_TOUCH: mcontent = touch(req.mcontent, &amp;success); break; case REQ_RM: mcontent = rm(req.mcontent, &amp;success); break; case REQ_CAT: mcontent = cat(req.mcontent, &amp;success); break; case REQ_LS: mcontent = ls(req.mcontent, &amp;success); break; case REQ_RDLK: mcontent = rdlk(req.mcontent, &amp;success); break; default: mcontent = alloc_sprintf(&quot;unsupported msgType:%d&quot;, req.msgType); success = false; break; } if(success) { ret.msgType = RET_SUCCESS; logger(LOG_DEBUG, &quot;SERVER: success&quot;); } else { ret.msgType = 0; logger(LOG_DEBUG, &quot;SERVER: fail&quot;); } size_t len = strlen(mcontent); char *tcontent = mcontent; ret.msgType |= RET_MORE; for(int i = 0; i &lt; len/BUFFER_SIZE; i++) { memcpy(ret.mcontent, mcontent, BUFFER_SIZE); CHECK_LOG(msgsnd(MSG_ID, &amp;ret, RET_SIZE, 0) != -1, &quot;&quot;); mcontent += BUFFER_SIZE; } memcpy(ret.mcontent, mcontent, len%BUFFER_SIZE); ret.msgType &amp;= ~RET_MORE; CHECK_LOG(msgsnd(MSG_ID, &amp;ret, RET_SIZE, 0) != -1, &quot;&quot;); safe_free(tcontent); fflush(NULL); _exit(0); // ä¸è¦æ‰§è¡Œatxiteæ³¨å†Œçš„å‡½æ•° break; default: break; } }}int main(int argc, char **argv) { //å¤„ç†å‚æ•° logfile = stderr; CHECK(argc &gt; 1, &quot;Usage: %s [server|client] argv...&quot;, argv[0]); MSQ_KEY_FILE = realpath(strdup(argv[0]), NULL); CHECK(atexit(atexitFreeKeyfile) != -1, &quot;&quot;); SELF_PID = getpid(); CHECK(SELF_PID != -1, &quot;&quot;); static key_t __MSG_KEY = -1; __MSG_KEY = ftok(MSQ_KEY_FILE, 't'); CHECK(__MSG_KEY != -1, &quot;&quot;); MSG_ID = msgget(__MSG_KEY, IPC_CREAT | 0666); CHECK(MSG_ID != -1, &quot;&quot;); if(!strcmp(&quot;client&quot;, argv[1])) { CHECK(argc &gt; 3, &quot;Usage: %s client filename cmd&quot;, argv[0]); int cmd; if(!strcmp(argv[3], &quot;touch&quot;)) { cmd = REQ_TOUCH; } else if(!strcmp(argv[3], &quot;ls&quot;)) { cmd = REQ_LS; } else if(!strcmp(argv[3], &quot;cat&quot;)) { cmd = REQ_CAT; } else if(!strcmp(argv[3], &quot;readlink&quot;)) { cmd = REQ_RDLK; } else if(!strcmp(argv[3], &quot;rm&quot;)) { cmd = REQ_RM; } else { cmd = -1; } client(argv[2], cmd); } else if(!strcmp(&quot;server&quot;, argv[1])) { CHECK(true, &quot;Usage: %s server [--daemon=] [--logfile=]&quot;, argv[0]); bool deamonlize = false; char *logfilename = NULL; for(int i = 2; i &lt; argc; i++) { if(!strncmp(&quot;--daemon=&quot;, argv[i], 9)) { if(!strcmp(argv[i] + 9, &quot;true&quot;)) { logger(LOG_DEBUG,&quot;SERVER: daemon&quot;); deamonlize = true; } else { logger(LOG_DEBUG,&quot;SERVER: non-daemon&quot;); } } else if(!strncmp(&quot;--logfile=&quot;, argv[i], 10)) { logfilename = argv[i] + 10; logger(LOG_DEBUG,&quot;SERVER: logfile: %s&quot;, logfilename); } else { logger(LOG_DEBUG, &quot;Unknown argv: %s&quot;, argv[i]); } } if(deamonlize) { CHECK(daemon(0,0) != -1, &quot;&quot;); } if(logfilename == NULL) { logfile = stderr; } else { int logfileFd; CHECK((logfileFd = open(logfilename, O_WRONLY | O_CREAT, 0600)) != -1, &quot;&quot;); logfile = fdopen(logfileFd, &quot;w&quot;); CHECK(logfile != NULL, &quot;&quot;); CHECK(dup2(logfileFd, STDERR_FILENO) != -1, &quot;&quot;); CHECK(dup2(logfileFd, STDOUT_FILENO) != -1, &quot;&quot;); CHECK(atexit(atexitCloseLogfile) != -1, &quot;&quot;); } server(); } else { CHECK(false, &quot;Usage: %s [server|client] argv...&quot;, argv[0]); }} 46.3åœ¨46.8èŠ‚ä¸­çš„å®¢æˆ·ç«¯-æœåŠ¡å™¨åº”ç”¨ç¨‹åºä¸­å®¢æˆ·ç«¯ä¸ºä½•åœ¨æ¶ˆæ¯ä½“(åœ¨clientId å­—æ®µä¸­)ä¸­ä¼ é€’å…¶æ¶ˆæ¯é˜Ÿåˆ—çš„æ ‡è¯†ç¬¦ï¼Œè€Œä¸æ˜¯åœ¨æ¶ˆæ¯ç±»å‹(mtype)ä¸­ä¼ é€’? clientidæœ‰å¯èƒ½ä¸º0ï¼Œmtypeä¸èƒ½ä¸º0 46.4 46.5å¯¹46.8èŠ‚ä¸­çš„å®¢æˆ·ç«¯-æœåŠ¡å™¨åº”ç”¨ç¨‹åºåšå‡ºä¸‹åˆ—å˜æ›´ã€‚ ä½¿ç”¨IPC_PRIVATEåˆ›å»ºï¼Œå°†æ ‡è¯†ç¬¦å†™å…¥æ–‡ä»¶ä¸­ï¼Œå®¢æˆ·ç«¯è¯»å–è¿™ä¸ªæ–‡ä»¶ å°†é”™è¯¯è¾“å‡ºåˆ°syslog daemon ä½¿ç”¨ä¿¡å·SIGTERMå’ŒSIGINTåˆ›å»ºå¹²å‡€çš„é€€å‡º å¤„ç†å®¢æˆ·ç«¯è¿‡æ—©é€€å‡ºçš„æƒ…å†µï¼ˆtimerè¶…æ—¶ï¼‰ å®¢æˆ·ç«¯è€ƒè™‘æœåŠ¡ç«¯å¯èƒ½å‡ºç°çš„é”™è¯¯ï¼ˆå¦‚ï¼šæ¶ˆæ¯é˜Ÿåˆ—æ»¡ï¼‰ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdbool.h&gt;#include &lt;stddef.h&gt;#include &lt;syslog.h&gt;#include &lt;wait.h&gt;#define DEBUG_LEVEL LOG_DEBUG#ifndef DEBUG_LEVEL#define DEBUG_LEVEL LOG_INFO#endifFILE *logfile = NULL;bool syslog_enable = false;#define alloc_sprintf(__alloc_sprintf_str, __format...) do { \\ int __alloc_sprintf_len = snprintf(NULL, 0, __format); \\ (__alloc_sprintf_str) = malloc(__alloc_sprintf_len+1); \\ if(__alloc_sprintf_str != NULL) \\ snprintf(__alloc_sprintf_str, __alloc_sprintf_len+1, __format); \\} while(0)#define logger(level, msg...) do { \\ if(level &lt;= DEBUG_LEVEL) { \\ fprintf(logfile, msg); \\ fprintf(logfile, &quot;\\n&quot;); \\ } \\ if(syslog_enable) { \\ char *data; \\ alloc_sprintf(data, msg); \\ syslog(level, &quot;%s&quot;, data); \\ safe_free(data); \\ } \\} while(0)#define COND_RET(x, ret, msg...) \\ do { \\ if(!(x)) { \\ if(errno == 0)logger(LOG_ERR, &quot;%s:%d\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__, #x); \\ else logger(LOG_ERR, &quot;%s:%d\\nerror: %s\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__,strerror(errno), #x); \\ logger(LOG_ERR, msg); \\ logger(LOG_ERR, &quot;\\n&quot;); \\ ret \\ } \\ } while(0)#define CHECK(x, msg...) COND_RET(x, return -1;, msg)#define CHECK_EXIT(x, msg...) COND_RET(x, exit(EXIT_FAILURE);, msg)#define CHECK_LOG(x, msg...) COND_RET(x, ;, msg)#define safe_free(__safe_free_ptr) do { if(__safe_free_ptr) { free(__safe_free_ptr); (__safe_free_ptr) = NULL;} } while(0)#define BUFFER_SIZE 4096static pid_t SELF_PID = -1;static int MSG_ID = -1;#define SERVER_MSG_TYPE 1#define CLIENT_MSG_TYPE SELF_PID#define REQ_TOUCH 1#define REQ_RM 2#define REQ_CAT 3#define REQ_LS 4#define REQ_RDLK 5#define RET_MORE 0x0001#define RET_SUCCESS 0x0010#define SERVER_MSG_FILE &quot;SERVER_MSG_FILE-Meow&quot;struct ServerReturnType { long mtype; int msgtype; char mcontent[BUFFER_SIZE];};struct ClientRequestType { long mtype; int msqid; char mcontent[BUFFER_SIZE];};#define REQ_SIZE (offsetof(struct ClientRequestType, mcontent) - offsetof(struct ClientRequestType, msqid) + BUFFER_SIZE)#define RET_SIZE (offsetof(struct ServerReturnType, mcontent) - offsetof(struct ServerReturnType, msgtype) + BUFFER_SIZE)void atexitWorker(int status, void *arg) { if(WIFEXITED(status) &amp;&amp; (WEXITSTATUS(status) == EXIT_SUCCESS)) return; struct ClientRequestType *req = arg; logger(DEBUG_LEVEL, &quot;worker atexitWorker&quot;); CHECK_LOG(msgctl(req-&gt;msqid, IPC_RMID, NULL) != -1, &quot;&quot;);}void atexitCloseLogfile(int status, void *arg) { if(!*(bool *)arg) return; logger(LOG_DEBUG, &quot;SERVER: atexitCloseLogfile&quot;); CHECK_LOG(fclose(logfile) != -1, &quot;&quot;); logfile = stderr;}void atexitCloseLog(int status, void *arg) { if(!*(bool *)arg) return; logger(LOG_DEBUG, &quot;SERVER: atexitCloseLog&quot;); closelog();}void atexitRMID(int status, void *arg) { if(!*(bool *)arg) return; logger(LOG_DEBUG, &quot;SERVER: atexitRMID&quot;); CHECK_LOG(unlink(SERVER_MSG_FILE) != -1, &quot;&quot;); CHECK_LOG(msgctl(MSG_ID, IPC_RMID, NULL) != -1, &quot;&quot;);}void clientAtexitRMID(int status, void *arg) { logger(LOG_DEBUG, &quot;CLIENT: atexitRMID&quot;); CHECK_LOG(msgctl(MSG_ID, IPC_RMID, NULL) != -1, &quot;&quot;);}void client(const char *filename, int msgType) { on_exit(clientAtexitRMID, NULL); int SERVER_MSG_ID = -1; int server_msg_id = open(SERVER_MSG_FILE, O_EXCL | O_RDONLY); CHECK_EXIT(server_msg_id != -1, &quot;&quot;); CHECK_EXIT(read(server_msg_id, &amp;SERVER_MSG_ID, sizeof(int)) == sizeof(int), &quot;&quot;); close(server_msg_id); struct ServerReturnType ret; struct ClientRequestType req; req.mtype = msgType; req.msqid = MSG_ID; strcpy(req.mcontent, filename); ssize_t send = msgsnd(SERVER_MSG_ID, &amp;req, REQ_SIZE, IPC_NOWAIT); CHECK_EXIT(send != -1, &quot;&quot;); do { ssize_t recv = msgrcv(MSG_ID, &amp;ret, RET_SIZE, 0, 0); CHECK_EXIT(recv != -1, &quot;&quot;); if(ret.msgtype &amp; RET_SUCCESS) { printf(&quot;oJBk: &quot;); } else { printf(&quot;fail: &quot;); } printf(&quot;%s&quot;, ret.mcontent); } while (ret.msgtype &amp; RET_MORE); printf(&quot;\\n&quot;);}void waitChild(int sig, siginfo_t *info, void *buf) { logger(LOG_DEBUG, &quot;SERVER: received sig:%d(%s)&quot;, sig, strsignal(sig)); int savedErrno = errno; if(sig == SIGCHLD)CHECK_LOG(waitpid(-1, NULL, WNOHANG) != -1, &quot;&quot;); // ç­‰æ‰€æœ‰å§ errno = savedErrno;}char *execute(char *cmd, bool *success) { *success = false; FILE *f = popen(cmd, &quot;r&quot;); if(!f) { logger(LOG_DEBUG, &quot;SERVER: execute, f is NULL&quot;); free(cmd); return NULL; } char content[BUFFER_SIZE] = {0}; char *ret = strdup(&quot;&quot;); while (fgets(content, BUFFER_SIZE-1, f) != NULL) { char *concat; alloc_sprintf(concat, &quot;%s%s&quot;, ret, content); free(ret); ret = concat; } free(cmd); int status = pclose(f); *success = WIFEXITED(status) &amp;&amp; (WEXITSTATUS(status) == 0); logger(LOG_DEBUG, &quot;SERVER: execute success=%d, ret = %s&quot;, *success, ret); return ret;}char *touch(char *filename, bool *success) { char *cmd; alloc_sprintf(cmd, &quot;touch %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}char *rm(char *filename, bool *success) { char *cmd; alloc_sprintf(cmd, &quot;rm -rf %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}char *ls(char *filename, bool *success) { char *cmd; alloc_sprintf(cmd, &quot;ls %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}char *rdlk(char *filename, bool *success) { char *cmd; alloc_sprintf(cmd, &quot;readlink %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}char *cat(char *filename, bool *success) { char *cmd; alloc_sprintf(cmd, &quot;cat %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}void server_exit(int sig) { exit(0);}char *splitby(char *mcontent, const char *sep) { while (*sep) { char *ptr = strchr(mcontent, *sep); if(ptr) *ptr = '\\0'; sep++; } return mcontent;}bool is_server = false;int task_timeout = 20;void workerTimeout(int sig) { logger(LOG_DEBUG, &quot;WORKER: received sig:%d(%s), work timeout!&quot;, sig, strsignal(sig)); fflush(NULL); exit(EXIT_FAILURE);}void server() { is_server = true; int server_msg_id = open(SERVER_MSG_FILE, O_CREAT | O_EXCL | O_RDONLY | O_FSYNC | O_WRONLY, 0666); CHECK_EXIT(server_msg_id != -1, &quot;&quot;); CHECK_EXIT(write(server_msg_id, &amp;MSG_ID, sizeof(int)) == sizeof(int), &quot;&quot;); close(server_msg_id); struct sigaction action; struct ClientRequestType req; action.sa_flags = SA_RESTART; CHECK_EXIT(sigemptyset(&amp;action.sa_mask) != -1, &quot;&quot;); action.sa_sigaction = waitChild; CHECK_EXIT(sigaction(SIGCHLD, &amp;action, NULL) != -1, &quot;&quot;); CHECK_EXIT(on_exit(atexitRMID, &amp;is_server) != -1, &quot;&quot;); CHECK_EXIT(signal(SIGHUP, server_exit) != SIG_ERR, &quot;&quot;); CHECK_EXIT(signal(SIGINT, server_exit) != SIG_ERR, &quot;&quot;); CHECK_EXIT(signal(SIGTERM, server_exit) != SIG_ERR, &quot;&quot;); ssize_t msg_len; for(;;) { memset(&amp;req, 0, sizeof(struct ClientRequestType)); msg_len = msgrcv(MSG_ID, &amp;req, REQ_SIZE, 0, 0); if(msg_len == -1) { if(errno == EINTR) continue; CHECK_EXIT(false, &quot;&quot;); } logger(LOG_DEBUG, &quot;read msg&quot;); struct ServerReturnType ret; sigset_t sigset; sigemptyset(&amp;sigset); sigaddset(&amp;sigset, SIGCHLD); switch (fork()) { case -1: CHECK_EXIT(false, &quot;&quot;); break; case 0: is_server = false; sigprocmask(SIG_SETMASK, &amp;sigset, NULL); // é˜²æ­¢pcloseåˆ é™¤æ¶ˆæ¯é˜Ÿåˆ— memset(&amp;ret, 0, sizeof(struct ServerReturnType)); ret.mtype = 1; char *mcontent; bool success; splitby(req.mcontent, &quot;; |&gt;&amp;&quot;); on_exit(atexitWorker, &amp;req); CHECK_EXIT(signal(SIGALRM, workerTimeout) != SIG_ERR, &quot;&quot;); CHECK_EXIT(alarm(task_timeout) != -1, &quot;&quot;); switch (req.mtype) { case REQ_TOUCH: mcontent = touch(req.mcontent, &amp;success); break; case REQ_RM: mcontent = rm(req.mcontent, &amp;success); break; case REQ_CAT: mcontent = cat(req.mcontent, &amp;success); break; case REQ_LS: mcontent = ls(req.mcontent, &amp;success); break; case REQ_RDLK: mcontent = rdlk(req.mcontent, &amp;success); break; default: alloc_sprintf(mcontent, &quot;unsupported msgType:%ld&quot;, req.mtype); success = false; break; } if(success) { ret.msgtype = RET_SUCCESS; logger(LOG_DEBUG, &quot;SERVER: success&quot;); } else { ret.msgtype = 0; logger(LOG_DEBUG, &quot;SERVER: fail&quot;); } size_t len = strlen(mcontent); char *tcontent = mcontent; ret.msgtype |= RET_MORE; for(int i = 0; i &lt; len/BUFFER_SIZE; i++) { memcpy(ret.mcontent, mcontent, BUFFER_SIZE); CHECK_LOG(msgsnd(req.msqid, &amp;ret, RET_SIZE, 0) != -1, &quot;&quot;); mcontent += BUFFER_SIZE; } memcpy(ret.mcontent, mcontent, len%BUFFER_SIZE); ret.msgtype &amp;= ~RET_MORE; CHECK_LOG(msgsnd(req.msqid, &amp;ret, RET_SIZE, 0) != -1, &quot;&quot;); CHECK_EXIT(alarm(0) != -1, &quot;&quot;); //cancel safe_free(tcontent); fflush(NULL); exit(EXIT_SUCCESS); break; default: break; } }}int main(int argc, char **argv) { //å¤„ç†å‚æ•° logfile = stderr; CHECK(argc &gt; 1, &quot;Usage: %s [server|client] argv...&quot;, argv[0]); SELF_PID = getpid(); CHECK(SELF_PID != -1, &quot;&quot;); MSG_ID = msgget(IPC_PRIVATE, 0666); CHECK(MSG_ID != -1, &quot;&quot;); if(!strcmp(&quot;client&quot;, argv[1])) { CHECK(argc &gt; 3, &quot;Usage: %s client filename cmd&quot;, argv[0]); int cmd; if(!strcmp(argv[3], &quot;touch&quot;)) { cmd = REQ_TOUCH; } else if(!strcmp(argv[3], &quot;ls&quot;)) { cmd = REQ_LS; } else if(!strcmp(argv[3], &quot;cat&quot;)) { cmd = REQ_CAT; } else if(!strcmp(argv[3], &quot;readlink&quot;)) { cmd = REQ_RDLK; } else if(!strcmp(argv[3], &quot;rm&quot;)) { cmd = REQ_RM; } else { cmd = -1; } client(argv[2], cmd); } else if(!strcmp(&quot;server&quot;, argv[1])) { CHECK(true, &quot;Usage: %s server [--daemon=true|false] [--logfile=] [--syslog=true|false] [--timeout=number]&quot;, argv[0]); bool deamonlize = false; char *logfilename = NULL; for(int i = 2; i &lt; argc; i++) { if(!strncmp(&quot;--daemon=&quot;, argv[i], 9)) { if(!strcmp(argv[i] + 9, &quot;true&quot;)) { logger(LOG_DEBUG,&quot;SERVER: daemon&quot;); deamonlize = true; } else { logger(LOG_DEBUG,&quot;SERVER: non-daemon&quot;); } } else if(!strncmp(&quot;--logfile=&quot;, argv[i], 10)) { logfilename = argv[i] + 10; logger(LOG_DEBUG,&quot;SERVER: logfile: %s&quot;, logfilename); } else if(!strncmp(&quot;--syslog=&quot;, argv[i], 9)) { if(!strcmp(argv[i] + 9, &quot;true&quot;)) { syslog_enable = true; openlog(argv[0], LOG_CONS|LOG_PID, LOG_USER); on_exit(atexitCloseLog, &amp;is_server); logger(LOG_DEBUG,&quot;SERVER: enable-syslog&quot;); } else { logger(LOG_DEBUG,&quot;SERVER: disable-syslog&quot;); } } else if(!strncmp(&quot;--timeout=&quot;, argv[i], 10)) { logger(LOG_DEBUG, &quot;timeout: %s&quot;, argv[i]); task_timeout = atoi(argv[i] + 10); } else { logger(LOG_DEBUG, &quot;Unknown argv: %s&quot;, argv[i]); } } if(deamonlize) { CHECK(daemon(1,0) != -1, &quot;&quot;); } if(logfilename != NULL) { int logfileFd; if(access(logfilename, F_OK)) { unlink(logfilename); } CHECK((logfileFd = open(logfilename, O_WRONLY | O_CREAT | O_APPEND, 0600)) != -1, &quot;&quot;); logfile = fdopen(logfileFd, &quot;w&quot;); setlinebuf(logfile); CHECK(logfile != NULL, &quot;&quot;); CHECK(dup2(logfileFd, STDERR_FILENO) != -1, &quot;&quot;); CHECK(dup2(logfileFd, STDOUT_FILENO) != -1, &quot;&quot;); CHECK(on_exit(atexitCloseLogfile, &amp;is_server) != -1, &quot;&quot;); } server(); } else { CHECK(false, &quot;Usage: %s [server|client] argv...&quot;, argv[0]); }}","link":"/home/2023/09/02/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha46/"},{"title":"cha5.æ·±å…¥æ¢ç©¶æ–‡ä»¶IO","text":"ç»ƒä¹ 1 è¯·ä½¿ç”¨æ ‡å‡†æ–‡ä»¶IOç³»ç»Ÿè°ƒç”¨(open()å’Œlseek())å’Œoff_tæ•°æ®ç±»å‹ä¿®æ”¹ç¨‹åºæ¸…å•5-3ä¸­çš„ç¨‹åºã€‚å°†å®_FILE_OFFSET_BITSçš„å€¼è®¾ç½®ä¸º64è¿›è¡Œç¼–è¯‘ï¼Œå¹¶æµ‹è¯•è¯¥ç¨‹åºæ˜¯å¦èƒ½å¤ŸæˆåŠŸåˆ›å»ºä¸€ä¸ªå¤§æ–‡ä»¶ã€‚ å°†xxx64æ”¹ä¸ºxxxï¼Œoff64_tæ”¹ä¸ºoff_tï¼Œå¯ä»¥åˆ›å»ºå¤§æ–‡ä»¶ï¼ˆä½¿ç”¨ -m32ç¼–è¯‘ï¼‰ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// #define _LARGEFILE64_SOURCE#define _FILE_OFFSET_BITS 64#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;errno.h&gt;#include&lt;stdlib.h&gt;#define debug#ifdef debug#include&lt;stdio.h&gt;#endifvoid writeErr(const char* str);#ifdef _LARGEFILE64_SOURCEint main(int argc, char **argv) { #ifdef debug printf(&quot;sizeof(long) = %d, sizeof(long long) = %d, sizeof(off_t) = %d, sizeof(off64_t) = %d\\n&quot;, sizeof(long), sizeof(long long), sizeof(off_t), sizeof(off64_t)); #endif if(argc !=3 || strcmp(argv[1], &quot;--help&quot;) == 0) { writeErr(argv[0]); writeErr(&quot; pathname offset\\n&quot;); exit(3); } int fd = open64(argv[1], O_RDWR | O_CREAT, S_IRUSR|S_IWUSR); if(fd == -1) { writeErr(&quot;open64 fail&quot;); exit(2); } off64_t off = atoll(argv[2]); if(lseek64(fd, off, SEEK_SET) == -1) { writeErr(&quot;lseek64&quot;); exit(3); } if(write(fd, &quot;test&quot;, 4) == -1) { writeErr(&quot;write&quot;); exit(4); } return 0;}#endif#ifdef _FILE_OFFSET_BITSint main(int argc, char **argv) { #ifdef debug printf(&quot;sizeof(long) = %d, sizeof(long long) = %d, sizeof(off_t) = %d\\n&quot;, sizeof(long), sizeof(long long), sizeof(off_t)); #endif if(argc !=3 || strcmp(argv[1], &quot;--help&quot;) == 0) { writeErr(argv[0]); writeErr(&quot; pathname offset\\n&quot;); exit(3); } int fd = open(argv[1], O_RDWR | O_CREAT, S_IRUSR|S_IWUSR); if(fd == -1) { writeErr(&quot;open64 fail&quot;); exit(2); } off_t off = atoll(argv[2]); if(lseek(fd, off, SEEK_SET) == -1) { writeErr(&quot;lseek64&quot;); exit(3); } if(write(fd, &quot;test&quot;, 4) == -1) { writeErr(&quot;write&quot;); exit(4); } return 0;}#endifvoid writeErr(const char* str) { errno = 0; int writeSize = write(STDERR_FILENO, str, strlen(str)); if(writeSize == -1) { exit(1); }} ç»ƒä¹ 2 5-2.ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œä½¿ç”¨O_APPENDæ ‡å¿—å¹¶ä»¥å†™æ–¹å¼æ‰“å¼€ä¸€ä¸ªå·²å­˜åœ¨çš„æ–‡ä»¶ï¼Œä¸”å°†æ–‡ä»¶åç§»é‡ç½®äºæ–‡ä»¶èµ·å§‹å¤„ï¼Œå†å†™å…¥æ•°æ®ã€‚æ•°æ®ä¼šæ˜¾ç¤ºåœ¨æ–‡ä»¶ä¸­çš„å“ªä¸ªä½ç½®?ä¸ºä»€ä¹ˆ? æ–‡ä»¶æœ«å°¾ï¼Œåœ¨writeæ—¶ï¼Œlseekå¤±æ•ˆäº† ç»ƒä¹ 3 æœ¬ä¹ é¢˜çš„è®¾è®¡ç›®çš„åœ¨äºå±•ç¤ºä¸ºä½•ä»¥O_APPENDæ ‡å¿—æ‰“å¼€æ–‡ä»¶æ¥ä¿éšœæ“ä½œçš„åŸå­æ€§æ˜¯å¿…è¦çš„ã€‚è¯·ç¼–å†™ä¸€ç¨‹åºï¼Œå¯æ¥æ”¶å¤šè¾¾3ä¸ªå‘½ä»¤è¡Œå‚æ•°: $ atomic_append filename num-bytes [x] è¯¥ç¨‹åºåº”æ‰“å¼€æ‰€æŒ‡å®šçš„æ–‡ä»¶(å¦‚æœ‰å¿…è¦ï¼Œåˆ™åˆ›å»ºä¹‹)ï¼Œç„¶åä»¥æ¯æ¬¡è°ƒç”¨write()å†™å…¥ä¸€ä¸ªå­—èŠ‚çš„æ–¹å¼ï¼Œå‘æ–‡ä»¶å°¾éƒ¨è¿½åŠ num-bytesä¸ªå­—èŠ‚ã€‚ç¼ºçœæƒ…å†µä¸‹ï¼Œç¨‹åºä½¿ç”¨O_APPENDæ ‡å¿—æ‰“å¼€æ–‡ä»¶ï¼Œä½†è‹¥å­˜åœ¨ç¬¬ä¸‰ä¸ªå‘½ä»¤è¡Œå‚æ•°(x)ï¼Œé‚£ä¹ˆæ‰“å¼€æ–‡ä»¶æ—¶å°†ä¸å†ä½¿ç”¨O_APPENDæ ‡å¿—ï¼Œä»£ä¹‹ä»¥åœ¨æ¯æ¬¡è°ƒç”¨write(å‰è°ƒç”¨lseek(fd,0,SEEK_END))ã€‚åŒæ—¶è¿è¡Œè¯¥ç¨‹åºçš„ä¸¤ä¸ªå®ä¾‹ï¼Œä¸å¸¦xå‚æ•°ï¼Œå°†100ä¸‡ä¸ªå­—èŠ‚å†™å…¥åŒä¸€æ–‡ä»¶: 1$ atomic_append f1 10000oo &amp; atomic_append f1 1000000 é‡å¤ä¸Šè¿°æ“ä½œï¼Œå°†æ•°æ®å†™å…¥å¦ä¸€æ–‡ä»¶ï¼Œä½†è¿è¡Œæ—¶åŠ å…¥xå‚æ•°: 1$ atomic_append f2 1000000 x &amp; atomic_append f2 1000000 x ä½¿ç”¨ls-1å‘½ä»¤æ£€æŸ¥æ–‡ä»¶f1å’Œf2çš„å¤§å°ï¼Œå¹¶è§£é‡Šä¸¤æ–‡ä»¶å¤§å°ä¸åŒçš„åŸå› , ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;errno.h&gt;#include&lt;stdlib.h&gt;#define debug#ifdef debug#include&lt;stdio.h&gt;#endifvoid writeErr(const char* str);ssize_t writeMeow(int __fd, const void *__buf, size_t __n, int argc);int main(int argc, char **argv) { if((argc !=4 &amp;&amp; argc != 5) || strcmp(argv[1], &quot;--help&quot;) == 0) { writeErr(argv[0]); writeErr(&quot; pathname string num [x]\\n&quot;); exit(3); } int fd = open(argv[1], O_RDWR | O_CREAT | (argc == 5 ? 0 : O_APPEND), S_IRUSR|S_IWUSR); if(fd == -1) { writeErr(&quot;open64 fail&quot;); exit(2); } long long off = atoll(argv[3]); int argv2len = strlen(argv[2]); for(int i = 0; i &lt; off; i++) if(writeMeow(fd, argv[2], argv2len, argc) == -1) { writeErr(&quot;writeMeow&quot;); exit(4); } return 0;}void writeErr(const char* str) { errno = 0; int writeSize = write(STDERR_FILENO, str, strlen(str)); if(writeSize == -1) { exit(1); }}ssize_t writeMeow(int __fd, const void *__buf, size_t __n, int argc) { if(argc == 5) lseek(__fd, 0, SEEK_END); write(__fd, __buf, __n);} è¿è¡Œç»“æœ12345$ ./practice5.3 f5.3 &quot;Meow &quot; 1048576 &amp; ./practice5.3 f5.3 &quot;Woof &quot; 1048576$ ./practice5.3 f5.3x &quot;Meow &quot; 1048576 x &amp; ./practice5.3 f5.3x &quot;Woof &quot; 1048576 x$ ll -h-rw------- 1 root root 10M Mar 23 20:17 f5.3-rw------- 1 root root 5.9M Mar 23 20:17 f5.3x è§£é‡ŠåŸå› ä¸åŠ xçš„10Mï¼ŒåŠ xçš„5.9M é€šè¿‡è®¡ç®—ï¼Œå¦‚æœæ‰€æœ‰æ•°æ®æ­£å¸¸å†™å…¥ï¼Œé‚£ä¹ˆæ–‡ä»¶å¤§å°åº”è¯¥åˆšå¥½æ˜¯10M åŠ Xçš„æŒ‡é’ˆç§»åŠ¨å’Œå†™å…¥ä¸å…·æœ‰åŸå­æ€§ï¼Œå¯èƒ½å­˜åœ¨ä¸¤ä¸ªè¿›ç¨‹åŒæ—¶å‘åŒä¸€åç§»é‡å¤„å†™å…¥æ•°æ®ï¼Œç›¸äº’è¦†ç›–ï¼Œå¯¼è‡´æ–‡ä»¶å¤§å°åå°ã€‚ ä¸åŠ Xçš„å…·æœ‰åŸå­æ€§ï¼ŒæŒ‡é’ˆç§»åŠ¨å’Œå†™å…¥ä¸ä¼šæ‰“æ–­ï¼Œä¸ä¼šåœ¨åŒä¸€ä½ç½®å†™å…¥ ç»ƒä¹ 4 ä½¿ç”¨fcntl()å’Œ close()(è‹¥æœ‰å¿…è¦)æ¥å®ç° dupOå’Œ dup2()ã€‚(å¯¹äºæŸäº›é”™è¯¯ï¼Œdup2()å’Œfentl()è¿”å›çš„errnoå€¼å¹¶ä¸ç›¸åŒï¼Œæ­¤å¤„å¯ä¸äºˆè€ƒè™‘ã€‚)åŠ¡å¿…ç‰¢è®°dup2()éœ€è¦å¤„ç†çš„ä¸€ç§ç‰¹æ®Šæƒ…å†µï¼Œå³ oldfdä¸ newfdç›¸ç­‰ã€‚è¿™æ—¶ï¼Œåº”æ£€æŸ¥oldfdæ˜¯å¦æœ‰æ•ˆï¼Œæµ‹è¯•fcntl(oldfdï¼ŒF_GETFL)æ˜¯å¦æˆåŠŸå°±èƒ½è¾¾åˆ°è¿™ä¸€ç›®çš„ã€‚è‹¥oldfdæ— æ•ˆï¼Œåˆ™dup2()å°†è¿”å›-1ï¼Œå¹¶å°†errnoç½®ä¸ºEBADFã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;errno.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdarg.h&gt;#define debug#ifdef debug#include&lt;stdio.h&gt;#endifvoid exitErr(int exitCode, const char *format, ...);int __dup(int oldfd);int __dup2(int oldfd, int newfd);int main(int argc, char **argv) { int dupStdout = __dup(STDOUT_FILENO); write(STDOUT_FILENO, &quot;Jingtianer\\n&quot;, strlen(&quot;Jingtianer\\n&quot;)); write(dupStdout, &quot;Jingtianer\\n&quot;, strlen(&quot;Jingtianer\\n&quot;)); dupStdout = __dup2(STDOUT_FILENO, dupStdout); write(STDOUT_FILENO, &quot;Jingtianer\\n&quot;, strlen(&quot;Jingtianer\\n&quot;)); write(dupStdout, &quot;Jingtianer\\n&quot;, strlen(&quot;Jingtianer\\n&quot;)); char tmpfile[] = &quot;JingtianTmpXXXXXX&quot;; int tmpfd = mkstemp(tmpfile); dupStdout = __dup2(STDOUT_FILENO, tmpfd); write(STDOUT_FILENO, &quot;Jingtianer\\n&quot;, strlen(&quot;Jingtianer\\n&quot;)); write(tmpfd, &quot;Jingtianer\\n&quot;, strlen(&quot;Jingtianer\\n&quot;)); unlink(tmpfile); close(tmpfd); return 0;}int __dup(int oldfd) { return fcntl(oldfd, F_DUPFD, oldfd);}int __dup2(int oldfd, int newfd) { if(oldfd != newfd) { close(newfd); } else if(fcntl(oldfd, F_GETFL) == -1) { errno = EBADF; return -1; } return fcntl(oldfd, F_DUPFD, newfd);}void exitErr(int exitCode, const char *format, ...) { va_list va; va_start(va, format); fprintf(stderr, format, va); va_end(va); exit(exitCode);} ç»ƒä¹ 5 ç¼–å†™ä¸€ç¨‹åºï¼ŒéªŒè¯æ–‡ä»¶æè¿°ç¬¦åŠå…¶å‰¯æœ¬æ˜¯å¦å…±äº«äº†æ–‡ä»¶åç§»é‡å’Œæ‰“å¼€æ–‡ä»¶çš„çŠ¶æ€æ ‡å¿—ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;errno.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdarg.h&gt;#define bool char#define true '\\1'#define false '\\0'#define debug#ifdef debug#include&lt;stdio.h&gt;#endifvoid exitErr(int exitCode, const char *format, ...);bool check(int fd1, int fd2);void exitErr(int exitCode, const char *format, ...);#define bool2str(x) (x == true ? &quot;true&quot; : &quot;false&quot;)int main(int argc, const char **argv) { if(argc != 3) { exitErr(1, &quot;Usage: %s file1 file2\\n&quot;, argv[0]); } int fd1 = open(argv[1], O_CREAT | O_RDWR); int fd2 = open(argv[2], O_CREAT | O_RDWR); if(fd1 == -1 || fd2 == -1) { exitErr(2, &quot;open fail\\n&quot;); } int fd1dup = dup(fd1); bool check1 = check(fd1, fd1dup); //true bool check2 = check(fd1, fd2); // false #ifdef debug fprintf(stdout, &quot;check1 == %s, check2 == %s\\n&quot;, bool2str(check1), bool2str(check2)); #endif return check1 + check2 - 1;}bool check(int fd1, int fd2) { if(lseek(fd1, 0, SEEK_CUR) != lseek(fd2, 0, SEEK_CUR)) { return false; } else { lseek(fd1, 1, SEEK_CUR); if(lseek(fd1, 0, SEEK_CUR) != lseek(fd2, 0, SEEK_CUR)) { lseek(fd1, -1, SEEK_CUR); return false; } lseek(fd1, -1, SEEK_CUR); } if(fcntl(fd1, F_GETFL) != fcntl(fd2, F_GETFL)) { return false; } else { const int flag = fcntl(fd1, F_GETFL); fcntl(fd1, F_SETFL, 0); if(fcntl(fd1, F_GETFL) != fcntl(fd2, F_GETFL)) { fcntl(fd1, F_SETFL, flag); return false; } fcntl(fd1, F_SETFL, flag); } return true;}void exitErr(int exitCode, const char *format, ...) { #ifdef debug va_list va; va_start(va, format); fprintf(stderr, format, va); va_end(va); #endif exit(exitCode);} ç»ƒä¹ 6 è¯´æ˜ä¸‹åˆ—ä»£ç ä¸­æ¯æ¬¡æ‰§è¡Œ write()åï¼Œè¾“å‡ºæ–‡ä»¶çš„å†…å®¹æ˜¯ä»€ä¹ˆï¼Œä¸ºä»€ä¹ˆã€‚ 12345678fd1 = open(file, O_RDNR | O_CREAT | O_TRUNCï¼ŒS_IRUSR | S_IMUSR);fd2 = dup(fd1);fd3 = open(fileï¼ŒO_RDWR);write(fd1,&quot;Hello,&quot;ï¼Œ6); // Hellowrite(fd2,&quot;world&quot;, 6); // Helloworld fd2ç”±fd1å¤åˆ¶è€Œæ¥ï¼Œå…±äº«æ–‡ä»¶æŒ‡é’ˆï¼Œfd1writeåï¼Œæ–‡ä»¶æŒ‡é’ˆåç§»ï¼Œfd2ä¹Ÿåç§»lseek(fd2, 0, SEEK_SET);write(fd1,&quot;HELLO,&quot;ï¼Œ6); // HELLOworld fd2ç§»åŠ¨åˆ°æ–‡ä»¶å¼€å¤´ï¼Œfd1ä¹Ÿç§»åŠ¨ï¼Œå…±äº«æ–‡ä»¶æŒ‡é’ˆå’ŒçŠ¶æ€æ ‡å¿—ã€inodeæŒ‡é’ˆwrite(fd3,&quot;Gidday&quot;ï¼Œ 6); // Giddayworldï¼Œfd3ä¸æ˜¯dup*è€Œæ¥ï¼Œä¸å…±äº«æŒ‡é’ˆï¼Œå…¶æŒ‡é’ˆè¿˜åœ¨0ï¼Œå†™å…¥0 ç»ƒä¹ 7 ä½¿ç”¨read()ã€write()ä»¥åŠ mallocå‡½æ•°åŒ…ï¼ˆè§7.1.2èŠ‚ï¼‰ä¸­çš„å¿…è¦å‡½æ•°ä»¥å®ç°readv()å’Œ writev()åŠŸèƒ½ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;errno.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdarg.h&gt;#include&lt;sys/uio.h&gt; //iovec#define bool char#define true '\\1'#define false '\\0'#define debug#ifdef debug#include&lt;stdio.h&gt;#endifssize_t __writev(int fd, const struct iovec *iov, int iovcount);ssize_t __readv(int fd, const struct iovec *iov, int iovcount);int main(int argc, const char **argv) { int fdw = open(argv[1], O_CREAT | O_TRUNC | O_RDWR); int fdr = open(argv[1], O_CREAT | O_TRUNC | O_RDWR); int contentCount = argc - 2; struct iovec *vecArr = (struct iovec*)malloc(2 * contentCount * sizeof(struct iovec)); for(int i = 2; i &lt; argc; i++) { vecArr[2*(i-2)].iov_base = argv[i]; vecArr[2*(i-2)].iov_len = strlen(argv[i]); vecArr[2*(i-2)+1].iov_base = &quot;\\n&quot;; vecArr[2*(i-2)+1].iov_len = 1; } writev(fdw, vecArr, 2 * contentCount); free(vecArr); vecArr = (struct iovec*)malloc(contentCount * sizeof(struct iovec)); for(int i = 2; i &lt; argc; i++) { int size = strlen(argv[i])+1; vecArr[i-2].iov_base = malloc(size * sizeof(char) + 1); vecArr[i-2].iov_len = size; } errno=0; int read = readv(fdr, vecArr, contentCount); if(read == -1) { const char *err = strerror(errno); write(STDOUT_FILENO, err, strlen(err)); write(STDOUT_FILENO, &quot;\\n&quot;, 1); return read; } writev(STDOUT_FILENO, vecArr, contentCount); close(fdw); close(fdr); free(vecArr); return 0;}ssize_t __writev(int fd, const struct iovec *iov, int iovcount) { ssize_t writeSize = 0; for(int i = 0; i &lt; iovcount; i++) { ssize_t writeSize1 = write(fd, iov[i].iov_base, iov[i].iov_len); writeSize += writeSize1; if(writeSize1 == -1 || writeSize1 &lt; iov[i].iov_len) { return writeSize1; } } return iovcount;}ssize_t __readv(int fd, const struct iovec *iov, int iovcount) { ssize_t readSize = 0; for(int i = 0; i &lt; iovcount; i++) { ssize_t readSize1 = read(fd, iov[i].iov_base, iov[i].iov_len); readSize += readSize1; if(readSize1 == -1 || readSize1 &lt; iov[i].iov_len) { return readSize; } else if(readSize == 0) { return i+1; } } return iovcount;} å­¦ä¹ çš„readï¼Œwriteï¼Œreadvï¼Œwritevï¼Œpreadvï¼Œpwritevï¼Œå…¶è¾“å…¥è¾“å‡ºçš„å†…å®¹ä¸å¿…éƒ½æ˜¯å­—ç¬¦ä¸²ï¼Œç”±iovecçš„å®šä¹‰ä»¥åŠä»–ä»¬çš„å‡½æ•°åŸå‹å¯è§ï¼Œå†™å…¥è¯»å–æ•°æ®çš„ç±»å‹ä¸ºvoid *æˆ–const void *ï¼Œæ˜¯ä¸é™åˆ¶è¾“å…¥è¾“å‡ºçš„æ•°æ®ç±»å‹çš„ã€‚ æ­¤å¤–ï¼Œpread*å’Œpwrite*å…·æœ‰åŸå­æ€§ï¼Œå¯ä»¥ä»£æ›¿lseek + write/readçš„ç»„åˆï¼Œé˜²æ­¢å¤šä¸ªè¿›ç¨‹ç›¸äº’è¯»å†™åŒä¸€æ–‡ä»¶æ—¶ï¼Œå‡ºç°è¯»å†™ä½ç½®å‡ºé”™çš„æƒ…å†µï¼Œå¦‚æœå¸¸å‡ºç°lseek + write/readçš„ç»„åˆï¼Œä½¿ç”¨pread*å’Œpwrite*å¯ä»¥å¤§é‡å‡å°‘ç³»ç»Ÿè°ƒç”¨çš„ä½¿ç”¨ï¼Œæé«˜æ€§èƒ½","link":"/home/2023/03/23/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha5/"},{"title":"cha48.System V å…±äº«å†…å­˜","text":"è¯»ä¹¦ç¬”è®°shmat/mmapæ—¶å¯ä»¥æŒ‡å®šè™šæ‹Ÿå†…å­˜åœ°å€ï¼ŒæŒ‡å®šå…¶ä½ç½®ï¼Œè¿™ä¸ªä½ç½®æ˜¯éœ€è¦æå‰mallocæˆ–sbrkåˆ›å»ºå‡ºæ¥çš„å—ï¼Ÿ 48.1ä½¿ç”¨äº‹ä»¶æ ‡è®°æ¥æ›¿æ¢ç¨‹åºæ¸…å•48-2(svshm_xfr_writerc)å’Œç¨‹åºæ¸…å•48-3(svshm_xfr_reader.c)ä¸­çš„äºŒå…ƒä¿¡å·é‡ã€‚(å°±æ˜¯27èŠ‚çš„event flag) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347//// Created by root on 9/14/23.//#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;stdbool.h&gt;#include &lt;stddef.h&gt;#include &lt;syslog.h&gt;#include &lt;wait.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/shm.h&gt;#define DEBUG_LEVEL LOG_DEBUG#ifndef DEBUG_LEVEL#define DEBUG_LEVEL LOG_INFO#endif#define STRING_MSG &quot;MSG&quot;FILE *logfile = NULL;bool syslog_enable = false;void __attribute__ ((constructor)) init() { syslog_enable = false; logfile = stderr;}#define alloc_sprintf(__alloc_sprintf_str, __format...) do { \\ int __alloc_sprintf_len = snprintf(NULL, 0, __format); \\ (__alloc_sprintf_str) = malloc(__alloc_sprintf_len+1); \\ if(__alloc_sprintf_str != NULL) \\ snprintf(__alloc_sprintf_str, __alloc_sprintf_len+1, __format); \\} while(0)#define logger(level, msg...) do { \\ if(level &lt;= DEBUG_LEVEL) { \\ fprintf(logfile, &quot;[%ld] &quot;, (long) getpid()); \\ fprintf(logfile, msg); \\ fprintf(logfile, &quot;\\n&quot;); \\ } \\ if(syslog_enable) { \\ char *data; \\ alloc_sprintf(data, msg); \\ syslog(level, &quot;%s&quot;, data); \\ safe_free(data); \\ } \\} while(0)#define COND_RET(x, ret, msg...) \\ do { \\ if(!(x)) { \\ if(errno != 0) logger(LOG_ERR, &quot;Error(%d): %s&quot;, errno, strerror(errno)); \\ logger(LOG_ERR, &quot;%s:%d&quot;, __FILE__, __LINE__); \\ logger(LOG_ERR, &quot;unmet condition:\\&quot;%s\\&quot;&quot;, #x); \\ logger(LOG_ERR, msg); \\ ret; \\ } \\ errno = 0; \\ } while(0)#define CHECK(x, msg...) COND_RET(x, return -1;, msg)#define CHECK_EXIT(x, msg...) COND_RET(x, exit(EXIT_FAILURE);, msg)#define CHECK_LOG(x, msg...) COND_RET(x, ;, msg)#define safe_free(__safe_free_ptr) do { if(__safe_free_ptr) { free(__safe_free_ptr); (__safe_free_ptr) = NULL;} } while(0)#define BUFFER_SIZE 4096union semun { int val; struct semid_ds *buf; unsigned short *array;#if defined(__linux__) struct seminfo *__buf;#endif};typedef struct { int semid;}EventFlag_t;int incrsem(int sem_id, int semnum, short incr, short flg) { struct sembuf sembuf; sembuf = (struct sembuf){ .sem_num=semnum, .sem_flg=flg, .sem_op=incr }; return semop(sem_id, &amp;sembuf, 1);}int P(int sem_id) { return incrsem(sem_id, 0, -1, 0);}int V(int sem_id) { return incrsem(sem_id, 0, 1, 0);}int waitFor(int sem_id) { return incrsem(sem_id, 1, 0, 0);}int getsem(int sem_id, int semnum, short *n) { union semun arg; int ret = semctl(sem_id, semnum, GETVAL, arg); *n = ret; return ret;}int setsem(int sem_id, int semnum, short n) { union semun arg; arg.val = n; return semctl(sem_id, semnum, SETVAL, arg);}int notifyAll(int sem_id) { return setsem(sem_id, 1, 0);}EventFlag_t *newEventFlag(const char *file, char x) { EventFlag_t eventFlag; key_t key = ftok(file, x); eventFlag.semid = semget(key, 4, IPC_CREAT | IPC_EXCL | 0666); // sem[0] as mutex, sem[1] as notifier, sem[2]|sem[3] as flag union semun arg; if(eventFlag.semid == -1) { if(errno == EEXIST) { eventFlag.semid = semget(key, 4, 0666); COND_RET(eventFlag.semid != -1, return NULL, STRING_MSG); struct semid_ds ds; arg.buf = &amp;ds; COND_RET(semctl(eventFlag.semid, 0, IPC_STAT, arg) != -1, return NULL, STRING_MSG); while (ds.sem_otime == 0) { logger(LOG_INFO, &quot;waiting for sem init&quot;); sleep(1); COND_RET(semctl(eventFlag.semid, 0, IPC_STAT, arg) != -1, return NULL, STRING_MSG); } logger(LOG_INFO, &quot;semget get old&quot;); } else { CHECK_LOG(false, STRING_MSG); return NULL; } } else { arg.array = (unsigned short *)&amp;(unsigned short[]){0, 0, 0, 0}; // sem[0] = 1, sem[1] = 0 if(semctl(eventFlag.semid, 0, SETALL, arg) == -1) { CHECK_LOG(false, STRING_MSG); CHECK_LOG(semctl(eventFlag.semid, 0, IPC_RMID) != -1, STRING_MSG); return NULL; } if(incrsem(eventFlag.semid, 0,1,0) == -1) { CHECK_LOG(false, STRING_MSG); CHECK_LOG(semctl(eventFlag.semid, 0, IPC_RMID) != -1, STRING_MSG); return NULL; } logger(LOG_INFO, &quot;semget create new&quot;); } return memcpy(malloc(sizeof(EventFlag_t)), &amp;eventFlag, sizeof(EventFlag_t));}int __setEventFlag(EventFlag_t *eventFlag, int flag) { short currentFlag; CHECK(getsem(eventFlag-&gt;semid, 2, &amp;currentFlag) != -1, STRING_MSG); CHECK(setsem(eventFlag-&gt;semid, 2, currentFlag | (flag &amp; 0xffff)) != -1, STRING_MSG); CHECK(getsem(eventFlag-&gt;semid, 3, &amp;currentFlag) != -1, STRING_MSG); CHECK(setsem(eventFlag-&gt;semid, 3, currentFlag | ((flag &gt;&gt; 16) &amp; 0xffff)) != -1, STRING_MSG); CHECK(notifyAll(eventFlag-&gt;semid) != -1, STRING_MSG);}int setEventFlag(EventFlag_t *eventFlag, int flag) { CHECK(P(eventFlag-&gt;semid) != -1, STRING_MSG); CHECK(__setEventFlag(eventFlag, flag) != -1, STRING_MSG); CHECK(V(eventFlag-&gt;semid) != -1, STRING_MSG); return 0;}int __clearEventFlag(EventFlag_t *eventFlag, int flag) { short currentFlag; CHECK(getsem(eventFlag-&gt;semid, 2, &amp;currentFlag) != -1, STRING_MSG); CHECK(setsem(eventFlag-&gt;semid, 2, currentFlag &amp; ~(flag &amp; 0xffff)) != -1, STRING_MSG); CHECK(getsem(eventFlag-&gt;semid, 3, &amp;currentFlag) != -1, STRING_MSG); CHECK(setsem(eventFlag-&gt;semid, 3, currentFlag &amp; ~((flag &gt;&gt; 16) &amp; 0xffff)) != -1, STRING_MSG);// CHECK(notifyAll(eventFlag-&gt;semid) != -1, STRING_MSG); return 0;}int clearEventFlag(EventFlag_t *eventFlag, int flag) { CHECK(P(eventFlag-&gt;semid) != -1, STRING_MSG); CHECK(__clearEventFlag(eventFlag, flag) != -1, STRING_MSG); CHECK(V(eventFlag-&gt;semid) != -1, STRING_MSG); return 0;}int __getEventFlag(EventFlag_t *eventFlag, int *flag) { if(flag) { short currentFlag = 0; int ret = 0; CHECK(getsem(eventFlag-&gt;semid, 2, &amp;currentFlag) != -1, STRING_MSG); ret |= currentFlag; CHECK(getsem(eventFlag-&gt;semid, 3, &amp;currentFlag) != -1, STRING_MSG); ret |= currentFlag &lt;&lt; 16; *flag = ret; return 0; } return -1;}int getEventFlag(EventFlag_t *eventFlag, int *flag) { CHECK(P(eventFlag-&gt;semid) != -1, STRING_MSG); CHECK_LOG(__getEventFlag(eventFlag, flag) != -1, STRING_MSG); CHECK(V(eventFlag-&gt;semid) != -1, STRING_MSG); return 0;}#define waitForMethod(eventFlag, flag, method) do { \\ int currentFlag;\\ CHECK(P(eventFlag-&gt;semid) != -1, STRING_MSG);\\ __getEventFlag(eventFlag, &amp;currentFlag); \\ while (method) {\\ CHECK(V(eventFlag-&gt;semid) != -1, STRING_MSG);\\ CHECK(waitFor(eventFlag-&gt;semid) != -1, STRING_MSG);\\ CHECK(P(eventFlag-&gt;semid) != -1, STRING_MSG);\\ __getEventFlag(eventFlag, &amp;currentFlag); \\ }\\ CHECK(V(eventFlag-&gt;semid) != -1, STRING_MSG);\\} while(0)int waitForAny(EventFlag_t *eventFlag, int flag) { waitForMethod(eventFlag, flag, (currentFlag &amp; flag) == 0); return 0;}int waitForAll(EventFlag_t *eventFlag, int flag) { waitForMethod(eventFlag, flag, (currentFlag &amp; flag) != flag); return 0;}int waitForAllAndClear(EventFlag_t *eventFlag, int flag) { int currentFlag; CHECK(P(eventFlag-&gt;semid) != -1, STRING_MSG); __getEventFlag(eventFlag, &amp;currentFlag); while ((currentFlag &amp; flag) != flag) { CHECK(V(eventFlag-&gt;semid) != -1, STRING_MSG); CHECK(waitFor(eventFlag-&gt;semid) != -1, STRING_MSG); CHECK(P(eventFlag-&gt;semid) != -1, STRING_MSG); __getEventFlag(eventFlag, &amp;currentFlag); } __clearEventFlag(eventFlag, flag); CHECK(V(eventFlag-&gt;semid) != -1, STRING_MSG); return 0;}void destroyEventFlag(EventFlag_t **eventFlag) { if(eventFlag) { if(*eventFlag) { semctl((*eventFlag)-&gt;semid, 0, IPC_RMID); } safe_free(*eventFlag); }}#define WRITE_FLAG 1#define READ_FLAG 2struct ShmStruct { ssize_t len; char buf[BUFFER_SIZE - sizeof(int)];};void onExitEventFlag(int status, void *arg) { destroyEventFlag((EventFlag_t **)&amp;arg); logger(LOG_INFO, &quot;onExitEventFlag, status = %d&quot;, status);}void onExitSHM(int status, void *id) { shmctl(*(int *)id, IPC_RMID, NULL); logger(LOG_INFO, &quot;onExitSHM, status = %d&quot;, status);}void onExitSHMdt(int status, void *ptr) { shmdt(ptr); logger(LOG_INFO, &quot;onExitSHMdt, status = %d&quot;, status);}void handler(int sig) { exit(0);}int main(int argc, char **argv) { CHECK_EXIT(argc == 2, &quot;Usage: %s writer|reader&quot;, argv[0]); signal(SIGINT, handler); signal(SIGTERM, handler); signal(SIGHUP, handler); EventFlag_t *eventFlag = newEventFlag(argv[0], 'a'); on_exit(onExitEventFlag, eventFlag); key_t key = ftok(argv[0], 'c'); CHECK_EXIT(key != -1, STRING_MSG); int shmid = shmget(key, BUFFER_SIZE, IPC_CREAT | IPC_EXCL | 0666); int savedErrno = errno; CHECK_EXIT(shmid != -1 || errno == EEXIST, STRING_MSG); if(shmid != -1) { setEventFlag(eventFlag, WRITE_FLAG); } else { if(savedErrno == EEXIST) { shmid = shmget(key, BUFFER_SIZE, 0666); } else { CHECK_EXIT(false, &quot;code will never reach&quot;); } } on_exit(onExitSHM, &amp;shmid); struct ShmStruct *shmp = shmat(shmid, NULL, 0); CHECK_EXIT(shmp != NULL, STRING_MSG); on_exit(onExitSHMdt, shmp); if(!strcmp(argv[1], &quot;writer&quot;)) { size_t size = 0; bool stop = false; for(int i = 0; !stop ;i++) { CHECK_EXIT(waitForAllAndClear(eventFlag, WRITE_FLAG) != -1, STRING_MSG); logger(LOG_INFO, &quot;write start&quot;); CHECK_EXIT((shmp-&gt;len = read(STDIN_FILENO, shmp-&gt;buf, BUFFER_SIZE - sizeof(int))) &gt;= 0, STRING_MSG); size += shmp-&gt;len; if(shmp-&gt;len == 0) { stop = true; } CHECK_EXIT(setEventFlag(eventFlag, READ_FLAG) != -1, STRING_MSG); logger(LOG_INFO, &quot;write end: i = %d, size = %lu&quot;, i, size); } } else { size_t size = 0; bool stop = false; for(int i = 0; !stop ;i++) { CHECK_EXIT(waitForAllAndClear(eventFlag, READ_FLAG) != -1, STRING_MSG); logger(LOG_INFO, &quot;read start&quot;); CHECK_EXIT(write(STDIN_FILENO, shmp-&gt;buf, shmp-&gt;len) == shmp-&gt;len, STRING_MSG); size += shmp-&gt;len; if(shmp-&gt;len == 0) { stop = true; } CHECK_EXIT(setEventFlag(eventFlag, WRITE_FLAG) != -1, STRING_MSG); logger(LOG_INFO, &quot;read end: i = %d, size = %lu&quot;, i, size); } }} 48.2è§£é‡Šä¸ºä½•ç¨‹åºæ¸…å•48-3åœ¨ for å¾ªç¯è¢«ä¿®æ”¹æˆå¦‚ä¸‹å½¢å¼æ—¶ä¼šé”™è¯¯åœ°æŠ¥å‘Šäº†ä¼ è¾“å­—èŠ‚æ•°ã€‚ 123456for (xfrs =0,bytes = 0; shmp-&gt;cnt != 0; xfrs++,bytes += shmp-&gt;cnt) { reserveSem(semid,READ SEM); /*Wait for return*/ if(write(STDOUT_FILENO,shmp-&gt;buf,shmp-&gt;cnt) != shmp-&gt;cnt) fatal(&quot;write&quot;); releaseSem(semid,WRITE SEM); /*Give writer a return*/} åŸç‰ˆä»£ç  1234567for (xfrs =0; shmp-&gt;cnt != 0; xfrs++) { reserveSem(semid,READ SEM); /*Wait for return*/ if(write(STDOUT_FILENO,shmp-&gt;buf,shmp-&gt;cnt) != shmp-&gt;cnt) fatal(&quot;write&quot;); bytes += shmp-&gt;cnt; releaseSem(semid,WRITE SEM); /*Give writer a return*/} å¾ˆæ˜¾ç„¶ï¼Œä»–å°†bytesçš„è‡ªå¢æ”¾åœ¨äº†Semé”å®šåŒºåŸŸä¹‹å¤–ï¼Œç”±äºshmpæŒ‡å‘çš„æ˜¯å…±äº«å†…å­˜ï¼Œåœ¨releaseSemåˆ°byteså¢åŠ ä¹‹é—´ï¼ŒshmpæŒ‡å‘çš„åŒºåŸŸå†…å­˜ä¸­çš„å€¼å¯èƒ½å·²ç»å‘ç”Ÿæ”¹å˜ï¼Œé€ æˆç»Ÿè®¡ä¸å‡†ç¡®ã€‚ 48.5ç¼–å†™ä¸€ä¸ªç›®å½•æœåŠ¡ä½¿ä¹‹ä½¿ç”¨ä¸€ä¸ªå…±äº«å†…å­˜æ®µæ¥å‘å¸ƒåç§°-å€¼å¯¹ã€‚ç¨‹åºéœ€è¦æä¾›ä¸€ä¸ªAPIæ¥å…è®¸è°ƒç”¨è€…åˆ›å»ºæ–°åç§°ã€ä¿®æ”¹ä¸€ä¸ªæ—¢æœ‰åç§°ã€åˆ é™¤ä¸€ä¸ªæ—¢æœ‰åç§°ä»¥åŠè·å–ä¸ä¸ªåç§°ç›¸å…³è”çš„å€¼ã€‚ä½¿ç”¨ä¿¡å·é‡æ¥ç¡®ä¿ä¸€ä¸ªæ‰§è¡Œå…±äº«å†…å­˜æ®µæ›´æ–°æ“ä½œçš„è¿›ç¨‹èƒ½å¤Ÿäº’æ–¥åœ°è®¿é—®æ®µã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369//// Created by root on 9/14/23.//#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;stdbool.h&gt;#include &lt;stddef.h&gt;#include &lt;syslog.h&gt;#include &lt;wait.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/shm.h&gt;#define DEBUG_LEVEL LOG_DEBUG#ifndef DEBUG_LEVEL#define DEBUG_LEVEL LOG_INFO#endif#define STRING_MSG &quot;MSG&quot;FILE *logfile = NULL;bool syslog_enable = false;void __attribute__ ((constructor)) init() { syslog_enable = false; logfile = stderr;}#define alloc_sprintf(__alloc_sprintf_str, __format...) do { \\ int __alloc_sprintf_len = snprintf(NULL, 0, __format); \\ (__alloc_sprintf_str) = malloc(__alloc_sprintf_len+1); \\ if(__alloc_sprintf_str != NULL) \\ snprintf(__alloc_sprintf_str, __alloc_sprintf_len+1, __format); \\} while(0)#define logger(level, msg...) do { \\ if(level &lt;= DEBUG_LEVEL) { \\ fprintf(logfile, &quot;[%ld] &quot;, (long) getpid()); \\ fprintf(logfile, msg); \\ fprintf(logfile, &quot;\\n&quot;); \\ } \\ if(syslog_enable) { \\ char *__syslog_enable__data; \\ alloc_sprintf(__syslog_enable__data, msg); \\ syslog(level, &quot;%s&quot;, __syslog_enable__data); \\ safe_free(__syslog_enable__data); \\ } \\} while(0)#define COND_RET(x, ret, msg...) \\ do { \\ if(!(x)) { \\ if(errno != 0) logger(LOG_ERR, &quot;Error(%d): %s&quot;, errno, strerror(errno)); \\ logger(LOG_ERR, &quot;%s:%d&quot;, __FILE__, __LINE__); \\ logger(LOG_ERR, &quot;unmet condition:\\&quot;%s\\&quot;&quot;, #x); \\ logger(LOG_ERR, msg); \\ ret; \\ } \\ errno = 0; \\ } while(0)#define CHECK(x, msg...) COND_RET(x, return -1;, msg)#define CHECK_EXIT(x, msg...) COND_RET(x, exit(EXIT_FAILURE);, msg)#define CHECK_LOG(x, msg...) COND_RET(x, ;, msg)#define safe_free(__safe_free_ptr) do { if(__safe_free_ptr) { free(__safe_free_ptr); (__safe_free_ptr) = NULL;} } while(0)#define BUFFER_SIZE 4096*4096union semun { int val; struct semid_ds *buf; unsigned short *array;#if defined(__linux__) struct seminfo *__buf;#endif};int incrsem(int sem_id, int semnum, short incr, short flg) { struct sembuf sembuf; sembuf = (struct sembuf){ .sem_num=semnum, .sem_flg=flg, .sem_op=incr }; return semop(sem_id, &amp;sembuf, 1);}int P(int sem_id, int semnum) { return incrsem(sem_id, semnum, -1, 0);}int V(int sem_id, int semnum) { return incrsem(sem_id, semnum, 1, 0);}int getsem(int sem_id, int semnum, short *n) { union semun arg; int ret = semctl(sem_id, semnum, GETVAL); *n = ret; return ret;}int setsem(int sem_id, int semnum, short n) { union semun arg; arg.val = n; return semctl(sem_id, semnum, SETVAL, arg);}int newMutex(const char *file, char x, int semcnt) { key_t key = ftok(file, x); int semid = semget(key, semcnt, IPC_CREAT | IPC_EXCL | 0666); // sem[0] as mutex, sem[1] as notifier, sem[2]|sem[3] as flag union semun arg; if(semid == -1) { if(errno == EEXIST) { semid = semget(key, semcnt, 0666); CHECK(semid != -1, STRING_MSG); struct semid_ds ds; arg.buf = &amp;ds; CHECK(semctl(semid, 0, IPC_STAT, arg) != -1, STRING_MSG); while (ds.sem_otime == 0) { logger(LOG_INFO, &quot;waiting for sem init&quot;); sleep(1); CHECK(semctl(semid, 0, IPC_STAT, arg) != -1, STRING_MSG); } logger(LOG_INFO, &quot;semget get old: %d&quot;, semid); } else { CHECK_LOG(false, STRING_MSG); return -1; } } else { arg.array = (unsigned short *)malloc(sizeof(unsigned short) * semcnt); // sem[0] = 0, sem[1] = 1, sem[2] = 1, ... for(int i = 0; i &lt; semcnt; i++) { arg.array[i] = 1; } arg.array[0] = 0; if(semctl(semid, 0, SETALL, arg) == -1) { CHECK_LOG(false, STRING_MSG); CHECK_LOG(semctl(semid, 0, IPC_RMID) != -1, STRING_MSG); return -1; } safe_free(arg.array); if(incrsem(semid, 0,1,0) == -1) { CHECK_LOG(false, STRING_MSG); CHECK_LOG(semctl(semid, 0, IPC_RMID) != -1, STRING_MSG); return -1; } logger(LOG_INFO, &quot;semget create new: %d&quot;, semid); } return semid;}void handler(int sig) { logger(LOG_INFO, &quot;received signal(%d):%s&quot;, sig, strsignal(sig)); exit(0);}#define KVMax 1024*8#define KMax 1024#define VMax 1024struct KVData { char key[KMax]; char val[VMax];};void *initshm(int argc, char *argv[], int *shmid) { signal(SIGINT, handler); signal(SIGTERM, handler); signal(SIGHUP, handler); key_t key = ftok(argv[0], 'c'); CHECK_EXIT(key != -1, STRING_MSG); *shmid = shmget(key, BUFFER_SIZE, IPC_CREAT | IPC_EXCL | 0666); int savedErrno = errno; CHECK_EXIT(*shmid != -1 || errno == EEXIST, STRING_MSG); bool creator = false; if(*shmid == -1) { if(savedErrno == EEXIST) { *shmid = shmget(key, BUFFER_SIZE, 0666); } else { CHECK_EXIT(false, &quot;code will never reach&quot;); } } else { creator = true; } void *shmp = shmat(*shmid, NULL, 0); CHECK_EXIT(shmp != NULL, STRING_MSG); if(creator) memset(shmp, 0, BUFFER_SIZE); return shmp;}int getValue(int semid, char *head, char* key, char *value) { CHECK(head != NULL, &quot;head should not be null&quot;); CHECK(key != NULL, &quot;key should not be null&quot;); CHECK(value != NULL, &quot;value should not be null&quot;); bool ok = false; for(int i = 0; i &lt; KVMax &amp;&amp; !ok; i++) { CHECK(P(semid, i) != -1, STRING_MSG); struct KVData *data = (struct KVData *)head; if(!strcmp(key, data-&gt;key)) { logger(DEBUG_LEVEL, &quot;data-&gt;key = %s&quot;, data-&gt;key); logger(DEBUG_LEVEL, &quot;data-&gt;val = %s&quot;, data-&gt;val); strncpy(value, data-&gt;val, VMax); value[VMax-1] = 0; ok = true; } else { head += sizeof(struct KVData); } CHECK(V(semid, i) != -1, STRING_MSG); } if(!ok) return -1; return 0;}int setValue(int semid, char *head, char* key, char *value) { CHECK(head != NULL, &quot;head should not be null&quot;); CHECK(key != NULL, &quot;key should not be null&quot;); CHECK(value != NULL, &quot;value should not be null&quot;); bool ok = false; for(int i = 0; i &lt; KVMax &amp;&amp; !ok; i++) { CHECK(P(semid, i) != -1, STRING_MSG); struct KVData *data = (struct KVData *)head; logger(DEBUG_LEVEL, &quot;data = %p, key = %s, val = %s&quot;, data, data-&gt;key, data-&gt;val); if(!strcmp(key, data-&gt;key)) { strncpy(data-&gt;val, value, VMax); data-&gt;val[VMax-1] = 0; ok = true; } else { head += sizeof(struct KVData); } CHECK(V(semid, i) != -1, STRING_MSG); } if(!ok) return -1; return 0;}int addKV(int semid, char *head, char* key, char *value) { CHECK(head != NULL, &quot;head should not be null&quot;); CHECK(key != NULL, &quot;key should not be null&quot;); CHECK(value != NULL, &quot;value should not be null&quot;); bool ok = false; for(int i = 0; i &lt; KVMax &amp;&amp; !ok; i++) { CHECK(P(semid, i) != -1, STRING_MSG); struct KVData *data = (struct KVData *)head; if(!*data-&gt;key) { logger(DEBUG_LEVEL, &quot;i = %d, data = %p&quot;, i, data); strncpy(data-&gt;key, key, KMax); strncpy(data-&gt;val, value, VMax); data-&gt;key[KMax-1] = 0; data-&gt;val[VMax-1] = 0; ok = true; } else { head += sizeof(struct KVData); } CHECK(V(semid, i) != -1, STRING_MSG); } if(!ok) return -1; return 0;}int getAll(int semid, char *head, char *value) { CHECK(head != NULL, &quot;head should not be null&quot;); CHECK(value != NULL, &quot;value should not be null&quot;); char *ret = value; for(int i = 0; i &lt; KVMax; i++) { CHECK(P(semid, i) != -1, STRING_MSG); struct KVData *data = (struct KVData *)head; if(*data-&gt;key) { strncpy(ret, data-&gt;key, KMax); ret = strchr(ret, '\\0'); strcpy(ret, &quot;:&quot;); ret++; strncpy(ret, data-&gt;val, VMax); ret = strchr(ret, '\\0'); strcpy(ret, &quot;\\n&quot;); ret++; } head += sizeof(struct KVData); CHECK(V(semid, i) != -1, STRING_MSG); } return 0;}int rmKV(int semid, char *head, char* key, char *value) { CHECK(key != NULL, &quot;key should not be null&quot;); CHECK(head != NULL, &quot;head should not be null&quot;); CHECK(value != NULL, &quot;value should not be null&quot;); bool ok = false; for(int i = 0; i &lt; KVMax &amp;&amp; !ok; i++) { CHECK(P(semid, i) != -1, STRING_MSG); struct KVData *data = (struct KVData *)head; if(!strcmp(key, data-&gt;key)) { strncpy(value, data-&gt;val, VMax); value[VMax-1] = 0; data-&gt;key[0] = 0; data-&gt;val[0] = 0; ok = true; } else { head += sizeof(struct KVData); } CHECK(V(semid, i) != -1, STRING_MSG); } if(!ok) return -1; return 0;}int main(int argc, char *argv[]) { CHECK_EXIT(argc &gt; 1, &quot;Usage: %s add|get|set|getAll|rm|destroy&quot;, argv[0]); int shmid; char *shmp = initshm(argc, argv, &amp;shmid); int mutexid = newMutex(argv[0], 'a', KVMax+1); CHECK_EXIT(mutexid != -1, STRING_MSG); if(!strcmp(&quot;get&quot;, argv[1])) { CHECK_EXIT(argc &gt; 2, &quot;Usage: %s set [key]&quot;, argv[0]); char *value = malloc(VMax); for(int i = 2; i &lt; argc; i++) { getValue(mutexid, shmp, argv[i], value); logger(LOG_INFO, &quot;value for \\&quot;%s\\&quot; is %s&quot;, argv[i], value); } safe_free(value); } else if(!strcmp(&quot;set&quot;, argv[1])) { CHECK_EXIT(argc &gt; 2, &quot;Usage: %s set [key:value]&quot;, argv[0]); for(int i = 2; i &lt; argc; i++) { char *value = strchr(argv[i], ':'); if(!value) { CHECK_EXIT(false, &quot;Usage: %s set [key:value]&quot;, argv[0]); } *value = 0; value++; setValue(mutexid, shmp, argv[i], value); logger(LOG_INFO, &quot;value for \\&quot;%s\\&quot; is %s&quot;, argv[i], value); } } else if(!strcmp(&quot;add&quot;, argv[1])) { CHECK_EXIT(argc &gt; 2, &quot;Usage: %s add [key:value]&quot;, argv[0]); for(int i = 2; i &lt; argc; i++) { char *value = strchr(argv[i], ':'); if(!value) { CHECK_EXIT(false, &quot;Usage: %s set [key:value]&quot;, argv[0]); } *value = 0; value++; addKV(mutexid, shmp, argv[i], value); logger(LOG_INFO, &quot;value for \\&quot;%s\\&quot; is %s&quot;, argv[i], value); } } else if(!strcmp(&quot;rm&quot;, argv[1])) { CHECK_EXIT(argc &gt; 2, &quot;Usage: %s add [key:value]&quot;, argv[0]); char *value = malloc(VMax); for(int i = 2; i &lt; argc; i++) { rmKV(mutexid, shmp, argv[i], value); logger(LOG_INFO, &quot;value for \\&quot;%s\\&quot; is %s&quot;, argv[i], value); } safe_free(value); } else if(!strcmp(&quot;getAll&quot;, argv[1])) { char *value = malloc((VMax + KMax) * KVMax); getAll(mutexid, shmp, value); logger(LOG_INFO, &quot;getAll&quot;); logger(LOG_INFO, &quot;%s&quot;, value); safe_free(value); } else if(!strcmp(&quot;destroy&quot;, argv[1])) { CHECK_LOG(semctl(mutexid, 0, IPC_RMID) != -1, STRING_MSG); CHECK_LOG(shmctl(shmid, IPC_RMID, NULL) != -1, STRING_MSG); } else { CHECK_EXIT(false, &quot;unknown operator: %s&quot;, argv[1]); } return 0;}","link":"/home/2023/09/14/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha48/"},{"title":"cha50.è™šæ‹Ÿå†…å­˜æ“ä½œ","text":"50.1ç¼–å†™ä¸€ä¸ªç¨‹åºä½¿å…¶ä¸ºRLIMITMEMLOCKèµ„æºé™åˆ¶è®¾ç½®ä¸€ä¸ªå€¼ä¹‹åå°†æ•°é‡è¶…è¿‡è¿™ä¸ªé™åˆ¶çš„å†…å­˜é”è¿›å†…å­˜æ¥éªŒè¯RLIMITMEMLOCKèµ„æºé™åˆ¶çš„ä½œç”¨ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136//// Created by root on 7/18/23.//#include &lt;utils.h&gt;#include &lt;limits.h&gt;#include &lt;sys/resource.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;signal.h&gt;#define USER 10087void test(__rlimit_resource_t res, const char *name,void (*task)(__rlimit_resource_t res, struct rlimit *)) { logger(LOG_INFO, &quot;test: %d(%s)&quot;, res, name); pid_t pid; CHECK_RET((pid = fork()) != -1, return;); if(!pid) { struct rlimit lim; CHECK_RET(getrlimit(res, &amp;lim) != -1, return;); logger(LOG_INFO, &quot;soft=%lu, hard=%lu&quot;, lim.rlim_cur, lim.rlim_max); task(res, &amp;lim); logger(LOG_INFO, &quot;soft=%lu, hard=%lu&quot;, lim.rlim_cur, lim.rlim_max); exit(0); } int status; CHECK_RET(waitpid(pid, &amp;status, 0) != -1, return;); if(WIFSIGNALED(status)) logger(LOG_INFO, &quot;status:%d, coredump:%d, term sig:%s(%d)&quot;, WEXITSTATUS(status), WCOREDUMP(status), strsignal(WTERMSIG(status)), WTERMSIG(status)); else if(WIFSTOPPED(status)) logger(LOG_INFO, &quot;status:%d, coredump:%d, term sig:%s(%d)&quot;, WEXITSTATUS(status), WCOREDUMP(status), strsignal(WSTOPSIG(status)), WSTOPSIG(status)); else logger(LOG_INFO, &quot;status:%d, coredump:%d&quot;, WEXITSTATUS(status), WCOREDUMP(status)); CHECK_RET(WEXITSTATUS(status) != 0 || WCOREDUMP(status) || WIFSTOPPED(status) || WIFSIGNALED(status), return;);}#define invoke_test(res) test(res, #res, f##res)#define fun(name) void f##name(__rlimit_resource_t res, struct rlimit *lim)fun(RLIMIT_MEMLOCK) { long pagesize = sysconf(_SC_PAGESIZE); bool error_occured = false; lim-&gt;rlim_cur = lim-&gt;rlim_max = pagesize * 2; // = pagesizeæ—¶ï¼Œlockä¸€ä¸ªä¹Ÿä¼šå‡ºé”™ï¼Œå¯èƒ½å·²ç»é»˜è®¤æœ‰ä¸€é¡µçš„å†…å­˜è¢«lockäº†ï¼ˆæ¯”å¦‚ä»£ç æ®µï¼Œæ•°æ®æ®µ CHECK_EXIT(setrlimit(res, lim) != -1); CHECK_EXIT(setuid(USER) != -1); void *mem; mem = malloc(pagesize*2); CHECK_LOG(mem != NULL); if(mlock(mem, pagesize) == -1) { //success CHECK_LOG(false); error_occured = true; } CHECK_LOG(munlock(mem, pagesize) != -1); safe_free(mem); mem = malloc(pagesize*3); CHECK_LOG(mem != NULL); if(mlock(mem, pagesize*2) == -1) { //fail CHECK_LOG(false); error_occured = true; } CHECK_LOG(munlock(mem, pagesize *2) != -1); safe_free(mem); if((mem = mmap(NULL, pagesize *3, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS | MAP_LOCKED, -1, 0)) == MAP_FAILED) { //fail CHECK_LOG(false); error_occured = true; } else { CHECK_LOG(munmap(mem, pagesize *3) != -1); } CHECK_LOG((mem = mmap(NULL, pagesize *3, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0)) != MAP_FAILED); if(mlock(mem, pagesize*3) == -1) { //fail CHECK_LOG(false); error_occured = true; } CHECK_LOG(munmap(mem, pagesize *3) != -1); if(error_occured) { exit(1); } exit(0);}#define BUFFER_SIZE 2048struct msgType { long mtype; char mcontent[BUFFER_SIZE];};#define REQ_SIZE (BUFFER_SIZE)void on_exit_msg(int status, void *id) { CHECK_LOG(msgctl(*(int *)id, IPC_RMID, NULL) != -1);}void timeout(int sig) { logger(LOG_INFO, &quot;received sig(%d):%s&quot;, sig, strsignal(sig)); exit(1); // CHECK_LOG(signal(SIGALRM, SIG_DFL) != SIG_ERR); // raise(SIGALRM);}fun(RLIMIT_MSGQUEUE) { struct msgType msg; msg.mtype = 1; strcpy(msg.mcontent, &quot;Meow!!&quot;); int id; CHECK_EXIT((id = msgget(IPC_PRIVATE, IPC_CREAT | 0666)) != -1); CHECK_EXIT(msgsnd(id, &amp;msg, REQ_SIZE, 0) != -1); CHECK_EXIT(msgctl(id, IPC_RMID, NULL) != -1); lim-&gt;rlim_cur = lim-&gt;rlim_max = BUFFER_SIZE/2; CHECK_EXIT(setrlimit(res, lim) != -1); CHECK_EXIT(setuid(USER) != -1); on_exit(on_exit_msg, &amp;id); CHECK_EXIT(signal(SIGALRM, timeout) != SIG_ERR); CHECK_EXIT((id = msgget(IPC_PRIVATE, IPC_CREAT | 0666)) != -1); CHECK_EXIT(msgsnd(id, &amp;msg, REQ_SIZE, 0) != -1); CHECK_EXIT(msgsnd(id, &amp;msg, REQ_SIZE, 0) != -1); CHECK_EXIT(msgsnd(id, &amp;msg, REQ_SIZE, 0) != -1); CHECK_EXIT(msgsnd(id, &amp;msg, REQ_SIZE, 0) != -1); CHECK_EXIT(msgsnd(id, &amp;msg, REQ_SIZE, 0) != -1); CHECK_EXIT(msgsnd(id, &amp;msg, REQ_SIZE, 0) != -1); CHECK_EXIT(msgsnd(id, &amp;msg, REQ_SIZE, 0) != -1); CHECK_EXIT(msgsnd(id, &amp;msg, REQ_SIZE, 0) != -1); CHECK_EXIT(alarm(1) != -1); CHECK_EXIT(msgsnd(id, &amp;msg, REQ_SIZE, 0) != -1);}fun(RLIMIT_RSS);int main(int argc, char ** argv) { invoke_test(RLIMIT_MEMLOCK); //è¿˜æ²¡å­¦ invoke_test(RLIMIT_MSGQUEUE); //è¿˜æ²¡å­¦// invoke_test(RLIMIT_RSS); //linuxæ²¡ä½œç”¨} 50.2å†™ä¸€ä¸ªç¨‹åºæ¥éªŒè¯madvise MADV DONTNEEDæ“ä½œåœ¨ä¸€ä¸ªå¯å†™MAP_PRIVATEæ˜ å°„ä¸Šçš„æ“ä½œã€‚ 12345678910111213141516171819202122//// Created by root on 7/18/23.//#include &lt;utils.h&gt;#include &lt;limits.h&gt;#include &lt;sys/resource.h&gt;#include &lt;sys/mman.h&gt;int main(int argc, char ** argv) { long pagesize = sysconf(_SC_PAGESIZE); char *mem; CHECK_EXIT((mem = mmap(NULL, pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)) != MAP_FAILED); memset(mem, 'a', pagesize); CHECK_EXIT(madvise(mem, pagesize, MADV_DONTNEED) != -1); for(int i = 0; i &lt; pagesize; i++) { if(mem[i] == 0) logger(LOG_INFO, &quot;mem:%p filled with '\\\\0'&quot;, mem); else if(mem[i] == 'a') logger(LOG_INFO, &quot;mem:%p remains to be 'a'&quot;, mem); else logger(LOG_INFO, &quot;mem:%p contains dirty data&quot;, mem); } CHECK_EXIT(munmap(mem, pagesize) != -1);}","link":"/home/2023/09/19/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha50/"},{"title":"cha7.å†…å­˜åˆ†é…","text":"7.1 ä¿®æ”¹ç¨‹åºæ¸…å•7-1ä¸­çš„ç¨‹åº(free_and_sbrk.c)ï¼Œåœ¨æ¯æ¬¡æ‰§è¡Œmallocåæ‰“å°å‡º program breakçš„å½“å‰å€¼ã€‚æŒ‡å®šä¸€ä¸ªè¾ƒå°çš„å†…å­˜åˆ†é…å°ºå¯¸æ¥è¿è¡Œè¯¥ç¨‹åºã€‚è¿™å°†è¯æ˜mallocä¸ä¼šåœ¨æ¯æ¬¡è¢«è°ƒç”¨æ—¶éƒ½è°ƒç”¨sbrk()æ¥è°ƒæ•´program break çš„ä½ç½®ï¼Œè€Œæ˜¯å‘¨æœŸæ€§åœ°åˆ†é…å¤§å—å†…å­˜ï¼Œå¹¶ä»ä¸­å°†å°ç‰‡å†…å­˜è¿”å›ç»™è°ƒç”¨è€…ã€‚ 1// ä¸ä»£ç 7.2mainç›¸åŒ 7.2 (é«˜çº§)å®ç° malloc()å’Œ free()ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#define CHECK(x, code, message, ...) if(!(x)) {fprintf(stderr, &quot;%s:%d, error: %s\\t----\\t&quot;, __FILE__, __LINE__, strerror(errno)); fprintf(stderr, (const char*)message, ##__VA_ARGS__); exit(code); }#define ERR(code, format, ...) fprintf(stderr, (const char*)format, ##__VA_ARGS__); exit(code)#define UNUSED 0#define USED 1#define EXIT_SBRK_FAIL 1#define UNKNOWN_FAIL 2#define UNKNOWN_MEM_ERROR 3#define FREE_TWICE 4#define MAXALLOC 100000void *freeMem = NULL;unsigned long getBlockSize(void *mem) { return *((unsigned long *)mem - 1);}void setBlockSize(void *mem, size_t size) { *((unsigned long *)mem - 1) = size;}void *getNextFreeBlock(void *__free) { return (unsigned long*) *((unsigned long *)__free + 1);}void setNextFreeBlock(void *__free, void *__ptr) { *((unsigned long *)__free + 1) = (unsigned long)__ptr;}void *getPrevFreeBlock(void *__free) { return (unsigned long*) *(unsigned long *)__free;}void setPrevFreeBlock(void *__free, void *__ptr) { *(unsigned long *)__free = (unsigned long)__ptr;}char getUsed(void *__ptr) { return *((char *)__ptr - 1 - sizeof(void *));}void setUsed(void *__ptr, char used) { *((char *)__ptr - 1 - sizeof(void *)) = used;}void memInit(char used, void *__ptr, void *prev, void *next, size_t size) { setUsed(__ptr, used); setBlockSize(__ptr, size); setPrevFreeBlock(__ptr, prev); setNextFreeBlock(__ptr, next);}void *firstFit(size_t size) { void *move = freeMem; void *next = getNextFreeBlock(freeMem); while(next != NULL) { if(getBlockSize(next) &gt;= size) { break; } move = next; next = getNextFreeBlock(next); } return move;}void *__malloc(size_t size) { if(freeMem == NULL) { freeMem = sbrk(sizeof(void *) * 3 + 1); CHECK(freeMem != (void*)-1, EXIT_SBRK_FAIL, &quot;sbrk fail\\n&quot;); freeMem += sizeof(void *) + 1; memInit(UNUSED, freeMem, NULL, NULL, sizeof(void *) * 2); } void *__free = firstFit(size); void *newMem = NULL; CHECK(__free != NULL, UNKNOWN_FAIL, &quot;unknown error\\n&quot;); if(getNextFreeBlock(__free) == NULL) { size = size &gt; 2 * sizeof(void *) ? size : 2 * sizeof(void *); newMem = sbrk(1 + sizeof(void *) + size); CHECK(newMem != (void*)-1, EXIT_SBRK_FAIL, &quot;sbrk fail\\n&quot;); newMem += 1 + sizeof(void *); memInit(USED, newMem, NULL, NULL, size); } else { newMem = getNextFreeBlock(__free); setUsed(newMem, USED); setNextFreeBlock(__free, getNextFreeBlock(newMem)); } return newMem;}void __free(void * __ptr) { CHECK(freeMem != NULL, UNKNOWN_MEM_ERROR,&quot;memory: %p is not allocated by __mallo\\n&quot;, __ptr); CHECK(getUsed(__ptr) == USED, FREE_TWICE, &quot;trying to free memory %p twice\\n&quot;, __ptr); setUsed(__ptr, UNUSED); void *move = freeMem; void *next = getNextFreeBlock(freeMem); void *front = (char *)__ptr - 1 - sizeof(void *), *back = (char *)__ptr + getBlockSize(__ptr); while(next != NULL) { if((char *)next - 1 - sizeof(void *) &gt;= (char *)back) { break; } move = next; next = getNextFreeBlock(next); } if(front == (char *)move + getBlockSize(move)) { setBlockSize(move, (char *)back - (char *)move); __ptr = move; } else { setNextFreeBlock(__ptr, getNextFreeBlock(move)); setNextFreeBlock(move, __ptr); setPrevFreeBlock(__ptr, move); } if(next == NULL) return; if(back == (char *)next - 1 - sizeof(void *)) { setBlockSize(__ptr, (char *)next + getBlockSize(next) - (char *)__ptr); } else { setPrevFreeBlock(next, __ptr); } return;}void __printMemblock(void* ptr) { printf(&quot;------------Memory Block %p---------------\\n&quot;, ptr); printf(&quot;front = %p, back = %p\\n&quot;, (char *)ptr - 1 - sizeof(void *), (char *)ptr + getBlockSize(ptr)); int used = *((char *)ptr - 1 - sizeof(unsigned long)); printf(&quot;used\\t\\t=\\t%d\\n&quot;, used); printf(&quot;blocksize\\t=\\t%lu\\n&quot;, *((unsigned long *)ptr - 1)); if(!used) { printf(&quot;last free block\\t=\\t%p\\n&quot;, (unsigned long*) *(unsigned long *)ptr); printf(&quot;next free block\\t=\\t%p\\n&quot;, (unsigned long*) *((unsigned long *)ptr + 1)); } printf(&quot;Current brk = %p\\n&quot;, sbrk(0));}void __showFreeBlocks() { printf(&quot;show free blocks\\n&quot;); void *move = freeMem; while(move) { __printMemblock(move); move = getNextFreeBlock(move); }}int main(int argc, char *argv[]) { if(argc &lt; 3) { ERR(1, &quot;Usage: %s numalloc blocksize [freestep] [freemin] [freemax]\\n&quot;, argv[0]); } int numalloc = atoi(argv[1]); size_t blocksize = atoi(argv[2]); int freestep = argc &gt; 3 ? atoi(argv[3]) : 1; int freemin = argc &gt; 4 ? atoi(argv[4]) : 1; int freemax = argc &gt; 5 ? atoi(argv[5]) : numalloc; void *ptr[MAXALLOC]; if(numalloc &gt; MAXALLOC) { ERR(2, &quot;constraint: numalloc &lt;= %d\\n&quot;, MAXALLOC); } printf(&quot;sizeof(void *) = %lu\\n&quot;, sizeof(void *)); printf(&quot;Start to allocate mem, Current program break: %p\\n&quot;, sbrk(0)); for(int i = 0; i &lt; numalloc; i++) { ptr[i] = __malloc(blocksize); if(ptr[i] == NULL) { ERR(3, &quot;fail to __malloc loc: %d\\n&quot;, i); } printf(&quot;Current program break: %p\\n&quot;, sbrk(0)); __printMemblock(ptr[i]); } for(int i = 0; i &lt; numalloc; i++) { __printMemblock(ptr[i]); } __showFreeBlocks(); printf(&quot;Allocation finished, Current program break: %p\\n&quot;, sbrk(0)); for(int i = freemin-1; i &lt; freemax; i += freestep) { __free(ptr[i]); printf(&quot;Current program break: %p\\n&quot;, sbrk(0)); __printMemblock(ptr[i]); } printf(&quot;Mem __free finished, Current program break: %p\\n&quot;, sbrk(0)); for(int i = freemin-1; i &lt; freemax; i += freestep) { __printMemblock(ptr[i]); } __showFreeBlocks(); return 0;} size_tå’Œunsigned longä»¥åŠvoid *ç±»å‹è½¬æ¢ä¹‹é—´è¿˜åœ¨æŠ¥warning æ²¡æœ‰å­—èŠ‚å¯¹é½ mallocæ‰¾ä¸åˆ°åˆé€‚çš„å—æ—¶ï¼Œæ¯æ¬¡éƒ½ä¼šsbrkæŠ¬å‡program break åªå®ç°äº†first fit bug fix freeMemä¸ºç©ºæ—¶å…ˆæŠ¬å‡program breakï¼Œä½œä¸ºé“¾è¡¨å¤´èŠ‚ç‚¹ï¼Œä½†æ˜¯å¯¹è¿™å—å†…å­˜çš„åˆ†é…ï¼ŒmemInit(UNUSED, freeMem, NULL, NULL, 0);ï¼Œæœ€åä¸€ä¸ªå‚æ•°ä¸åº”è¯¥æ˜¯0ï¼Œè€Œåº”è¯¥æ˜¯ 2 * sizeof(void *)ã€‚ ä¸€æ¬¡æ€§åˆ†é…å¤§å—å†…å­˜123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#define CHECK(x, code, message, ...) if(!(x)) {fprintf(stderr, &quot;%s:%d, error: %s\\t----\\t&quot;, __FILE__, __LINE__, strerror(errno)); fprintf(stderr, (const char*)message, ##__VA_ARGS__); exit(code); }#define ERR(code, format, ...) fprintf(stderr, (const char*)format, ##__VA_ARGS__); exit(code)#define UNUSED 0#define USED 1#define EXIT_SBRK_FAIL 1#define UNKNOWN_FAIL 2#define UNKNOWN_MEM_ERROR 3#define FREE_TWICE 4#define MAXALLOC 100000#define PAGE 0x010000void *freeMem = NULL;unsigned long getBlockSize(void *mem) { return *((unsigned long *)mem - 1);}void setBlockSize(void *mem, size_t size) { *((unsigned long *)mem - 1) = size;}void *getNextFreeBlock(void *__free) { return (unsigned long*) *((unsigned long *)__free + 1);}void setNextFreeBlock(void *__free, void *__ptr) { *((unsigned long *)__free + 1) = (unsigned long)__ptr;}void *getPrevFreeBlock(void *__free) { return (unsigned long*) *(unsigned long *)__free;}void setPrevFreeBlock(void *__free, void *__ptr) { *(unsigned long *)__free = (unsigned long)__ptr;}char getUsed(void *__ptr) { return *((char *)__ptr - 1 - sizeof(void *));}void setUsed(void *__ptr, char used) { *((char *)__ptr - 1 - sizeof(void *)) = used;}void memInit(char used, void *__ptr, void *prev, void *next, size_t size) { setUsed(__ptr, used); setBlockSize(__ptr, size); setPrevFreeBlock(__ptr, prev); setNextFreeBlock(__ptr, next);}void *firstFit(size_t size) { void *move = freeMem; void *next = getNextFreeBlock(freeMem); while(next != NULL) { if(getBlockSize(next) &gt;= size) { break; } move = next; next = getNextFreeBlock(next); } return move;}void *__malloc(size_t size) { if(freeMem == NULL) { freeMem = sbrk(PAGE); CHECK(freeMem != (void*)-1, EXIT_SBRK_FAIL, &quot;sbrk fail\\n&quot;); freeMem += sizeof(void *) + 1; memInit(UNUSED, freeMem, NULL, freeMem + sizeof(void *) * 3 + 1, sizeof(void *) * 2); memInit(UNUSED, freeMem + sizeof(void *) * 3 + 1, freeMem, NULL, PAGE - (1 + sizeof(void *) + 1 + 3*sizeof(void *))); } void *__free = firstFit(size); void *newMem = NULL; CHECK(__free != NULL, UNKNOWN_FAIL, &quot;unknown error\\n&quot;); if(getNextFreeBlock(__free) == NULL) { size = size &gt; 2 * sizeof(void *) ? size : 2 * sizeof(void *); size_t newSize = PAGE * (size / PAGE + 1) + 1 + sizeof(void *) + 1 + 3 * sizeof(void *); newMem = sbrk(newSize); // æŒ‰é¡µåˆ†é…ï¼Œå†åŠ ä¸€ä¸ªé“¾è¡¨å¤´ï¼Œä¸€ä¸ªå®Œæ•´é“¾è¡¨å¤´ CHECK(newMem != (void*)-1, EXIT_SBRK_FAIL, &quot;sbrk fail\\n&quot;); newMem += 1 + sizeof(void *); memInit(USED, newMem, NULL, NULL, size); void *next_free = (char *)newMem + size + 1 + sizeof(void *); setNextFreeBlock(__free, next_free); memInit(UNUSED, next_free, __free, NULL, newSize - (size + 1 + sizeof(void *) + 1 + sizeof(void *))); } else { newMem = getNextFreeBlock(__free); setUsed(newMem, USED); setNextFreeBlock(__free, getNextFreeBlock(newMem)); if(getBlockSize(newMem) &gt;= size + 1 + 3 * sizeof(void *)) { memInit(UNUSED, newMem + size + 1 + sizeof(void *), __free, getNextFreeBlock(__free), getBlockSize(newMem) - size - 1 - sizeof(void *)); setNextFreeBlock(__free, newMem + size + 1 + sizeof(void *)); if(getNextFreeBlock(newMem)) setPrevFreeBlock(getNextFreeBlock(newMem), newMem + size + 1 + sizeof(void *)); setBlockSize(newMem, size); } // å½“å‰å—çš„å¤§å°å¤§äºæœ¬æ¬¡åˆ†é…éœ€è¦çš„å¤§å°ï¼Œä¸”å‰©ä½™éƒ¨åˆ†ä»èƒ½æ”¾çš„çš„ä¸‹ä¸€ä¸ªå®Œæ•´çš„é“¾è¡¨å¤´ï¼Œåˆ™å°†è¯¥éƒ¨åˆ†å†æ¬¡åˆå§‹åŒ–ä¸€ä¸ªç©ºé—²èŠ‚ç‚¹ï¼Œæ’å…¥åŸåŒå‘é“¾è¡¨ä¸­ } return newMem;}void __free(void * __ptr) { CHECK(freeMem != NULL, UNKNOWN_MEM_ERROR,&quot;memory: %p is not allocated by __mallo\\n&quot;, __ptr); CHECK(getUsed(__ptr) == USED, FREE_TWICE, &quot;trying to free memory %p twice\\n&quot;, __ptr); setUsed(__ptr, UNUSED); void *move = freeMem; void *next = getNextFreeBlock(freeMem); void *front = (char *)__ptr - 1 - sizeof(void *), *back = (char *)__ptr + getBlockSize(__ptr); while(next != NULL) { if((char *)next - 1 - sizeof(void *) &gt;= (char *)back) { break; } move = next; next = getNextFreeBlock(next); } if(front == (char *)move + getBlockSize(move) &amp;&amp; move != freeMem) { // moveä¸æ˜¯å¤´èŠ‚ç‚¹ï¼Œå¤´èŠ‚ç‚¹ä¸å‚ä¸åˆ°å†…å­˜åˆ†é…ä¸­ï¼Œä¸ä¸åé¢çš„ç©ºé—²å†…å­˜åˆå¹¶ setBlockSize(move, (char *)back - (char *)move); __ptr = move; } else { setNextFreeBlock(__ptr, getNextFreeBlock(move)); setNextFreeBlock(move, __ptr); setPrevFreeBlock(__ptr, move); } if(next == NULL) return; if(back == (char *)next - 1 - sizeof(void *)) { setBlockSize(__ptr, (char *)next + getBlockSize(next) - (char *)__ptr); setNextFreeBlock(__ptr, getNextFreeBlock(next)); if(getNextFreeBlock(next)) setPrevFreeBlock(getNextFreeBlock(next), __ptr); } else { setPrevFreeBlock(next, __ptr); setNextFreeBlock(__ptr, next); } return;}void __printMemblock(void* ptr) { printf(&quot;------------Memory Block %p---------------\\n&quot;, ptr); printf(&quot;front = %p, back = %p\\n&quot;, (char *)ptr - 1 - sizeof(void *), (char *)ptr + getBlockSize(ptr)); int used = *((char *)ptr - 1 - sizeof(unsigned long)); printf(&quot;used\\t\\t=\\t%d\\n&quot;, used); printf(&quot;blocksize\\t=\\t%lu\\n&quot;, *((unsigned long *)ptr - 1)); if(!used) { printf(&quot;last free block\\t=\\t%p\\n&quot;, (unsigned long*) *(unsigned long *)ptr); printf(&quot;next free block\\t=\\t%p\\n&quot;, (unsigned long*) *((unsigned long *)ptr + 1)); } printf(&quot;Current brk = %p\\n&quot;, sbrk(0));}void __showFreeBlocks() { printf(&quot;show free blocks\\n&quot;); void *move = freeMem; while(move) { __printMemblock(move); move = getNextFreeBlock(move); }}int main(int argc, char *argv[]) { if(argc &lt; 3) { ERR(1, &quot;Usage: %s numalloc blocksize [freestep] [freemin] [freemax]\\n&quot;, argv[0]); } int numalloc = atoi(argv[1]); size_t blocksize = atoi(argv[2]); int freestep = argc &gt; 3 ? atoi(argv[3]) : 1; int freemin = argc &gt; 4 ? atoi(argv[4]) : 1; int freemax = argc &gt; 5 ? atoi(argv[5]) : numalloc; void *ptr[MAXALLOC]; if(numalloc &gt; MAXALLOC) { ERR(2, &quot;constraint: numalloc &lt;= %d\\n&quot;, MAXALLOC); } printf(&quot;sizeof(void *) = %lu\\n&quot;, sizeof(void *)); printf(&quot;Start to allocate mem, Current program break: %p\\n&quot;, sbrk(0)); for(int i = 0; i &lt; numalloc; i++) { ptr[i] = __malloc(blocksize); if(ptr[i] == NULL) { ERR(3, &quot;fail to __malloc loc: %d\\n&quot;, i); } printf(&quot;Current program break: %p\\n&quot;, sbrk(0)); __printMemblock(ptr[i]); __showFreeBlocks(); } for(int i = 0; i &lt; numalloc; i++) { __printMemblock(ptr[i]); } __showFreeBlocks(); printf(&quot;Allocation finished, Current program break: %p\\n&quot;, sbrk(0)); for(int i = freemin-1; i &lt; freemax; i += freestep) { __free(ptr[i]); printf(&quot;Current program break: %p\\n&quot;, sbrk(0)); __printMemblock(ptr[i]); __showFreeBlocks(); } printf(&quot;Mem __free finished, Current program break: %p\\n&quot;, sbrk(0)); for(int i = freemin-1; i &lt; freemax; i += freestep) { __printMemblock(ptr[i]); } __showFreeBlocks(); return 0;} freeæ—¶å¦‚æœå†…å­˜å—çš„frontå’Œå‰ä¸€ä¸ªå—çš„backç›¸åŒï¼Œå…ˆåˆ¤æ–­moveæ˜¯å¦ä¸ºå¤´èŠ‚ç‚¹ï¼Œä¸æ˜¯å¤´èŠ‚ç‚¹å†åˆå¹¶ï¼Œå¤´èŠ‚ç‚¹ä¸å‚ä¸å†…å­˜åˆ†é… å¤´èŠ‚ç‚¹ä¸ºç©º/æ‰¾ä¸åˆ°åˆé€‚çš„å—æ—¶ï¼ŒæŠ¬å‡program breakï¼Œä¸€æ¬¡æ€§åˆ†é…å¤šä¸ªpageï¼ŒæŠŠå‰©ä½™éƒ¨åˆ†ä½œä¸ºæ–°çš„ç©ºé—²å†…å­˜èŠ‚ç‚¹ï¼ŒåŠ å…¥åˆ°åŒå‘é“¾è¡¨ä¸­ åº”è¯¥è¿˜æœ‰å¾ˆå¤šåœ°æ–¹æ²¡è€ƒè™‘åˆ°ï¼Œæ¯”å¦‚åˆ¤æ–­ä¸€ä¸ªå†…å­˜å—æ˜¯å¦æ˜¯__mallocåˆ†é…çš„ å½“freeStepä¸º1æ—¶ï¼Œæœ€åå‰©ä½™å†…å­˜é“¾è¡¨åªå‰©ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œä¸€ä¸ªé•¿åº¦ä¸º16çš„å¤´èŠ‚ç‚¹ï¼Œå’Œä¸€ä¸ªå®Œæ•´çš„å†…å­˜å—ï¼Œä¸”è¯¥å†…å­˜å—çš„backä¸å½“å‰program breakç›¸åŒã€‚","link":"/home/2023/04/09/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha7/"},{"title":"cha6.è¿›ç¨‹","text":"ç»ƒä¹ 1 ç¼–è¯‘ç¨‹åºæ¸…å•6-1ä¸­çš„ç¨‹åº(mem_segments.c)ï¼Œä½¿ç”¨1s-lå‘½ä»¤æ˜¾ç¤ºå¯æ‰§è¡Œæ–‡ä»¶çš„å¤§å°ã€‚è™½ç„¶è¯¥ç¨‹åºåŒ…å«ä¸€ä¸ªå¤§çº¦10MBçš„æ•°ç»„ï¼Œä½†å¯æ‰§è¡Œæ–‡ä»¶å¤§å°è¦è¿œå°äºæ­¤,ä¸ºä»€ä¹ˆ? å±€éƒ¨å˜é‡ï¼Œåˆ†é…åœ¨æ ˆä¸­ï¼Œè¿è¡Œæ—¶åˆ†é… ç»ƒä¹ 2 ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œè§‚å¯Ÿå½“ä½¿ç”¨ longjmp()å‡½æ•°è·³è½¬åˆ°ä¸€ä¸ªå·²ç»è¿”å›çš„å‡½æ•°æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆ? å¼€ä¼˜åŒ–ä¼šæ— é™é€’å½’ï¼Œä¸å¼€ä¼˜åŒ–ä¹Ÿæœ‰å¯èƒ½æ— é™é€’å½’ ç»ƒä¹ 3 ä½¿ç”¨getenv()å‡½æ•°ã€putenv()å‡½æ•°ï¼Œå¿…è¦æ—¶å¯ç›´æ¥ä¿®æ”¹environï¼Œæ¥å®ç°setenv()å‡½æ•°å’Œunsetenv()å‡½æ•°ã€‚æ­¤å¤„çš„unsetenv()å‡½æ•°åº”æ£€æŸ¥æ˜¯å¦å¯¹ç¯å¢ƒå˜é‡è¿›è¡Œäº†å¤šæ¬¡å®šä¹‰ï¼Œå¦‚æœæ˜¯å¤šæ¬¡å®šä¹‰åˆ™å°†ç§»é™¤å¯¹è¯¥å˜é‡çš„æ‰€æœ‰å®šä¹‰(glibcç‰ˆæœ¬çš„unsetenv()å‡½æ•°å®ç°äº†è¿™-åŠŸèƒ½) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;errno.h&gt;extern char **environ;int __setenv(const char *, const char *, int overwrite);// overwrite = 0, å·²å­˜åœ¨åˆ™ä¸æ”¹å˜, return 0/-1int __unsetenv(const char *);// return 0/-1#define setenv(a,b,c) errno = 0; \\if(__setenv(a, b, c) == -1) { \\ perror(&quot;setenv&quot;); \\ exit(1); \\}#define unsetenv(a) errno = 0; \\if(__unsetenv(a) == -1) { \\ perror(&quot;unsetenv&quot;); \\ exit(1); \\}// #define GETENVvoid printEnv();int main(int argc, char **argv) { clearenv(); environ = (char **)malloc(argc*sizeof(char *)); for(int i = 1; i &lt; argc; i++) { environ[i-1] = argv[i]; environ[i-1] = argv[i]; } environ[argc-1] = NULL; printEnv(); setenv(&quot;Jingtianer&quot;, &quot;pretty&quot;, 1); setenv(&quot;Jingtianer&quot;, &quot;handsome&quot;, 1); setenv(&quot;Meeow&quot;, &quot;handsome&quot;, 0); setenv(&quot;Meeow&quot;, &quot;pretty&quot;, 0); printEnv(); unsetenv(&quot;Meeow&quot;); unsetenv(&quot;Jingtianer&quot;); unsetenv(&quot;A&quot;); printEnv(); return 0;}void printEnv() { printf(&quot;environ=%p\\n&quot;, environ); if(environ != NULL) for(char **env=environ; *env; env++) { printf(&quot;%s\\n&quot;, *env); }}int __setenv(const char *name, const char *val, int overwrite) { #ifndef GETENV size_t nameLen = strlen(name); char **env=environ; if(env) for(; *env; env++) { if(strncmp(name, *env, nameLen) == 0) { if(overwrite == 0) return 0; else break; } } char * envstr = (char *) malloc((nameLen+strlen(val)+1+1)*sizeof(char)); sprintf(envstr, &quot;%s=%s&quot;, name, val); if(env != NULL &amp;&amp; *env != NULL) { *env = envstr; } else { return putenv(envstr); } return 0; #endif #ifdef GETENV char *env; if(env=getenv(name) != NULL &amp;&amp; overwrite == 0) { return 0; } size_t nameLen = strlen(name); char * envstr = (char *) malloc((nameLen+strlen(val)+1+1)*sizeof(char)); sprintf(envstr, &quot;%s=%s&quot;, name, val); return putenv(envstr); #endif}int __unsetenv(const char *name) { #ifndef GETENV if(environ == NULL) return 0; size_t nameLen = strlen(name); char **env=environ, **move = environ; for(; *env; env++) { if(strncmp(name, *env, nameLen) != 0) { *move = *env; move++; } } *move = NULL; return 0; #endif #ifdef GETENV char *env; if(env=getenv(name) != NULL) { return putenv(name); //å¹¶éæ ‡å‡†å®ç° } #endif}","link":"/home/2023/03/25/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha6/"},{"title":"cha8.ç”¨æˆ·å’Œç»„","text":"8.1è¿è¡Œä¸‹é¢ä»£ç ï¼Œä¸ºä»€ä¹ˆè¾“å‡ºä¼šç›¸åŒï¼Ÿ 12345678910#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;pwd.h&gt;int main() { struct passwd * p1 = getpwnam(&quot;redis&quot;); struct passwd * p2 = getpwnam(&quot;sshd&quot;); printf(&quot;getpwnam(\\&quot;redis\\&quot;)-&gt;pw_uid = %u, getpwnam(\\&quot;sshd\\&quot;)-&gt;pw_uid = %u\\n&quot;, p1-&gt;pw_uid, p2-&gt;pw_uid); printf(&quot;getpwnam(\\&quot;redis\\&quot;) = %p, getpwnam(\\&quot;sshd\\&quot;) = %p\\n&quot;, p1, p2); return 0;} getpwnamå’Œgetpwuidè¿”å›çš„æŒ‡é’ˆæŒ‡å‘ç”±é™æ€åˆ†é…çš„çš„å†…å­˜ï¼Œåœ°å€éƒ½æ˜¯ç›¸åŒçš„ï¼Œæ‰€ä»¥ä¼šå¯¼è‡´ç›¸åŒã€‚ 8.2ç”¨getpwentï¼Œsetpwentï¼Œendpwentå®ç°getpwnam 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;pwd.h&gt;#include &lt;string.h&gt;struct passwd getpwnamRet;struct passwd *__getpwnam(const char *name) { struct passwd *pwd = NULL; while((pwd = getpwent()) != NULL) { if(!strcmp(name, pwd-&gt;pw_name)) { break; } } endpwent(); if(pwd != NULL) { memcpy(&amp;getpwnamRet, pwd, sizeof(struct passwd)); return &amp;getpwnamRet; } return NULL;}void printpwd(struct passwd *pwd) { if(pwd == NULL) { printf(&quot;User not Found!\\n&quot;); return; } printf(&quot;Login name:\\t%s\\n&quot;, pwd-&gt;pw_name); printf(&quot;Login passwd:\\t%s\\n&quot;, pwd-&gt;pw_passwd); printf(&quot;User uid:\\t%u\\n&quot;, pwd-&gt;pw_uid); printf(&quot;User gid:\\t%u\\n&quot;, pwd-&gt;pw_gid); printf(&quot;User info:\\t%s\\n&quot;, pwd-&gt;pw_gecos); printf(&quot;Work dir:\\t%s\\n&quot;, pwd-&gt;pw_dir); printf(&quot;Login shell:\\t%s\\n&quot;, pwd-&gt;pw_shell);}int main(int argc, char *argv[]) { printpwd(__getpwnam(argv[1])); return 0;} äº‹å®ä¸Šï¼Œæ²¡æœ‰å¿…è¦ä¸ºäº†å®šä¹‰å…¨å±€å˜é‡getpwnamRetï¼Œå› ä¸ºgetpwentçš„è¿”å›å€¼æœ¬èº«å°±æ˜¯é™æ€åŒºçš„ 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;pwd.h&gt;#include &lt;string.h&gt;struct passwd *__getpwnam(const char *name) { struct passwd *pwd = NULL; while((pwd = getpwent()) != NULL) { if(!strcmp(name, pwd-&gt;pw_name)) { break; } } endpwent(); return pwd;}void printpwd(struct passwd *pwd) { if(pwd == NULL) { printf(&quot;User not Found!\\n&quot;); return; } printf(&quot;Login name:\\t%s\\n&quot;, pwd-&gt;pw_name); printf(&quot;Login passwd:\\t%s\\n&quot;, pwd-&gt;pw_passwd); printf(&quot;User uid:\\t%u\\n&quot;, pwd-&gt;pw_uid); printf(&quot;User gid:\\t%u\\n&quot;, pwd-&gt;pw_gid); printf(&quot;User info:\\t%s\\n&quot;, pwd-&gt;pw_gecos); printf(&quot;Work dir:\\t%s\\n&quot;, pwd-&gt;pw_dir); printf(&quot;Login shell:\\t%s\\n&quot;, pwd-&gt;pw_shell);}int main(int argc, char *argv[]) { struct passwd *p1 = __getpwnam(argv[1]), *p2 = __getpwnam(argv[2]); printpwd(p1); printpwd(p2); return 0;}","link":"/home/2023/04/10/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha8/"},{"title":"cha9.è¿›ç¨‹å‡­è¯","text":"9.19-1.åœ¨ä¸‹åˆ—æ¯ç§æƒ…å†µä¸­ï¼Œå‡è®¾è¿›ç¨‹ç”¨æˆ·IDçš„åˆå§‹å€¼åˆ†åˆ«ä¸ºreal(å®é™…) = 1000ã€effective(æœ‰æ•ˆï¼‰= 0ã€savedï¼ˆä¿å­˜ï¼‰= 0ã€file-systemï¼ˆæ–‡ä»¶ç³»ç»Ÿï¼‰= 0ã€‚å½“æ‰§è¡Œè¿™äº›è°ƒç”¨åï¼Œç”¨æˆ·IDçš„çŠ¶æ€å¦‚ä½•? 12345setuid(2000);setreuid(-1, 2000);seteuid(2000);setfsuid(2000);setresuid(-1,2000,3000); å®éªŒä»£ç 12345678910111213141516171819202122232425262728293031323334353637#define _GNU_SOURCE#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/fsuid.h&gt;int main(int argc, char *argv[]) { setresuid(1000, 0, 0); setfsuid(0); int test = atoi(argv[1]); uid_t r, e, s, fs; if(getresuid(&amp;r, &amp;e, &amp;s) == -1) return 1; fs = setfsuid(0); printf(&quot;real = %u, effective = %u, save = %u, fs = %u\\n&quot;, r, e, s, fs); switch (test) { case 1: printf(&quot;setuid(2000) = %d\\n&quot;, setuid(2000)); break; case 2: printf(&quot;setreuid(-1, 2000) = %d\\n&quot;, setreuid(-1, 2000)); break; case 3: printf(&quot;seteuid(2000) = %d\\n&quot;, seteuid(2000)); break; case 4: printf(&quot;setfsuid(2000) = %d\\n&quot;, setfsuid(2000)); break; case 5: printf(&quot;setresuid(-1, 2000, 3000) = %d\\n&quot;, setresuid(-1, 2000, 3000)); break; } if(getresuid(&amp;r, &amp;e, &amp;s) == -1) return 1; fs = setfsuid(0); printf(&quot;real = %u, effective = %u, save = %u, fs = %u\\n&quot;, r, e, s, fs); return 0;} ç¯å¢ƒå‡†å¤‡ ç™»å½•rootç”¨æˆ·ï¼Œåˆ›å»ºç”¨æˆ· 123useradd -m tmp -u 1000 -s /bin/bash # åˆ›å»ºtmpï¼Œåˆ›å»ºhomeï¼ŒæŒ‡å®šç™»å½•shell# passwd tmp# usermod -a -G sudo tmp # sudoæƒé™ ç¼–è¯‘ç¨‹åºï¼Œè®¾ç½®set-user-idæ ‡è®° 12345gcc practice9_1.c -o practice9_1for i in `seq 5`; do ./practice9_1 $i; donechmod +s practice9_1su tmpfor i in `seq 5`; do ./practice9_1 $i; done æ¢å¤ç¯å¢ƒ12userdel tmprm -rf /home/tmp æ‰§è¡Œç»“æœ rootç”¨æˆ·/æ™®é€š(æˆ–root)ç”¨æˆ·æœ‰set-user-id-rootæ ‡å¿—ï¼ˆåªæœ‰è¿™äº›æƒ…å†µçš„åˆå§‹çŠ¶æ€ä¸ºä¸Šæ‰€è¿°ï¼‰ exec real effective save fs è§£é‡Š setuid(2000); 2000 2000 2000 2000 setuidä¼šåŒæ—¶ä¿®æ”¹r,e,s setreuid(-1, 2000); 1000 2000 2000 2000 è¿™é‡Œsä¹Ÿè·Ÿç€å˜äº†ï¼Œæ˜¯å› ä¸ºæ»¡è¶³äº†sæ”¹å˜çš„æ¡ä»¶ seteuid(2000); 1000 2000 0 2000 fsä¼šéšç€eæ”¹å˜ï¼Œä¸Šé¢ä¹Ÿæ˜¯è¿™æ · setfsuid(2000); 1000 0 0 2000 åªæ”¹å˜fs setresuid(-1,2000,3000); 1000 2000 3000 2000 å¾ˆæ­£å¸¸ 9.2æ‹¥æœ‰å¦‚ä¸‹ç”¨æˆ·IDçš„è¿›ç¨‹äº«æœ‰ç‰¹æƒå—?è¯·äºˆè§£é‡Šã€‚real=0 effective=1000 saved=1000 file-system=1000 æ²¡æœ‰ï¼Œä½†æ˜¯å¯ä»¥seteuid(0)ï¼Œæ‹¥æœ‰æƒé™ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#define _GNU_SOURCE#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/fsuid.h&gt;#include &lt;sys/wait.h&gt;#include &lt;errno.h&gt;int checkPermission() { pid_t pid; pid = fork(); int childret = 0; if(pid == 0) { char **argv = malloc(3 * sizeof(char *)); argv[0] = &quot;/usr/bin/ls&quot;; argv[1] = &quot;/root/&quot;; argv[2] = NULL; int ret; if((ret = execv(argv[0], argv)) == -1) { fprintf(stderr, &quot;fail to exec ls, error: %s, ret = %d\\n&quot;, strerror(errno), ret); } return ret; } else { if(wait(&amp;childret) != (pid_t)-1) { childret = WEXITSTATUS(childret); printf(&quot;child process stop, childret = %d\\n&quot;, childret); if(childret == 0) { printf(&quot;permission granted\\n&quot;); } else if(childret == WEXITSTATUS(-1)) { printf(&quot;exec fail\\n&quot;); } else { printf(&quot;no permission\\n&quot;); } } else { fprintf(stderr, &quot;wait, error: %s\\n&quot;, strerror(errno)); } } return 0;}void printres() { uid_t r, e, s, fs; if(getresuid(&amp;r, &amp;e, &amp;s) == -1) exit(-1); fs = setfsuid(0); printf(&quot;real = %u, effective = %u, save = %u, fs = %u\\n&quot;, r, e, s, fs); checkPermission();}int main(int argc, char *argv[]) { printres(); if(setresuid(0, 1000, 1000) == -1) return 1; printres(); if(setfsuid(1000) == -1) return 2; printres(); if(seteuid(0) == -1) return 3; printres(); return 0;} åˆ›å»ºå­è¿›ç¨‹æ‰§è¡Œls /rootï¼Œæ²¡æœ‰ç‰¹æƒä¼šè¿”å›2ï¼Œæ‰§è¡Œç»“æœä¸º0220 9.3ä½¿ç”¨setgroups()åŠåº“å‡½æ•°ä»å¯†ç æ–‡ä»¶ã€ç»„æ–‡ä»¶ï¼ˆå‚è§8.4èŠ‚)ä¸­è·å–ä¿¡æ¯ï¼Œä»¥å®ç°initgroups()ã€‚è¯·æ³¨æ„ï¼Œæ¬²è°ƒç”¨setgroupsï¼Œè¿›ç¨‹å¿…é¡»äº«æœ‰ç‰¹æƒã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#define _GNU_SOURCE#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;grp.h&gt;#include &lt;limits.h&gt;#include &lt;errno.h&gt;#define BUFFSIZE 0xffff// #define BUFFSIZE 2#define CHECK(x) if(!(x)) {fprintf(stderr, &quot;error: %s\\n&quot;, strerror(errno)); exit(errno); }char *strAllocCat(char *str1, const char *str2, int *len1, int len2) { char *ret = malloc((*len1 + len2 + 1) * sizeof(char)); strncpy(ret, str1, *len1); strncpy(ret + *len1, str2, len2); free(str1); *len1 += len2; return ret;} // å¤åˆ¶ä¸”åˆ†é…å†…å­˜ï¼Œæœ€åä¸€ä½åŠ ä¸Š0ï¼Œå¤„ç†æˆcè¯­è¨€å­—ç¬¦ä¸²ï¼Œé‡Šæ”¾str1å†…å­˜ï¼Œæ›´æ–°å­—ç¬¦ä¸²é•¿åº¦char *readline(int fileno, int *readsize) { static char buf[BUFFSIZE+1]; static char *off = buf; static int eof = 0; char *line = malloc(sizeof(char)); int lineSize = 0; char *move = off; if(off - buf &gt;= eof) { eof = read(fileno, buf, BUFFSIZE); if(eof == 0) { *readsize = 0; return NULL; } CHECK(eof != -1) buf[eof] = 0; off = buf; move=off; } while(*move &amp;&amp; *move != '\\n') { move++; } line = strAllocCat(line, off, &amp;lineSize, move - off); off = move+1; if(*move == 0) { int extrasize = 0; char *extra = readline(fileno, &amp;extrasize); line = strAllocCat(line, extra, &amp;lineSize, extrasize); } *readsize = lineSize; return line;} // ä¸€æ¬¡è¯»ä¸€è¡Œgid_t parse_group(char *line, const char *user, const int usersize) { char *group_name = line; char *gpwd = strchr(line, ':'); *gpwd = 0;gpwd++; char *sgid = strchr(gpwd, ':'); *sgid = 0;sgid++; char *userlist = strchr(sgid, ':'); *userlist = 0;userlist++; // å¤„ç†groupsé‡Œçš„æ•°æ®ï¼ŒæŒ‰ç…§å†’å·åˆ†éš” while(strncmp(userlist, user, usersize) != 0) { userlist = strchr(userlist, ','); if(userlist == NULL) { return -1; } userlist++; } // è¯»userlistï¼Œæœ‰æ²¡æœ‰user if(userlist[usersize] != ',' &amp;&amp; userlist[usersize] != '\\0') return -1; // rootttt ä¸ root æ¯”è¾ƒçš„æƒ…å†µ return atol(sgid);}// ç³»ç»Ÿè°ƒç”¨è¯»è¡Œint __initgroups(const char *user, gid_t group) { int file_group = open(&quot;/etc/groups&quot;, O_CREAT | O_RDWR); CHECK(file_group != -1) int size = 0; char *line = NULL; gid_t groups[NGROUPS_MAX+1]; int groupscount = 0; groups[groupscount++] = group; // å‚æ•°groupå­˜å…¥ int usersize = strlen(user); while((line = readline(file_group, &amp;size)) != NULL) { write(STDOUT_FILENO, &quot;read line: &quot;, strlen(&quot;read line: &quot;)); write(STDOUT_FILENO, line, size); write(STDOUT_FILENO, &quot;\\n&quot;, 1); gid_t isid = parse_group(line, user, usersize); if(isid != (gid_t)-1 &amp;&amp; isid != group) {// å­˜åœ¨ä¸”ä¸æ˜¯å‚æ•°çš„gidï¼Œåˆ™å­˜å…¥ groups[groupscount++] = isid; printf(&quot;gid = %u contails user %s\\n&quot;, isid, user); if(groupscount &gt; NGROUPS_MAX) { return -1; // æ€»æ•°è¶…è¿‡limits } } } return setgroups(groupscount, groups);}// sscanfè¯»è¡Œint ___initgroups(const char *user, gid_t group) { FILE *file_groups = fopen(&quot;/etc/groups&quot;, &quot;rw&quot;); char line[BUFFSIZE+1]; int usersize = strlen(user); gid_t groups[NGROUPS_MAX+1]; int groupscount = 0; groups[groupscount++] = group; while(fscanf(file_groups, &quot;%s\\n&quot;, line) != EOF) { printf(&quot;%s\\n&quot;, line); gid_t iuid = parse_group(line, user, usersize); if(iuid != (gid_t)-1 &amp;&amp; iuid != group) { groups[groupscount++] = iuid; printf(&quot;gid = %u contails user %s\\n&quot;, iuid, user); if(groupscount &gt; NGROUPS_MAX) { return -1; // æ€»æ•°è¶…è¿‡limits } } } return setgroups(groupscount, groups);}// ç³»ç»Ÿè°ƒç”¨ getgrent setgrent endgrentint ____initgroups(const char *user, gid_t group) { struct group *grp = NULL; int usersize = strlen(user); gid_t groups[NGROUPS_MAX+1]; int groupscount = 0; groups[groupscount++] = group; while((grp = getgrent()) != NULL) { while(*grp-&gt;gr_mem) { if(strcmp(user, *grp-&gt;gr_mem) == 0 &amp;&amp; grp-&gt;gr_gid != group) { groups[groupscount++] = grp-&gt;gr_gid; printf(&quot;gid = %u contails user %s\\n&quot;, grp-&gt;gr_gid, user); if(groupscount &gt; NGROUPS_MAX) { return -1; // æ€»æ•°è¶…è¿‡limits } break; } grp-&gt;gr_mem++; } } endgrent(); return setgroups(groupscount, groups);}int main() { CHECK(____initgroups(getenv(&quot;USER&quot;), getgid()) != -1); gid_t groups[NGROUPS_MAX+1]; int size = getgroups(NGROUPS_MAX, groups); for(int i = 0; i &lt; size; i++) { struct group *g = getgrgid(groups[i]); printf(&quot;getgroups(%u): %s:%s:%u&quot;, groups[i], g-&gt;gr_name, g-&gt;gr_passwd, g-&gt;gr_gid); // è¯»å–çš„æ˜¯ groupsï¼Œè¿™é‡Œä¸å‰é¢ä¸ä¸€æ ·æ­£å¸¸ï¼Œgidä¸€æ ·å°±å¥½ if(*g-&gt;gr_mem) { printf(&quot;:%s&quot;, *g-&gt;gr_mem); g-&gt;gr_mem++; } while(*g-&gt;gr_mem) { printf(&quot;,%s&quot;, *g-&gt;gr_mem); g-&gt;gr_mem++; } printf(&quot;\\n&quot;); }} 9.4å‡è®¾æŸè¿›ç¨‹çš„æ‰€æœ‰ç”¨æˆ·æ ‡è¯†å‡ä¸ºXï¼Œæ‰§è¡Œäº†ç”¨æˆ·Dä¸ºYçš„set-user-IDç¨‹åºï¼Œä¸”Yä¸ºé0å€¼,å¯¹è¿›ç¨‹å‡­è¯çš„è®¾ç½®å¦‚ä¸‹: 123456789101112131415161718192021#define _GNU_SOURCE#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main() { uid_t r,e,s; getresuid(&amp;r, &amp;e, &amp;s); printf(&quot;r = %u, e = %u, s = %u\\n&quot;, r, e, s); seteuid(r); getresuid(&amp;r, &amp;e, &amp;s); printf(&quot;r = %u, e = %u, s = %u\\n&quot;, r, e, s); seteuid(s); getresuid(&amp;r, &amp;e, &amp;s); printf(&quot;r = %u, e = %u, s = %u\\n&quot;, r, e, s); setuid(r); getresuid(&amp;r, &amp;e, &amp;s); printf(&quot;r = %u, e = %u, s = %u\\n&quot;, r, e, s); return setuid(0); // å¸Œæœ›æœ€åä¸€ä¸ªå¤±è´¥ï¼Œè¿”å›255(-1)} ç¯å¢ƒå‡†å¤‡12345gcc practice9_4.c -o practice9_4sudo chown root practice9_4chmod u+s practice9_4su tmp./practice9_4 9.5rootæœ€åä¸€å¥æˆåŠŸï¼Œérootæœ€åä¸€å¥ä¸æˆåŠŸ","link":"/home/2023/04/13/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha9/"},{"title":"6.824-lab1-Mapreduce","text":"Introå®éªŒç›®çš„ å®ç°ä¸€ä¸ªMapReduceè°ƒåº¦å™¨(Coordinator) å‡†å¤‡å·¥ä½œ ä¸‹è½½æºç  1git clone git://g.csail.mit.edu/6.824-golabs-2021 6.824 ä¸²è¡Œè¿è¡Œ word-count123456cd ./6.824cd src/maingo build -race -buildmode=plugin ../mrapps/wc.gorm mr-out*go run -race mrsequential.go wc.so pg*.txtmore mr-out-0 æˆ‘çš„ä»»åŠ¡ä¿®æ”¹mr/coordinator.go, mr/worker.go, mr/rpc.goï¼Œå®ç°coordinatorå’Œworker è¿è¡Œæ–¹å¼ ç¼–è¯‘å¹¶è¿è¡Œcoordinator 123go build -race -buildmode=plugin ../mrapps/wc.go rm mr-out*go run -race mrcoordinator.go pg-*.txt å¤šå¼€å‡ ä¸ªçª—å£è·‘worker 1go run -race mrworker.go wc.so æµ‹è¯• 1bash test-mr.sh æµ‹è¯•early exit1234567891011121314151617181920212223242526rm -f mr-*echo '***' Starting early exit test.timeout -k 2s 180s ../mrcoordinator ../pg*txt &amp;## give the coordinator time to create the sockets.sleep 1## start multiple workers.timeout -k 2s 180s ../mrworker ../../mrapps/early_exit.so &amp;timeout -k 2s 180s ../mrworker ../../mrapps/early_exit.so &amp;timeout -k 2s 180s ../mrworker ../../mrapps/early_exit.so &amp;## wait for any of the coord or workers to exit## `jobs` ensures that any completed old processes from other tests## are not waited uponjobs &amp;&gt; /dev/nullwait -n## å…³é”®æ˜¯è¿™ä¸€è¡Œ## a process has exited. this means that the output should be finalized## otherwise, either a worker or the coordinator exited earlysort mr-out* | grep . &gt; mr-wc-all-initial## wait for remaining workers and coordinator to exit.wait è¿™ä¸€è¡Œçš„ä½œç”¨æ˜¯å½“ä¸Šé¢ä»»ä½•ä¸€ä¸ªçº¿ç¨‹ä¸­ï¼Œç¬¬ä¸€ä¸ªçº¿ç¨‹ç»“æŸï¼Œåˆ™åœæ­¢waitç»§ç»­ä¸‹é¢çš„è„šæœ¬ ä¹Ÿå°±æ˜¯è¯´ï¼Œå¤§å®¶è¦ä¸€èµ·é€€å‡ºï¼Œä¸èƒ½å› ä¸ºæ‰§è¡Œå®Œä»»åŠ¡äº†ï¼Œä¹Ÿæ²¡æœ‰æ–°ä»»åŠ¡äº†ï¼Œå°±è®©workerç»“æŸ12wait -n## å…³é”®æ˜¯è¿™ä¸€è¡Œ ä¸€ç§å¯è¡Œçš„æ–¹æ³•æ˜¯å½“æ‰€æœ‰reduceä»»åŠ¡ç»“æŸåï¼Œç›´æ¥é€€å‡ºï¼Œsocketè¿æ¥å…³é—­ï¼Œåé¢çš„workerå¿ƒè·³ç›´æ¥è¿æ¥å…³é—­çš„socketå¯¼è‡´panicé€€å‡º ä½†è¿™æ ·å¤ªä¸ä¼˜é›… æ¯ä¸ªworkerè¯·æ±‚taskæ—¶å‘é€è‡ªå·±å·²ç»å®Œæˆçš„reduceæ•°å¦‚æœcoordinatoræ”¶åˆ°äº†æ‰€æœ‰çš„reduce completeæ¶ˆæ¯ï¼Œç»´æŠ¤ä¸€ä¸ªå˜é‡reduceï¼Œæ­¤æ—¶æ¯æ”¶åˆ°ä¸€ä¸ªRequestTaskæ¶ˆæ¯reduce+=è¯¥å®¢æˆ·ç«¯çš„reduceæ•°ï¼Œå¹¶å‘é€finishæ¶ˆæ¯ï¼Œworkeræ”¶åˆ°åç«‹åˆ»finishCoordinatorçš„Doneå®ç°ä¸ºï¼Œè¯¥reduceå¤§äºç­‰äºNReduceæ—¶ï¼Œç»“æŸè¿è¡Œ job count test æ£€æŸ¥æŸä¸ªjobè¿è¡Œçš„æ¬¡æ•°æ˜¯å¦æ­£ç¡® è¿™ä¸ªæ£€æµ‹æœ€åˆæ²¡æœ‰é€šè¿‡ï¼Œå°±å»çœ‹äº†æµ‹è¯•è„šæœ¬å’Œæºç  1234567891011121314151617181920212223echo '***' Starting job count test.rm -f mr-*timeout -k 2s 180s ../mrcoordinator ../pg*txt &amp;sleep 1timeout -k 2s 180s ../mrworker ../../mrapps/jobcount.so &amp;timeout -k 2s 180s ../mrworker ../../mrapps/jobcount.sotimeout -k 2s 180s ../mrworker ../../mrapps/jobcount.so &amp;timeout -k 2s 180s ../mrworker ../../mrapps/jobcount.soNT=`cat mr-out* | awk '{print $2}'`if [ &quot;$NT&quot; -ne &quot;8&quot; ]then echo '---' map jobs ran incorrect number of times &quot;($NT != 8)&quot; echo '---' job count test: FAIL failed_any=1else echo '---' job count test: PASSfiwait ç®€å•åˆ†æå¯çŸ¥ï¼ŒåŠ è½½jobcountä¸­çš„ç‰¹æ®Šmapï¼Œreduceå‡½æ•°ï¼Œä½¿è¾“å‡ºæ–‡ä»¶è¾“å‡ºçš„æ˜¯mapçš„ä¸ªæ•°é€šè¿‡catè¾“å‡ºmr-outçš„æ‰€æœ‰æ–‡ä»¶ï¼Œåœ¨ä½¿ç”¨awkè¾“å‡ºmr-outçš„ç¬¬äºŒä¸ªå‚æ•°(awk 'print $2') mrapps/crash.go12345678910111213141516171819202122232425262728var count intfunc Map(filename string, contents string) []mr.KeyValue { me := os.Getpid() f := fmt.Sprintf(&quot;mr-worker-jobcount-%d-%d&quot;, me, count) count++ err := ioutil.WriteFile(f, []byte(&quot;x&quot;), 0666) if err != nil { panic(err) } time.Sleep(time.Duration(2000+rand.Intn(3000)) * time.Millisecond) return []mr.KeyValue{mr.KeyValue{&quot;a&quot;, &quot;x&quot;}}}func Reduce(key string, values []string) string { files, err := ioutil.ReadDir(&quot;.&quot;) if err != nil { panic(err) } invocations := 0 for _, f := range files { // println(&quot;test, f =&quot;, f.Name(), strings.HasPrefix(f.Name(), &quot;mr-worker-jobcount&quot;)) if strings.HasPrefix(f.Name(), &quot;mr-worker-jobcount&quot;) { invocations++ } } return strconv.Itoa(invocations)} åˆ†æè¿™é‡Œçš„ä»£ç å¯çŸ¥ï¼Œæ¯è°ƒç”¨ä¾æ¬¡mapï¼Œå…¨å±€å˜é‡countå°±ä¼š++ï¼Œå¹¶åˆ›å»ºè¯¥workerçš„ç¬¬countä¸ªæ–‡ä»¶åœ¨reduceä¸­æ•°å½“å‰ç›®å½•ä¸‹å‰ç¼€ä¸ºmr-worker-jobcountçš„æ–‡ä»¶ä¸ªæ•°å°±æ˜¯mapçš„ä¸ªæ•° è°ƒè¯•äº†è‡ªå·±çš„ä»£ç ï¼Œmapåªè°ƒç”¨äº†8æ¬¡ï¼Œreduceåªè°ƒç”¨äº†ä¸€æ¬¡ æ³¨æ„åˆ°jobcountä¸­ä½¿ç”¨äº†goå·²ç»å¼ƒç”¨çš„ioutilsåŒ…ï¼Œæ”¹ä¸ºosï¼Œé—®é¢˜è§£å†³ crash test12## mimic rpc.go's coordinatorSock()SOCKNAME=/var/tmp/824-mr-`id -u` æµ‹è¯•è„šæœ¬è¦æ¨¡ä»¿Coordinatorçš„Sock","link":"/home/2022/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.824/lab1/"},{"title":"MIT-6.824-notebook","text":"åœ°å€","link":"/home/2022/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.824/mit6.824notes/"}],"tags":[{"name":"JavaåŸºç¡€","slug":"JavaåŸºç¡€","link":"/home/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"Kotlin-Android å®ä¹ ","slug":"Kotlin-Android-å®ä¹ ","link":"/home/tags/Kotlin-Android-%E5%AE%9E%E4%B9%A0/"},{"name":"projects","slug":"projects","link":"/home/tags/projects/"},{"name":"Kotlin-Android","slug":"Kotlin-Android","link":"/home/tags/Kotlin-Android/"},{"name":"LeetCode","slug":"LeetCode","link":"/home/tags/LeetCode/"},{"name":"LeetCodeå‘¨èµ›","slug":"LeetCodeå‘¨èµ›","link":"/home/tags/LeetCode%E5%91%A8%E8%B5%9B/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","link":"/home/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode 101","slug":"LeetCode-101","link":"/home/tags/LeetCode-101/"},{"name":"åŠ¨æ€è§„åˆ’","slug":"åŠ¨æ€è§„åˆ’","link":"/home/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"æ•°æ®åº“","slug":"æ•°æ®åº“","link":"/home/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"å¤šçº¿ç¨‹","slug":"å¤šçº¿ç¨‹","link":"/home/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"PAT-(Advanced-Level)-Practice","slug":"PAT-Advanced-Level-Practice","link":"/home/tags/PAT-Advanced-Level-Practice/"},{"name":"PAT-(Basic-Level)-Practice","slug":"PAT-Basic-Level-Practice","link":"/home/tags/PAT-Basic-Level-Practice/"},{"name":"æ’åº","slug":"æ’åº","link":"/home/tags/%E6%8E%92%E5%BA%8F/"},{"name":"gallery","slug":"gallery","link":"/home/tags/gallery/"},{"name":"hexo","slug":"hexo","link":"/home/tags/hexo/"},{"name":"C&#x2F;C++","slug":"C-C","link":"/home/tags/C-C/"},{"name":"git","slug":"git","link":"/home/tags/git/"},{"name":"linux","slug":"linux","link":"/home/tags/linux/"},{"name":"shell","slug":"shell","link":"/home/tags/shell/"},{"name":"misc","slug":"misc","link":"/home/tags/misc/"},{"name":"geth","slug":"geth","link":"/home/tags/geth/"},{"name":"blockchain","slug":"blockchain","link":"/home/tags/blockchain/"},{"name":"ç‰›å®¢","slug":"ç‰›å®¢","link":"/home/tags/%E7%89%9B%E5%AE%A2/"},{"name":"åˆ·é¢˜","slug":"åˆ·é¢˜","link":"/home/tags/%E5%88%B7%E9%A2%98/"},{"name":"OS","slug":"OS","link":"/home/tags/OS/"},{"name":"OI KIWI","slug":"OI-KIWI","link":"/home/tags/OI-KIWI/"},{"name":"Android FrameWork","slug":"Android-FrameWork","link":"/home/tags/Android-FrameWork/"},{"name":"Androidé¢è¯•æŸ¥æ¼è¡¥ç¼º","slug":"Androidé¢è¯•æŸ¥æ¼è¡¥ç¼º","link":"/home/tags/Android%E9%9D%A2%E8%AF%95%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"Android é«˜çº§å¼€å‘ç“¶é¢ˆçªç ´ç³»åˆ—è¯¾","slug":"Android-é«˜çº§å¼€å‘ç“¶é¢ˆçªç ´ç³»åˆ—è¯¾","link":"/home/tags/Android-%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/"},{"name":"Flutter","slug":"Flutter","link":"/home/tags/Flutter/"},{"name":"Android-å®˜æ–¹æºç ","slug":"Android-å®˜æ–¹æºç ","link":"/home/tags/Android-%E5%AE%98%E6%96%B9%E6%BA%90%E7%A0%81/"},{"name":"Android","slug":"Android","link":"/home/tags/Android/"},{"name":"gradle","slug":"gradle","link":"/home/tags/gradle/"},{"name":"fedfab","slug":"fedfab","link":"/home/tags/fedfab/"},{"name":"Android-å®˜æ–¹æ–‡æ¡£","slug":"Android-å®˜æ–¹æ–‡æ¡£","link":"/home/tags/Android-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"},{"name":"Linux&#x2F;UNIXç³»ç»Ÿç¼–ç¨‹æ‰‹å†Œ","slug":"Linux-UNIXç³»ç»Ÿç¼–ç¨‹æ‰‹å†Œ","link":"/home/tags/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/"},{"name":"6.824","slug":"6-824","link":"/home/tags/6-824/"}],"categories":[{"name":"JavaåŸºç¡€","slug":"JavaåŸºç¡€","link":"/home/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"Kotlin-Android","slug":"Kotlin-Android","link":"/home/categories/Kotlin-Android/"},{"name":"LeetCode","slug":"LeetCode","link":"/home/categories/LeetCode/"},{"name":"LeetCodeå‘¨èµ›","slug":"LeetCode/LeetCodeå‘¨èµ›","link":"/home/categories/LeetCode/LeetCode%E5%91%A8%E8%B5%9B/"},{"name":"ç®—æ³•","slug":"LeetCode/ç®—æ³•","link":"/home/categories/LeetCode/%E7%AE%97%E6%B3%95/"},{"name":"æ•°æ®åº“","slug":"LeetCode/æ•°æ®åº“","link":"/home/categories/LeetCode/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"å¤šçº¿ç¨‹","slug":"LeetCode/å¤šçº¿ç¨‹","link":"/home/categories/LeetCode/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"PAT-(Advanced-Level)-Practice","slug":"PAT-Advanced-Level-Practice","link":"/home/categories/PAT-Advanced-Level-Practice/"},{"name":"PAT-(Basic-Level)-Practice","slug":"PAT-Basic-Level-Practice","link":"/home/categories/PAT-Basic-Level-Practice/"},{"name":"gallery","slug":"gallery","link":"/home/categories/gallery/"},{"name":"misc","slug":"misc","link":"/home/categories/misc/"},{"name":"git","slug":"git","link":"/home/categories/git/"},{"name":"linux","slug":"linux","link":"/home/categories/linux/"},{"name":"ç‰›å®¢","slug":"ç‰›å®¢","link":"/home/categories/%E7%89%9B%E5%AE%A2/"},{"name":"OS","slug":"OS","link":"/home/categories/OS/"},{"name":"OI KIWI","slug":"OI-KIWI","link":"/home/categories/OI-KIWI/"},{"name":"åˆ·é¢˜","slug":"ç‰›å®¢/åˆ·é¢˜","link":"/home/categories/%E7%89%9B%E5%AE%A2/%E5%88%B7%E9%A2%98/"},{"name":"Android","slug":"Android","link":"/home/categories/Android/"},{"name":"ç®—æ³•","slug":"OI-KIWI/ç®—æ³•","link":"/home/categories/OI-KIWI/%E7%AE%97%E6%B3%95/"},{"name":"æ‰‹æ’¸Androidæºç ","slug":"Android/æ‰‹æ’¸Androidæºç ","link":"/home/categories/Android/%E6%89%8B%E6%92%B8Android%E6%BA%90%E7%A0%81/"},{"name":"gradle","slug":"Android/gradle","link":"/home/categories/Android/gradle/"},{"name":"fedfab","slug":"fedfab","link":"/home/categories/fedfab/"}],"pages":[{"title":"about","text":".Label, .label { border: max(1px, 0.0625rem) solid #30363d; border-radius: 2em; display: inline-block; font-size: 0.75rem; font-weight: 500; line-height: 18px; padding: 0 7px; white-space: nowrap; } .Label--secondary { border-color: #30363d; color: #7d8590; } åŸºæœ¬ä¿¡æ¯ é¡¹ç›® å€¼ å§“å åˆ˜æ™¯å¤© æ˜µç§° åˆ˜å–µå–µ å‡ºç”Ÿå¹´æœˆ 2000/02 é‚®ç®± jingtian.liu@foxmail.com qq ç‚¹å‡»è¿™é‡Œ æ•™è‚²ç»å† èµ·å§‹æ—¶é—´ ç»“æŸæ—¶é—´ å­¦æ ¡ ä¸“ä¸š 2018.09 2022.06 ä¸œåŒ—å¤§å­¦(ç§¦çš‡å²›) è®¡ç®—æœºç§‘å­¦ä¸æŠ€æœ¯ 2022.09 2025.06(é¢„è®¡) åŒ—äº¬é‚®ç”µå¤§å­¦ è®¡ç®—æœºæŠ€æœ¯(åŒºå—é“¾æ–¹å‘) é¡¹ç›®ä¿¡æ¯fedml: deployment and modification to combine with Hyperledger fabric repo fabric: deployment and combination with fedml repo Yaml-Requests: read your yaml config file to generate python function repo Algorithm: notes for leetcode and other oj repo AFLGOæŒ–æ˜é¡¹ç›®ã€æ¶‰å¯†ã€‘ å¯¹AFLGOä¿®æ”¹ï¼Œæ·»åŠ ä»£ç è®¿é—®æ¬¡æ•°ç»Ÿè®¡åŠŸèƒ½ keywords: llvm Privaterepo å¯¹æŸäº›è½¯ä»¶è¿›è¡Œfuzz keywords: socketç¼–ç¨‹, pthread, asan å¯¹AFLGOä¿®æ”¹ï¼Œæ·»åŠ ç›®æ ‡å—å‘½ä¸­æ¬¡æ•°ç»Ÿè®¡ keywords: ç³»ç»Ÿè°ƒç”¨, I/O, llvm IRæ’è£…, å…±äº«å†…å­˜ Privaterepo å®ä¹ ç»å†å­—èŠ‚è·³åŠ¨ ä»Šæ—¥å¤´æ¡ éƒ¨é—¨: ä»Šæ—¥å¤´æ¡-æ¶æ„ è´Ÿè´£åŸºç¡€ç»„ä»¶çš„å‡çº§åŒ…æ‹¬å®˜æ–¹fragment,è‡ªç ”sdk leetcodeé¢˜è§£ [hard] 1255. å¾—åˆ†æœ€é«˜çš„å•è¯é›†åˆ çŠ¶æ€å‹ç¼©+å‰ªæ [Medium] 1073. è´ŸäºŒè¿›åˆ¶æ•°ç›¸åŠ  å…¶ä»–ä¿¡æ¯æ¬¢è¿ç›¸äº’å­¦ä¹ &amp;äº¤æµ! ä¸ƒè–å¬å–šã®é¾é›¢å…ˆç”Ÿã®ã‚«ãƒ¼ãƒ‰ãŒã‹ã£ã“ã‚ˆã™ãã‚‹ä»¶ã«ã¤ã„ã¦#åŸç¥ #é¾é›¢ #Zhongli pic.twitter.com/AOwV6ozK5e&mdash; celsior500 (@celsior500) May 19, 2023 ğŸğŸ„Merry ChristmasğŸº ë©”ë¦¬ í¬ë¦¬ìŠ¤ë§ˆìŠ¤ â›“ï¸#Wriothesley ã€‚ã‚œãƒ»â„ï¸ãƒ»ã€‚ãƒ»ã€‚ ãƒ» ã€‚ã€‚ã‚œãƒ»ã€‚ â…ã‚œ ãƒ»ã€‚ã‚œãƒ» â„ï¸ã‚œ ãƒ»ã€‚â„ï¸ã‚œ ã‚œ ãƒ»ã€‚ã‚œ ãƒ»ãƒ»â„ï¸ ã‚œãƒ» ã€‚ ã‚œâ…ã‚œ ã‚œã‚œã€‚ ã€‚ ã‚œãƒ»ã€‚ ã€‚ã‚œ ãƒ» ã€‚ â„ï¸ã‚œãƒ» ã€‚ â…ã‚œ ã‚œã€‚ãƒ»ã‚œ â„ï¸ã€‚ â…ãƒ»ã€‚ãƒ»ã€‚ ã‚œãƒ» ã€‚ã‚œ ãƒ» ã€‚ã€‚ã‚œã€‚ ã‚œãƒ» ã€‚ã‚œãƒ» â„ï¸ãƒ» ã€‚ ã‚œâ…ã‚œ ã‚œã‚œã€‚ ã€‚ pic.twitter.com/5HSjrdZRBB&mdash; âœ¨NPâœ¨ (@1231_0720) December 22, 2023 å¥èº« åŠ¨ä½œ æ¨èå“‘é“ƒå¤§å° æ¨èé‡é‡ï¼ˆå•åªï¼‰ ç®­å¼“æ­¥ å¤§ 17.5kg å•è‡‚åˆ’èˆ¹ å¤§ 17.5kg åå§¿æ¨ä¸¾ å¤§ 17.5kg å“‘é“ƒæ·±è¹² å¤§ 17.5kg ä¾§å¹³ä¸¾ å° 7kg äºŒå¤´å¼¯ä¸¾ å° 7kg é£é¸Ÿ+ä¿¯å§æ’‘ å° 7kg ç¢é¢…è€… å° 7kg è´Ÿé‡æŠ¬è…¿å·è…¹ å° 7kg 2024å¹´2æœˆ26æ—¥ ï¼ˆç¬¬ä¸€å‘¨ï¼‰ åŠ¨ä½œ å½“å‰é…é‡ æ˜¯å¦èƒ½æ‰¿å— ç®­å¼“æ­¥ 2.5kg èƒ½ å•è‡‚åˆ’èˆ¹ 2.5kg èƒ½ åå§¿æ¨ä¸¾ 2.5kg èƒ½ å“‘é“ƒæ·±è¹² 2.5kg èƒ½ ä¾§å¹³ä¸¾ 2.5kg èƒ½ äºŒå¤´å¼¯ä¸¾ 2.5kg èƒ½ é£é¸Ÿ+ä¿¯å§æ’‘ 2.5kg èƒ½ ç¢é¢…è€… 2.5kg èƒ½ è´Ÿé‡æŠ¬è…¿å·è…¹ 2.5kg èƒ½ 2024å¹´3æœˆ4æ—¥ åŠ¨ä½œ å½“å‰é…é‡ æ˜¯å¦èƒ½æ‰¿å— ç®­å¼“æ­¥ 4kg èƒ½ å•è‡‚åˆ’èˆ¹ 4kg èƒ½ åå§¿æ¨ä¸¾ 4kg èƒ½ å“‘é“ƒæ·±è¹² 4kg èƒ½ ä¾§å¹³ä¸¾ 4kg æé™ äºŒå¤´å¼¯ä¸¾ 4kg èƒ½ é£é¸Ÿ+ä¿¯å§æ’‘ 4kg èƒ½ ç¢é¢…è€… 4kg åˆšå¥½ è´Ÿé‡æŠ¬è…¿å·è…¹ 4kg èƒ½","link":"/home/about/index.html"},{"title":"categories","text":"","link":"/home/categories/index.html"},{"title":"","text":"function copyToClipboard(text, callBack) { navigator.clipboard.writeText(text).then( value => { // fulfillment callBack() }, reason => { // rejection alert(\"fail: \" + reason) } ) } $(document).ready(function() { $(\".copy\").click(function() { copyCode(this) }) var buttons = document.getElementsByClassName(\"button\") for (let i = 0; i < buttons.length; i++) { if (buttons[i].getAttribute(\"title\") == \"RSS\") { var url = document.baseURI + \"atom.xml\" buttons[i].href = \"javascript:;\" buttons[i].target = \"_self\" buttons[i].setAttribute('onclick', \"copyToClipboard(\\\"\" + url + \"\\\", function() { alert(\\\"Copied to clipboard!\\\") })\") break } } }) function copyCode(element) { if (element instanceof Element) { var elemt = element while(elemt.tagName != \"FIGURE\") { elemt = elemt.parentElement } elemt = elemt.getElementsByClassName(\"code\")[0] var text =elemt.innerText copyToClipboard(text, function() { var node = $(element.childNodes[0]) node.attr('class', \"fa fa-check\") setTimeout(function () { node.attr('class', \"fas fa-copy\") } ,1000) }) } } function fadeOutAndIn(node, onShow, onHide) { node.fadeOut(200, function() { onHide() node.fadeIn(200, function () { onShow() }) }) }","link":"/home/js/clickClipBoard.js"},{"title":"","text":"import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs' function initMermaid() { mermaid.initialize( { startOnLoad: true, theme: \"neutral\", fontSize: '16px', look: \"handDrawn\", sequence: {showSequenceNumbers: true}, fontFamily: \"system-ui\", forceLegacyMathML: true } ) } initMermaid()","link":"/home/js/mermaidInitializer.js"},{"title":"","text":"(function fairyDustCursor() { var possibleColors = [\"#D61C59\", \"#E7D84B\", \"#1B8798\"] var width = window.innerWidth; var height = window.innerHeight; var cursor = { x: width / 2, y: width / 2 }; var particles = []; function init() { bindEvents(); loop(); } // Bind events that are needed function bindEvents() { document.addEventListener('mousemove', onMouseMove); document.addEventListener('touchmove', onTouchMove); document.addEventListener('touchstart', onTouchMove); window.addEventListener('resize', onWindowResize); } function onWindowResize(e) { width = window.innerWidth; height = window.innerHeight; } function onTouchMove(e) { if (e.touches.length > 0) { for (var i = 0; i < e.touches.length; i++) { addParticle(e.touches[i].clientX, e.touches[i].clientY, possibleColors[Math.floor(Math.random() * possibleColors.length)]); } } } function onMouseMove(e) { cursor.x = e.clientX; cursor.y = e.clientY; addParticle(cursor.x, cursor.y, possibleColors[Math.floor(Math.random() * possibleColors.length)]); } function addParticle(x, y, color) { var particle = new Particle(); particle.init(x, y, color); particles.push(particle); } function updateParticles() { for (var i = 0; i < particles.length; i++) { particles[i].update(); } for (var i = particles.length - 1; i >= 0; i--) { if (particles[i].lifeSpan < 0) { particles[i].die(); particles.splice(i, 1); } } } function loop() { requestAnimationFrame(loop); updateParticles(); } function Particle() { this.character = \"*\"; this.lifeSpan = 120; //ms this.initialStyles = { \"position\": \"fixed\", \"top\": \"0\", //å¿…é¡»åŠ  \"display\": \"block\", \"pointerEvents\": \"none\", \"z-index\": \"10000000\", \"fontSize\": \"20px\", \"will-change\": \"transform\" }; this.init = function (x, y, color) { this.velocity = { x: (Math.random() < 0.5 ? -1 : 1) * (Math.random() / 2), y: 1 }; this.position = { x: x - 10, y: y - 20 }; this.initialStyles.color = color; // console.log(color); this.element = document.createElement('span'); this.element.innerHTML = this.character; applyProperties(this.element, this.initialStyles); this.update(); document.body.appendChild(this.element); }; this.update = function () { this.position.x += this.velocity.x; this.position.y += this.velocity.y; this.lifeSpan--; this.element.style.transform = \"translate3d(\" + this.position.x + \"px,\" + this.position.y + \"px,0) scale(\" + (this.lifeSpan / 120) + \")\"; } this.die = function () { this.element.parentNode.removeChild(this.element); } } function applyProperties(target, properties) { for (var key in properties) { target.style[key] = properties[key]; } } init(); })();","link":"/home/js/fairyDustCursor.js"},{"title":"","text":".text-popup { animation: textPopup 1s; user-select: none; white-space: nowrap; position: absolute; z-index: 99; } @keyframes textPopup { 0%, 100% { opacity: 0; } 5% { opacity: 1; } 100% { transform: translateY(-50px); } }","link":"/home/css/textPopup.css"},{"title":"","text":"var colors = new Array(\"#FF0000\",\"#FF7F00\",\" #FFFF00\",\"#00FF00\",\"#00FFFF\",\"#0000FF\",\"#8B00FF\",\"#FF0000\",\"#FF7F00\",\" #FFFF00\",\"#00FF00\",\"#00FFFF\",\"#0000FF\",\"#8B00FF\"); var fnTextPopup = function (arr, options) { // arrå‚æ•°æ˜¯å¿…é¡»çš„ if (!arr || !arr.length) { return; } // ä¸»é€»è¾‘ var index = 0; document.documentElement.addEventListener('click', function (event) { var x = event.pageX, y = event.pageY; var eleText = document.createElement('span'); eleText.className = 'text-popup'; this.appendChild(eleText); if (arr[index]) { eleText.innerHTML = arr[index]; } else { index = 0; eleText.innerHTML = arr[0]; } // åŠ¨ç”»ç»“æŸååˆ é™¤è‡ªå·± eleText.addEventListener('animationend', function () { eleText.parentNode.removeChild(eleText); }); // ä½ç½® eleText.style.left = (x - eleText.clientWidth / 2) + 'px'; eleText.style.top = (y - eleText.clientHeight) + 'px'; //è®¾ç½®é¢œè‰² eleText.style.color = colors[index%14] // indexé€’å¢ index++; }); }; fnTextPopup(['å¯Œå¼º', 'æ°‘ä¸»', 'æ–‡æ˜', 'å’Œè°', 'è‡ªç”±', 'å¹³ç­‰', 'å…¬æ­£', 'æ³•æ²»', 'çˆ±å›½', 'æ•¬ä¸š', 'è¯šä¿¡', 'å‹å–„']);","link":"/home/js/textPopup.js"},{"title":"search","text":"","link":"/home/search/index.html"}]}