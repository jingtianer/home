{"posts":[{"title":"00-Java数组遍历性能对比","text":"三种遍历方式性能对比 循环与数组的length比较 12345678910public class JavaMain { static Object[] objs = new Object[10000000]; static int zero() { int sum = 0; for(int i = 0; i &lt; objs.length; i++) { sum ^= objs[i].hashCode(); } return sum; }} 将数组length存在方法栈中 1234567891011public class JavaMain { static Object[] objs = new Object[10000000]; static int one() { int sum = 0; int len = objs.length; for(int i = 0; i &lt; len; i++) { sum ^= objs[i].hashCode(); } return sum; }} for-each循环 12345678910public class JavaMain { static Object[] objs = new Object[10000000]; static int two() { int sum = 0; for (Object obj : objs) { sum ^= obj.hashCode(); } return sum; }} 测试速度123456789101112131415161718192021222324252627public class JavaMain { static Object[] objs = new Object[10000000]; static long run(IntSupplier f) { long start = System.currentTimeMillis(); int result = 0; for(int i = 0; i &lt; 100; i++) { result = f.getAsInt(); } long end = System.currentTimeMillis(); System.out.println(&quot;result = &quot; + result + &quot;, time = &quot; + (end - start) / 1000.0); return end - start; } public static void main(String[] args) { for (int i = 0; i &lt; objs.length; i++) { objs[i] = new Object(); objs[i].hashCode(); // 首次计算hashcode更慢，先缓存 } for (int i = 0; i &lt; 10; i++) { long zeroTime = run(JavaMain::zero); long oneTime = run(JavaMain::one); long twoTime = run(JavaMain::two); System.out.printf(&quot;2比1快: %.2f%%\\n&quot;, ((double)oneTime - twoTime) / oneTime * 100); System.out.printf(&quot;2比0快: %.2f%%\\n&quot;, ((double)zeroTime - twoTime) / zeroTime * 100); System.out.printf(&quot;1比0快: %.2f%%\\n&quot;, ((double)zeroTime - oneTime) / oneTime * 100); } }} 测试结果123456result = 360970567, time = 1.393result = 360970567, time = 1.174result = 360970567, time = 0.8862比1快: 24.53%2比0快: 36.40%1比0快: 18.65% 对比字节码使用javap -c查看字节🐴 123456789101112131415161718192021static int zero();Code: 0: iconst_0 1: istore_0 2: iconst_0 3: istore_1 4: iload_1 5: getstatic #7 // Field objs:[Ljava/lang/Object; 8: arraylength 9: if_icmpge 29 12: iload_0 13: getstatic #7 // Field objs:[Ljava/lang/Object; 16: iload_1 17: aaload 18: invokevirtual #13 // Method java/lang/Object.hashCode:()I 21: ixor 22: istore_0 23: iinc 1, 1 26: goto 4 29: iload_0 30: ireturn 数组的length并不是一个字段，没有通过getfield获取 1234567891011121314151617181920212223static int one();Code: 0: iconst_0 1: istore_0 2: getstatic #7 // Field objs:[Ljava/lang/Object; 5: arraylength 6: istore_1 7: iconst_0 8: istore_2 9: iload_2 10: iload_1 11: if_icmpge 31 14: iload_0 15: getstatic #7 // Field objs:[Ljava/lang/Object; 18: iload_2 19: aaload 20: invokevirtual #13 // Method java/lang/Object.hashCode:()I 23: ixor 24: istore_0 25: iinc 2, 1 28: goto 9 31: iload_0 32: ireturn 每次使用arraylength获取数组长度会更慢，具体arraylength做了什么可以看这篇文章JVM是如何得到数组长度的 zero和one对比 zero每次循环前，要依次执行iload_1, getstatic, arraylength, if_icmpge one每次循环前，要依次执行iload_2, iload_1, if_icmpge one只需要虚拟机读取两个操作数进行比较就可以，而zero需要通过getstatic获取数组对象，arraylength获取长度 123456789101112131415161718192021222324252627static int two();Code: 0: iconst_0 1: istore_0 2: getstatic #7 // Field objs:[Ljava/lang/Object; 5: astore_1 6: aload_1 7: arraylength 8: istore_2 9: iconst_0 10: istore_3 11: iload_3 12: iload_2 13: if_icmpge 35 16: aload_1 17: iload_3 18: aaload 19: astore 4 21: iload_0 22: aload 4 24: invokevirtual #13 // Method java/lang/Object.hashCode:()I 27: ixor 28: istore_0 29: iinc 3, 1 32: goto 11 35: iload_0 36: ireturn one和two对比 在循环前，两者都是通过iload读取数组长度和当前index对比 在循环体中 one每次需要getstatic获取数组对象，然后根据偏移量取出对应位置的对象 two在循环开始前，就将数组对象存在本地方法栈中，不需要使用getstatic来获取数组对象 强烈怀疑是getstatic性能过于拉胯，导致三者循环速度差异大 将数组对象作为参数传递到函数中测试代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class JavaMain { static Object[] objs = new Object[10000000]; static int zero(Object[] objs) { int sum = 0; for(int i = 0; i &lt; objs.length; i++) { sum ^= objs[i].hashCode(); } return sum; } static int one(Object[] objs) { int sum = 0; int len = objs.length; for(int i = 0; i &lt; len; i++) { sum ^= objs[i].hashCode(); } return sum; } static int two(Object[] objs) { int sum = 0; for (Object obj : objs) { sum ^= obj.hashCode(); } return sum; } static long run(Function&lt;Object[], Integer&gt; f) { long start = System.currentTimeMillis(); int result = 0; for(int i = 0; i &lt; 100; i++) { result = f.apply(objs); } long end = System.currentTimeMillis(); System.out.println(&quot;result = &quot; + result + &quot;, time = &quot; + (end - start) / 1000.0); return end - start; } public static void main(String[] args) { for (int i = 0; i &lt; objs.length; i++) { objs[i] = new Object(); objs[i].hashCode(); } for (int i = 0; i &lt; 10; i++) { long zeroTime = run(JavaMain::zero); long oneTime = run(JavaMain::one); long twoTime = run(JavaMain::two); System.out.printf(&quot;2比1快: %.2f%%\\n&quot;, ((double)oneTime - twoTime) / oneTime * 100); System.out.printf(&quot;2比0快: %.2f%%\\n&quot;, ((double)zeroTime - twoTime) / zeroTime * 100); System.out.printf(&quot;1比0快: %.2f%%\\n&quot;, ((double)zeroTime - oneTime) / oneTime * 100); } }} 比较结果123456789101112131415161718result = 360970567, time = 0.85result = 360970567, time = 0.871result = 360970567, time = 0.8732比1快: -0.23%2比0快: -2.71%1比0快: -2.41%result = 360970567, time = 0.864result = 360970567, time = 0.847result = 360970567, time = 0.8492比1快: -0.24%2比0快: 1.74%1比0快: 2.01%result = 360970567, time = 0.851result = 360970567, time = 0.849result = 360970567, time = 0.8622比1快: -1.53%2比0快: -1.29%1比0快: 0.24% 三种方法难分伯仲 字节码对比12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091Compiled from &quot;JavaMain.java&quot;public class test.JavaMain { static java.lang.Object[] objs; public test.JavaMain(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return static int zero(java.lang.Object[]); Code: 0: iconst_0 1: istore_1 2: iconst_0 3: istore_2 4: iload_2 5: aload_0 6: arraylength 7: if_icmpge 25 10: iload_1 11: aload_0 12: iload_2 13: aaload 14: invokevirtual #7 // Method java/lang/Object.hashCode:()I 17: ixor 18: istore_1 19: iinc 2, 1 22: goto 4 25: iload_1 26: ireturn static int one(java.lang.Object[]); Code: 0: iconst_0 1: istore_1 2: aload_0 3: arraylength 4: istore_2 5: iconst_0 6: istore_3 7: iload_3 8: iload_2 9: if_icmpge 27 12: iload_1 13: aload_0 14: iload_3 15: aaload 16: invokevirtual #7 // Method java/lang/Object.hashCode:()I 19: ixor 20: istore_1 21: iinc 3, 1 24: goto 7 27: iload_1 28: ireturn static int two(java.lang.Object[]); Code: 0: iconst_0 1: istore_1 2: aload_0 3: astore_2 4: aload_2 5: arraylength 6: istore_3 7: iconst_0 8: istore 4 10: iload 4 12: iload_3 13: if_icmpge 36 16: aload_2 17: iload 4 19: aaload 20: astore 5 22: iload_1 23: aload 5 25: invokevirtual #7 // Method java/lang/Object.hashCode:()I 28: ixor 29: istore_1 30: iinc 4, 1 33: goto 10 36: iload_1 37: ireturn static {}; Code: 0: ldc #77 // int 10000000 2: anewarray #2 // class java/lang/Object 5: putstatic #17 // Field objs:[Ljava/lang/Object; 8: return} 三者区别不大，总体耗时区别也不大，可见arraylength指令并不是性能瓶颈，而是getstatic有较大影响同样，我也测试了不通过函数参数传递，而将数组和三个方法改成非static修饰的，三者差异较大，可见getField指令的性能开销也要比load大 结论在遍历数组时，不论是使用数组的length，提前存储数组长度，还是使用for-each，差别不大，重要的是先将数组对象放到本地方法栈，避免频繁执行getstatic和getfield指令，造成性能影响。 和八股安卓性能优化所归咎的原因稍有不同。","link":"/home/2024/09/13/Java%E5%9F%BA%E7%A1%80/00-Java%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"},{"title":"实习笔记-2","text":"retrofit 参考 – Retrofit + RxJava ＋ OkHttp 让网络请求变的简单-基础篇","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8813%E6%97%A5/"},{"title":"实习笔记-1","text":"px dp sp 的区别 px 其实就是像素单位，比如我们通常说的手机分辨列表800*400都是px的单位 sp 同dp相似，还会根据用户的字体大小偏好来缩放 dp 虚拟像素，在不同的像素密度的设备上会自动适配 隐藏状态栏任务栏 在api30之前1getWindow().getDecorView().setSystemUIVisibility(View.SYSTEM_UI_FLAG_FULLSCREEN) api30后12345WindowCompat.setDecorFitsSystemWindows(window, false)WindowInsetsControllerCompat(window, window.decorView).let { it.hide(WindowInsetsCompat.Type.systemBars()) //it.systemBarsBehavior = WindowInsetsControllerCompat.BEHAVIOR_SHOW_BARS_BY_TOUCH} androidx.core 依赖的版本至少1.5 设置导航栏，状态栏颜色12window.statusBarColor = Color.TRANSPARENTwindow.navigationBarColor = Color.TRANSPARENT fragment 生命周期 onCreateView 与onActivityCreated 的区别onCreateView每次创建、绘制该Fragment的View组件时回调该方法，Fragment将会显示该方法返回的View组件。 onActivityCreated当Fragment所在的Activity被启动完成后回调该方法。 保存view的状态的时候需要用onActivityCreated 访问父activity的view层的时候需要在onActivityCreated 方法里面做 如果view是静态的，就可以在onCreateView之后取得view进行操作 如果view是动态的，则需要在onActivityCreated后find 1 静态布局1.1 View和ViewGroup静态布局都是由View和ViewGroup继承而来。 静态布局树状图 View是所有的UI组件都要继承并实现的，一个View要在屏幕上占据一块矩形区域。 ViewGroup是一个容器，可以将View添加进ViewGroup中，ViewGroup可以对其内的View进行布局，ViewGroup可以添加其他的ViewGroup。 所有的控件都是从View继承而来，ViewGroup是View的一个重要子类，绝大多数布局都是从ViewGroup继承而来。 1.3 六大布局1.3.1 LinearLayoutline是线的意思，linear是线性的意思，这个布局就是线性布局。只能横着排，或者只能竖着排。关键属性是orientation，这个是方向的意思。这个有两个选项 vertical，horizontal。是不是觉得太长记不住呢，有一个简便的记忆方法，利用IDE的自动提示功能，只要记住第一个字母就可以了对吧，可以把h记作横（heng）这样就不会错了。 1.3.2 RelativeLayoutrelative是相对的意思，这个布局是相对布局。相对布局就是依据父元素和某元素进行相对布局。有三种类型的属性： 属性值是true或falseandroid:layout_centerHrizontal 水平居中android:layout_centerVertical 垂直居中android:layout_centerInparent 相对于父元素完全居中。android:layout_alignParentBottom 位于父元素的下边缘android:layout_alignParentTop 位于父元素的上边缘android:layout_alignParentLeft 位于父元素的左边缘android:layout_alignParentRight 位于父元素的右边缘属性值是”@id/*“android:layout_below 在某元素的下方android:layout_above 在某元素的上方andorid:layout_toRightOf 在某元素的右方android:layout_toLeftOf 在某元素的左方android:layout_alignBottom 和某元素下方对齐android:layout_alignTop 和某元素上方对齐android:layout_alignRight 和某元素右方对齐android:layout_alignLeft 和某元素左方对齐属性值是数值android:layout_marginLeft 离某元素左边缘的距离android:layout_marginRight 离某元素右边缘的距离android:layout_marginTop 离某元素上边缘的距离android:layout_marginBottom 离某元素下边缘的距离上面这两种是最常用的两种布局，基本能完成一些基本的布局了。 1.3.3 自定义布局 自定义是对ViewGroup进行继承，一般要实现以下方法： 重写onMeasure()方法对子View进行测量。在onMeasure中计算childView的测量值以及模式，以及设置自己的宽和高。 重写onLayout()方法确定子View的位置，对所有childView进行定位（设置childView的绘制区域）。自定义ViewGroup是很有必要的，因为当官方给出的空间无法满足自己的需求时，就需要自己取定义一种布局了。 1.3.4 FrameLayout框架布局，第一个控件放在最底层的左上角，然后后面的控件在左上角一层一层的覆盖上去。类似于Ps图层的样子。 1.3.5 TableLayout表格布局，顾名思义，就是一个表格。它遵循着以下结构： 12345678&lt;TableLayout&gt; &lt;TableRow&gt; &lt;!-在这里填充第一行的元素-&gt; &lt;/TableRow&gt; &lt;TableRow&gt; &lt;!-在这里填充第二行的元素-&gt; &lt;/TableRow&gt; &lt;/TableLayout&gt; 还有几个重要属性： 写在TableLayout中的属性 android:stretchColumns 设置第几列为伸展(0表示第一列) ndroid:shrinkColumns 设置第几列为收缩 android:collapseColumns 设置第几列为隐藏 写在TableRow里的控件里的属性 android:layout_column 设置控件在第几列 android:layout_span 设置控件能跨多少列 1.3.6 AbsoluteLayout绝对布局，已经被淘汰了的布局。 所有控件都要设置x,y坐标，使用绝对的布局。 android:layout_x //控件x坐标android:layout_y //控件y坐标 1.4 控件 1.4.1 android自带控件1.4.2 自定义控件自定义控件有三种方法： 对现有控件进行扩展，继承控件后重写onDraw()方法，在回调父类方法前实现自己的逻辑。 通过组合来实现新的控件 重写View来实现全新的控件123456@Overrideprotected void onDraw(Canvas canvas){ //在回调之前实现自己逻辑。 super.onDraw(canvas); //在回调之后实现自己逻辑。} 2 动态布局2.1 用类修改xml可以使用findViewById找到想要进行接管的控件，然后再修改其中的属性，然后达到动态的目的。 2.2 动态生成首先创建一个布局管理器，然后使用setContentView()将布局管理器绘制出来,之后再用addView()方法加入控件元素 Drawable类及XMLDrawable的使用一.性质可直接使用.png、.jpg、.gif、9.png等图片作为资源,也可使用多种XML文件作为资源。（就是这些资源都能生成Drawable对象）。并对XML文件作出相关处理 二.XMLDrawable1.StateListDrawable(selector)作用：StateListDrawable对象所显示的Drawable对象会随着目标组件状态的改变而改变 组成： 123根元素&lt;selector/&gt;，子元素&lt;item/&gt;子元素&lt;item/&gt;的属性：android:color或android:drawableandroid:state_xxx:状态 2.LayerDrawable(ps图层)作用：可包含一个Drawable数组，系统会按照Drawable对象的数组顺序绘制，索引越大越被绘制在上层 12345根元素：&lt;layer-list&gt; 子元素：&lt;item/&gt;子元素的属性：android:drawable 作为LayerDrawable的Drawable对象android:id 为Drawable对象指定标识符android:buttom|top...等 指定Drawable的绘制位置 3.ShapeDrawable作用：设置一个基本的几何图形（矩形、圆形、线条灯） 12345678910根元素：&lt;shape/&gt;根元素的属性：android:shape=[&quot;rectangle&quot;|&quot;oval&quot;|&quot;line&quot;|&quot;ring&quot;]子元素：&lt;corners/&gt;：设置整体或者四个边角的弧度&lt;gradient/&gt;:渐变（可选择渐变的角度但必须是45的倍数，默认为0，渐变的中心点，渐变的类型，渐变的半径和开始和终止的颜色）&lt;padding/&gt;:内边距 （可以控制四周的边距）&lt;size/&gt;:形状的大小 （设置形状的宽高）&lt;solid/&gt;:单种颜色填充 &lt;stroke/&gt;:绘制边框 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:dither=[&quot;true&quot; | &quot;false&quot;] //将在位图的像素配置与屏幕不同时（例如：ARGB 8888 位图和 RGB 565 屏幕）启用位图的抖动；值为“false”时则停用抖动。默认值为 true。 android:shape=[&quot;rectangle&quot; | &quot;oval&quot; | &quot;line&quot; | &quot;ring&quot;]//分别为矩形、椭圆、线、环。默认为矩形rectangle android:innerRadius=&quot;integer&quot; // shape为ring时有效，内环半径 android:innerRadiusRatio=&quot;float&quot; // shape为ring时有效，内环的厚度比，即环的图形宽度与内环半径的比例，按照这个比例计算内环半径，默认为3，可被innerRadius值覆盖 android:thickness=&quot;integer&quot; // shape为ring时有效，环的厚度 android:thicknessRatio=&quot;float&quot; // shape为ring时有效，环的厚度比，即环的图形宽度与环的厚度的比例，按照这个比例计算环的厚度，默认为9，可被thickness值覆盖 android:tint=&quot;color&quot; // 给shape着色 android:tintMode=[&quot;src_in&quot; | &quot;src_atop&quot; | &quot;src_over&quot; | &quot;add&quot; | &quot;multiply&quot; | &quot;screen&quot;] // 着色类型 android:useLevel=[&quot;true&quot; | &quot;false&quot;] // 较少用，一般设为false，否则图形不显示。为true时可在LevelListDrawable使用 android:visible=[&quot;true&quot; | &quot;false&quot;] &gt; &lt;!-- 圆角 --&gt; &lt;corners android:radius=&quot;integer&quot; // 圆角半径，设置下面四个属性时，对应的位置属性会被覆盖 android:topLeftRadius=&quot;integer&quot; // 左上角圆角半径 android:topRightRadius=&quot;integer&quot; // 右上角圆角半径 android:bottomLeftRadius=&quot;integer&quot; // 左下角圆角半径 android:bottomRightRadius=&quot;integer&quot; // 右下角圆角半径 /&gt; &lt;!-- 渐变 --&gt; &lt;gradient android:type=[&quot;linear&quot; | &quot;radial&quot; | &quot;sweep&quot;]// 渐变类型，线性、放射性、扫描性；默认为线性 android:angle=&quot;integer&quot; // 渐变角度，渐变类型为linear时有效；默认为0，从左至右渐变，角度逆时针方向计算，角度需要时45的整数倍数 android:centerColor=&quot;integer&quot; // 渐变中间位置颜色 android:startColor=&quot;color&quot; // 渐变开始位置颜色 android:endColor=&quot;color&quot; // 渐变结束位置颜色 android:centerX=&quot;float&quot; // 设置渐变中心的X坐标，取值区间[0,1]，默认为0.5，即中心位置 android:centerY=&quot;float&quot; // 设置渐变中心的Y坐标，取值区间[0,1]，默认为0.5，即中心位置 android:gradientRadius=&quot;integer&quot; // type为放射性渐变radial时有效，渐变的半径 android:useLevel=[&quot;true&quot; | &quot;false&quot;] // 与shape中该属性的一致 /&gt; &lt;!-- 内边距 --&gt; &lt;padding android:left=&quot;integer&quot; // 左边距 android:top=&quot;integer&quot; // 上边距 android:right=&quot;integer&quot; // 右边距 android:bottom=&quot;integer&quot; // 下边距 /&gt; &lt;!-- 大小 --&gt; &lt;size android:width=&quot;integer&quot; // 图形宽度 android:height=&quot;integer&quot; // 图形高度 /&gt; &lt;!-- 填充 --&gt; &lt;solid android:color=&quot;color&quot; // 图形的填充色 /&gt; &lt;!-- 描边 --&gt; &lt;stroke android:width=&quot;integer&quot; // 描边的宽度 android:color=&quot;color&quot; // 描边的颜色 android:dashWidth=&quot;integer&quot; // 虚线宽度 android:dashGap=&quot;integer&quot; // 虚线间隔 /&gt;&lt;/shape&gt; 可设置画笔的颜色和粗细并设置每画一条线的长度和间距且必须两者都设置才有效 4.ClipDrawable作用：从Drawable上截取一个”图片片段” 123456根元素：&lt;clip&gt; 不使用子元素。根元素属性： android:drawable: 选定Drawable对象android:clipOrientation:指定截取方向android:gravity:从什么地方开始截取 总结：选定图片并选择方向与位置截取图片 使用：从java中获取ClipDrawable并用setLevel()改变截取大小 //setLevel()只能从0~10000 123456&lt;!--res/drawable/test_clip.xml--&gt;&lt;clip xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:drawable=&quot;@mipmap/start&quot; android:clipOrientation=&quot;horizontal&quot; android:gravity=&quot;center&quot;&gt;&lt;/clip&gt; 123456789101112131415&lt;!--res/layout/activity_main.xml--&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;com.chen.android.test.MainActivity&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/test_clip&quot;/&gt;&lt;/LinearLayout&gt; 12345678910111213141516171819202122232425262728293031323334353637/*实现图片渐渐展开的效果*/public class MainActivity extends AppCompatActivity { int data = 0; int what = 0X11; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ImageView img = (ImageView)findViewById(R.id.imageView); //ImageView.getDrawable()获取的是当前控件里的图片，返回的是Drawable类型,还有说明Drawable对象可随意变成子对象并调用子对象的方法 final ClipDrawable clipDrawable = (ClipDrawable)img.getDrawable(); //创建Handler等待计时器传送的信息，使图片扩展 final Handler mHandler = new Handler(){ @Override public void handleMessage(Message msg) { super.handleMessage(msg); if (msg.what == what){ clipDrawable.setLevel(data);//扩大截取的图片面积 data += 200; } } }; //创建计时器 final Timer timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { if (data &gt;= 10000){ timer.cancel(); } mHandler.obtainMessage(what).sendToTarget(); } },0,300); }} 5.AnimationDrawable简介：放在res/anim下，支持逐帧动画和补间动画 12345678910111213根元素：&lt;set&gt; 根元素属性：android:interpolator=&quot;参数&quot;linear_interpolator：匀速变换 accelerate_interpolar：加速变换decelerate_interpolator：减速变换android:shareInterpolator= &quot;true|false&quot; ：是否让资源的interpolator与根元素相同android:duration=&quot;时间&quot;：定义持续时间子元素(同样可以设置duration)&lt;alpha&gt;：设置开始和结束的透明度&lt;scale&gt;：设置缩放的中心、开始的X，Y的尺寸和结束时X,Y的尺寸&lt;translate&gt;：设置图片的开始位置和结束位置进行位移&lt;rotate&gt;：设置旋转的中心、开始的角度和结束时候的角度 注意：利用android:fillAfter=”true|false”：设置保留后的状态（哪个状态想保留就用这个，如果都像就放在set中） 使用：利用AnimationUtils的静态方法loadAninmation(Context context,int resId) 123456789101112131415161718192021222324&lt;!--在res/anim/test_animtaion中--&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@android:anim/linear_interpolator&quot; android:shareInterpolator=&quot;true&quot; android:fillAfter=&quot;true&quot;&gt; &lt;alpha android:fromAlpha=&quot;50.0&quot; android:toAlpha=&quot;100.0&quot; /&gt; &lt;scale android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:fromXScale=&quot;1.0&quot; android:fromYScale=&quot;1.0&quot; android:toXScale=&quot;1.5&quot; android:toYScale=&quot;1.5&quot; android:duration=&quot;3000&quot; /&gt; &lt;translate android:fromXDelta=&quot;30&quot; android:toXDelta=&quot;300&quot; android:fromYDelta=&quot;40&quot; android:toYDelta=&quot;90&quot; android:duration=&quot;3000&quot;/&gt;&lt;/set&gt; 123456789101112131415/*实现动画*/public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ImageView img = (ImageView)findViewById(R.id.imageView); /*利用工具类获取对象*/ Animation animation= AnimationUtils.loadAnimation(this,R.anim.test_animation); /*将动画附加在图片上*/ img.startAnimation(animation); }}","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8812%E6%97%A5/"},{"title":"实习笔记-3","text":"在安卓中显示gif图片使用WebView 123456&lt;WebView android:id=&quot;@+id/runWebView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_centerVertical=&quot;true&quot; /&gt; 12345678runWebView.loadDataWithBaseURL(null,&quot;&lt;html&gt; &lt;body bgcolor='#f3f3f3'&gt; &lt;div align=center&gt; &lt;IMG src='file:///android_asset/run.gif'/&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&quot;, &quot;text/html&quot;, &quot;UTF-8&quot;,null); 实现底部状态栏使用recyclerview + gridlayoutmanager12345val rc_btm_navi = findViewById&lt;RecyclerView&gt;(R.id.rc_btm_navi)rc_btm_navi.layoutManager = GridLayoutManager(this,1).apply { orientation = GridLayoutManager.HORIZONTAL}rc_btm_navi.adapter = navi_adapter() adaper中获取屏幕宽度，创建view时设置view的宽度1234567891011override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): view_holder { val view: View = LayoutInflater.from(parent.context) .inflate( R.layout.item_navi, parent, false ) view.layoutParams.width = getScreenWidth(activity) / navi_arr.size return view_holder(view)} 自定义下拉刷新(没学会) TRANSLUCENT 半透明 rectF类 Rect F holds four float coordinates for a rectangle . The rectangleis represented by the coordinates of its 4 edges ( left , top , rightbottom ). These fields can be accessed directly . Use width () andheight () to retrieve the rectangle ’ s width and height . Note :most methods do not check to see that the coordinates are sortedcorrectly ( i . e . left &lt;= right and top &lt;= bottom ). ViewFlipper(翻转视图) 就是首次安装软件后的功能介绍页面 使用导入图片123456789101112131415&lt;ViewFlipper android:id=&quot;@+id/vflp_help&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:inAnimation=&quot;@anim/right_in&quot; android:outAnimation=&quot;@anim/right_out&quot; android:flipInterval=&quot;3000&quot;&gt; &lt;include layout=&quot;@layout/page_help_one&quot; /&gt; &lt;include layout=&quot;@layout/page_help_two&quot; /&gt; &lt;include layout=&quot;@layout/page_help_three&quot; /&gt; &lt;include layout=&quot;@layout/page_help_four&quot; /&gt; &lt;!--此处为静态导入--&gt;&lt;/ViewFlipper&gt; 123456789//动态导入for(int i = 0;i &lt; resId.length;i++){ vflp_help.addView(getImageView(resId[i]));}private ImageView getImageView(int resId){ ImageView img = new ImageView(this); img.setBackgroundResource(resId); return img;} 翻动手动翻动 自定义一个GestureListener 创建一个GestureDetector 重写activity的onTouchEvent12345678910111213141516171819private class MyGestureListener extends GestureDetector.SimpleOnGestureListener { @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float v, float v1) { if(e1.getX() - e2.getX() &gt; MIN_MOVE){ vflp_help.setInAnimation(mContext,R.anim.right_in); vflp_help.setOutAnimation(mContext, R.anim.right_out); vflp_help.showNext(); }else if(e2.getX() - e1.getX() &gt; MIN_MOVE){ vflp_help.setInAnimation(mContext,R.anim.left_in); vflp_help.setOutAnimation(mContext, R.anim.left_out); vflp_help.showPrevious(); } return true; }}@Overridepublic boolean onTouchEvent(MotionEvent event) { return mDetector.onTouchEvent(event);} 12//自动翻动vflp_help.startFlipping(); fragment中实现触摸事件参考","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8814%E6%97%A5/"},{"title":"实习笔记-4","text":"ImageView的参数1android:adjustViewBounds=&quot;true&quot; 对应源码1234567@android.view.RemotableViewMethodpublic void setAdjustViewBounds(boolean adjustViewBounds) { mAdjustViewBounds = adjustViewBounds; if (adjustViewBounds) { setScaleType(ScaleType.FIT_CENTER); }} 应用场景 当宽高有且仅有一个设置为wrapContent的时候是有用，指定一个宽or高，再根据drawable的比例确定另一个高/宽的值 协调者布局 CoordinateLayout作用协调子 View 之间交互的容器 使用例1 点击FloatingActionBar弹出sneakbar，如果不适用CoordinateLayout，会导致弹出的SneakBar遮挡住FAB layout_scrollFlags scroll|exitUntilCollapsed如果AppBarLayout的直接子控件设置该属性,该子控件可以滚动,向上滚动NestedScrollView出父布局(一般为CoordinatorLayout)时,会折叠到顶端,向下滚动时NestedScrollView必须滚动到最上面的时候才能拉出该布局 scroll|enterAlways只要向下滚动该布局就会显示出来,只要向上滑动该布局就会向上收缩 scroll|enterAlwaysCollapsed向下滚动NestedScrollView到最底端时该布局才会显示出来如果不设置改属性,则改布局不能滑动 snap滑动时的弹性 CollapsingToolbarLayout它的直接子布局可以使用的属性:app:layout_collapseMode(折叠模式) pin:在滑动过程中,此自布局会固定在它所在的位置不动,直到CollapsingToolbarLayout全部折叠或者全部展开 parallax:视差效果，在折叠的时候会有个视差折叠的效果 不设置:跟随NestedScrollView的滑动一起滑动,NestedScrollView滑动多少距离他就会跟着走多少距离 自定义Behavior通常自定义Behavior分为两种情况： 某个View依赖另一个View，监听其位置、尺寸等状态的变化。 某个View监听CoordinatorLayout内实现了NestedScrollingChild接口的子View的滑动状态变化(也是一种依赖关系)。 只有CoordinatorLayout的直接子布局才能响应 效果示例 可override的几个函数 onInterceptTouchEvent()：是否拦截触摸事件 onTouchEvent()：处理触摸事件 layoutDependsOn()：确定使用Behavior的View要依赖的View的类型 onDependentViewChanged()：当被依赖的View状态改变时回调 onDependentViewRemoved()：当被依赖的View移除时回调 onMeasureChild()：测量使用Behavior的View尺寸 onLayoutChild()：确定使用Behavior的View位置 onStartNestedScroll()：嵌套滑动开始（ACTION_DOWN），确定Behavior是否要监听此次事件 onStopNestedScroll()：嵌套滑动结束（ACTION_UP或ACTION_CANCEL） onNestedScroll()：嵌套滑动进行中，要监听的子 View的滑动事件已经被消费 onNestedPreScroll()：嵌套滑动进行中，要监听的子 View将要滑动，滑动事件即将被消费（但最终被谁消费，可以通过代码控制） onNestedFling()：要监听的子 View在快速滑动中 onNestedPreFling()：要监听的子View即将快速滑动 (参考)[https://www.jianshu.com/p/b987fad8fcb4] NestedScrollView NestedScrollView 与 ScrollView 一样，内部只能容纳一个子控件。当存在多个组件（产生滑动冲突时），解决冲突的办法：1android:nestedScrollingEnabled=&quot;false&quot; RecyclerView 实现瀑布流效果 1）通过LinearLayoutManager：我们可以实现横向、纵向的列表效果 2）通过GridLayoutManager：我们可以实现像GridView一样的网格布局 3）通过StaggeredGridLayoutManager：我们可以实现瀑布流的效果 网络请求踩坑明码传输 D/OkHttp: &lt;– HTTP FAILED: java.net.UnknownServiceException: CLEARTEXT communication to japi.juhe.cn not permitted by network security policy 为保证用户数据和设备的安全，Google针对下一代 Android 系统(Android P) 的应用程序，将要求默认使用加密连接，这意味着 Android P 将禁止 App 使用所有未加密的连接，因此运行 Android P 系统的安卓设备无论是接收或者发送流量，未来都不能明码传输。 在res文件夹下创建一个xml文件夹，然后创建一个network_security_config.xml文件，文件内容如下：1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted=&quot;true&quot; /&gt;&lt;/network-security-config&gt; 接着，在AndroidManifest.xml文件下的application标签增加以下属性1android:networkSecurityConfig=&quot;@xml/network_security_config&quot; 声明权限 12&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; 注意标签是uses-permission，不是permission","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8817%E6%97%A5/"},{"title":"实习笔记-7","text":"FragmentActivity和Activity的具体区别在哪里fragment是3.0以后的东西，为了在低版本中使用fragment就要用到android-support-v4.jar兼容包,fragmentActivity提供了操作fragment的一些方法，其功能跟3.0及以后的版本的Activity的功能一样。 1、fragmentactivity 继承自activity，用来解决android3.0 之前没有fragment的api，所以在使用的时候需要导入support包，同时继承fragmentActivity，这样在activity中就能嵌入fragment来实现你想要的布局效果。 2、当然3.0之后你就可以直接继承自Activity，并且在其中嵌入使用fragment了。 3、获得Manager的方式也不同 3.0以下：getSupportFragmentManager() 3.0以上：getFragmentManager()（已弃用） activity 转场动画 参考 使用windowAnimation和ActivityAnimation windowAnimation包含 windowEnterAnimation windowExitAnimation ActivityAnimation包含 android:activityOpenEnterAnimation android:activityOpenExitAnimation android:activityCloseEnterAnimation android:activityCloseExitAnimation 在项目中WindowAnimation的控制权大于Activity的控制权，即在Activity转场过程中，如果同时设置了WindowAnimation和ActivityAnimation,那么 可能（因为这种情况非常多） 只会执行WindowAnimation 对于WindowAnimation的定义很简单，在style.xml文件中只需要继承Animation.Style即可 overridePendingTransition 只能紧跟startActivity和finish之后调用 xml style在values/styles.xml下 1234567891011&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.DayNight.NoActionBar&quot;&gt; &lt;item name=&quot;android:windowAnimationStyle&quot;&gt;@style/myActivityOutEnterAnima&lt;/item&gt;&lt;/style&gt;&lt;style name=&quot;myActivityOutEnterAnima&quot; parent=&quot;@android:style/Animation.Activity&quot;&gt;&lt;!-- 定义activity的进出场动画 --&gt; &lt;item name=&quot;android:activityOpenEnterAnimation&quot;&gt;@anim/enter_from_right&lt;/item&gt; &lt;item name=&quot;android:activityOpenExitAnimation&quot;&gt;@anim/out_to_left&lt;/item&gt; &lt;item name=&quot;android:activityCloseEnterAnimation&quot;&gt;@anim/enter_from_left&lt;/item&gt; &lt;item name=&quot;android:activityCloseExitAnimation&quot;&gt;@anim/out_to_right&lt;/item&gt;&lt;/style&gt; 最后给Application/activity配置theme选项 5.0以后 内置Activity切换动画常用参数 enter：用于决定第一次打开当前Activity时的动画 exit : 用于决定退出当前Activity时的动画 reenter: 用于决定如果当前Activity已经打开过，并且再次打开该Activity时的动画 shared elements:用于决定在两个Activity之间切换时，指定两个Activity中对应的View的过渡效果 步骤1.在setContentView()之前执行，用于告诉Window页面切换需要使用动画接下来就是加载切换动画1getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS); 2.加载切换动画123Transition explode = TransitionInflater .from(this) .inflateTransition(R.transition.explode); 3.告诉Window，当前的Activity在什么情况下使用上面的动画123getWindow().setExitTransition(explode);getWindow().setEnterTransition(explode);getWindow().setReenterTransition(explode); 或者在主题中添加 123&lt;item name=&quot;android:windowExitTransition&quot;&gt;@transition/explode&lt;/item&gt;&lt;item name=&quot;android:windowEnterTransition&quot;&gt;@transition/explode&lt;/item&gt;&lt;item name=&quot;android:windowReenterTransition&quot;&gt;@transition/explode&lt;/item&gt; 4.调用startActivity时，将Transition变成bundle1startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(this).toBundle()); 使用内置动画在res/transition目录下，新建xml文件 123&lt;explode xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;300&quot; /&gt; 123456&lt;slide xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:slideEdge=&quot;end&quot; android:duration=&quot;300&quot; /&gt; &lt;!--slideEdge表示起始滑动的侧边位置--&gt; &lt;!-- start, end top,bottom --&gt; 如果不希望状态栏，导航栏跟随一起执行动画，可以添加 target excludeId 123456789&lt;slide xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:slideEdge=&quot;end&quot; android:duration=&quot;300&quot;&gt; &lt;target android:excludeId=&quot;@android:id/navigationBarBackground&quot;/&gt; &lt;target android:excludeId=&quot;@android:id/statusBarBackground&quot;/&gt; &lt;/slide&gt; &lt;!--slideEdge表示起始滑动的侧边位置--&gt; &lt;!-- start, end top,bottom --&gt; 123&lt;fade xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;300&quot; /&gt; sharedElement效果共享元素效果，与前面几种效果不同的是，共享元素效果是将前面一个Activity的某个子View与后面一个Activity的某个子View之间有过渡效果 1.将两个Activity中需要过渡的View加上Android:transitionName属性两个View的android:transitionName属性取值要一致 2.调用startActivity，makeTransitionAnimation时添加第二个参数–第一个Activity中的view对象，第三个参数–transitionName1startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(this, SharedView, &quot;TransitionName&quot;).toBundle()) 添加多个view同时具有Transition过度切换效果把SharedView和TransitionName组成一个Pair，依次穿给makeSceneTransitionAnimation 123Pair first = new Pair&lt;&gt;(firstSharedView, ViewCompat.getTransitionName(firstSharedView));Pair second = new Pair&lt;&gt;(secondSharedView, ViewCompat.getTransitionName(secondSharedView));ActivityOptionsCompat.makeSceneTransitionAnimation(activity, first, second); 自定义过渡动画轨迹路径1.创建一个View的过渡移动的轨迹路径PathMotion类 我们可以创建ArcMotion对象，ArcMotion是PathMotion子类，是个曲线路径。想要了解更多ArcMotion可以查看： ArcMotion官方文档 2.定义ChangeBounds类我们自定义一个继承ChangeBounds的类，主要重写createAnimator函数，即创建你要执行的动画。这个函数由3个参数： ViewGroup sceneRoot：屏幕根View，即DecorView，第二个Activity的DecorView。 TransitionValues startValues ：属性动画的起始属性值，TransitionValues 对象内部有各Map类型的属性values，用于保存需要执行属性动画的属性。这个里面的属性值是在函数captureStartValues里放置，因此你可以重写captureStartValues函数，并把你自定义的属性动画中的属性放进去。 TransitionValues endValues：与startValues类似，表示属性动画结束时的属性值。可以通过重写captureEndValues函数，并把你自定义的属性动画里面的最终属性值放进去。 自动弹起软键盘1234567891011window.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE)et.postDelayed({ runOnUiThread { et.isFocusable = true et.isFocusableInTouchMode = true et.requestFocus() et.findFocus() val inputManager = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager inputManager.showSoftInput(et, InputMethodManager.SHOW_IMPLICIT) }},300) 代码混淆application 初始化减少log 必须加debugviewbinding海外工作注意事项 海外app开发时不能连公司wifi，必须断网，或者用4g 不会的东西自己解决不了，大胆和同事请教和同事协调时间和进度。 心态上 别人指出问题，有自己判断，要客观","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8821%E6%97%A5/"},{"title":"实习笔记-6","text":"recyclerview 刷新数组越界问题属性动画 参考 recyclerview 点击位移","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8820%E6%97%A5/"},{"title":"实习笔记-5","text":"git相关知识 参考 新建代码库12345678## 当前目录 新建一个Git代码库$ git init ## 新建一个目录，将其初始化为Git代码库$ git init [project-name] ## 下载一个项目和它的整个代码历史$ git clone [url] 配置123456789## 显示当前的Git配置$ git config --list ## 编辑Git配置文件$ git config -e [--global] ## 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 增加/删除文件123456789101112131415161718192021## 添加指定文件到暂存区$ git add [file1] [file2] ... ## 添加指定目录到暂存区，包括子目录$ git add [dir] ## 添加当前目录的所有文件到暂存区$ git add . ## 添加每个变化前，都会要求确认## 对于同一个文件的多处变化，可以实现分次提交$ git add -p ## 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ... ## 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file] ## 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] -p 参数的提示1234567891011121314y - stage this hunkn - do not stage this hunkq - quit; do not stage this hunk nor any of the remaining onesa - stage this hunk and all later hunks in the filed - do not stage this hunk nor any of the later hunks in the fileg - select a hunk to go to/ - search for a hunk matching the given regexj - leave this hunk undecided, see next undecided hunkJ - leave this hunk undecided, see next hunkk - leave this hunk undecided, see previous undecided hunkK - leave this hunk undecided, see previous hunks - split the current hunk into smaller hunkse - manually edit the current hunk? - print help 代码提交123456789101112131415161718## 提交暂存区到仓库区$ git commit -m [message] ## 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message] ## 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a ## 提交时显示所有diff信息$ git commit -v ## 使用一次新的commit，替代上一次提交## 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message] ## 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142## 列出所有本地分支$ git branch ## 列出所有远程分支$ git branch -r ## 列出所有本地分支和远程分支$ git branch -a ## 新建一个分支，但依然停留在当前分支$ git branch [branch-name] ## 以远程分支为基础新建一个分支，并切换到该分支$ git checkout -b [branch] origin/[remote-branch] ## 新建一个分支，指向指定commit$ git branch [branch] [commit] ## 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch] ## 切换到指定分支，并更新工作区$ git checkout [branch-name] ## 切换到上一个分支$ git checkout - ## 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch] ## 合并指定分支到当前分支$ git merge [branch] ## 选择一个commit，合并进当前分支$ git cherry-pick [commit] ## 删除分支$ git branch -d [branch-name] ## 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签 Git 可以给仓库历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（ v1.0 、 v2.0 等等）。 You have to commit first before tagging1234567891011121314151617181920212223242526272829303132## 列出所有tag$ git tag## 查看tag的信息$ git show [tag] ## 新建一个tag在当前commit$ git tag -a v1.4 -m &quot;my version 1.4&quot;## 轻量标签$ git tag [tag]## 轻量标签本质上是将提交校验和存储到一个文件中，没有保存任何其他信息。 ## 新建一个tag在指定commit$ git tag [tag] [commit] ## 删除本地tag$ git tag -d [tag] ## 删除远程tag$ git push origin :refs/tags/[tagName] ## 查看tag信息$ git show [tag] ## 提交指定tag$ git push [remote] [tag] ## 提交所有tag$ git push [remote] --tags ## 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960## 显示有变更的文件，本地未commit的文件$ git status ## 显示当前分支的版本历史$ git log ## 显示commit历史，以及每次commit发生变更的文件$ git log --stat ## 搜索提交历史，根据关键词$ git log -S [keyword] ## 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s ## 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature ## 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file] ## 显示指定文件相关的每一次diff$ git log -p [file] ## 显示过去5次提交$ git log -5 --pretty --oneline ## 显示所有提交过的用户，按提交次数排序$ git shortlog -sn ## 显示指定文件是什么人在什么时间修改过$ git blame [file] ## 显示暂存区和工作区的差异$ git diff ## 显示暂存区和上一个commit的差异$ git diff --cached [file] ## 显示工作区与当前分支最新commit之间的差异$ git diff HEAD ## 显示两次提交之间的差异$ git diff [first-branch]...[second-branch] ## 显示今天你写了多少行代码$ git diff --shortstat &quot;@{0 day ago}&quot; ## 显示某次提交的元数据和内容变化$ git show [commit] ## 显示某次提交发生变化的文件$ git show --name-only [commit] ## 显示某次提交时，某个文件的内容$ git show [commit]:[filename] ## 显示当前分支的最近几次提交$ git reflog 远程同步1234567891011121314151617181920212223## 下载远程仓库的所有变动$ git fetch [remote] ## 显示所有远程仓库$ git remote -v ## 显示某个远程仓库的信息$ git remote show [remote] ## 增加一个新的远程仓库，并命名$ git remote add [shortname] [url] ## 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch] ## 上传本地指定分支到远程仓库$ git push [remote] [branch] ## 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force ## 推送所有分支到远程仓库$ git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031## 恢复暂存区的指定文件到工作区$ git checkout [file] ## 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file] ## 恢复暂存区的所有文件到工作区$ git checkout . ## 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file] ## 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard ## 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit] ## 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit] ## 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit] ## 新建一个commit，用来撤销指定commit## 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit] ## 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop git分支管理master分支和开发分支 主分支只用来分布重大版本，日常开发应该在另一条分支上完成。我们把开发用的分支，叫做Develop。 创建develop分支1git checkout -b develop master 合并12345## 切换到Master分支git checkout master## 对Develop分支进行合并git merge --no-ff develop --no-ff参数 默认情况下，Git执行”快进式合并”（fast-farward merge），会直接将Master分支指向Develop分支。 使用--no-ff参数，会执行正常合并，在Master分支上生成一个新节点 功能分支 为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop。 功能分支的名字，可以采用feature-*的形式命名。 创建一个功能分支：1git checkout -b feature-x develop 开发完成后，将功能分支合并到develop分支：123git checkout developgit merge --no-ff feature-x 删除feature分支：1git branch -d feature-x 预发布分支 指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。 预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支。它的命名，可以采用release-*的形式。 创建一个预发布分支：1git checkout -b release-1.2 develop 确认没有问题后，合并到master分支：123456git checkout mastergit merge --no-ff release-1.2## 对合并生成的新节点，做一个标签git tag -a 1.2 再合并到develop分支：123git checkout developgit merge --no-ff release-1.2 最后，删除预发布分支：1git branch -d release-1.2 修补bug分支 修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支。它的命名，可以采用fixbug-*的形式。 创建一个修补bug分支：12git checkout -b fixbug-0.1 master## 以master分支为基础，创建一个分支 修补结束后，合并到master分支：12345678git checkout master## 切换到master分支git merge --no-ff fixbug-0.1#合并分支git tag -a 0.1.1## 打tag 再合并到develop分支：123git checkout developgit merge --no-ff fixbug-0.1 最后，删除”修补bug分支”：1git branch -d fixbug-0.1 版本回退-撤销文件修改（针对文件修改的恢复） 参考 自定义组件之–自定义xml属性step1. 自定义属性名称 在values中创建一个xml文件，并且在其中写上你需要的自定义属性的名称以及类型。12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;MyTitle&quot;&gt; &lt;!--name 指向自定义组件的类名--&gt; &lt;attr name=&quot;textColor&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;titleText&quot; format=&quot;string&quot;/&gt; &lt;attr name=&quot;leftText&quot; format=&quot;string&quot;/&gt; &lt;attr name=&quot;rightText&quot; format=&quot;string&quot;/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; step2. 将属性名称与控件关联1234567891011//从xml的属性中获取到字体颜色与stringTypedArray ta=context.obtainStyledAttributes(attrs,R.styleable.MyTitle);colorText=ta.getColor(R.styleable.MyTitle_textColor,Color.BLACK);textLeft=ta.getString(R.styleable.MyTitle_leftText);textTitle=ta.getString(R.styleable.MyTitle_titleText);textRight=ta.getString(R.styleable.MyTitle_rightText);ta.recycle();//public void recycle ()：//Give back a previously retrieved array, for later re-use.//回收 TypedArray,用于后续调用时可复用之。当调用该方法后，不能再操作该变量。//该类没有公共的构造函数，只提供静态方法获取实例，显然是一个典型的单例模式。这个 array 是从一个 array pool的池中获取的。 step3. 从第三方命名空间获取到自定义属性名称1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:my_view=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;!--添加这个 命名空间--&gt; &lt;com.example.double2.viewxmltest.MyView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@android:color/holo_blue_dark&quot; my_view:leftText=&quot;Back&quot; my_view:rightText=&quot;Go&quot; my_view:textColor=&quot;#fff&quot; my_view:titleText=&quot;MyViewTest&quot;/&gt; &lt;!--添加属性--&gt;&lt;/RelativeLayout&gt;","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8819%E6%97%A5/"},{"title":"实习笔记-8","text":"组件merge类名.()的写法123456789inline fun AppCompatActivity.fragmentTransaction(block: FragmentTransaction.() -&gt; Unit): Boolean { kotlin.runCatching { val t = supportFragmentManager.beginTransaction() block.invoke(t) t.commitNowAllowingStateLoss() return true } return false} 1234/* 新的协程job */fun newWorkerThreadCoroutineJob(block: suspend CoroutineScope.() -&gt; Unit): Job { return GlobalScope.launch(context = Dispatchers.IO, block = block)} android-job庫 參考 kotlin基礎kotlin 携程 顶层主协程? 协程是轻量级的线程 delay 是一个特殊的 挂起函数 ，它不会造成线程阻塞，但是会 挂起 协程，并且只能在协程中使用。12345678910import kotlinx.coroutines.*fun main() { GlobalScope.launch { // 在后台启动一个新的协程并继续 delay(1000L) // 非阻塞的等待 1 秒钟（默认时间单位是毫秒） println(&quot;World!&quot;) // 在延迟后打印输出 } println(&quot;Hello,&quot;) // 协程已在等待时主线程还在继续 Thread.sleep(2000L) // 阻塞主线程 2 秒钟来保证 JVM 存活} delay是非阻塞的，sleep是阻塞的 抛棄sleep，使用runBlocking與delay123456789101112import kotlinx.coroutines.*fun main() { GlobalScope.launch { // 在后台启动一个新的协程并继续 delay(1000L) println(&quot;World!&quot;) } println(&quot;Hello,&quot;) // 主线程中的代码会立即执行 runBlocking { // 但是这个表达式阻塞了主线程 delay(2000L) // ……我们延迟 2 秒来保证 JVM 的存活 } } 子協程的join方法123456val job = GlobalScope.launch { // 启动一个新协程并保持对这个作业的引用 delay(1000L) println(&quot;World!&quot;)}println(&quot;Hello,&quot;)job.join() // 等待直到子协程执行结束 suspend關鍵字object關鍵字能自動實現單例模式的class，不能被賦值123object Test { val a = 0;} 對應的字節碼 1234567891011121314151617public final class Test { private static final int a; @NotNull public static final Test INSTANCE; public final int getA() { return a; } private Test() { } static { Test var0 = new Test(); INSTANCE = var0; }} 伴生對象 在 JVM 平台，如果使用 @JvmStatic 注解，你可以将伴生对象的成员生成为真正的静态方法和字段。更详细信息请参见Java 互操作性一节 。 handler讓子綫程結束后的結果傳遞給主綫程， 給主綫程更新界面handler異步通信系統：Handler，message，Looper， MessageQueueLooper:主綫程不斷從消息隊列中拿消息的東西子綫程–拿到主綫程的handler，sendMessage–&gt;主綫程的Handler系統–從消息隊列中拿到消息，交給主綫程，handleMessage–&gt;主綫程","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8822%E6%97%A5/"},{"title":"projects","text":"fedml: deployment and modification to combine with Hyperledger fabric repo fabric: deployment and combination with fedml repo Yaml-Requests: read your yaml config file to generate python function repo Algorithm: notes for leetcode and other oj repo","link":"/home/2022/10/22/projects/"},{"title":"实习笔记-9","text":"APP新手蒙层引导实现方式1SmartGuideView库 github 链接 教程 TourGuide库 github 使用Dialog自定义显示软键盘12345678910111213141516binding.etSearchSearchBar.postDelayed({ runOnUiThread { binding.etSearchSearchBar.apply { isFocusable = true isFocusableInTouchMode = true requestFocus() findFocus() } val inputManager = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager inputManager.showSoftInput( binding.etSearchSearchBar, InputMethodManager.SHOW_IMPLICIT ) }}, 300)","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8824%E6%97%A5/"},{"title":"实习笔记-10","text":"读取软件 声明权限123456789&lt;uses-permission android:name=&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot; /&gt;&lt;!-- 对于安卓11开始 --&gt;&lt;uses-permission android:name=&quot;android.permission.QUERY_ALL_PACKAGES&quot; tools:ignore=&quot;QueryAllPackagesPermission&quot; /&gt;&lt;queries&gt; &lt;intent&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;/intent&gt;&lt;/queries&gt; 12345val pm = context.applicationContext.packageManagerval installedApplications = pm.getInstalledApplications(0)installedApplications.forEach {info -&gt; //handle info} 该操作比较耗时,在新线程或协程job中执行 获取应用Label(应用名) , 应用图标和应用安装时间123info.loadIcon(pm)pm.getApplicationLabel(info)pm.getPackageInfo(name, 0).firstInstallTime 卸载软件 发送intent 1234val intent = Intent(Intent.ACTION_DELETE)intent.data = Uri.parse(&quot;package:$packageName&quot;)intent.putExtra(Intent.EXTRA_RETURN_RESULT, true)mStartActivity.launch(intent) 注册StartActivityForResult 123456private val mStartActivity = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { val adapter = binding.rvSearchResult.adapter as AppsAdapter adapter.deletionResult(it != null &amp;&amp; it.resultCode == Activity.RESULT_OK) } ActivityResultContract12345678910111213//第一步，注册交互数据回调监听val contact = registerForActivityResult(ActivityResultContracts.PickContact()) { uri : Uri? -&gt; //如果Uri为null，说明用户没有操作直接返回，这里代码会在下面补贴出来，因为涉及跨进程交互，代码比较长，不想贴这里影响阅读效率 ……}//第二步，intent，和原来一样xxx.setOnClickListener { val intent = Intent(Intent.ACTION_PICK) intent.addCategory(Intent.CATEGORY_DEFAULT) intent.setType(&quot;vnd.android.cursor.dir/phone_v2&quot;) contact.launch(intent)}","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8825%E6%97%A5/"},{"title":"实习笔记-11","text":"Intent Action相关chooser可自定义标题，弹出软件选择器 123456789Intent intent = new Intent();intent.setAction(Intent.ACTION_SEND);intent.setType(&quot;text/plain&quot;);Intent intent2 = new Intent();intent2.setAction(Intent.ACTION_CHOOSER);intent2.putExtra(Intent.EXTRA_TITLE, &quot;please selete a app&quot;);//extra intentintent2.putExtra(Intent.EXTRA_INTENT, intent);startActivity(intent2); 方便起见，可以使用 1Intent.createChooser(Intent,CharSequence) ACTION_CONFIGURATION_CHANGED设备的设置改变，orientation，locale等 Configuration1Configuration config = getResources().getConfiguration(); requestedOrientation更改此Activity的所需方向。如果 Activity 当前处于前台或以其他方式影响屏幕方向，则屏幕将立即更改（可能导致 Activity 重新启动）。否则，这将在下次Activity可见时使用。 12345678landscape：限制界面为横屏，旋转屏幕也不会改变当前状态。portrait：限制界面为竖屏，旋转屏幕也不会改变当前状态。sensor:根据传感器定位方向，旋转手机90度，180,270,360，界面都会发生变化。sensorLandscape：（横屏的旋转，不会出现竖屏的现象）根据传感器定位方向，旋转手机180度界面旋转。一般横屏游戏会是这个属性。sensorPortrait：（竖屏的旋转，不会出现横屏的现象）根据传感器定位方向，旋转手机180度界面会旋转。unspecified：由系统选择显示方向，不同的设备可能会有所不同。（旋转手机，界面会跟着旋转）user:用户当前的首选方向。nosensor：不由传感器确定方向。旋转设备的时候，界面不会跟着旋转。初始界面方向由系统提供。 SystemClock12345678910111、public static long currentThreadTimeMillis () 返在当前线程运行的毫秒数。2、public static long elapsedRealtime () 返回系统启动到现在的毫秒数，包含休眠时间。3、public static long elapsedRealtimeNanos () 返回系统启动到现在的纳秒数，包含休眠时间。4、public static boolean setCurrentTimeMillis (long millis) 设置当前的&quot;墙&quot;时间，要求调用进程有许可权限。返回是否成功。5、public static void sleep (long ms) 等待给定的时间。和Thread.sleep(millis)类似，但是它不会抛出InterruptedException异常。事件被推迟到下一个中断操作。该方法直到指定的时间过去才返回。6、public static long uptimeMillis () 返回系统启动到现在的毫秒数，不包含休眠时间。就是说统计系统启动到现在的非休眠期时间。 Java 的强引用、弱引用、软引用、虚引用 1、强引用（StrongReference） 强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。 当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。 2、软引用（SoftReference） 如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 内存不足时才回收 3、弱引用（WeakReference） 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。 只要被gc扫描到，无论是否缺内存都回收 4、虚引用（PhantomReference） “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。 虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8826%E6%97%A5/"},{"title":"实习笔记-12","text":"PendingIntent认识 PendIntent其实是Intent的封装 不是立刻执行某个行为，而是满足某些条件或触发某些事件后才执行指定的行为 我们的 Activity 如果设置了 exported = false，其他应用如果使用 Intent 就访问不到这个 Activity，但是使用 PendingIntent 是可以的。 即：PendingIntent将某个动作的触发时机交给其他应用；让那个应用代表自己去执行那个动作（权限都给他） 获取PendingIntent12345getActivity()getActivities()getBroadcast()getService()getForegroundService() 12345参数:Context - 上下文对象requestCode - 请求码Intent - 请求意图用以指明启动类及数据传递flags -关键标志位 flags FLAG_CANCEL_CURRENT 先将当前已有的PendingIntent取消，然后重新生成一个PendingIntent对象。 FLAG_NO_CREATE 如果当前系统中不存在相同的PendingIntent对象，系统将返回null，否则返回已有对象 FLAG_ONE_SHOT 该PendingIntent只作用一次。在该PendingIntent对象通过send()方法触发过后，PendingIntent将自动调用cancel()进行销毁，那么如果你再调用send()方法的话，系统将会返回一个SendIntentException。 FLAG_UPDATE_CURRENT 更新之前PendingIntent中的Intent对象数据，例如更新Intent中的Extras FLAG_IMMUTABLE 创建的PendingIntent是不可变的，使用send方法发送的附加Intent会被忽略 原理 A应用希望让B应用帮忙触发一个行为，这是跨应用的通信 需要 Android 系统作为中间人，这里的中间人就是 ActivityManager。 A应用创建建 PendingIntent，在创建 PendingIntent 的过程中，向 ActivityManager 注册了这个 PendingIntent，所以，即使A应用死了，当它再次苏醒时，只要提供相同的参数，还是可以获取到之前那个 PendingIntent 的。 当 A 将 PendingIntent 调用系统 API 比如 AlarmManager.set()，实际是将权限给了B应用，这时候， B应用可以根据参数信息，来从 ActivityManager 获取到 A 设置的 PendingIntent Canvas 相当于一个透明图层 每次调用canvas.drawXXXX系列函数来绘图，都会产生一个全新的Canvas画布。 如果在DrawXXX前，调用平移、旋转等函数来对Canvas进行了操作，那么这个操作是不可逆的！每次产生的画布最新位置都是这些操作后的位置。 在Canvas与屏幕合成时，超出屏幕范围的图像是不会显示出来的。 rotate函数 12345678910public class MyTextView extends TextView { public MyTextView(Context context, AttributeSet attrs) { super(context, attrs); } @Override protected void onDraw(Canvas canvas) { canvas.rotate(-90); super.onDraw(canvas); } } translate函数123void translate(float dx, float dy)// float dx：水平方向平移的距离，正数指向正方向（向右）平移的量，负数为向负方向（向左）平移的量// float dy: 垂直方向平移的距离，正数指向正方向 (向下) 平移量，负数为向负方向 (向上) 平移量 扭曲（skew）其实我觉得译成斜切更合适，在PS中的这个功能就差不多叫斜切。但这里还是直译吧，大家都是这个名字。看下它的构造函数： 123void skew (float sx, float sy)//float sx:将画布在x方向上倾斜相应的角度，sx倾斜角度的tan值//float sy:将画布在y轴方向上倾斜相应的角度，sy为倾斜角度的tan值 save restore每次save，将当前画布状态保存到一个状态栈中，restore从栈顶取出一个状态恢复到画布上 SDCard123456Environment.MEDIA_UNMOUNTED // 用户手工到手机设置中卸载sd卡之后的状态 Environment.MEDIA_REMOVED // 用户手动卸载，然后将sd卡从手机取出之后的状态 Environment.MEDIA_BAD_REMOVAL // 用户未到手机设置中手动卸载sd卡，直接拨出之后的状态 Environment.MEDIA_SHARED // 手机直接连接到电脑作为u盘使用之后的状态 Environment.MEDIA_CHECKINGS // 手机正在扫描sd卡过程中的状态 Environment.MEDIA_MOUNTED //挂载到挂载点上且有读写权限","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8827%E6%97%A5/"},{"title":"实习笔记-18","text":"协调问题 需要SceneEvent的Observer（√） 跳转问题（√）： battery错误跳转到boost，boost错误跳转到boost MainPageActivity在任务栈中时，点击通知按钮不跳转到功能页面，没有处理onNewIntent 在什么位置startService（√） startActivity的过程 如果intent指明了Component，直接通过component找到ActivityInfo，否则 如果Intent指定了组件所在包名，通过包名获取ActivityInfo，否则 通过ActivityIntentResolver等类的queryIntentForPackage进行模糊匹配，如Action，Category","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%8814%E6%97%A5/"},{"title":"实习笔记-19","text":"SlidingPaneLayoutwindowSizeClass – 屏幕布局决策ActivityEmbeddingNavigationRailBox With Constraints – 不同展示内容决策Custom Layout – 不同方式布局Scaffold","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%8815%E6%97%A5/"},{"title":"实习笔记-21","text":"协程取消问题可以自动取消的lifecycleScope","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%8817%E6%97%A5/"},{"title":"实习笔记-17","text":"协调问题 outsideLauncher 安卓中的单例模式 LayoutInflator也是一个SystemService SYSTEM_SERVICE_FETCHERS是一个hashMap，保存ServiceName-&gt;ServiceFetcher的单例 ServiceFetctor是一个接口，定义了 T getService(ContextImpl ctx); 安卓中的Builder模式 隔离getter，setter，在对象生成时对成员变量配置，生成后屏蔽 dialog","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%8811%E6%97%A5/"},{"title":"实习笔记-20","text":"App真正的入口ActivityThread 中的main方法，一个应用程序对应一个ActivityThread对象，Zygote孵化出一个进程后，就会执行main方法 准备Looper和消息队列 thread.attach()方法绑定到ActivityManagerService中 attach方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283private void attach(boolean system, long startSeq) { sCurrentActivityThread = this; mConfigurationController = new ConfigurationController(this); mSystemThread = system; if (!system) { android.ddm.DdmHandleAppName.setAppName(&quot;&lt;pre-initialized&gt;&quot;, UserHandle.myUserId()); RuntimeInit.setApplicationObject(mAppThread.asBinder()); final IActivityManager mgr = ActivityManager.getService(); try { mgr.attachApplication(mAppThread, startSeq); // } catch (RemoteException ex) { throw ex.rethrowFromSystemServer(); } // Watch for getting close to heap limit. BinderInternal.addGcWatcher(new Runnable() { @Override public void run() { if (!mSomeActivitiesChanged) { return; } Runtime runtime = Runtime.getRuntime(); long dalvikMax = runtime.maxMemory(); long dalvikUsed = runtime.totalMemory() - runtime.freeMemory(); if (dalvikUsed &gt; ((3*dalvikMax)/4)) { if (DEBUG_MEMORY_TRIM) Slog.d(TAG, &quot;Dalvik max=&quot; + (dalvikMax/1024) + &quot; total=&quot; + (runtime.totalMemory()/1024) + &quot; used=&quot; + (dalvikUsed/1024)); mSomeActivitiesChanged = false; try { ActivityTaskManager.getService().releaseSomeActivities(mAppThread); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } } }); } else { // Don't set application object here -- if the system crashes, // we can't display an alert, we just want to die die die. android.ddm.DdmHandleAppName.setAppName(&quot;system_process&quot;, UserHandle.myUserId()); try { mInstrumentation = new Instrumentation(); mInstrumentation.basicInit(this); ContextImpl context = ContextImpl.createAppContext( this, getSystemContext().mPackageInfo); mInitialApplication = context.mPackageInfo.makeApplication(true, null); mInitialApplication.onCreate(); } catch (Exception e) { throw new RuntimeException( &quot;Unable to instantiate Application():&quot; + e.toString(), e); } } ViewRootImpl.ConfigChangedCallback configChangedCallback = (Configuration globalConfig) -&gt; { synchronized (mResourcesManager) { // TODO (b/135719017): Temporary log for debugging IME service. if (Build.IS_DEBUGGABLE &amp;&amp; mHasImeComponent) { Log.d(TAG, &quot;ViewRootImpl.ConfigChangedCallback for IME, &quot; + &quot;config=&quot; + globalConfig); } // We need to apply this change to the resources immediately, because upon returning // the view hierarchy will be informed about it. if (mResourcesManager.applyConfigurationToResources(globalConfig, null /* compat */, mInitialApplication.getResources().getDisplayAdjustments())) { mConfigurationController.updateLocaleListFromAppContext( mInitialApplication.getApplicationContext()); // This actually changed the resources! Tell everyone about it. final Configuration updatedConfig = mConfigurationController.updatePendingConfiguration(globalConfig); if (updatedConfig != null) { sendMessage(H.CONFIGURATION_CHANGED, globalConfig); mPendingConfiguration = updatedConfig; } } } }; ViewRootImpl.addConfigCallback(configChangedCallback);}","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%8816%E6%97%A5/"},{"title":"实习笔记-22","text":"LiveData, MutableLiveData防止暴露子类某些方法12val name: LiveData&lt;NameBean&gt; get() = _nameprivate val _name = MutableLiveData&lt;NameBean&gt;() 界面性能优化ViewStub根据条件判断某些控件显示，某些不显示时，可以使用ViewStub来减少不必要的实例化开销。 android.view.ViewStub，ViewStub 是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有 ViewStub会被初始化，然后当ViewStub被设置为可见的时候，或是调用了ViewStub.inflate()的时候。 ViewStub的局限性 ViewStub只能Inflate一次，之后ViewStub对象会被置为空。按句话说，某个被ViewStub指定的布局被Inflate后，就不会够再通过ViewStub来控制它了。 ViewStub只能用来Inflate一个布局文件，而不是某个具体的View，当然也可以把View写在某个布局文件中。 基于以上的特点，那么可以考虑使用ViewStub的情况有： 在程序的运行期间，某个布局在Inflate后，就不会有变化，除非重新启动。 因为ViewStub只能Inflate一次，之后会被置空，所以无法指望后面接着使用ViewStub来控制布局。所以当需要在运行时不止一次的显示和隐藏某个布局，那么ViewStub是做不到的。这时就只能使用View的可见性来控制了。 想要控制显示与隐藏的是一个布局文件，而非某个View。 因为设置给ViewStub的只能是某个布局文件的Id，所以无法让它来控制某个View。 所以，如果想要控制某个View(如Button或TextView)的显示与隐藏，或者想要在运行时不断的显示与隐藏某个布局或View，只能使用View的可见性来控制。 startService","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%8818%E6%97%A5/"},{"title":"实习笔记-15","text":"gradle全局配置配置GRADLE_USER_HOME环境变量","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%888%E6%97%A5/"},{"title":"实习笔记-23","text":"MutableLiveData踩坑使用MutableLiveData的observer对数据进行观察，跳转界面返回后删除list中的元素，出现CurrentModificationException改用Vector等线程安全的集合 BinderBinder 与其他IPC的比较 binder 共享内存 Socket 拷贝一次 0 1 C/S模式，易用性高 控制负载，易用性差 C/S开销大 为每个App分配UID 访问接入点是开放的，不安全 访问接入点是开放的，不安全 共享内存 两个mmap，Binder一个mmap AIDLbindService到onConnection之间 asInterface会获得Proxy，调用代理对象的方法会调用mRemote.transact,传递调用的方法的编码，并挂起当前进程 能够启动服务所在进程和服务","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%8822%E6%97%A5/"},{"title":"实习笔记-13","text":"为什么用SurfaceView不用自定义组件 小组件在布局上的局限性 只支持原生控件，且不支持他们的后代 难以动态更新动画1234567891011121314151617FrameLayoutLinearLayoutRelativeLayoutGridLayoutAnalogClockButtonChronometerImageButtonImageViewProgressBarTextViewViewFlipperListViewGridViewStackViewAdapterViewFlipper 只能显示在某一屏 优化空间 壁纸的操作和部分launcher的操作冲突 只能在右侧，对左撇子不友好 两个wallpaper的drawFrame方法相似，可以进一步抽象","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%882%E6%97%A5/"},{"title":"实习笔记-14","text":"更新桌面小组件 Handler更新：只能坚持几秒钟 Service发送广播更新 Service的context从onReceive获取，一切正常。会存在保活的问题，至少30分钟系统才调用onUpdate一次 使用lateinit保存onUpdate的context，会报错lateinit property mContext has not been initialized onUpdate暴力递归 点击后无法更新","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%887%E6%97%A5/"},{"title":"实习笔记-16","text":"Android View绘制流程performTraversals()获取Surface对象，performMeasure-丈量View树的各个view的大小，performLayout-对整个视图树进行布局，performDraw，对视图树进行绘制源码解析 第一阶段，确定activity的宽高123456789if(Activity窗口是第一次被请求执行测量、布局和绘制操作){ if(如果窗口的类型是有状态栏的){ Activity窗口所需要的宽度和高度就是除了状态栏; }else{ Activity窗口所需要的宽度和高度就是整个屏幕的宽高; }}else{ Activity窗口的宽高为frame成员变量中的保存的上一次测量、布局和绘制时的值;} 排序中文按照拼音排序 1234567list.sortBy { try { URLEncoder.encode(it.label.lowercase(), &quot;GBK&quot;) } catch (e:Exception) { &quot;&quot; }} 123Comparator cmp = Collator.getInstance(java.util.Locale.CHINA);cmp.compare(s1,s2);Arrays.sort(arr, cmp); VectorDrawablemerge标签将merge下的所有view直接添加到根标签下","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%889%E6%97%A5/"},{"title":"Kotlin学习笔记——Activity活动跳转","text":"传送配对字段数据打开一个新页面1startActivity&lt;secondActivity&gt;() 注意 这个函数需要anko库的支持 打开页面并向新页面传递参数使用关键字to1234startActivity&lt;secondActivity&gt;( &quot;start_time&quot; to currentTime.toString(), &quot;message&quot; to &quot;good Morning&quot; ) 使用Pair类1234startActivity&lt;secondActivity&gt; ( Pair(&quot;start_time&quot;, currentTime.toString(), Pair(&quot;message&quot;, &quot;good Morning&quot;)) 在新页面中获取参数123val bundle = intent.extrasval start_time = bundle.getString(&quot;start_time&quot;)val message = bundle.getString(&quot;message&quot;) 补充1. intent参考：Android组件系列—-Intent详解 Intent的概念：Android中提供了Intent机制来协助应用间的交互与通讯，或者采用更准确的说法是，Intent不仅可用于应用程序之间，也可用于应用程序内部的activity, service和broadcast receiver之间的交互。Intent这个英语单词的本意是“目的、意向、意图”。 Intent是一种运行时绑定（runtime binding)机制，它能在程序运行的过程中连接两个不同的组件。通过Intent，你的程序可以向Android表达某种请求或者意愿，Android会根据意愿的内容选择适当的组件来响应。 activity、service和broadcast receiver之间是通过Intent进行通信的，而另外一个组件Content Provider本身就是一种通信机制，不需要通过Intent。我们来看下面这个图就知道了： 如果Activity1需要和Activity2进行联系，二者不需要直接联系，而是通过Intent作为桥梁。通俗来讲，Intnet类似于中介、媒婆的角色。 2. bundle参考Android中Bundle类的作用 Android中Bundle类的作用 Bundle类用作携带数据，它类似于Map，用于存放key-value名值对形式的值 根据google官方的文档（http://developer.android.com/reference/android/os/Bundle.html） Bundle类是一个key-value对，“A mapping from String values to various Parcelable types.” 传送序列化数据12@Parcelizedata class MessageInfo(val content: String, val send_time: String) : Parcelable {} 注意 注解@Parcelize不是没有用的，它可以告诉编译器，让编译器自动实现writeToParcel、createFromParcel、newArray、describeContents四个方法 要在build.gradle的文件末尾添加如下几行123androidExtensions { experimental = true} 这样以后，就可以在页面之间传递活动跳转的序列化数据了12val request = MessageInfo(&quot;你好你好！&quot;, currentTime.toString())startActivity&lt;secondActivity&gt;(&quot;message&quot; to request) 在跳转后的页面获取数据1val request = intent.extras.getParcelabel&lt;MessageInfo&gt;(&quot;message)//获得数据 跳转时指定启动模式 启动标志 对应anko库函数 说明 备注 Intent.FLAG_ACTIVITY_NEW_TAST intent.newTask() 开启一个新任务。这个值类似于launchMode=”standard”，不同之处在于，如果原来不存在活动栈，这个标志就会创建一个新栈 Intent.FLAG_ACTIVITY_SINGLE_TOP intent.singleTop() 当栈顶为待跳转的activity实例时，重用栈顶的实例，该值等同于launchMode=”singleTop” Intent.FLAG_ACTIVITY_CLEAR_TOP intent.clrarTop() 当栈中存在待跳转的activity实例时，重新创建一个新实例，并将原实例上方所有实例清除。该值与launchMode=”singleTask”相似，但是launchMode=”singleTask”采用onNewInten启用原任务，而这个标志先onDestroy再onCreate创建新任务 Intent.FLAG_ACTIVITY_NO_HISTORY intent.noHistory() 这个标志与launchMode=”standard”相似，但栈中不保存新启动的activity实例。下次无论使用哪种方法再启动该实例，都要走完standard的完整流程 Intent.FLAG_ACTIVITY_CLEAR_TAST intent.clearTask() 这个标志非常暴力，跳转到新页面时，栈中原有实例都被清空。这个flag要结合newTask使用 处理返回数据当从一个页面跳转回原来的页面时，有可能要向上一个activity返回一些数据 第一个页面打开第二个页面时，改用startActivityForResult12val info = MessageInfo(&quot;去吧！去吧！&quot;, currentTime.toString())startActivityForResult&lt;secondActivity&gt;(0, &quot;go！go！go！&quot; to info)//传递给第二个页面的数据 第二个页面退出时，添加传送数据123456val info = MessageInfo(&quot;回来了！回来了！&quot;, currentTime.toString())//返回给第一个页面的数据//MessageInfo类是之前写的继承Parcelable 的 data classval intent = Intent()intent.putExtra(&quot;back&quot;, info)setResult(Activity.RESULT_OK, intent)finish() 上一个页面接受返回值123456override fun onActivityResult(RequestCode:Int, resultCode:Int, data:Intent?) { if (data != null) { val response = data.extras.getParcelable&lt;MessageInfo&gt;(&quot;back&quot;) //获取了MessageInfo类的对象 }} onRestart()函数参考： Activity的onRestart()方法调用时机 两分钟彻底让你明白Android Activity生命周期(图文)! https://blog.csdn.net/liuhe688/article/details/6733407 调用时机 按下home键之后，然后切换回来，会调用onRestart()。 从本Activity跳转到另一个Activity之后，按back键返回原来Activity，会调用onRestart(); 从本Activity切换到其他的应用，然后再从其他应用切换回来，会调用onRestart(); 应用场景在登录页面上，用户忘记密码，点击”忘记密码”并跳转到相应页面，当返回登录页面时，最好自动清空原来的密码，如果这个操作写在onActivityResult上，那么当用户打开”找回密码”页面，不属于调用onActivityResult的时机 实例1234override fun onRestart() { //do what u wanna do super.onRestart()}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Activity%E6%B4%BB%E5%8A%A8%E8%B7%B3%E8%BD%AC/"},{"title":"Kotlin学习笔记——BroadCast","text":"1#define 小毛驴 xml 收发广播使用场景：Fragment想要向外传递信息 在Fragment中发送广播1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class BlankFragment : Fragment() { var ctx:Context? = null var mPosition:Int = 0 var mInageId:Int = 0 var mDesc:String = &quot;&quot; var title:String = &quot;&quot; val colorNames = listOf&lt;String&gt;(&quot;红色&quot;,&quot;黄色&quot;,&quot;绿色&quot;,&quot;青色&quot;,&quot;蓝色&quot;) val colors = intArrayOf(Color.RED, Color.YELLOW, Color.GREEN, Color.CYAN, Color.BLUE) var mSeq:Int = 0 override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { ctx = activity if (arguments != null) { mPosition = arguments!!.getInt(&quot;position&quot;, 0) mInageId = arguments!!.getInt(&quot;image_id&quot;, 0) mDesc = arguments!!.getString(&quot;desc&quot;) title = arguments!!.getString(&quot;title&quot;) } val view = inflater.inflate(R.layout.show_info, container, false) view.findViewById&lt;ImageView&gt;(R.id.imageView).setImageResource(mInageId) view.findViewById&lt;TextView&gt;(R.id.textView).text = mDesc view.findViewById&lt;Button&gt;(R.id.se).setOnClickListener { ctx!!.selector(&quot;选择颜色&quot;, colorNames) { mSeq = it val intent = Intent(BlankFragment.EVENT) intent.putExtra(&quot;seq&quot;, it) intent.putExtra(&quot;color&quot;, colors[it]) ctx!!.sendBroadcast(intent)//发送广播 } } return view } companion object { const val EVENT:String = &quot;changeColor&quot;//const，编译期常量 fun newInstance(position:Int, image_id:Int, desc:String, title:String) : BlankFragment { val fragment = BlankFragment() val bundle = Bundle() bundle.putInt(&quot;position&quot;, position) bundle.putInt(&quot;image_id&quot;, image_id) bundle.putString(&quot;desc&quot;, desc) bundle.putString(&quot;title&quot;, title) fragment.arguments = bundle return fragment } }} 在要接收广播的页面注册receiver1234567891011121314151617181920212223242526272829303132333435363738394041class MainActivity : FragmentActivity(){ private var BGChangeRecever:myBgChangeRecever? = null override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) var vp:ViewPager = findViewById(R.id.vp) var title: PagerTabStrip = findViewById(R.id.title) val pics = arrayOf(R.mipmap.basic, R.mipmap.close, R.mipmap.debug, R.mipmap.edit) val list:MutableList&lt;itemInfo&gt; = mutableListOf() for (i in pics.indices) { list.add(itemInfo((i+1).toString(), pics[i], ((i+1)*(i+1)).toString())) } vp.adapter = infoPagerAdapter(supportFragmentManager, list) vp.currentItem = 0 } public override fun onStart() { super.onStart() BGChangeRecever = myBgChangeRecever() val filiter = IntentFilter(BlankFragment.EVENT)//广播过滤器，过滤掉参数以外的广播 registerReceiver(BGChangeRecever,filiter)//开始时注册接收器 } public override fun onStop() { unregisterReceiver(BGChangeRecever)//结束前注销接收器 super.onStop() } private inner class myBgChangeRecever : BroadcastReceiver() {//广播接收器 override fun onReceive(context: Context?, intent: Intent?) {//接收广播后执行的操作 if (intent != null) { val color = intent.getIntExtra(&quot;color&quot;, Color.GREEN) textView2.setTextColor(color) } } }} 接收系统广播静态注册没学会 动态注册1234567891011121314151617181920212223242526272829303132333435363738394041424344class MainActivity : AppCompatActivity() { var receiver:broadCastRecever = broadCastRecever() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) } override fun onDestroy() { super.onDestroy() receiver.unRegiste() } override fun onStart() { super.onStart() receiver.registe(this) } inner class broadCastRecever : BroadcastReceiver() { private var isRegisted = false var allBroadCast = arrayOf(Intent.ACTION_TIME_TICK, Intent.ACTION_SCREEN_ON, Intent.ACTION_SCREEN_OFF) var registTo:Context? = null override fun onReceive(context: Context?, intent: Intent?) { text.append(&quot;收到：${(intent?.action?:&quot;empty&quot;)}\\n&quot;) } fun registe(context: Context) { if (!isRegisted) { var filter:IntentFilter = IntentFilter() for (item in allBroadCast) { filter.addAction(item) } context.registerReceiver(this@broadCastRecever, filter) isRegisted = true registTo = context } } fun unRegiste() { if (isRegisted) { registTo?.unregisterReceiver(this@broadCastRecever) isRegisted = false } } }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94BroadCast/"},{"title":"Kotlin学习笔记——Button","text":"实现短按长按的方法调用函数 方法 参数 参数解释 返回值 备注 setOnClickListener lambda表达式 lambda的参数为发生点击动作的View，返回值Unit Unit 相当于override fun onClickListener(v:View) setOnLongClickListener lambda表达式 lambda的参数为发生点击动作的View，返回值Boolean(true表示这个事件已经消耗完了，false表示事件继续传递，会触发一次短按事件) Unit 相当于override fun onLongClick(v:View):Boolean 例子1234567btn.setOnClickListener { toast(&quot;click&quot;)}btn.setOnLongClickListener { toast(&quot;Long Click&quot;) true} 使用内部类例子12345678910//在Activity类里面/*inner 关键字，访问外部类的数据继承View.onClickListener*/private inner class MyClickListener : View.onClickListener { override fun onClick(v:View) { toast.(&quot;您点击了：${(v as Button).text}&quot;) }} 实现接口让当前Activity实现OnClickListener和OnLongClickListener两个接口 例子12345678910111213141516171819class MainActivity : AppCompatActivity() , OnClickListener, OnLongClickListener { override fun onClick(v: View?) { var text:TextView = findViewById(R.id.text) text.append(&quot;hello world\\n&quot;) } override fun onLongClick(v: View?): Boolean { toast(&quot;哎呀，一直按着人家干什么啦~~&quot;) return true } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) var start:FloatingActionButton = findViewById(R.id.start) start.setOnLongClickListener(this) start.setOnClickListener(this) }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Button/"},{"title":"Kotlin学习笔记——Fragment","text":"1#define 小毛驴 xml 使用方法Fragment与ViewPager搭配，实现翻页，实现每页多个控件 写好每个item的小毛驴文件和数据传送类 继承Fragment类，自定义一个fragment12345678910111213141516171819202122232425262728293031323334353637383940class BlankFragment : Fragment() { var ctx:Context? = null var mPosition:Int = 0 var mInageId:Int = 0 var mDesc:String = &quot;&quot; var title:String = &quot;&quot; val colorNames = listOf&lt;String&gt;(&quot;红色&quot;,&quot;黄色&quot;,&quot;绿色&quot;,&quot;青色&quot;,&quot;蓝色&quot;) val colors = intArrayOf(Color.RED, Color.YELLOW, Color.GREEN, Color.CYAN, Color.BLUE) var mSeq:Int = 0 override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { ctx = activity if (arguments != null) { mPosition = arguments!!.getInt(&quot;position&quot;, 0) mInageId = arguments!!.getInt(&quot;image_id&quot;, 0) mDesc = arguments!!.getString(&quot;desc&quot;) title = arguments!!.getString(&quot;title&quot;) }//获取数据 val view = inflater.inflate(R.layout.show_info, container, false) view.findViewById&lt;ImageView&gt;(R.id.imageView).setImageResource(mInageId) view.findViewById&lt;TextView&gt;(R.id.textView).text = mDesc //显示数据 return view } companion object { fun newInstance(position:Int, image_id:Int, desc:String, title:String) : BlankFragment {//调用这个函数，创建新的fragment val fragment = BlankFragment() val bundle = Bundle() bundle.putInt(&quot;position&quot;, position) bundle.putInt(&quot;image_id&quot;, image_id) bundle.putString(&quot;desc&quot;, desc) bundle.putString(&quot;title&quot;, title) fragment.arguments = bundle return fragment } }} ViewPager的适配器1234567891011class infoPagerAdapter(val fragManger: FragmentManager, val itemList:MutableList&lt;itemInfo&gt;) : FragmentStatePagerAdapter(fragManger) { override fun getCount(): Int = itemList.size override fun getItem(p0: Int): Fragment { val item = itemList[p0] return BlankFragment.newInstance(p0, item.pic, item.desc, item.name) } override fun getPageTitle(position: Int): CharSequence? { return itemList[position].name }} 4.给ViewPager添加适配器12345678910111213class MainActivity : FragmentActivity(){//这个时候，继承的是FragmentActivity override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) var vp:ViewPager = findViewById(R.id.vp) var title: PagerTabStrip = findViewById(R.id.title) val list:MutableList&lt;itemInfo&gt; = mutableListOf() //省略中间给list赋值的过程 vp.adapter = infoPagerAdapter(supportFragmentManager, list) vp.currentItem = 0 }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Fragment/"},{"title":"Kotlin学习笔记——EditText","text":"输入监听器方便起见，在activity的内部写一个内部类，用来监听输入 编写监听器1234567891011inner class EditWatcher : TextWatcher { override fun afterTextChanged(s:Editable) { } override fun beforeTextChanged(s:CharSequence, start:Int, count:Int, after:Int) { } override fun onTextChanged(s:CharSequence, start:Int, count:Int, after:Int) { }} 注意 把Editable直接toString()就是用户当前的输入 使用监听器1et.addTextChangedListener(EditWatcher()) 效果1. 自动隐藏输入法面板12345678910111213141516171819202122232425private inner class EditWatcher(val type:String, val len:Int, val edit:EditText) : TextWatcher { override fun afterTextChanged(s:Editable) { var str:String = s.toString() if (str.indexOf(&quot;\\n&quot;) &gt;= 0 || str.indexOf(&quot;\\r&quot;) &gt;= 0 || str.indexOf(&quot; &quot;) &gt;= 0) { str = str.replace(&quot;\\r&quot;, &quot;&quot;).replace(&quot;\\n&quot;, &quot;&quot;).replace(&quot; &quot;, &quot;&quot;) } if (str.length &gt; len) { toast(&quot;${type}最长${len}位！&quot;) edit.setText(str.substring(0, len)) //大于len的时候再截取子串 val imm = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager //软键盘如果已经打开则关闭之 if (imm.isActive) { imm.toggleSoftInput(0, InputMethodManager.HIDE_NOT_ALWAYS) } } } override fun beforeTextChanged(s:CharSequence, start:Int, count:Int, after:Int) { } override fun onTextChanged(s:CharSequence, start:Int, count:Int, after:Int) { }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94EditText/"},{"title":"Kotlin学习笔记——GridView","text":"Kotlin学习笔记——GridView1#define 小毛驴 xml 使用方法 设计好界面 新建一个小毛驴文件，这个小毛驴文件是GridView中，每一个Item的界面布局文件 （可选）编写一个数据类，用来保存每个item中的数据，用data class可以很方便 编写一个继承BaseAdapter适配器的类123456789101112131415161718192021222324252627282930313233343536class GridAdapter(private val context: Context, private val strList:MutableList&lt;myItems&gt;, private val background:Int) : BaseAdapter() { override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View { var view = convertView val holder:ViewHolder if (convertView == null) { view = LayoutInflater.from(context).inflate(R.layout.item, null) //我猜这个函数的作用是指定这个类所对应的小毛驴文件 holder = ViewHolder() holder.myLayout = view.findViewById&lt;LinearLayout&gt;(R.id.all) holder.desc = view.findViewById&lt;TextView&gt;(R.id.textView) holder.pic = view.findViewById&lt;ImageView&gt;(R.id.imageView) view.tag = holder } else { holder = (view?.tag) as ViewHolder } //以上是固定格式 val myItem = strList[position] //传进来的数据数组，适配器根据数组大小反复调用这个函数构造ViewList //position是当前位置，对应数组下标 //holder.myLayout.setBackgroundColor(background) holder.desc.text = myItem.desc holder.pic.setImageResource(myItem.image) //以上是自定义每个控件的显示内容 return view!! } override fun getItem(position: Int): Any = strList[position] override fun getItemId(position: Int): Long = position.toLong() override fun getCount(): Int = strList.size inner class ViewHolder { lateinit var myLayout:LinearLayout lateinit var desc: TextView lateinit var pic: ImageView }} 如果编写了数据类（起了一个c++中结构体的作用，因为数组只能传递一个），创建对应的List并且赋值 给GridView添加适配器123456789var grid:GridView = findViewById(R.id.panel)var pics = arrayOf(R.mipmap.a, R.mipmap.b, R.mipmap.c, R.mipmap.d, R.mipmap.e, R.mipmap.f, R.mipmap.g, R.mipmap.h)var descs = arrayOf(&quot;超级大帅哥刘甜甜&quot;, &quot;刘甜甜最喜欢的大明星周周&quot;, &quot;刘甜甜最喜欢的性感裸男&quot;, &quot;刘甜甜最想养的橘猫&quot;, &quot;还是超级大帅哥刘甜甜&quot;, &quot;刘甜甜最喜欢的动画人物米奇&quot;, &quot;还是刘甜甜最喜欢的动画人物米奇&quot;, &quot;用来凑数的发际线哥&quot;)var data:MutableList&lt;myItems&gt; = mutableListOf()for (i in pics.indices) { data.add(myItems(descs[i], pics[i]))}grid.adapter = GridAdapter(this, data, Color.GRAY)grid.numColumns = 2//设置列数","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94GridView/"},{"title":"Kotlin学习笔记——ListView","text":"1#define 小毛驴 xml 使用方法 设计好界面 新建一个小毛驴文件，这个小毛驴文件是ListView中，每一个Item的界面布局文件 （可选）编写一个数据类，用来保存每个item中的数据，用data class可以很方便 编写一个继承BaseAdapter适配器的类123456789101112131415161718192021222324252627282930313233343536373839class ListViewAdapter(private val context: Context, private val strList:MutableList&lt;myItems&gt;, private val background:Int) : BaseAdapter() { override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View { var view = convertView val holder:ViewHolder if (convertView == null) { view = LayoutInflater.from(context).inflate(R.layout.item, null) //我猜这个函数的作用是指定这个类所对应的小毛驴文件 holder = ViewHolder() holder.ll_item = view.findViewById&lt;LinearLayout&gt;(R.id.ll_item) holder.iv_icon = view.findViewById&lt;ImageView&gt;(R.id.iv_icon) holder.tv_name = view.findViewById&lt;TextView&gt;(R.id.tv_name) holder.tv_desc = view.findViewById&lt;TextView&gt;(R.id.tv_desc) view.tag = holder } else { holder = (view?.tag) as ViewHolder } //以上是固定格式 val myItem = strList[position] //传进来的数据数组，适配器根据数组大小反复调用这个函数构造ViewList //position是当前位置，对应数组下标 holder.ll_item.setBackgroundColor(background) holder.iv_icon.setImageResource(myItem.image) holder.tv_name.text = myItem.name holder.tv_desc.text = myItem.desc //以上是自定义每个控件的显示内容，根据之前传进来的List里面的数据 return view!! } override fun getItem(position: Int): Any = strList[position] override fun getItemId(position: Int): Long = position.toLong() override fun getCount(): Int = strList.size inner class ViewHolder { lateinit var ll_item:LinearLayout lateinit var iv_icon:ImageView lateinit var tv_name:TextView lateinit var tv_desc:TextView }} 如果编写了数据类（起了一个c++中结构体的作用，因为数组只能传递一个），创建对应的List并且赋值 给ListView添加适配器1234567891011121314var item:MutableList&lt;myItems&gt; = mutableListOf()val imageIds = arrayOf(R.mipmap.a, R.mipmap.b, R.mipmap.c, R.mipmap.d, R.mipmap.e)var name = arrayOf(&quot;超级大帅哥刘甜甜&quot;, &quot;还是超级大帅哥刘甜甜&quot;, &quot;可爱的橘猫&quot;, &quot;性感裸男&quot;,&quot;周周&quot;)var desc = arrayOf(&quot;是他是他就是他，我们的大帅哥，刘天天&quot;, &quot;是他是他还是他，我们的大帅哥，刘天天&quot;, &quot;刘天天最想养的橘猫&quot;, &quot;刘天天最喜欢的性感裸男&quot;,&quot;刘天天最喜欢的大明星周周&quot;)//各种数据setContentView(R.layout.activity_clickhere)for (i in imageIds.indices) { item.add(myItems(name[i], desc[i], imageIds[i]))}//初始化要传递的Listvar list:ListView = findViewById&lt;ListView&gt;(R.id.list)list.adapter = ListViewAdapter(this,item ,Color.WHITE)//你刚才自己写的适配器类//为ListView添加适配器","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94ListView/"},{"title":"Kotlin学习笔记——RadioButton和RadioGroup","text":"RadioButton的使用拖拽出RadioButton，和RadioGroup，把RadioButton拖到RadioGroup的子部件下 RadioGroup的使用 方法 使用 备注 android:orientation 设置RadioGroup中RadioButton的排列方式 “vertical”为垂直，”horizontal”为水平 setOnCheckedChangeListener 设置选择改变时的操作 无 特定效果RadioButton多行多列显示解决方案1多个ButtonGroup，当一个group的按钮被选择后，清除其他按钮的选择 解决方案2重写 RadioGroup 的 onMeasure、onLayout 实现 RadioButton 多行多列排列参考教程（来自csdn）图片编辑器–重写 RadioGroup 的 onMeasure、onLayout 实现 RadioButton 多行多列排列","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RadioButton%E5%92%8CRadioGroup/"},{"title":"Kotlin学习笔记——RecyclerView","text":"1#define 小毛驴 xml 布局管理器LinearLayoutManager类似于线性布局 构造 (Context context) (Context context,int orientation,boolean reverseLayout) (Context context, AttributeSet attrs, int defStyleAttr,int defStyleRes) 参数 解释 Context context 上下文，初始化时，构造方法内部加载资源用 int orientation 方向，垂直和水平，默认为垂直 boolean reverseLayout 是否倒序，设置为True，从最后一个item开始，倒序加载。此时，RecyclerView第一个item是添加进Adapter中的最后一个，最后一个item是第一个加进Adapter的数据,RecyclerView会自动滑到末尾 参考英勇青铜5 GridLayoutManager类似GridView 构造 解释 (Context context, int spanCount) spanCount为列数 (Context context, int spanCount, int orientation,boolean reverseLayout) orientation在GridLayoutManager中有静态常量 StaggeredGridLayoutManager瀑布流 构造 解释 (int spanCount, int orientation) 显然法 使用方法 写一个基础适配器1234567891011121314151617181920212223242526272829303132//abstract抽象类作为基类abstract class RecyclerBaseAdapter&lt;VH: RecyclerView.ViewHolder&gt;(val context:Context) : RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;(), AdapterView.OnItemClickListener, AdapterView.OnItemLongClickListener { //与小毛驴文件绑定 val inflater:LayoutInflater = LayoutInflater.from(context) override abstract fun getItemCount(): Int override abstract fun onCreateViewHolder(p0: ViewGroup, p1: Int): RecyclerView.ViewHolder override fun getItemViewType(position: Int): Int = 0 override fun getItemId(position: Int): Long = position.toLong() var itemClickListener:AdapterView.OnItemClickListener? = null fun setOnItemClickListener(listener:AdapterView.OnItemClickListener) { this.itemClickListener = listener } var itemLongClickListener: AdapterView.OnItemLongClickListener? = null fun setOnItemLongClickLostenner(listener: AdapterView.OnItemLongClickListener) { this.itemLongClickListener = listener } override fun onItemClick(parent: AdapterView&lt;*&gt;?, view: View?, position: Int, id: Long) { } override fun onItemLongClick(parent: AdapterView&lt;*&gt;?, view: View?, position: Int, id: Long): Boolean { return true }} 设计好item的小毛驴文件，写好传送数据的类 完成业务逻辑的适配器1234567891011121314151617181920212223class RecyclerGridAdapter(context:Context, private val infos:MutableList&lt;RecyclerInfo&gt;) : RecyclerBaseAdapter&lt;RecyclerView.ViewHolder&gt;(context) { //继承刚才的基础类 override fun getItemCount(): Int = infos.size override fun onCreateViewHolder(p0: ViewGroup, p1: Int): RecyclerView.ViewHolder { val view: View = inflater.inflate(R.layout.layout ,p0, false) return ItemHoder(view) } override fun onBindViewHolder(p0: RecyclerView.ViewHolder, p1: Int) { val vh = p0 as ItemHoder vh.pic.setImageResource(infos[p1].pic) vh.text.text = infos[p1].text } inner class ItemHoder(view:View): RecyclerView.ViewHolder(view) { val ll = view.findViewById&lt;ConstraintLayout&gt;(R.id.ll) var pic = view.findViewById&lt;ImageView&gt;(R.id.pic) var text = view.findViewById&lt;TextView&gt;(R.id.text) }} 为RecyclerView添加布局管理器和适配器12345678910111213141516171819202122232425262728293031323334353637class MainActivity : AppCompatActivity() { var l:RecyclerView? = null override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) var data:MutableList&lt;RecyclerInfo&gt; = mutableListOf() //省略为data赋值的代码 l = findViewById(R.id.l) l?.layoutManager = LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false) val adapter = RecyclerGridAdapter(this, data) adapter.setOnItemClickListener(adapter) adapter.setOnItemLongClickLostenner(adapter) l?.adapter = adapter l?.itemAnimator = DefaultItemAnimator() l?.addItemDecoration(SpacesItemDecoration(30)) } override fun onCreateOptionsMenu(menu: Menu?): Boolean { menu?.add(&quot;LinearLayoutManager(线性)&quot;) menu?.add(&quot;GridLayoutManager(网格)&quot;) menu?.add(&quot;StaggeredGridLayoutManager(瀑布流)&quot;) return super.onCreateOptionsMenu(menu) } override fun onOptionsItemSelected(item: MenuItem?): Boolean { if (item != null) {//菜单中选择各种布局 when(item.title) { &quot;LinearLayoutManager(线性)&quot; -&gt; l?.layoutManager = LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false) &quot;GridLayoutManager(网格)&quot; -&gt; l?.layoutManager = GridLayoutManager(this, 2) &quot;StaggeredGridLayoutManager(瀑布流)&quot; -&gt; l?.layoutManager = StaggeredGridLayoutManager(2, StaggeredGridLayoutManager.VERTICAL) else -&gt; toast(&quot;error&quot;) } } return super.onOptionsItemSelected(item) }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RecyclerView/"},{"title":"Kotlin学习笔记——SharedPreference","text":"12#define 小毛驴 xml#define SPS SharedPreferences 知识补充模板类 Any类——相当于java中的Object类 &lt;*&gt;——相当于java中的&lt;?&gt;表示不同于模板类的T 委托属性待补充 lazy修饰符让变量在首次使用的时候赋值 与lateinit的区别： lateinit是在创建变量时不赋值，想编译器保证在使用之前会赋值，这样这个变量仍然会被当做非空变量 lazy是创建变量时”赋值”，但是真正赋值是在首次使用的时候才赋值 with函数1with(函数头语句){函数体语句} 函数头语句先于函数体语句执行，函数头语句会返回一个值 函数体语句会在头语句的返回对象的命名空间中执行，体语句可以直接调用头部返回的类的方法 使用场景SharedPreferences是Android中最简单的数据储存方式 使用方法方法一览SharedPreferences类的方法（注意最后有一个s） 方法 参数 解释 getSharedPreferences String + MODD 初始化一个SPS。第一个String是文件名，与str.xml文件共享参数。第二个参数是参数的操作模式，是Context类中的静态常量（这个函数不是SPS的方法，是Context的，但是为了方便起见写在这里） getString key-value obviously getInt key-value obviously getBoolean key-value obviously getFloat key-value obviously getLong key-value obviously 编写一个Util类123456789101112131415161718192021222324252627282930313233343536373839class SharedPreferencesUtil&lt;T&gt;(val context: Context, val name:String, val default:T) : ReadWriteProperty&lt;Any?, T&gt; { val prefs: SharedPreferences by lazy { context.getSharedPreferences(&quot;default&quot;, Context.MODE_PRIVATE) } override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T { return findPreference(name, default) } override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) { putPreference(name, value) } private fun findPreference(name:String, default: T) : T = with(prefs){ return when (default) { is Long -&gt; getLong(name, default) is String -&gt; getString(name, default) is Int -&gt; getInt(name, default) is Boolean -&gt; getBoolean(name, default) is Float -&gt; getFloat(name, default) else -&gt; throw IllegalArgumentException(&quot;Unsupport type&quot;) } as T } private fun &lt;T&gt; putPreference(name:String, value:T) = with(prefs.edit()) { when (value) { is Long -&gt; putLong(name, value) is String -&gt; putString(name, value) is Int -&gt; putInt(name, value) is Boolean -&gt; putBoolean(name, value) is Float -&gt; putFloat(name, value) else -&gt; throw IllegalArgumentException(&quot;Unsupport type&quot;) }.apply() //commit和apply都表示提交 //应该是对when-else语句的返回值调用apply方法 }} 使用1234var name:String by SharedPreferencesUtil(this, &quot;name&quot;, &quot;&quot;)var age:Int by SharedPreferencesUtil(this, &quot;age&quot;, 0)var marriage:Boolean by SharedPreferencesUtil(this, &quot;marriage&quot;, true)//以上三个变量就被“本地化”保存了","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94SharedPreference/"},{"title":"Kotlin学习笔记——Spinner","text":"android提供的spinner1234567891011121314151617181920212223class MainActivity : AppCompatActivity() { val strs = arrayOf(&quot;1&quot;, &quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;, &quot;6&quot;, &quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;11&quot;,&quot;12&quot;,&quot;13&quot;,&quot;14&quot;,&quot;15&quot;,&quot;16&quot;) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val sp = findViewById&lt;View&gt;(R.id.spinner) as Spinner val startAdapter = ArrayAdapter(this, R.layout.support_simple_spinner_dropdown_item, strs) startAdapter.setDropDownViewResource(R.layout.support_simple_spinner_dropdown_item) sp.prompt = &quot;请选择&quot; sp.adapter = startAdapter sp.setSelection(0) var listen = myItemClickListener() sp.onItemSelectedListener = listen } internal inner class myItemClickListener : AdapterView.OnItemSelectedListener { override fun onNothingSelected(parent: AdapterView&lt;*&gt;?) { } override fun onItemSelected(parent: AdapterView&lt;*&gt;?, view: View?, position: Int, id: Long) { toast(&quot;你的选择是：${strs[position]}&quot;) } }} 步骤 一个ArrayAdapter，参数分别是this，R.layout.support_simple_spinner_dropdown_item，Array&lt;String&gt;（到时候的item） 刚才的ArrayAdapter设置效率视窗资源，调用setDropDownViewResource函数，参数是R.layout.support_simple_spinner_dropdown_item 把ArrayAdapter赋值给spinner的adapter成员 设置默认选项，setSelection 如果想让spinner为对话框形式的，在xml文件中设置android:spinnerMode=&quot;Dialog&quot;,spinner的prompt成员为设置对话框标题的接口 新建一个内部类，监听下拉选择，继承AdapterView.OnItemSelectedListener，重载onNothingSelected和onItemSelected两个方法 新建监听器对象，通过spinner的onItemSelectedListener设置为监听器 anko库提供的spinner——selector1234567val strs = Arrayof(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)aTextView.text = &quot;假装这是一个spinner，其实我是TextView&quot;aTextView.setOnClickListener { selector(&quot;请选择&quot;, strs) { i -&gt; toast(&quot;你的选择是：${strs[i]}&quot;) }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Spinner/"},{"title":"Kotlin学习笔记——TextView","text":"文本属性设置函数 方法 说明 备注 text 当前文本内容 可以直接赋值，更改内容，可以当做变量，获取内容 textSize 文本大小 Float类型 setTextColor 设置文本颜色 与Color类一起使用 setBackgroundColor 设置背景色 与Color类一起使用 gravity 设置对齐方式 与Gravity一起使用，多种对齐方式用or连接 ellipsize 多余文本的省略方式 与TruncateAt一起使用 setSingleLine 是否单行显示 参数Boolean isFocusable 是否可获得焦点 可赋值，更改属性，可以取值 isFocusableInTouchMode 是否在触摸时获得焦点 可赋值，更改属性，可以取值 补充ColorColor类中的常用静态成员 名称 参数 作用 rgb 三个r、g、b值 返回一个对应rgb的Color对象 其他静态成员常量 无 yellow、green、red、grey等对应颜色的Color对象 GravityColor类中的常用静态成员 名称 作用 LEFT 左对齐 RIGHT 右对齐 CENTER 居中 TruncateAtColor类中的常用静态成员 名称 作用 START 省略号在开头 MIDDLE 省略号在中间 END 省略号在末尾 MARQUEE 跑马灯显示，一定要设置为单行显示 特定效果跑马灯显示，自动滚动，不需要获得焦点 重载isFocused函数，让其永远返回true，默认一直在获得焦点 设置单行显示 设置Focusable12345678910111213141516class MyTextView : TextView { init { this.gravity = Gravity.LEFT or Gravity.CENTER this.ellipsize = TextUtils.TruncateAt.MARQUEE this.setSingleLine(true) this.isFocusable = true this.isFocusableInTouchMode = true } constructor(context: Context) : super(context) constructor(context: Context, attrs: AttributeSet?) : super(context, attrs) constructor(context: Context, attrs: AttributeSet?, style: Int) : super(context, attrs, style) override fun isFocused(): Boolean { return true }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94TextView/"},{"title":"Kotlin学习笔记——anko库","text":"弹出吐司 方法 参数 解释 备注 toast CharSequence 弹出短吐司 相当于Toast.makeText(this, &quot;String&quot;, Toast.Toast.LENGTH_SHORT).show() longToast CharSequence 弹出长吐司 相当于Toast.makeText(this, &quot;String&quot;, Toast.Toast.LENGTH_LONG).show() 像素转换方法 方法 说明 dip dip 转 px sp sp 转 px px2dip px 转 dip px2sp px 转 sp dimen dip 转 sp 弹出警告窗口12345678alert(&quot;对话框内容&quot;, &quot;对话框标题&quot;) { positiveButton(&quot;确认&quot;) { //点按确认后执行的操作 } negativeButton(&quot;取消&quot;) { //点按取消后执行的操作 }}.show()","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94anko%E5%BA%93/"},{"title":"Kotlin学习笔记——TabLayout","text":"1#define 小毛驴 xml 使用场景如果想让ViewPager的tab标签和Toolbar合二为一的话，可以在Toolbar中嵌套TabLayout 使用方法 编写好小毛驴文件，把TabLayout嵌套到Toolbar中，编写好每一页的小毛驴布局文件，写好传递数据的类 编写Fragment1234567891011121314151617181920212223242526272829303132333435363738class BlankFragment : Fragment() { var ctx:Context? = null var mPosition:Int = 0 var mInageId:Int = 0 var mDesc:String = &quot;&quot; var title:String = &quot;&quot; override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { ctx = activity if (arguments != null) { mPosition = arguments!!.getInt(&quot;position&quot;, 0) mInageId = arguments!!.getInt(&quot;image_id&quot;, 0) mDesc = arguments!!.getString(&quot;desc&quot;) title = arguments!!.getString(&quot;title&quot;) } val view = inflater.inflate(R.layout.item, container, false) val pic:ImageView = view.findViewById(R.id.imageView) val desc:TextView = view.findViewById(R.id.textView) pic.setImageResource(mInageId) desc.text = mDesc return view } companion object { fun newInstance(position:Int, image_id:Int, desc:String, title:String) : BlankFragment { val fragment = BlankFragment() val bundle = Bundle() bundle.putInt(&quot;position&quot;, position) bundle.putInt(&quot;image_id&quot;, image_id) bundle.putString(&quot;desc&quot;, desc) bundle.putString(&quot;title&quot;, title) fragment.arguments = bundle return fragment } }} 编写ViewPager的适配器1234567891011class infoPagerAdapter(val fragManger: FragmentManager, val itemList:MutableList&lt;itemInfo&gt;) : FragmentStatePagerAdapter(fragManger) { override fun getCount(): Int = itemList.size override fun getItem(p0: Int): Fragment { val item = itemList[p0] return BlankFragment.newInstance(p0, item.pic, item.desc, item.name) } override fun getPageTitle(position: Int): CharSequence? { return itemList[position].name }} 给ViewPager添加适配器12345678910111213141516171819202122232425262728293031323334353637383940class the_pics : AppCompatActivity() , TabLayout.OnTabSelectedListener { override fun onTabReselected(p0: TabLayout.Tab?) {} override fun onTabUnselected(p0: TabLayout.Tab?) { } override fun onTabSelected(p0: TabLayout.Tab?) { if (p0 != null) vp.currentItem = p0.position //如果用户点击了某个标签，把下面ViewPager也滚动到相应位置 //以上三个重载函数都是Toolbar上的标签产生事件后相应的操作 } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_the_pics) val bar:android.support.v7.widget.Toolbar = findViewById(R.id.bar) setSupportActionBar(bar) supportActionBar?.title = &quot;&quot; bar.setNavigationOnClickListener { setResult(Activity.RESULT_OK) finish() }//设置Toolbar的返回导航键的click监听器 var data:MutableList&lt;itemInfo&gt; = mutableListOf() /*省略data的赋值过程*/ tab_title.addOnTabSelectedListener(this) vp.adapter = infoPagerAdapter(supportFragmentManager, data) vp.addOnPageChangeListener(object : ViewPager.SimpleOnPageChangeListener() { override fun onPageSelected(position: Int) { tab_title.getTabAt(position)!!.select()//让标签栏的第position个变成被选择状态 //这个重载函数是ViewPager上有Page的改变后调用的函数 } }) }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94TabLayout/"},{"title":"Kotlin学习笔记——ViewPager","text":"1#define 小毛驴 xml 使用方法 在活动页面添加ViewPager，如果需要tab标签，在ViewPager里嵌套PagerTabStrip或PagerTitleStrip 设计传送数据的类（一张图和一个标题就足够） 编写ViewPager的适配器12345678910111213141516171819202122232425262728293031class ImagePagerAdapter(val context: Context, val itemList:MutableList&lt;itemInfo&gt;) : PagerAdapter() { val views = mutableListOf&lt;ImageView&gt;() init { for (item in itemList) { val view = ImageView(context) //view.layoutParams = ActionBar.LayoutParams(ActionBar.LayoutParams.MATCH_PARENT, ActionBar.LayoutParams.WRAP_CONTENT) view.layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT) view.setImageResource(item.pic) view.scaleType = ImageView.ScaleType.FIT_CENTER views.add(view) } } override fun isViewFromObject(p0: View, p1: Any): Boolean = (p0 === p1) override fun getCount(): Int = views.size override fun destroyItem(container: ViewGroup, position: Int, `object`: Any) { container.removeView(views[position]) } override fun instantiateItem(container: ViewGroup, position: Int): Any { container.addView(views[position]) return views[position] } override fun getPageTitle(position: Int): CharSequence? { return itemList[position].desc }//与PagerTabStrip或配合使用} 给PagerView添加适配器和页面改变的Listener123456789101112131415161718192021222324252627282930313233class MainActivity : AppCompatActivity(), ViewPager.OnPageChangeListener { override fun onPageScrollStateChanged(p0: Int) { } override fun onPageScrolled(p0: Int, p1: Float, p2: Int) { } override fun onPageSelected(p0: Int) { Toast.makeText(this, p0.toString(), Toast.LENGTH_SHORT).show() } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) //supportActionBar?.hide() var vp:ViewPager = findViewById(R.id.vp) val pics = arrayOf(R.mipmap.basic, R.mipmap.close, R.mipmap.debug, R.mipmap.edit) val list:MutableList&lt;itemInfo&gt; = mutableListOf() for (i in pics.indices) { list.add(itemInfo((i+1).toString(), pics[i])) } vp.adapter = ImagePagerAdapter(this, list) vp.currentItem = 0 vp.addOnPageChangeListener(this) var title: PagerTabStrip = findViewById(R.id.title) title.setTextSize(TypedValue.COMPLEX_UNIT_SP, 20f) title.setTextColor(Color.RED) }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94ViewPager/"},{"title":"Kotlin学习笔记——基础语法篇之控制语句","text":"if…else…用法Kotlin中if...else...基本用法与C/C++，java中相同 例子12345678button.setOnClickListener { if (flag) { text.text = &quot;I love you, at the first sight of you.&quot; } else { text.text = &quot;I love three things in this world.Sun, moon and you. &quot; + &quot;Sun for morning, moon for night, and you forever.&quot; }} 而Kotlin的if else可以有返回值 例子12345678button.setOnClickListener { text.text = if (flag) { &quot;I love you, at the first sight of you.&quot; } else { &quot;I love three things in this world.Sun, moon and you. &quot; + &quot;Sun for morning, moon for night, and you forever.&quot; }} Kotlin中没有java，C/C++的三目运算符，但是可以用if…else…取代 例子1234567button.setOnClickListener { text.text = if (flag) (16).toString() else (153.6).toString() /* 像极了三目元算符：(假装这里是C/C++或java) text.text = flag ? (16).toString() : (153.6).toString(); */} when…else…用法Kotlin中的when...else...多路分支相当于C/C++，java中的switch...case...，但是用法稍有不同 Kotlin的when...else...和Kotlin的if...else...一样，允许有返回值 Kotlin的when...else...各个分支中，可以不是常量，变量也可以 Kotlin的when...else...不用写break，每个分支结束后自动退出when...else...语句块 例子123456789button.setOnClickListener { text.text = when(type) { 1,2,3 -&gt; &quot;I love you, at the first sight of you.&quot;//多个值走同一个分支，用逗号隔开 in 4..10 -&gt; &quot;I love three things in this world.Sun, moon and you. &quot; + &quot;Sun for morning, moon for night, and you forever.&quot;//表示在4到10之间 !in 1..10 -&gt; &quot;We don't talk anymore.&quot;//表示不在1到10之间 else -&gt; &quot;error&quot; }} 循环for循环Kotlin居然取消了常见的for循环，tmd 遍历循环1. for-in循环类似C++/java中的for_each形式的循环，可以对字符串、数组、Array&lt;&gt;, 队列、映射、集合进行遍历 例子123456btn.setOnClickListener { var str:String = &quot;0123456789&quot; for (item in str) {//item自动类型推断 Toast.makeText(this, &quot;${item}&quot;, Toast.Toast.LENGTH_SHORT).show() }} 例子(下标数组遍历)123456btn.setOnClickListener { var str:String = &quot;0123456789&quot; for (i in str.indices) {//indices是下标数组 Toast.makeText(this, &quot;${str[i]}&quot;, Toast.Toast.LENGTH_SHORT).show() }} 条件循环格式123456for(i in 11 until 66) {}//左闭右开区间，[11,66)for (i in 23..89 step 4) {}//每次循环，i += 4，如果条件允许，可以到89for (i in 50 downTo 7) {}//从50 递减到 7 while循环用法同java/C/C++ do-while循环用法同java/C/C++ 跳出多重循环和java类似，如果想一次性跳出多个循环，可以在循环外面加”标签” 例子123456789101112var i:Int = 0var j:Int = 0@outside while (i &lt;= 10) { j = 10; while (i * j != 50) { j-- if (j == 0) { break@outside } } i++}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87%E4%B9%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"},{"title":"Kotlin学习笔记——基础语法篇之数据类型","text":"一、基本数据类型Kotlin的数据类型 数据类型名称 Kotlin的数据类型 整型 Int 长整型 Long 浮点型 Float 双精度浮点型 Double 布尔型 Boolean 声明变量1234567891011var integer:Int//一般用法var/val + 标识符 + : + 类型名，var表示变量val integer1:Int = 0//val表示常量，相当于java中的final，c++中的constvar str = &quot;this is a string&quot;//没有&quot;:String&quot;，此时只要保证编译器可以知道变量的类型，则编译器可以完成类型推断var flt:Float = 5f//f表示数据为float类型var tobar:Toolbar? = findViewById&lt;Toolbar&gt;(R.id.toolbar)/*类型名后+'?'表示该变量为可空变量，kotlin为了防止java中NullPointerException，默认所有的变量都是不可空（不能为null的），如果要让变量为空，需要+'?'，此时，编译器会强制程序员对所有可空变量进行非空判断*/ Kotlin的类型转换强制类型转换12var double:Double = 16.0val dbl2Int:Int = (double as Int) 数据转换函数在kotlin的世界中，一切都是类和对象，基本数据类型也是，其中用于数据转换的成员函数 Kotlin的数据类型转换函数 toInt toLong toFloat toDouble toChar toString 二、字符串字符串与其他基本数据类型转换 String的成员函数 备注 toInt toLong toFloat toDouble toBoolean toCharArray 返回的是CharArray不是Array&lt;Char&gt; 字符串的常用方法 String的成员函数 解释 indexOf 查找子串 substring 获取子串 replace 替换子串 split 按特定字符分隔子串，返回值是List&lt;String&gt; 字符串拼接12345678val str1:String = &quot;我刘景天宇宙第一帅！&quot;val integer:Int = 8848val text:TextView = findViewById&lt;TextView&gt;(R.id.text)val strCat:String = &quot;str1 = ${str1} integer = $integer, 当前text中显示的内容是：${text.text}&quot;/*$变量名${表达式}*/ 三、数组Kotlin的数组类型 数组名称 初始化方法 数组名称 初始化方法 IntArray intArrayOf Array&lt;Int&gt; ArrayOf LongArray longArrayOf Array&lt;Long&gt; ArrayOf FloatArray floatArrayOf Array&lt;Float&gt; ArrayOf DoubleArray doubleArrayOf Array&lt;Double&gt; ArrayOf BooleanArray booleanArrayOf Array&lt;Boolean&gt; ArrayOf CharArray charArrayOf Array&lt;Char&gt; ArrayOf null null Array&lt;String&gt; ArrayOf 数组常用方法 成员 解释 size 数组长度 get(index) 获取元素 set(index, value) 修改元素值 ps:kotlin也可以通过下标引用元素和修改元素 四、容器Kotlin的容器 Kotlin容器 名称 初始化方法 只读集合 Set setOf 可变集合 MutableSet mutableSetOf 只读队列 Set listOf 可变队列 MutableSet mutableListOf 只读映射 Set mapOf 可变映射 MutableSet mutableMapOf 容器的通用常用方法 方法名 返回值 解释 isEmpty() Boolean 判断是否为空 isNotEmpty() Boolean 判断是否为非空 clear() Unit（猜测） 清空容器（找不到这个方法） contains(value) Boolean 查找有没有这个元素 iterator() 对应的迭代器 返回容器的迭代器 count() Int 获取元素个数 size Int 获取元素个数 ps:只读容器初始化后就不可更改了 容器的迭代器的常用方法 方法名 解释 hasNext() 类似java的Scanner的hasNext方法 next() 类似java的Scanner的Next方法 集合Kotlin集合的特性 集合内部元素不按照顺序排列，无法下标访问 集合内部元素具有唯一性 MutableSet的元素变更方法 方法 解释 add(element) 添加元素 remove(element) 移除某个元素 映射初始化方法123456var map1:map&lt;String, int&gt; = mapOf(&quot;1&quot; to 1, &quot;2&quot; to 2, &quot;3&quot; to 3)var map2:mutableMap&lt;String, Boolean&gt; = mutableMapOf(Pair(&quot;a&quot;, true), Pair(&quot;b&quot;, false))/*不论是map还是mutableMap，都可以使用 key to value和Pair(Key, Value)*/ Map和MutableMap的常用方法 方法 返回值 解释 Map MutableMap containsKey(key) Boolean 判断是否有指定键的元素 √ √ containsValue(value) Boolean 判断是否有指定值的元素 √ √ put(key, value) String? 添加元素 × √ remove(key) String? 移除元素 × √ remove(key， value) Boolean 移除元素 × √ 队列队列的常用方法 方法 返回值 解释 List MutableList get(index) ElementType 返回对应位置的元素 √ √ [index] ElementType 下标运算 √ √ add(element) Unit 向队尾添加元素 × √ set(index, element) ElementType 修改指定位置的元素 × √ removeAt(index) Int 移除指定位置的元素 × √ sortBy{排序条件} Unit 按照排序条件升序排列 × √ sortByDescending{排序条件} Unit 按照排序条件降序排列 × √ sort() Unit 排序 × √ 五、类型判断例子12345if (varable is String) { //Do something，} else if (varable is Int) { //or you will do something} 例子12345when (varable) { is String -&gt; //Do something is Int -&gt; //or you will do something else -&gt; //nothing} 六、空安全1234567891011121314var i:Int = 0//Kotlin默认的变量是不可为空(null)的var str:String? = null//如果想让一个变量为空，要在类型名后面加'?'i = str?.length //可空变量在调用方法时，在后面加上'?'，一旦可空变量str的值为空，返回nulltry { i = str!!.length} catch(e: Exception) { Toast.makeText(this, &quot;遇到${e}错误&quot;, Toast.LENGTH_SHORT).show()}//可空变量加!!，表示如果为空，抛出异常i = str?.length : -1//表示如果str为空，则值为0","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"Kotlin学习笔记——基础语法篇之函数","text":"函数的一般形式12345fun mathodName(/*para list*/) : String/*return value type*/ { /* function body */} 与C、C++或java的不同 如果要重载，在fun前面加override 如果想让子类重载，要加open关键词（类也一样） 可以定义全局函数，函数不是必须写在类里 可以有默认参数，且默认参数不必放在最后几个123456789101112fun TextView.println(str:CharSequence) { append(&quot;\\n${str}&quot;)}fun TextView.print(str:CharSequence) { append(str)}//这个东西是扩展函数，后面说fun func(str:String = &quot;哈哈哈&quot;,i:Int, j:Double) {//str的默认参数&quot;哈哈哈&quot; val text:TextView = findViewById(R.id.text) text.print(&quot;$str&quot;) text.println(&quot;$i&quot;) text.println(&quot;$j&quot;)} 此时，在调用时，如果第一个不采用默认参数，则按照顺序传递三个参数，否则按照以下形式传递参数1func(i = 10, j = 20.5) 可变参数，在参数列表中，参数名称前用vararg（var = varable, arg = 参数）修饰1234567fun appendString(tag:String, vararg info:String?) : String { var str:String = &quot;${tag}&quot; for (item in info) { str = &quot;${str}\\n${item}&quot; } return str} Kotlin的特殊函数泛型函数/内联函数例子1234567fun&lt;T&gt; appendString(tag:String, vararg info:T?) : String { var str:String = &quot;${tag}&quot; for (item in info) { str = &quot;${str}\\n${item.toString()}&quot; } return str} 在fun后面加入&lt;泛型列表&gt;,表示泛型函数 调用方法123btn.setOnClickListener { text.text = appendString&lt;Int&gt;(&quot;转化&quot;, 1,2,3,4,5,6,7,8,9)} 注意 只有泛型类才拥有成员泛型函数，或者可以把泛型函数作为全局函数 Kotlin是强类型的语言，如果需要即传递Number类继承的类对象，而不继承其他类对象，不能写&lt;Number&gt; 要写成&lt;reified T : Number&gt;,这个写法等价于java的&lt;T extends Number&gt; 简化函数Kotlin中，函数的定义形式和变量十分相似，这是因为函数也是一种特殊变量，可以对他赋值 例子1fun factorial(n:Int):Int = if(n &lt;= 1) n else n*factorial(n-1) 尾递归函数在fun之前加上关键字tailrec(tail——尾巴，rec——不知道)，告诉编译器这是一个尾递归函数，编译器可以自动优化成循环 例子12tailrec fun findFixPoint(x:Double = 1.0) : Double = if (x == Math.cos(x)) x else findFixPoint(Math.cos(x)) 高阶函数传入的参数是一个函数，个人认为相当于C/C++的函数指针，或者说传递了一个函数变量 例子1234567891011121314fun&lt;T&gt; maxCustom(array:Array&lt;T&gt;, greater:(T,T) -&gt; Boolean) : T? { /* 这个地方 greater(T, T) -&gt; Boolean 表示一个函数名为greater，参数为两个T类型，返回值的Boolean的函数 */ var max:T? = null for (item in array) { if (max == null || greater(item, max)) { max = item } } return max} 调用1234val arr:Array&lt;Int&gt; = arrayOf(1,2,3)btn.setOnClickListener { text.text = &quot;最大值为${maxCustom&lt;Int&gt;(arr, {a,b -&gt; a &gt; b}).toString()}&quot;}//使用lambad表达式 系统增强函数扩展函数可以给已有的类中添加函数，作为成员函数 例子123456fun TextView.println(str:CharSequence) { append(&quot;${str}\\n&quot;)}fun TextView.print(str:CharSequence) { append(str)} 调用和正常成员函数一样调用 123456val text:TextView = findViewById(R.id.text)val btn:Button = findViewById(R.id.btn)btn.setOnClickListener { text.println(&quot;123&quot;) text.print(&quot;demo&quot;)} 单例对象用object替换class，这样其中的所有函数都是静态成员函数了 相当于static修饰符","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87%E4%B9%8B%E5%87%BD%E6%95%B0/"},{"title":"实习笔记-24","text":"设备到设备文件传输如果您的应用以 Android 11 或更高版本为目标平台，您将无法使用 allowBackup 属性停用应用文件的设备到设备迁移。系统会自动启用此功能。 不过，即使您的应用以 Android 11 或更高版本为目标平台，您也可以通过将 allowBackup 属性设为 false 来停用应用文件的云端备份和恢复。 非 SDK 接口限制相机媒体 intent 操作需要系统默认相机从 Android 11 开始，只有预装的系统相机应用可以响应以下 intent 操作： android.media.action.VIDEO_CAPTUREandroid.media.action.IMAGE_CAPTUREandroid.media.action.IMAGE_CAPTURE_SECURE如果有多个预装的系统相机应用可用，系统会显示一个对话框，供用户选择应用。如果您希望自己的应用使用特定的第三方相机应用来代表其捕获图片或视频，可以通过为 intent 设置软件包名称或组件来使这些 intent 变得明确。 应用打包和安装现在还必须使用 APK 签名方案 v2 或更高版本进行签名 Toastopen fun setView(view: View!): Unit Deprecated: Custom toast views are deprecated. Apps can create a standard text toast with the Custom toast views are deprecated. 以 Android 11 或更高版本为目标平台的应用会发现文本消息框受到以下负面影响： getView() 方法返回 null。 以下方法的返回值并不反映实际值，因此您不应在应用中依赖于它们： getHorizontalMargin() getVerticalMargin() getGravity() getXOffset() getYOffset() 以下方法是空操作，因此您的应用不应使用它们： setMargin() setGravity()","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%89%E5%8D%9311%E6%96%B0%E7%89%B9%E6%80%A7/"},{"title":"Kotlin学习笔记——lambda","text":"参考文献——kotlin之Lambda编程来自简书作者——程自舟 Kotlin lambda语法12345678910111213btn.setOnClickListener ((View v) -&gt; { toast(&quot;click&quot;)})btn.setOnclickListener { toast(&quot;click&quot;)}btn.setOnLongClickListener { toast(&quot;Long Click&quot;) true//lambdda的返回值，不写return}{a:Int, b:String -&gt; String (a + b.toDouble()).toString()} 完整写法123456789{a:Int, b:String, c:Long/*输入参数列表*/ -&gt; String/*返回值类型*/ /*lambda body*/ var temp:Double = a + b.toDouble() if (c == 0L) { &quot;error&quot; } else { (temp.toDouble() + c).toString() }//返回值(不要写return)} 省略参数的写法12345{ /* lambda body */} lambda的使用 作为高阶函数的参数，比如setOnclickListener，List的sort系列函数 调用run方法1run { toast(&quot;run&quot;) } Lambda表达式也可以传递给一个高阶函数当做参数,因此上述代码中1view.setOnClickListener({v -&gt; viewClicked(v) }) 在 Kotlin 中有一个约定，如果函数的最后一个参数是一个函数，并且你传递一个 lambda 表达式作为相应的参数，你可以在圆括号之外指定它因此可以实现如下1view.setOnClickListener() {v -&gt; viewClicked(v) } 在 Kotlin中还有另外一个约定，如果一个函数的参数只有一个，并且参数也是一个函数，那么可以省略圆括号1view.setOnClickListener{v -&gt; viewClicked(v) } 使用默认参数名称（注意）12//使用默认参数名称people.maxBy { it.age} //&quot;it&quot;是自动生成的参数名称 默认名称it只会在实参名称没有显示的指定时候才会生成。it能大大缩短简化代码，但是不应该滥用，尤其是在lambda嵌套情况下，最好显示声明lambda参数。否则很难搞清it引用的到底是哪个值，本末倒置。","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94lambda/"},{"title":"实习笔记-25","text":"创建型单例优点 节省资源 内存 重对象中包含的io，文件指针 调用方便 缺点 适用于昂贵对象，对于轻量对象，为了维护单例造成的同步等开销比创建一个对象更高。得不偿失 不方便mock，（可以把单例对象作为函数参数则可以mock），相较于静态方法更方便（静态方法需要代理的方式mock） 测试时常常并行测试，使用单例会降低效率函数式编程，拷贝云控，打点 Alex静态工具方法，少用，不要有状态，确保永远不会变 建造者 构建一个参数非常复杂的对象，但是常用的组合很有限，写一个builder提供常用组合，builder内部自己填充其他的参数 与连续调用没有关系，可以链式调用的叫fluentApi 优点 完整性 创建对象的合法性，在build时检查/默认值 灵活性 工厂静态工厂线程池，collections封装构造器，简化构造 实例工厂解耦时，不希望类持有不需要的类，使用factory持有该对象 抽象工厂返回抽象/接口，方便修改，选择不同实现 结构型添加新需求，加判断，时尝试： 代理模式（构造器传入委托人） wrapper 快捷键，double shift， 搜 delegate method 静态代理（正常）动态代理（反射）装饰器（相互组合代理） wrapper 内部看为代理-委托 给执行包一层皮，每层皮实现一种功能（如对cloud加缓存、sdk模式），包的顺序不同，调用顺序也不同 组合模式（对象持有） wrapper eg 对方法计数，如果是继承（推荐默认final， kotlin默认final），子类的行为改变了父类的行为（父类调用自己计过数的方法），组合模式避免了这种情况 局限性，内部的特性无法访问 组合由于继承","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"LeetCode-32","text":"第 388 场周赛100233. 重新分装苹果 贪心 1234567891011121314151617class Solution {public: int minimumBoxes(vector&lt;int&gt;&amp; apple, vector&lt;int&gt;&amp; capacity) { int need = accumulate(apple.begin(), apple.end(), 0); sort(capacity.begin(), capacity.end()); int ans = 0, total = 0; for(int i = capacity.size() - 1; i &gt;= 0; i--) { if(total &lt; need) { total += capacity[i]; ans++; } else { break; } } return ans; }}; 100247. 幸福值最大化的选择方案 贪心 123456789101112class Solution {public: long long maximumHappinessSum(vector&lt;int&gt;&amp; happiness, int k) { long long ans = 0; int len = happiness.size(); sort(happiness.begin(), happiness.end()); for(int i = 0; i &lt; k; i++) { ans += max(happiness[len - 1 - i] - i, 0); } return ans; }}; 100251. 数组中的最短非公共子字符串 暴力 12345678910111213141516171819202122232425262728293031323334353637class Solution { string min(string &amp;a, string&amp; b) { int len_a = a.length(); int len_b = b.length(); if(len_a != len_b) return len_a &lt; len_b ? a : b; return std::min(a, b); }public: vector&lt;string&gt; shortestSubstrings(vector&lt;string&gt;&amp; arr) { int len = arr.size(); vector&lt;string&gt; res(len); for(int i = 0; i &lt; len; i++) { int strlen_i = arr[i].length(); string min_substri = arr[i]; bool find_min = false; for(int sub_strlen = strlen_i; sub_strlen &gt; 0; sub_strlen--) { for(int start_index = 0; start_index &lt;= strlen_i - sub_strlen; start_index++) { bool flag = true; string substri = arr[i].substr(start_index, sub_strlen); for(int j = 0; j &lt; len; j++) { if(i == j) continue; if(arr[j].find(substri) != string::npos) { flag = false; break; } } if(flag) { min_substri = min(min_substri, substri); find_min = true; } } } if(find_min) res[i] = min_substri; } return res; }}; 100216. K 个不相交子数组的最大能量值超时12345678910111213141516171819202122232425class Solution {public: long long maximumStrength(vector&lt;int&gt;&amp; nums, int k) { int len = nums.size(); vector&lt;vector&lt;long long&gt;&gt; dp(k+1, vector&lt;long long&gt;(len+1, LLONG_MIN)); vector&lt;long long&gt; prefix_sum(len+1, 0); for(int i = 1; i &lt;= len; i++) { prefix_sum[i] = prefix_sum[i-1] + nums[i-1]; } long long sign = 1; fill(dp[0].begin(), dp[0].end(), 0); for(int seperator = 1; seperator &lt;= k; seperator++) { dp[seperator][0] = 0; for(int i = 1; i &lt;= len; i++) { for(int j = seperator-1; j &lt; i; j++) { dp[seperator][i] = max(dp[seperator][i], dp[seperator-1][j] + (k - seperator + 1) * sign * (prefix_sum[i] - prefix_sum[j])); } // cout &lt;&lt; dp[seperator][i] &lt;&lt; &quot;,&quot;; } sign *= -1; // cout &lt;&lt; endl; } return *max_element(dp[k].begin() + k, dp[k].end()); }}; AC 把含下标j的和含下标seperator分开，可以减少一次循环 123456789101112131415161718192021222324252627class Solution {public: long long maximumStrength(vector&lt;int&gt;&amp; nums, int k) { int len = nums.size(); vector&lt;vector&lt;long long&gt;&gt; dp(k+1, vector&lt;long long&gt;(len+1, 0)); vector&lt;long long&gt; prefix_sum(len+1, 0); for(int i = 1; i &lt;= len; i++) { prefix_sum[i] = prefix_sum[i-1] + nums[i-1]; } long long sign = 1; fill(dp[0].begin(), dp[0].end(), 0); for(int seperator = 1; seperator &lt;= k; seperator++) { dp[seperator][seperator-1] = LLONG_MIN; long long mx = LLONG_MIN; for(int i = seperator; i &lt;= len - k + seperator; i++) { // for(int j = seperator-1; j &lt; i; j++) { mx = max(mx, dp[seperator - 1][i - 1] - prefix_sum[i - 1] * (k - seperator + 1) * sign); dp[seperator][i] = max(dp[seperator][i - 1], prefix_sum[i] * (k - seperator + 1) * sign + mx); // } // cout &lt;&lt; dp[seperator][i] &lt;&lt; &quot;,&quot;; } sign *= -1; // cout &lt;&lt; endl; } return *max_element(dp[k].begin() + k, dp[k].end()); }}; 第 387 场周赛3069. 将元素分配到两个数组中 I123456789101112131415161718192021class Solution {public: vector&lt;int&gt; resultArray(vector&lt;int&gt;&amp; nums) { int len = nums.size(), arr1 = 0; vector&lt;int&gt; arr2; arr2.push_back(nums[1]); for(int i = 2; i &lt; len; i++) { if(nums[arr1] &gt; arr2.back()) { nums[++arr1] = nums[i]; } else { arr2.push_back(nums[i]); } } arr1++; for(int i = arr1; i &lt; len; i++) { nums[i] = arr2[i - arr1]; } // cout &lt;&lt; arr1 &lt;&lt; endl; return nums; }}; 3070. 元素和小于等于 k 的子矩阵的数目12345678910111213141516171819202122232425class Solution {public: int countSubmatrices(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int k) { int m = grid.size(), n = grid[0].size(); int ans = 0; if(grid[0][0] &lt;= k) ans++; for(int i = 1; i &lt; m; i++) { grid[i][0] += grid[i-1][0]; if(grid[i][0] &lt;= k) ans++; } for(int j = 1; j &lt; n; j++) { grid[0][j] += grid[0][j-1]; if(grid[0][j] &lt;= k) ans++; } for(int i = 1; i &lt; m; i++) { for(int j = 1; j &lt; n; j++) { grid[i][j] += grid[i-1][j] + grid[i][j-1] - grid[i-1][j-1]; if(grid[i][j] &lt;= k) ans++; else break; } } return ans; // grid[i][j] - grid[a][j] - grid[i][b] + grid[a][b]; }}; 3071. 在矩阵上写出字母 Y 所需的最少操作次数123456789101112131415161718192021222324class Solution {public: int minimumOperationsToWriteY(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int y[3] = {0}, cnt[3] = {0}, n = grid.size(); for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { cnt[grid[i][j]]++; if((i == j &amp;&amp; j &lt;= n/2) || (i+j == n-1 &amp;&amp; j &gt;= n/2) || (j == n/2 &amp;&amp; i &gt;= n/2)) { y[grid[i][j]]++; } } } auto cal = [&amp;](int y_val, int noty_val, int other_val) { return y[noty_val] + y[other_val] + cnt[y_val] + cnt[other_val] - y[y_val] - y[other_val]; }; return min( min(cal(0, 1, 2), cal(0, 2, 1)), min( min(cal(1, 0, 2), cal(1, 2, 0)), min(cal(2, 0, 1), cal(2, 1, 0)) ) ); }}; 3072. 将元素分配到两个数组中 II 离散化 + 树状数组 第 381 场周赛3014. 输入单词需要的最少按键次数 I思路1 按照字符出现次数分配按键的位置 123456789101112131415161718192021222324252627class Solution {public: int minimumPushes(string word) { int alpha_cnt[26] = {0}; int key_cnt[8] = {0}; int cur_key = 0; auto cmp = [&amp;alpha_cnt](int i, int j) { return alpha_cnt[i] &lt; alpha_cnt[j]; }; priority_queue&lt;int, vector&lt;int&gt;, decltype(cmp)&gt; q(cmp); for(char c : word) { alpha_cnt[c - 'a']++; } for(int i = 0; i &lt; 26; i++) { if(alpha_cnt[i]) q.push(i); } int ans = 0; while(!q.empty()) { int top = q.top(); q.pop(); key_cnt[cur_key]++; ans += key_cnt[cur_key] * alpha_cnt[top]; cur_key = (cur_key + 1) % 8; } return ans; }}; 思路2 没看到题目说所有字母都是不同的，可以简化 123456789class Solution {public: int minimumPushes(string word) { int n = word.length(); int div8 = n &gt;&gt; 3; int mod8 = n &amp; 0b111; return (((div8 + 1) * div8) &lt;&lt; 2) + (div8 + 1) * mod8; }}; 3015. 按距离统计房屋对数目 I1234567891011121314class Solution {public: vector&lt;int&gt; countOfPairs(int n, int x, int y) { vector&lt;int&gt; ans(n); for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= n; j++) { if(i == j) continue; int dis = min(abs(i - j), abs(min(i, j) - min(x, y)) + abs(max(x, y) - max(i, j)) + 1); ans[dis - 1]++; } } return ans; }}; 3016. 输入单词需要的最少按键次数 II123456789101112131415161718192021222324252627class Solution {public: int minimumPushes(string word) { int alpha_cnt[26] = {0}; int key_cnt[8] = {0}; int cur_key = 0; auto cmp = [&amp;alpha_cnt](int i, int j) { return alpha_cnt[i] &lt; alpha_cnt[j]; }; priority_queue&lt;int, vector&lt;int&gt;, decltype(cmp)&gt; q(cmp); for(char c : word) { alpha_cnt[c - 'a']++; } for(int i = 0; i &lt; 26; i++) { if(alpha_cnt[i]) q.push(i); } int ans = 0; while(!q.empty()) { int top = q.top(); q.pop(); key_cnt[cur_key]++; ans += key_cnt[cur_key] * alpha_cnt[top]; cur_key = (cur_key + 1) % 8; } return ans; }}; 3017. 按距离统计房屋对数目 II 想分类计算，但是没算出来","link":"/home/2024/03/10/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93-%E5%91%A8%E8%B5%9B1/"},{"title":"Kotlin学习笔记——基础语法篇之类和对象","text":"类的构造Kotlin类的写法 Kotlin类的构造函数分为主构造函数和二级构造函数 主构造函数的特点——函数名为init，参数要写在类名后面（下面举例），一般用于初始化 如果要在java中调用kotlin的类，要在类名前面加上@JvmOverloads（让java能够识别默认参数），并且补充constructor关键字 主构造函数的参数写在类名后，如果没有@JvmOverloads修饰，constructor关键字可省略（不是指二级构造函数的constructor，是类名后面的） 二级构造函数用constructor关键字 二级构造函数的特点——可有可无，相互独立，如果有主构造函数，先调用主构造函数 例子123456789101112131415161718class Animal (type:String = &quot;动物&quot;, name:String) { //没有@JvmOverloads修饰，可以省略constructor //等价以下写法//class Animal constructor(type:String = &quot;动物&quot;, name:String) { var Type:String = &quot;&quot; var Name:String = &quot;&quot; var Age:Int = 0 var Sex:String = &quot;&quot; init { Type = type Name = name } constructor(type:String = &quot;动物&quot;, name:String, age:Int, sex:String) : this(type, name){ Age = age Sex = sex }} 类的成员类的成员属性观察上述代码，构造函数传入的参数和成员变量一一对应，对于这些变量，Kotlin提供简便写法，在参数名之前加上val或var 例子1234567891011class Animal (var type:String = &quot;动物&quot;, var name:String) { //只有主构造函数中才可以有成员属性 var sex:Int = 0 var age = 0 constructor(type:String = &quot;动物&quot;, name:String, age:Int, sex:Int) : this(type, name){ this.sex = sex this.age = age }}//到时候可以直接调用成员变量type，name等 伴生对象和静态属性想要让类具有类似java中静态成员函数和静态成员变量，要用到伴生对象，相当于java中的static代码块儿 例子1234567891011121314151617181920212223class Animal (var type:String = &quot;动物&quot;, var name:String) { var sex:Int = 0 var age = 0 constructor(type:String = &quot;动物&quot;, name:String, age:Int, sex:Int) : this(type, name){ this.sex = sex this.age = age } companion object StaticMembers { val MALE:Int = 0 val FEMALE:Int = 1 val UNKNOWNSEX:Int = 2 val UNDIFINEDSEX:Int = 3 fun sexToString(sex:Int):String { return when(sex) { MALE -&gt; &quot;Male&quot; FEMALE -&gt; &quot;Female&quot; UNKNOWNSEX -&gt; &quot;UnKnownSex&quot; UNDIFINEDSEX -&gt; &quot;UnDefindSex&quot; else -&gt; &quot;Invalid input&quot; } } }} 类的继承在Kotlin中，默认情况下，类是不允许被继承的，成员函数也是不允许重写的，只有加上open修饰符，被修饰的类才可以被继承，被修饰的函数才可以被重写，Kotlin的类和函数默认相当于java的final类和方法 Kotlin中的开放性修饰符 开放性修饰符 说明 public 对所有人开放，Kotlin的类、函数变量不加修饰全部都是public internal 对于本模块开放 protected 对于自己和子类开放 private 私有，不能和open一起使用 抽象类写法： 123abstract class demo() { abstract fun func1():Int} 接口123456interface interDemo { fun func1():String fun func2():String { return &quot;I'm tired&quot; }} 注意 Kotlin不允许多继承，通过接口来间接实现多继承 抽象类不能定义对象 kotlin允许在接口内部实现某个方法 接口内部的所有方法默认都是open类型默认是抽象的 继承的时候，基类的成员属性不用加val或var 几种特殊的类嵌套类注意 嵌套类就是在类里面再写一个类 普通的嵌套类不能访问外部类的数据 例子1234567class outerClass(var otrName:String = &quot;outer name&quot;) { class innerClass(var inrName:String = &quot;inner name&quot;) { fun getInfo():String { return &quot;我的名字是：${inrName}&quot; } }} 内部类 可以访问外部类数据的嵌套类1234567class outerClass(var otrName:String = &quot;outer name&quot;) { inner class innerClass(var inrName:String = &quot;inner name&quot;) { fun getInfo():String { return &quot;内部类的名字是：${inrName}\\n外部类的名字是：${otrName}&quot; } }} 枚举类和密封类先不学 数据类在类名前加上data修饰 特点 这种类自动生成每个字段的get和set方法 equals方法，比较每一个数据 提供copy方法，用于复制数据对象 提供toSting方法 注意 必须有主构造函数，且至少一个参数 输入参数前面必须要加val或var 数据类不能是基类，不能是子类，不能是抽象类，不能是内部类，不能是密封类 模板类类名后面添加&lt;/*泛型列表*/&gt;，表示这是一个模板类 例子123class MyArray&lt;T&gt; (var arr:Array&lt;T&gt;) { }","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87%E4%B9%8B%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"title":"LeetCode-11","text":"2020-07-2755. 跳跃游戏思路 对nums数组，令nums[i] += i,这样表示i位置最远可以走到的距离 算法 从i = 0开始对于当前i，可以从0走到nums[i]，选取0-nums[i]的最大值，如果最大值大于等于n-1，则可以到达最后，若小于，重复这个步骤，除非i=最大值，则不能到达最后 为了降低时间复杂度，创建一个数组v，v[i] = max(nums[k]), k = 0,1,…,i AC代码12345678910111213141516171819202122232425class Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { int n = int(nums.size()); for(int i = 0; i &lt; n; i++) { nums[i] += i; } vector&lt;int&gt; v; int max = nums[0]; for(int i = 0; i &lt; n; i++) { if (nums[i] &gt; max) { max = nums[i]; } v.push_back(max); } int i = 0; while (i != v[i]) { i = v[i]; if (i &gt;= n-1) { return true; } } return false || n == 1; }}; 优化参考已经提交的代码，可以不创建数组v，也用O(n)的时间完成 优化代码123456789101112131415161718class Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { int n = int(nums.size()); int i = 0; int max = nums[0]; while (i &lt;= max) { if (max &lt; i + nums[i]) { max = i + nums[i]; } if (max &gt;= n-1) { return true; } i++; } return false || n == 1; }}; 这道题leetcode上的测速不准，没有参考价值，相同参考代码能跑出不同的速度。 16. 最接近的三数之和AC代码123456789101112131415161718class Solution {public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) { sort(nums.begin(), nums.end()); int mincut = nums[0] + nums[1] + nums[2]; for(int i = 0; i &lt; (int)nums.size() - 2; i ++) { int j = i + 1, k = nums.size() - 1; while(j &lt; k) { int threesum = nums[i] + nums[j] + nums[k]; if(abs(threesum - target) &lt; abs(mincut - target)) mincut = threesum; if(threesum == target) return target; else if(threesum &lt; target) j ++; else k --; } } return mincut; }}; 优化跳过一些不用考虑的值，1.和上次枚举的数相同的值，2.已经等于target的情况 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution {public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) { sort(nums.begin(), nums.end()); int n = nums.size(); int best = 1e7; // 根据差值的绝对值来更新答案 // 枚举 a for (int i = 0; i &lt; n; ++i) { // 保证和上一次枚举的元素不相等 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) { continue; } // 使用双指针枚举 b 和 c int j = i + 1, k = n - 1; while (j &lt; k) { int sum = nums[i] + nums[j] + nums[k]; // 如果和为 target 直接返回答案 if (sum == target) { return target; } if (abs(sum - target) &lt; abs(best - target)) { best = sum; } if (sum &gt; target) { // 如果和大于 target，移动 c 对应的指针 int k0 = k - 1; // 移动到下一个不相等的元素 while (j &lt; k0 &amp;&amp; nums[k0] == nums[k]) { --k0; } k = k0; } else { // 如果和小于 target，移动 b 对应的指针 int j0 = j + 1; // 移动到下一个不相等的元素 while (j0 &lt; k &amp;&amp; nums[j0] == nums[j]) { ++j0; } j = j0; } } } return best; }}; 61. 旋转链表AC代码123456789101112131415161718192021222324class Solution {public: ListNode* rotateRight(ListNode* head, int k) { if(head == NULL) { return head; } int n = 0; ListNode *p = head; while (p-&gt;next != NULL) { n++; p = p-&gt;next; } n++; k %= n; p-&gt;next = head; p = head; for (int i = 0; i &lt; n - k - 1; i++) { p = p-&gt;next; } ListNode* new_head = p-&gt;next; p-&gt;next = NULL; return new_head; }}; 经验看似简单的题，发现了自己的知识漏洞，图遍历的时候要有visit数组记录它是否访问过，此处用map代替。 133. 克隆图AC代码123456789101112131415161718192021222324class Solution {public: Node* cloneGraph(Node* node) { if(node == NULL) return NULL; unordered_map&lt;Node*, Node*&gt; m; queue&lt;Node*&gt; q; q.push(node); Node* head = new Node(node-&gt;val, vector&lt;Node*&gt;{}); m[node]=head; while (!q.empty()) { Node* temp = q.front(); q.pop(); for (Node* child: temp-&gt;neighbors) { if(!m.count(child)) { m[child] = new Node(child-&gt;val, vector&lt;Node*&gt;{}); q.push(child); } m[temp]-&gt;neighbors.push_back(m[child]); } } return head; }}; 120. 三角形最小路径和超时算法 普通的搜索123456789101112131415161718192021222324252627282930class Solution {public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) { int ni = int(triangle.size()); vector&lt;int&gt; v(ni, 0); vector&lt;int&gt; index(ni, 0); int sum = INT_MAX; while(v[0] == 0) { int t_sum = 0; for (int j = 0; j &lt; ni; j++) { t_sum += triangle[j][index[j]]; } if (t_sum &lt; sum) { sum = t_sum; } int i = ni-1; while (i &gt; 0 &amp;&amp; v[i] == 1) { v[i] = 0; i--; } index[i]++; for (int j = i+1; j &lt; ni ; j++) { index[j] = index[j-1]; } v[i] = 1; } return sum; }}; 优化思路一个个枚举会超时，要用动态规划 AC代码12345678910111213141516class Solution {public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) { int ni = int(triangle.size()); vector&lt;int&gt; v(ni, 0); v[0] = triangle[0][0]; for (int i = 1; i &lt; ni; i++) { v[i] = v[i-1] + triangle[i][i]; for (int j = i - 1; j &gt; 0; j--) { v[j] = min(v[j-1],v[j]) + triangle[i][j]; } v[0] += triangle[i][0]; } return *min_element(v.begin(), v.end()); }}; 2020-07-2833. 搜索旋转排序数组AC代码12345678910111213141516171819202122232425262728293031class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { int l = 0, h = int(nums.size())-1; while (l &lt;= h) { int mid = (h-l)/2+l; if (nums[mid] == target) { return mid; } if (nums[mid] &gt; nums[l]) { if (target &gt;= nums[l] &amp;&amp; target &lt; nums[mid]) { h = mid - 1; } else { l = mid + 1; } } else if (nums[mid] == nums[l]) { if (h == l) { return -1; } l++; } else { if (target &lt;= nums[h] &amp;&amp; target &gt; nums[mid]) { l = mid + 1; } else { h = mid - 1; } } } return -1; }}; 思路 二分查找法，由于是两段有序，分别有几种情况，且没有相等元素 nums[mid] &gt; nums[l]，说明l-mid为严格的升序，如果target在nums[l]-nums[mid]之间，h=mid-1，否则l=mid+1。切换到l-h之间搜索 nums[mid] == nums[l]，说明 (l+h)/2 = l, h=l-1 或 h=l h=l-1，令l=h h=l，mid=h=l，说明无解，return -1 nums[mid] &lt; nums[h]，说明mid-h为严格升序，如果target在nums[mid]-nums[h]之间，l=mid+1，否则h=mid-1。切换到l-h之间搜索 74. 搜索二维矩阵AC代码123456789101112131415161718192021222324class Solution {public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) { int m = int(matrix.size()); if (m &lt;= 0) { return false; } int n = int(matrix[0].size()); int num = m*n; int l = 0,h = num-1; while (l &lt;= h) {// 二分查找法 int mid = (h-l)/2+l; if (matrix[(mid)/n][(mid)%n] == target) {//算出mid对应的下标就行 return true; } else if (matrix[(mid)/n][(mid)%n] &gt; target) { h = mid-1; } else { l = mid+1; } } return false; }};","link":"/home/2020/07/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9311/"},{"title":"Kotlin学习笔记——基础语法篇之特殊运算符","text":"参考文献——Kotlin学习之运算符来自简书作者——Hunter_Arley 等值判断 运算符 解释 重载函数 a == b 判断ab是否结构相等，相当于java中a.equals(b)或b.equals(a) a?.equals(b)?:b===null a != b 判断ab是否结构不等，相当于java中!a.equals(b)或!b.equals(a) !(a?.equals(b)？:b===null) === 判断是否结构相等且引用相同 ps: Kotlin中的==用来比较两个元素是否相同，比如字符串的内容，整数，浮点数的值，而不比较引用是否相同，而===表示比较内容是否相同，且引用是否相同 新增运算符 运算符 解释 重载函数 is 判断变量是否为某个类型 a in b 检查元素a是否在b中 b.contains(a) 下标运算符 操作符 函数 a[i] a.get(i) a[i,j] a.get(i,j) a[i_1,…,i_n] a.get(i_1,…,i_n) a[i]=b a.set(i,b) a[i,j]=b a.set(i,j,b) a[i_1,…,i_n]=b a.set(i_1,…,i_n,b) 与Java不同，Kotlin的这个运算符不仅可以用在数组变量后，也可以用在集合变量后，可以方便地调用和操作数组和集合中的元素。 位、逻辑运算符 Java位运算符 Kotlin Kotlin函数 描述 ~a 无 a.inv() 按位取非 a&amp;b a and b a.and(b) 按位与 a | b a or b a.or(b) 按位或 a^b a xor b a.xor(b) 按位异或 a&lt;&lt; b a shl b a.shl(b) 左移b位 a&gt;&gt;b a shr b a.shr(b) 右移b位 a&gt;&gt;&gt;b a ushr b a.ushr(b) 无符号右移b位","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87%E4%B9%8B%E7%89%B9%E6%AE%8A%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"title":"LeetCode-10","text":"2020-07-25Z 字形变换AC代码123456789101112131415161718192021222324252627282930class Solution {public: string convert(string s, int numRows) { if (numRows &lt;= 1) { return s; } int n = s.size(); string temp[numRows]; int t_numRows = 0; int p = 0; while(p &lt; n) { while(p &lt; n &amp;&amp; t_numRows &lt; numRows) { temp[t_numRows] += s[p]; p++; t_numRows++; } t_numRows = numRows -2; while (p &lt; n &amp;&amp; t_numRows &gt; 0) { temp[t_numRows] += s[p]; p++; t_numRows--; } } string res; for(int i = 0 ; i &lt; numRows; i++) { res = res + temp[i]; } return res; }}; 优化思路 两层while循环多次判断p&lt;n,效率底下，实际上只需要当t_numRows==0或t_numRows==numRows-1时改变方向即可 实际上需要的string数组长度是min(n, numRows) 优化代码1234567891011121314151617181920212223class Solution {public: string convert(string s, int numRows) { if (numRows &lt;= 1) { return s; } int n = int(s.size()); int len = min(numRows, n); vector&lt;string&gt; temp(len); int t_numRows = 0; bool goingDown = false; for(int i = 0; i &lt; n; i++) { temp[t_numRows] += s[i]; if (t_numRows == 0 || t_numRows == numRows-1) { goingDown = !goingDown; } t_numRows += goingDown ? 1 :-1; } string res; for (int i = 0; i &lt; len; i++) res += temp[i]; return res; }}; 再次优化可以直接找新旧数列的数字关系，直接计算 优化代码123456789101112131415161718192021222324252627282930313233class Solution {public: string convert(string s, int numRows) { if (numRows &lt;= 1) { return s; } int len_s = int(s.size()); int unit =(2*numRows-2); int n = len_s/unit; int remain = len_s%unit; string res(len_s, 0); for (int i = 0; i &lt; len_s; i++) { int p = 0; if (i%unit == 0) { p = i/unit+1; } else { int r = i%unit + 1,c = i/unit+1; if (r &gt; numRows) { r = unit-r+2; p = 1; } else if (r == numRows) { p = 1-c; } p += n + (n*2)*(r-2) + 2*(c-1) + min(r-1, remain)+1; if (remain &gt; numRows) { p += max(r-(unit-remain+2),0); } } res[p-1] = s[i]; } return res; }}; 最终成绩 执行用时：8 ms, 在所有 C++ 提交中击败了98.89%的用户 内存消耗：7.7 MB, 在所有 C++ 提交中击败了100.00%的用户 ### 75. 颜色分类AC代码 计数12345678910111213141516class Solution {public: void sortColors(vector&lt;int&gt;&amp; nums) { int n[3] = {0}; for(int i : nums) { n[i]++; } int x = 0; for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; n[i]; j++) { nums[j+x] = i; } x += n[i]; } }}; 优化 三指针法123456789101112131415161718192021class Solution {public: void sortColors(vector&lt;int&gt;&amp; nums) { int f,t = int(nums.size())-1,m; f = m = 0; while (m &lt;= t) { if (nums[m] == 0) { swap(nums[m++], nums[f++]); } else if (nums[m] == 2) { swap(nums[m], nums[t--]); } else { m++; } } } void xchg(int&amp; a, int&amp; b) { a = a+b; b = a-b; a = a-b; }}; 129. 求根到叶子节点数字之和AC代码1234567891011121314151617181920212223class Solution {public: int sum = 0; void go(TreeNode* root, int num) { if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) { sum += num*10+root-&gt;val; return; } if (root-&gt;left != NULL) { go(root-&gt;left, num*10+root-&gt;val); } if (root-&gt;right != NULL) { go(root-&gt;right, num*10+root-&gt;val); } } int sumNumbers(TreeNode* root) { if (root == NULL) { return 0; } go(root, 0); return sum; }}; 29. 两数相除AC代码12345678910111213141516171819202122232425262728class Solution {public: unsigned int i2ui(int n) { return (n&lt;0&amp;&amp;n != -2147483648)?-n:((n == -2147483648) ? 2147483648 : n); } int divide(int dividend, int divisor) { bool neg = (dividend&lt;0)^(divisor&lt;0); unsigned int a = i2ui(dividend), b = i2ui(divisor); unsigned int res = 0; unsigned int tb = b; unsigned int add = 1; while((tb &amp; 0x80000000)==0) { tb &lt;&lt;= 1; add &lt;&lt;= 1; } while (a &gt;= b) { if (a &gt;= tb) { res += add; a -= tb; } add &gt;&gt;=1; tb &gt;&gt;= 1; } res = (res &gt; 2147483647 &amp;&amp; !neg) ? INT_MAX : res; int ires = neg ? ((res&gt;2147483648)?INT_MAX:-res) : res; return ires; }}; 思路利用最基本的列竖式法，先转成正数，再计算 优化 不满足题目的假设我们的环境只能存储 32 位有符号整数的条件 类似上面的算法，把所有数转化为负数，再对divisor=0x80000000时特判 优化代码123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: int nabs(int n) { return (n &gt; 0)? -n : n; } int divide(int dividend, int divisor) { int neg = ((dividend&lt;0)^(divisor&lt;0)); dividend = nabs(dividend); divisor = nabs(divisor); int sub = 1; if (divisor==INT_MIN) { return (dividend == INT_MIN) ? 1 : 0; } int t_divisor = -divisor; while((t_divisor &amp; 0x40000000)==0) { t_divisor &lt;&lt;= 1; sub &lt;&lt;= 1; } int res = 0;// cout &lt;&lt; t_divisor &lt;&lt; &quot; &quot; &lt;&lt; sub &lt;&lt; endl; while (dividend &lt;= divisor &amp;&amp; sub != 0) { if (dividend &lt;= -t_divisor) { dividend += t_divisor; res -= sub; } sub &gt;&gt;= 1; t_divisor &gt;&gt;= 1; } if (dividend &lt;= divisor) { res = (res == INT_MIN)? res : res-1;// cout &lt;&lt; res &lt;&lt; endl; } res = !neg ? ((res==-2147483648)?INT_MAX:-res) : res; return res; }}; 最终成绩 执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户 内存消耗：6 MB, 在所有 C++ 提交中击败了100.00%的用户 36. 有效的数独AC代码12345678910111213141516171819202122232425262728293031323334class Solution {public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { for (int i = 0; i &lt; 9; i++) { int r[9] = {0}; int c[9] = {0}; int s[9] = {0}; for (int j = 0; j &lt; 9; j++) { if (board[i][j] != '.') { r[board[i][j]-'1']++; } if (board[j][i] != '.') { c[board[j][i]-'1']++; } } int a = i/3; int b = i%3; for (int ii = 3*a; ii &lt; 3*(a+1); ii++) { for (int ij = 3*b; ij &lt; 3*(b+1); ij++) { if (board[ii][ij] != '.') { s[board[ii][ij]-'1']++; } } } for (int j = 0; j &lt; 9; j++) { if (r[j] &gt; 1 || c[j] &gt; 1 || s[j] &gt; 1) { return false; } } } return true; }}; 5. 最长回文子串AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution {public: map&lt;int ,int, greater&lt;int&gt;&gt; m; int rb=0,re=0; string longestPalindrome(string s) { int n = int(s.size()); if (n &lt;= 0) { return &quot;&quot;; } go(s, 0, n); for (int off = 1; off &lt; n; off++) { go(s, off, n); go(s, 0, n-off); } while (!m.empty()) { int sub = m.begin()-&gt;first; int sum = m.begin()-&gt;second; int beg = (sum-sub)/2; int end = (sum+sub)/2; if(go(s, beg,end) &amp;&amp; ((re-rb) &gt; (end-beg))) break; } return s.substr(rb, re-rb); } bool go(string&amp; s,int beg, int end) { int pos = isPalindrome(s, beg, end); if (pos != beg) { end -= pos-beg; beg = pos; m[end-beg]=end+beg; return false; }else { m.erase(end-beg); if ((end-beg) &gt; (re-rb)) { rb = beg; re = end; } return true; } } int isPalindrome(string&amp; s, int beg, int end) { int res = -1; for(int i = 0; i &lt; (end-beg)/2; i++) { if(s[beg+i] != s[end-1 - i] &amp;&amp; i &gt; res) res = i; } return beg+res+1; }}; 优化参考优秀的题解，大致思想是把每个字符作为中心，向左右展开 123456789101112131415161718192021222324252627282930class Solution {public: int l=0,h=0; string longestPalindrome(string s) { int n = int(s.size()); if (n &lt;= 1) { return s; } for (int i = 0; i &lt; n; i++) { i = findLongest(s, i, n); } return s.substr(l, h-l+1); } int findLongest(const string&amp; s,int i, int n) { int high = i; while (high &lt; n-1 &amp;&amp; s[high+1] == s[i]) { high++; }// 中部字符全部相同 int ans = high; while (i &gt; 0 &amp;&amp; high &lt; n-1 &amp;&amp; s[i-1]==s[high+1]) { i--; high++;//向两边展开 } if ((high - i) &gt; h-l) { h = high; l = i; //更新最长串的位置 } return ans; }}; 62. 不同路径思路大佬们都是用dp，而我是推公式，就是这么简单 AC代码12345678910111213141516171819202122232425262728class Solution {public: int uniquePaths(int m, int n) { if (m &gt; n) { m = m+n; n = m-n; m = m-n; } int res = n; if (m &lt; 2) { return 1; } if (m == 2) { return n; } vector&lt;int&gt; v(m-2, 0); for (int i = 1; i &lt;= n-1; i++) { v[0] += i; for (int j = 1; j &lt; m - 2; j++) { v[j] += v[j-1]; } } for (int i = 0; i &lt; m -2; i++) { res += v[i]; } return res; }}; 最终成绩 执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户 内存消耗：5.9MB, 在所有 C++ 提交中击败了100.00%的用户 63. 不同路径 IIAC代码123456789101112131415161718192021222324252627282930313233class Solution {public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) { int n = int(obstacleGrid.size()); int m = int(obstacleGrid[0].size()); bool swap = false; if (m &gt; n) { m = m+n; n = m-n; m = m-n; swap = true; } vector&lt;long long&gt; v(m+1, 0); long long t_v0 = 1; for (int i = 0; i &lt; n; i++) { if ((!swap &amp;&amp; obstacleGrid[n-i-1][m-1]) || (swap &amp;&amp; obstacleGrid[m-1][n-1-i])) { v[0] = 0; } else { v[0] = t_v0; } t_v0 = v[0]; for(int j = 1; j &lt; m; j++) { if ((!swap &amp;&amp; obstacleGrid[n-i-1][m-1-j]) || (swap &amp;&amp; obstacleGrid[m-1-j][n-1-i])) { v[j] = 0; } else { v[j] += v[j-1]; } } } return (int)v[m-1]; }}; 优化1不需要转置，这个问题来自于试错过程中的错误判断看了题解以后发现自己的代码和它惊人的相似，原来我无师自通学会动规了？？哈哈哈哈 优化1代码12345678910111213141516171819202122232425class Solution {public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) { int n = int(obstacleGrid.size()); int m = int(obstacleGrid[0].size()); vector&lt;long long&gt; v(m+1, 0); long long t_v0 = 1; for (int i = 0; i &lt; n; i++) { if (obstacleGrid[n-i-1][m-1]) { v[0] = 0; } else { v[0] = t_v0; } t_v0 = v[0]; for(int j = 1; j &lt; m; j++) { if (obstacleGrid[n-i-1][m-1-j]) { v[j] = 0; } else { v[j] += v[j-1]; } } } return (int)v[m-1]; }};","link":"/home/2020/07/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9310/"},{"title":"LeetCode-14","text":"927. 三等分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution {public: vector&lt;int&gt; threeEqualParts(vector&lt;int&gt;&amp; arr) { int sum = countOne(arr); int len = arr.size(); if(sum % 3 != 0) { return {-1,-1}; } if(sum == 0) { return {0, len -1}; } int p1,p2,p3; p1 = p2 = p3 = 0; int i = 0; int cur = 0; while(i &lt; len) { if(arr[i] == 1) { if(cur == 0) { p1 = i; } else if(cur == sum/3) { p2 = i; } else if(cur == 2*sum/3) { p3 = i; } cur++; } i++; } //把1平均分成3份，p1 p2 p3分别找到三段的第一个1的位置 // printf(&quot;%d %d %d\\n&quot;, p1, p2, p3); int x = p1,y = p2,z = p3; int farclen = len - p3; if(p1 + farclen &gt; p2 || p2 + farclen &gt; p3) { return {-1, -1}; } while(x &lt; p2 &amp;&amp; y &lt; p3 &amp;&amp; z &lt; len) { if(arr[x] != arr[y] || arr[y] != arr[z]) { return {-1, -1}; } x++;y++;z++; } // printf(&quot;%d %d %d\\n&quot;, x, y, z); return {p1+farclen-1, p2+farclen}; } int countOne(vector&lt;int&gt;&amp; arr) { int count = 0; for(int a : arr) { count += a; } return count; }}; 难，看懂解析思路后才写出来的 刚开始的思路是找0，把1分成了n段，取n/3 , 2n/3和 n段后面的0，然后向右移动双指针比较 后来发现有超级长的输入，超时了 解析的思路与我刚好相反，先数1的个数，如果是0或者不能被3整除，说明不能分成三段 1的个数为n，找到第0 n/3 2n/3个1，记为p1, p2, p3 p3到后末尾的长度就是三个子串的长度，如果p1 或 p2 + 字串长度分别大于p2 p3，说明无解 然后向后比较，若后面的数完全相同则有解 1636. 按照频率将数组升序排序123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; frequencySort(vector&lt;int&gt;&amp; nums) { int freq[205] = {0}; for(int v : nums) { freq[100+v]++; } int invfreq[205][205] = {0}; int count[205] = {0}; for(int i = 0; i &lt; 205; i++) { invfreq[freq[i]][count[freq[i]]++] = i-100; } int numsc = 0; for(int i = 1; i &lt; 205; i++) { for(int j = count[i]-1; j &gt;= 0; j--) { //printf(&quot;%d %d\\n&quot;, i, invfreq[i][j]); for(int k = 0; k &lt; i; k++) { nums[numsc++] = invfreq[i][j]; } } } return nums; }}; 简单，但是还是错了几次（没认真读题，没发现同频率的要降序排列） 先用map计算每个数字的出现次数，hash为100+i 再把map做倒排索引，由于hash是100+i，那么倒排后的索引也自然以升序排好序了 根据倒排索引进行输出。 1624. 两个相同字符之间的最长子字符串1234567891011121314151617181920212223242526class Solution {public: int maxLengthBetweenEqualCharacters(string s) { int left[26] = {0}; int right[26] = {0}; int len = s.size(); for(int i = 0; i &lt; len; i++) { if(left[s[i]-'a'] == 0) { left[s[i]-'a'] = i+1; } } for(int i = len-1; i &gt;= 0; i--) { if(right[s[i]-'a'] == 0) { right[s[i]-'a'] = i+1; } } int max = 0; int flag = false; for(int i = 0; i &lt; 26; i++) { int x = right[i] - left[i] - 1; max = max &gt; x ? max : x; if(x+1 &gt; 0) flag = true; } return flag ? max : -1; }}; 简单，数一下每个字母第一次出现的位置和最后一次出现的位置，相减-1取最大值，再对不存在的情况进行特殊标记，也就是所有字母第一次出现的位置和最后一次出现的位置全都相同的情况 827. 最大人工岛优化到最短的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution { int indexMap[505][505] = {0}; //岛屿点，对应一个岛 int areaMap[505*505] = {0}; //岛屿点，对应一个岛 int n; const vector&lt;int&gt; d = {0, -1, 0, 1, 0};public: int largestIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { n = grid.size(); int islandCount = 0; int max2area = 0; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(grid[i][j] == 1) { if(indexMap[i][j] == 0) { indexMap[i][j] == ++islandCount; dfs(grid, i, j, islandCount); max2area = max2area &gt; areaMap[islandCount] ? max2area : areaMap[islandCount]; } } } } for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { unordered_set&lt;int&gt; neighbour; int areai = 1; if(grid[i][j] == 0) { for(int k = 0; k &lt; 4; k++) { if(valid(i, j , k) &amp;&amp; grid[i + d[k]][j + d[k+1]] == 1) { if(neighbour.count(indexMap[i + d[k]][j + d[k+1]]) == 0) { areai += areaMap[indexMap[i + d[k]][j + d[k+1]]]; neighbour.insert(indexMap[i + d[k]][j + d[k+1]]); } } } max2area = max2area &gt; areai ? max2area : areai; } } } return max2area; } bool valid(int i, int j, int k) { int x = i + d[k]; int y = j + d[k+1]; return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &lt; n; } void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, int index) { if(indexMap[x][y] != 0) return; indexMap[x][y] = index; areaMap[index]++; for(int k = 0; k &lt; 4; k++) { if(valid(x, y, k) &amp;&amp; grid[x + d[k]][y + d[k+1]] == 1) { dfs(grid, x + d[k], y + d[k+1], index); } } }}; 但是这样效率特别低，主要是valid函数太低下了 不用valid12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Solution {private: int indexMap[505][505] = {0}; //岛屿点，对应一个岛 int areaMap[505*505] = {0}; //岛屿点，对应一个岛 int n;public: int largestIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { n = grid.size(); int islandCount = 0; bool find0 = false; bool find1 = false; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(grid[i][j] == 1) { find1 = true; if(indexMap[i][j] == 0) { ++islandCount; indexMap[i][j] == islandCount; dfs(grid, i, j, islandCount); } } else { find0 = true; } } } int max2area = 0; if(!find0 &amp;&amp; find1) return n*n; if(find0 &amp;&amp; !find1) return 1; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { set&lt;int&gt; neighbour; int areai = 1; if(grid[i][j] == 0) { if(j-1 &gt;= 0 &amp;&amp; grid[i][j-1] == 1) { neighbour.insert(indexMap[i][j-1]); } if(i-1 &gt;= 0 &amp;&amp; grid[i-1][j] == 1) { neighbour.insert(indexMap[i-1][j]); } if(j+1 &lt; n &amp;&amp; grid[i][j+1] == 1) { neighbour.insert(indexMap[i][j+1]); } if(i+1 &lt; n &amp;&amp; grid[i+1][j] == 1) { neighbour.insert(indexMap[i+1][j]); } for(set&lt;int&gt;::iterator ite = neighbour.begin(); ite != neighbour.end(); ite++) { areai += areaMap[*ite]; } max2area = max2area &gt; areai ? max2area : areai; } } } return max2area; } void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, int index) { if(indexMap[x][y] != 0) return; indexMap[x][y] = index; areaMap[index]++; if(y-1 &gt;= 0 &amp;&amp; grid[x][y-1] == 1) { dfs(grid, x, y-1, index); } if(y+1 &lt; n &amp;&amp; grid[x][y+1] == 1) { dfs(grid, x, y+1, index); } if(x+1 &lt; n &amp;&amp; grid[x+1][y] == 1) { dfs(grid, x+1, y, index); } if(x-1 &gt;= 0 &amp;&amp; grid[x-1][y] == 1) { dfs(grid, x-1, y, index); } }}; 首次通过的代码，比较冗长123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110class Solution {private: struct Island { int area; int index; Island(int a, int i):area(a), index(i) {} }; bool edgeMap[505][505]; //边界点，对应的哪个岛 Island* islandMap[505][505]; //岛屿点，对应一个岛 // vector&lt;Island*&gt; allIsland; //方便回收内存 int n;public: int largestIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { n = grid.size(); int island_count = 0; bool find0 = false; bool find1 = false; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(grid[i][j] == 1) { find1 = true; Island *island = nullptr; if(islandMap[i][j] == nullptr) { island = new Island(0, island_count++); dfs(grid, i, j, island); } else { island = islandMap[i][j]; } if(j-1 &gt;= 0 &amp;&amp; grid[i][j-1] == 0) { edgeMap[i][j-1] = true; } if(i-1 &gt;= 0 &amp;&amp; grid[i-1][j] == 0) { edgeMap[i-1][j] = true; } } else { find0 = true; Island *island = nullptr; if(j-1 &gt;= 0 &amp;&amp; grid[i][j-1] == 1) { edgeMap[i][j] = true; } if(i-1 &gt;= 0 &amp;&amp; grid[i-1][j] == 1) { edgeMap[i][j] = true; } } } } // int max_area = 0; int max2area = 0; if(!find0 &amp;&amp; find1) return n*n; if(find0 &amp;&amp; !find1) return 1; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { set&lt;Island*&gt; neighbour; int areai = 1; if(edgeMap[i][j]) { if(j-1 &gt;= 0 &amp;&amp; grid[i][j-1] == 1) { Island *island = islandMap[i][j-1]; neighbour.insert(island); } if(i-1 &gt;= 0 &amp;&amp; grid[i-1][j] == 1) { Island *island = islandMap[i-1][j]; neighbour.insert(island); } if(j+1 &lt; n &amp;&amp; grid[i][j+1] == 1) { Island *island = islandMap[i][j+1]; neighbour.insert(island); } if(i+1 &lt; n &amp;&amp; grid[i+1][j] == 1) { Island *island = islandMap[i+1][j]; neighbour.insert(island); } for(set&lt;Island*&gt;::iterator ite = neighbour.begin(); ite != neighbour.end(); ite++) { areai += (*ite)-&gt;area; } max2area = max2area &gt; areai ? max2area : areai; } } } return max2area; // return max_area &gt; max2area ? max_area : max2area; } void addDot(int x, int y) { edgeMap[x][y] = true; } void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, Island *island) { if(islandMap[x][y] != nullptr) return; islandMap[x][y] = island; island-&gt;area++; // printf(&quot;add %p x=%d y=%d, area=%d\\n&quot;, island, x, y, island-&gt;area); if(y-1 &gt;= 0 &amp;&amp; grid[x][y-1] == 1) { dfs(grid, x, y-1, island); } if(y+1 &lt; n &amp;&amp; grid[x][y+1] == 1) { dfs(grid, x, y+1, island); } if(x+1 &lt; n &amp;&amp; grid[x+1][y] == 1) { dfs(grid, x+1, y, island); } if(x-1 &gt;= 0 &amp;&amp; grid[x-1][y] == 1) { dfs(grid, x-1, y, island); } }}; 写了很久，其实和题解的思路是一模一样的","link":"/home/2022/10/22/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9314/"},{"title":"LeetCode-13","text":"1640. 能否连接形成数组123456789101112131415161718192021222324class Solution {public: bool canFormArray(vector&lt;int&gt;&amp; arr, vector&lt;vector&lt;int&gt;&gt;&amp; pieces) { int arr_map[105] = {0}; int len_arr = arr.size(); for(int i = 0; i &lt; len_arr; i++) { arr_map[arr[i]] = i+1; } int pie_len = pieces.size(); for(int i = 0; i &lt; pie_len; i++) { int i_len = pieces[i].size(); int diff = arr_map[pieces[i][0]]; if(diff == 0) { return false; } for(int j = 1; j &lt; i_len; j++) { if(diff != arr_map[pieces[i][j]] - j) { return false; } } } return true; }}; 4ms，和最快的思路刚好相反，用map存储arr的index，最快的思路是反过来，用map存一个piece的第一个index 123456789101112131415161718192021222324class Solution {public: bool canFormArray(vector&lt;int&gt;&amp; arr, vector&lt;vector&lt;int&gt;&gt;&amp; pieces) { int arr_map[105] = {0}; int len_arr = arr.size(); int pie_len = pieces.size(); for(int i = 0; i &lt; pie_len; i++) { arr_map[pieces[i][0]] = i+1; } int i = 0; while(i &lt; len_arr) { int row = arr_map[arr[i]]; if(row == 0) return false; vector&lt;int&gt;&amp; subv = pieces[row-1]; int i_len = subv.size(); for(int j = 0; j &lt; i_len; j++, i++) { if(arr[i] != subv[j]) { return false; } } } return true; }}; 707. 设计链表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273struct List { List *next; int val; List(int val0, List* next0 = nullptr):val(val0), next(next0) {}};class MyLinkedList {private: List *root; List *tail; int size; inline List* getNode(int&amp; index) { List *move = root; while(index &gt; 0 &amp;&amp; move-&gt;next != nullptr) { move = move-&gt;next; index--; } return move; }public: MyLinkedList() { root = new List(0); tail = root; size = 0; } int get(int index) { List *move = getNode(index); return (move-&gt;next == nullptr) ? -1 : move-&gt;next-&gt;val; } void addAtHead(int val) { List* node = new List(val, root-&gt;next); root-&gt;next = node; if(root == tail) { tail = node; } size++; } void addAtTail(int val) { List* node = new List(val, tail-&gt;next); tail-&gt;next = node; tail = node; size++; } void addAtIndex(int index, int val) { List *move = getNode(index); if(index &gt; 0) { return; } List* node = new List(val, move-&gt;next); move-&gt;next = node; if(move == tail) { tail = node; } size++; } void deleteAtIndex(int index) { List *move = getNode(index); List *target = move-&gt;next; if(target != nullptr) { move-&gt;next = target-&gt;next; if(target == tail) { tail = move; } delete target; size--; } }}; 60ms -&gt; 36ms 之前内部函数getNode有两个参数，第二个参数off用于返回index和找到的节点的距离差距。将这个参数优化掉，维护一个size替代。 1652. 拆炸弹12345678910111213141516171819202122232425262728293031323334353637class Solution {public: vector&lt;int&gt; decrypt(vector&lt;int&gt;&amp; code, int k) { int len = code.size(); if(k &gt; 0) { vector&lt;int&gt; after(len, 0); for(int i = 0; i &lt; k; i++) { after[0] += code[(i+1)%len]; } for(int i = 1; i &lt; len; i++) { if(i + k &lt; len) { after[i] = after[i-1] - code[i] + code[(i+k)]; } else { after[i] = after[i-1] - code[i] + code[(i+k)- len]; } // cout &lt;&lt; (i+k+1)%len &lt;&lt; &quot; &quot; &lt;&lt; code[(i+k)%len] &lt;&lt; endl; } return after; } if(k &lt; 0) { vector&lt;int&gt; before(len, 0); for(int i = 0; i &lt; -k; i++) { before[0] += code[(i + k + len)%len]; } for(int i = 1; i &lt; len; i++) { if ((i -1 + k) &gt;= 0) { before[i] = before[i-1] - code[(i -1 + k)] + code[i-1]; } else { before[i] = before[i-1] - code[(i -1 + k + len)] + code[i-1]; } // cout &lt;&lt; (i+k+len)%len &lt;&lt; endl; } return before; } return vector&lt;int&gt;(len, 0); }}; 4ms -&gt; 0ms 之前使用取余达到题目所说的“循环数组”的效果，后来看题解上直接把数组copy一份，创建一个2n长的数组避免越界。这里不取余，越界后直接加或减去数组长度。 788. 旋转数字123456789101112131415161718192021222324252627class Solution {public: int rotatedDigits(int n) { int goodDigits[10] = {0, 1, 5, -1, -1, 2, 9, -1, 8, 6}; int count = 0; for(int i = 1; i &lt;= n; i++) { bool flag1 = false; bool flag2 = false; int cur_i = i; while(cur_i != 0) { int mod = cur_i % 10; if(goodDigits[mod] != mod) { flag1 = true; } if(goodDigits[mod] == -1) { flag2 = true; } cur_i /= 10; } if(flag1 &amp;&amp; !flag2) { count++; // printf(&quot;%d, &quot;, i); } } return count; }}; 第一次提交没有注意读题，数字的每一位都要能反转，且至少有一位反转后与原来不同，导致逻辑错误。 面试题 17.19. 消失的两个数字12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution {public: vector&lt;int&gt; missingTwo(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int a = -1,b = -1; for(int i = 0; i &lt; len; i++) { while(nums[i] - 1 != i &amp;&amp; nums[i] != -1) { if(nums[i]-1 == len) { swap(nums[i], a); } else if(nums[i]-1 == len+1) { swap(nums[i], b); } else { swap(nums[i], nums[nums[i] - 1]); } } } while(a - 1 != len &amp;&amp; a != -1) { if(a-1 == len) { swap(a, a); } else if(a-1 == len+1) { swap(a, b); } else { swap(a, nums[a - 1]); } } while(b - 1 != len+1 &amp;&amp; b != -1) { if(b-1 == len) { swap(b, a); } else if(b-1 == len+1) { swap(b, b); } else { swap(b, nums[b - 1]); } } vector&lt;int&gt; ret(2); int count = 0; for(int i = 0; i &lt; len; i++) { if(nums[i] - 1 != i) { ret[count] = i+1; count++; if(count &gt;= 2) break; } } if(count &lt; 2 &amp;&amp; a-1 != len) { ret[count] = len+1; count++; } if(count &lt; 2 &amp;&amp; b-1 != len) { ret[count] = len+2; count++; } return ret; } void inline swap(int &amp;a, int &amp;b) { int temp = a; a = b; b = temp; }}; 之前做过类似的题目，数字是1 - N，就把他们一直交换，数字N就放到位置N，直到当前循环计数变量i的位置对应的数字和i相同或为-1 注意到参数传入的数组只有N-2的长度，而题目要求使用空间O(1)的原地算法，创建两个变量a, b并赋初值为-1，分别作为原来数组的延长，遇到这两个位置时进行特殊判断。 后来看代码的时候发现第48行的判断写错了，应该是count &lt; 2 &amp;&amp; b-1 != len+1，但是代码依旧通过测试了，看来测试样例还是不够全。 面试题 01.02. 判定是否互为字符重排123456789101112131415161718class Solution {public: bool CheckPermutation(string s1, string s2) { int len = s1.size(); if(len != s2.size()) return false; int m1[26] = {0}, m2[26] = {0}; for(int i = 0; i &lt; len; i++) { m1[s1[i]-'a']++; m2[s2[i]-'a']++; } for(int i = 0; i &lt; 26; i++) { if(m1[i] != m2[i]) { return false; } } return true; }}; 简单题，直接统计字母频率就好 面试题 17.09. 第 k 个数123456789101112131415161718192021222324252627class Solution {public: int getKthMagicNumber(int k) { vector&lt;int&gt; kth(k); int p1,p2,p3; p1 = p2 = p3 = 0; kth[0] = 1; for(int i = 1; i &lt; k; i++) { int a, b,c; // printf(&quot;%d %d %d %d\\n&quot;, p1, p2, p3, i); a = kth[p1] * 3; b = kth[p2] * 5; c = kth[p3] * 7; kth[i] = min(a, min(b,c)); if(kth[i] == a) { p1++; } if(kth[i] == b) { p2++; } if(kth[i] == c) { p3++; } } return kth[k-1]; }}; 比较难，尝试了很多次，最后看题解才写出来。 刚开始想先用素数筛算出足够的素数，再利用素数数组，从1，3，5，7之后开始，所有的非素数奇数中一个个筛选出不含有除3，5，7外其他素数的数。但是后来发现这样会超时，样例输入251时需要350万个素数，光是算素数就已经超时了。 最后才用了题解的dp，每次算出一个，如果是乘3就把3的指针向后移，5和7同理，这样就可以逐个由小到大算出第k个数。 面试题 01.09. 字符串轮转12345678910111213141516171819202122class Solution {public: bool isFlipedString(string s1, string s2) { int len = s1.size(); int i = 0; if(len == 0) return true; for(i; i &lt; len; i++) { bool flag = true; for(int j = 0; j &lt; len; j++) { if(s1[(i+j)%len] != s2[j]) { flag = false; break; } } if(flag) { return true; } } return false; }}; 最开始暴力直接搜，看了题解后可以构造string s = s1 + s1，然后使用kmp搜索s中是否有s2子串 面试题 01.08. 零矩阵1234567891011121314151617181920212223242526272829class Solution {public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int m = matrix.size(); if(m &lt;= 0) return; int n = matrix[0].size(); vector&lt;bool&gt; r(m, false), c(n, false); // bool r[10000] = {false}, c[10000] = {false}; for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; n; j++) { if(matrix[i][j] == 0) { r[i] = true; c[j] = true; } } } for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; n; j++) { if(r[i]) { matrix[i][j] = 0; } if(c[j]) { matrix[i][j] = 0; } } } }}; 简单题，直接记录某行某列是否有0，然后根据每行每列的flag更新就好了 1694. 重新格式化电话号码1234567891011121314151617181920212223242526272829303132class Solution {public: string reformatNumber(string number) { string ret; int len = number.size(); int count_n = 0; int count = 0; for(int i = 0; i &lt; len; i++) { if(number[i] &gt;= '0' &amp;&amp; number[i] &lt;= '9') { ret.push_back(number[i]); count++; if(count%3 == 0) { ret.push_back('-'); } count_n = count%3; } } // printf(&quot;%d %d\\n&quot;, count_n, count); if(count_n == 0) { ret.pop_back(); } else if(count_n == 1 &amp;&amp; count &gt;= 3) { int off = count / 3; count += off; char t = ret[count-2]; ret[count-2] = ret[count-3]; ret[count-3] = t; // printf(&quot;%c %c\\n&quot;, ret[count-2], ret[count-3]); } return ret; }}; 简单题，第一次提交时忘记之前添加过字符-,想通过最后余数对结尾4个的字符的情况进行特殊处理，直接用字符的计数器count忘记加上添加的-的个数 777. 在LR字符串中交换相邻字符12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution {public: int len; bool canTransform(string start, string end) { int i,j = 0; int len = start.size(); if(end.size() != len) { return false; } char t[10005] = {0}; int t_i = 0; for(char c: start) { if(c != 'X') { t[t_i] = c; t_i++; } } int t_len = t_i; t_i = 0; for(char c : end) { if(c == 'X') { continue; } if(t_i &lt; t_len &amp;&amp; c == t[t_i]) { t_i++; } else { return false; } } if(t_i != t_len) return false; while(j &lt; len) { if(end[j] == 'L') { int it = j; while(it &lt; len &amp;&amp; start[it] == 'X') { it++; } if(it &lt; len &amp;&amp; start[it] == 'L') { char temp_c = start[it]; start[it] = start[j]; start[j] = temp_c; } else { return false; } } else if(end[j] == 'R') { int it = j; while(it &gt;= 0 &amp;&amp; start[it] == 'X') { it--; } if(it &gt;= 0 &amp;&amp; start[it] == 'R') { char temp_c = start[it]; start[it] = start[j]; start[j] = temp_c; } else { return false; } } else { } j++; } return j == len &amp;&amp; start[j-1] == end[len-1]; }}; 比较难 第一次的思路是直接忽略X，比较L和R的序列是否相同，这个显然是没有完全考虑完全 第二次打算进行搜索，生成所有左移右移后的情况，和end进行对比，但是没有考虑到L，R可以多次移动，L多次移动的话就要进行多次的回溯，非常麻烦 第三次真正理解题意，根据end对start进行移动，在结合第一次的思路比较一下忽略X的LR序列是否完全相同。 1784. 检查二进制字符串字段1234567891011121314class Solution {public: bool checkOnesSegment(string s) { int count = 0; int i = 0; int length = s.size(); while(i &lt; length) { while(i &lt; length &amp;&amp; s[i] == '1') i++; count++; while(i &lt; length &amp;&amp; s[i] == '0') i++; } return count &lt;= 1; }}; 简单，有手就行，就是统计有几群连续的1 921. 使括号有效的最少添加12345678910111213141516171819class Solution {public: int minAddToMakeValid(string s) { stack&lt;char&gt; sta; int count = 0; for(char c : s) { if(c == '(') { sta.push(c); } else { if(sta.empty()) { count++; } else { sta.pop(); } } } return count + sta.size(); }}; 题目的样例好像有错误还是我没看懂，总之是括号匹配，问有几个不匹配的 每次出现右括号且没有左括号匹配时，计数器++，字符串变量结束后，在加上栈中剩余的没匹配的左括号的个数就好了。 811. 子域名访问计数12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;string&gt; subdomainVisits(vector&lt;string&gt;&amp; cpdomains) { unordered_map&lt;string, int&gt; m; for(string&amp; s : cpdomains) { char domain[105] = {0}; int num; sscanf(s.c_str(), &quot;%d %s&quot;, &amp;num, domain); int length = strlen(domain); int i = 0; m[domain] +=num; while(i &lt; length) { while(i &lt; length &amp;&amp; domain[i] != '.') i++; if(i &gt;= length) break; char subdomain[105] = {0}; for(int j = 0; j &lt; length - i - 1; j++) { subdomain[j] = domain[i+1+j]; } m[subdomain] += num; i++; } } vector&lt;string&gt; v; for(unordered_map&lt;string, int&gt;::iterator i = m.begin(); i != m.end(); i++) { char str[105] = {0}; sprintf(str, &quot;%d %s&quot;, i-&gt;second, i-&gt;first.c_str()); v.push_back(str); } return v; }}; 比较简单，找个map统计每个域名的出现个数就行，然后从左往右找.，找到后拿到子串，map中统计所有子串的出现个数。","link":"/home/2022/10/22/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9313/"},{"title":"LeetCode-16","text":"934. 最短的桥1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution {public: int indexMap[105][105] = {0}; //岛屿点，对应一个岛 int n; int edgex[105*105] = {0}; int edgey[105*105] = {0}; int edgei[105*105] = {0}; int edgej[105*105] = {0}; int edgecount = 0; int edgeicount = 0; int shortestBridge(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { n = grid.size(); int islandCount = 0; int p1x,p1y; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(grid[i][j] == 1 &amp;&amp; indexMap[i][j] == 0) { ++islandCount; dfs(grid, i, j, islandCount); } } } int min=INT_MAX; for(int i = 0; i &lt; edgecount; i++) { for(int j = 0; j &lt; edgeicount; j++) { int path = abs(edgex[i]-edgei[j]) + abs(edgey[i] - edgej[j]) - 1; if(min &gt;= path) { min = path; } } } return min; } void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, int index) { if(x &lt; 0 || y &lt; 0 || x &gt;= n || y &gt;= n) return; if(indexMap[x][y] != 0 || grid[x][y] != 1) return; indexMap[x][y] = index; bool flag = (y-1 &gt;= 0 &amp;&amp; grid[x][y-1] == 0) || (y+1 &lt; n &amp;&amp; grid[x][y+1] == 0) || (x+1 &lt; n &amp;&amp; grid[x+1][y] == 0) || (x-1 &gt;= 0 &amp;&amp; grid[x-1][y] == 0); dfs(grid, x, y-1, index); dfs(grid, x, y+1, index); dfs(grid, x+1, y, index); dfs(grid, x-1, y, index); if(flag) { if(indexMap[x][y]==1) { edgex[edgecount]=x; edgey[edgecount]=y; edgecount++; } else if(indexMap[x][y]==2) { edgei[edgeicount]=x; edgej[edgeicount]=y; edgeicount++; } } }}; 和之前写的一道题有点像，827. 最大人工岛827. 最大人工岛我先dfs找到所有连通子图和包围岛的0点，然后找这些点中有无同时包围多个岛的，把他们的面积加起来取最大值 这道题也可以使用相同的方法，找到每个岛屿的边界点，然后计算边界点的距离(只有两个岛，两个岛之间肯定是可以连通的，且不管使用那条途径，最短距离一定是 $ abs(x_1 - x_2) + abs(y_1-y_2)-1 $) 看答案1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution {public: void dfs(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; grid, queue&lt;pair&lt;int, int&gt;&gt; &amp;qu) { if (x &lt; 0 || y &lt; 0 || x &gt;= grid.size() || y &gt;= grid[0].size() || grid[x][y] != 1) { return; } qu.emplace(x, y); grid[x][y] = -1; dfs(x - 1, y, grid, qu); dfs(x + 1, y, grid, qu); dfs(x, y - 1, grid, qu); dfs(x, y + 1, grid, qu); } int shortestBridge(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); vector&lt;vector&lt;int&gt;&gt; dirs = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}}; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (grid[i][j] == 1) { queue&lt;pair&lt;int, int&gt;&gt; qu; dfs(i, j, grid, qu); int step = 0; while (!qu.empty()) { int sz = qu.size(); for (int i = 0; i &lt; sz; i++) { auto [x, y] = qu.front(); qu.pop(); for (int k = 0; k &lt; 4; k++) { int nx = x + dirs[k][0]; int ny = y + dirs[k][1]; if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n) { if (grid[nx][ny] == 0) { qu.emplace(nx, ny); grid[nx][ny] = -1; } else if (grid[nx][ny] == 1) { return step; } } } } step++; } } } } return 0; }}; 对于一个为1的点，先dfs吧所有在同一个岛屿内的1放入队列q中对于队列中的每个节点，把包围他们的0入队，反复操作，直到遇到1也就是在岛屿附近画圈，遇到1对应的圈数就是结果。 915. 分割数组123456789101112131415161718192021222324252627282930class Solution {public: int partitionDisjoint(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; max(n+1); max[0] = INT_MIN; vector&lt;int&gt; min(n); min[n-1] = nums[n-1]; for(int i = 0; i &lt; n; i++) { if(nums[i] &gt; max[i]) { max[i+1] = nums[i]; } else { max[i+1] = max[i]; } } for(int i = n-2; i &gt;= 0; i--) { if(nums[i] &lt; min[i+1]) { min[i] = nums[i]; } else { min[i] = min[i+1]; } } for(int i = 1; i &lt; n; i++) { if(max[i] &lt;= min[i]) { return i; } } return -1; }}; 没想到会这么慢 优化1 max数组没必要 不用vector 12345678910111213141516171819202122232425class Solution {public: int partitionDisjoint(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int min[100005] = {0}; min[n-1] = nums[n-1]; for(int i = n-2; i &gt;= 0; i--) { if(nums[i] &lt; min[i+1]) { min[i] = nums[i]; } else { min[i] = min[i+1]; } } int max = nums[0]; for(int i = 1; i &lt; n; i++) { if(max &lt;= min[i]) { return i; } if(max &lt; nums[i]) { max = nums[i]; } } return -1; }}; 1768. 交替合并字符串12345678910111213141516171819202122class Solution {public: string mergeAlternately(string word1, string word2) { string ret; int len1 = word1.size(), len2 = word2.size(); int i = 0; for(; i &lt; len1 &amp;&amp; i &lt; len2; i++) { ret.push_back(word1[i]); ret.push_back(word2[i]); } if(len1 &lt; len2) { for(; i &lt; len2; i++) { ret.push_back(word2[i]); } } else { for(; i &lt; len1; i++) { ret.push_back(word1[i]); } } return ret; }}; 1235. 规划兼职工作123456789101112131415161718192021class Solution {public: int jobScheduling(vector&lt;int&gt;&amp; startTime, vector&lt;int&gt;&amp; endTime, vector&lt;int&gt;&amp; profit) { int n = startTime.size(); vector&lt;int&gt; index(n); for(int i = 0; i &lt; n; i++) { index[i] = i; } sort(index.begin(), index.end(), [&amp;](int a, int b)-&gt;bool {return endTime[a] &lt; endTime[b];}); vector&lt;int&gt; dp(n+1); for(int i = 1; i &lt;= n; i++) { int j = index[i-1]; int k = i-2; for(; k &gt;= 0; k--) { if(endTime[index[k]] &lt;= startTime[j]) break; } dp[i] = max(dp[i-1], dp[k+1] + profit[j]); } return dp[n]; }}; 开始想用贪心，给时薪排序，一次选择，但是发现这样得到的不是profit最大，而是工作时间更短的情况下的收益最大看了答案后自己写的，发现是一个非常典型的dp问题 官方题解123456789101112131415161718192021class Solution {public: int jobScheduling(vector&lt;int&gt; &amp;startTime, vector&lt;int&gt; &amp;endTime, vector&lt;int&gt; &amp;profit) { int n = startTime.size(); vector&lt;vector&lt;int&gt;&gt; jobs(n); for (int i = 0; i &lt; n; i++) { jobs[i] = {startTime[i], endTime[i], profit[i]}; } sort(jobs.begin(), jobs.end(), [](const vector&lt;int&gt; &amp;job1, const vector&lt;int&gt; &amp;job2) -&gt; bool { return job1[1] &lt; job2[1]; }); vector&lt;int&gt; dp(n + 1); for (int i = 1; i &lt;= n; i++) { int k = upper_bound(jobs.begin(), jobs.begin() + i - 1, jobs[i - 1][0], [&amp;](int st, const vector&lt;int&gt; &amp;job) -&gt; bool { return st &lt; job[1]; }) - jobs.begin(); dp[i] = max(dp[i - 1], dp[k] + jobs[i - 1][2]); } return dp[n]; }}; 复习 769. 最多能完成排序的块这个题之前没有看太懂，现在再看一次 题解1123456789101112131415161718class Solution { public int maxChunksToSorted(int[] arr) { int n = arr.length, ans = 0; for (int i = 0, j = 0, min = n, max = -1; i &lt; n; i++) { min = Math.min(min, arr[i]); max = Math.max(max, arr[i]); if (j == min &amp;&amp; i == max) { ans++; j = i + 1; min = n; max = -1; } } return ans; }}作者：AC_OIer链接：https://leetcode.cn/problems/max-chunks-to-make-sorted/solution/by-ac_oier-4uny/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 这个题解比官方的好理解一点，j比i落后一点当i，j区间内拥有i，j两个数时，且i是最大值，j的最小值，这时对这个区间排序，可以让max = i到i的位置，min = j到j的位置也就是说i，j区间内所有数字都找到了自己的位置。这就找到了一个划分，重复这样做，就可以找到所有区间 题解2123456789101112131415161718192021222324class Solution {public: int maxChunksToSorted(vector&lt;int&gt;&amp; arr) { stack&lt;int&gt; stk; for (int v : arr) { if (stk.empty() || v &gt;= stk.top()) { stk.push(v); } else { int mx = stk.top(); stk.pop(); while (!stk.empty() &amp;&amp; stk.top() &gt; v) { stk.pop(); } stk.push(mx); } } return stk.size(); }};作者：lcbin链接：https://leetcode.cn/problems/max-chunks-to-make-sorted/solution/by-lcbin-jgrv/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 以数据 单调栈单调栈：分为单调递增和单调递减栈(栈内元素成递增或者递减性) 单调栈的作用 把序列中每个元素放到单调栈中进行维护就可以在 O(n) 的时间复杂度内求出区间每个元素为最大值/最小值时 单调栈的性质如下： 元素加入栈前会把栈顶破坏单调性的元素删除 一般使用单调栈的题目具有以下的两点 离自己最近（栈的后进先出的性质） 比自己大（小）、高(低) 板子： 12345678910111213stack&lt;int&gt; stk;for (遍历这个数组){ if (栈空 || 栈顶元素大于等于当前比较元素){ 入栈; } else{ while (栈不为空 &amp;&amp; 栈顶元素小于当前元素){ 栈顶元素出栈; 更新结果; } 当前数据入栈; }} 1822. 数组元素积的符号1234567891011121314class Solution {public: int arraySign(vector&lt;int&gt;&amp; nums) { bool ret = false; for(int n : nums) { if(n==0){ return 0; } else if (n&lt;0) { ret=!ret; } } return ret?-1:1; }}; 比较简单，就是数数的问题","link":"/home/2022/10/25/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9316/"},{"title":"LeetCode-15","text":"904. 水果成篮123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: int totalFruit(vector&lt;int&gt;&amp; fruits) { int len = fruits.size(); vector&lt;int&gt; v(len); int i = 0; int cur = fruits[i]; i++; int max_diff = 1; int typea = fruits[0], typeb = -1, typec = -1; vector&lt;int&gt; last(len+1); int curr = 0; int j = 1; while(j &lt; len) { while(j &lt; len &amp;&amp; fruits[j] == fruits[curr]) { j++; } last[j] = curr; curr = j; j++; } while(i &lt; len) { int diff = 1; typeb = typec = -1; while(i &lt; len) { if(fruits[i] != typea &amp;&amp; fruits[i] != typeb) { if(typeb == -1) { typeb = fruits[i]; } else if(typec == -1) { typec = fruits[i]; } } if(typec == -1) { diff++; } else { break; } i++; } max_diff = diff &gt; max_diff ? diff : max_diff; if(i-1 &gt;= 0 &amp;&amp; i &lt; len){ typea = fruits[i-1]; i = last[i]+1; } } return max_diff; }}; 想法很简单，就是从左往右遍历，数当前遇到了几种水果，当遇到第三种水果后，更新一下装入水果的最大值，三种水果记录为typea, typeb, typec然后回溯，找到前一个节点在左侧最后一个typea后第一次出现的位置（其实也是typea最后出现的位置的后两个位置） 优化(空间，放弃last数组)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: int totalFruit(vector&lt;int&gt;&amp; fruits) { int len = fruits.size(); vector&lt;int&gt; v(len); int i = 0; int cur = fruits[i]; i++; int max_diff = 1; int typea = fruits[0], typeb = -1, typec = -1; while(i &lt; len) { int diff = 1; typeb = typec = -1; int lasta = i-1, lastb = 0; while(i &lt; len) { if(fruits[i] != typea &amp;&amp; fruits[i] != typeb) { if(typeb == -1) { typeb = fruits[i]; } else if(typec == -1) { typec = fruits[i]; } } if(fruits[i] == typea) { lasta = i; } else if(fruits[i] == typeb) { lastb = i; } if(typec == -1) { diff++; } else { break; } i++; } max_diff = diff &gt; max_diff ? diff : max_diff; if(i-1 &gt;= 0 &amp;&amp; i &lt; len){ if(fruits[i-1] == typea) { i = lastb + 2; } else if(fruits[i-1] == typeb) { typea = typeb; i = lasta + 2; } // printf(&quot;%d, %d, %d\\n&quot;, i, lasta, lastb); } } return max_diff; }}; 1441. 用栈操作构建数组1234567891011121314151617181920class Solution {public: vector&lt;string&gt; buildArray(vector&lt;int&gt;&amp; target, int n) { int cur = 0; int len = target.size(); vector&lt;string&gt; ret; for(int i = 0; i &lt; len; i++) { int diff = target[i] - cur; cur = target[i]; if(diff &gt; 1) { for(int j = 0; j &lt; diff-1; j++) { ret.push_back(&quot;Push&quot;); ret.push_back(&quot;Pop&quot;); } } ret.push_back(&quot;Push&quot;); } return ret; }}; 优化，使用emplace_back()push_back()方法要调用构造函数和复制构造函数，这也就代表着要先构造一个临时对象，然后把临时的copy构造函数拷贝或者移动到容器最后面。而emplace_back()在实现时，则是直接在容器的尾部创建这个元素，省去了拷贝或移动元素的过程。 123456789101112131415161718class Solution {public: vector&lt;string&gt; buildArray(vector&lt;int&gt;&amp; target, int n) { int cur = 0; int len = target.size(); vector&lt;string&gt; ret; for(int i = 0; i &lt; len; i++) { int diff = target[i] - cur - 1; cur = target[i]; for(int j = 0; j &lt; diff; j++) { ret.emplace_back(&quot;Push&quot;); ret.emplace_back(&quot;Pop&quot;); } ret.emplace_back(&quot;Push&quot;); } return ret; }}; 769. 最多能完成排序的块1234567891011121314151617class Solution {public: int maxChunksToSorted(vector&lt;int&gt;&amp; arr) { int count = 0; int len = arr.size(); int maxx = 0; for(int i = 0; i &lt; len; i++) { if(arr[i] &gt;= maxx) { maxx = arr[i]; } if(maxx == i) { count++; } } return count; }}; 如果在找到下一个最大值之前，当前最大值能找到最大位置，则存在一个组 940. 不同的子序列 IIcomming soon 902. 最大为 N 的数字组合123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution {public: vector&lt;int&gt; digitscount; int len; int bit; int hasdigit[10] = {0}; int atMostNGivenDigitSet(vector&lt;string&gt;&amp; digits, int n) { digitscount = vector&lt;int&gt;(11); string nstr = toString(n); bit = nstr.size(); len = digits.size(); for(int i = 0; i &lt; len; i++) { hasdigit[digits[i][0]-'0']=1; } digitscount[digits[0][0]-'0'+1]++; for(int i = 1; i &lt; len; i++) { for(int j = digits[i-1][0]-'0'+1; j &lt;= digits[i][0]-'0'; j++) { digitscount[j+1] = digitscount[j]; } digitscount[digits[i][0]-'0'+1]++; } for(int i = digits[len-1][0]-'0'+1; i &lt; 10; i++) { digitscount[i+1] = digitscount[i]; } int count = 0; if(len == 1) { count = bit-1; } else { count = len*(1-pow(len, bit-1))/(1-len); } return count + cal(bit-1, digits, nstr); } int cal(int i, vector&lt;string&gt;&amp; digits, string&amp; nstr) { if(i &lt; 0) return 1; int x = digitscount[nstr[i]-'0']; return x*pow(len, i) + hasdigit[nstr[i]-'0']*cal(i-1, digits, nstr); } long long pow(long long x, long long n) { long long res = 1; while(n) { if(n&amp;1){ res *= x; } n /= 2; x *= x; } return res; } string toString(int n) { string ret = &quot;&quot;; while(n) { ret.push_back(n%10 + '0'); n/=10; } return ret; }}; 思想很简单，首先有n个数字可以用，每个数字使用次数不限，所以求指数目标数字是n位数，那么任意的1位数到n-1位数的任意组合都是可以使用的对于n位数的情况，逐次考虑每一位，对于第i位， 若第i位使用的数字小于目标数字的第i位，后面的数字可以任意组合 若第i位使用的数字等于目标数字的第i位（前提是digits数组中有这个数），则 $ 1 \\times (第i+1位) $ 的情况 两种情况之和就是结果 需要注意的是，pow使用long long防止结果溢出 优化 避免反复使用pow函数 当hasdigit已经是0了，无需后续计算 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution {public: vector&lt;int&gt; digitscount; int len; int bit; int hasdigit[10] = {0}; int atMostNGivenDigitSet(vector&lt;string&gt;&amp; digits, int n) { digitscount = vector&lt;int&gt;(11); string nstr = toString(n); bit = nstr.size(); len = digits.size(); for(int i = 0; i &lt; len; i++) { hasdigit[digits[i][0]-'0']=1; } digitscount[digits[0][0]-'0'+1]++; for(int i = 1; i &lt; len; i++) { for(int j = digits[i-1][0]-'0'+1; j &lt;= digits[i][0]-'0'; j++) { digitscount[j+1] = digitscount[j]; } digitscount[digits[i][0]-'0'+1]++; } for(int i = digits[len-1][0]-'0'+1; i &lt; 10; i++) { digitscount[i+1] = digitscount[i]; } int count = 0; if(len == 1) { count = bit-1; } else { count = len*(1-pow(len, bit-1))/(1-len); } return count + cal(bit-1, digits, nstr, pow(len, bit-1)); } int cal(int i, vector&lt;string&gt;&amp; digits, string&amp; nstr, int power) { if(i &lt; 0) return 1; int x = digitscount[nstr[i]-'0']; if(hasdigit[nstr[i]-'0'] == 0) { return x*power; } return x*power + hasdigit[nstr[i]-'0']*cal(i-1, digits, nstr, power/len); } long long pow(long long x, long long n) { long long res = 1; while(n) { if(n&amp;1){ res *= x; } n /= 2; x *= x; } return res; } string toString(int n) { string ret = &quot;&quot;; while(n) { ret.push_back(n%10 + '0'); n/=10; } return ret; }}; 快速幂算法： 从代码反推可知，实际上把n看作二进制数 假设$ n = 110011001b $ ，则$ x^n = x + x^8 + x^{16} + x^{128} + x^{256} $ 等价于$$ \\sum_0^n n_i \\times x^{2^i} (i从右到左为0,1,2…) $$ 817. 链表组件1234567891011121314151617181920212223class Solution {public: int numComponents(ListNode* head, vector&lt;int&gt;&amp; nums) { bool m[10005] = {false}; for(int num : nums) { m[num] = true; } int component_count = 0; while(head != nullptr &amp;&amp; !m[head-&gt;val]) { head = head-&gt;next; } while(head) { while(head != nullptr &amp;&amp; m[head-&gt;val]) { head = head-&gt;next; } while(head != nullptr &amp;&amp; !m[head-&gt;val]) { head = head-&gt;next; } component_count++; } return component_count; }}; 适当展开循环，可以减少不必要的判断 1790. 仅执行一次字符串交换能否使两个字符串相等12345678910111213141516171819202122class Solution {public: bool areAlmostEqual(string s1, string s2) { int len = s1.size(); if(s2.size() != len) return false; if(s1 == s2) return true; int diff1 = -1; for(int i = 0; i &lt; len; i++) { if(s1[i] != s2[i]) { if(diff1 == -1) { diff1 = i; } else { char a = s2[diff1]; s2[diff1] = s2[i]; s2[i] = a; return s1 == s2; } } } return false; }}; 可以轻易地用脚趾头想到，两个字符串只能有两处不同，长度相同 当找到第二个字符串后进行交换，如果交换后和s1相等，则ok，否则不ok 优化 防止重复比较diff1 与 diff2之间的字符123456789101112131415161718192021222324class Solution {public: bool areAlmostEqual(string s1, string s2) { int len = s1.size(); if(s2.size() != len) return false; if(s1 == s2) return true; int diff1 = -1; for(int i = 0; i &lt; len; i++) { if(s1[i] != s2[i]) { if(diff1 == -1) { diff1 = i; } else { for(int j = i+1; j &lt; len; j++) { if(s1[j] != s2[j]) { return false; } } return s2[diff1] == s1[i] &amp;&amp; s2[i] == s1[diff1]; } } } return false; }}; 856. 括号的分数12345678910111213141516171819202122232425class Solution {public: int scoreOfParentheses(string s) { stack&lt;int&gt; score; int len = s.size(); score.push(0); for(int i = 0; i &lt; len; i++) { if(s[i] == '(') { score.push(0); } else { int sc1 = score.top(); score.pop(); int sc2 = score.top(); score.pop(); if(sc1 == 0) { sc1+=1; } else { sc1*=2; } score.push(sc1+sc2); } } return score.top(); }}; 进行栈的模拟，遇到左括号push一个0，表示该左括号内部的平衡括号分数总和当遇到一个右括号，pop一个score，如果是0，说明是()，则对该score+1，如果不是0，则该score乘以2从栈中再pop一个score记为score2，score2与score相加后入栈为了防止最外端的括号无法取出两个score，在遍历s前先push一个0最终栈顶元素就是最后结果 1700. 无法吃午餐的学生数量12345678910111213141516171819202122class Solution {public: int countStudents(vector&lt;int&gt;&amp; students, vector&lt;int&gt;&amp; sandwiches) { queue&lt;int&gt; stuqueue; int len = students.size(); for(int i = 0; i &lt; len; i++) { stuqueue.push(students[i]); } for(int i = 0; i &lt; len; i++) { int count = 0; while(count &lt; len &amp;&amp; stuqueue.front() != sandwiches[i]) { int front = stuqueue.front(); stuqueue.pop(); stuqueue.push(front); count++; } if(count == len) return stuqueue.size(); stuqueue.pop(); } return stuqueue.size(); }}; 优化，直接模拟效率太低了123456789101112131415161718class Solution {public: int countStudents(vector&lt;int&gt;&amp; students, vector&lt;int&gt;&amp; sandwiches) { int len = students.size(); int s1 = accumulate(students.begin(), students.end(), 0); int s0 = len - s1; for(int i = 0; i &lt; len; i++) { if(sandwiches[i] == 0 &amp;&amp; s0 != 0) { s0--; } else if(sandwiches[i] == 1 &amp;&amp; s1 != 0) { s1--; } else { return s0+s1; } } return s0+s1; }}; 当学生无法拿栈顶的东西时，一定是因为剩下的所有人都不吃当前栈顶元素。 与队列的先后顺序无关 从栈顶到栈底，遇到某个食物只要在队列里随便找一个学生就好了。如果恰好能吃完，则返回0，如果遇到某个食物没人吃了，就返回剩下的人数。 根据题意，我们可以知道栈顶的三明治能否被拿走取决于队列剩余的学生中是否有喜欢它的. 只要当前栈顶的东西学生不喜欢，就会一直向后排队，直到出现喜欢的东西为止，所以可以不考虑当前队列的顺序。 779. 第K个语法符号123456789101112131415161718192021222324class Solution {public: int kthGrammar(int n, int k) { stack&lt;int&gt; route; while(k&gt;1) { route.push(k%2); k = k%2 + k/2; } //route.push(1); string a = &quot;01&quot;,b = &quot;10&quot;; string cur = a; int next = 0; while(!route.empty()) { if(cur[next] == '0') { cur = a; } else { cur = b; } next=1-route.top(); route.pop(); } return cur[next]-'0'; }}; 类似完全二叉树的思想，10的父节点是1，01的父节点是0比如需要第n行的第k个，那么其父节点是第n-1行第$ \\lceil n/2 \\rceil = n/2 + n%2 $个数由于只有0和1两种情况，对于k，如果k%2 == 1,则是其父节点的左子节点，否则是右子节点故可以计算 $ (\\lceil n/2 \\rceil)%2 $，依次找到根节点，根节点一定是0，stack中最后一个数一定是1则从0生成01，再根据stack中剩下的数，如果是1，则是01的左节点0，又生成01；如果是0，则是01的右节点1，生成10，用这种方法逐渐生成到叶节点以k=14为例，祖先依次是7，4，2，1，stack中依次是，1，0，0，1，0则 0 -&gt; 01 -&gt; 10 -&gt; 01 -&gt; 01 -&gt; 1 0010110011010010110100110010110 这个算法甚至不需要用n这个参数 优化-使用位运算1234567891011121314151617181920212223class Solution {public: int kthGrammar(int n, int k) { stack&lt;int&gt; route; while(k&gt;1) { route.push(k%2); k = k%2 + k/2; } int cur = 0x01; int next = 1; while(!route.empty()) { cur = (cur &gt;&gt; next)&amp;0x01; if(cur == 0) { cur = 0x01; } else { cur = 0x02; } next=route.top(); route.pop(); } return (cur&gt;&gt;next)&amp;0x01; }}; 524. 通过删除字母匹配到字典里最长单词1234567891011121314151617181920212223242526class Solution {public: string findLongestWord(string s, vector&lt;string&gt;&amp; dictionary) { // sort(dictionary.begin(), dictionary.end()); int lend = dictionary.size(); int lens = s.size(); int maxlen = 0; string maxstr = &quot;&quot;; for(int i = 0; i &lt; lend; i++) { int j = 0, k = 0; int leni = dictionary[i].size(); for(; k &lt; leni &amp;&amp; j &lt; lens; j++) { if(s[j] == dictionary[i][k]) k++; } if(leni &gt;= maxlen &amp;&amp; k &gt;= leni) { if(maxlen == leni) { maxstr = dictionary[i] &gt; maxstr ? maxstr : dictionary[i]; } else { maxstr = dictionary[i]; } maxlen = leni; } } return maxstr; }}; 暴力，干就完了 优化(抄答案就完事)1234567891011121314151617181920212223242526class Solution: def findLongestWord(self, s: str, dictionary: List[str]) -&gt; str: m = len(s) f = [[0] * 26 for _ in range(m)] f.append([m] * 26) for i in range(m - 1, -1, -1): for j in range(26): if ord(s[i]) == j + 97: f[i][j] = i else: f[i][j] = f[i + 1][j] print(f) res = &quot;&quot; for t in dictionary: match = True j = 0 for i in range(len(t)): if f[j][ord(t[i]) - 97] == m: match = False break j = f[j][ord(t[i]) - 97] + 1 if match: if len(t) &gt; len(res) or (len(t) == len(res) and t &lt; res): res = t return res 大概就是生成一个表，如果f[i][j]不是m，就表示第i位或第i位之后可以取到这个字符为了保证按照顺序使用字母表s中的字符，j=f[i][j]，表示下一次要从这个位置开始取字符 81. 搜索旋转排序数组 II12345678910111213141516171819202122232425262728class Solution {public: bool search(vector&lt;int&gt;&amp; nums, int target) { int len = nums.size(); int k = 1; for(int i = 1; i &lt; len; i++, k++) { if(nums[i] &lt; nums[i-1]) { break; } } k = len - k; // cout &lt;&lt; k &lt;&lt; endl; int l = 0, r = len; while(l &lt;= r) { int mid = (r - l)/2 + l; // cout &lt;&lt; nums[(mid - k + len)%len] &lt;&lt; endl; if(target == nums[(mid - k + len)%len]) { return true; } else if(target &lt; nums[(mid - k + len)%len]) { r = mid-1; } else { l = mid+1; } } // cout &lt;&lt; l &lt;&lt; r &lt;&lt; endl; return target == nums[(r - k + len)%len] || target == nums[(l - k + len)%len]; }}; O(n)的算法不太好 优化123456789101112131415161718192021222324252627282930313233343536class Solution {public: bool search(vector&lt;int&gt; &amp;nums, int target) { int n = nums.size(); if (n == 0) { return false; } if (n == 1) { return nums[0] == target; } int l = 0, r = n - 1; while (l &lt;= r) { int mid = (l + r) / 2; if (nums[mid] == target) { return true; } if (nums[l] == nums[mid] &amp;&amp; nums[mid] == nums[r]) { ++l; --r; } else if (nums[l] &lt;= nums[mid]) { if (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) { r = mid - 1; } else { l = mid + 1; } } else { if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - 1]) { l = mid + 1; } else { r = mid - 1; } } } return false; }}; 分成了两个递增区间，左边较大的和右边较小的如果mid落在左边区间，如果mid大于target 且 target也落在较大的区间，向左移动，否则向右移动如果mid落在右边区间，如果mid小于target 且 target也落在较大的区间，向右移动，否则向左移动如果特殊情况[1,1,0,1,1,1]，则直接缩小区间大小，逐渐逼近 540. 有序数组中的单一元素1234567891011121314151617181920212223242526272829303132class Solution {public: int singleNonDuplicate(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int l = 0, r = len; while(l &lt;= r) { int mid = (r - l)/2 + l; if(mid%2 == 0) { if(mid &gt; 0 &amp;&amp; nums[mid-1] == nums[mid]) { r = mid-1; continue; } if (mid &lt; len-1 &amp;&amp; nums[mid+1] == nums[mid]) { l = mid+1; continue; } return nums[mid]; } else { if(mid &gt; 0 &amp;&amp; nums[mid-1] == nums[mid]) { l = mid+1; continue; } if (mid &lt; len-1 &amp;&amp; nums[mid+1] == nums[mid]) { r = mid-1; continue; } return nums[mid]; } } return nums[l]; }}; 如果下标是偶数，如果左边没有单个数字，那么我右边应该和我一样，那么单个数字就在我右边，否则就在我左边如果下标是奇数，如果左边没有单个数字，那么我左边应该和我一样，那么单个数字就在我右边，否则就在我左边 优化如果mid是奇数，处理成偶数 1234567891011121314151617class Solution {public: int singleNonDuplicate(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int l = 0, r = len-1; while(l &lt; r) { int mid = (r - l)/2 + l; mid -= mid &amp; 1; if (nums[mid+1] == nums[mid]) { l = mid+2; } else { r = mid; } } return nums[l]; }}; 154. 寻找旋转排序数组中的最小值 II12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {public: int findMin(vector&lt;int&gt;&amp; nums) { int len = nums.size(); if (len == 1) { return nums[0]; } if (len == 2) { return min(nums[0], nums[1]); } int l = 0, r = len-1; while (l &lt;= r) { int mid = (l + r) / 2; if (nums[l] == nums[mid] &amp;&amp; nums[mid] == nums[r]) { ++l; --r; } else if (nums[l] &lt;= nums[mid]) { if(nums[mid] &lt;= nums[r]) return nums[l]; if(mid &lt; len-1) { if (nums[mid] &lt;= nums[mid+1]) { l = mid + 1; } else { return nums[mid+1]; } } else { return nums[mid]; } } else { if(mid &gt; 0) { if (nums[mid] &lt; nums[mid-1]) { return nums[mid]; } else { r = mid -1; } } else { return nums[mid]; } } } return nums[r]; }}; 优化，去掉不必要的判断1234567891011121314151617181920212223242526272829class Solution {public: int findMin(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int l = 0, r = len-1; while (l &lt; r) { int mid = (l + r) / 2; if (nums[l] == nums[mid] &amp;&amp; nums[mid] == nums[r]) { ++l; --r; } else if (nums[l] &lt;= nums[mid]) { if(nums[mid] &lt;= nums[r]) return nums[l]; if (nums[mid] &lt;= nums[mid+1]) { l = mid + 1; } else { return nums[mid+1]; } } else { if (nums[mid] &lt; nums[mid-1]) { return nums[mid]; } else { r = mid -1; } } } return nums[r]; }}; 题解思路123456789101112131415161718class Solution {public: int findMin(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int l = 0, r = len-1; while (l &lt; r) { int mid = (l + r) / 2; if (nums[mid] == nums[r]) { --r; } else if (nums[r] &lt;= nums[mid]) { l = mid + 1; } else { r = mid; } } return nums[r]; }}; 不需要关注左边的情况，之前的代码比较对称，可以看出可以简化mid比r大，说明落在了左侧较大的区间，右移如果mid比r小，说明落在了右侧的较小区间，左移，但不确定我是不是最小值，故r=mid不减1 901. 股票价格跨度12345678910111213141516171819202122class StockSpanner {public: vector&lt;int&gt; stocks; int len; StockSpanner() { len = 0; } int next(int price) { stocks.push_back(price); len++; int m = 0; for(int i = len-1; i &gt;= 0; i--) { if(stocks[i] &lt;= price) { m++; } else { break; } } return m; }}; 显然太慢了 优化1234567891011121314151617181920212223242526272829303132333435363738394041424344class StockSpanner {public: vector&lt;int&gt; peak; vector&lt;int&gt; stocks; int len; int peaklen; int l1, l2; StockSpanner() { len = 0; peaklen = 0; } int next(int price) { len++; stocks.push_back(price); if(len == 1) { return 1; } if(len == 2) { if(stocks[len-2] &gt; price) { peaklen++; peak.push_back(len-2); } return 1 + (stocks[len-2] &lt;= price); } int a = stocks[len-1], b = stocks[len-2], c = stocks[len-3]; if(b &gt;= a &amp;&amp; b &gt; c) { peaklen++; peak.push_back(len-2); } int pk = peaklen-1; while(pk &gt;= 0 &amp;&amp; stocks[peak[pk]] &lt;= price) { pk--; } if(pk &lt; 0) { return len; } int i; for(i = peak[pk]; i &lt; len &amp;&amp; stocks[i] &gt; price; i++) { } if(i == len-1) return 1; return len - i; }}; 股价的变化是波动的，会出现波峰和波谷，找到前一个比我大的波峰，向后查找，就可以找到对应的位置 再优化找到波峰，还可以记录波谷，这样波峰波谷之间可以二分查找 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class StockSpanner {public: vector&lt;pair&lt;int, int&gt;&gt; peak; vector&lt;int&gt; stocks; int len; int peaklen; int valleylen; int l1, l2; StockSpanner() { len = 0; peaklen = 0; valleylen = 0; } int next(int price) { len++; stocks.push_back(price); if(len == 1) { return 1; } if(len == 2) { if(stocks[len-2] &gt; price) { peaklen++; peak.push_back(pair&lt;int,int&gt;(len-2, INT_MAX)); } return 1 + (stocks[len-2] &lt;= price); } int a = stocks[len-1], b = stocks[len-2], c = stocks[len-3]; if(b &gt;= a &amp;&amp; b &gt; c) { peaklen++; peak.push_back(pair&lt;int, int&gt;(len-2, INT_MAX)); } else if(b &lt;= a &amp;&amp; b &lt; c) { peak[peaklen-1].second = len-2; } int pk = peaklen-1; while(pk &gt;= 0 &amp;&amp; stocks[peak[pk].first] &lt;= price) { pk--; } if(pk &lt; 0) { return len; } if(peak[pk].second == INT_MAX) return 1; auto ite = lower_bound(stocks.begin()+peak[pk].first,stocks.begin()+peak[pk].second+1,price, greater&lt;int&gt;()); if(ite == stocks.end()) return 1; return stocks.end() - ite; }}; debug没de出来 看答案123456789101112131415161718192021class StockSpanner {public: StockSpanner() { this-&gt;stk.emplace(-1, INT_MAX); this-&gt;idx = -1; } int next(int price) { idx++; while (price &gt;= stk.top().second) { stk.pop(); } int ret = idx - stk.top().first; stk.emplace(idx, price); return ret; }private: stack&lt;pair&lt;int, int&gt;&gt; stk; int idx;}; 好像是一样的思路，但是我像个傻子 347. 前 K 个高频元素1234567891011121314151617181920212223242526class Solution {public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int, int&gt; frequent; int len = nums.size(); for(int i = 0; i &lt; len; i++) { frequent[nums[i]]++; } sort(nums.begin(), nums.end(), [&amp;](int a, int b) -&gt; bool { if(frequent[a] != frequent[b]) { return frequent[a] &gt; frequent[b]; } return a &lt; b; }); vector&lt;int&gt; res; res.push_back(nums[0]); int count = 1; for(int i = 1; count &lt; k; i++) { if(nums[i] != nums[i-1]) { res.push_back(nums[i]); count++; } } return res; }}; 优化三次遍历 1234567891011121314151617181920212223class Solution {public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int, int&gt; frequent; map&lt;int, set&lt;int&gt;&gt; inv; int len = nums.size(); for(int i = 0; i &lt; len; i++) { frequent[nums[i]]++; } for(int i = 0; i &lt; len; i++) { inv[frequent[nums[i]]].insert(nums[i]); } vector&lt;int&gt; res; int count = 0; for(auto ite = inv.rbegin(); ite != inv.rend() &amp;&amp; count &lt; k; ite++) { for(auto jte = ite-&gt;second.begin(); jte != ite-&gt;second.end(); jte++) { res.push_back(*jte); count++; } } return res; }};","link":"/home/2022/10/22/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9315/"},{"title":"LeetCode-19","text":"1710. 卡车上的最大单元数1234567891011121314151617181920class Solution {public: int maximumUnits(vector&lt;vector&lt;int&gt;&gt;&amp; boxTypes, int truckSize) { sort(boxTypes.begin(), boxTypes.end(), [](vector&lt;int&gt;&amp; x, vector&lt;int&gt;&amp; y)-&gt;bool { return x[1] &gt; y[1]; }); int n = boxTypes.size(); int ret = 0; for(int i = 0; i &lt; n; i++) { if(truckSize) { ret += min(truckSize, boxTypes[i][0])*boxTypes[i][1]; truckSize -= min(truckSize, boxTypes[i][0]); } else { break; } } return ret; }};// 50 + 27 + 14 = 91 简单题，排个序就行 775. 全局倒置与局部倒置1234567891011class Solution {public: bool isIdealPermutation(vector&lt;int&gt;&amp; nums) { for (int i = 0; i &lt; nums.size(); i++) { if (abs(nums[i] - i) &gt; 1) { return false; } } return true; }}; 最开始想复杂了，想用差分数组统计个数 39. 组合总和1234567891011121314151617181920212223242526class Solution {public: int n; int target; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { this-&gt;target = target; n = candidates.size(); vector&lt;int&gt; vec; search(0, 0, vec, move(candidates)); return res; } void search(int index, int sum, vector&lt;int&gt; &amp; vec, vector&lt;int&gt;&amp;&amp; candidates) { if(sum == target) { res.push_back(vec); return; } if(sum &gt; target) return; vec.push_back(candidates[index]); search(index, sum+candidates[index], vec, move(candidates)); vec.pop_back(); if(index+1 &lt; n) { search(index+1, sum, vec, move(candidates)); } }}; 硬搜，不要重复就好了 792. 匹配子序列的单词数超时1123456789101112131415161718192021222324252627282930313233class Solution {public:int n; int numMatchingSubseq(string s, vector&lt;string&gt;&amp; words) { n = s.size(); int count = 0; int len = words.size(); for(int i = 0; i &lt; len; i++) { if(isSubstr(move(s), move(words[i]))) { count++; } } return count; } bool isSubstr(string&amp;&amp; s, string&amp;&amp; word) { int nw = word.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(nw, 0)); dp[0][0]=(word[0]==s[0]); for(int i=1;i&lt;n;i++) { dp[i][0] = max(dp[i-1][0], int(word[0]==s[i])); } for(int i=1;i&lt;nw;i++){ dp[0][i] = max(dp[0][i-1], int(s[0]==word[i])); } for(int j = 1; j &lt; nw; j++) { for(int i = 1; i &lt; n; i++) { dp[i][j] = max(dp[i-1][j-1] + int(s[i] == word[j]),max(dp[i-1][j],dp[i][j-1])); } } //cout &lt;&lt; dp[n-1][nw-1] &lt;&lt; endl; return dp[n-1][nw-1]==nw; }}; 超时212345678910111213141516171819202122232425262728class Solution {public:int n; int numMatchingSubseq(string s, vector&lt;string&gt;&amp; words) { n = s.size(); int count = 0; int len = words.size(); unordered_map&lt;string, bool&gt; m; for(int i = 0; i &lt; len; i++) { if(m.count(words[i])) { count++; } else if(isSubstr(move(s), move(words[i]))) { m[words[i]] = true; count++; } } return count; } bool isSubstr(string&amp;&amp; s, string&amp;&amp; word) { int nw = word.size(); for(int i = 0, j = 0; i &lt; nw; i++) { for(;j&lt;n &amp;&amp; word[i] != s[j]; j++); if(j == n) return false; j++; } return true; }};","link":"/home/2022/11/15/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9319/"},{"title":"LeetCode-18","text":"1668. 最大重复子字符串1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: int maxRepeating(string sequence, string word) { int len1 = sequence.size(); int len2 = word.size(); int maxk = 0, k = 0; for(int i = 0; i &lt; len1;) { bool flag = true; int next = i+1; bool flag1 = false; for(int j = 0; j &lt; len2; j++) { if(sequence[i+j] != word[j]) { flag = false; break; } if(!flag1 &amp;&amp; j != 0 &amp;&amp; sequence[i+j] == word[0]) { next = i+j; flag1=true; } } // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; maxk &lt;&lt; endl; if(flag) { k++; i += len2; } else { maxk = max(k, maxk); if(k == 0) { i+=1; } else { i = i-len2+1; } k = 0; } // cout &lt;&lt; i &lt;&lt; endl; } return max(maxk, k); }}; 笨方法，从右向左找，适当回溯 754. 到达终点数字解法11234567891011121314151617181920class Solution {public: int reachNumber(int target) { target = abs(target); int n = (sqrt(8.0*target+1)-1)/2; //8.0,防止int溢出 int sum = (n+1)*n/2; if(sum == target) { return n; } int diff = target-sum; if((n % 2 == 1 &amp;&amp; diff % 2 == 0) || (n % 2 == 0 &amp;&amp; diff % 2 == 1)) { n += 1; } else if(diff %2 == 1) { n += 2; } else { n += 3; } return n; }}; 这道题直接暴力搜索是不可行的，算法成为$ O( 2^{ target } ) $ 级别 考虑到只求步数，负数target可以转化成正数处理首先计算 $ sum = 1 + 2 + 3 + … + i + … + n &lt;= target $, 如果 $ sum==target $，则n就是步数否则对sum进行调整，记 $ diff = target-sum &lt;= n $ (一定小于n+1)，所以需要先减小sum，再加上几个数，使得新的sum等于target情况一，第i步改为向左，再加上n+1, 也就是 $ sum - 2i + n+1 $，调整前后的差为 $ delta = n + 1 -2i $, $ i = 1,2,3,…,n; delta = n-1, n-3, n-5 … $。这种情况对于diff奇数n偶数，或diff偶数n奇数的情况适用，总计步数n+1情况二，第i步改为向左，再加上n+1和n+2，也就是 $ sum - 2i + n+1 + n+2 $，调整前后的差为 $ delta = 2(n-i) + 3 $, $ i = 1,2,3,…,n; delta = 3, 5, 7, 9, … $。这种情况对于diff奇数且diff &gt;= 3的情况适用，总计步数n+2情况三，减去n+1,加上n+2，显然使用于diff=1的情况，总计步数n+2，可以和情况二合并情况四，以上没有覆盖到的情况，举个例子可知，总计步数n+3 解法2123456789101112131415161718class Solution {public: int reachNumber(int target) { target = abs(target); int sum = 0; int n = 0; while(sum &lt; target) { n++; sum += n; } if((sum-target) % 2 == 0) return n; while((sum-target)%2) { n++; sum += n; } return n; }}; 计算 $ sum=1+2+3+…+n &gt;= target $情况一：如果 $ diff = sum-target &lt;= n $ 是偶数，则步数就是n。 由于diff &lt;= n,所以可以让第i步变成向左，即 $ sum - 2i, i=0,1,2,3,…,n+1 $，则刚好可以变成target其他情况：如果diff是奇数，则继续在sum的基础上加n,直到diff为偶数 方法31234567891011121314class Solution {public: int reachNumber(int target) { target = abs(target); int sum = 0; int n = 0; while(sum &lt; target) { n++; sum += n; } if((sum-target) % 2 == 0) return n; return n + n%2 +1; }}; 根据方法1，调整的步数最多3步，进一步分析，当diff为奇数时，sum加几个数可以变成偶数，根据公式 $$ sum = n(n+1)/2 $$可知：n偶数，sum偶数，n+1奇数，sum=sum+n+1后sum变奇数$$ n = 4i, sum=2i(2i+1) $$ n奇数，sum奇数，n+1偶数，n+2奇数，sum=sum+n+1+n+2后sum变偶数$$ n = 4i+1, sum=(4i+1)(2i+1) $$n偶数，sum奇数，n+1奇数，sum=sum+n+1后sum变偶数$$ n = 4i+2, sum=(2i+1)(4i+3) $$n奇数，sum偶数，n+1偶数，n+2奇数sum=sum+n+1+n+2后sum变奇数$$ n = 4i+3, sum=(4i+3)(2i+2) $$ 由于diff为奇数，则sum为奇数时要变成偶数，否则变成奇数整理上面的讨论，可知调整的步数为n%2+1，总步数为n+n%2+1 1106. 解析布尔表达式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {private: const static int NOT = '!'; const static int AND = '&amp;'; const static int OR = '|';public: bool parseBoolExpr(string expression) { stack&lt;char&gt; ops; stack&lt;char&gt; value; int len = expression.size(); for(int i = 0; i &lt; len; i++) { if(expression[i] == 't' || expression[i] == 'f') { value.push(expression[i]); } else if(expression[i] == NOT || expression[i] == AND || expression[i] == OR) { ops.push(expression[i]); } else if(expression[i] == '(') { value.push('('); } else if(expression[i] == ')') { char op = ops.top(); ops.pop(); bool res = value.top() == 't'? true : false; value.pop(); if(op == NOT) { res = !res; if(!value.empty()) { value.pop(); } } else { while(!value.empty() &amp;&amp; value.top() != '(') { bool temp = value.top() == 't'? true : false; if (op == AND) { res &amp;= temp; } else if(op == OR) { res |= temp; } value.pop(); } if(!value.empty()) { value.pop(); } } value.push(res ? 't' : 'f'); } } return value.top() == 't'? true : false; }}; 就是写一个计算器，难点在于n元运算，需要在数值栈中保存括号，以判断每个操作作用于那些值 1678. 设计 Goal 解析器1234567891011121314151617181920class Solution {public: string interpret(string command) { string s; int len = command.size(); for(int i = 0; i &lt; len; i++) { if(command[i] == 'G') { s.push_back('G'); } else if(command[i] == '(') { if(command[i+1] == ')') { s.push_back('o'); } else { s.push_back('a'); s.push_back('l'); } } } return s; }}; 816. 模糊坐标123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: int len; vector&lt;string&gt; ambiguousCoordinates(string s) { len = s.size(); vector&lt;string&gt; coord; for(int i = 2; i &lt; len-1; i++) { vector&lt;string&gt; n1; vector&lt;string&gt; n2; gen(move(s), 1, i, n1); int len1 = n1.size(); if(len1 &lt;=0) continue; gen(move(s), i, len-1, n2); int len2 = n2.size(); if(len2 &lt;= 0) continue; for(int k1 = 0; k1 &lt; len1; k1++) { for(int k2=0; k2&lt; len2; k2++) { coord.push_back(&quot;(&quot; + n1[k1] + &quot;, &quot; + n2[k2] + &quot;)&quot;); } } } return coord; } void gen(string&amp;&amp; s, int i, int j, vector&lt;string&gt;&amp; ret) { if(s[j-1] == '0' &amp;&amp; s[i] =='0' &amp;&amp; j-i&gt;1) { return; } if(s[j-1] == '0') { ret.push_back(s.substr(i, j-i)); return; } if(s[i] == '0') { ret.push_back(&quot;0.&quot; + s.substr(i+1, j-i-1)); return; } for(int k = i; k &lt; j-1; k++) { ret.push_back(s.substr(i, k-i+1) + &quot;.&quot; + s.substr(k+1, j-k-1)); } ret.push_back(s.substr(i, j-i)); return; }}; 1684. 统计一致字符串的数目1234567891011121314151617181920212223class Solution {public: int countConsistentStrings(string allowed, vector&lt;string&gt;&amp; words) { bool all[129] = {false}; for(char c : allowed) { all[c] = true; } int count = 0; for(string &amp;w : words ) { bool flag = true; for(char c : w) { if(!all[c]) { flag = false; break; } } if(flag) { count++; } } return count; }}; 位运算1234567891011121314151617181920212223class Solution {public: int countConsistentStrings(string allowed, vector&lt;string&gt;&amp; words) { int all = 0; for(char c : allowed) { all |= 1 &lt;&lt; (c-'a'); } int count = 0; for(string &amp;w : words ) { bool flag = true; for(char c : w) { if(!((all &gt;&gt; (c-'a'))&amp;1)) { flag = false; break; } } if(flag) { count++; } } return count; }}; 题中说明了 allowed只包含26个字母，所以用一个int就可以表示字符是否存在 764. 最大加号标志前缀和12345678910111213141516171819202122232425262728293031323334353637class Solution {public: int orderOfLargestPlusSign(int n, vector&lt;vector&lt;int&gt;&gt;&amp; mines) { vector&lt;vector&lt;int&gt;&gt; mat(n, vector&lt;int&gt;(n, 1)), x(n, vector&lt;int&gt;(n+1, n)),y(n+1, vector&lt;int&gt;(n, n)); for(auto mine : mines) { mat[mine[0]][mine[1]] = 0; } for(int i = n-1; i &gt;= 0; i--) { for(int j = n-1; j &gt;= 0; j--) { if(mat[i][j] == 1) { x[i][j] = x[i][j+1]; } else { x[i][j] = j; } if(mat[j][i] == 1) { y[j][i] = y[j+1][i]; } else { y[j][i] = j; } } } vector&lt;int&gt; miny(n, -1); int maxx = 0; for(int i = 0; i &lt; n; i++) { int minx = -1; for(int j = 0; j &lt; n; j++) { if(mat[i][j] == 0) { minx = j; miny[j] = i; } else { maxx = max(maxx, min(min(x[i][j] - j , j - minx), min(y[i][j] - i , i - miny[j]))); } } } return maxx; }}; 刚开始想用dp，但是想法不对，试了7.8次，最后想到正确的方法x, y记录点(i, j) 右测/下方第一个0的坐标，minx记录左方第一个0的坐标，miny记录上方第一个0的位置mat用来保存这个矩阵加号的阶数为(i, j)坐标到上下左右四个方向上最近的0的距离的最小值要注意特殊值的处理，右侧/下方没有0，则记其坐标为n,上方/左侧没有0记为-1 一直以为只有把某一侧的数全都加起来才算前缀和只要是把每个位置之前的一维线段或二维矩形预先存储，就叫做前缀和/积分图 大佬的解法1234567891011121314151617181920212223class Solution {public: int orderOfLargestPlusSign(int n, vector&lt;vector&lt;int&gt;&gt;&amp; mines) { vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, n)); for (auto&amp; e : mines) dp[e[0]][e[1]] = 0; for (int i = 0; i &lt; n; ++i) { int left = 0, right = 0, up = 0, down = 0; for (int j = 0, k = n - 1; j &lt; n; ++j, --k) { left = dp[i][j] ? left + 1 : 0; right = dp[i][k] ? right + 1 : 0; up = dp[j][i] ? up + 1 : 0; down = dp[k][i] ? down + 1 : 0; dp[i][j] = min(dp[i][j], left); dp[i][k] = min(dp[i][k], right); dp[j][i] = min(dp[j][i], up); dp[k][i] = min(dp[k][i], down); } } int ans = 0; for (auto&amp; e : dp) ans = max(ans, *max_element(e.begin(), e.end())); return ans; }}; 其实仔细一看，和我是一样的，一个一维for两个二维for，但是很短dp存的是到最近的一个0的长度 优化空间123456789101112131415161718192021222324class Solution {public: int orderOfLargestPlusSign(int n, vector&lt;vector&lt;int&gt;&gt;&amp; mines) { vector&lt;vector&lt;int&gt;&gt; mat(n, vector&lt;int&gt;(n, n)); for(auto mine : mines) mat[mine[0]][mine[1]] = 0; for(int i = 0; i &lt; n; i++) { int l = -1,r = n,u = -1,d = n; for(int j = 0, k = n-1; j &lt; n; j++, k--) { l = mat[i][j] ? l : j; u = mat[j][i] ? u : j; r = mat[i][k] ? r : k; d = mat[k][i] ? d : k; mat[i][j] = min(mat[i][j], j - l); mat[j][i] = min(mat[j][i], j - u); mat[i][k] = min(mat[i][k], r - k); mat[k][i] = min(mat[k][i], d - k); } } int maxx = INT_MIN; for(vector&lt;int&gt;&amp; vec : mat) maxx = max(maxx, *max_element(vec.begin(), vec.end())); return maxx; }}; 参考大佬的方法，把我的思路优化成只用一个二维数组这里要注意mat初始化为n，如果初始化为1的话后面没办法找最小值。 462. 最小操作次数使数组元素相等 II前缀和1234567891011121314151617class Solution {public: int minMoves2(vector&lt;int&gt;&amp; nums) { int len = nums.size(); long long int minn = INT_MAX; vector&lt;int&gt; preSum(len, 0); preSum[0] = nums[0]; sort(nums.begin(), nums.end()); for(int i = 1; i &lt; len; i++) { preSum[i] = preSum[i-1] + nums[i]; } for(long long int i = 0; i &lt; len; i++) { minn = min(minn, (i+1)*nums[i] - preSum[i] + preSum[len-1] - preSum[i] - (len-i -1)*nums[i]); } return minn; }}; 先排序，假设第i个数是能使总体调整数最小的数，那么总的调整次数为$$ i \\times nums_i - \\sum_{ j=0 }^{ j=i-1 }(nums_i) + \\sum_{ j=i+1 }^{ j=n-1 }(nums_j) - (n - i -1) \\times nums_i $$$$ i = 0,1,…,n-1 $$并使用前缀和优化找他的最小值即可 数学方法123456789101112class Solution {public: int minMoves2(vector&lt;int&gt;&amp; nums) { int len = nums.size(); long long int sum = 0; sort(nums.begin(), nums.end()); for(long long int i = 0; i &lt; len; i++) { sum += abs(nums[i] - nums[len/2]); } return sum; }}; 排序后，中位数之一刚好就是所求元素假设 $ a_i a_j; i+j=len-1 $ 为两个待调整元素$ h $ 为最终调整后的数，那么 $$ h = a_j - d_j = d_i - a_i $$也就是 $$ a_j - a_i = d_j + d_i $$对于关于中心对称的数，不管要调整成他们中间的哪一个数，调整的步数之和总是 $ a_j - a_i $ 所以根本不需要知道最终调整成哪个数，只要计算对称位置的两个数的差值之和即可 123456789101112class Solution {public: int minMoves2(vector&lt;int&gt;&amp; nums) { int len = nums.size(); long long int sum = 0; sort(nums.begin(), nums.end()); for(long long int i = 0; i &lt; len/2; i++) { sum += nums[len-1-i] - nums[i]; } return sum; }}; 不排序找到第len/2小的数123456789101112class Solution {public: int minMoves2(vector&lt;int&gt;&amp; nums) { int len = nums.size(); nth_element(nums.begin(), nums.begin() + len/2, nums.end()); int sum = 0; for(int i = 0; i &lt; len; i++) { sum += abs(nums[i] - nums[len/2]); } return sum; }}; 自己实现partition 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: int minMoves2(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int i = 0, j = len; int k = 0; for(;;) { k = partition(nums, i ,j); if(k == len/2) { break; } else if(k &gt; len/2) { j = k; } else { i = k+1; } } int sum = 0; for(int i = 0; i &lt; len; i++) { sum += abs(nums[i] - nums[k]); } return sum; } int partition(vector&lt;int&gt;&amp; nums, int i, int j) { int target = i; j--; while(i &lt; j) { while(j &gt; i &amp;&amp; nums[j] &gt;= nums[target]) { j--; } if(nums[j] &lt; nums[target])swap(nums[target], nums[j]); target = j; while(j &gt; i &amp;&amp; nums[i] &lt;= nums[target]) { i++; } if(nums[i] &gt; nums[target])swap(nums[target], nums[i]); target = i; } return i; }}; 太慢了。。。 去掉swap 123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: int minMoves2(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int i = 0, j = len-1; int k = 0; for(;;) { k = partition(nums, i, j); if(k == len/2) { break; } else if(k &gt; len/2) { j = k-1; } else { i = k+1; } } int sum = 0; for(int i = 0; i &lt; len; i++) { sum += abs(nums[i] - nums[k]); } return sum; } int partition(vector&lt;int&gt;&amp; nums, int i, int j) { int pivot = nums[i]; while(i &lt; j) { while(j &gt; i &amp;&amp; nums[j] &gt;= pivot) { j--; } nums[i] = nums[j]; while(j &gt; i &amp;&amp; nums[i] &lt;= pivot) { i++; } nums[j] = nums[i]; } nums[i] = pivot; return i; }}; 470. 用 Rand7() 实现 Rand10()123456class Solution {public: int rand10() { return rand()%10+1; }}; 满身反骨 202. 快乐数1234567891011121314151617181920class Solution {public: bool isHappy(int n) { while(n != 1) { n = next(n); if(n == 4) { return false; } } return true; } int next(int n) { int sum = 0; while(n) { sum += (n%10)*(n%10); n /= 10; } return sum; }}; 大家都有相同的循环节 快慢指针12345678910111213141516171819202122class Solution {public: bool isHappy(int n) { int nn = n; do { n = next(n); nn = next(nn); if(nn == 1) return true; nn = next(nn); if(nn == 1) return true; } while(n != nn); return false; } int next(int n) { int sum = 0; while(n) { sum += (n%10)*(n%10); n /= 10; } return sum; }}; 123456789101112131415161718192021class Solution {public: bool isHappy(int n) { int nn = n; do { n = next(n); if(n == 1) return true; nn = next(nn); nn = next(nn); } while(n != nn); return false; } int next(int n) { int sum = 0; while(n) { sum += (n%10)*(n%10); n /= 10; } return sum; }}; 790. 多米诺和托米诺平铺12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;double&gt; frac; int sum = 0; int numTilings(int n) { frac = vector&lt;double&gt;(n+1, 1); for(int i = 2; i &lt;= n; i++) { frac[i] = (i * frac[i-1]); } calcualte(n, n, 0, 1); return sum; } void calcualte(int k, int n, int count, double div) { if(k &gt;= 3) { for(int i = n/k; i &gt;= 0; i--) { double div1 = (div*frac[i]); for(int j = (n-i*k)/k; j &gt;= 0; j--) { calcualte(k-1, n - i*k - j*k, count + i + j, (div1*frac[j]) ); } } } else if(k == 2) { for(int i = n/k; i&gt;=0; i--) { calcualte(k-1, n-i*k, count + i, (div*frac[i])); } } else { sum = int(sum + frac[count + n]/div/frac[n])%1000000007; } }}; 没通过，思路不对，算阶乘溢出，找出所有组合的代价也太大 在这个地方我犯了一个错误，就是认为 $ \\frac{a}{b} \\quad mod\\quad c = \\frac{a\\quad mod\\quad c}{b\\quad mod\\quad c} $正确的关系是， $ \\frac{a}{b}\\quad mod\\quad c = \\frac{a\\quad mod\\quad (b \\cdot c)}{b} $ ，证明：$ \\frac{a}{b}\\quad mod\\quad c = k $$ \\frac{a}{b} = x \\cdot c + k $$ a = b \\cdot x \\cdot c + b \\cdot k $$ a\\quad mod\\quad (b \\cdot c) = b \\cdot k $$ a\\quad mod\\quad (b \\cdot c) / b = k $$ \\frac{a}{b}\\quad mod\\quad c = \\frac{a\\quad mod\\quad (b \\cdot c)}{b} $ $ a^n \\quad mod \\quad c = (a \\cdot a^{n-1}) \\quad mod \\quad c = ((a \\quad mod \\quad c) \\cdot (a^{n-1} \\quad mod \\quad c)) \\quad mod \\quad c$ dp123456789101112131415#define MOD 1000000007class Solution {public: int numTilings(int n) { vector&lt;vector&lt;long long&gt;&gt; dp(n+1, vector&lt;long long&gt;(4, 0)); dp[0][3] = 1; for(int i = 1; i &lt;= n; i++) { dp[i][0] = dp[i-1][3]; dp[i][1] = (dp[i-1][0] + dp[i-1][2])%MOD; dp[i][2] = (dp[i-1][0] + dp[i-1][1])%MOD; dp[i][3] = (dp[i-1][0] + dp[i-1][1] + dp[i-1][2] + dp[i-1][3])%MOD; } return dp[n][3]; }}; 快速幂123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#define MOD 1000000007class Solution {public: int numTilings(int n) { vector&lt;vector&lt;long long&gt;&gt; pow = { {0,0,0,1}, {1,0,1,0}, {1,1,0,0}, {1,1,1,1} }, base = { {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {1,0,0,0} }; pow = matPow(pow, n, 4); base = matMul(pow, base, 4, 4, 4); return base[3][0]; } vector&lt;vector&lt;long long&gt;&gt; matPow(vector&lt;vector&lt;long long&gt;&gt;&amp; a, int pow, int m) { vector&lt;vector&lt;long long&gt;&gt; res(m, vector&lt;long long&gt;(m)); for(int i = 0; i &lt; m; i++) { res[i][i] = 1; } while(pow) { if(pow&amp;1) { res = matMul(a, res,m,m,m); } a = matMul(a, a,m,m,m); pow = pow &gt;&gt; 1; } return res; } vector&lt;vector&lt;long long&gt;&gt; matMul(vector&lt;vector&lt;long long&gt;&gt;&amp; a, vector&lt;vector&lt;long long&gt;&gt;&amp; b, int m, int n, int k) { vector&lt;vector&lt;long long&gt;&gt; c(m, vector&lt;long long&gt;(k)); for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; k; j++) { int sum = 0; for(int l = 0; l &lt; n; l++) { sum = (sum + (a[i][l]*b[l][j])%MOD)%MOD; } c[i][j] = sum; } } return c; }}; 791. 自定义字符串排序1234567891011121314class Solution {public: string customSortString(string order, string s) { int lenO = order.size(); int argOrder[26] = {0}; for(int i = 0; i &lt; lenO; i++) { argOrder[order[i]-'a'] = i+1; } sort(s.begin(), s.end(), [&amp;](char x, char y) -&gt; bool{ return argOrder[x-'a'] &lt; argOrder[y-'a']; }); return s; }};","link":"/home/2022/11/07/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9318/"},{"title":"LeetCode-17","text":"1662. 检查两个字符串数组是否相等12345678910111213141516class Solution {public: bool arrayStringsAreEqual(vector&lt;string&gt;&amp; word1, vector&lt;string&gt;&amp; word2) { return join(move(word1)) == join(move(word2)); } string join(vector&lt;string&gt;&amp;&amp; word) { string s; int len = word.size(); if(len &lt;= 0) return s; for(int i = 0; i &lt; len-1; i++) { s += word[i]; } s+=word[len-1]; return s; }}; 实现一个join函数就好了 481. 神奇字符串1234567891011121314151617181920212223class Solution {public: int magicalString(int n) { int bit = 3; int count = 1; bool q[100005] = {false}; int queue_front = 0; int queue_rear = 0; bool cur=1; bool gen=0; while(bit &lt; n) { bit += cur+1; q[queue_front++] = gen; if(cur) { q[queue_front++] = gen; } gen=1-gen; count+=gen?cur+gen:0; cur = q[queue_rear++]; } return count -(bit&gt;n &amp;&amp; gen); }}; 关键在于想清楚如何生成这个神奇字符串，题目中说，s的前几个字符是122111生成1,s=12生成22，因为前一个1生成了1，这个2不能也生成1,s=1222生成11，因为前一个2生成了2，这个2不能也生成2,s=122111生成2，前一个2生成了1，这个1就只能生成2了,s=1221121生成1,s=12211212生成22,s=122112122 只要有前三个字符122，即可生成全部字符 784. 字母大小写全排列123456789101112131415161718192021222324252627class Solution {public:vector&lt;string&gt; res;int len; vector&lt;string&gt; letterCasePermutation(string s) { len = s.size(); search(s, 0); return res; } void search(string s, int index) { if(index&gt;=len) { res.emplace_back(s); return; } if(isalpha(s[index])) { search(s,index+1); if(isupper(s[index])) { s[index] = s[index]-'A'+'a'; } else { s[index] = s[index]-'a'+'A'; } search(s, index+1); } else { search(s, index+1); } }}; 搜! 搜就完了 优化 可以搜索下一个alpha的位置，不必每个字符都递归，节省递归深度 12345678910111213141516171819202122232425262728class Solution {public:vector&lt;string&gt; res;int len; vector&lt;string&gt; letterCasePermutation(string s) { len = s.size(); search(s, nextAlpha(s, 0)); return res; } void search(string&amp; s, int index) { if(index&gt;=len) { res.emplace_back(s); return; } int next=nextAlpha(s, index+1); search(s,next); if(isupper(s[index])) { s[index] = s[index]-'A'+'a'; } else { s[index] = s[index]-'a'+'A'; } search(s, next); } int nextAlpha(string&amp; s, int index){ while(index&lt;len &amp;&amp; !isalpha(s[index])) index++; return index; }}; 1773. 统计匹配检索规则的物品数量123456789101112131415161718class Solution {public: int countMatches(vector&lt;vector&lt;string&gt;&gt;&amp; items, string ruleKey, string ruleValue) { int index=0; if(ruleKey[0]=='c') { index=1; } else if(ruleKey[0]=='n') { index=2; } int count = 0; for(auto &amp;&amp;item : items) { if(!item[index].compare(ruleValue)) { count++; } } return count; } }; 感觉直接比较第0个字符应该也很快吧？ 907. 子数组的最小值之和123456789101112131415161718192021222324252627282930313233class Solution {public: int sumSubarrayMins(vector&lt;int&gt;&amp; arr) { int n = arr.size(); vector&lt;int&gt; monoStack; vector&lt;int&gt; left(n), right(n); for (int i = 0; i &lt; n; i++) { while (!monoStack.empty() &amp;&amp; arr[i] &lt;= arr[monoStack.back()]) { monoStack.pop_back(); } // 小于栈内元素，则 left[i] = i - (monoStack.empty() ? -1 : monoStack.back()); // 若空，则放入下一个序号，否则是与前一个数的距离 monoStack.emplace_back(i); } // 得到一个单增的栈 //只需要找到每个元素 arr[i] 以该元素为最右且最小的子序列的数目 left[i]，以及以该元素为最左且最小的子序列的数目 right[i]，则以 arr[i] 为最小元素的子序列的数目合计为 left[i]×right[i] monoStack.clear(); for (int i = n - 1; i &gt;= 0; i--) { while (!monoStack.empty() &amp;&amp; arr[i] &lt; arr[monoStack.back()]) { monoStack.pop_back(); } right[i] = (monoStack.empty() ? n : monoStack.back()) - i; monoStack.emplace_back(i); } long long ans = 0; long long mod = 1e9 + 7; for (int i = 0; i &lt; n; i++) { ans = (ans + (long long)left[i] * right[i] * arr[i]) % mod; } return ans; }}; 看了答案才会，想到是用单调栈，但是没有思路$ left \\times right $ 的原因是，n个元素的连续子数组的个数为 $ n \\times (n-1) $ 1620. 网络信号最好的坐标123456789101112131415161718192021222324252627282930313233343536class Solution {public: int len; int Power(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; towers, int radius) { int power = 0; for(int j = 0; j &lt; len; j++) { double d = sqrt((towers[j][0]-x)*(towers[j][0]-x) + (towers[j][1]-y)*(towers[j][1]-y)); if(d &lt;= radius) { power += towers[j][2]/(1+d); } } return power; } vector&lt;int&gt; bestCoordinate(vector&lt;vector&lt;int&gt;&gt;&amp; towers, int radius) { int resx = 0, resy = 0; len = towers.size(); int maxPower = 0; for(int x = 0; x &lt;= 100; x++) { for(int y = 0; y &lt;= 100; y++) { int power = Power(x, y, towers, radius); if(power &gt; maxPower) { maxPower = power; resx = x; resy = y; } else if(power == maxPower) { bool smaller = (x &lt; resx) || (x == resx &amp;&amp; y &lt; resy); if(smaller) { resx = x; resy = y; } } } } return {resx, resy}; }}; 暴力！！就暴力，看见题干就完了，搜索空间有多大我就搜多大哈哈哈哈或或 优化123456789101112131415161718192021222324252627282930class Solution {public: int len; int Power(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; towers, int radius) { int power = 0; for(int j = 0; j &lt; len; j++) { double d = sqrt((towers[j][0]-x)*(towers[j][0]-x) + (towers[j][1]-y)*(towers[j][1]-y)); if(d &lt;= radius) { power += towers[j][2]/(1+d); } } return power; } vector&lt;int&gt; bestCoordinate(vector&lt;vector&lt;int&gt;&gt;&amp; towers, int radius) { int resx = 0, resy = 0; len = towers.size(); int maxPower = 0; for(int x = 0; x &lt;= 50; x++) { for(int y = 0; y &lt;= 50; y++) { int power = Power(x, y, towers, radius); if(power &gt; maxPower) { maxPower = power; resx = x; resy = y; } } } return {resx, resy}; }}; 大于50的就没必要了，只会衰减","link":"/home/2022/11/01/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9317/"},{"title":"LeetCode-20","text":"1758. 生成交替二进制字符串的最少操作数1234567891011121314151617class Solution {public: int minOperations(string s) { int len = s.size(); return min(cal(s, len, true), cal(s, len, false)); } int cal(const string&amp; s, int len, bool flag) { int count = 0; for(int i = 0; i &lt; len; i++) { if(flag &amp;&amp; s[i] == '0' || !flag &amp;&amp; s[i] == '1') { count++; } flag = !flag; } return count; }}; 813. 最大平均值和的分组超时暴搜1234567891011121314151617181920212223class Solution {public: int len = 0; vector&lt;int&gt; sum; double largestSumOfAverages(vector&lt;int&gt;&amp; nums, int k) { len = nums.size(); sum = vector&lt;int&gt;(len+1, 0); for(int i = 1; i &lt;= len; i++) { sum[i] = nums[i-1] + sum[i-1]; } return search(nums, k, 1, 1, 0, 0); } double search(vector&lt;int&gt;&amp; nums, int k, int i, int K, double left_value, int last_j) { if(k == K || i == len) { return left_value + (sum[len] - sum[last_j] + 0.0) / (len - last_j); } return max(search(nums, k, i+1, K+1, left_value + (sum[i] - sum[last_j] + 0.0)/(i-last_j), i), search(nums, k,i+1, K, left_value, last_j)); } double max(double a, double b) { return a &gt; b ? a : b; }}; 昨天第一个思路是用排序，找出最大的m个数，这m个数恰好将数组分成k个部分，发现不可行。然后暴力搜索，超时了，暴搜时考虑添加隔板，其中left_value表示当前搜索下标i之前的分组平均值 类似背包12345678910111213141516171819202122232425262728class Solution {public: double largestSumOfAverages(vector&lt;int&gt;&amp; nums, int k) { int len = nums.size(); vector&lt;int&gt; sum(len+1, 0); vector&lt;vector&lt;double&gt;&gt; left_avg(k-1, vector&lt;double&gt;(len, 0)); for(int i = 1; i &lt;= len; i++) { sum[i] = nums[i-1] + sum[i-1]; } double maxx = sum[len] / (len + 0.0); if(k &lt;= 1) return maxx; for(int i = 1; i &lt; len; i++) { left_avg[0][i] = double(sum[i])/i; maxx = max(maxx, left_avg[0][i] + double(sum[len] - sum[i])/(len-i)); } for(int i = 0; i &lt; k-2; i++) { //第几个隔板 for(int j = i+1; j &lt; len; j++) { // 前一个隔板的位置 for(int p = j+1; p &lt; len; p++) { // 现在隔板的位置 maxx = max(left_avg[i][j] + double(sum[p] - sum[j])/(p-j) + double(sum[len] - sum[p])/(len-p), maxx); // left_avg + 当前隔板与上一个隔板的avg， 最后一个数到当前隔板的avg left_avg[i+1][p] = max(left_avg[i][j] + double(sum[p] - sum[j])/(p-j), left_avg[i+1][p]); // 更新avg } } } return maxx; }}; 今天考虑用类似背包的想法，结合暴力搜索的left_avg，用$ left_avg[i][j] $ ，表示添加i个隔板，在j之前的最大left_avg从第二个隔板开始，假设第i个隔板分别在位置 $j = i+1,i+2,i+3 …$ 时，第 $i+1$个隔板可以在 $p = j+1, j+2, …$计算前后两个隔板各种情况的最大值，更新left_avg，更新maxx 优化1234567891011121314151617181920212223242526272829class Solution {public: double largestSumOfAverages(vector&lt;int&gt;&amp; nums, int k) { int len = nums.size(); vector&lt;int&gt; sum(len+1, 0); for(int i = 1; i &lt;= len; i++) { sum[i] = nums[i-1] + sum[i-1]; } if(k &lt;= 1) return sum[len] / (len + 0.0); vector&lt;vector&lt;double&gt;&gt; left_avg(k-1, vector&lt;double&gt;(len, 0)); for(int i = 1; i &lt; len; i++) { left_avg[0][i] = double(sum[i])/i; } for(int i = 0; i &lt; k-2; i++) { for(int j = i+1; j &lt; len-1; j++) { for(int p = j+1; p &lt; len; p++) { left_avg[i+1][p] = max(left_avg[i][j] + double(sum[p] - sum[j])/(p-j), left_avg[i+1][p]); } } } double maxx = 0; for(int i = 0; i &lt; k-1; i++) { for(int j = 0; j &lt; len; j++) { maxx = max(left_avg[i][j]+double(sum[len] - sum[j])/(len-j), maxx); } } return maxx; }}; 减少maxx计算次数 1752. 检查数组是否经排序和轮转得到123456789101112class Solution {public: bool check(vector&lt;int&gt;&amp; nums) { int i = 1, j = 0; int len = nums.size(); while(i &lt; len &amp;&amp; nums[i-1] &lt;= nums[i]) i++; if(i == len) return true; j = i+1; while(j &lt; len &amp;&amp; nums[j-1] &lt;= nums[j]) j++; return j == len &amp;&amp; nums[len-1] &lt;= nums[0]; }}; 882. 细分图中的可到达节点暴搜超时12345678910111213141516171819202122232425262728293031323334353637383940class Solution {public: vector&lt;vector&lt;int&gt;&gt; graph; vector&lt;bool&gt; global_visited; int res = 0; vector&lt;vector&lt;int&gt;&gt; copy_edges; int reachableNodes(vector&lt;vector&lt;int&gt;&gt;&amp; edges, int maxMoves, int n) { int edge_size = edges.size(); graph = vector&lt;vector&lt;int&gt;&gt;(n); global_visited = vector&lt;bool&gt;(n, false); copy_edges = vector&lt;vector&lt;int&gt;&gt;(2,vector&lt;int&gt;(edge_size, 0)); for(int i = 0; i &lt; edge_size; i++) { graph[edges[i][0]].push_back(i); graph[edges[i][1]].push_back(i); } dfs(std::move(edges), 0, maxMoves); for(int i = 0; i &lt; edge_size; i++) { res += min(edges[i][2], copy_edges[0][i] + copy_edges[1][i]); } for(int i = 0; i &lt; n; i++) { if(global_visited[i]) { res++; } } return res; } void dfs(vector&lt;vector&lt;int&gt;&gt;&amp;&amp; edges, int node, int move) { global_visited[node] = true; if(move &lt;= 0) return; for(int e : graph[node]) { int w = edges[e][2]; int next = edges[e][0] == node ? edges[e][1] : edges[e][0]; int direction = edges[e][0] == node ? 0 : 1; copy_edges[direction][e] = max(min(w, move), copy_edges[direction][e]); if(move &gt; w) { dfs(std::move(edges), next, move-w-1); } } }}; djikstra-题解123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: int encode(int u, int v, int n) { return u * n + v; } int reachableNodes(vector&lt;vector&lt;int&gt;&gt;&amp; edges, int maxMoves, int n) { vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adList(n); for (auto &amp;edge : edges) { int u = edge[0], v = edge[1], nodes = edge[2]; adList[u].emplace_back(v, nodes); adList[v].emplace_back(u, nodes); } unordered_map&lt;int, int&gt; used; unordered_set&lt;int&gt; visited; int reachableNodes = 0; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; pq.emplace(0, 0); while (!pq.empty() &amp;&amp; pq.top().first &lt;= maxMoves) { auto [step, u] = pq.top(); pq.pop(); if (visited.count(u)) { continue; } visited.emplace(u); reachableNodes++; for (auto [v, nodes] : adList[u]) { if (nodes + step + 1 &lt;= maxMoves &amp;&amp; !visited.count(v)) { pq.emplace(nodes + step + 1, v); } used[encode(u, v, n)] = min(nodes, maxMoves - step); } } for (auto &amp;edge : edges) { int u = edge[0], v = edge[1], nodes = edge[2]; reachableNodes += min(nodes, used[encode(u, v, n)] + used[encode(v, u, n)]); } return reachableNodes; }};","link":"/home/2022/11/28/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9320/"},{"title":"LeetCode-22","text":"2347. 最好的扑克手牌12345678910111213141516171819202122232425class Solution {public: string bestHand(vector&lt;int&gt;&amp; ranks, vector&lt;char&gt;&amp; suits) { vector&lt;int&gt; rank_count(13, 0), suits_count(4, 0); for(int i = 0; i &lt; 5; i++) { rank_count[ranks[i]-1]++; suits_count[suits[i] - 'a']++; } int count = 0; for(int i = 0; i &lt; 4; i++) { count = max(count, suits_count[i]); } if(count == 5) return &quot;Flush&quot;; count = 0; for(int i = 0; i &lt; 13; i++) { count = max(count, rank_count[i]); } if(count &gt;= 3) { return &quot;Three of a Kind&quot;; } else if (count == 2) { return &quot;Pair&quot;; } return &quot;High Card&quot;; }}; 1604. 警告一小时内使用相同员工卡大于等于三次的人123456789101112131415161718192021222324252627class Solution {public: vector&lt;string&gt; alertNames(vector&lt;string&gt;&amp; keyName, vector&lt;string&gt;&amp; keyTime) { map&lt;string, vector&lt;int&gt;&gt; hour_count; int len = keyName.size(); for(int i = 0; i &lt; len; i++) { int h = (keyTime[i][0]-'0')*10 + keyTime[i][1] - '0', m = (keyTime[i][3] - '0') * 10 + keyTime[i][4] - '0'; hour_count[keyName[i]].push_back(h*60+m); } vector&lt;string&gt; warning_list; for(auto ite = hour_count.begin(); ite != hour_count.end(); ite++) { bool warn = false; sort(ite-&gt;second.begin(), ite-&gt;second.end()); int len = ite-&gt;second.size(); for(int i = 0; i &lt; len-2; i++) { if(ite-&gt;second[i+2] - ite-&gt;second[i] &lt;= 60) { warn = true; break; } } if(warn) { warning_list.push_back(ite-&gt;first); } } return warning_list; }}; 1234567891011121314151617181920212223242526272829303132333435class Solution {public: vector&lt;string&gt; alertNames(vector&lt;string&gt;&amp; keyName, vector&lt;string&gt;&amp; keyTime) { map&lt;string, priority_queue&lt;int&gt;&gt; hour_count; int len = keyName.size(); for(int i = 0; i &lt; len; i++) { int h = (keyTime[i][0]-'0')*10 + keyTime[i][1] - '0', m = (keyTime[i][3] - '0') * 10 + keyTime[i][4] - '0'; hour_count[keyName[i]].push(h*60+m); } vector&lt;string&gt; warning_list; for(auto ite = hour_count.begin(); ite != hour_count.end(); ite++) { int len = ite-&gt;second.size(); if(len &lt;= 2) continue; int a, b, c; a = ite-&gt;second.top(); ite-&gt;second.pop(); b = ite-&gt;second.top(); ite-&gt;second.pop(); c = ite-&gt;second.top(); ite-&gt;second.pop(); bool warn = a - c &lt;= 60; while(!warn &amp;&amp; !ite-&gt;second.empty()) { a = b; b = c; c = ite-&gt;second.top(); ite-&gt;second.pop(); warn = a - c &lt;= 60; } if(warn) { warning_list.push_back(ite-&gt;first); } } return warning_list; }}; 2331. 计算布尔二叉树的值123456789class Solution {public: bool evaluateTree(TreeNode* root) { if(root-&gt;val &lt;= 1) return root-&gt;val == 1 ? true : false; bool left = evaluateTree(root-&gt;left); bool right = evaluateTree(root-&gt;right); return root-&gt;val == 2 ? left||right : left&amp;&amp;right; }}; 1798. 你能构造出连续值的最大数目1234567891011121314class Solution {public: int getMaximumConsecutive(vector&lt;int&gt;&amp; coins) { int res = 1; sort(coins.begin(), coins.end()); for (auto&amp; i : coins) { if (i &gt; res) { break; } res += i; } return res; }}; 直接抄的答案，贪心，代码的意思就是排序，从小到大加起来没注意到题目条件要求是从0开始的，这一点很重要若最大只能到1，则数组为 [1]若最大只能到2，则数组为 [1 1] (不能是[2]，因为这样没有无法组出1)若最大只能到3，则数组为 [1 1 1], [1 2]若最大只能到4，则数组为 [1 1 1 1], [1 1 2]若最大只能到5，则数组为 [1 1 1 1 1], [1 1 1 2], [1 1 3] 观察上面列表可知，若最大只能到5，则是最大到4在多额外的1，或者最大到2且额外的一个3，这里就能看到令res初始为1，将数组排序后，相加，直到coins[i] &gt; res为止 1145. 二叉树着色游戏 这道题的提议是，第一步red先手，blue后手选择二叉树中的一个节点选择后的每一步，两个玩家只能选择当前所选所有节点的未涂色的邻接节点“我”作为后手的二号节点，如何选择我的第一个节点，让我能涂色的节点大于先手的red为了利益最大化，只有三种选择，选择x的父节点，左孩子或右孩子选择父节点，则x及x所有子节点都会被red涂色，自己只能涂色n-red个选择左孩子，自己只能涂色x的左孩子以及左孩子的所有子代节点选择右孩子，与左孩子同理以上三种情况，分别计算red和blue，只要有一种情况可以使得red &lt; blue，则blue一定可以胜利，否则一定不能胜利 123456789101112131415161718192021222324252627282930class Solution {public: bool btreeGameWinningMove(TreeNode* root, int root_sum, int x) { TreeNode* find = search(root, x); int red = sum(find); if(red &lt; root_sum - red) return true; int blue = sum(find-&gt;left); if(root_sum - blue &lt; blue) return true; blue = sum(find-&gt;right); if(root_sum - blue &lt; blue) return true; return false; } int sum(TreeNode* node) { if(node == nullptr) return 0; return 1 + sum(node-&gt;left) + sum(node-&gt;right); } TreeNode* search(TreeNode* node, int target) { if(node-&gt;val == target) { return node; } TreeNode* find = nullptr; if(node-&gt;left != nullptr) find = search(node-&gt;left, target); if(find != nullptr) return find; if(node-&gt;right != nullptr) find = search(node-&gt;right, target); return find; }}; 认真读题发现n就是总节点数，不用再算一遍了 1129. 颜色交替的最短路径BFS12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution {public: const bool RED = true; const bool BLUE = false; vector&lt;vector&lt;pair&lt;bool, int&gt;&gt;&gt; graph; vector&lt;int&gt; answer; vector&lt;map&lt;pair&lt;bool, int&gt;, bool&gt;&gt; visited; vector&lt;int&gt; shortestAlternatingPaths(int n, vector&lt;vector&lt;int&gt;&gt;&amp; redEdges, vector&lt;vector&lt;int&gt;&gt;&amp; blueEdges) { visited = vector&lt;map&lt;pair&lt;bool, int&gt;, bool&gt;&gt;(n); graph = vector&lt;vector&lt;pair&lt;bool, int&gt;&gt;&gt;(n); for(auto&amp; edge: redEdges) { visited[edge[0]][make_pair(RED, edge[1])] = false; graph[edge[0]].push_back(make_pair(RED, edge[1])); } for(auto&amp; edge: blueEdges) { visited[edge[0]][make_pair(BLUE, edge[1])] = false; graph[edge[0]].push_back(make_pair(BLUE, edge[1])); } answer = vector&lt;int&gt;(n, INT_MAX); search(); for(int i = 1; i &lt; n; i++) { if(answer[i] == INT_MAX) answer[i] = -1; } answer[0] = 0; return answer; } void search() { int len = 0; queue&lt;pair&lt;bool, int&gt;&gt; q; q.push(make_pair(RED, 0)); q.push(make_pair(BLUE, 0)); while(!q.empty()) { queue&lt;pair&lt;bool, int&gt;&gt; tmp; while(!q.empty()) { auto [color, node] = q.front(); q.pop(); for(auto&amp; edge:graph[node]) { if(edge.first != color &amp;&amp; !visited[node][edge]) { answer[edge.second] = min(answer[edge.second], len+1); tmp.push(edge); visited[node][edge] = true; } } } len++; q = tmp; } }}; 不必重复遍历边由于自环，平行边的存在，同一个节点可以重复遍历，这样可以凑出红蓝交替的路径对于边，定义为pair&lt;bool, int&gt;，代表&lt;color, next&gt;bfs时，选取与上一条边颜色相反的边入队 dfs1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: const bool RED = true; const bool BLUE = false; vector&lt;vector&lt;pair&lt;bool, int&gt;&gt;&gt; graph; vector&lt;map&lt;pair&lt;bool, int&gt;, bool&gt;&gt; visited; vector&lt;int&gt; shortestAlternatingPaths(int n, vector&lt;vector&lt;int&gt;&gt;&amp; redEdges, vector&lt;vector&lt;int&gt;&gt;&amp; blueEdges) { graph = vector&lt;vector&lt;pair&lt;bool, int&gt;&gt;&gt;(n); for(auto&amp; edge: redEdges) { graph[edge[0]].push_back(make_pair(RED, edge[1])); } for(auto&amp; edge: blueEdges) { graph[edge[0]].push_back(make_pair(BLUE, edge[1])); } vector&lt;int&gt; answer(n); for(int i = 1; i &lt; n; i++) { visited = vector&lt;map&lt;pair&lt;bool, int&gt;, bool&gt;&gt;(n); for(auto&amp; edge: redEdges) { visited[edge[0]][make_pair(RED, edge[1])] = false; } for(auto&amp; edge: blueEdges) { visited[edge[0]][make_pair(BLUE, edge[1])] = false; } answer[i] = min(search(0, i, 0, RED), search(0, i, 0, BLUE)); if(answer[i] == INT_MAX) answer[i] = -1; } return answer; } int search(int node, int target, int len, bool last_color) { if(node == target) return len; int find = INT_MAX; for(auto&amp; edge : graph[node]) { if(edge.first != last_color &amp;&amp; !visited[node][edge]) { visited[node][edge] = true; find = min(search(edge.second, target, len+1, edge.first), find); visited[node][edge] = false; } } return find; }}; 超时，但应该是正确的复杂度 $ O(n^2) $ 1806. 还原排列的最少操作步数模拟12345678910111213141516171819202122232425262728class Solution {public: int n; int reinitializePermutation(int n) { this-&gt;n = n; vector&lt;int&gt; arr(n),tmp(n), *x, *y; for(int i = 0; i &lt; n; i++) { arr[i] = i%2 == 0 ? i/2 : n/2+(i-1)/2; } int step = 1; x = &amp;arr; y = &amp;tmp; while(!ok(x)) { for(int i = 0; i &lt; n; i++) { (*y)[i] = i%2 == 0 ? (*x)[i/2] : (*x)[n/2+(i-1)/2]; } swap(x, y); step++; } return step; } bool ok(vector&lt;int&gt;* arr) { for(int i = 0; i &lt; n; i++) { if((*arr)[i] != i) return false; } return true; }}; 模拟21234567891011121314151617class Solution {public: int n; int reinitializePermutation(int n) { this-&gt;n = n; vector&lt;int&gt; arr(n); for(int i = 0; i &lt; n; i++) { arr[i] = i%2 == 0 ? i/2 : n/2+(i-1)/2; } int step = 1, p = arr[1]; while(p != 1) { p = arr[p]; step++; } return step; }}; 238. 除自身以外数组的乘积123456789101112131415class Solution {public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) { int len = nums.size(); vector&lt;int&gt; l(len, 1), r(len,1); for(int i = 1; i &lt; len; i++) { l[i] = l[i-1] * nums[i-1]; r[len-i-1] = r[len-i] * nums[len-i]; } for(int i = 0; i &lt; len; i++) { nums[i] = l[i]*r[i]; } return nums; }}; 空间O(1)12345678910111213141516class Solution {public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) { int len = nums.size(); vector&lt;int&gt; res(len, 1); for(int i = 1; i &lt; len; i++) { res[len-i-1] = res[len-i] * nums[len-i]; } int left = 1; for(int i = 0; i &lt; len; i++) { res[i] = left*res[i]; left *= nums[i]; } return res; }}; 他这里对 $ O(1) $ 的定义是除了输入输出数组外，只用常量级的空间，很容易想到l数组可以优化 2357. 使数组中所有元素都等于零1234567891011121314class Solution {public: int minimumOperations(vector&lt;int&gt;&amp; nums) { unordered_map&lt;int, int&gt; m; for(int n:nums) { if(n &gt; 0) { m[n]++; } } int count = 0; for(auto ite=m.begin(); ite != m.end(); ite++,count++); return count; }}; 1238. 循环码排列二叉树123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;int&gt; res; vector&lt;int&gt; circularPermutation(int n, int start) { int len = 1 &lt;&lt; n; res = vector&lt;int&gt;(len); vector&lt;int&gt; rotate(len); int split = 2; for(int i = 0; i &lt; n; i++) { int a = 0; for(int j = 0; j &lt; split; j++) { cal(len/split*j, len/split*(j+1), a); if(j%2==0) a = !a; } split &lt;&lt;= 1; } int k = 0; while(k &lt; len &amp;&amp; res[k] != start) k++; for(int i = 0; i &lt; len; i++) { rotate[i] = res[(i+k)%len]; } return rotate; } void cal(int i, int j, int a) { for(; i &lt; j; i++) { res[i] &lt;&lt;= 1; res[i] += a&amp;1; } }}; 把他想成一个二叉树，每层按照0110的顺序生成 二叉树1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: vector&lt;int&gt; res; vector&lt;int&gt; circularPermutation(int n, int start) { int len = 1 &lt;&lt; n; vector&lt;int&gt; rotate(len); queue&lt;TreeNode*&gt; q; for(int i = 0; i &lt; len; i++) { q.push(new TreeNode(i)); } TreeNode* root = nullptr; while(!q.empty()) { TreeNode *n1 = q.front(), *n2 = nullptr; q.pop(); if(!q.empty()) { n2 = q.front(); q.pop(); q.push(new TreeNode(n1-&gt;val + n2-&gt;val, n1, n2)); } else { root = n1; break; } } flip(root); treavourse(root); int k = 0; while(k &lt; len &amp;&amp; res[k] != start) k++; for(int i = 0; i &lt; len; i++) { rotate[i] = res[(i+k)%len]; } return rotate; } void treavourse(TreeNode* root) { if(root-&gt;left != nullptr &amp;&amp; root-&gt;right != nullptr) { treavourse(root-&gt;left); treavourse(root-&gt;right); } else { res.push_back(root-&gt;val); } } void flip(TreeNode* root) { if(root-&gt;left == nullptr || root-&gt;right == nullptr) return; swap(root-&gt;right-&gt;left, root-&gt;right-&gt;right); flip(root-&gt;left); flip(root-&gt;right); }}; 翻转二叉树，先序把右孩子的左右孩子互换 格雷码123456789101112131415161718192021222324252627class Solution {public: vector&lt;int&gt; res; vector&lt;int&gt; circularPermutation(int n, int start) { int len = 1 &lt;&lt; n; res = vector&lt;int&gt;(len); int split = 2; for(int i = 0; i &lt; n; i++) { int a = 0; for(int j = 0; j &lt; split; j++) { cal(len/split*j, len/split*(j+1), a); if(j%2==0) a = !a; } split &lt;&lt;= 1; } for(int i = 0; i &lt; len; i++) { res[i] = res[i] ^ start; } return res; } void cal(int i, int j, int a) { for(; i &lt; j; i++) { res[i] &lt;&lt;= 1; res[i] += a&amp;1; } }}; 格雷码有他的生成公式 12345678910class Solution {public: vector&lt;int&gt; circularPermutation(int n, int start) { vector&lt;int&gt; ret(1 &lt;&lt; n); for (int i = 0; i &lt; ret.size(); i++) { ret[i] = (i &gt;&gt; 1) ^ i ^ start; } return ret; }}; 1326. 灌溉花园的最少水龙头数目dp123456789101112131415161718class Solution {public: int minTaps(int n, vector&lt;int&gt;&amp; ranges) { vector&lt;int&gt; dp(n+1, INT_MAX), index(n+1); for(int i = 0; i &lt;= n; i++) index[i] = i; sort(index.begin(), index.end(), [&amp;ranges](int i, int j)-&gt;bool{return i-ranges[i] &lt; j-ranges[j];}); dp[0] = 0; for(int i = 0; i &lt;= n; i++) { int start = max(index[i] - ranges[index[i]], 0); int end = min(index[i] + ranges[index[i]], n); if(dp[start] == INT_MAX) return -1; for(int j = start; j &lt;= end; j++) { dp[j] = min(dp[start]+1, dp[j]); } } return dp[n]; }}; $dp[i]$表示区间$[0, i]$被灌溉所需的最少水龙头数将$ranges[i]$按照$i-ranges[i]$从小到大排序按顺序遍历排序好的ranges，计算其$start,end$$start$处已经计算出其所需最小水龙头数了，有两种情况 当前$ [0, x] $已知, $ start &lt;= end &lt;= x $, 则$[start, end]$之间最少水龙头数保持不变 当前$ [0, x] $已知, $ start &lt;= x &lt; end $, 则$[start+1, end]$之间最少水龙头数为$dp[start]+1$ 当前$ [0, x] $已知, $ x &lt; start &lt;= end $, 则无解 贪心12345678910111213141516171819class Solution {public: int minTaps(int n, vector&lt;int&gt;&amp; ranges) { vector&lt;int&gt; right(n+1); for(int i = 0; i &lt;= n; i++) right[max(0, i-ranges[i])] = max(min(i + ranges[i],n), right[max(0, i-ranges[i])]); int last = 0; int ret = 0; int pre = 0; for(int i = 0; i &lt; n; i++) { last = max(last, right[i]); if(i == last) return -1; if(i == pre) { ret++; pre = last; } } return ret; }}; $right[start]$表示从$start$位置，经过某个水龙头的浇灌最远能到达的位置$last$表示当前最远到达的位置，$pre$表示上一个使用的水龙头最远的位置从左向右遍历，一边遍历一遍寻找最远能到达的位置，如果$i$到达了最远能到达的位置且不是n，说明无法覆盖。如果i遇到了前一个水龙头的边界，说明接下来该使用下一个水龙头了 1247. 交换字符使得字符串相同123456789101112131415161718192021class Solution {public: int minimumSwap(string s1, string s2) { int count[2][2] = {0}; int len = s1.length(); for(int i= 0; i &lt; len; i++) { if(s1[i] == 'x' &amp;&amp; s2[i] == 'y') { count[0][1]++; } else if(s1[i] == 'y' &amp;&amp; s2[i] == 'x') { count[1][0]++; } } int res = count[0][1]/2 + count[1][0]/2; if(count[0][1]%2 == 1 &amp;&amp; count[1][0]%2 == 1) { res+=2; } else if(count[0][1]%2 || count[1][0]%2) { return -1; } return res; }}; 根据题目的样例 “xx”+”yy”型(“yy”+”xx”型)，只需要一步“xy”+”yx”型(“yx”+”xy”型)，需要两步交换时可以两个字符串上任意两个位置进行交换。 1703. 得到连续 K 个 1 的最少相邻交换次数123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: int k; int minMoves(vector&lt;int&gt;&amp; nums, int k) { int i = 0, j = 0, n = nums.size(); this-&gt;k = k; queue&lt;int&gt; index, wait; for(int i = 0; i &lt; n; i++) { if(nums[i] == 1) { index.push(i); } } for(int i = 0; i &lt; k; i++) { wait.push(index.front()); index.pop(); } int minn = cal(wait); while(!index.empty()) { wait.push(index.front()); index.pop(); wait.pop(); minn = min(cal(wait), minn); } return minn; } int cal(queue&lt;int&gt; q) { int l = 0, r = 0, count = 1, last = q.front(); for(int i = 0; i &lt; k/2; i++) { q.pop(); l += count * (q.front() - last - 1); count++; last = q.front(); } last = q.front(); for(int i = k/2; i &lt; k-1; i++) { q.pop(); r += (k - i - 1) * (q.front() - last - 1); last = q.front(); } return l + r; }}; 两个队列 index 和 queindex存放值为1的下表从index取k个放入que计算que的长度que中pop一个，index也pop一个放入index，再次计算index，直到index为空取每次计算que的最小值que计算长度时，从中间一分为二，将两边的1向最中间的1靠拢移动。 优化1123456789101112131415161718192021222324252627282930313233343536class Solution {public: int k; int minMoves(vector&lt;int&gt;&amp; nums, int k) { int i = 0, j = 0, count = 0, n = nums.size(); this-&gt;k = k; vector&lt;int&gt; index(n); int minn = INT_MAX; for(int i = 0; i &lt; n; i++) { if(nums[i] == 1) { index[j] = i; j++; if(j &gt;= k) { minn = min(cal(move(index), count), minn); count++; } } } return minn; } int cal(vector&lt;int&gt;&amp;&amp; v, int start) { int l = 0, r = 0; int li = 0; for(int i = k/2; i &gt; 0; i--) { li += (v[i+start] - v[i+start-1] - 1); l += li; } int ri = 0; for(int i = k/2; i &lt; k-1; i++) { ri += (v[i+start+1] - v[i+start] - 1); r += ri; } return l + r; }}; 题解12345678910111213141516171819202122232425262728293031323334class Solution {public: int minMoves(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); int minn = 0, cost = 0; vector&lt;int&gt; left{0}, zero; int leftSum = 0; int i = 0; for(; i &lt; n &amp;&amp; nums[i] == 0; i++); for(; i &lt; n;) { i++; int count; for(count = 0; i &lt; n &amp;&amp; nums[i] == 0; i++, count++); leftSum += count; if(i &lt; n) { zero.push_back(count); left.push_back(leftSum); } } int l = 0, r = k-2; for(int i = l; i &lt;= r; i++) { cost += zero[i] * min(1+i, 1+r-i); } minn=cost; int nn = zero.size(); for(int i = 1, j = k-1; j &lt; nn; i++, j++) { int mid = (i+j)/2; cost -= left[mid] - left[i-1]; cost += left[j+1] - left[mid+k%2]; minn = min(minn, cost); } return minn; }}; 参考题解， 就是找到窗口滑动时，cost的O(1)的更新方法 1255. 得分最高的单词集合12345678910111213141516171819202122232425262728class Solution {public: int wn; int maxScoreWords(vector&lt;string&gt;&amp; words, vector&lt;char&gt;&amp; letters, vector&lt;int&gt;&amp; score) { wn = words.size(); int ln = letters.size(); vector&lt;int&gt; letterCount = vector&lt;int&gt;(26); for(int i = 0; i &lt; ln; i++) { letterCount[letters[i] - 'a']++; } return dfs(0, words, score, letterCount); } int dfs(int index, vector&lt;string&gt;&amp; words, vector&lt;int&gt;&amp; score, vector&lt;int&gt; state) { if(index &gt;= wn) return 0; int scoreNext = dfs(index+1, words, score, state); int wlen = words[index].length(); int scorei = 0; for(int i = 0; i &lt; wlen; i++) { if(state[words[index][i] - 'a'] &gt; 0) { state[words[index][i] - 'a']--; scorei += score[words[index][i] - 'a']; } else { return scoreNext; } } return max(scoreNext, scorei + dfs(index+1, words, score, state)); }}; 艺术，就是暴搜！！！然后再记录一下当前状态下，26个字母当前剩余个数 状态压缩，但是负优化123456789101112131415161718192021222324252627282930313233class Solution {public: int maxScoreWords(vector&lt;string&gt;&amp; words, vector&lt;char&gt;&amp; letters, vector&lt;int&gt;&amp; score) { int wn = words.size(); int ln = letters.size(); vector&lt;int&gt; letterCount = vector&lt;int&gt;(26); for(int i = 0; i &lt; ln; i++) { letterCount[letters[i] - 'a']++; } int res = 0; for(int s = 1; s &lt; (1 &lt;&lt; wn); s++) { vector&lt;int&gt; wordCount = letterCount; int scoreState = 0; for(int i = 0; i &lt; wn; i++) { if(s &amp; (1 &lt;&lt; i)) { int wlen = words[i].length(); for(int j = 0; j &lt; wlen; j++) { if(wordCount[words[i][j] - 'a'] &gt; 0) { wordCount[words[i][j] - 'a']--; scoreState += score[words[i][j] - 'a']; } else { s = ((s &gt;&gt; (wn -i)) + 1) &lt;&lt; (wn - i); goto NextState; } } } } res = max(res, scoreState); NextState:; } return res; }}; s的每一位表示对应wordi是否选择，复制最初的状态，统计分数，如果遇到不可以的，直接到下一个状态 剪枝1234567891011121314151617181920212223242526272829303132333435class Solution {public: int maxScoreWords(vector&lt;string&gt;&amp; words, vector&lt;char&gt;&amp; letters, vector&lt;int&gt;&amp; score) { int wn = words.size(); int ln = letters.size(); vector&lt;int&gt; letterCount = vector&lt;int&gt;(26); for(int i = 0; i &lt; ln; i++) { letterCount[letters[i] - 'a']++; } int res = 0; for(int s = 1; s &lt; (1 &lt;&lt; wn);) { vector&lt;int&gt; wordCount = letterCount; int scoreState = 0; for(int i = 0; i &lt; wn; i++) { if(s &amp; (1 &lt;&lt; (wn - i - 1))) { int wlen = words[i].length(); for(int j = 0; j &lt; wlen; j++) { if(wordCount[words[i][j] - 'a'] &gt; 0) { wordCount[words[i][j] - 'a']--; scoreState += score[words[i][j] - 'a']; } else { s = ((s &gt;&gt; (wn - i - 1)) + 1) &lt;&lt; (wn - i - 1); // s += 1 &lt;&lt; (wn - i - 1); goto NextState; } } } } res = max(res, scoreState); s++; NextState:; } return res; }}; 题解中的状态 $ s $的第 $ i $ 位(从 $ 0 $ 开始，从左往右)对应的是 $ words $ 数组中第 $ n-1-i $ 个字符串，我这里改成对应第 $ i $ 个字符串 对于状态 $ s $，当发现第 $ k $ 位的字符个数条件满足不了以后，第 $ k+1 $ 位至第 $ n-1 $ 位的情况都不需要考虑了，则状态直接跳转到 $ ((s &gt;&gt; (n - k - 1)) + 1) &lt;&lt; (n - k - 1) $ ,由于当前状态第 $ k $ 位后全为 $ 0 $ ，也就是当前状态s再加上 $ 1 &lt;&lt; (n - k - 1) $ 或者状态 $ s $ 从 $ -1 $ 到 $ -(1 &lt;&lt; wn) $ 12345678910111213141516171819202122232425262728293031323334class Solution {public: int maxScoreWords(vector&lt;string&gt;&amp; words, vector&lt;char&gt;&amp; letters, vector&lt;int&gt;&amp; score) { int wn = words.size(); int ln = letters.size(); vector&lt;int&gt; letterCount = vector&lt;int&gt;(26); for(int i = 0; i &lt; ln; i++) { letterCount[letters[i] - 'a']++; } int res = 0; for(int s = -1; s &gt; -(1 &lt;&lt; wn);) { vector&lt;int&gt; wordCount = letterCount; int scoreState = 0; for(int i = 0; i &lt; wn; i++) { if(s &amp; (1 &lt;&lt; (wn - i - 1))) { int wlen = words[i].length(); for(int j = 0; j &lt; wlen; j++) { if(wordCount[words[i][j] - 'a'] &gt; 0) { wordCount[words[i][j] - 'a']--; scoreState += score[words[i][j] - 'a']; } else { s -= (1 &lt;&lt; (wn - i - 1)); goto NextState; } } } } res = max(res, scoreState); s--; NextState:; } return res; }};","link":"/home/2023/02/20/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9322/"},{"title":"LeetCode-21","text":"1234. 替换子串得到平衡字符串12345678910111213141516171819202122232425262728293031class Solution {public: bool isBalance(int* count, int avg) { return count['Q'] &lt;= avg &amp;&amp; count['R'] &lt;= avg &amp;&amp; count['E'] &lt;= avg &amp;&amp; count['W'] &lt;= avg; } int balancedString(string s) { int count[128] = {0}; for (char c : s) { count[c]++; } int len = s.length(); int avg = len / 4; if (isBalance(count, avg)) { return 0; } int res = len; for (int l = 0, r = 0; l &lt; len; l++) { while (r &lt; len &amp;&amp; !isBalance(count, avg)) { count[s[r]]--; r++; } if (!isBalance(count, avg)) { break; } res = min(res, r - l); count[s[l]]++; } return res; }}; 1138. 字母板上的路径123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: string alphabetBoardPath(string target) { int x = 0, y = 0; string res = &quot;&quot;; for(char c : target) { int next_x = getX(c), next_y = getY(c); char step_x = 'L', step_y = 'U'; int diff_x = x - next_x, diff_y = y - next_y; if(next_x &gt; x) { step_x = 'R'; diff_x = -diff_x; } if(next_y &gt; y) { step_y = 'D'; diff_y = - diff_y; } if(next_y == 5) { for(int i = 0; i &lt; diff_x; i++) { res += step_x; } for(int i = 0; i &lt; diff_y; i++) { res += step_y; } } else { for(int i = 0; i &lt; diff_y; i++) { res += step_y; } for(int i = 0; i &lt; diff_x; i++) { res += step_x; } } res += &quot;!&quot;; x = next_x; y = next_y; } return res; } int getX(char c) { return (c - 'a') % 5; } int getY(char c) { return (c - 'a') / 5; }}; 如果默认先纵向走，再横向走，那么当从外部到z时，需要先横向走再纵向走如果默认先横向走，再纵向走，那么当从z到外部时，需要先纵向走再横向走 2335. 装满杯子需要的最短总时长12345678910111213141516171819202122232425262728293031323334353637class Solution {public: int fillCups(vector&lt;int&gt;&amp; amount) { int res = 0; int x,y; int minn = 0; if(amount[0] == 0 || amount[1] == 0 || amount[2] == 0) { if(amount[0] == 0) minn = 0; if(amount[1] == 0) minn = 1; if(amount[2] == 0) minn = 2; } else { if(amount[1] &lt; amount[minn]) { minn = 1; } if(amount[2] &lt; amount[minn]) { minn = 2; } int a,b; if(amount[(minn+1)%3] &gt; amount[(minn + 3 - 1) % 3]) { a = (minn+1)%3; b = (minn + 3 - 1) % 3; } else { b = (minn+1)%3; a = (minn + 3 - 1) % 3; } res += amount[minn]; int diff = min(amount[a] - amount[b], amount[minn]); amount[minn] -= diff; amount[a] -= diff; amount[a] -= amount[minn]/2; amount[b] -= amount[minn] - amount[minn]/2; amount[minn] = 0; } res += max(amount[(minn + 3 - 1) % 3], amount[(minn+1)%3]); return res; }}; 假设初始状态，三杯水的需求量都大于0。选最少的一种，让他和另外两种水一起接，并且尽量让另外两杯水的需求量相近，处理好最少的一种后，最少的一种就变成了0对于剩下的两中温度，操作数就是最大的那个温度如果初始有一个为0，则将minn初始化为对应下标由于只有3个，可以取余减少重复代码 1797. 设计一个验证系统1234567891011121314151617181920212223242526class AuthenticationManager {public: unordered_map&lt;string, int&gt; live; int timeToLive; AuthenticationManager(int timeToLive) { this-&gt;timeToLive = timeToLive; } void generate(string tokenId, int currentTime) { live[tokenId] = currentTime + timeToLive; } void renew(string tokenId, int currentTime) { if(!live.count(tokenId) || live[tokenId] &lt;= currentTime) return; live[tokenId] = currentTime + timeToLive; } int countUnexpiredTokens(int currentTime) { int count = 0; for(auto ite = live.begin(); ite != live.end(); ite++) { if(ite-&gt;second &gt; currentTime) count++; } return count; }}; 1250. 检查「好数组」123456789101112131415161718class Solution {public: bool isGoodArray(vector&lt;int&gt;&amp; nums) { int gcd_ = nums[0]; int n = nums.size(); for(int i = 0; i &lt; n; i++) { gcd_ = gcd(nums[i], gcd_); if(gcd_ == 1) return true; } return false; } int gcd(int a, int b) { if(a &lt; b) return gcd(b, a); if(b == 0) return a; return gcd(b, a%b); }}; 根据提示 $ Eq. ax+by=1 has solution x, y if gcd(a,b) = 1. $只要整个数组的最大公约数为1，则可满足题意 1233. 删除子文件夹12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364struct MTreeNode { unordered_map&lt;string, MTreeNode*&gt; childList;};class Solution {public: vector&lt;string&gt; res; vector&lt;string&gt; removeSubfolders(vector&lt;string&gt;&amp; folder) { MTreeNode * root = new MTreeNode(); for(string&amp; dir : folder) { vector&lt;string&gt; dirs = splitPath(dir); MTreeNode* move = root; int dir_len = dirs.size(); for(int i = 0; i &lt; dir_len; i++) { if(!move-&gt;childList.count(dirs[i])) { move-&gt;childList[dirs[i]] = new MTreeNode(); } move = move-&gt;childList[dirs[i]]; } } for(string&amp; dir : folder) { vector&lt;string&gt; dirs = splitPath(dir); MTreeNode* move = root; int dir_len = dirs.size(); for(int i = 0; i &lt; dir_len; i++) { if(!move-&gt;childList.count(dirs[i])) { break; } move = move-&gt;childList[dirs[i]]; } move-&gt;childList.clear(); } dfs(root, &quot;&quot;); return res; } void dfs(MTreeNode* root, string path) { if(root-&gt;childList.size() == 0) { res.push_back(path); return; } for(auto ite = root-&gt;childList.begin(); ite != root-&gt;childList.end(); ite++) { dfs(ite-&gt;second, path+&quot;/&quot;+ite-&gt;first); } } vector&lt;string&gt; splitPath(string s) { vector&lt;string&gt; path; int i = 0; int n = s.size(); while(i &lt; n) { string dir; while(i &lt; n &amp;&amp; s[i] == '/') i++; if(i &lt; n) { while(i &lt; n &amp;&amp; s[i] != '/') { dir.push_back(s[i]); i++; } path.push_back(dir); } } return path; }}; 模拟，构造那棵树，删除，然后还原 12执行用时：620 ms, 在所有 C++ 提交中击败了5.15%的用户内存消耗：213.6 MB, 在所有 C++ 提交中击败了4.99%的用户 我不管，这是O(n)，就是最快的 123456789101112131415161718192021class Solution {public: vector&lt;string&gt; res; vector&lt;string&gt; removeSubfolders(vector&lt;string&gt;&amp; folder) { sort(folder.begin(), folder.end()); int cmp = 0; int i = 1, n = folder.size(), cmp_len = folder[cmp].length(); res.push_back(folder[cmp]); for(; i &lt; n; i++) { int j; for(j = 0; j &lt; cmp_len &amp;&amp; folder[cmp][j] == folder[i][j]; j++); if(j == cmp_len &amp;&amp; folder[i][j] == '/') { } else { cmp = i; cmp_len = folder[cmp].length(); res.push_back(folder[cmp]); } } return res; }}; 排序，比较 1210. 穿过迷宫的最少移动次数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution {public: int minimumMoves(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n; n = grid.size(); queue&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt; que; if(n &lt;= 0) return 0; vector&lt;vector&lt;vector&lt;bool&gt;&gt;&gt; visited(n, vector&lt;vector&lt;bool&gt;&gt;(n, vector&lt;bool&gt;(2, false))); que.push(make_pair(make_pair(0,0),0)); int step = 0; while(!que.empty()) { queue&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt; que_temp; while(!que.empty()) { auto [pos, ver] = que.front(); auto [x, y] = pos; visited[x][y][ver] = true; que.pop(); if(x == n-1 &amp;&amp; y == n-2 &amp;&amp; !ver) {return step;} if(ver) { if(x+2 &lt; n &amp;&amp; !grid[x+2][y]) { if(!visited[x+1][y][1]) { que_temp.push(make_pair(make_pair(x+1,y),1)); visited[x+1][y][1] = true; } } if(y+1 &lt; n &amp;&amp; x+1 &lt; n &amp;&amp; !grid[x][y+1] &amp;&amp; !grid[x+1][y+1]) { if(!visited[x][y][0]) { que_temp.push(make_pair(make_pair(x,y),0)); visited[x][y][0] = true; } if(!visited[x][y+1][1]) { que_temp.push(make_pair(make_pair(x,y+1),1)); visited[x][y+1][1] = true; } } } else { if(y+2 &lt; n &amp;&amp; !grid[x][y+2]) { if(!visited[x][y+1][0]) { que_temp.push(make_pair(make_pair(x,y+1),0)); visited[x][y+1][0] = true; } } if(y+1 &lt; n &amp;&amp; x+1 &lt; n &amp;&amp; !grid[x+1][y] &amp;&amp; !grid[x+1][y+1]) { if(!visited[x][y][1]) { que_temp.push(make_pair(make_pair(x,y),1)); visited[x][y][1] = true; } if(!visited[x+1][y][0]) { que_temp.push(make_pair(make_pair(x+1,y),0)); visited[x+1][y][0] = true; } } } } step++; que = que_temp; } return -1; }}; 经典的BFS 2341. 数组能形成多少数对123456789101112131415161718192021class Solution {public: vector&lt;int&gt; numberOfPairs(vector&lt;int&gt;&amp; nums) { unordered_map&lt;int, bool&gt; m; int len = nums.size(); for(int n:nums) { if(m.count(n)) { m[n] = !m[n]; } else { m[n] = true; } } int res = 0; for(auto ite = m.begin(); ite != m.end(); ite++) { if(ite-&gt;second) { res++; } } return {(len - res) &gt;&gt; 1, res}; }}; 1139. 最大的以 1 为边界的正方形1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: int largest1BorderedSquare(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = grid.size(), n = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; up(m, vector&lt;int&gt;(n, 0)), down(m, vector&lt;int&gt;(n, 0)), left(m, vector&lt;int&gt;(n, 0)), right(m, vector&lt;int&gt;(n, 0)); for(int i = 0; i &lt; m; i++) { left[i][0] = grid[i][0]; right[i][n-1] = grid[i][n-1]; for(int j = 1; j &lt; n; j++) { if(grid[i][j]) left[i][j] = left[i][j-1] + 1; else left[i][j] = 0; if(grid[i][n-1-j]) right[i][n-1-j] = right[i][n-j] + 1; else right[i][n-1-j] = 0; } } for(int i = 0; i &lt; n; i++) { up[0][i] = grid[0][i]; down[m-1][i] = grid[m-1][i]; for(int j = 1; j &lt; m; j++) { if(grid[j][i]) up[j][i] = up[j-1][i] + 1; else up[j][i] = 0; if(grid[m-1-j][i]) down[m-1-j][i] = down[m-j][i] + 1; else down[m-1-j][i] = 0; } } int maxx = 0; for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; n; j++) { if(grid[i][j]) { int diff = min(down[i][j], right[i][j]); for(int l = 0; l &lt; diff; l++) { if(l-up[i+l][j+l]+1 &lt;= 0 &amp;&amp; l-left[i+l][j+l]+1 &lt;= 0) { maxx = max(maxx, l+1); } } } } } return maxx*maxx; }}; 记录上下左右四个方向从位置(i, j)开始连续的1的个数对于一个为1的点，在其下方和右方有连续1的范围内的斜对角上的各点，如果斜对角线上各点的上方和左方能和(i,j)的下方和右方围成正方形，则更新最大值。 1663. 具有给定数值的最小字符串1234567891011class Solution {public: string getSmallestString(int n, int k) { string res(n, 'a'-1); for(int i = n-1; i &gt;= 0; i--) { res[i] += min(26, k-i); k -= min(26, k-i); } return res; }}; 1234567891011121314class Solution {public: string getSmallestString(int n, int k) { string res(n, 'a'); int i = n-1; k-=n; for( ; k &gt;= 26; i--) { res[i] += 25; k -= 25; } res[i] += k; return res; }}; 1237. 找出给定方程的正整数解暴力搜索1234567891011121314class Solution {public: vector&lt;vector&lt;int&gt;&gt; findSolution(CustomFunction&amp; customfunction, int z) { vector&lt;vector&lt;int&gt;&gt; res; int x, y; for(x = 1; x &lt;= 1000; x++) { for(y = 1000; y &gt; 1 &amp;&amp; customfunction.f(x,y) &gt; z; y--); if(customfunction.f(x,y) == z) { res.push_back({x, y}); } } return res; }}; 二分查找1234567891011121314151617181920class Solution {public: vector&lt;vector&lt;int&gt;&gt; findSolution(CustomFunction&amp; customfunction, int z) { vector&lt;vector&lt;int&gt;&gt; res; int x, y; for(x = 1; x &lt;= 1000; x++) { int l = 1, r = 1001; while(l &lt;= r) { y = (r - l) / 2 + l; if(customfunction.f(x, y) == z) break; if(customfunction.f(x,y) &gt; z) r = y-1; else l = y+1; } if(customfunction.f(x,y) == z) { res.push_back({x, y}); } } return res; }}; 由于是增函数，则确定x，y可以二分 双指针123456789101112131415class Solution {public: vector&lt;vector&lt;int&gt;&gt; findSolution(CustomFunction&amp; customfunction, int z) { vector&lt;vector&lt;int&gt;&gt; res; int x = 1, y = 1000; for(x = 1; x &lt;= 1000; x++) { int l = 1, r = 1001; for(; y &gt; 1 &amp;&amp; customfunction.f(x, y) &gt; z; y--); if(customfunction.f(x,y) == z) { res.push_back({x, y}); } } return res; }}; 由于是递增的，x增大y必然要减少 1792. 最大平均通过率超时12345678910111213141516171819202122232425class Solution {public: double maxAverageRatio(vector&lt;vector&lt;int&gt;&gt;&amp; classes, int extraStudents) { double res = 0; int len = classes.size(); for(int i = 0; i &lt; extraStudents; i++) { double max_res = 0; int p = 0; for(int j = 0; j &lt; len; j++) { double diff = (classes[j][0]+1.0) / (classes[j][1] + 1) - 1.0*classes[j][0]/classes[j][1]; if(diff &gt; max_res) { max_res = diff; p = j; } } classes[p][0]++; classes[p][1]++; // cout &lt;&lt; p &lt;&lt; endl; } for(int j = 0; j &lt; len; j++) { res += 1.0*classes[j][0]/classes[j][1]; } return res / len; }}; 虽然错了，但是这里的思路是正确的根据糖水不等式， $ (a+c)/(b+c) &gt; b / a $目标所有班级的糖水浓度之和的平均值最大，也就是浓度总和最大每份糖应该加在能使得 $ diff = (a+c)/(b+c) - b / a $ 最大化的位置上 优先队列1234567891011121314151617181920212223242526272829struct cmp { bool operator()(pair&lt;int, int&gt; &amp;a, pair&lt;int, int&gt;&amp; b) { double diff_a = (a.first + 1.0) / (a.second + 1.0) - 1.0 * a.first / a.second; double diff_b = (b.first + 1.0) / (b.second + 1.0) - 1.0 * b.first / b.second; return diff_a &lt; diff_b; }};class Solution {public: double maxAverageRatio(vector&lt;vector&lt;int&gt;&gt;&amp; classes, int extraStudents) { double res = 0; int len = classes.size(); priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, cmp&gt; queue; for(int j = 0; j &lt; len; j++) { queue.push(make_pair(classes[j][0], classes[j][1])); } for(int i = 0; i &lt; extraStudents; i++) { auto [x, y] = queue.top(); queue.pop(); queue.push(make_pair(x+1, y+1)); } while(!queue.empty()) { auto [x, y] = queue.top(); queue.pop(); res += 1.0*x/y; } return res / len; }}; 使用优先队列进行排序 用lambda1234567891011121314151617181920212223242526class Solution {public: double maxAverageRatio(vector&lt;vector&lt;int&gt;&gt;&amp; classes, int extraStudents) { double res = 0; int len = classes.size(); auto diff = [&amp;](int i) -&gt; double {return (1.0+classes[i][0])/(1+classes[i][1]) - 1.0*classes[i][0]/classes[i][1];}; auto cmp = [&amp;](int i, int j) -&gt; bool {return diff(i) &lt; diff(j);}; priority_queue&lt;int, vector&lt;int&gt;, decltype(cmp)&gt; queue(cmp); for(int j = 0; j &lt; len; j++) { queue.push(j); } for(int i = 0; i &lt; extraStudents; i++) { int j = queue.top(); queue.pop(); classes[j][0]++; classes[j][1]++; queue.push(j); } while(!queue.empty()) { int j = queue.top(); queue.pop(); res += 1.0*classes[j][0]/classes[j][1]; } return res / len; }}; 用lambda反而更慢了，不过知道了decltype的一个用法 1824. 最少侧跳次数贪心123456789101112131415161718192021222324252627282930class Solution {public: int minSideJumps(vector&lt;int&gt;&amp; obstacles) { int n = obstacles.size() - 1; vector&lt;vector&lt;int&gt;&gt; obstacles_lane(n+1, vector&lt;int&gt;(3, 0)); for(int i = 0; i &lt; 3; i++) { obstacles_lane[n][i] = n+1; } for(int i = n-1; i &gt;= 0; i--) { obstacles_lane[i][0] = obstacles_lane[i+1][0]; obstacles_lane[i][1] = obstacles_lane[i+1][1]; obstacles_lane[i][2] = obstacles_lane[i+1][2]; if(obstacles[i] != 0) { obstacles_lane[i][obstacles[i]-1] = i; } } int jump = 0; for(int i = obstacles_lane[0][1]-1; i &lt; n; ) { int max_lane = 0; for(int j = 1; j &lt; 3; j++) { if(obstacles_lane[i][j] &gt; obstacles_lane[i][max_lane]) { max_lane = j; } } jump++; i = obstacles_lane[i][max_lane]-1; } return jump; }}; 贪心，先算出右侧最远的一个障碍的位置，直接跳到那一个跑道上，再向前移动在初始的2号跑道上要先向前移动 dp123456789101112131415161718192021222324252627class Solution {public: int minSideJumps(vector&lt;int&gt;&amp; obstacles) { int n = obstacles.size() - 1; vector&lt;int&gt; dp = {1, 0 ,1}; for(int i = 1; i &lt;= n; i++) { int minCount = INT_MAX; //不跳 for(int j = 0; j &lt; 3; j++) { if(j == obstacles[i]-1) { dp[j] = INT_MAX; } else { minCount = min(minCount, dp[j]); } } //跳 for(int j = 0; j &lt; 3; j++) { if(j == obstacles[i]-1) { continue; } else { dp[j] = min(dp[j], minCount+1); } } } return min(dp[0], min(dp[1], dp[2])); }}; 对于当前位置i的跑道j如果考虑不从i-1位置跳，当前到达当前跑到所用跳数不变，如果有障碍则是无穷如果考虑如果跳到当前位置，前提是当前位置没有障碍，则是另外两个跑到跳数+1和自己本身跳数的最小值 1817. 查找用户活跃分钟数1234567891011121314class Solution {public: vector&lt;int&gt; findingUsersActiveMinutes(vector&lt;vector&lt;int&gt;&gt;&amp; logs, int k) { unordered_map&lt;int, set&lt;int&gt;&gt; UAM; vector&lt;int&gt; answer(k, 0); for(auto&amp; op:logs) { UAM[op[0]].insert(op[1]); } for(auto ite = UAM.begin(); ite!=UAM.end(); ite++) { answer[ite-&gt;second.size()-1]++; } return answer; }}; 1813. 句子相似性 III12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution {public: bool areSentencesSimilar(string sentence1, string sentence2) { vector&lt;string&gt; splitSentence1 = split(sentence1), splitSentence2 = split(sentence2); int wordCount1 = splitSentence1.size(), wordCount2 = splitSentence2.size(); if(wordCount1 &lt; wordCount2) { vector&lt;string&gt; t = splitSentence1; splitSentence1 = splitSentence2; splitSentence2 = t; } wordCount1 = splitSentence1.size();wordCount2 = splitSentence2.size(); int i = 0, j = 0; while(i &lt; wordCount1 &amp;&amp; splitSentence1[i] != splitSentence2[j]) i++; int count = i-j &gt; 0 ? 1 : 0; while(i &lt; wordCount1 &amp;&amp; j &lt; wordCount2) { while(i &lt; wordCount1 &amp;&amp; j &lt; wordCount2 &amp;&amp; splitSentence1[i] == splitSentence2[j]) { i++;j++; } if(j &lt; wordCount2) { while(i &lt; wordCount1 &amp;&amp; splitSentence1[i] != splitSentence2[j]) { i++; } count++; } else if(i &lt; wordCount1) { count++; } } if(count &lt;= 1 &amp;&amp; j == wordCount2) return true; i = wordCount1-1;j = wordCount2-1; while(i &gt;= wordCount1 &amp;&amp; splitSentence1[i] != splitSentence2[j]) i--; int count1 = j-i &gt; 0 ? 1 : 0; while(i &gt;= 0 &amp;&amp; j &gt;= 0) { while(i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; splitSentence1[i] == splitSentence2[j]) { i--;j--; } if(j &gt;= 0) { while(i &gt;= 0 &amp;&amp; splitSentence1[i] != splitSentence2[j]) { i--; } count1++; } else if(i &gt;= 0) { count1++; } } return (count1 &lt;=1 &amp;&amp; j == -1); } vector&lt;string&gt; split(const string&amp; str) { int i = 0, len = str.size(); vector&lt;string&gt; res; while(i &lt; len) { string subStr = &quot;&quot;; while(i &lt; len &amp;&amp; str[i] != ' ') { subStr += str[i]; i++; } res.push_back(subStr); while(i &lt; len &amp;&amp; str[i] == ' ' ) i++; } return res; }}; 先split，再双指针数较短的字符串将较长的字符串分成了几份，如果小于2，则ok需要正着反着各尝试一遍 题解方法12345678910111213141516171819202122232425class Solution {public: bool areSentencesSimilar(string sentence1, string sentence2) { vector&lt;string&gt; splitSentence1 = split(sentence1), splitSentence2 = split(sentence2); int wordCount1 = splitSentence1.size(), wordCount2 = splitSentence2.size(); int i = 0, j = 0; while(i &lt; wordCount1 &amp;&amp; i &lt; wordCount2 &amp;&amp; splitSentence1[i] == splitSentence2[i]) i++; while(j &lt; wordCount1-i &amp;&amp; j &lt; wordCount2-i &amp;&amp; splitSentence1[wordCount1-j-1] == splitSentence2[wordCount2-j-1]) j++; return i+j == min(wordCount1, wordCount2); } vector&lt;string&gt; split(const string&amp; str) { int i = 0, len = str.size(); vector&lt;string&gt; res; while(i &lt; len) { string subStr = &quot;&quot;; while(i &lt; len &amp;&amp; str[i] != ' ') { subStr += str[i]; i++; } res.push_back(subStr); while(i &lt; len &amp;&amp; str[i] == ' ' ) i++; } return res; }}; 由于只能添加一段，先正向找相同的单词数，再反向找“不与正向重叠的”相同的单词数，如果两者单词数相加刚好等同于较短的字符串的单词数，说明可以通过插入一句话来使两个句子相同","link":"/home/2023/02/13/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9321/"},{"title":"LeetCode-24","text":"1616. 分割两个字符串得到回文串ac代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: bool checkPalindromeFormation(string a, string b) { int len = a.length(); if(len == 1) return true; bool flaga = true, flagb = true; int i = 0; for(; i &lt; len; i++) { if(a[i] == b[len-1-i]) { } else { break; } } for(int j = i; j &lt; len-1-i; j++) { if(b[j] != b[len-1-j]) { flagb = false; break; } } for(int j = i; j &lt; len-1-i; j++) { if(a[j] != a[len-1-j]) { flaga = false; break; } } if(flaga || flagb) return true; flaga = flagb = true; for(i = 0; i &lt; len; i++) { if(a[len-1-i] == b[i]) { } else { break; } } for(int j = i; j &lt; len-1-i; j++) { if(a[j] != a[len-1-j]) { flaga = false; break; } } for(int j = i; j &lt; len-1-i; j++) { if(b[j] != b[len-1-j]) { flagb = false; break; } } return flaga || flagb; }}; ab两个字符串在同一个位置分隔开，若 $ pre_a + suf_b $ 或 $ pre_b + suf_a $ 是回文串，则返回true，否则返回false这个规则相当于ab截取相同且任意长的前缀并交换，看交换后是否存在回文我的思路是先比较a的第i位与b的倒数第i位是否想等，找到第一次不相等的位置i，此时可以从第i位分割，判断b的剩余部分是否是回文，或者从len-i-1处分割，判断a的剩余部分是否是回文若都不是，再比较b的第i位与a的倒数i位，找到第一个不满足的i，再比较a，b的剩余部分 优化行数12345678910111213141516171819202122class Solution {public: bool checkPalindromeFormation(string a, string b) { int len = a.length(); int paliA = len/2-1, paliB = len/2; while(paliA &gt; 0 &amp;&amp; a[paliA] == a[len-1-paliA]) paliA--; while(paliB &gt; 0 &amp;&amp; b[paliB] == b[len-1-paliB]) paliB--; int i, j; for(i = 0; i &lt; len/2; i++) { if(a[i] != b[len-1-i]) { break; } } for(j = 0; j &lt; len/2; j++) { if(b[j] != a[len-1-j]) { break; } } return min(paliA, paliB) &lt; max(i, j); }}; 最大的情况下执行$2*len$次 2389. 和有限的最长子序列艺术就是派大星12345678910111213141516171819class Solution {public: vector&lt;int&gt; answerQueries(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; queries) { vector&lt;int&gt; answer; int n = nums.size(), m = queries.size(); sort(nums.begin(), nums.end()); for(int i = 0; i &lt; m; i++) { int sum = 0; int count = 0; for(int j = 0; j &lt; n; j++) { if(sum + nums[j] &lt;= queries[i]) { count ++; sum += nums[j]; } } answer.push_back(count); } return answer; }}; 二分查找12345678910111213141516class Solution {public: vector&lt;int&gt; answerQueries(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; queries) { vector&lt;int&gt; answer; int n = nums.size(), m = queries.size(); sort(nums.begin(), nums.end()); for(int j = 1; j &lt; n; j++) { nums[j] += nums[j-1]; } for(int i = 0; i &lt; m; i++) { int count = upper_bound(nums.begin(), nums.end(), queries[i]) - nums.begin(); answer.push_back(count); } return answer; }}; 手写upper_bound()123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; answerQueries(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; queries) { vector&lt;int&gt; answer; int n = nums.size(), m = queries.size(); sort(nums.begin(), nums.end()); for(int j = 1; j &lt; n; j++) { nums[j] += nums[j-1]; } for(int i = 0; i &lt; m; i++) { int l = 0, r = n; while(l &lt; r) { int mid = l + (r - l) / 2; if(nums[mid] &gt; queries[i]) { r = mid; } else { l = mid+1; } } answer.push_back(l); } return answer; }}; 1615. 最大网络秩暴力12345678910111213141516171819202122232425262728293031323334353637class Solution {public: int maximalNetworkRank(int n, vector&lt;vector&lt;int&gt;&gt;&amp; roads) { vector&lt;vector&lt;bool&gt;&gt; mat(n, vector&lt;bool&gt;(n, false)); vector&lt;int&gt; count(n); for(auto&amp; r : roads) { mat[r[0]][r[1]] = true; mat[r[1]][r[0]] = true; } int max_a = 0, max_b = 0; int max_i = 0, max_j = 0; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(mat[i][j]) { count[i]++; } } if(count[i] &gt;= max_a) { max_b = max_a; max_a = count[i]; max_j = max_i; max_i = i; } else if(count[i] &gt; max_b){ max_b = count[i]; max_j = i; } } for(int i = 0; i &lt; n; i++) { for(int j = i+1; j &lt; n; j++) { if(((max_a == count[i] &amp;&amp; max_b == count[j])||(max_b == count[i] &amp;&amp; max_a == count[j])) &amp;&amp; !mat[i][j]) { return max_a + max_b; } } } return max_a + max_b - 1; }}; 先统计每个城市的道路数，找到最大的两个，然后查找在所有等于最大两个道路数的城市组合中，有无没有边的组合，否则就减一 优化后续查找123456789101112131415161718192021222324252627282930313233class Solution {public: int maximalNetworkRank(int n, vector&lt;vector&lt;int&gt;&gt;&amp; roads) { vector&lt;vector&lt;bool&gt;&gt; mat(n, vector&lt;bool&gt;(n, false)); vector&lt;int&gt; count(n), index(n); for(auto&amp; r : roads) { mat[r[0]][r[1]] = true; mat[r[1]][r[0]] = true; } for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(mat[i][j]) { count[i]++; } } index[i] = i; mat[i][i] = true; } sort(index.begin(), index.end(), [&amp;](int a, int b)-&gt;bool{return count[a] &lt; count[b];}); int x = n-1,y = n-2; while(x &gt;= 0 &amp;&amp; count[index[x]] == count[index[n-1]]) { y = x-1; while(y &gt;= 0 &amp;&amp; count[index[y]] == count[index[n-2]]) { if(!mat[index[x]][index[y]]) { return count[index[n-1]] + count[index[n-2]]; } y--; } x--; } return count[index[n-1]] + count[index[n-2]] - 1; }}; 1605. 给定行和列的和求可行矩阵12345678910111213141516class Solution {public: vector&lt;vector&lt;int&gt;&gt; restoreMatrix(vector&lt;int&gt;&amp; rowSum, vector&lt;int&gt;&amp; colSum) { int m = rowSum.size(),n = colSum.size(); vector&lt;vector&lt;int&gt;&gt; res = vector&lt;vector&lt;int&gt;&gt;(m, vector&lt;int&gt;(n)); for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; n; j++) { int x = min(rowSum[i], colSum[j]); res[i][j] = x; rowSum[i] -= x; colSum[j] -= x; } } return res; }}; 根据行列和的要求，当前方格中可以填入的最大值是两个要求的最小值，直接填入该值，并更新对应位置的要求 2383. 赢得比赛需要的最少训练时长12345678910111213class Solution {public: int minNumberOfHours(int initialEnergy, int initialExperience, vector&lt;int&gt;&amp; energy, vector&lt;int&gt;&amp; experience) { int eng = 1, expLeft = 0, len = energy.size(); int exp = 0; for(int i = 0; i &lt; len; i++) { eng += energy[i]; exp = max(exp, experience[i] - expLeft+1); expLeft += experience[i]; } return (eng &gt; initialEnergy ? eng - initialEnergy : 0) + (exp &gt; initialExperience ? exp - initialExperience : 0); }}; 能量是从左到右消耗的，所以初始能量大于能量总和就可以经验是可以从左到右累积的，所以初始经验大于当前对手的经验减去累积的经验就可以了 1625. 执行操作后字典序最小的字符串过于暴力1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: map&lt;string, bool&gt; visited; int len, a, b; void add(string&amp; s) { for(int i = 1; i &lt; len; i+=2) { s[i] = (s[i] + a)%10; } } string rotate(string s) { string ret; for(int i = 0; i &lt; len; i++) { ret.push_back(s[(i+b)%len]); } return ret; } void search(string s) { if(visited.count(s) != 0) { return; } visited[s] = true; search(rotate(s)); add(s); search(s); } string findLexSmallestString(string s, int a, int b) { this-&gt;len = s.size(); this-&gt;a = a; this-&gt;b = b; for(int i = 0; i &lt; len; i++) { s[i] -= '0'; } search(s); string ret = visited.begin()-&gt;first; for(int i = 0; i &lt; len; i++) { ret[i] += '0'; } return ret; }}; 暴力，硬搜，把所有可能情况都算出来 面试题 17.05. 字母与数字12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;string&gt; findLongestSubarray(vector&lt;string&gt;&amp; array) { int len = array.size(); vector&lt;int&gt; sum(len); sum[0] = isalpha(array[0][0]) ? 1 : -1; for(int i = 1; i &lt; len; i++) { sum[i] = sum[i-1] + (isalpha(array[i][0]) ? 1 : -1); } unordered_map&lt;int, int&gt; m; int left = 0, right = -1; for(int i = 0; i &lt; len; i++) { if(sum[i] == 0) { if(i &gt; right - left) { left = 0; right = i; } } else { if(!m.count(sum[i])) { m[sum[i]] = i + 1; } else { if(i - m[sum[i]] &gt; right - left) { right = i; left = m[sum[i]]; } } } } return {array.begin() + left, array.begin() + right + 1}; }}; 使用前缀和，sum表示字母比数字多多少，如果是0，则说明区间[0,i]上是字母数字平衡的对于不是0的情况，若[0,a]字母比数字多n个，[0,b]字母比数字也多n个，则[a+1,b]中，数字字母一样多由于求最长子串，则存每个n第一次出现的位置即可","link":"/home/2023/03/18/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9324/"},{"title":"LeetCode-25","text":"Your browser does not support the audio element. [hard] 1377. T 秒后青蛙的位置题目分析题目强调为一颗无向树，每次访问未访问过的节点。也就是说，每秒若有子节点，则跳到子节点，否则呆在原地不动。 也就是根据题目构造一棵根节点为1的树，并按照层次遍历该树即可。但是题目输入的边并不一定以1为根节点。 代码 实际构造为图 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution {public: vector&lt;bool&gt; visited; int n; double frogPosition(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int t, int target) { vector&lt;vector&lt;int&gt;&gt; tree(n+1, vector&lt;int&gt;(n+1, 0)); visited = vector&lt;bool&gt;(n+1, false); this-&gt;n = n; for(auto&amp; e : edges) { if(!tree[e[0]][e[1]]) { tree[e[0]][0]++; } if(!tree[e[1]][e[0]]) { tree[e[1]][0]++; } tree[e[0]][e[1]] = 1; tree[e[1]][e[0]] = 1; } return level(tree, t, 1, target, 1); } double level(vector&lt;vector&lt;int&gt;&gt;&amp; tree, int t, int root, int target, double prob) { int len = tree[root][0]; for(int i = 1; i &lt;= n; i++) { if(visited[i] &amp;&amp; tree[root][i]) len--; } // printf(&quot;root = %d, len = %d\\n&quot;, root, len); if(root == target) { if((t &gt; 0 &amp;&amp; len == 0) || t == 0) { return prob; } else if (t &lt; 0){ return 0.0; } } visited[root] = true; for(int e = 1; e &lt;= n; e++) { if(!tree[root][e] || visited[e])continue; double ret; if((ret = level(tree, t-1, e, target, prob * 1.0 / len)) != 0) { return ret; } } return 0; }}; 时间 28ms 击败25.75%空间 20MB 击败 5.30% 优化visited数组考虑到输入是严格的树，在层次遍历时，不希望访问已经访问过的节点，这种节点只有双亲节点一种可能。 所以对于非根节点，子节点数，就是 $ N_{与之相邻的边}-1 $，层次遍历时只要知道其父节点，不去访问父节点即可 对于根节点，添加一条边$ &lt;0, 1&gt; $即可 1234567891011121314151617181920212223242526272829303132333435class Solution {public: int n; double frogPosition(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int t, int target) { vector&lt;vector&lt;int&gt;&gt; tree(n+1, vector&lt;int&gt;(1, 0)); this-&gt;n = n; edges.push_back({0, 1}); for(auto&amp; e : edges) { tree[e[0]][0]++; tree[e[1]][0]++; tree[e[0]].push_back(e[1]); tree[e[1]].push_back(e[0]); } return level(tree, t, 1, target, 1, 0); } double level(vector&lt;vector&lt;int&gt;&gt;&amp; tree, int t, int root, int target, double prob, int parent) { int len = tree[root][0] - 1; if(root == target) { if((t &gt; 0 &amp;&amp; len == 0) || t == 0) { return prob; } else if (t &lt; 0){ return 0.0; } } for(int i = 1; i &lt;= len+1; i++) { int e = tree[root][i]; if(e == parent)continue; double ret; if((ret = level(tree, t-1, e, target, prob * 1.0 / len, root)) != 0) { return ret; } } return 0; }}; 时间 12 ms 击败 97.73%内存 15.1 MB 击败 31.82% [Medium] 1090. 受标签影响的最大值分析重量都为1的背包问题，如果把labels看作物品的分类，对每类物品的限制都相同，都至多有useLimit个，每类物品中其value也不尽相同 优先队列对于每个label，维护一个value由大到小的优先队列，每次从所有队列中取最大的一个数，若队列空或此类label已经超过useLimit限制，则不再考虑该label 排序优化，根据label排序，相同la 代码12345678910111213141516171819202122232425262728293031323334353637class Solution {public: int largestValsFromLabels(vector&lt;int&gt;&amp; values, vector&lt;int&gt;&amp; labels, int numWanted, int useLimit) { int n = values.size(); vector&lt;int&gt; index = vector&lt;int&gt;(n); map&lt;int, int&gt; limit; iota(index.begin(), index.end(), 0); sort(index.begin(), index.end(), [&amp;](int a, int b){ if(labels[a] != labels[b]) { return labels[a] &gt; labels[b]; } else { return values[a] &gt; values[b]; } }); auto cmp = [&amp;](int a, int b){return values[index[a]] &lt; values[index[b]];}; priority_queue&lt;int, vector&lt;int&gt;, decltype(cmp)&gt; q(cmp); q.push(0); limit[labels[index[0]]] = useLimit; for(int i = 1; i &lt; n; i++) { if(labels[index[i]] != labels[index[i-1]]) { q.push(i); } limit[labels[index[i]]] = useLimit; } int sum = 0; for(int K = 0; K &lt; numWanted &amp;&amp; !q.empty(); K++) { int i = q.top(); q.pop(); sum += values[index[i]]; limit[labels[index[i]]]--; if(i + 1 &lt; n &amp;&amp; labels[index[i+1]] == labels[index[i]] &amp;&amp; limit[labels[index[i]]]) { q.push(i + 1); } } return sum; }}; 时间 52 ms 击败 7.94%内存 19.3 MB 击败 61.22% 优化想复杂了，只要按照值排序后，从大到小按照限制选择即可，并记录每个标签所选次数就好了 123456789101112131415161718192021class Solution {public: int largestValsFromLabels(vector&lt;int&gt;&amp; values, vector&lt;int&gt;&amp; labels, int numWanted, int useLimit) { int n = values.size(); vector&lt;int&gt; index = vector&lt;int&gt;(n); map&lt;int, int&gt; limit; iota(index.begin(), index.end(), 0); sort(index.begin(), index.end(), [&amp;](int a, int b){ return values[a] &gt; values[b]; }); int sum = 0; for(int K = 0, i = 0; K &lt; numWanted &amp;&amp; i &lt; n; i++) { if(limit[labels[index[i]]] &lt; useLimit) { sum += values[index[i]]; limit[labels[index[i]]]++; K++; } } return sum; }}; [Medium] 1080. 根到叶路径上的不足节点分析按照题意，首先对二叉树遍历 当到达叶节点时，计算根节点到叶节点的总和 如果大于等于limit，则该节点及其所有祖先节点都不需要删除，此时返回true 否则返回false。 对于非叶子节点 如果左右子树返回了true，该节点不需要被删除，向其父节点返回true 则返回true的子树不需要被删除 返回false的子节点置为nullptr，需要被删除 如果都返回了false，则该节点需要被删除。向其父节点返回false 代码123456789101112131415161718192021222324252627282930class Solution {public: int limit; TreeNode* sufficientSubset(TreeNode* root, int limit) { this-&gt;limit = limit; if(root &amp;&amp; cal(root, 0)) { return root; } return nullptr; } bool cal(TreeNode *root, int n) { bool ret = false; if(!root-&gt;left &amp;&amp; !root-&gt;right) { n += root-&gt;val; ret = n &gt;= limit; } else { if(root-&gt;left &amp;&amp; cal(root-&gt;left, root-&gt;val + n)) { ret = true; } else { root-&gt;left = nullptr; } if(root-&gt;right &amp;&amp; cal(root-&gt;right, root-&gt;val + n)) { ret = true; } else { root-&gt;right = nullptr; } } return ret; }}; 时间 40 ms 击败 66.87%内存 32.2 MB 击败 48.64% [Easy] 2451. 差值数组不同的字符串分析依次对所有字符串计算相邻两个字符之间的差值，找到差值不同的那一个 计算第一个字符串的差值，寻找第一个与其不同的字符串 若第一个与其不一样的字符串下标大于1，则[0, j-1]是相同的，j为与其他不同的字符串 若等于1 words总长度为2，则0，1两串不同，返回任意一个即可 总长度大于2，查看字符串2的差值，若与1相同则返回0，否则返回1 代码123456789101112131415161718192021222324252627class Solution {public: string oddString(vector&lt;string&gt;&amp; words) { int len = words[0].size(); int n = words.size(); for(int i = 1; i &lt; len; i++) { int diff = words[0][i] - words[0][i-1]; int j = 1; while(j &lt; n &amp;&amp; words[j][i] - words[j][i-1] == diff) { j++; } if(j == n) { continue; } if(j &gt; 1 || n == 2) { return words[j]; } else { if(words[2][i] - words[2][i-1] == diff) { return words[1]; } else { return words[0]; } } } return words[0]; }}; [Easy] LCP 33. 蓄水分析实际难度应该是hard吧，好难 直接抄答案 代码1234567891011121314151617181920class Solution {public: int storeWater(vector&lt;int&gt;&amp; bucket, vector&lt;int&gt;&amp; vat) { int n = bucket.size(); int maxx = 0; for(int i = 0; i &lt; n; i++) { maxx = max(maxx, vat[i]); } if(maxx == 0) return 0; int res = INT_MAX; for(int k = 1; k &lt;= maxx &amp;&amp; k &lt; res; k++) { int t = 0; for(int i = 0; i &lt; n; i++) { t += max(0, (vat[i] + k - 1) / k - bucket[i]); } res = min(res, t+k); } return res; }}; [Hard] 1373. 二叉搜索子树的最大键值和分析对于每个节点 $ node $， 首先要判断其是否为bst，如果是bst计算以node为根的子树之和 用bst函数的返回值返回是否为bst，三个参数分别返回子树之和，子树的最大值，子树的最小值 子树的最大值即，左子树的子树最大值，右子树子树最大值，根节点的值三者最大值 子树最小值即，左子树的子树最小值，右子树子树最小值，根节点的值三者最小值 题目中的不合理： 123输入：root = [-4,-2,-5]输出：0解释：所有节点键值都为负数，和最大的二叉搜索树为空。 这个输入的输出应该是-2，而非0。定义中只要求左子树小于根，右子树大于根，并未要求正负。 123输入：root = [4,3,null,1,2]输出：2解释：键值为 2 的单节点子树是和最大的二叉搜索树。 根据这个输入知道，单节点也算是二叉搜索树，那2算最大子树，-2也应该算最大子树 代码12345678910111213141516171819202122232425262728293031class Solution {public: int maxx = INT_MIN; int maxSumBST(TreeNode* root) { int sum = 0, lmax, rmin; bool ok = bst(root, sum, lmax, rmin); if(ok) { maxx = max(maxx, sum); } return max(0, maxx); } bool bst(TreeNode *root, int&amp; sum, int&amp; leftMax, int&amp; rightMin) { if(root == nullptr) return true; int lsum = 0, rsum = 0; int llMax = INT_MIN, lrMin = INT_MAX; int rlMax = INT_MIN, rrMin = INT_MAX; bool lok = bst(root-&gt;left, lsum, llMax, lrMin); bool rok = bst(root-&gt;right, rsum, rlMax, rrMin); leftMax = max(root-&gt;val, max(llMax, rlMax)); rightMin = min(root-&gt;val, min(lrMin, rrMin)); if(lok &amp;&amp; rok) { bool ok = (!root-&gt;left || llMax &lt; root-&gt;val) &amp;&amp; (!root-&gt;right || rrMin &gt; root-&gt;val); if(ok) { sum += root-&gt;val + lsum + rsum; maxx = max(maxx, sum); } return ok; } return false; }}; [Medium] 1079. 活字印刷分析状态压缩+bfs总长度最大只有7，最多7个不同字符，直接暴力枚举所有情况 需要记录当前有哪些位使用了，哪些没有使用，用int的最后7位表示 不需要真的生成字符串，只要对每个字符编码，计算一个8进制数就好了 code12345678910111213141516171819202122232425262728293031323334class Solution {public: set&lt;int&gt; strset; vector&lt;int&gt; tiles_int; int n; int numTilePossibilities(string tiles) { this-&gt;n = tiles.length(); tiles_int = vector&lt;int&gt;(n, 0); int tile_count = 1; tiles_int[0] = 1; sort(tiles.begin(), tiles.end()); for(int i = 1; i &lt; n; i++) { if(tiles[i] == tiles[i-1]) { tiles_int[i] = tile_count; } else { tiles_int[i] = ++tile_count; } } dfs(0, 0); return strset.size(); } void dfs(int state, int s) { int mask = 1; for(int i = 0; i &lt; n; i++) { if(!(mask &amp; state)) { int next_str = (s &lt;&lt; 3) + tiles_int[i]; strset.insert(next_str); dfs(state | mask, next_str); } mask &lt;&lt;= 1; } }}; 时间 40 ms 击败 27.67%内存 12.1 MB 击败 32.56% 优化既然排序了，那相同字符就不用重复考虑了 1234567891011121314151617181920212223242526272829303132333435class Solution {public: set&lt;int&gt; strset; vector&lt;int&gt; tiles_int; int n; int numTilePossibilities(string tiles) { int len = tiles.length(); int tile_count = 1; n = 1; sort(tiles.begin(), tiles.end()); for(int i = 1; i &lt; len; i++) { if(tiles[i] != tiles[i-1]) { tiles_int.push_back(tile_count); tile_count = 1; n++; } else { ++tile_count; } } tiles_int.push_back(tile_count); dfs(0); return strset.size(); } void dfs(int s) { for(int i = 0; i &lt; n; i++) { if(tiles_int[i]) { int next_str = (s &lt;&lt; 3) + i + 1; strset.insert(next_str); tiles_int[i]--; dfs(next_str); tiles_int[i]++; } } }}; 继续优化参考题解，同时结合上面的分析，既然排序后不存在重复了，那可以直接计数，不需要set了 12345678910111213141516171819202122232425262728293031323334class Solution {public: vector&lt;int&gt; tiles_int; int n; int numTilePossibilities(string tiles) { int len = tiles.length(); int tile_count = 1; n = 1; sort(tiles.begin(), tiles.end()); for(int i = 1; i &lt; len; i++) { if(tiles[i] != tiles[i-1]) { tiles_int.push_back(tile_count); tile_count = 1; n++; } else { ++tile_count; } } tiles_int.push_back(tile_count); return dfs(0); } int dfs(int s) { int ret = 0; for(int i = 0; i &lt; n; i++) { if(tiles_int[i]) { int next_str = (s &lt;&lt; 3) + i + 1; tiles_int[i]--; ret += dfs(next_str) + 1; tiles_int[i]++; } } return ret; }}; [Medium] 1091. 二进制矩阵中的最短路径分析一眼BFS，但是一直超时 超时12345678910111213141516171819202122232425262728293031323334class Solution {public: int shortestPathBinaryMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); queue&lt;pair&lt;int, int&gt;&gt; q; if(!grid[0][0] &amp;&amp; !grid[n-1][n-1]) q.push(make_pair(0, 1)); vector&lt;bool&gt; visited = vector&lt;bool&gt;(n * n, false); while(!q.empty()) { auto [pos, len] = q.front(); q.pop(); if(len &gt; n*n) continue; visited[pos] = true; int x = pos / n, y = pos % n; if(x == n-1 &amp; y == n-1) { return len; } for(int dx = -1; dx &lt;= 1; dx++) { for(int dy = -1; dy &lt;= 1; dy++) { pos = pos2int(x + dx, y + dy, n); if(!checkpos(x+dx, y+dy, n) || grid[x+dx][y+dy] || visited[pos]) continue; q.push({pos, len+1}); } } } return -1; } inline bool checkpos(int x, int y, int n) { return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &lt; n; } inline int pos2int(int x, int y, int n) { return x*n + y; }}; 在入队时就应该吧visited置为true 代码1234567891011121314151617181920212223242526272829303132333435class Solution {public: int shortestPathBinaryMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); vector&lt;bool&gt; visited = vector&lt;bool&gt;(n * n, false); queue&lt;pair&lt;int, int&gt;&gt; q; if(!grid[0][0] &amp;&amp; !grid[n-1][n-1]){ q.push(make_pair(0, 1)); visited[0] = true; } while(!q.empty()) { auto [pos, len] = q.front(); q.pop(); int x = pos / n, y = pos % n; if(x == n-1 &amp; y == n-1) { return len; } for(int dx = -1; dx &lt;= 1; dx++) { for(int dy = -1; dy &lt;= 1; dy++) { pos = pos2int(x + dx, y + dy, n); if(!checkpos(x+dx, y+dy, n) || grid[x+dx][y+dy] || visited[pos]) continue; q.push({pos, len+1}); visited[pos] = true; } } } return -1; } inline bool checkpos(int x, int y, int n) { return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &lt; n; } inline int pos2int(int x, int y, int n) { return x*n + y; }}; 时间 44 ms 击败 91.20%内存 18.8 MB 击败 68.63% [Medium] 1073. 负二进制数相加分析找规律首先分析其相加的规律 123456789101112131415161718// 1 + 1 = 110// 00 + 00 = 00,00// 10 + 10 = 11,00// 11 + 11 = 00,10// 10 + 00 = 00,10// 00 + 10 = 00,10// 11 + 00 = 00,11// 11 + 10 = 11,01// 10 + 11 = 11,01// 01 + 11 = 00,00// 100 + 100 = 11000// 101 + 101 = 11000 + 110 = 11110// 110 + 110 = 100// 111 + 111 = 11010// 1111 + 1111 = 1010 发现，1位，3位的结果相当于前面补0后偶数位的结果 总结转换矩阵以相邻两位为单位，有如下转换关系 123456vector&lt;vector&lt;int&gt;&gt; transform = { {0b0000, 0b0001, 0b0010, 0b0011}, // 00 + xx {0b0001, 0b0110, 0b0011, 0b0000}, // 01 + xx {0b0010, 0b0011, 0b1100, 0b1101}, // 10 + xx {0b0011, 0b0000, 0b1101, 0b0010} // 11 + xx}; 将多出来的高两位视为进位，低两位视为相加结果 进位考虑到进位，以及进位的进位，需要比最长数字多四位 $$\\begin{equation*}\\begin{aligned}&amp;&amp;&amp;&amp;&amp;&amp;x_1&amp;x_0&amp;\\+&amp;&amp;&amp;&amp;&amp;&amp;y_1&amp;y_0&amp;\\=&amp;&amp;&amp;&amp;t_{13}&amp;t_{12}&amp;t_{11}&amp;t_{10}&amp;\\+&amp;&amp;&amp;&amp;&amp;&amp;c_{1}&amp;c_{0}&amp;\\=&amp;&amp;&amp;&amp;t_{23}&amp;t_{22}&amp;t_{21}&amp;t_{20}&amp;\\+&amp;&amp;&amp;&amp;t_{13}&amp;t_{12}&amp;&amp;&amp;&amp;\\=&amp;&amp;t_{33}&amp;t_{32}&amp;t_{31}&amp;t_{30}&amp;t_{21}&amp;t_{20}&amp;\\\\end{aligned}\\end{equation*}$$ c代表进位，t代表相加后的结果 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution {public: vector&lt;vector&lt;int&gt;&gt; transform = { {0b0000, 0b0001, 0b0010, 0b0011}, // 00 + xx {0b0001, 0b0110, 0b0011, 0b0000}, // 01 + xx {0b0010, 0b0011, 0b1100, 0b1101}, // 10 + xx {0b0011, 0b0000, 0b1101, 0b0010} // 11 + xx }; vector&lt;int&gt; addNegabinary(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2) { int len1 = arr1.size() - 1, len2 = arr2.size() - 1; if(len1 % 2 == 0) { arr1.insert(arr1.begin(), 0); len1++; } if(len2% 2 == 0) { arr2.insert(arr2.begin(), 0); len2++; } // 补成偶数 vector&lt;int&gt; summ = vector&lt;int&gt;(max(len1, len2) + 5, 0); //多分配四位 int len_res = max(len1, len2) + 5 - 1; for(int i = 0; len1 &gt; 0 || len2 &gt; 0; len1-=2, len2-=2, i+=2) { int x = len1 &gt; 0 ? (arr1[len1-1]&lt;&lt;1) + (arr1[len1]) : 0; int y = len2 &gt; 0 ? (arr2[len2-1]&lt;&lt;1) + (arr2[len2]) : 0; int carry = (summ[i+1]&lt;&lt;1) + (summ[i]); int trans1 = transform[x][y]; // x + y int trans2 = transform[trans1&amp;0b0011][carry]; // 低二位(x + y) + carry int trans3 = transform[(trans1&amp;0b1100) &gt;&gt; 2][(trans2&amp;0b1100) &gt;&gt; 2]; // 高二位 summ[i] = trans2&amp;0b0001; summ[i+1] = (trans2&amp;0b0010) &gt;&gt; 1; summ[i+2] = (trans3&amp;0b0001); summ[i+3] = (trans3&amp;0b0010) &gt;&gt; 1; summ[i+4] = (trans3&amp;0b0100) &gt;&gt; 2; summ[i+5] = (trans3&amp;0b1000) &gt;&gt; 3; } //计算 while(!summ.empty() &amp;&amp; summ.back() == 0) summ.pop_back(); if(summ.size() == 0) summ = {0}; // 删除前导0 reverse(summ.begin(), summ.end()); return summ; }}; 时间 4 ms 击败 90.75%内存 19.3 MBn 击败 5.2% [Medium] 1093. 大样本统计分析看起来很简单的题目，还是错了两次 计算总数偶数个中位数，且中位数两个数不相等时，没有考虑到两个数直接相差可能大于1，既第 $ summ/2 $ 与 $ summ/2 + 1 $ 之间有很多数为0的情况 对0-255加权求和时，右边应该先转double再计算，防止int溢出 代码class Solution { public: vector&lt;double&gt; sampleStats(vector&lt;int&gt;&amp; count) { int minmum = 255; int maximum = 0; double mean = 0; double mode = 0; double medium = 0; int summ = 0; for(int i = 0; i &lt; 256; i++) { if(count[i] &gt; 0) { minmum = min(minmum, i); maximum = max(maximum, i); summ += count[i]; mean += 1.0*i*count[i]; } if(count[i] &gt; count[mode]) { mode = i; } } mean /= summ; { int i = 0, c = count[0]; for(; c&lt;summ/2; c+=count[++i])continue; if(summ%2 == 0) medium = i; for(; c&lt;=summ/2; c+=count[++i])continue; medium += i; if(summ%2 == 0) { medium /= 2; } } return {(double)minmum, (double)maximum, mean, medium, mode}; } };","link":"/home/2023/05/24/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9325/"},{"title":"LeetCode-26","text":"[Medium] 1110. 删点成林分析 使用什么样的数据结构 直接用数组 用孩子兄弟表示法 使用什么样的遍历方法？ 代码1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: vector&lt;TreeNode*&gt; forest; vector&lt;TreeNode*&gt; delNodes(TreeNode* root, vector&lt;int&gt;&amp; to_delete) { if(root){ if(del(root, to_delete)) { push_forest(root); } else { forest.push_back(root); } } return forest; } bool del(TreeNode* root, vector&lt;int&gt;&amp; to_delete) { if(root-&gt;left &amp;&amp; del(root-&gt;left, to_delete)) { push_forest(root-&gt;left); root-&gt;left = nullptr; } if(root-&gt;right &amp;&amp; del(root-&gt;right, to_delete)) { push_forest(root-&gt;right); root-&gt;right = nullptr; } for(int d : to_delete) { if(d == root-&gt;val) { return true; } } return false; } void push_forest(TreeNode *root) { if(root-&gt;left) { forest.push_back(root-&gt;left); } if(root-&gt;right) { forest.push_back(root-&gt;right); } }}; 结果 若使用孩子兄弟表示法，需要将二叉树转换为孩子兄弟，处理好后在转换回来，同时将根节点及其兄弟变成数组，不如直接用数组 若使用先序，若不知道孩子是否应该被删除，而直接放入最终结果中，若子节点也需要被删除，那么处理将会变得复杂 时间 16 ms 击败 92.74%内存 24.6 MB 击败 85.48% [Hard] 1439. 有序矩阵中的第 k 个最小数组和分析总体思路小顶堆+n指针 我们已知mat的每一行都是非递减的，那么最小的元素一定是全部取每行第一个元素的情况。我们记录为状态[0,0,0,0,...] 参考bfs的思想，在初始状态的基础上移动一个指针，一定比第初始状态大 此处贪心，每次选取最小的状态（即n个指针对应元素之和最小的），将其下一步状态生成出来，生成k次后，即为第k小的状态 状态转换易知初始状态S=[0,0,0,...,0]的下一步为 S1=[1,0,0,...,0] S2=[0,1,0,...,0] S3=[0,0,1,...,0] ... Sn=[0,0,0,...,1] 然而对于状态Si的第j个子状态与Sj的第i个子状态都是Sij=Sji=[0,0,0,...,1,...,1,...,0]。为了防止重复，规定，Si只能从第i个指针及其后面的指针向后移动一位表示为 pair&lt;int, vector&lt;int&gt;&gt;(i, {0,0,0,...,1,...,0})此处i为该状态允许向后移动的指针第一个指针 注意12输入：mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7输出：9 状态[0,2,0]小于[1,0,0]。也就是移动指针次数多的，其值可能反而比移动次数少的更小，这也是使用堆的原因 代码12345678910111213141516171819202122232425262728293031323334353637class Solution {public: int m, n; int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int k) { m = mat.size(), n = mat[0].size(); auto cmp = [&amp;](pair&lt;int, vector&lt;int&gt;&gt;&amp; a, pair&lt;int, vector&lt;int&gt;&gt;&amp; b) { int suma = 0, sumb = 0; for(int i = 0; i &lt; m; i++) { suma += mat[i][a.second[i]]; sumb += mat[i][b.second[i]]; } return suma &gt; sumb; }; priority_queue&lt;pair&lt;int, vector&lt;int&gt;&gt;, vector&lt;pair&lt;int, vector&lt;int&gt;&gt;&gt;, decltype(cmp)&gt; q(cmp); vector&lt;int&gt; state = vector&lt;int&gt;(m, 0); q.push(make_pair(0, state)); while(k--) { auto tmp = q.top(); q.pop(); state = tmp.second; for(int i = tmp.first; i &lt; m; i++) { if(state[i] + 1 &gt;= n) continue; state[i]++; q.push(make_pair(i, state)); state[i]--; } } return value(state, mat); } int value(const vector&lt;int&gt;&amp; v, vector&lt;vector&lt;int&gt;&gt;&amp; mat) { int sum = 0; for(int i = 0; i &lt; m; i++) { sum += mat[i][v[i]]; } return sum; }}; 优化代码 使用数组前两位代表原来的i和value，减少重复计算value 使用前一步状态的value计算新value，减少遍历次数 使用--k而不是k--，第k个无需计算其后代，后代一定不比他小12345678910111213141516171819202122232425262728293031class Solution {public: int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int k) { int m = mat.size(), n = mat[0].size(); auto cmp = [&amp;](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) { return a[1] &gt; b[1]; }; priority_queue&lt;vector&lt;int&gt;, vector&lt;vector&lt;int&gt;&gt;, decltype(cmp)&gt; q(cmp); vector&lt;int&gt; state = vector&lt;int&gt;(m+2, 0); for(int i = 0; i &lt; m; i++) { state[1] += mat[i][0]; } q.push(state); while(--k) { state = q.top(); q.pop(); int oldvalue = state[1]; for(int i = state[0]; i &lt; m; i++) { if(state[i+2] + 1 &gt;= n) continue; state[1] -= mat[i][state[i+2]]; state[i+2]++; state[0] = i; state[1] += mat[i][state[i+2]]; q.push(state); state[i+2]--; state[1] = oldvalue; } } return q.top()[1]; }}; 时间 16 ms 击败 93.5%内存 14.4 MB 击败 38.35% [Medium] 1130. 叶值的最小代价生成树分析观察测试用例123输入：arr = [6,2,4]输出：32解释：有两种可能的树，第一种的非叶节点的总和为 36 ，第二种非叶节点的总和为 32 。 这里一共两种方法 先选择arr[0]和arr[1] 先选择arr[1]和arr[2] 第二种最后代价最小 这里就联想到数据结构中哈夫曼树的算法。略有不同： 不能对数组排序，因为他对应着中序遍历 生成父节点时，要找到两个节点子树中叶节点的最大值 构造算法根据哈夫曼树算法，每次选取两个节点，生成一个父节点，存入数组中，此时数组多了一个空闲节点，这个节点就用来存放该父节点下的最大叶子。 初始情况下，直接选择乘积最小的两个相邻节点node1, node2生成父节点node，此时将父节点插入原来node1的位置，node2的位置用来保存max(node1, node2)。 此时需要一个辅助数组标记每个位置是节点还是信息，用true代表其是节点 后续中，每次选择两个相邻的节点（两个相邻的true或者两个true之间只有false），选择乘积最小的两对，此时有以下几种情况 110… //两个连续1且第二个1后面有0（第二个节点为非叶） 111… // 两个都叶 10..11.. // 第一个节点非叶，第二个为叶子 10..10..0 // 两个都非叶，且没有下一对节点了 10..10..1 // 两个都非叶，且有下一对节点了 11 // 两个都叶且没有下一对节点了 10…1 // 第一个节点非叶，第二个为叶子且没有下一对节点了 也就是需要考虑两个节点是否是叶子的情况，还有没有下一对节点的情况，不论何种情况，都将node1位置存放生成的父节点node，node1位置+1存放最大叶子。这样如果一个节点为后面位置为false，则后面这个数就是子树中的最大叶子 按照哈夫曼树算法，重复n-1次上面操作 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution {public: int mctFromLeafValues(vector&lt;int&gt;&amp; arr) { int n = arr.size(); int ret = 0; vector&lt;bool&gt; available = vector&lt;bool&gt;(n, true); for(int cnt = 0; cnt &lt; n - 1; cnt++) { int i = 0, j = 0; int mini = 0, minj = 0; int minn = INT_MAX, minn1, minn2; while(i &lt; n &amp;&amp; !available[i]) i++; j = i+1; while(j &lt; n) { while(j &lt; n &amp;&amp; !available[j]) j++; if(j &gt;= n) break; int node = 0, node1, node2; if(available[i+1]) { node1 = arr[i]; } else { node1 = arr[i+1]; } if(j + 1 &lt; n &amp;&amp; !available[j+1]) { node2 = arr[j+1]; } else { node2 = arr[j]; } node = node1 * node2; if(node &lt; minn) { mini = i; minj = j; minn = node; minn1 = node1; minn2 = node2; } i = j; j++; } ret += minn; arr[mini+1] = max(minn1, minn2); arr[mini] = minn; available[mini+1] = false; available[minj] = false; } return ret; }}; 时间 4 ms 击败 77.21%内存 8.2 MB 击败 61.86% 优化由于最大只有40个节点，状态也只有true, false，只需要一个long long就可以代替available数组 时间 $ O(n^2) $ 空间 $ O(1) $ 参考这个题解，我的思路其实与他完全相似，且没必要存储父节点的值（每次父节点的值保存起来，但是计算时都用不到），只要把较小的值删除就好 123456789101112131415161718class Solution {public: int mctFromLeafValues(vector&lt;int&gt;&amp; arr) { int n = arr.size(), ret = 0; for(int cnt = n - 1; cnt &gt; 0; cnt--) { // cnt恰好就是数组的size int min_index = 0, minn = INT_MAX; for(int i = 0; i &lt; cnt; i++) { if(arr[i] * arr[i+1] &lt; minn) { minn = arr[i] * arr[i+1]; min_index = arr[i] &lt; arr[i+1] ? i : i + 1; } } ret += minn; arr.erase(arr.begin() + min_index); } return ret; }}; [Medium] 1156. 单字符重复子串的最大长度分析观察样例12输入：text = &quot;ababa&quot;输出：3 把这一类拓展，归类为单层汉堡类型也就是$ XX…XyXX…X $ 用cnt[alpha]表示字符alpha在整个字符串中出现的次数 这类情况会有两种解决方法 若y左边有连续a1个X，右边有a2个X 若a1 + a2 &lt; cnt[X]，则将y与a1,a2之外的另一个X交换，X总长度为a1 + a2 + 1 若a1 + a2 == cnt[X]，则将y与a1中第一个X交换，X总长度为a1 + a2 = cnt[X] 把这在单层汉堡的情况下继续拓展，若遇到多层汉堡，即夹心y(可能为：生菜* $ n_1 $，牛肉饼*$n_2$，番茄酱*$n_3$，酸黄瓜*$n_4 $等多种类型的)的个数大于1$ XX…Xy_1y_2…y_nXX…X $ 这类情况会有两种解决方法 若y左边有连续a1个X，右边有a2个X 若a1 &gt;= a2，则将$ y_1 $与a2之中的一个X交换，X总长度为a1 + 1 若a1 &lt;= a2，则将$ y_n $于a1中的一个X交换，X总长度为a2 + 1 上面两种情况统称汉堡类型，即至少三层 对于两层的披萨模型以及一层的饼干模型 只要统计每种字符的个数即可取最大值即可 代码123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: int maxRepOpt1(string text) { int cnt[26] = {0}; int n = text.length(); for(int i = 0; i &lt; n; i++) { text[i] -= 'a'; cnt[text[i]]++; } int i = 0; int last_end[26] = {-1}, last_cnt[26] = {0}; int ret = 0; while(i &lt; n) { int counti = 0; int j = i; while(j &lt; n &amp;&amp; text[i] == text[j]) { j++; counti++; } if(last_cnt[text[i]] != 0) { if(i - last_end[text[i]] == 2) { if(cnt[text[i]] == counti + last_cnt[text[i]]) { ret = max(ret, counti + last_cnt[text[i]]); } else { ret = max(ret, 1 + counti + last_cnt[text[i]]); } } else { ret = max(ret, 1 + max(counti, last_cnt[text[i]])); } } else { ret = max(ret, counti); } last_end[text[i]] = j-1; last_cnt[text[i]] = counti; i = j; } return ret; }}; [Medium] 2352. 相等行列对暴力12345678910111213141516171819202122class Solution {public: int equalPairs(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); int cnt = 0; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { bool flag = true; for(int k = 0; k &lt; n; k++) { if(grid[i][k] != grid[k][j]) { flag = false; break; } } if(flag) { cnt++; } } } return cnt; }}; 优化排序+二分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: int equalPairs(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); int cnt = 0; vector&lt;vector&lt;int&gt;&gt; grid1(n, vector&lt;int&gt;(n, 0)); for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { grid1[i][j] = grid[j][i]; } } int l = 0; sort(grid1.begin(), grid1.end()); sort(grid.begin(), grid.end()); for(int i = 0; i &lt; n; i++) { int r = n-1; while(l &lt;= r) { int mid = (r - l) / 2 + l; if(grid1[mid] == grid[i]) { cnt++; for(int k = mid-1; k &gt;= 0; k--) { if(grid1[k] == grid[i]) { cnt++; } else { break; } } for(int k = mid + 1; k &lt; n; k++) { if(grid1[k] == grid[i]) { cnt++; } else { break; } } l = mid; break; } else if(grid1[mid] &gt; grid[i]) { r = mid - 1; } else { l = mid + 1; } } } return cnt; }}; 再优化排序+二分+计数 12345678910111213141516171819202122232425262728293031323334class Solution {public: int equalPairs(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); int cnt = 0; vector&lt;vector&lt;int&gt;&gt; grid1(n, vector&lt;int&gt;(n, 0)); map&lt;vector&lt;int&gt;, int&gt; vec2cnt; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { grid1[i][j] = grid[j][i]; } vec2cnt[grid1[i]]++; } int l = 0; sort(grid1.begin(), grid1.end()); sort(grid.begin(), grid.end()); for(int i = 0; i &lt; n; i++) { int r = n-1; while(l &lt;= r) { int mid = (r - l) / 2 + l; if(grid1[mid] == grid[i]) { cnt += vec2cnt[grid1[mid]]; l = mid; break; } else if(grid1[mid] &gt; grid[i]) { r = mid - 1; } else { l = mid + 1; } } } return cnt; }}; 再再优化用vector计数 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {public: int equalPairs(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); int cnt = 0; vector&lt;vector&lt;int&gt;&gt; grid1(n, vector&lt;int&gt;(n, 0)); vector&lt;int&gt; index_cnt(n, 1); for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { grid1[i][j] = grid[j][i]; } } int l = 0; sort(grid1.begin(), grid1.end()); sort(grid.begin(), grid.end()); for(int i = 1; i &lt; n; i++) { if(grid1[i] == grid1[i-1]) { index_cnt[i] = index_cnt[i-1] + 1; } } for(int i = n-1; i &gt; 0; i--) { if(grid1[i] == grid1[i-1]) { index_cnt[i-1] = index_cnt[i]; } } for(int i = 0; i &lt; n; i++) { int r = n-1; while(l &lt;= r) { int mid = (r - l) / 2 + l; if(grid1[mid] == grid[i]) { cnt += index_cnt[mid]; l = mid; break; } else if(grid1[mid] &gt; grid[i]) { r = mid - 1; } else { l = mid + 1; } } } return cnt; }}; hash123456789101112131415161718192021class Solution {public: int equalPairs(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); int cnt = 0; vector&lt;vector&lt;int&gt;&gt; grid1(n, vector&lt;int&gt;(n, 0)); map&lt;vector&lt;int&gt;, int&gt; vec2cnt; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { grid1[i][j] = grid[j][i]; } vec2cnt[grid1[i]]++; } for(int i = 0; i &lt; n; i++) { if(vec2cnt.count(grid[i]) &gt; 0) { cnt += vec2cnt[grid[i]]; } } return cnt; }}; [Medium] 2611. 老鼠和奶酪分析如果要找全局最优，即没有第一只老鼠吃k只的限制，那么只要让reward更大的老鼠吃掉第i块奶酪即可 现在希望对老鼠吃掉的数目进行限制，对两个reward差值由大到小进行排序 由小鼠1吃掉前k个，这样 假如reward1 &gt; reward2 的奶酪数目等于k，则刚好是全局最优 假如reward1 &gt; reward2 的奶酪数目大于k，则老鼠2吃掉了原属于小鼠1的奶酪，但前k个差值最大，能获得最大得分 假如reward1 &gt; reward2 的奶酪数目小于k，则老鼠1吃掉了原属于小鼠2的奶酪，但后n-k个差值最大，能获得最大得分 代码12345678910111213141516171819class Solution {public: int miceAndCheese(vector&lt;int&gt;&amp; reward1, vector&lt;int&gt;&amp; reward2, int k) { int n = reward1.size(), rwd = 0; vector&lt;int&gt; index(n); iota(index.begin(), index.end(), 0); sort(index.begin(), index.end(), [&amp;](int a, int b){ return reward1[a] - reward2[a] &gt; reward1[b] - reward2[b]; }); int i = 0; for(;i &lt; k; i++) { rwd += reward1[index[i]]; } for(;i &lt; n; i++) { rwd += reward2[index[i]]; } return rwd; }}; 就是找前k大快排123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: int miceAndCheese(vector&lt;int&gt;&amp; reward1, vector&lt;int&gt;&amp; reward2, int k) { if(k == 0) return accumulate(reward2.begin(), reward2.end(), 0); int n = reward1.size(); int l = 0, r = n - 1, pivx; while((pivx = partition(reward1, reward2, l, r)) != k-1) { if(pivx &gt; k-1) { r = pivx - 1; } else { l = pivx + 1; } } int rwd = 0; for(l = 0;l &lt; k; l++) { rwd += reward1[l]; } for(;l &lt; n; l++) { rwd += reward2[l]; } return rwd; } int partition(vector&lt;int&gt;&amp; reward1, vector&lt;int&gt;&amp; reward2, int l, int r) { int pivx1 = reward1[l]; int pivx2 = reward2[l]; while(l &lt; r) { while(l &lt; r &amp;&amp; reward1[r] - reward2[r] &lt;= pivx1 - pivx2) { r--; } reward1[l] = reward1[r]; reward2[l] = reward2[r]; while(l &lt; r &amp;&amp; reward1[l] - reward2[l] &gt;= pivx1 - pivx2) { l++; } reward1[r] = reward1[l]; reward2[r] = reward2[l]; } reward1[l] = pivx1; reward2[l] = pivx2; return l; }}; 超时，因为已经有序的情况会导致其下降为O(n^2) 优先队列12345678910111213141516171819202122class Solution {public: int miceAndCheese(vector&lt;int&gt;&amp; reward1, vector&lt;int&gt;&amp; reward2, int k) { int rwd = 0; int n = reward1.size(), q_size = 0; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; for (int i = 0; i &lt; n; i++) { rwd += reward2[i]; q.emplace(reward1[i] - reward2[i]); if (q_size == k) { q.pop(); } else { q_size++; } } while (k--) { rwd += q.top(); q.pop(); } return rwd; }};","link":"/home/2023/05/30/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9326/"},{"title":"LeetCode-29","text":"2661. 找出叠涂元素123456789101112131415161718192021class Solution {public: int firstCompleteIndex(vector&lt;int&gt;&amp; arr, vector&lt;vector&lt;int&gt;&gt;&amp; mat) { int m = mat.size(), n = mat[0].size(); vector&lt;int&gt; cnt_row(m, 0), cnt_col(n, 0); vector&lt;int&gt; index(m*n+1); for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; n; j++) { index[mat[i][j]] = i*n+j; } } int len = arr.size(); for(int i = 0; i &lt; len; i++) { int x = index[arr[i]]/n, y = index[arr[i]]%n; cnt_row[x]++; cnt_col[y]++; if(cnt_row[x] == n || cnt_col[y] == m) return i; } return -1; }}; 1657. 确定两个字符串是否接近123456789101112131415161718192021222324class Solution {public: inline bool logicXor(bool a, bool b) { return (a &amp;&amp; !b) || (b &amp;&amp; !a); } bool closeStrings(string word1, string word2) { vector&lt;int&gt; word1_cnt(26, 0), word2_cnt(26, 0); for(char c : word1) { word1_cnt[c - 'a']++; } for(char c : word2) { word2_cnt[c - 'a']++; } for(int i = 0; i &lt; 26; i++) { if(logicXor(word1_cnt[i] == 0, word2_cnt[i] == 0)) return false; } sort(word1_cnt.begin(), word1_cnt.end()); sort(word2_cnt.begin(), word2_cnt.end()); for(int i = 0; i &lt; 26; i++) { if(word1_cnt[i] != word2_cnt[i]) return false; } return true; }}; 2336. 无限集中的最小数字123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class SmallestInfiniteSet { vector&lt;pair&lt;unsigned, unsigned&gt;&gt; s;public: SmallestInfiniteSet() { s.emplace_back(1, -1); } int popSmallest() { int smallest = s[0].first++; if(s[0].first == s[0].second) { s.erase(s.begin()); } return smallest; } void addBack(int num) { // cout &lt;&lt; &quot;add\\n&quot;; int n = s.size(); int i = 0; while(i &lt; n &amp;&amp; s[i].second &lt;= num) i++; if(i &gt;= n) { s.emplace_back(num, num + 1); return; } if(s[i].first &lt;= num) { return; } else { if(s[i].first-1 == num) { s[i].first--; // 检查前面的，拼接 if(i-1 &gt;= 0 &amp;&amp; s[i-1].second == s[i].first) { s[i-1].second = s[i].second; s.erase(s.begin() + i); } } else { if(i - 1 &gt;= 0 &amp;&amp; s[i-1].second == num) { s[i-1].second++; } else { s.insert(s.begin() + i, make_pair(num, num+1)); } } } }};/** * Your SmallestInfiniteSet object will be instantiated and called as such: * SmallestInfiniteSet* obj = new SmallestInfiniteSet(); * int param_1 = obj-&gt;popSmallest(); * obj-&gt;addBack(num); */ 1670. 设计前中后队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112class FrontMiddleBackQueue { deque&lt;int&gt; leftHalf, rightHalf; int leftHalfLen = 0, rightHalfLen = 0;public: FrontMiddleBackQueue() { } void pushFront(int val) { leftHalf.push_front(val); if(leftHalfLen - rightHalfLen &gt; 0) { rightHalf.push_front(leftHalf.back()); leftHalf.pop_back(); rightHalfLen++; } else { leftHalfLen++; } } void pushMiddle(int val) { if(leftHalfLen &gt; rightHalfLen) { rightHalf.push_front(leftHalf.back()); leftHalf.pop_back(); leftHalf.push_back(val); rightHalfLen++; } else { leftHalf.push_back(val); leftHalfLen++; } } void pushBack(int val) { rightHalf.push_back(val); if(rightHalfLen &gt;= leftHalfLen) { leftHalf.push_back(rightHalf.front()); rightHalf.pop_front(); leftHalfLen++; } else { rightHalfLen++; } } int popFront() { int ret = -1; if(leftHalfLen &lt;= 0) { if(rightHalfLen &gt; 0) { ret = rightHalf.front(); rightHalf.pop_front(); rightHalfLen--; } } else { ret = leftHalf.front(); leftHalf.pop_front(); if(leftHalfLen &lt;= rightHalfLen) { leftHalf.push_back(rightHalf.front()); rightHalf.pop_front(); rightHalfLen--; } else { leftHalfLen--; } } return ret; } int popMiddle() { int ret = -1; if(leftHalfLen &gt;= rightHalfLen) { if(leftHalfLen == 0) return -1; ret = leftHalf.back(); leftHalf.pop_back(); leftHalfLen--; } else { ret = rightHalf.front(); rightHalf.pop_front(); rightHalfLen--; } return ret; } int popBack() { int ret = -1; if(rightHalfLen &lt;= 0) { if(leftHalfLen &gt; 0) { ret = leftHalf.back(); leftHalf.pop_back(); leftHalfLen--; } } else { ret = rightHalf.back(); rightHalf.pop_back(); if(leftHalfLen &gt; rightHalfLen) { rightHalf.push_front(leftHalf.back()); leftHalf.pop_back(); leftHalfLen--; } else { rightHalfLen--; } } return ret; }};/** * Your FrontMiddleBackQueue object will be instantiated and called as such: * FrontMiddleBackQueue* obj = new FrontMiddleBackQueue(); * obj-&gt;pushFront(val); * obj-&gt;pushMiddle(val); * obj-&gt;pushBack(val); * int param_4 = obj-&gt;popFront(); * int param_5 = obj-&gt;popMiddle(); * int param_6 = obj-&gt;popBack(); */ 1094. 拼车123456789101112131415161718192021class Solution {public: bool carPooling(vector&lt;vector&lt;int&gt;&gt;&amp; trips, int capacity) { vector&lt;int&gt; max_capacity(1002, 0); int max_end = 0; int min_start = 1002; int len = trips.size(); for(int i = 0; i &lt; len; i++) { max_capacity[trips[i][1]] += trips[i][0]; max_capacity[trips[i][2]] -= trips[i][0]; max_end = max(trips[i][2], max_end); min_start = min(trips[i][1], min_start); } int cur_capacity = 0; for(int i = min_start; i &lt;= max_end; i++) { cur_capacity += max_capacity[i]; if(cur_capacity &gt; capacity) return false; } return true; }}; 1423. 可获得的最大点数123456789101112131415161718class Solution {public: int maxScore(vector&lt;int&gt;&amp; cardPoints, int k) { int maxSum = 0; int sum = 0; int len = cardPoints.size(); for(int i = 0; i &lt; k; i++) { sum += cardPoints[i]; } maxSum = sum; for(int i = 0; i &lt; k; i++) { sum -= cardPoints[k - 1 - i]; sum += cardPoints[len - 1 - i]; maxSum = max(maxSum, sum); } return maxSum; }}; 1234567891011121314class Solution {public: int maxScore(vector&lt;int&gt; &amp;cardPoints, int k) { int n = cardPoints.size(); int m = n - k; int s = accumulate(cardPoints.begin(), cardPoints.begin() + m, 0); int min_s = s; for (int i = m; i &lt; n; i++) { s += cardPoints[i] - cardPoints[i - m]; min_s = min(min_s, s); } return accumulate(cardPoints.begin(), cardPoints.end(), 0) - min_s; }}; 1038. 从二叉搜索树到更大和树1234567891011121314151617181920212223242526class Solution { vector&lt;int&gt; arr;public: TreeNode* bstToGst(TreeNode* root) { _bstToGst(root); int len = arr.size(); for(int i = len - 2; i &gt;= 0; i--) { arr[i] += arr[i+1]; } int index = 0; setGst(root, index); return root; } void _bstToGst(TreeNode* root) { if(!root) return; _bstToGst(root-&gt;left); arr.push_back(root-&gt;val); _bstToGst(root-&gt;right); } void setGst(TreeNode* root, int&amp; index) { if(!root) return; setGst(root-&gt;left, index); root-&gt;val = arr[index++]; setGst(root-&gt;right, index); }}; 123456789101112class Solution { int sum = 0;public: TreeNode* bstToGst(TreeNode* root) { if(!root) return root; bstToGst(root-&gt;right); sum += root-&gt;val; root-&gt;val = sum; bstToGst(root-&gt;left); return root; }}; 828. 统计子串中的唯一字符12345678910111213141516171819class Solution {public: int uniqueLetterString(string s) { vector&lt;vector&lt;int&gt;&gt; vec(26, vector&lt;int&gt;(1, -1)); int len = s.length(), ret = 0; for(int i = 0; i &lt; len; i++) { vec[s[i] - 'A'].push_back(i); } for(int i = 0; i &lt; 26; i++) { vector&lt;int&gt; &amp;arr = vec[i]; arr.push_back(len); int arr_len = arr.size(); for(int j = 1; j &lt; arr_len - 1; j++) { ret += (arr[j] - arr[j-1]) * (arr[j + 1] - arr[j]); } } return ret; }}; 1457. 二叉树中的伪回文路径123456789101112131415161718192021222324class Solution { vector&lt;int&gt; m; int odd_cnt = 0;public: Solution():m(10) {} int pseudoPalindromicPaths (TreeNode* root) { if(!root) { return 0; } int ret = 0; m[root-&gt;val]++; if(m[root-&gt;val] % 2 == 1) odd_cnt++; else odd_cnt--; if(!root-&gt;left &amp;&amp; !root-&gt;right) { if(odd_cnt &lt;= 1)ret = 1; } if(root-&gt;left) ret += pseudoPalindromicPaths(root-&gt;left); if(root-&gt;right) ret += pseudoPalindromicPaths(root-&gt;right); m[root-&gt;val]--; if(m[root-&gt;val] % 2 == 1) odd_cnt++; else odd_cnt--; return ret; }}; 2824. 统计和小于目标的下标对数目123456789101112131415class Solution {public: int countPairs(vector&lt;int&gt;&amp; nums, int target) { sort(nums.begin(), nums.end()); int n = nums.size(); int ret = 0, pos = n - 1; int i = 0; while(i &lt; pos) { while(pos &gt; i &amp;&amp; nums[pos] + nums[i] &gt;= target) pos--; ret += pos - i; i++; } return ret; }}; 1234567891011121314class Solution {public: int countPairs(vector&lt;int&gt;&amp; nums, int target) { sort(nums.begin(), nums.end()); int n = nums.size(); int ret = 0; for(int i = 0; i &lt; n - 1; i++) { if(nums[i+1] &gt;= target - nums[i]) break; int pos = upper_bound(nums.begin() + i + 1, nums.end(), target - nums[i] - 1) - nums.begin(); ret += pos - i - 1; } return ret; }}; 1410. HTML 实体解析器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: bool strneq(const string&amp; str, int index, int strlen, const char *cmp, int len) { if(strlen - index &lt; len) return false; for(int i = 0; i &lt; len; i++) { if(str[index + i] != cmp[i]) return false; } return true; } string entityParser(string text) { string res; int len = text.length(), i = 0; while(i &lt; len) { if(text[i] != '&amp;') res.push_back(text[i]); else { if(strneq(text, i, len, &quot;&amp;quot;&quot;, 6)) { i += 6; res.push_back('&quot;'); continue; } else if(strneq(text, i, len, &quot;&amp;apos;&quot;, 6)) { i += 6; res.push_back('\\''); continue; } else if(strneq(text, i, len, &quot;&amp;amp;&quot;, 5)) { i += 5; res.push_back('&amp;'); continue; } else if(strneq(text, i, len, &quot;&amp;gt;&quot;, 4)) { i += 4; res.push_back('&gt;'); continue; } else if(strneq(text, i, len, &quot;&amp;lt;&quot;, 4)) { i += 4; res.push_back('&lt;'); continue; } else if(strneq(text, i, len, &quot;&amp;frasl;&quot;, 7)) { i += 7; res.push_back('/'); continue; } else { res.push_back(text[i]); } } i++; } return res; }}; 2304. 网格中的最小路径代价12345678910111213141516171819202122class Solution {public: int minPathCost(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;int&gt;&gt;&amp; moveCost) { int m = grid.size(), n = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; g(m, vector&lt;int&gt;(n, INT_MAX / 2)); for(int j = 0; j &lt; n; j++) { g[0][j] = 0; } for(int i = 0; i &lt; m - 1; i++) { for(int j = 0; j &lt; n; j++) { for(int k = 0; k &lt; n; k++) { g[i+1][k] = min(g[i+1][k], g[i][j] + grid[i][j] + moveCost[grid[i][j]][k]); } } } int minCost = INT_MAX; for(int k = 0; k &lt; n; k++) { minCost = min(minCost, g[m-1][k] + grid[m-1][k]); } return minCost; }}; 2216. 美化数组的最少删除数1234567891011121314151617181920class Solution {public: int minDeletion(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int i = 0; bool odd = false; int deleteCnt = 0; while(i &lt; len) { int j = i + 1; while(!odd &amp;&amp; j &lt; len &amp;&amp; nums[j] == nums[i]) j++; deleteCnt += j - i - 1; i = j; odd = !odd; } if((len - deleteCnt) % 2 == 1) { deleteCnt++; } return deleteCnt; }}; 53. 最大子数组和写过，记住答案了，还是不太懂 123456789101112class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int subSum = 0, maxSubSum = INT_MIN; for(int n : nums) { if(subSum &lt;= 0) subSum = n; else subSum += n; maxSubSum = max(maxSubSum, subSum); } return maxSubSum; }}; 思考可以把前缀和的折线图画出来，发现，如果遇到负数，曲线会从最高值降低，如果在变成0之前遇到正数，则此时在原来的基础上加上该正数，就可以得到目前为止，局部的最大值如果在变成0之后遇到正数，则此时不在原来的基础上加上该正数，这样正数就不会被前面的负数和儿抵消，从而获得当前的局部最大值 2477. 到达首都的最少油耗 只要总路程最小就好了，需要对车辆座位的最大化利用 如果一条线路的长度不足以坐满一辆车，可以把多个线路的乘客先聚集在最近的公共祖先上，然后统一发车 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution {public: long long minimumFuelCost(vector&lt;vector&lt;int&gt;&gt;&amp; roads, int seats) { int n = roads.size() + 1; vector&lt;vector&lt;int&gt;&gt; g(n); vector&lt;int&gt; parent(n, 0); vector&lt;int&gt; len(n, 0); vector&lt;int&gt; deg(n, 0); vector&lt;bool&gt; visited(n, false); for(vector&lt;int&gt; &amp; vec : roads) { g[vec[1]].push_back(vec[0]); g[vec[0]].push_back(vec[1]); } queue&lt;int&gt; q; q.push(0); int depth = 0; while(!q.empty()) { int node = q.front(); q.pop(); depth++; visited[node] = true; for(int child : g[node]) { if(visited[child]) continue; parent[child] = node; deg[node]++; q.push(child); } } visited = vector&lt;bool&gt;(n, false); for(int i = 1; i &lt; n; i++) { if(deg[i] == 0) { q.push(i); } } long long ret = 0; while(!q.empty()) { int city = q.front(); q.pop(); len[parent[city]] += len[city] + 1; ret += (len[city] + 1) / seats + ((len[city] + 1)%seats ? 1 : 0); deg[parent[city]]--; city = parent[city]; if(deg[city] == 0 &amp;&amp; city != 0) { q.push(city); } } return ret; }}; 2342. 数位和相等数对的最大和123456789101112131415161718192021222324252627282930313233class Solution {public: int maximumSum(vector&lt;int&gt;&amp; nums) { int n = nums.size(); unordered_map&lt;int, int&gt; bitSumMapMax; unordered_map&lt;int, int&gt; bitSumMapSecondMax; int maxSum = -1; for(int i = 0; i &lt; n; i++) { int num = nums[i]; int sum = 0; while(num) { sum += num % 10; num /= 10; } if(!bitSumMapMax.count(sum)) { bitSumMapMax[sum] = nums[i]; } else { if(nums[i] &gt;= bitSumMapMax[sum]) { bitSumMapSecondMax[sum] = bitSumMapMax[sum]; bitSumMapMax[sum] = nums[i]; maxSum = max(maxSum, bitSumMapSecondMax[sum] + bitSumMapMax[sum]); } else if(!bitSumMapSecondMax.count(nums[i])) { bitSumMapSecondMax[sum] = nums[i]; maxSum = max(maxSum, bitSumMapSecondMax[sum] + bitSumMapMax[sum]); } else if(nums[i] &gt; bitSumMapSecondMax[sum]) { bitSumMapMax[sum] = nums[i]; maxSum = max(maxSum, bitSumMapSecondMax[sum] + bitSumMapMax[sum]); } } } return maxSum; }}; 12345678910111213141516171819202122232425class Solution {public: int maximumSum(vector&lt;int&gt;&amp; nums) { int n = nums.size(); unordered_map&lt;int, int&gt; bitSumMapMax; int maxSum = -1; for(int i = 0; i &lt; n; i++) { int num = nums[i]; int sum = 0; while(num) { sum += num % 10; num /= 10; } if(!bitSumMapMax.count(sum)) { bitSumMapMax[sum] = nums[i]; } else { maxSum = max(maxSum, nums[i] + bitSumMapMax[sum]); if(nums[i] &gt;= bitSumMapMax[sum]) { bitSumMapMax[sum] = nums[i]; } } } return maxSum; }}; 1466. 重新规划路线12345678910111213141516171819202122232425262728class Solution {public: int minReorder(int n, vector&lt;vector&lt;int&gt;&gt;&amp; connections) { vector&lt;vector&lt;int&gt;&gt; g(n), parent(n); vector&lt;bool&gt; visited(n, false); int ret = 0; for(int i = 0; i &lt; n - 1; i++) { g[connections[i][0]].push_back(connections[i][1]); g[connections[i][1]].push_back(connections[i][0]); parent[connections[i][0]].push_back(connections[i][1]); } stack&lt;int&gt; q; q.push(0); while(!q.empty()) { int node = q.top(); q.pop(); visited[node] = true; for(int child : g[node]) { if(visited[child]) continue; if(find(parent[node].begin(), parent[node].end(), child) != parent[node].end()) { ret++; } q.push(child); } } return ret; }}; 123456789101112131415161718192021222324class Solution {public: int minReorder(int n, vector&lt;vector&lt;int&gt;&gt;&amp; connections) { vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; g(n); int ret = 0; for(int i = 0; i &lt; n - 1; i++) { g[connections[i][0]].push_back(make_pair(connections[i][1], 1)); g[connections[i][1]].push_back(make_pair(connections[i][0], 0)); } stack&lt;int&gt; q; q.push(0); while(!q.empty()) { int node = q.top(); q.pop(); visited[node] = true; for(auto&amp; child : g[node]) { if(visited[child.first]) continue; ret += child.second; q.push(child.first); } } return ret; }};","link":"/home/2023/12/01/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9329/"},{"title":"LeetCode-1","text":"1.两数之和AC代码思路 刚开始就是用双层for循环写，然后秉承着谦虚的态度看了题解，发现真的有O(N)的算法一遍哈希表。 主要就是利用map建立从数到数组下标的map，然后每次计算出target-nums[i]的值，然后看map里面有对应的下标，有的话就输出，没有就继续。 map的值为0时，如何区分stl的map知识有限，如何判断0是数组里面没有这个数还是查询的引索为0呢？只要储存的时候下标+1，用的时候减一就行了，这样map值为0，一定是没有这个数。 12345678910111213141516171819class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;int&gt; ans; map&lt;int, int&gt; m; for (int i = 0; i &lt; nums.size(); i++) { int pos = target - nums[i]; if (m[pos] != 0 &amp;&amp; m[pos] != i + 1) { pos = m[pos] - 1; ans.push_back(pos &gt; i ? i : pos); ans.push_back(pos &lt; i ? i : pos); break; } m[nums[i]] = i + 1; } return ans; }}; 2. 两数相加没想到第二题就是链表了，LeetCode给出的这种带构造函数的结构体挺好的，用起来方便了很多，开始创建一个head，后面直接返回head-&gt;next就好。 next自动赋值为NULL（我觉得可以搞成next默认参数为NULL，自由度更大一点） 必须传递参数，限制使用，更安全 AC代码12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode* temp, *ans; int carry = 0, n; ans = temp = new ListNode(0); while (l1 != NULL || l2 != NULL) { //用逻辑或链接，把两个链表都遍历完 n = (l1 == NULL ? 0 : l1-&gt;val) + (l2 == NULL ? 0 : l2-&gt;val) + carry; //注意某个链表此时可能遍历完的可能 temp-&gt;next = new ListNode(n%10); carry = n / 10; //计算 if (l1 != NULL)l1 = l1-&gt;next; if (l2 != NULL)l2 = l2-&gt;next; //注意到链表为空或已经遍历完 temp = temp-&gt;next; //集体指向next } if (carry) temp-&gt;next = new ListNode(carry); //如果还有剩余的进位，再new一个 return ans-&gt;next; //返回头结点的next（头结点没意义） }}; 7. 整数反转第一次AC的，28ms思路 先干掉负号，sprintf变字符串，调用std的reverse函数，反转，再变回数字，然后把符号还原 由于要考察对溢出的处理，就偷梁换柱用了long long，超过int范围的就返回0 1234567891011121314class Solution {public: int reverse(int y) { long long x = y; bool negative = (x &lt; 0); if (negative) x *= -1; char n[1024]; sprintf(n, &quot;%lld&quot;, x); std::reverse(n, n + strlen(n)); sscanf (n, &quot;%lld&quot;, &amp;x); if (negative) x *= -1; return x &gt;= 2147483647 || x &lt;= -2147483648 ? 0 : x; }}; 看了的高分同学的代码第二次AC的20ms手动大哭，凭什么一样的算法，人家就是最高分，我就是中位数？？这位同学代码块的原因主要是解除了与stdio的同步，cin.tie(nullptr)对cin，cout进行加速了，把取消同步的代码删除后，反而比我第一次AC的代码慢了。也不知道是什么原因。 1234567891011121314static int x = [](){ios::sync_with_stdio(false); cin.tie(nullptr); return 0; }();class Solution {public: int reverse(int y) { long long x = y; long long ans = 0; while (x) { ans *= 10; ans += x % 10; x /= 10; } return ans &gt;= 2147483647 || ans &lt;= -2147483648 ? 0 : ans; }}; 9. 回文数第一次AC代码思路转字符串，直接循环比 1234567891011121314class Solution {public: bool isPalindrome(int x) { char n[16] = {0}; sprintf(n, &quot;%d&quot;, x); int len = strlen(n); for (int i = 0; i &lt; len/2; i++) { if (n[i] != n[len - 1 - i]) { return false; } } return true; }}; 看了高分同学代码后的第二次AC的代码思路把数字当十进制转十进制，算一次的结果刚好和原来的数反转过来，如果大于0，比较两个数是否相等，否则反转一定不合条件，返回false 12345678910class Solution {public: bool isPalindrome(int x) { long long y = 0; for (int z = x; z; z /= 10) { y = y*10 + z % 10; } return x &gt;= 0 ? y == x : false; }}; 13. 罗马数字转整数刚开始毫无思路，后来看了评论里大佬的思路才写出来。 第一次AC代码思路 把几个符号的ASCII值当下标，储存符号的对应的值 遍历字符串，对于每一个字符，如果后一个字符的值大于自身，从总数中减去自己的值，如果后面的值小于等于自身（III，MMII），则在总数中加上自己 123456789101112131415161718192021222324252627static const auto io_sync_off=[](){ std::ios::sync_with_stdio(false); std::cin.tie(NULL); return 0;}();class Solution {public: int romanToInt(string s) { int m[100] = {0}; m['M'] = 1000; m['D'] = 500; m['C'] = 100; m['L'] = 50; m['X'] = 10; m['V'] = 5; m['I'] = 1; int ans = 0; for (int i = 0; i &lt; s.length() - 1; i++) { //防止越界，不管最后一个字符，循环结束后单独考虑 if (m[s[i]] &gt;= m[s[i+1]]) ans += m[s[i]]; else ans -= m[s[i]]; } ans += m[s[s.length() - 1]]; //最后一个字符没有后面一个，不论如何，都加上它的值 return ans; }}; 14. 最长公共前缀第一次AC代码思路 找到最短的字符串 从1开始截取字符串，跟其他字符串的前缀比较，直到出现前缀不同 1234567891011121314151617181920212223242526272829303132static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { string ans; for (int i = 0; i &lt; minlen(strs); i++) { bool find = false; char cmp = strs[0][i]; for (int j = 0; j &lt; strs.size(); j++) { if (cmp != strs[j][i]) { find = true; break; } } if (!find) ans.append(1, cmp); else break; } return ans; } int minlen(vector&lt;string&gt;&amp; strs) { if (strs.size() == 0) return 0; int min = strs[0].length(); for (int i = 1; i &lt; strs.size(); i++) { if (strs[i].length() &lt; min) min = strs[i].length(); } return min; }}; 看了题解后利用二分查找法的AC代码（Edition 1）思路 找到最短的字符串的下标 把最短的字符串一分为二，自己变成前半段，后半段存在另一个string里面 比较一次，如果前缀都相同，把右半边一分为二，拼接到左半半，右半半变成自己的右半半。 一次比较完成后 如果前缀都相同，且后半半只剩一个字符了，把这个字符拼过去再查一次，有问题就恢复，没问题保留，返回此时的左半半；如果前缀 如果前缀不同，左半半只剩下一个字符了，在比较一次，看看这个字符是不是公共前缀，是就返回，否则返回空串（没有公共前缀） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { if (strs.size() == 1) return strs[0]; if (!strs.size()) return &quot;&quot;; int min = IndexOfMinLen(strs); if (!strs[min].length()) return &quot;&quot;; string sub = strs[min].substr(0, strs[min].length() / 2); string right = strs[min].substr(strs[min].length() / 2, strs[min].length() - strs[min].length() / 2); while (1){ bool find = false; for (int i = 0; i &lt; strs.size(); i++) { if (strs[i].substr(0, sub.length()) != sub) { find = true; } } if (find) { if (sub.length() == 1) { for (int i = 0; i &lt; strs.size(); i++) { if (strs[i].substr(0, sub.length()) != sub) { find = true; } } if (find) { sub = &quot;&quot;; } break; } right = sub.substr(sub.length() / 2, sub.length() - sub.length()/2); sub = sub.substr(0, sub.length()/2); } else { if (right.length() == 1) { for (int i = 0; i &lt; strs.size(); i++) { if (strs[i].substr(0, sub.length()+1) != sub + right) { find = true; } } if (!find) { sub += right; } break; } sub.append(right.substr(0, right.length()/2)); right = right.substr(right.length() / 2, right.length() - right.length()/2); } } return sub; } int IndexOfMinLen(vector&lt;string&gt;&amp; strs) { int min = strs[0].length(); int pos = 0; for (int i = 1; i &lt; strs.size(); i++) { if (strs[i].length() &lt; min) { min = strs[i].length(); pos = i; } } return pos; }}; 根据题解写的简化版二分查找（Edition 2）思路 每次截取一半，遍历比较 如果前缀相同，把边界右移一半 如果前缀不同，把边界前移一半 123456789101112131415161718192021222324252627282930313233343536373839404142434445static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { if (strs.size() == 1) return strs[0]; if (!strs.size()) return &quot;&quot;; int min = IndexOfMinLen(strs); if (!strs[min].length()) return &quot;&quot;; int len = strs[min].length(); int left = 1, right = strs[min].length(); string sub; while (left &lt;= right){ int mid = (left + right) / 2; sub = strs[min].substr(0, mid); bool find = false; for (int i = 0; i &lt; strs.size(); i++) { if (strs[i].substr(0, sub.length()) != sub) { find = true; } } if (find) { right = mid - 1; } else { left = mid + 1; } } sub = strs[min].substr(0, (left + right) / 2); return sub; } int IndexOfMinLen(vector&lt;string&gt;&amp; strs) { int min = strs[0].length(); int pos = 0; for (int i = 1; i &lt; strs.size(); i++) { if (strs[i].length() &lt; min) { min = strs[i].length(); pos = i; } } return pos; }};","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%931/"},{"title":"LeetCode-23","text":"1144. 递减元素使数组呈锯齿状1234567891011121314151617181920212223242526272829303132class Solution {public: int movesToMakeZigzag(vector&lt;int&gt;&amp; nums) { int odd2less, even2less; odd2less = even2less = 0; int n = nums.size(); if(n &lt;= 1) return 0; for(int i = 1; i &lt; n - 1; i++) { if(i%2 == 0) { if(nums[i] &gt;= min(nums[i-1], nums[i+1])) { even2less += nums[i] - min(nums[i-1], nums[i+1]) + 1; } } else { if(nums[i] &gt;= min(nums[i-1], nums[i+1])) { odd2less += nums[i] - min(nums[i-1], nums[i+1]) + 1; } } } if(nums[0] &gt;= nums[1]) { even2less += nums[0] - nums[1] + 1; } if(nums[n-1] &gt;= nums[n-2]) { if((n-1)%2 == 0) { even2less += nums[n-1] - nums[n-2] + 1; } else { odd2less += nums[n-1] - nums[n-2] + 1; } } return min(even2less, odd2less); }}; 遍历所有奇数，使其小于两端，记录操作数1遍历所有偶数，使其小于两端，记录操作数2返回最小值 优化代码行数123456789101112131415161718class Solution {public: int movesToMakeZigzag(vector&lt;int&gt;&amp; nums) { int op[2] = {0}, n = nums.size(); if(n &lt;= 1) return 0; for(int i = 1; i &lt; n - 1; i++) { if(nums[i] &gt;= min(nums[i-1], nums[i+1])) op[i&amp;1] += nums[i] - min(nums[i-1], nums[i+1]) + 1; } if(nums[0] &gt;= nums[1]) { op[0] += nums[0] - nums[1] + 1; } if(nums[n-1] &gt;= nums[n-2]) { op[(n-1)&amp;1] += nums[n-1] - nums[n-2] + 1; } return min(op[0], op[1]); }}; 2325. 解密消息1234567891011121314151617class Solution {public: string decodeMessage(string key, string message) { vector&lt;int&gt; alphabet = vector&lt;int&gt;(26, -1); int klen = key.length(), slen = message.length(), index = 0; for(int i = 0; i &lt; klen &amp;&amp; index &lt; 26; i++) { if(isalpha(key[i]) &amp;&amp; alphabet[key[i] - 'a'] == -1) { alphabet[key[i] - 'a'] = 'a' + index++; } } for(int i = 0; i &lt; slen; i++) { if(isalpha(message[i])) message[i] = alphabet[message[i] - 'a']; } return message; }}; 2319. 判断矩阵是否是一个 X 矩阵12345678910111213141516class Solution {public: bool checkXMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if((i - j == 0 || i + j == n - 1)) { if(grid[i][j] == 0) return false; } else { if(grid[i][j] != 0) return false; } } } return true; }}; 主对角线，副对角线上的元素不能是0，其他必须是0主对角线上的点满足 $ i - j == 0 $， 副对角线上满足 $ i + j == n-1 $ 1669. 合并两个链表1234567891011121314151617181920class Solution {public: ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) { int i = 0; ListNode *dummy = new ListNode(0, list1), *x, *y, *move; for(move = dummy; i &lt;= b; move = move-&gt;next, i++) { if(i == a) { x = move; } if(i == b) { y = move-&gt;next; } } x-&gt;next = list2; move = list2; while(move-&gt;next != nullptr) move = move-&gt;next; move-&gt;next = y-&gt;next; return dummy-&gt;next; }}; 优化12345678910111213class Solution {public: ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) { int i = 0; ListNode *x, *y; for(x = list1; i &lt; a-1; x = x-&gt;next, i++); for(y = x; i &lt; b; y = y-&gt;next, i++); x-&gt;next = list2; while(list2-&gt;next != nullptr) list2 = list2-&gt;next; list2-&gt;next = y-&gt;next; return list1; }}; 题目中 a, b的范围是 $ 1 &lt;= a &lt;= b &lt; list1.length - 1 $，第一个节点不需要被删除，所以dummy节点是多余的将寻找a，b的for循环拆成两块，减少if跳转指令的执行次数move节点也是多余的 2315. 统计星号1234567891011121314class Solution {public: int countAsterisks(string s) { int len = s.length(); int count = 0; for(int i = 0; i &lt; len; i++) { for(;i &lt; len &amp;&amp; s[i] != '|'; i++) { if(s[i] == '*') count++; } for(i++; i &lt; len &amp;&amp; s[i] != '|'; i++); } return count; }}; 1664. 生成平衡数组的方案数123456789101112131415161718192021222324252627282930class Solution {public: int waysToMakeFair(vector&lt;int&gt;&amp; nums) { int n = nums.size(), ret = 0; if(n &lt;= 1) return n; int len = n; if(n % 2 == 1) { nums.push_back(0); n++; } vector&lt;int&gt; preSum(n + 2); for(int i = 0; i &lt; n; i++) { preSum[i+2] = preSum[i] + nums[i]; } for(int i = 0; i &lt; len; i++) { int odd = 0, even = 0; if(i%2 == 0) { even = preSum[n-1 + 2] - preSum[i+2-1] + preSum[i + 2 -2]; odd = preSum[n-2 + 2] - preSum[i + 2] + preSum[i+2 - 1]; } else { even = preSum[n-1+2] - preSum[i+2] + preSum[i+2 -1]; odd = preSum[n-2+2] - preSum[i+2+1-2] + preSum[i+2-2]; } if(even == odd) { ret++; } } return ret; }}; 分奇数下标和偶数下标计算前缀和当某个值被删除时，其后方奇数下标边偶数下标，偶数下标边奇数下标，前方则不变。假设删除某个数，计算变化后的奇偶下标之和，如果相等，则方案数+1为了方便代码编写，如果n是奇数，则添加一个0保证其为偶数，但注意删除添加的这个数使得平衡并不算有效方案 空间优化123456789101112131415161718192021222324252627282930class Solution {public: int waysToMakeFair(vector&lt;int&gt;&amp; nums) { int n = nums.size(), ret = 0; if(n &lt;= 1) return n; int odd1, even1, odd2, even2; odd1 = even1 = odd2 = even2 = 0; for(int i = 0; i &lt; n; i++) { if(i&amp;1) { odd2+=nums[i]; } else { even2+=nums[i]; } } for(int i = 0; i &lt; n; i++) { if(i&amp;1) { odd2-=nums[i]; } else { even2-=nums[i]; } if(odd2 + even1 == odd1 + even2) ret++; if(i&amp;1) { odd1+=nums[i]; } else { even1+=nums[i]; } } return ret; }}; odd2,even2表示位置i被删除后，被删除元素后方的奇数下标和和偶数下标和（相对于未改变前的）odd1,even1表示位置i被删除后，被删除元素前方的奇数下标和和偶数下标和假设删除i，就从odd2或even2中删除由于变化后奇数下标变偶数，偶数变奇数，则比较 $(odd2 + even1 == odd1 + even2)$是否成立比较后，将i加回odd1或even1 2309. 兼具大小写的最好英文字母12345678910111213141516171819202122class Solution {public: string greatestLetter(string s) { vector&lt;bool&gt; upper(26, false),lower(26, false); char maxx = -1; for(char c : s) { if(c &gt;= 'A' &amp;&amp; c &lt;= 'Z') { upper[c - 'A'] = true; if(lower[c-'A'] &amp;&amp; c-'A' &gt; maxx) { maxx = c - 'A'; } } if(c &gt;= 'a' &amp;&amp; c &lt;= 'z') { lower[c - 'a'] = true; if(upper[c-'a'] &amp;&amp; c-'a' &gt; maxx) { maxx = c-'a'; } } } return maxx &gt;= 0 ? string(1, maxx + 'A') : &quot;&quot;; }}; 2363. 合并相似的物品123456789101112131415161718class Solution {public: vector&lt;vector&lt;int&gt;&gt; mergeSimilarItems(vector&lt;vector&lt;int&gt;&gt;&amp; items1, vector&lt;vector&lt;int&gt;&gt;&amp; items2) { map&lt;int, int&gt; m; for(auto&amp; v : items1) { m[v[0]] += v[1]; } for(auto&amp; v : items2) { m[v[0]] += v[1]; } vector&lt;vector&lt;int&gt;&gt; ret; for(auto ite = m.begin(); ite != m.end(); ite++) { auto&amp; [x, y] = *ite; ret.push_back({x, y}); } return ret; }}; 1234567891011121314151617181920212223242526272829303132333435class Solution {public: vector&lt;vector&lt;int&gt;&gt; mergeSimilarItems(vector&lt;vector&lt;int&gt;&gt;&amp; items1, vector&lt;vector&lt;int&gt;&gt;&amp; items2) { sort(items1.begin(), items1.end(), [](vector&lt;int&gt;&amp; x, vector&lt;int&gt;&amp; y)-&gt;bool{return x[0] &lt; y[0];}); sort(items2.begin(), items2.end(), [](vector&lt;int&gt;&amp; x, vector&lt;int&gt;&amp; y)-&gt;bool{return x[0] &lt; y[0];}); int i = 0, j = 0, value = min(items1[0][0], items2[0][0]); int n1 = items1.size(), n2 = items2.size(); vector&lt;vector&lt;int&gt;&gt; ret{{value, 0}}; int retSize = 0; while(i &lt; n1 &amp;&amp; j &lt; n2) { while(i &lt; n1 &amp;&amp; items1[i][0] == value) { ret[retSize][1] += items1[i][1]; i++; } while(j &lt; n2 &amp;&amp; items2[j][0] == value) { ret[retSize][1] += items2[j][1]; j++; } if(i &lt; n1 &amp;&amp; j &lt; n2) { value = min(items1[i][0], items2[j][0]); ret.push_back({value, 0}); retSize++; } } while(i &lt; n1) { ret.push_back({items1[i][0], items1[i][1]}); i++; } while(j &lt; n2) { ret.push_back({items2[j][0], items2[j][1]}); j++; } return ret; }}; 2373. 矩阵中的局部最大值12345678910111213class Solution {public: vector&lt;vector&lt;int&gt;&gt; largestLocal(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); vector&lt;vector&lt;int&gt;&gt; ret = vector&lt;vector&lt;int&gt;&gt;(n-2, vector&lt;int&gt;(n-2, 0)); for(int i = 1; i &lt; n-1; i++) { for(int j = 1; j &lt; n-1; j++) { ret[i-1][j-1] = max(grid[i][j], max(max(max(grid[i-1][j], grid[i+1][j]),max(grid[i][j-1], grid[i][j+1])),max(max(grid[i+1][j+1], grid[i-1][j-1]),max(grid[i-1][j+1], grid[i+1][j-1])))); } } return ret; }}; 1828. 统计一个圆中点的数目暴力123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; countPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, vector&lt;vector&lt;int&gt;&gt;&amp; queries) { vector&lt;vector&lt;int&gt;&gt; xy = vector&lt;vector&lt;int&gt;&gt;(501, vector&lt;int&gt;(501, 0)); for(auto&amp; p: points) { xy[p[0]][p[1]]++; } int n = queries.size(); vector&lt;int&gt; ret(n, 0); for(int i = 0; i &lt;= 500; i++) { for(int j = 0; j &lt;= 500; j++) { if(xy[i][j] &gt; 0) { for(int k = 0; k &lt; n; k++) { int x = queries[k][0], y = queries[k][1], r = queries[k][2]; if((i - x)*(i - x) + (j - y)*(j - y) &lt;= r*r) { ret[k] += xy[i][j]; } } } } } return ret; }}; 注意不同点可能有相同的坐标 更暴力123456789101112131415class Solution {public: vector&lt;int&gt; countPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, vector&lt;vector&lt;int&gt;&gt;&amp; queries) { int m = points.size(), n = queries.size(); vector&lt;int&gt; ret = vector&lt;int&gt;(n, 0); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { if ((queries[i][0] - points[j][0]) * (queries[i][0] - points[j][0]) + (queries[i][1] - points[j][1]) * (queries[i][1] - points[j][1]) &lt;= queries[i][2] * queries[i][2]) { ret[i]++; } } } return ret; }}; 面试题 05.02. 二进制数转字符串乘2法1234567891011121314class Solution {public: string printBin(double num) { int count = 0; string res = &quot;0.&quot;; for(; count &lt; 30 &amp;&amp; num &gt; 0; count++) { num *= 2; int bit = num; res.push_back(bit+'0'); num -= bit; } return count &lt; 30 ? res : &quot;ERROR&quot;; }}; ieee 754123456789101112131415161718192021class Solution {public: string printBin(double num) { long long int *bit = (long long int *)&amp;num; string res = string(64, '\\0'); int i = 63; for(; ((*bit)&amp;1)==0; i--, (*bit) &gt;&gt;= 1); int last = i; for(; i &gt; 11; i--) { res[i - 12] += ((*bit)&amp;1) + '0'; (*bit) &gt;&gt;= 1; } int e = ((*bit) &amp; 0x7ff) - 1023; string pre = &quot;0.&quot;; if(e &lt; -1) { pre += string(-e-1,'0'); } pre += &quot;1&quot;; return last-12 &lt; 32-3-(-e-1) ? pre+res : &quot;ERROR&quot;; }}; 分别计算浮点数的尾数，阶码，在判断能否用32位保存下来","link":"/home/2023/02/27/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9323/"},{"title":"LeetCode-27","text":"[Medium] 29. 两数相除分析 只能用加减法，最朴素的方法是循环相减/加，直到小于0/大于0，计算加/减的次数 这样算法是o(n)，考虑到i+=i或者i&lt;&lt;=1相当于i*=2,i&gt;&gt;=1相当于i/=2 只考虑divisor, divident都大于0的情况，先找到整数p，使得 $divisor2^p &lt;= divident$，$divident-=divisor2^p, ratio+=2^p$若divident为0，则商为ratio，否则重复上面的过程，直到divident为0。 考虑divisor, divident到可能正，可能负，而负数的范围大于正数，直接将所有整数变成负数，并记录符号 注意取相反数的时候要用位运算~x+1 代码12345678910111213141516171819202122232425262728293031323334353637383940class Solution {public: int divide(int dividend, int divisor) { if(dividend &lt; divisor &amp;&amp; dividend &gt; 0) return 0; if(dividend &gt; divisor &amp;&amp; dividend &lt; 0) return 0; if((dividend == INT_MIN) &amp;&amp; (divisor == -1)) return INT_MAX; if((dividend == INT_MIN) &amp;&amp; (divisor == 1)) return INT_MIN; if(dividend == divisor) return 1; if(dividend &lt; 0 &amp;&amp; divisor &gt; 0 &amp;&amp; dividend == ~divisor+1) return -1; if(dividend &gt; 0 &amp;&amp; divisor &lt; 0 &amp;&amp; ~dividend+1 == divisor) return -1; bool sign = false; if(dividend &lt; 0) { sign = !sign; } else { dividend = ~dividend+1; } if(divisor &lt; 0) { sign = !sign; } else { divisor = ~divisor+1; } int res = 0; int i = -1; while(dividend &lt; divisor &amp;&amp; divisor &gt;= (INT_MIN &gt;&gt; 1)) { divisor += divisor; i+=i; } while(true) { while(dividend &gt; divisor) { if(i == -1) { return sign ? (res) : (~res+1); } divisor &gt;&gt;= 1; i&gt;&gt;=1; } dividend -= divisor; res+=i; } }}; 275. H 指数 II代码12345678910111213141516171819class Solution {public: int hIndex(vector&lt;int&gt;&amp; citations) { int n = citations.size(); int l = 0, r = n-1; int res = 0; while(l &lt; r) { int mid = (r - l) / 2 + l; if(n - mid &lt;= citations[mid]) { res = max(res, n-mid); r=mid-1; } else { res = max(res, citations[mid]); l = mid+1; } } return max(res, min(citations[l], n-l)); }}; 优化1234567891011121314151617class Solution {public: int hIndex(vector&lt;int&gt;&amp; citations) { int n = citations.size(); int l = 0, r = n-1; int res = 0; while(l &lt;= r) { int mid = (r - l) / 2 + l; if(n - mid &lt;= citations[mid]) { r=mid - 1; } else { l = mid+1; } } return n-l; }}; 274. H 指数代码12345678910111213141516171819class Solution {public: int hIndex(vector&lt;int&gt;&amp; citations) { int arr[1001] = {0}; int max_cite = 0; int min_cite = INT_MAX; for(int n : citations) { arr[n]++; max_cite = max(max_cite, n); min_cite = min(min_cite, n); } int sum = 0, res = 0; for(int i = max_cite; i &gt;= min_cite; i--) { sum += arr[i]; res = max(res, min(sum, i)); } return res; }}; 2558. 从数量最多的堆取走礼物12345678910111213141516171819class Solution {public: long long pickGifts(vector&lt;int&gt;&amp; gifts, int k) { priority_queue&lt;int&gt; gift_heap; for(int n : gifts) { gift_heap.push(n); } long long res = 0; while(k--) { gift_heap.push(sqrt(gift_heap.top())); gift_heap.pop(); } while(!gift_heap.empty()) { res += gift_heap.top(); gift_heap.pop(); } return res; }}; 1465. 切割后面积最大的蛋糕123456789101112131415161718class Solution {public: int maxArea(int h, int w, vector&lt;int&gt;&amp; horizontalCuts, vector&lt;int&gt;&amp; verticalCuts) { int h_len = horizontalCuts.size(); int v_len = verticalCuts.size(); sort(verticalCuts.begin(), verticalCuts.end()); sort(horizontalCuts.begin(), horizontalCuts.end()); int max_h = max(h - horizontalCuts.back(), horizontalCuts.front()); int max_v = max(w - verticalCuts.back(), verticalCuts.front()); for(int i = 1; i &lt; h_len; i++) { max_h = max(max_h, horizontalCuts[i] - horizontalCuts[i-1]); } for(int i = 1; i &lt; v_len; i++) { max_v = max(max_v, verticalCuts[i] - verticalCuts[i-1]); } return ((long long)(max_h)%1000000007 * (max_v)%1000000007) % 1000000007; }}; 2520. 统计能整除数字的位数1234567891011121314class Solution {public: int countDigits(int num) { int n = num; int ret = 0; while(n) { if(num % (n % 10) == 0) { ret++; } n /= 10; } return ret; }}; 2698. 求一个整数的惩罚数思路 首先要计算出所有满足sum(split(i*i)) == i的元素 发现很少，直接放到数组里去查表 对于一个数i，希望它拆分后和等于target 先分成a，b两份，判断是否等于，等于return true，不等于就把a分开（递归） 代码123456789101112131415161718192021222324252627282930313233343536class Solution {public: int punishmentNumber(int n) { int res = 0; // for(int i = 1; i &lt;= 1000; i++) { // int n = i*i; // if(search(i*i, i)) { // cout &lt;&lt; i &lt;&lt; &quot;, &quot;; // } // } int punish_arr[] = {1, 9, 10, 36, 45, 55, 82, 91, 99, 100, 235, 297, 369, 370, 379, 414, 657, 675, 703, 756, 792, 909, 918, 945, 964, 990, 991, 999, 1000}; int len = sizeof(punish_arr)/sizeof(int); for(int i = 0; i &lt; len; i++) { if(n &gt;= punish_arr[i]) res += punish_arr[i]*punish_arr[i]; } return res; } bool search(int i, int target) { int n = i; int base = 1; int r = 0; while(n) { r += base*(n%10); if(r+n/10 == target) { return true; } else { if(search(n/10, target - r)){ return true; } } n /= 10; base *= 10; } return false; }}; 1155. 掷骰子等于目标和的方法数思路 先暴力递归，然后发现可以总结出dp公式，然后把递归改成dp尝试，成功了 代码123456789101112131415161718192021222324252627class Solution {public: vector&lt;vector&lt;int&gt;&gt; dp; int numRollsToTarget(int n, int k, int target) { dp = vector&lt;vector&lt;int&gt;&gt;(30+1, vector&lt;int&gt;(1000+1, 0)); dp[0][0] = 1; for(int i = 1; i &lt;= n; i++) { for(int t = 1; t &lt;= target; t++) for(int K = 1;K &lt;= k; K++) if(t &gt;= K) dp[i][t] = (dp[i][t] + dp[i-1][t-K]) % 1000000007; } return dp[n][target]; } int search(int n, int k, int target) { if(target == 0 &amp;&amp; n == 0) { return 1; } else if(n == 0) return 0; int res = 0; for(int i = 1; i &lt;= k; i++) { if(target &gt;= i) { res += numRollsToTarget(n-1, k, target-i); } } return res; }}; 优化观察代码可知，dp[i][t]就是dp[i-1][t-1]+…dp[i-1][t-k]，可以用前缀和优化 1234567891011121314151617class Solution {public: vector&lt;vector&lt;int&gt;&gt; dp; int numRollsToTarget(int n, int k, int target) { dp = vector&lt;vector&lt;int&gt;&gt;(30+1, vector&lt;int&gt;(1000+1,0)); dp[0][0] = 1; for(int i = 1; i &lt;= n; i++) { for(int t = 1; t &lt;= target; t++) { dp[i][t] = (dp[i][t-1] + dp[i-1][t-1]) % 1000000007; } for(int t = target; t &gt;= k; t--) { dp[i][t] = (dp[i][t] - dp[i][t-k] + 1000000007) % 1000000007; } } return dp[n][target]; }}; 1402. 做菜顺序 一眼dp，鉴定为，纯纯的简单题 一遍就做对啦哈哈哈1234567891011121314151617181920212223class Solution {public: int maxSatisfaction(vector&lt;int&gt;&amp; satisfaction) { int n = satisfaction.size(); vector&lt;int&gt; dp(n+1, 0); vector&lt;int&gt; sums(n+1, 0); sums[0] = accumulate(satisfaction.begin(), satisfaction.end(), 0); sort(satisfaction.begin(), satisfaction.end(), less&lt;int&gt;()); for(int i = 0; i &lt; n; i++) { dp[0] += (i+1) * satisfaction[i]; } for(int i = 1; i &lt;= n; i++) { if(dp[i-1] &lt; dp[i-1] - sums[i-1]) { dp[i] = dp[i-1] - sums[i-1]; sums[i] = sums[i-1] - satisfaction[i-1]; } else { dp[i] = dp[i-1]; sums[i] = sums[i-1]; } } return dp[n]; }}; 优化dp数组和sum数组可以优化掉 1234567891011121314151617181920class Solution {public: int maxSatisfaction(vector&lt;int&gt;&amp; satisfaction) { int n = satisfaction.size(); int dp = 0; int sums = 0; sort(satisfaction.begin(), satisfaction.end()); for(int i = 0; i &lt; n; i++) { dp += (i+1) * satisfaction[i]; sums += satisfaction[i]; } for(int i = 1; i &lt;= n; i++) { if(dp &lt; dp - sums) { dp = dp - sums; sums = sums - satisfaction[i-1]; } } return dp; }}; 2678. 老人的数目12345678910class Solution {public: int countSeniors(vector&lt;string&gt;&amp; details) { int res = 0; for(const string &amp;laodeng : details) { if((laodeng[11] == '6' &amp;&amp; laodeng[12] &gt; '0') || (laodeng[11] &gt; '6' &amp;&amp; laodeng[12] &gt;= '0')) res++; } return res; }}; 2316. 统计无向图中无法互相到达点对数123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;vector&lt;int&gt;&gt; g; vector&lt;bool&gt; visited; long long countPairs(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) { g = move(vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;())); visited = move(vector&lt;bool&gt;(n, false)); for(const vector&lt;int&gt;&amp; edge : edges) { g[edge[0]].push_back(edge[1]); g[edge[1]].push_back(edge[0]); } long long res = 0; for(int i = 0; i &lt; n; i++) { if(!visited[i]) { long long node_num = count_nodes(i); res += (n - node_num) * node_num; } } return res &gt;&gt; 1; } int count_nodes(int root) { visited[root] = true; int res = 1; for(int child : g[root]) { if(!visited[child]) res += count_nodes(child); } return res; }}; 并查集 这里一直写不出来，发现并查集无法把所有相连的点归到一个集合中，因为在遍历的时候没有用union操作123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; s; int find(int x) { return x == s[x] ? x : (s[x] = find(s[x])); } long long countPairs(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) { s = move(vector&lt;int&gt;(n, 0)); vector&lt;int&gt; cnt = move(vector&lt;int&gt;(n, 0)); iota(s.begin(), s.end(), 0); size_t elen = edges.size(); for(int j = 0; j &lt; elen; j++) { s[find(edges[j][1])] = find(edges[j][0]); } for(int i = 0; i &lt; n; i++) { cnt[find(i)]++; } long long res = 0; for(int i = 0; i &lt; n; i++) { res += (n - (long long)cnt[i])*cnt[i]; } return res &gt;&gt; 1; }}; 继续优化 换个公式减少一次循环123456789101112131415161718192021class Solution {public: vector&lt;int&gt; s; int find(int x) { return x == s[x] ? x : (s[x] = find(s[x])); } long long countPairs(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) { s = move(vector&lt;int&gt;(n, 0)); vector&lt;int&gt; cnt = move(vector&lt;int&gt;(n, 0)); iota(s.begin(), s.end(), 0); size_t elen = edges.size(); for(int j = 0; j &lt; elen; j++) { s[find(edges[j][1])] = find(edges[j][0]); } long long res = 0; for(int i = 0; i &lt; n; i++) { res += cnt[find(i)]++; } return (long long)n*(n-1)/2 - res; }}; 2525. 根据规则将箱子分类1234567891011class Solution {public: string categorizeBox(int length, int width, int height, int mass) { bool bulky = length &gt;= 10000 || height &gt;= 10000 || width &gt;= 10000 || (long long)length*width*height &gt;= 1000000000; bool heavy = mass &gt;= 100; if(bulky &amp;&amp; heavy) return &quot;Both&quot;; else if(!bulky &amp;&amp; !heavy) return &quot;Neither&quot;; else if(bulky &amp;&amp; !heavy) return &quot;Bulky&quot;; else return &quot;Heavy&quot;; }}; 117. 填充每个节点的下一个右侧节点指针 II思路 首先想到的就是层次遍历，非常简单 对于进阶使用O(1)空间的算法，一直没想到利用已有的next指针 树每层最左侧节点找parent，把同层都连起来就好123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution {public: Node* levelConnect(Node* root) { queue&lt;Node *&gt; q; if(root) q.push(root); while(!q.empty()) { Node *node = nullptr; int n = q.size(); while(n--) { if(node) node-&gt;next = q.front(); node = q.front(); if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); q.pop(); } } return root; } Node* connect(Node* root) { // return levelConnect(root); if(root) recursiveConnect(root, new Node(0, root, nullptr, nullptr), true); return root; } void recursiveConnect(Node* root, Node *parent, bool isLeft) { Node *move = root; while(move &amp;&amp; !move-&gt;next) { Node *to = nullptr; if(isLeft &amp;&amp; parent-&gt;right) { to = parent-&gt;right; isLeft = false; } else { Node *pMove = parent-&gt;next; while(pMove &amp;&amp; !pMove-&gt;left &amp;&amp; !pMove-&gt;right) pMove = pMove-&gt;next; if(pMove) { if(pMove-&gt;left) { isLeft = true; to = pMove-&gt;left; } else if(pMove-&gt;right) { isLeft = false; to = pMove-&gt;right; } parent = pMove; } } move-&gt;next = to; move = to; } if(root-&gt;right) recursiveConnect(root-&gt;right, root, false); if(root-&gt;left) recursiveConnect(root-&gt;left, root, true); }}; 整理下代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {public: Node* levelConnect(Node* root) { queue&lt;Node *&gt; q; if(root) q.push(root); while(!q.empty()) { Node *node = nullptr; int n = q.size(); while(n--) { if(node) node-&gt;next = q.front(); node = q.front(); if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); q.pop(); } } return root; } Node* connect(Node* root) { // return levelConnect(root); if(root) recursiveConnect(root, new Node(0, root, nullptr, nullptr)); return root; } void recursiveConnect(Node* root, Node *parent) { Node *move = root; while(move &amp;&amp; !move-&gt;next) { Node *to = nullptr; if(move != parent-&gt;left || !parent-&gt;right) { parent = parent-&gt;next; } Node *pMove = parent; while(pMove &amp;&amp; !pMove-&gt;left &amp;&amp; !pMove-&gt;right) pMove = pMove-&gt;next; to = pMove ? (pMove-&gt;left == move ? pMove-&gt;right : pMove-&gt;left ? pMove-&gt;left : pMove-&gt;right) : nullptr; // 你就猜吧，一猜一个不吱声 parent = pMove; move-&gt;next = to; move = to; } if(root-&gt;right) recursiveConnect(root-&gt;right, root); if(root-&gt;left) recursiveConnect(root-&gt;left, root); }}; 2127. 参加会议的最多员工数并查集 一个重要结论，图中一定有环（n个节点，大于n-1条边） 如果环的大小大于2，则只能将环上的节点上桌，支链上的点无法上桌 如果环的大小不大于2，则环上节点的最长支链也可以跟着上桌 多个环长为2的子图（不论是否有支链），都可以全部上桌 故，统计所有环长大于2的最大环长，为maxRing统计所有环长不大于2的环长之和，以及环上各节点的最大之链长度之和，为maxNumber返回max(maxRing, maxNumber) 步骤 并查集将节点分类 degree统计每个节点的入度 dSetSize统计每个集合的大小 按照是否存在入度为0的点，将子图划分两类 存在，则图含有支链，计算环的长度(findMaxRing) 大于2，统计最大环长（maxRing） 不大于2，从任意度为0的节点开始遍历，将环上节点的visited变成非0，并标记该子图为is2，累加maxNumber（环长为2，都可以上桌） 不存在，则图不含有支链，计算环的长度(findMaxRing) 大于2，统计最大环长（maxRing） 不大于2，累加如maxNumber（环长为2，都可以上桌） 对所有入度为0，且所在子图是is2的节点，计算该点到环上点的距离为支链长度，记录最大支链长度 所有最大支链长度累加maxNumber 返回max(maxNumber, maxRing) 时间 1848 ms 击败 5.2%内存 98.4 MB 击败 35.8% 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697class Solution {public: int maxRing = 0; vector&lt;int&gt; visited; vector&lt;int&gt; addtional_len; vector&lt;int&gt; dSet; vector&lt;bool&gt; dSetVisited; vector&lt;int&gt; dSetSize; vector&lt;bool&gt; isRing; vector&lt;bool&gt; is2; vector&lt;int&gt; degree; int find(int i) { return i == dSet[i] ? i : (dSet[i] = find(dSet[i])); } int maximumInvitations(vector&lt;int&gt;&amp; favorite) { int n = favorite.size(); visited = move(vector&lt;int&gt;(n, 0)); dSetVisited = move(vector&lt;bool&gt;(n, false)); isRing = move(vector&lt;bool&gt;(n, true)); is2 = move(vector&lt;bool&gt;(n, false)); addtional_len = move(vector&lt;int&gt;(n, 0)); degree = move(vector&lt;int&gt;(n, 0)); dSet = move(vector&lt;int&gt;(n, 0)); iota(dSet.begin(), dSet.end(), 0); dSetSize = move(vector&lt;int&gt;(n, 0)); for(int i = 0; i &lt; n; i++) { degree[favorite[i]]++; dSet[find(i)] = find(favorite[i]); } for(int i = 0; i &lt; n; i++) { dSetSize[find(i)]++; if(degree[i] == 0) isRing[dSet[i]] = false; } int maxNumber = 0; for(int i = 0; i &lt; n; i++) { int len = 1; int ringNode = -1; if(isRing[dSet[i]]) { if(!dSetVisited[dSet[i]]) { dSetVisited[dSet[i]] = true; int ring = dSetSize[dSet[i]]++; if(ring &gt; 2) { maxRing = max(maxRing, ring); } else { maxNumber += ring; } } } else { if(!dSetVisited[dSet[i]] &amp;&amp; degree[i] == 0) { dSetVisited[dSet[i]] = true; int ring = findMaxRing(favorite, i, len, ringNode); if(ring &gt; 2) { maxRing = max(maxRing, ring); } else { // addtional_len[ringNode] = max(len - ring, addtional_len[ringNode]); int move = i; while(move != ringNode) { visited[move] = false; move = favorite[move]; } is2[dSet[i]] = true; maxNumber += ring; } } } } for(int i = 0; i &lt; n; i++) { if(is2[dSet[i]] &amp;&amp; degree[i] == 0) { int move = i; int len = 0; while(!visited[move]) { len++; move = favorite[move]; } addtional_len[move] = max(addtional_len[move], len); } } for(int i = 0; i &lt; n; i++) { // cout &lt;&lt; i &lt;&lt; &quot;, &quot; &lt;&lt; addtional_len[i] &lt;&lt; endl; if(addtional_len[i] &gt; 0) { maxNumber += addtional_len[i]; } } return max(maxNumber, maxRing); } int findMaxRing(const vector&lt;int&gt;&amp; favorite, int node, int &amp;len, int &amp;ringNode) { visited[node] = len; int child = favorite[node]; if(visited[child]) { ringNode = child; return len - visited[child] + 1; } len++; return findMaxRing(favorite, child, len, ringNode); }}; 优化 上面的代码在遇到有公共部分的支链，（会分叉的支链时），会导致重叠部分反复被访问 使用arcFav统计被喜欢图，根据被喜欢图从环上开始寻找最大支链，可以避免，速度也得到了极大的优化 时间 284ms 击败 12.78% 使用 C++ 的用户内存 166.84MB 击败 25.57% 使用 C++ 的用户 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899class Solution {public: int maxRing = 0; vector&lt;int&gt; visited; vector&lt;int&gt; addtional_len; vector&lt;vector&lt;int&gt;&gt; arcFav; vector&lt;int&gt; dSet; vector&lt;bool&gt; dSetVisited; vector&lt;int&gt; dSetSize; vector&lt;bool&gt; isRing; vector&lt;int&gt; degree; int find(int i) { return i == dSet[i] ? i : (dSet[i] = find(dSet[i])); } int maximumInvitations(vector&lt;int&gt;&amp; favorite) { int n = favorite.size(); visited = move(vector&lt;int&gt;(n, 0)); arcFav = move(vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;())); dSetVisited = move(vector&lt;bool&gt;(n, false)); isRing = move(vector&lt;bool&gt;(n, true)); addtional_len = move(vector&lt;int&gt;(n, 0)); degree = move(vector&lt;int&gt;(n, 0)); dSet = move(vector&lt;int&gt;(n, 0)); iota(dSet.begin(), dSet.end(), 0); dSetSize = move(vector&lt;int&gt;(n, 0)); for(int i = 0; i &lt; n; i++) { degree[favorite[i]]++; dSet[find(i)] = find(favorite[i]); arcFav[favorite[i]].push_back(i); } for(int i = 0; i &lt; n; i++) { dSetSize[find(i)]++; if(degree[i] == 0) isRing[dSet[i]] = false; } int maxNumber = 0; for(int i = 0; i &lt; n; i++) { int len = 1; int ringNode = -1; if(isRing[dSet[i]]) { if(!dSetVisited[dSet[i]]) { dSetVisited[dSet[i]] = true; int ring = dSetSize[dSet[i]]++; if(ring &gt; 2) { maxRing = max(maxRing, ring); } else { maxNumber += ring; } } } else { if(!dSetVisited[dSet[i]] &amp;&amp; degree[i] == 0) { dSetVisited[dSet[i]] = true; int ring = findMaxRing(favorite, i, len, ringNode); if(ring &gt; 2) { maxRing = max(maxRing, ring); } else { int move = i; while(move != ringNode) { visited[move] = 0; move = favorite[move]; } addtional_len[ringNode] = searchArcFav(ringNode); move = favorite[ringNode]; while(move != ringNode) { addtional_len[move] = searchArcFav(move); move = favorite[move]; } maxNumber += ring; } } } } for(int i = 0; i &lt; n; i++) { if(addtional_len[i] &gt; 0) { maxNumber += addtional_len[i]; } } return max(maxNumber, maxRing); } int searchArcFav(int move) { visited[move] = 1; int ret = 0; for(int child : arcFav[move]) { if(!visited[child]) { ret = max(searchArcFav(child)+1, ret); } } return ret; } int findMaxRing(const vector&lt;int&gt;&amp; favorite, int node, int &amp;len, int &amp;ringNode) { visited[node] = len; int child = favorite[node]; if(visited[child]) { ringNode = child; return len - visited[child] + 1; } len++; return findMaxRing(favorite, child, len, ringNode); }}; 并查集+拓扑排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Solution {public: int maxRing = 0; vector&lt;int&gt; visited; vector&lt;int&gt; addtional_len; vector&lt;vector&lt;int&gt;&gt; arcFav; vector&lt;int&gt; dSet; vector&lt;int&gt; degree; int find(int i) { return i == dSet[i] ? i : (dSet[i] = find(dSet[i])); } int maximumInvitations(vector&lt;int&gt;&amp; favorite) { int n = favorite.size(); visited = move(vector&lt;int&gt;(n, 0)); arcFav = move(vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;())); addtional_len = move(vector&lt;int&gt;(n, 0)); degree = move(vector&lt;int&gt;(n, 0)); dSet = move(vector&lt;int&gt;(n, 0)); iota(dSet.begin(), dSet.end(), 0); vector&lt;int&gt; ringNodes; unordered_map&lt;int, int&gt; ringSize; for(int i = 0; i &lt; n; i++) { degree[favorite[i]]++; dSet[find(i)] = find(favorite[i]); arcFav[favorite[i]].push_back(i); } queue&lt;int&gt; topologyQueue; for(int i = 0; i &lt; n; i++) { if(degree[i] == 0) { topologyQueue.push(i); } } while(!topologyQueue.empty()) { int front = topologyQueue.front(); topologyQueue.pop(); if((--degree[favorite[front]]) == 0) { topologyQueue.push(favorite[front]); } } unordered_set&lt;int&gt; ring2set; for(int i = 0; i &lt; n; i++) { if(degree[i] &gt; 0) { ringNodes.push_back(i); ringSize[find(i)]++; } } for(int i = 0; i &lt; n; i++) { if(ringSize[find(i)] &lt;= 2) { ring2set.insert(find(i)); } } int maxNumber = 0; for(int ringNode : ringNodes) { int ring = ringSize[dSet[ringNode]]; if(ring &gt; 2) { maxRing = max(maxRing, ring); } else { addtional_len[ringNode] = searchArcFav(ringNode); } } for(int i = 0; i &lt; n; i++) { if(addtional_len[i] &gt; 0) { maxNumber += addtional_len[i]; // add ring number } } return max(maxNumber + (ring2set.size() &lt;&lt; 1), (size_t)maxRing); } int searchArcFav(int move) { visited[move] = 1; // 判断， not in ring int ret = 0; for(int child : arcFav[move]) { if(!visited[child] &amp;&amp; degree[child] == 0) { ret = max(searchArcFav(child)+1, ret); } } return ret; }}; 更慢了，原因是不能在拓扑排序的同时计算最大支链长度 优化掉并查集 在拓扑排序中寻找最长支链，为每个节点定义f(x) $ f(x) = max_{i=0}^j(f(aFav(x)_i) + 1) $ 每个节点初始为0，拓扑排序时，每次i将j的degree被减小，其值为max(f(i)+1, f(j))1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution {public: int maxRing = 0; vector&lt;bool&gt; visited; vector&lt;int&gt; degree; vector&lt;int&gt; f; int maximumInvitations(vector&lt;int&gt;&amp; favorite) { int n = favorite.size(); visited = move(vector&lt;bool&gt;(n, false)); degree = move(vector&lt;int&gt;(n, 0)); f = move(vector&lt;int&gt;(n, 0)); vector&lt;int&gt; ringNodes; unordered_map&lt;int, int&gt; ringSize; for(int i = 0; i &lt; n; i++) { degree[favorite[i]]++; } queue&lt;int&gt; topologyQueue; for(int i = 0; i &lt; n; i++) { if(degree[i] == 0) { topologyQueue.push(i); } } while(!topologyQueue.empty()) { int front = topologyQueue.front(); topologyQueue.pop(); f[favorite[front]] = max(f[favorite[front]], f[front] + 1); visited[front] = true; if((--degree[favorite[front]]) == 0) { topologyQueue.push(favorite[front]); } } int maxNumber = 0; for(int i = 0; i &lt; n; i++) { if(!visited[i]) if(favorite[favorite[i]] == i) { maxNumber += f[i] + 1; } else { int ring = 1; int move = favorite[i]; while(!visited[move] &amp;&amp; move != i) { visited[move] = true; move = favorite[move]; ring++; } maxRing = max(maxRing, ring); } } return max(maxNumber, maxRing); }};","link":"/home/2023/10/28/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9327/"},{"title":"LeetCode-3","text":"58. 最后一个单词的长度AC代码1234567891011class Solution {public: int lengthOfLastWord(string s) { reverse(s.begin(), s.end()); stringstream ss(s); string buf; ss &gt;&gt; buf; reverse(buf.begin(), buf.end()); return buf.length(); }}; 1234567891011class Solution {public: int lengthOfLastWord(string s) { int count = 0; for (int i = s.length() -1 ; i &gt;= 0; i--) { if (s[i] != ' ')count++; else if (count &gt; 0) break; } return count; }}; 66. 加一思路写一个模拟加法的算法就可以。假设加0，第一次carry（进位）为1 AC代码1234567891011121314151617181920static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) { int carry = 1; int i = digits.size(); while (i &amp;&amp; carry) { int t = digits[i-1] + carry; digits[i-1] = t%10; carry = t/10; i--; } if (carry) digits.insert(digits.begin(), carry); return digits; }}; 67. 二进制求和AC代码123456789101112131415161718class Solution {public: string addBinary(string a, string b) { if (a.length() &gt; b.length()) { b.insert(0, a.length() - b.length(), '0'); } else if (a.length() &lt; b.length()){ a.insert(0, b.length() - a.length(), '0'); } int carry = 0; for (int i = a.length() - 1; i &gt;= 0; i--) { int n = a[i] + b[i] + carry - '0'*2; a[i] = n % 2 + '0'; carry = n/2; } if (carry) a.insert(0, 1, carry + '0'); return a; }}; 69. x 的平方根AC代码123456class Solution {public: int mySqrt(int x) { return sqrt(x); }}; 思路暴力求解 12345678910111213141516171819class Solution {public: int mySqrt(int x) { if (x &lt;= 0) return 0; long long cmp = 0; long long i = 0; while (cmp &lt;= x) { i++; cmp = i*i; if (i &gt; INT_MAX) { i = INT_MIN; } if (i &lt; INT_MIN) { i = INT_MAX; } } return i - 1; }}; 思路牛顿迭代法xn+1 = xn - f(xn) / f’(xn); AC代码12345678910111213141516171819class Solution {public: double fx(double x,double n) { return x*x - n; } double dfxdx(double x) { return 2*x; } int mySqrt(int n) { double x = 0.01; double exp = 0.01; double temp = 1; while (fabs(x - temp) &gt; exp) { temp = x; x = x - fx(x, n)/dfxdx(x); } return x; }}; 88. 合并两个有序数组思路遍历nums2，对于每一个元素，查找比它大的元素，插入 AC代码12345678910111213class Solution {public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { int count = 0; for (int i = 0, j = 0; i &lt; nums2.size(); i++) { while (j &lt; m &amp;&amp; nums2[i] &gt; nums1[j])j++; nums1.insert(nums1.begin() + j, nums2[i]); count++; m++; } nums1.erase(nums1.end() - count, nums1.end()); }}; 思路三个指针a，b，c，分别指向m+n-1,m-1,n-1 a开始向前遍历，比较另外两个指针的值，把较大的那个赋值给a，然后较大的指针前移 AC代码12345678910111213141516171819202122232425262728class Solution {public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { if (!m) { for (int i = 0; i &lt; n; i++) { nums1[i] = nums2[i]; } return; } if (!n) return; int i = n + m - 1, j = m - 1, k = n - 1; while (j &gt;= 0 &amp;&amp; k &gt;= 0) { nums1[i--] = nums1[j] &gt; nums2[k] ? nums1[j--] : nums2[k--]; } if (j != - 1) { while (j &gt;= 0) { nums1[i--] = nums1[j--]; } } if (k != - 1) { while (k &gt;= 0) { nums1[i--] = nums2[k--]; } } }}; 100. 相同的树真没想到从来没接触过树的我居然一遍过了 思路深度优先遍历，先递归调用，访问所有节点 遇到结束时，为null，则比较两个是不是都是null，如果不是，说明树的形状不一样 叶子节点返回后，比较上一节点的值，相同返回true，最后达到函数结尾的一律返回false（值不一样或者形状不一样） AC代码123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool isSameTree(TreeNode* p, TreeNode* q) { if (p == NULL || q == NULL) return q == p; if (isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right)) { if (p-&gt;val == q-&gt;val) { return true; } } return false; }}; 21. 合并两个有序链表思路跟88. 合并两个有序数组的思路是一样样的，不过由于用指针，所以最后处理末尾数据的时候，可以直接把多出来的一截赋值给上一个节点的next AC代码123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode *head, *temp, *temp1; if (l1 == NULL) return l2; if (l2 == NULL) return l1; temp = head = new ListNode(0); while (l2 != NULL &amp;&amp; l1 != NULL) { if (l1-&gt;val &gt; l2-&gt;val) { temp-&gt;next = l2; l2 = l2-&gt;next; } else { temp-&gt;next = l1; l1 = l1-&gt;next; } temp = temp-&gt;next; } if (l1 != NULL) { temp-&gt;next = l1; } if (l2 != NULL) { temp-&gt;next = l2; } return head-&gt;next; }}; 118. 杨辉三角大一必会题，但是题解里说这个也属于动态规划 AC代码12345678910111213141516171819class Solution {public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) { vector&lt;vector&lt;int&gt;&gt; ans; for (int i = 0; i &lt; numRows; i++) { vector&lt;int&gt; line; for (int j = 0; j &lt; i + 1; j++) { if (j == 0 || j == i) { line.push_back(1); } else { line.push_back(ans[i-1][j] + ans[i-1][j-1]); } } ans.push_back(line); line.clear(); } return ans; }}; 119. 杨辉三角 II思路（空间复杂度为O(K)）的算法利用组合数的对称性 12345678910111213141516171819class Solution {public: vector&lt;int&gt; getRow(int rowIndex) { vector&lt;int&gt; ans(rowIndex + 1); for (int i = 0; i &lt; rowIndex+1; i++) { for (int j = 0; j &lt; i / 2 + 1; j++) { if (j == 0) { ans[j] = 1; } else { ans[j] = ans[j] + ans[i - j]; } } for (int j = i / 2 + 1; j &lt; i + 1; j++) { ans[i - (j - (i/2+1))] = ans[j - (i/2+1)]; } } return ans; }}; 121. 买卖股票的最佳时机思路画出售价的时间 - 价格图，关注波峰和波谷如果现在的值小于当前的最小值，则把当前值作为最小值，如果大于最小值，那么计算当前值与最小值的差，如果大于当前利润，则作为最新利润。 AC代码1234567891011121314class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int min = INT_MAX; int profit = 0; for (int i = 0; i &lt; prices.size(); i++) { if (prices[i] &lt; min) min = prices[i]; else if (profit &lt; prices[i] - min) profit = prices[i] - min; } return profit; }}; 122. 买卖股票的最佳时机 II思路找相邻波峰和波谷，波谷买入，波峰售出大循环遍历数组，内层第一个循环找波谷，下一个循环找波峰然后波峰波谷相减，加到profit上 1234567891011121314151617class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { if (!prices.size()) return 0; int i = 0, peak, valley, profit = 0; for (; i &lt; prices.size() - 1; ) { while (i &lt; prices.size() - 1 &amp;&amp; prices[i] &gt;= prices[i + 1]) i++; valley = prices[i]; while (i &lt; prices.size() - 1 &amp;&amp; prices[i] &lt;= prices[i + 1]) i++; peak = prices[i]; profit += peak - valley; } return profit; }}; 136. 只出现一次的数字思路利用异或运算的性质（同为0，不同为1） AC代码12345678910class Solution {public: int singleNumber(vector&lt;int&gt;&amp; nums) { int n = 0; for (auto num : nums) { n ^= num; } return n; }}; 125. 验证回文串思路把是字符的存起来，然后复制反转一份，然后比较 AC代码1234567891011121314class Solution {public: bool isPalindrome(string s) { string temp, cmp; for(int i = 0; i &lt; s.length(); i++) { if(isalpha(s[i]) || isdigit(s[i])) { temp += tolower(s[i]); cmp += tolower(s[i]); } } reverse(cmp.begin(), cmp.end()); return cmp == temp; }}; 141. 环形链表哈希表12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: bool hasCycle(ListNode *head) { map&lt;ListNode*, int&gt; m; ListNode* temp = head; while (temp != NULL) { if (m[temp] &gt;= 2) { return true; } m[temp]++; temp = temp-&gt;next; } return false;}; 思路双指针一个指针一次后移一个，一个指针后移两次，如果快的那个先到终点，说明没有环，如果快的追上，慢的，说明一定有环 1234567891011121314151617class Solution {public: bool hasCycle(ListNode *head) { ListNode *slow, *fast; slow = fast = head; while (slow != NULL) { slow = slow-&gt;next; if (fast != NULL &amp;&amp; fast-&gt;next != NULL) fast = fast-&gt;next-&gt;next; else break; if (slow == fast) { return true; } } return false; }}; 155. 最小栈AC代码12345678910111213141516171819202122232425262728293031323334353637class MinStack {public: /** initialize your data structure here. */ vector&lt;int&gt; data; multiset&lt;int&gt; min; MinStack() { } void push(int x) { data.push_back(x); min.insert(x); } void pop() { min.erase(find(min.begin(), min.end(), *(data.end() - 1))); data.erase(data.end() - 1); } int top() { return *(data.end() - 1); return 0; } int getMin() { return *(min.begin()); return 0; }};/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ AC代码12345678910111213141516171819202122232425262728293031class MinStack {public: stack&lt;int&gt; data; stack&lt;int&gt; min; MinStack() { } void push(int x) { data.push(x); if (min.empty() || x &lt;= min.top()) {//要等号 min.push(x); } } void pop() { int p = data.top(); data.pop(); if (p == min.top()) { min.pop(); } } int top() { return data.top(); } int getMin() { return min.top(); }}; 160. 相交链表思路双指针 两个指针，初始化分别指向链表A、B 如果两个指针不相等，一直循环以下动作 AB指针各自向后移动一格 当某一个指针到大末尾时，指向对方链表的头 最后循环退出，如果结果是NULL表示没有相交 AC代码123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *l1 = headA, *l2 = headB; while (l1 != l2) { if (l1 != NULL) { l1 = l1-&gt;next; } else { l1 = headB; } if (l2 != NULL) { l2 = l2-&gt;next; } else { l2 = headA; } } return l1; }}; 167. 两数之和 II - 输入有序数组思路双指针一个指向开头，一个指向结束相加大于target，后面的前移相加小于target，前面的后移等于，返回下标 AC代码12345678910111213class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) { int i = 0, j = numbers.size() - 1; vector&lt;int&gt; &amp;v = numbers; while (i &lt; j) { if (v[i] + v[j] &gt; target) j--; else if (v[i] + v[j] &lt; target) i++; else return {i + 1, j + 1}; } return {}; }}; 168. Excel表列名称思路递归 首先n-- 如果n在0 - 25，返回对应字母 否则先返回n%26的对应的字母，再返回n/26+1对应的字母 ps：写完看了评论才反应过来，是转换26进制的问题，手动笑哭 AC代码1234567891011121314class Solution {public: string convertToTitle(int n) { string ans; n--; if (n / 26 &gt; 0) { ans += convertToTitle(n/26); ans += convertToTitle(n%26 + 1); } else { return string(1 ,(char)('A' + n)); } return ans; }};","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%933/"},{"title":"LeetCode-28","text":"[Hard] 715. Range 模块思路 二分查找 一开始想的是用[left, right)和全部区间进行比较查找，但是这样比较困难，在处理边界合并情况时会变成O(N) 用left和right分别在所有ranges中查找 对于query，如果两个下标相同，则true，否则false 对于add，查找left-1和right的下标，然后其间的所有ranges删除，插入新range 对于remove，查找left和right-1的下标，然后根据下标把之间的删除，插入剩余的区间 ac代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138class RangeModule { vector&lt;pair&lt;int, int&gt;&gt; ranges; int len = 0; int ops = 0; static constexpr bool debug = false; void printRanges() { int size = ranges.size(); cout &lt;&lt; &quot;len = &quot; &lt;&lt; len &lt;&lt; &quot;, size = &quot; &lt;&lt; size &lt;&lt; &quot;\\n&quot;; for(int i = 0; i &lt; size; i++) { cout &lt;&lt; &quot;[&quot; &lt;&lt; ranges[i].first &lt;&lt; &quot;, &quot; &lt;&lt; ranges[i].second &lt;&lt; &quot;]\\n&quot;; } } bool inRange(int n, int index) { return ranges[index].first &lt;= n &amp;&amp; n &lt; ranges[index].second; } bool bigger(int n, int index) { return n &gt;= ranges[index].second; } bool smaller(int n, int index) { return ranges[index].first &gt; n; } int searchRanges(int n) { int l = 0, r = len; while(l &lt; r) { int mid = (r - l) / 2 + l; if(inRange(n, mid)) return mid; else if(bigger(n, mid)) { l = mid + 1; } else { r = mid; } } return l; }public: RangeModule() { } void addRange(int left, int right) { // if(debug) { // ops++; // cout &lt;&lt; &quot;[&quot; &lt;&lt; ops &lt;&lt; &quot;], &quot; &lt;&lt; &quot;addRange&quot; &lt;&lt; &quot;[&quot; &lt;&lt; left &lt;&lt; &quot;, &quot; &lt;&lt; right &lt;&lt; &quot;]&quot; &lt;&lt; &quot;\\n&quot;; // } _addRange(left, right); // if(debug) printRanges(); } void _addRange(int left, int right) { int leftIndex = searchRanges(left-1); int rightIndex = searchRanges(right); // add时考虑合并相邻的集合，所以把边界放宽 // if(leftIndex &gt; 0 &amp;&amp; ranges[leftIndex - 1].second == left) { // leftIndex--; // } // if(rightIndex &lt; len - 1 &amp;&amp; ranges[rightIndex + 1].first == ) // if(debug) cout &lt;&lt; &quot;leftIndex = &quot; &lt;&lt; leftIndex &lt;&lt; &quot;, rightIndex = &quot; &lt;&lt; rightIndex &lt;&lt; &quot;\\n&quot;; if(leftIndex == rightIndex &amp;&amp; leftIndex == len) { } else { left = min(left, ranges[leftIndex].first); if(rightIndex &lt; len) { if(inRange(right, rightIndex)) { right = max(right, ranges[rightIndex].second); rightIndex++; } } ranges.erase(ranges.begin() + leftIndex, ranges.begin() + rightIndex); len -= rightIndex - leftIndex; } ranges.insert(ranges.begin() + leftIndex, make_pair(left, right)); len++; } bool queryRange(int left, int right) { // if(debug) { // ops++; // cout &lt;&lt; &quot;[&quot; &lt;&lt; ops &lt;&lt; &quot;], &quot; &lt;&lt; &quot;queryRange&quot; &lt;&lt; &quot;[&quot; &lt;&lt; left &lt;&lt; &quot;, &quot; &lt;&lt; right &lt;&lt; &quot;]&quot; &lt;&lt; &quot;\\n&quot;; // } bool ret = _queryRange(left, right); // if(debug) cout &lt;&lt; (ret ? &quot;ok&quot; : &quot;not found&quot;) &lt;&lt; &quot;\\n&quot;; // if(debug) printRanges(); return ret; } bool _queryRange(int left, int right) { int leftIndex = searchRanges(left); int rightIndex = searchRanges(right-1); if(leftIndex &gt;= len || rightIndex &gt;= len) return false; return leftIndex == rightIndex &amp;&amp; inRange(left, leftIndex) &amp;&amp; inRange(right-1, rightIndex); } void removeRange(int left, int right) { // if(debug) { // ops++; // cout &lt;&lt; &quot;[&quot; &lt;&lt; ops &lt;&lt; &quot;], &quot; &lt;&lt; &quot;removeRange&quot; &lt;&lt; &quot;[&quot; &lt;&lt; left &lt;&lt; &quot;, &quot; &lt;&lt; right &lt;&lt; &quot;]&quot; &lt;&lt; &quot;\\n&quot;; // } _removeRange(left, right); // if(debug) printRanges(); } void _removeRange(int left, int right) { int leftIndex = searchRanges(left); int rightIndex = searchRanges(right-1); // if(debug) cout &lt;&lt; &quot;leftIndex = &quot; &lt;&lt; leftIndex &lt;&lt; &quot;, rightIndex = &quot; &lt;&lt; rightIndex &lt;&lt; &quot;\\n&quot;; if(leftIndex == rightIndex &amp;&amp; leftIndex == len) { return; } else { int leftLeft = left, rightRight = right; if(inRange(left, leftIndex)) { leftLeft = ranges[leftIndex].first; } if(rightIndex &lt; len) { if(inRange(right-1, rightIndex)) { rightRight = ranges[rightIndex].second; rightIndex++; } } // if(debug) cout &lt;&lt; &quot;leftIndex = &quot; &lt;&lt; leftIndex &lt;&lt; &quot;, rightIndex = &quot; &lt;&lt; rightIndex &lt;&lt; &quot;\\n&quot;; // if(debug) cout &lt;&lt; &quot;leftLeft = &quot; &lt;&lt; leftLeft &lt;&lt; &quot;, rightRight = &quot; &lt;&lt; rightRight &lt;&lt; &quot;\\n&quot;; ranges.erase(ranges.begin() + leftIndex, ranges.begin() + rightIndex); len -= rightIndex - leftIndex; // if(debug) cout &lt;&lt; &quot;len = &quot; &lt;&lt; len &lt;&lt; &quot;\\n&quot;; if(rightRight &gt; right) { len++; ranges.insert(ranges.begin() + leftIndex, make_pair(right, rightRight)); // if(debug) cout &lt;&lt; &quot;add right len = &quot; &lt;&lt; len &lt;&lt; &quot;\\n&quot;; } if(leftLeft &lt; left) { len++; ranges.insert(ranges.begin() + leftIndex, make_pair(leftLeft, left)); // if(debug) cout &lt;&lt; &quot;add left len = &quot; &lt;&lt; len &lt;&lt; &quot;\\n&quot;; } } }};/** * Your RangeModule object will be instantiated and called as such: * RangeModule* obj = new RangeModule(); * obj-&gt;addRange(left,right); * bool param_2 = obj-&gt;queryRange(left,right); * obj-&gt;removeRange(left,right); */ 优化一些情况可以利用原有的ranges，而无需删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150class RangeModule { vector&lt;pair&lt;int, int&gt;&gt; ranges; int len = 0; int ops = 0; static constexpr bool debug = false; void printRanges() { int size = ranges.size(); cout &lt;&lt; &quot;len = &quot; &lt;&lt; len &lt;&lt; &quot;, size = &quot; &lt;&lt; size &lt;&lt; &quot;\\n&quot;; for(int i = 0; i &lt; size; i++) { cout &lt;&lt; &quot;[&quot; &lt;&lt; ranges[i].first &lt;&lt; &quot;, &quot; &lt;&lt; ranges[i].second &lt;&lt; &quot;]\\n&quot;; } } bool inRange(int n, int index) { return ranges[index].first &lt;= n &amp;&amp; n &lt; ranges[index].second; } bool bigger(int n, int index) { return n &gt;= ranges[index].second; } bool smaller(int n, int index) { return ranges[index].first &gt; n; } int searchRanges(int n) { int l = 0, r = len; while(l &lt; r) { int mid = (r - l) / 2 + l; if(inRange(n, mid)) return mid; else if(bigger(n, mid)) { l = mid + 1; } else { r = mid; } } return l; }public: RangeModule() { } void addRange(int left, int right) { if(debug) { ops++; cout &lt;&lt; &quot;[&quot; &lt;&lt; ops &lt;&lt; &quot;], &quot; &lt;&lt; &quot;addRange&quot; &lt;&lt; &quot;[&quot; &lt;&lt; left &lt;&lt; &quot;, &quot; &lt;&lt; right &lt;&lt; &quot;]&quot; &lt;&lt; &quot;\\n&quot;; } _addRange(left, right); if(debug) printRanges(); } void _addRange(int left, int right) { int leftIndex = searchRanges(left-1); int rightIndex = searchRanges(right); // add时考虑合并相邻的集合，所以把边界放宽 if(debug) cout &lt;&lt; &quot;leftIndex = &quot; &lt;&lt; leftIndex &lt;&lt; &quot;, rightIndex = &quot; &lt;&lt; rightIndex &lt;&lt; &quot;\\n&quot;; if(leftIndex == rightIndex &amp;&amp; leftIndex == len) { ranges.insert(ranges.begin() + leftIndex, make_pair(left, right)); len++; } else { left = min(left, ranges[leftIndex].first); if(rightIndex &lt; len) { if(inRange(right, rightIndex)) { right = max(right, ranges[rightIndex].second); rightIndex++; } } if(leftIndex == rightIndex &amp;&amp; !inRange(left-1, leftIndex) &amp;&amp; !inRange(right, rightIndex)) { ranges.insert(ranges.begin() + leftIndex, make_pair(left, right)); len++; } else { ranges[leftIndex].first = left; ranges[leftIndex].second = right; leftIndex++; if(rightIndex &gt; leftIndex) ranges.erase(ranges.begin() + leftIndex, ranges.begin() + rightIndex); if(rightIndex &gt; leftIndex) len -= rightIndex - leftIndex; } } } bool queryRange(int left, int right) { if(debug) { ops++; cout &lt;&lt; &quot;[&quot; &lt;&lt; ops &lt;&lt; &quot;], &quot; &lt;&lt; &quot;queryRange&quot; &lt;&lt; &quot;[&quot; &lt;&lt; left &lt;&lt; &quot;, &quot; &lt;&lt; right &lt;&lt; &quot;]&quot; &lt;&lt; &quot;\\n&quot;; } bool ret = _queryRange(left, right); if(debug) cout &lt;&lt; (ret ? &quot;ok&quot; : &quot;not found&quot;) &lt;&lt; &quot;\\n&quot;; if(debug) printRanges(); return ret; } bool _queryRange(int left, int right) { int leftIndex = searchRanges(left); int rightIndex = searchRanges(right-1); if(leftIndex &gt;= len || rightIndex &gt;= len) return false; return leftIndex == rightIndex &amp;&amp; inRange(left, leftIndex) &amp;&amp; inRange(right-1, rightIndex); } void removeRange(int left, int right) { if(debug) { ops++; cout &lt;&lt; &quot;[&quot; &lt;&lt; ops &lt;&lt; &quot;], &quot; &lt;&lt; &quot;removeRange&quot; &lt;&lt; &quot;[&quot; &lt;&lt; left &lt;&lt; &quot;, &quot; &lt;&lt; right &lt;&lt; &quot;]&quot; &lt;&lt; &quot;\\n&quot;; } _removeRange(left, right); if(debug) printRanges(); } void _removeRange(int left, int right) { int leftIndex = searchRanges(left); int rightIndex = searchRanges(right-1); if(debug) cout &lt;&lt; &quot;leftIndex = &quot; &lt;&lt; leftIndex &lt;&lt; &quot;, rightIndex = &quot; &lt;&lt; rightIndex &lt;&lt; &quot;\\n&quot;; if(leftIndex == rightIndex &amp;&amp; leftIndex == len) { return; } else { int leftLeft = left, rightRight = right; if(inRange(left, leftIndex)) { leftLeft = ranges[leftIndex].first; } if(rightIndex &lt; len) { if(inRange(right-1, rightIndex)) { rightRight = ranges[rightIndex].second; rightIndex++; } } if(debug) cout &lt;&lt; &quot;leftIndex = &quot; &lt;&lt; leftIndex &lt;&lt; &quot;, rightIndex = &quot; &lt;&lt; rightIndex &lt;&lt; &quot;\\n&quot;; if(debug) cout &lt;&lt; &quot;leftLeft = &quot; &lt;&lt; leftLeft &lt;&lt; &quot;, rightRight = &quot; &lt;&lt; rightRight &lt;&lt; &quot;\\n&quot;; if(rightRight &gt; right) { rightIndex--; ranges[rightIndex].first = right; ranges[rightIndex].second = rightRight; if(debug) cout &lt;&lt; &quot;add right len = &quot; &lt;&lt; len &lt;&lt; &quot;\\n&quot;; } if(leftLeft &lt; left) { if(leftIndex == rightIndex) { ranges.insert(ranges.begin() + leftIndex, make_pair(leftLeft, left)); len++; } else { ranges[leftIndex].first = leftLeft; ranges[leftIndex].second = left; leftIndex++; } if(debug) cout &lt;&lt; &quot;add left len = &quot; &lt;&lt; len &lt;&lt; &quot;\\n&quot;; } ranges.erase(ranges.begin() + leftIndex, ranges.begin() + rightIndex); len -= rightIndex - leftIndex; if(debug) cout &lt;&lt; &quot;len = &quot; &lt;&lt; len &lt;&lt; &quot;\\n&quot;; } }};/** * Your RangeModule object will be instantiated and called as such: * RangeModule* obj = new RangeModule(); * obj-&gt;addRange(left,right); * bool param_2 = obj-&gt;queryRange(left,right); * obj-&gt;removeRange(left,right); */ 1334. 阈值距离内邻居最少的城市Floyd1234567891011121314151617181920212223242526272829303132333435class Solution {public: int findTheCity(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int distanceThreshold) { vector&lt;vector&lt;int&gt;&gt; g(n, vector&lt;int&gt;(n, INT_MAX)); vector&lt;int&gt; cnt(n, 0); for(vector&lt;int&gt;&amp; edge : edges) { g[edge[0]][edge[1]] = edge[2]; g[edge[1]][edge[0]] = edge[2]; } for(int w = 0; w &lt; n; w++) { for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(g[i][w] != INT_MAX &amp;&amp; g[w][j] != INT_MAX &amp;&amp; g[i][w] + g[w][j] &lt; g[i][j]) g[i][j] = g[i][w] + g[w][j]; } } } for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(i != j &amp;&amp; g[i][j] &lt;= distanceThreshold) { cnt[i]++; } } } int ret = 0; int min_num = INT_MAX; for(int i = n-1; i &gt;= 0; i--) { if(cnt[i] &lt; min_num) { min_num = cnt[i]; ret = i; } } return ret; }}; 中间节点w要放在最外层循环 优化一下下1234567891011121314151617181920212223242526272829303132333435class Solution {public: int findTheCity(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int distanceThreshold) { vector&lt;vector&lt;int&gt;&gt; g(n, vector&lt;int&gt;(n, INT_MAX / 2)); for(vector&lt;int&gt;&amp; edge : edges) { g[edge[0]][edge[1]] = edge[2]; g[edge[1]][edge[0]] = edge[2]; } for(int w = 0; w &lt; n; w++) { g[w][w] = 0; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(g[i][w] + g[w][j] &lt; g[i][j]) g[i][j] = g[i][w] + g[w][j]; } } } int ret = 0; int min_num = INT_MAX; for(int i = n-1; i &gt;= 0; i--) { int cnt = 0; for(int j = 0; j &lt; n; j++) { if(g[i][j] &lt;= distanceThreshold) { cnt++; } } if(cnt &lt; min_num) { // cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;, cnt[i] = &quot; &lt;&lt; cnt[i] &lt;&lt; &quot;\\n&quot;; min_num = cnt; ret = i; } } return ret; }}; BFS写了半天，发现带权图不能bfs求最短路径 dijkstra1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution { int min_index(int len, const vector&lt;int&gt;&amp; v, const vector&lt;bool&gt;&amp; visited) { pair&lt;int, int&gt; ret(INT_MAX, -1); for(int i = 0; i &lt; len; i++) { if(!visited[i] &amp;&amp; v[i] &lt; ret.first) { ret = {v[i], i}; } } return ret.second; }public: int findTheCity(int n, vector&lt;vector&lt;int&gt;&gt; &amp;edges, int distanceThreshold) { vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; g(n); for(auto&amp; edge : edges) { g[edge[0]].push_back(make_pair(edge[1], edge[2])); g[edge[1]].push_back(make_pair(edge[0], edge[2])); } int ret = -1; int min_cnt = INT_MAX; for(int node = 0; node &lt; n; node++) { int cnt = 0; vector&lt;int&gt; min_dis(n, INT_MAX &gt;&gt; 2); vector&lt;bool&gt; visited(n, false); min_dis[node] = 0; int next = node; do { visited[next] = true; for(auto&amp; [child, weight] : g[next]) { min_dis[child] = min(min_dis[child], min_dis[next] + weight); } } while((next = min_index(n, min_dis, visited)) != -1); for(int i = 0; i &lt; n; i++) { if(min_dis[i] &lt;= distanceThreshold) { cnt++; } } if(cnt &lt;= min_cnt) { min_cnt = cnt; ret = node; } } return ret; }}; 307. 区域和检索 - 数组可修改分块思路把数组分成sqrt(n)份，存储每份的和更新时，找到对应区间把值更新，O(1)求值时，把left到right对应区间的和加起来，加上right右边的不足一个区间的，减去左侧超过一个区间的，三个运算都在sqrt(n)内完成, O(sqrt(n)) 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344class NumArray { vector&lt;int&gt; data; vector&lt;int&gt; preSum; int size; int len;public: NumArray(vector&lt;int&gt;&amp; nums) { data = nums; len = nums.size(); if(len == 0) return; size = sqrt(len); preSum = vector&lt;int&gt;(size + 20, 0); for(int i = 0; i &lt; len; i++) { preSum[i / size] += nums[i]; } } void update(int index, int val) { int prev = data[index]; data[index] = val; preSum[index / size] += val - prev; } int sumRange(int left, int right) { int sum = 0; for(int i = left/size; i &lt; right/size; i++) { sum += preSum[i]; } for(int i = right / size * size; i &lt;= right; i++) { sum += data[i]; } for(int i = left / size * size; i &lt; left; i++) { sum -= data[i]; } return sum; }};/** * Your NumArray object will be instantiated and called as such: * NumArray* obj = new NumArray(nums); * obj-&gt;update(index,val); * int param_2 = obj-&gt;sumRange(left,right); */ 线段树 构造一棵树 根节点代表[0, n-1]的和 两个子节点分别代表[0,(n-1)/2]和[(n-1)/2+1, n-1]的和 如果区间为0，则不继续细分 更新 根据index在树中查找，同时更新所有父节点的值 查询 对于一个查询， 如果查询范围刚好等于节点代表的范围，则返回该节点的值 如果不同，则将查询一分为两个子查询，分别交给子节点处理，直到遇到子查询与子节点代表的范围相同，将所有子查询相加 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class NumArray {private: vector&lt;int&gt; tree; int n; int build(int node, int l, int r, const vector&lt;int&gt;&amp; nums) { if(l == r) tree[node] = nums[l]; else { int mid = (r - l) / 2 + l; tree[node] = build(2*node+1, l, mid, nums) + build(2*node+2, mid+1, r, nums); } return tree[node]; } void updateTree(int node, int index, int l, int r, int val) { if(l == r) tree[node] = val; else { int mid = (r - l) / 2 + l; if(index &lt;= mid) { updateTree(node*2+1, index, l, mid, val); } else { updateTree(node*2+2, index, mid+1, r, val); } tree[node] = tree[2*node+1] + tree[2*node+2]; } } int sumTree(int node, int left, int right, int l, int r) { if(left == l &amp;&amp; right == r) { return tree[node]; } int mid = (r - l) / 2 + l; if(left &gt; mid) { return sumTree(node*2+2, left, right, mid+1, r); } else if(right &lt;= mid) { return sumTree(node*2+1, left, right, l, mid); } else { return sumTree(node*2+1, left, mid, l, mid) + sumTree(2*node+2, mid+1, right, mid+1, r); } }public: NumArray(vector&lt;int&gt;&amp; nums) { n = nums.size(); tree = vector&lt;int&gt;(n * 4); build(0, 0, n-1, nums); } void update(int index, int val) { updateTree(0, index, 0, n-1, val); } int sumRange(int left, int right) { return sumTree(0, left, right, 0, n-1); }};/** * Your NumArray object will be instantiated and called as such: * NumArray* obj = new NumArray(nums); * obj-&gt;update(index,val); * int param_2 = obj-&gt;sumRange(left,right); */ 765. 情侣牵手思路看了下面的提示： Say there are N two-seat couches. For each couple, draw an edge from the couch of one partner to the couch of the other partner. 让我画出座位上的人到其伴侣的箭头 如果箭头在同一个沙发上，就无需交换 如果不在同一个沙发上，就让另一个人与其交换 对每个沙发执行相同的任务 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution { int n; int min_swap_cnt = INT_MAX; unordered_map&lt;int, int&gt; pos;public: int minSwapsCouples(vector&lt;int&gt;&amp; row) { n = row.size(); for(int i = 0; i &lt; n; i++) { pos[row[i]] = i; } search(0, 0, row); return min_swap_cnt; } void print(const vector&lt;int&gt;&amp; nums) { cout &lt;&lt; nums[0]; for(int i = 1; i &lt; n; i++) cout &lt;&lt; &quot;, &quot; &lt;&lt; nums[i]; cout &lt;&lt; &quot;\\n&quot;; } bool check(const vector&lt;int&gt;&amp; nums) { for(int i = 0; i &lt; n; i+=2) { if(abs(nums[i] - nums[i+1]) != 1) return false; } return true; } void search(int s, int cnt, vector&lt;int&gt; &amp;nums) { // print(nums); if(check(nums)) { min_swap_cnt = min(min_swap_cnt, cnt); return; } if(s &gt;= n) return; int i = s; for(int i = s; i &lt; n; i++) { int target = nums[i] + ((nums[i] &amp; 1) ? -1 : 1); int j = pos[target]; if(i/2 != j/2) { int x = (i&amp;1) ? -1 : 1; pos[target] = i + x; pos[nums[i + x]] = j; swap(nums[i + x], nums[j]); search(i + 2, cnt+1, nums); // swap(nums[i + x], nums[j]); // pos[target] = j; // pos[nums[i + x]] = i + x; // search(i + 2, cnt, nums); break; } } }}; emm,一点点蒙对的，居然对了 简化代码123456789101112131415161718192021class Solution {public: int minSwapsCouples(vector&lt;int&gt;&amp; row) { int swap_cnt = 0; int n = row.size(); vector&lt;int&gt; pos(n); for(int i = 0; i &lt; n; i++) { pos[row[i]] = i; } for(int i = 0; i &lt; n; i+=2) { int target = row[i] + ((row[i] &amp; 1) ? -1 : 1); int j = pos[target]; if(i/2 != j/2) { swap(pos[target], pos[row[i + 1]]); swap(row[i + 1], row[j]); swap_cnt++; } } return swap_cnt; }};","link":"/home/2023/11/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9328/"},{"title":"LeetCode-30","text":"162. 寻找峰值123456789class Solution {public: int findPeakElement(vector&lt;int&gt;&amp; nums) { int index = 0; int n = nums.size(); while(index &lt; n-1 &amp;&amp; nums[index] &lt; nums[index+1]) index++; return index; }}; 1901. 寻找峰值 II1234567891011121314151617181920212223242526class Solution {public: vector&lt;int&gt; findPeakGrid(vector&lt;vector&lt;int&gt;&gt;&amp; mat) { int x = 0, y = 0; int m = mat.size(), n = mat[0].size(); bool findPoint = true; while(findPoint) { findPoint = false; if(x + 1 &lt; m &amp;&amp; mat[x+1][y] &gt; mat[x][y]) { findPoint = true; x++; } else if(x - 1 &gt;= 0 &amp;&amp; mat[x-1][y] &gt; mat[x][y]) { findPoint = true; x--; } else if(y + 1 &lt; n &amp;&amp; mat[x][y+1] &gt; mat[x][y]) { findPoint = true; y++; } else if(y - 1 &gt;= 0 &amp;&amp; mat[x][y-1] &gt; mat[x][y]) { findPoint = true; y--; } } return {x, y}; }}; 贪心，从某一点开始，如果上下左右存在比当前点大的数，移动过去，直到无法移动 746. 使用最小花费爬楼梯1234567891011121314class Solution {public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) { int n = cost.size(); vector&lt;int&gt; vecc(n+1, INT_MAX); vecc[0] = vecc[1] = 0; for(int i = 0; i &lt; n-1; i++) { vecc[i+1] = min(vecc[i+1], vecc[i] + cost[i]); vecc[i+2] = min(vecc[i+2], vecc[i] + cost[i]); } vecc[n] = min(vecc[n], vecc[n-1] + cost[n-1]); return vecc[n]; }}; 12345678910111213class Solution {public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) { int n = cost.size(); int a = cost[0], b = cost[1]; for(int i = 2; i &lt; n; i++) { int t = cost[i] + min(a, b); a = b; b = t; } return min(a, b); }}; 2415. 反转二叉树的奇数层123456789101112131415161718192021222324252627282930class Solution {public: TreeNode* reverseOddLevels(TreeNode* root) { queue&lt;TreeNode *&gt; q; if(root) q.push(root); int n = 1; bool rev = false; while(!q.empty()) { int cnt = n; vector&lt;TreeNode *&gt; tmp; while(n--) { TreeNode *node = q.front(); q.pop(); if(rev) tmp.push_back(node); if(node-&gt;left &amp;&amp; node-&gt;right) { q.push(node-&gt;left); q.push(node-&gt;right); } } if(rev) { for(int i = 0; i &lt; cnt / 2; i++) { swap(tmp[i]-&gt;val, tmp[cnt - 1 - i]-&gt;val); } } rev = !rev; n = cnt &lt;&lt; 1; } return root; }}; 1631. 最小体力消耗路径超时123456789101112131415161718192021222324252627class Solution {public: int minimumEffortPath(vector&lt;vector&lt;int&gt;&gt;&amp; heights) { int row = heights.size(), col = heights[0].size(); if(row &lt;= 1 &amp;&amp; col &lt;= 1) return 0; vector&lt;int&gt; len(row*col, INT_MAX / 2); vector&lt;bool&gt; visited(row*col, false); len[0] = 0; for(int i = 0; i &lt; row*col - 1; i++) { int min_dis = 0; int node = -1; for(int j = 0; j &lt; row*col; j++) { if(!visited[j] &amp;&amp; (node == -1 || len[j] &lt; len[node])) { node = j; } } int x = node / col, y = node % col; if(x &lt; row - 1 &amp;&amp; !visited[node+col]) len[node+col] = min(len[node+col], max(len[node], abs(heights[x][y] - heights[x+1][y]))); if(y &lt; col - 1 &amp;&amp; !visited[node+1]) len[node+1] = min(len[node+1], max(len[node], abs(heights[x][y] - heights[x][y+1]))); if(x &gt; 0 &amp;&amp; !visited[node-col]) len[node-col] = min(len[node-col], max(len[node], abs(heights[x][y] - heights[x-1][y]))); if(y &gt; 0 &amp;&amp; !visited[node-1]) len[node-1] = min(len[node-1], max(len[node], abs(heights[x][y] - heights[x][y-1]))); visited[node] = true; } return len[row*col-1]; }}; 优化dijkstra需要用优先队列优化一下 1234567891011121314151617181920212223242526272829303132333435class Solution { static constexpr int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};public: int minimumEffortPath(vector&lt;vector&lt;int&gt;&gt;&amp; heights) { int row = heights.size(), col = heights[0].size(); if(row &lt;= 1 &amp;&amp; col &lt;= 1) return 0; vector&lt;int&gt; len(row*col, INT_MAX / 2); vector&lt;bool&gt; visited(row*col, false); len[0] = 0; int min_dis = 0; int node = -1; auto tupleCmp = [](const auto&amp; e1, const auto&amp; e2) { auto&amp;&amp; [x1, d1] = e1; auto&amp;&amp; [x2, d2] = e2; return d1 &gt; d2; }; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(tupleCmp)&gt; q(tupleCmp); q.emplace(0, 0); while(!q.empty()) { auto [node, dis] = q.top(); q.pop(); int x = node / col, y = node % col; for(int i = 0; i &lt; 4; i++) { int nx = x + dirs[i][0]; int ny = y + dirs[i][1]; if(nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; row &amp;&amp; ny &lt; col &amp;&amp; max(dis, abs(heights[x][y] - heights[nx][ny])) &lt; len[node + col * dirs[i][0] + dirs[i][1]]) { len[node + col * dirs[i][0] + dirs[i][1]] = max(dis, abs(heights[x][y] - heights[nx][ny])); q.emplace(node + col * dirs[i][0] + dirs[i][1], len[node + col * dirs[i][0] + dirs[i][1]]); } } visited[node] = true; } return len[row*col-1]; }}; LCR 078. 合并 K 个升序链表 方法和和并两个升序链表相同，k个链表每次从k个指针中选择出值最小的一个插入到总链表中 使用优先队列可以把算法优化到O(k*log(k)) 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { auto cmp = [](ListNode *a, ListNode *b) { return a-&gt;val &gt; b-&gt;val; }; priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, decltype(cmp)&gt; q(cmp); ListNode dummyNode; ListNode *dummyPtr = &amp;dummyNode; int k = lists.size(); for(int i = 0; i &lt; k; i++) { if(lists[i]) q.push(lists[i]); } while(!q.empty()) { ListNode *node = q.top(); q.pop(); dummyPtr-&gt;next = node; dummyPtr = node; node = node-&gt;next; if(node) { q.push(node); } } return dummyNode.next; }}; 2866. 美丽塔 II枚举山峰1234567891011121314151617181920212223242526272829303132333435class Solution {private: int len; void toHill(const vector&lt;int&gt;&amp; arr, int&amp; index, int endIndex) const { while(index + 1 &lt; endIndex &amp;&amp; arr[index] &lt;= arr[index+1]) index++; } void toValley(const vector&lt;int&gt;&amp; arr, int&amp; index, int endIndex) const { while(index + 1 &lt; endIndex &amp;&amp; arr[index] &gt;= arr[index+1]) index++; }public: long long maximumSumOfHeights(vector&lt;int&gt;&amp; maxHeights) { len = maxHeights.size(); int index = 0; toHill(maxHeights, index, len); long long res = 0; while(index &lt; len) { int val = maxHeights[index]; long long sum = 0; for(int i = index; i &gt;= 0; i--) { val = min(val, maxHeights[i]); sum += val; } val = maxHeights[index]; for(int i = index + 1; i &lt; len; i++) { val = min(val, maxHeights[i]); sum += val; } res = max(sum, res); index++; toValley(maxHeights, index, len); toHill(maxHeights, index, len); } return res; }}; 单调栈 还是不会单调栈，明天开学单调栈！ 2048. 下一个更大的数值平衡数排列组合 若平衡数为d位数，将d拆成若干个不相等的数 如：6可以拆成，6, 2+4, 1+5, 1+2+3 他们分别对应，666666, 224444, 155555, 122333以及他们的排列组合 求出所有排列组合，找到大于n的最小排列 由于一个数的下一个平衡数的位数可能大于他，需要考虑相邻两位的情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution { vector&lt;vector&lt;string&gt;&gt; origin = { {&quot;1&quot;}, {&quot;22&quot;}, {&quot;122&quot;, &quot;333&quot;}, {&quot;1333&quot;, &quot;4444&quot;}, {&quot;22333&quot;, &quot;14444&quot;, &quot;55555&quot;}, {&quot;122333&quot;, &quot;155555&quot;, &quot;224444&quot;, &quot;666666&quot;}, {&quot;1224444&quot;/*, &quot;1666666&quot;, &quot;7777777&quot;*/}, {&quot;88888888&quot;} // dummy for 1000000 }; int n; int ret = INT_MAX; int len;public: int nextBeautifulNumber(int n) { if(n == 0) return 1; this-&gt;n = n; len = digitCnt(n); for(string s : origin[len-1]) { permutaion(s, 0); } len++; for(string s : origin[len-1]) { permutaion(s, 0); } return ret; } void permutaion(string &amp;arr, int start) { if(start == len) { int number = 0; for(int i = 0; i &lt; len; i++) { number *= 10; number += arr[i] - '0'; } if(number &gt; n) ret = min(ret, number); } for(int i = start; i &lt; len; i++) { bool flag = false; for (int j = start; j &lt; i; j++) { if (arr[i] == arr[j]) { flag = true; break; } } if(!flag) { swap(arr[i], arr[start]); permutaion(arr, start+1); swap(arr[i], arr[start]); } } } int digitCnt(int n) { int digit = 0; while(n) { n /= 10; digit++; } return digit; }}; 打表 生成所有满足条件的数123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;limits.h&gt;#include &lt;stdbool.h&gt;bool check(int i) { int cnt[10] = {0}; char digits[128] = {0}; sprintf(digits, &quot;%d&quot;, i); char *ptr = digits; while(*ptr) { cnt[*ptr - '0']++; ptr++; } bool flag = cnt[0] == 0; for(int i = 1; i &lt; 10; i++) { if(cnt[i] &amp;&amp; cnt[i] != i) { flag = false; break; } } return flag;}int main() { printf(&quot;{&quot;); for(int i = 0; i &lt; 1000000; i++) { if(check(i)) printf(&quot;%d,&quot;, i); } for(int i = 1000000 + 1; i &lt; INT_MAX; i++) { if(check(i)) { printf(&quot;%d}\\n&quot;, i); break; } } return 0;} 123456789class Solution { vector&lt;int&gt; origin = { 1,22,122,212,221,333,1333,3133,3313,3331,4444,14444,22333,23233,23323,23332,32233,32323,32332,33223,33232,33322,41444,44144,44414,44441,55555,122333,123233,123323,123332,132233,132323,132332,133223,133232,133322,155555,212333,213233,213323,213332,221333,223133,223313,223331,224444,231233,231323,231332,232133,232313,232331,233123,233132,233213,233231,233312,233321,242444,244244,244424,244442,312233,312323,312332,313223,313232,313322,321233,321323,321332,322133,322313,322331,323123,323132,323213,323231,323312,323321,331223,331232,331322,332123,332132,332213,332231,332312,332321,333122,333212,333221,422444,424244,424424,424442,442244,442424,442442,444224,444242,444422,515555,551555,555155,555515,555551,666666,1224444 };public: int nextBeautifulNumber(int n) { return *upper_bound(origin.begin(), origin.end(), n); }}; 1671. 得到山形数组的最少删除次数dp 不会，抄答案 arr1[i]表示0..(i-1)中小于nums[i]的元素个数 arr2[i]表示(i+1)..(len)中小于nums[i]的元素个数 arr1[i] + arr2[i] + 1表示以i为山峰的山状数组长度 1234567891011121314151617181920212223242526272829class Solution { int n = 0; vector&lt;int&gt; getLISArray(const vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; dp(n, 1); for (int i = 0; i &lt; n; ++i) { for (int j = 0; j &lt; i; ++j) { if (nums[j] &lt; nums[i]) { dp[i] = max(dp[i], dp[j] + 1); } } } return dp; }public: int minimumMountainRemovals(vector&lt;int&gt;&amp; nums) { n = nums.size(); vector&lt;int&gt; pre = getLISArray(nums); vector&lt;int&gt; suf = getLISArray({nums.rbegin(), nums.rend()}); reverse(suf.begin(), suf.end()); int ans = 0; for (int i = 0; i &lt; n; ++i) { if (pre[i] &gt; 1 &amp;&amp; suf[i] &gt; 1) { ans = max(ans, pre[i] + suf[i] - 1); } } return n - ans; }}; 1962. 移除石子使总数最小模拟ac代码123456789101112131415161718192021class Solution {public: int minStoneSum(vector&lt;int&gt;&amp; piles, int k) { priority_queue&lt;int&gt; q; int ret = 0; for(int rock : piles) { if(rock) q.push(rock); } while(!q.empty() &amp;&amp; k--) { int rock = q.top(); q.pop(); if(rock - rock / 2) q.push(rock - rock / 2); } while(!q.empty()) { int rock = q.top(); q.pop(); ret += rock; } return ret; }}; 优化模拟 一边减少一边算最终结果 1234567891011121314class Solution {public: int minStoneSum(vector&lt;int&gt;&amp; piles, int k) { priority_queue&lt;int&gt; q(piles.begin(), piles.end()); int ret = accumulate(piles.begin(), piles.end(), 0); while(k--) { int rock = q.top(); q.pop(); if(rock - rock / 2) q.push(rock - rock / 2); ret -= rock / 2; } return ret; }}; 时间100% 看了时间100%的方法，由于数字最大是10000，可以创建一个长度为10000+1的bool数组 从下标最大到最小，选择存在于原数组的下标（bool数组置为true），除二，并把剩余部分设置为true 这样就可以起到和优先队列一样的效率 代码1234567891011121314151617181920212223class Solution {public: int minStoneSum(vector&lt;int&gt;&amp; piles, int k) { bool buck[10000] = {false}; int ret = 0, max_rock = INT_MIN; for(int rock : piles) { max_rock = max(max_rock, rock); buck[rock-1] = true; ret += rock; } while(max_rock--) { if(!buck[max_rock]) continue; if(k--) { int diff = (max_rock + 1) / 2; buck[max_rock - diff] = true; ret -= diff; } else { break; } } return ret; }}; 这个代码跑是错的，因为没有考虑同一个数出现多次的情况，所以不能使用bool数组 1234567891011121314151617181920class Solution {public: int minStoneSum(vector&lt;int&gt;&amp; piles, int k) { int buck[10000+1] = {false}; int ret = 0, max_rock = INT_MIN; for(int rock : piles) { max_rock = max(max_rock, rock); buck[rock]++; ret += rock; } for(;max_rock &amp;&amp; k; max_rock--) { int width = min(buck[max_rock], k); int diff = (max_rock) / 2; ret -= diff * width; buck[max_rock - diff] += width; k -= width; } return ret; }}; 1954. 收集足够苹果的最小花园周长枚举 刚开始看错题了，认为只计算正方形的边上的苹果数 推导出当边长为2*radius时，边上的苹果数目为 4*radius + 8*radius + 4*3*radius*(radius-1) 枚举边长并将边上的苹果加起来，直到超过需要的苹果即可 公式推导 bfs的思想 边长为0的所有点(0,0) 的子节点，分为两类是 |x| + |y| = 1 (1, 0), (0, 1), (-1, 0), (0, -1) |x| + |y| = 2 (1, 1), (1, -1), (-1, 1), (-1, -1) 点可能存在两种子节点，一种节点会让|x| + |y|增大1，另一种会增大2 四个角上的子节点会增大二，四个角上的子节点有增大2和增大1的 非四个角上的子节点只会增大1 四个角上的节点的|x| + |y| = 2*radius孵化子代 产生4个增大2的，也就是公差为2的，也就是4*2*radius 产生8个增大1的 剩余节点孵化子代 只会产生一个公差为1的 再统计边长为1的所有点的子节点，可以发现，当半径为radius时： |x| + |y| = radius 的有 4 个 |x| + |y| = radius + i, i = 1, 2, ..., radius-1的各有8个 |x| + |y| = 2*radius的有4个 总和为： 4*radius $ 8 \\times \\sum_{i=radius+1}^{2*radius-1}{i} = \\frac{(3 \\times radius)\\times(radius-1)}{2} \\times 8$ 4*2*radius 将以上三部分求和，得到 $ 4radius + 8radius + 12radius(radius - 1)$ 代码1234567891011class Solution {public: long long minimumPerimeter(long long neededApples) { long long radius = 0, apple = 0; while(apple &lt; neededApples) { radius++; apple += 4*radius + 8*radius + 4*3*radius*(radius-1); } return 8 * radius; }}; 二分 将上面的公式再次推导，即可得到对于半径为radius的正方形上以及其内部，共有苹果 $ 2radius(radius+1)(2radius+1) $ 然后就能愉快的二分啦 12345678910111213141516171819202122232425class Solution {public: long long minimumPerimeter(long long neededApples) { long long mid = 0, apple = 0; int l = 0, r = 500000; while(l &lt; r) { // [l, r] // f(l) &lt; target // f(r) &gt;= target mid = (r - l) / 2 + l; apple = 2*mid*(mid+1)*(2*mid+1); if(apple &lt; neededApples) { l = mid + 1; } else { r = mid; } } // [r, l) return 8 * l; }};// l = mid + 1, r = mid - 1, 闭区间// r = mid, l = mid, 开区间// l &lt;= r // 双闭区间(对应区间没有数)","link":"/home/2023/12/19/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9330/"},{"title":"LeetCode-31","text":"1276. 不浪费原料的汉堡制作方案 解方程，判断是非负整数解就行 用位运算，能快一点 12345678910111213class Solution {public: vector&lt;int&gt; numOfBurgers(int tomatoSlices, int cheeseSlices) { int jumbo = 0, small = 0; // jumbo + small == cheeseSlices; // 4*jumbo + 2*small == tomatoSlices; small = ((cheeseSlices &lt;&lt; 2) - tomatoSlices); jumbo = (tomatoSlices - (cheeseSlices &lt;&lt; 1)); if(jumbo &gt;= 0 &amp;&amp; small &gt;= 0 &amp;&amp; (small &amp; 1) == 0 &amp;&amp; (jumbo &amp; 1) == 0) return {jumbo &gt;&gt; 1, small &gt;&gt; 1}; return {}; }}; 1185. 一周中的第几天 梦回大一 1234567891011121314151617181920212223242526class Solution {public: string dayOfTheWeek(int day, int month, int year) { int week = 0; for(int i = 1971; i &lt; year; i++) { week = (week + 31 * 7 + 30 * 4 + 28) % 7; if((i % 100 != 0 &amp;&amp; i % 4 == 0) || i % 400 == 0) { week = (week + 1) % 7; } } for(int i = 1; i &lt; month; i++) { if(i == 2) { week = (week + 28) % 7; if((year % 100 != 0 &amp;&amp; year % 4 == 0) || year % 400 == 0) { week = (week + 1) % 7; } } else if(i == 1 || i == 3 || i == 5 || i == 7 || i == 8 || i == 10 || i == 12) { week = (week + 31) % 7; } else { week = (week + 30) % 7; } } week = (week + day + 4) % 7; return vector&lt;string&gt;{&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;}[week]; }}; 2706. 购买两块巧克力123456789101112131415class Solution {public: int buyChoco(vector&lt;int&gt;&amp; prices, int money) { int minPrice = INT_MAX / 2, secondMinPrice = INT_MAX / 2; for(int price : prices) { if(price &lt; minPrice) { secondMinPrice = minPrice; minPrice = price; } else if(price &lt; secondMinPrice) { secondMinPrice = price; } } return (minPrice + secondMinPrice &lt;= money) ? (money - minPrice - secondMinPrice) : money; }}; 2735. 收集巧克力123456789101112131415class Solution {public: long long minCost(vector&lt;int&gt;&amp; nums, int x) { int n = nums.size(); vector&lt;int&gt; f(nums); long long ans = accumulate(f.begin(), f.end(), 0LL); for (int k = 1; k &lt; n; ++k) { for (int i = 0; i &lt; n; ++i) { f[i] = min(f[i], nums[(i + k) % n]); } ans = min(ans, (long long)(k) * x + accumulate(f.begin(), f.end(), 0LL)); } return ans; }}; 1599. 经营摩天轮的最大利润模拟 模拟经营 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: int minOperationsMaxProfit(vector&lt;int&gt;&amp; customers, int boardingCost, int runningCost) { int wating = 0; int porfit = 0; int maxProfit = 0; int maxProfitI = -2; int len = customers.size(); int i = 0; for(; i &lt; len; i++) { if(customers[i] + wating &gt; 4) { wating += customers[i] - 4; customers[i] = 4; } else { customers[i] = customers[i] + wating; wating = 0; } porfit += boardingCost * customers[i] - runningCost; if(porfit &gt; maxProfit) { maxProfit = porfit; maxProfitI = i; } } while(wating &gt; 0) { int onboard = 0; if(wating &gt; 4) { onboard = 4; wating -= 4; } else { onboard = wating; wating = 0; } porfit += boardingCost * onboard - runningCost; if(porfit &gt; maxProfit) { maxProfit = porfit; maxProfitI = i; } i++; } return maxProfitI+1; }}; 优化 数组遍历结束后，剩下的乘客可以不用模拟，直接/4看有几次就好 如果boardingCost runningCost的值恰好无论如何都无法盈利，可以不算后面的 12345678910111213141516171819202122232425262728293031323334353637383940class Solution {public: int minOperationsMaxProfit(vector&lt;int&gt;&amp; customers, int boardingCost, int runningCost) { int wating = 0; int porfit = 0; int maxProfit = 0; int maxProfitI = -1; int len = customers.size(); int i = 1; for(; i &lt;= len; i++) { wating += customers[i-1]; int onboard = min(4, wating); wating -= onboard; porfit += boardingCost * onboard - runningCost; if(porfit &gt; maxProfit) { maxProfit = porfit; maxProfitI = i; } } int fullCost = (boardingCost &lt;&lt; 2) - runningCost; if(fullCost &lt;= 0) return maxProfitI; if(wating &gt; 0) { int ramain = wating % 4; int roll = wating &gt;&gt; 2; wating = ramain; porfit += roll * fullCost; i += roll; if(porfit &gt; maxProfit) { maxProfit = porfit; maxProfitI = i - 1; } porfit += boardingCost * wating - runningCost; if(porfit &gt; maxProfit) { maxProfit = porfit; maxProfitI = i; } } return maxProfitI; }}; 889. 根据前序和后序遍历构造二叉树 对于根节点，先序序列的右侧是左节点，后序序列的右测是右节点 如果两个节点不同，则节点有两个子节点，如果相同，则该节点可能是左节点，也可能是右节点 对于其他节点，维护好该节点可在先序序列中可查询子代的范围，如果范围是1，则无子代，否则继续插入子代 非递归算法 两个数组，分别记录节点在先序、后序序列中的位置 queue保存当前节点位置，以及在先序序列中后代的范围 1234567891011121314151617181920212223242526272829303132class Solution {public: TreeNode* constructFromPrePost(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; postorder) { int len = preorder.size(); TreeNode *root = new TreeNode(preorder[0]); queue&lt;tuple&lt;TreeNode*, int, int&gt;&gt; q; q.push(make_tuple(root, 0, len)); vector&lt;int&gt; pre_index(len+1), post_index(len+1); for(int i = 0; i &lt; len; i++) { pre_index[preorder[i]] = i; post_index[postorder[i]] = i; } while(!q.empty()) { auto [node, l, r] = q.front(); q.pop(); if(l+1 &gt;= r) continue; int left = pre_index[node-&gt;val] + 1, right = post_index[node-&gt;val] - 1; if(left &lt; len &amp;&amp; right &gt;= 0) { if(preorder[left] != postorder[right]) { node-&gt;left = new TreeNode(preorder[left]); node-&gt;right = new TreeNode(postorder[right]); q.emplace(node-&gt;left, left, pre_index[postorder[right]]); q.emplace(node-&gt;right, pre_index[postorder[right]], r); } else { node-&gt;left = new TreeNode(preorder[left]); q.emplace(node-&gt;left, left, r); } } } return root; }}; 递归算法123456789101112131415161718192021222324252627282930class Solution { int len; void insertNode(TreeNode* node, int l, int r, vector&lt;int&gt; &amp;pre_index, vector&lt;int&gt; &amp;post_index, vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; postorder) { if(l+1 &gt;= r) return; int left = pre_index[node-&gt;val] + 1, right = post_index[node-&gt;val] - 1; if(left &lt; len &amp;&amp; right &gt;= 0) { if(preorder[left] != postorder[right]) { node-&gt;left = new TreeNode(preorder[left]); node-&gt;right = new TreeNode(postorder[right]); insertNode(node-&gt;left, left, pre_index[postorder[right]], pre_index, post_index, preorder, postorder); insertNode(node-&gt;right, pre_index[postorder[right]], r, pre_index, post_index, preorder, postorder); } else { node-&gt;left = new TreeNode(preorder[left]); insertNode(node-&gt;left, left, r, pre_index, post_index, preorder, postorder); } } }public: TreeNode* constructFromPrePost(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; postorder) { len = preorder.size(); TreeNode *root = new TreeNode(preorder[0]); vector&lt;int&gt; pre_index(len+1), post_index(len+1); for(int i = 0; i &lt; len; i++) { pre_index[preorder[i]] = i; post_index[postorder[i]] = i; } insertNode(root, 0, len, pre_index, post_index, preorder, postorder); return root; }}; 递归反而更快了 106. 从中序与后序遍历序列构造二叉树123456789101112131415161718192021class Solution { TreeNode* addNode(int left, int right, vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int &amp;index, unordered_map&lt;int, int&gt;&amp; in_index) { if(left &gt;= right || index &lt; 0) return nullptr; int val = postorder[index]; TreeNode *node = new TreeNode(val); index--; node-&gt;right = addNode(in_index[val]+1, right, inorder, postorder, index, in_index); node-&gt;left = addNode(left, in_index[val], inorder, postorder, index, in_index); return node; }public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) { int len = inorder.size(); unordered_map&lt;int, int&gt; in_index; for(int i = 0; i &lt; len; i++) { in_index[inorder[i]] = i; } int index = len - 1; return addNode(0, len, inorder, postorder, index, in_index); }}; 105. 从前序与中序遍历序列构造二叉树12345678910111213141516171819202122class Solution { int len; TreeNode* addNode(int left, int right, vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int &amp;index, unordered_map&lt;int, int&gt;&amp; in_index) { if(left &gt;= right || index &gt;= len) return nullptr; int val = preorder[index]; TreeNode *node = new TreeNode(val); index++; node-&gt;left = addNode(left, in_index[val], preorder, inorder, index, in_index); node-&gt;right = addNode(in_index[val]+1, right, preorder, inorder, index, in_index); return node; }public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) { len = inorder.size(); unordered_map&lt;int, int&gt; in_index; for(int i = 0; i &lt; len; i++) { in_index[inorder[i]] = i; } int index = 0; return addNode(0, len, preorder, inorder, index, in_index); }}; 590. N 叉树的后序遍历12345678910111213141516171819202122232425262728293031323334/*// Definition for a Node.class Node {public: int val; vector&lt;Node*&gt; children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector&lt;Node*&gt; _children) { val = _val; children = _children; }};*/class Solution { vector&lt;int&gt; res; void run_postorder(Node *root) { for(Node *child : root-&gt;children) { run_postorder(child); } res.push_back(root-&gt;val); }public: vector&lt;int&gt; postorder(Node* root) { if(root) run_postorder(root); return res; }}; 589. N 叉树的前序遍历1234567891011121314class Solution { vector&lt;int&gt; res; void run_preorder(Node *root) { res.push_back(root-&gt;val); for(Node *child : root-&gt;children) { run_preorder(child); } }public: vector&lt;int&gt; preorder(Node* root) { if(root) run_preorder(root); return res; }}; 429. N 叉树的层序遍历123456789101112131415161718192021222324252627282930313233343536373839404142/*// Definition for a Node.class Node {public: int val; vector&lt;Node*&gt; children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector&lt;Node*&gt; _children) { val = _val; children = _children; }};*/class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) { vector&lt;vector&lt;int&gt;&gt; res; queue&lt;Node*&gt; q; if(root) q.push(root); while(!q.empty()) { vector&lt;int&gt; level; int q_size = q.size(); while(q_size--) { Node *node = q.front(); q.pop(); level.push_back(node-&gt;val); for(Node *child : node-&gt;children) { q.push(child); } } res.push_back(level); } return res; }}; 103. 二叉树的锯齿形层序遍历12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) { bool rev = false; vector&lt;vector&lt;int&gt;&gt; res; queue&lt;TreeNode*&gt; q; if(root) q.push(root); while(!q.empty()) { vector&lt;int&gt; level; int q_size = q.size(); while(q_size--) { TreeNode *node = q.front(); q.pop(); level.push_back(node-&gt;val); if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); } if(rev) { reverse(level.begin(), level.end()); } res.push_back(level); rev = !rev; } return res; }}; 123456789101112131415161718192021222324class Solution {public: vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) { bool rev = false; vector&lt;vector&lt;int&gt;&gt; res; queue&lt;TreeNode*&gt; q; if(root) q.push(root); while(!q.empty()) { int q_size = q.size(); int index = q_size; vector&lt;int&gt; level(q_size); while(index--) { TreeNode *node = q.front(); q.pop(); level[(rev ? index : q_size - index - 1)] = node-&gt;val; if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); } res.push_back(level); rev = !rev; } return res; }}; 107. 二叉树的层序遍历 II123456789101112131415161718192021222324252627282930class Solution { int depth(TreeNode *root) { return ( root == nullptr ? 0 : 1 + max(depth(root-&gt;left), depth(root-&gt;right)) ); }public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) { int dep = depth(root); vector&lt;vector&lt;int&gt;&gt; res(dep); queue&lt;TreeNode*&gt; q; if(root) q.push(root); while(!q.empty()) { int q_size = q.size(); int index = q_size; vector&lt;int&gt; level(q_size); while(index--) { TreeNode *node = q.front(); q.pop(); level[q_size - index - 1] = node-&gt;val; if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); } res[--dep] = level; } return res; }}; 102. 二叉树的层序遍历12345678910111213141516171819202122class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; res; queue&lt;TreeNode*&gt; q; if(root) q.push(root); while(!q.empty()) { int q_size = q.size(); int index = q_size; res.push_back(vector&lt;int&gt;(q_size)); vector&lt;int&gt; &amp;level = res.back(); while(index--) { TreeNode *node = q.front(); q.pop(); level[q_size - index - 1] = node-&gt;val; if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); } } return res; }}; 987. 二叉树的垂序遍历 题目的要求很繁琐，需要输出二维数组，y坐标相同的节点放在同一数组内 且需要高层的放在底层的后面，同层的小值位于大值前面 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution { int cnt_range(TreeNode *root, int cur, int&amp; left_min, int&amp; right_max) { if(!root) return 0; int ldep = 0, rdep = 0; if(root-&gt;left) { left_min = min(left_min, cur - 1); ldep = cnt_range(root-&gt;left, cur-1, left_min, right_max); } if(root-&gt;right) { right_max = max(right_max, cur + 1); rdep = cnt_range(root-&gt;right, cur+1, left_min, right_max); } return 1 + max(ldep, rdep); }public: vector&lt;vector&lt;int&gt;&gt; verticalTraversal(TreeNode* root) { int left_min = 0, right_max = 0; int depth = cnt_range(root, 0, left_min, right_max); vector&lt;vector&lt;int&gt;&gt; ans(right_max - left_min + 1); vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; level_ans(right_max - left_min + 1, vector&lt;vector&lt;int&gt;&gt;(depth)); queue&lt;pair&lt;TreeNode*, int&gt;&gt; q; if(root) q.emplace(root, 0); int dep = 0; while(!q.empty()) { int q_size = q.size(); while(q_size--) { auto [node, y] = q.front(); q.pop(); level_ans[y-left_min][dep].push_back(node-&gt;val); if(node-&gt;left) q.emplace(node-&gt;left, y-1); if(node-&gt;right) q.emplace(node-&gt;right, y+1); } dep++; } for(int i = 0; i &lt; right_max - left_min + 1; i++) { for(int j = 0; j &lt; depth; j++) { sort(level_ans[i][j].begin(), level_ans[i][j].end()); for(int node : level_ans[i][j]) { ans[i].push_back(node); } } } return ans; }}; 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { int cnt_range(TreeNode *root, int cur, int&amp; left_min, int&amp; right_max) { if(!root) return 0; int ldep = 0, rdep = 0; if(root-&gt;left) { left_min = min(left_min, cur - 1); ldep = cnt_range(root-&gt;left, cur-1, left_min, right_max); } if(root-&gt;right) { right_max = max(right_max, cur + 1); rdep = cnt_range(root-&gt;right, cur+1, left_min, right_max); } return 1 + max(ldep, rdep); }public: vector&lt;vector&lt;int&gt;&gt; verticalTraversal(TreeNode* root) { int left_min = 0, right_max = 0; int depth = cnt_range(root, 0, left_min, right_max); vector&lt;vector&lt;int&gt;&gt; ans(right_max - left_min + 1); vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; level_ans(right_max - left_min + 1); queue&lt;pair&lt;TreeNode*, int&gt;&gt; q; if(root) q.emplace(root, 0); int dep = 0; while(!q.empty()) { int q_size = q.size(); while(q_size--) { auto [node, y] = q.front(); q.pop(); level_ans[y-left_min].emplace_back(dep, node-&gt;val); if(node-&gt;left) q.emplace(node-&gt;left, y-1); if(node-&gt;right) q.emplace(node-&gt;right, y+1); } dep++; } for(int i = 0; i &lt; right_max - left_min + 1; i++) { sort(level_ans[i].begin(), level_ans[i].end()); for(auto [_, node] : level_ans[i]) { ans[i].push_back(node); } } return ans; }}; 145. 二叉树的后序遍历递归1234567891011121314class Solution { void postorder(TreeNode *root, vector&lt;int&gt; &amp;vec) { if(!root) return; postorder(root-&gt;left, vec); postorder(root-&gt;right, vec); vec.push_back(root-&gt;val); }public: vector&lt;int&gt; postorderTraversal(TreeNode* root) { vector&lt;int&gt; res; postorder(root, res); return res; }}; 非递归 在中序遍历的基础上改造 对于当前节点，持续向左走压栈，直到无法往左走 此时栈顶节点的左子树访问结束，输出栈顶元素 若右子树为空，则栈顶元素的右子树访问完成，可以将该元素弹出栈 若右子树不为空，考虑该右子树是否是刚才访问过的，通过prev记录上一个输出的节点 若prev于当前元素的right相同，则当前节点已经访问过右子树，输出当前节点 若prev于当前元素的right不同，则当前节点变成右子树 此时栈顶元素的左子树节点访问结束，即重复第二步123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; postorderTraversal(TreeNode* root) { vector&lt;int&gt; res; stack&lt;TreeNode *&gt; s; TreeNode *cur = root, *prev = nullptr; while(!s.empty() || cur) { while(cur) { s.push(cur); cur = cur-&gt;left; } cur = s.top(); if(cur-&gt;right &amp;&amp; cur-&gt;right != prev) { cur = cur-&gt;right; } else { prev = cur; s.pop(); res.push_back(cur-&gt;val); cur = nullptr; } } return res; }}; 144. 二叉树的前序遍历递归1234567891011121314class Solution { void preorder(TreeNode *root, vector&lt;int&gt;&amp; ans) { if(!root) return; ans.push_back(root-&gt;val); preorder(root-&gt;left, ans); preorder(root-&gt;right, ans); }public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; ans; preorder(root, ans); return ans; }}; 非递归12345678910111213141516class Solution {public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; ans; stack&lt;TreeNode*&gt; s; if(root) s.push(root); while(!s.empty()) { TreeNode *node = s.top(); s.pop(); ans.push_back(node-&gt;val); if(node-&gt;right) s.push(node-&gt;right); if(node-&gt;left) s.push(node-&gt;left); } return ans; }}; 94. 二叉树的中序遍历递归1234567891011121314class Solution { void inorder(TreeNode *root, vector&lt;int&gt;&amp; ans) { if(!root) return; inorder(root-&gt;left, ans); ans.push_back(root-&gt;val); inorder(root-&gt;right, ans); }public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; ans; inorder(root, ans); return ans; }}; 非递归 对于当前节点，持续向左走压栈，直到无法往左走 此时栈顶节点的左子树访问结束 将右子树变成当前元素，若右子树为空，则栈顶元素的右子树访问完成，可以将该元素弹出栈 此时栈顶元素的左子树节点访问结束，即重复第二步 12345678910111213141516171819class Solution {public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; ans; stack&lt;TreeNode *&gt; s; TreeNode *cur = root; while(!s.empty() || cur) { while(cur) { s.push(cur); cur = cur-&gt;left; } cur = s.top(); s.pop(); ans.push_back(cur-&gt;val); cur = cur-&gt;right; } return ans; }}; 236. 二叉树的最近公共祖先ac12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { stack&lt;TreeNode*&gt; findTreeNode(TreeNode *root, TreeNode *target) { stack&lt;TreeNode *&gt; s; TreeNode *cur = root, *prev = nullptr; while(!s.empty() || cur) { while(cur) { s.push(cur); cur = cur-&gt;left; } cur = s.top(); if(cur-&gt;right &amp;&amp; prev != cur-&gt;right) { cur = cur-&gt;right; } else { prev = cur; if(cur == target) break; s.pop(); cur = nullptr; } } stack&lt;TreeNode *&gt; ans; while(!s.empty()) { ans.push(s.top()); s.pop(); } return ans; }public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { stack&lt;TreeNode *&gt; pstack = findTreeNode(root, p); stack&lt;TreeNode *&gt; qstack = findTreeNode(root, q); TreeNode *ans = nullptr; while(!pstack.empty() &amp;&amp; !qstack.empty()) { if(pstack.top() == qstack.top()) { ans = pstack.top(); pstack.pop(); qstack.pop(); } else { break; } } return ans; }}; 后序遍历时，如果找到目标节点，那么当前栈就是所有祖先 对比两个栈，找到最近的祖先 优化 减少一次遍历123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution { stack&lt;TreeNode*&gt; rev(stack&lt;TreeNode*&gt; s) { stack&lt;TreeNode*&gt; ans; while(!s.empty()) { ans.push(s.top()); s.pop(); } return ans; } void findTreeNode(TreeNode *root, TreeNode *p, TreeNode *q, stack&lt;TreeNode*&gt;&amp; pstack, stack&lt;TreeNode*&gt;&amp; qstack) { stack&lt;TreeNode *&gt; s; TreeNode *cur = root, *prev = nullptr; bool findp = false, findq = false; while(!s.empty() || cur) { while(cur) { s.push(cur); cur = cur-&gt;left; } cur = s.top(); if(cur-&gt;right &amp;&amp; prev != cur-&gt;right) { cur = cur-&gt;right; } else { prev = cur; if(cur == p) { pstack = rev(s); findp = true; } if(cur == q) { qstack = rev(s); findq = true; } if(findp &amp;&amp; findq) break; s.pop(); cur = nullptr; } } }public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { stack&lt;TreeNode *&gt; pstack, qstack; findTreeNode(root, p, q, pstack, qstack); TreeNode *ans = nullptr; while(!pstack.empty() &amp;&amp; !qstack.empty()) { if(pstack.top() == qstack.top()) { ans = pstack.top(); pstack.pop(); qstack.pop(); } else { break; } } return ans; }}; 继续优化非递归 参考的代码是递归的，我改成非递归的 123456789101112131415161718192021222324252627282930313233343536373839class Solution { TreeNode *ans = nullptr;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { stack&lt;tuple&lt;TreeNode *, bool, bool&gt;&gt; s; TreeNode *cur = root, *prev = nullptr; while(!s.empty() || cur) { while(cur) { s.emplace(cur, false, false); cur = cur-&gt;left; } auto [node, findp, findq] = s.top(); cur = node; // 这里多创建一个node if(cur-&gt;right &amp;&amp; prev != cur-&gt;right) { cur = cur-&gt;right; } else { if(cur == p) { findp = true; } if(cur == q) { findq = true; } if(findp &amp;&amp; findq &amp;&amp; ans == nullptr) { ans = cur; break; } s.pop(); if(!s.empty() &amp;&amp; (findp || findq)) { auto &amp;[_, last_findp, last_findq] = s.top(); last_findp = last_findp || findp; last_findq = last_findq || findq; } prev = cur; cur = nullptr; } } return ans; }}; 不用引用会快一点 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution { TreeNode *ans = nullptr;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { stack&lt;tuple&lt;TreeNode *, bool, bool&gt;&gt; s; TreeNode *cur = root, *prev = nullptr; while(!s.empty() || cur) { while(cur) { s.emplace(cur, false, false); cur = cur-&gt;left; } auto [node, findp, findq] = s.top(); cur = node; if(cur-&gt;right &amp;&amp; prev != cur-&gt;right) { cur = cur-&gt;right; } else { if(cur == p) { findp = true; } if(cur == q) { findq = true; } if(findp &amp;&amp; findq &amp;&amp; ans == nullptr) { ans = cur; break; } s.pop(); if(!s.empty() &amp;&amp; (findp || findq)) { auto [last, last_findp, last_findq] = s.top(); s.pop(); last_findp = last_findp || findp; last_findq = last_findq || findq; s.emplace(last, last_findp, last_findq); } prev = cur; cur = nullptr; } } return ans; }}; 递归123456789101112131415161718192021222324252627282930313233class Solution { TreeNode *ans = nullptr; void dfs(TreeNode *cur, TreeNode *p, TreeNode *q, bool&amp; last_findp, bool &amp;last_findq) { bool findp = false, findq = false; if(cur == p) { findp = true; } if(cur == q) { findq = true; } if(cur-&gt;left) { dfs(cur-&gt;left, p, q, last_findp, last_findq); findp = last_findp || findp; findq = last_findq || findq; } if(cur-&gt;right) { dfs(cur-&gt;right, p, q, last_findp, last_findq); findp = last_findp || findp; findq = last_findq || findq; } last_findp = findp; last_findq = findq; if(findp &amp;&amp; findq &amp;&amp; ans == nullptr) { ans = cur; } }public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { bool findp = false, findq = false; dfs(root, p, q, findp, findq); return ans; }}; 避免stl会快 993. 二叉树的堂兄弟节点非递归12345678910111213141516171819202122232425262728293031323334353637class Solution {public: bool isCousins(TreeNode* root, int x, int y) { TreeNode *xFather = nullptr, *yFather = nullptr; int xDepth = 0, yDepth = 0; bool findX = false, findY = false; TreeNode* s[101] = {nullptr}; int stack_ptr = 0; TreeNode *cur = root, *prev = nullptr; while(!(stack_ptr==0) || cur) { while(cur) { s[stack_ptr++] = cur; cur = cur-&gt;left; } cur = s[stack_ptr-1]; if(cur-&gt;right &amp;&amp; cur-&gt;right != prev) { cur = cur-&gt;right; } else { if(cur-&gt;val == x) { xFather = stack_ptr-2 &gt;= 0 ? s[stack_ptr-2] : nullptr;; xDepth = stack_ptr; findX = true; } if(cur-&gt;val == y) { yFather = stack_ptr-2 &gt;= 0 ? s[stack_ptr-2] : nullptr;; yDepth = stack_ptr; findY = true; } if(findX &amp;&amp; findY) break; stack_ptr--; prev = cur; cur = nullptr; } } return xFather &amp;&amp; yFather &amp;&amp; xFather != yFather &amp;&amp; xDepth == yDepth; }}; 递归12345678910111213141516171819202122class Solution { int xDepth = 0, yDepth = 0; TreeNode *xFather = nullptr, *yFather = nullptr; void postorder(TreeNode *root, TreeNode *parent, int x, int y, int dep) { if(!root) return; postorder(root-&gt;left, root, x, y, dep+1); postorder(root-&gt;right, root, x, y, dep+1); if(root-&gt;val == x) { xDepth = dep; xFather = parent; } if(root-&gt;val == y) { yDepth = dep; yFather = parent; } }public: bool isCousins(TreeNode* root, int x, int y) { postorder(root, nullptr, x, y, 0); return xFather &amp;&amp; yFather &amp;&amp; xFather != yFather &amp;&amp; xDepth == yDepth; }}; leetcode真奇怪，递归算法反而会更快 2641. 二叉树的堂兄弟节点 IIac12345678910111213141516171819202122232425262728293031class Solution {public: TreeNode* replaceValueInTree(TreeNode* root) { if(!root) return nullptr; queue&lt;pair&lt;TreeNode*, TreeNode*&gt;&gt; q; q.emplace(root, nullptr); while(!q.empty()) { vector&lt;pair&lt;TreeNode *, TreeNode *&gt;&gt; level; int q_size = q.size(), level_sum = 0; int q_size_cnt = q_size; while(q_size_cnt--) { auto [node, p] = q.front(); q.pop(); level_sum += node-&gt;val; level.emplace_back(node, p); if(node-&gt;left) q.emplace(node-&gt;left, node); if(node-&gt;right) q.emplace(node-&gt;right, node); } for(int i = 0; i &lt; q_size;) { if(i + 1 &lt; q_size &amp;&amp; level[i].second == level[i+1].second) { level[i].first-&gt;val = level[i+1].first-&gt;val = level_sum - level[i].first-&gt;val - level[i+1].first-&gt;val; i += 2; } else { level[i].first-&gt;val = level_sum - level[i].first-&gt;val; i += 1; } } } return root; }}; 优化 层次遍历 计算子节点（下一层节点）的和 父节点对子节点修改，改为两兄弟之和 获得当前层的和（prev_level_sum），将当前节点值(node-&gt;val)改为prev_level_sum - node-&gt;val 1234567891011121314151617181920212223242526272829303132class Solution {public: TreeNode* replaceValueInTree(TreeNode* root) { if(!root) return nullptr; queue&lt;TreeNode*&gt; q; q.push(root); int prev_level_sum = root-&gt;val; int q_size = 1; while(q_size &gt; 0) { int level_sum = 0; while(q_size--) { auto node = q.front(); q.pop(); if(node-&gt;left) { q.push(node-&gt;left); level_sum += node-&gt;left-&gt;val; } if(node-&gt;right) { q.push(node-&gt;right); level_sum += node-&gt;right-&gt;val; } if(node-&gt;left &amp;&amp; node-&gt;right) { node-&gt;left-&gt;val = node-&gt;right-&gt;val = node-&gt;left-&gt;val + node-&gt;right-&gt;val; } node-&gt;val = prev_level_sum - node-&gt;val; } prev_level_sum = level_sum; q_size = q.size(); } return root; }};","link":"/home/2023/12/25/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9331/"},{"title":"LeetCode-35","text":"518. 零钱兑换 II1234567891011121314class Solution {public: int change(int amount, vector&lt;int&gt;&amp; coins) { int n = coins.size(); vector&lt;int&gt; dp(amount+1); dp[0] = 1; for(int i = 1; i &lt;= n; i++) { for(int j = coins[i-1]; j &lt;= amount; j++) { dp[j] += dp[j-coins[i-1]]; } } return dp[amount]; }}; 322. 零钱兑换123456789101112131415class Solution {public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { int n = coins.size(); vector&lt;int&gt; dp(amount + 1, INT_MAX); dp[0] = 0; for(int i = 1; i &lt;= n; i++) { for(int j = coins[i-1]; j &lt;= amount; j++) { if(dp[j - coins[i-1]] != INT_MAX) dp[j] = min(dp[j], dp[j - coins[i-1]] + 1); } } return dp[amount] == INT_MAX ? -1 : dp[amount]; }}; 25. K 个一组翻转链表 啊？真的是困难吗 12345678910111213141516171819202122232425262728293031class Solution { int listLen(ListNode *head) { int n = 0; while(head) { n++; head = head-&gt;next; } return n; }public: ListNode* reverseKGroup(ListNode* head, int k) { ListNode dummy, *move = &amp;dummy, *next = head; int n = listLen(head); for(int j = 0; j + k &lt;= n; j+=k) { next = head; for(int i = 0; i &lt; k; i++) { ListNode *tmp = head; head = head-&gt;next; tmp-&gt;next = move-&gt;next; move-&gt;next = tmp; } move = next; } while(head) { move-&gt;next = head; move = head; head = head-&gt;next; } return dummy.next; }}; 2642. 设计可以求最短路径的图类1234567891011121314151617181920212223242526272829303132333435363738class Graph { int n; vector&lt;vector&lt;int&gt;&gt; dist;public: Graph(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) : n(n), dist(n, vector&lt;int&gt;(n, INT_MAX &gt;&gt; 1)) { for(auto&amp; edge : edges) { dist[edge[0]][edge[1]] = edge[2]; } for(int w = 0; w &lt; n; w++) { dist[w][w] = 0; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { dist[i][j] = min(dist[i][j], dist[i][w] + dist[w][j]); } } } } void addEdge(vector&lt;int&gt; edge) { if(dist[edge[0]][edge[1]] &lt;= edge[2]) return; dist[edge[0]][edge[1]] = edge[2]; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { dist[i][j] = min(dist[i][j], dist[i][edge[0]] + dist[edge[0]][j]); } } for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { dist[i][j] = min(dist[i][j], dist[i][edge[1]] + dist[edge[1]][j]); } } } int shortestPath(int node1, int node2) { return dist[node1][node2] == (INT_MAX &gt;&gt; 1) ? -1 : dist[node1][node2]; }}; 用边更新 12345678910111213141516171819202122232425262728293031323334353637383940class Graph { int n; vector&lt;vector&lt;int&gt;&gt; dist;public: Graph(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) : n(n), dist(n, vector&lt;int&gt;(n, INT_MAX &gt;&gt; 2)) { for(auto&amp; edge : edges) { dist[edge[0]][edge[1]] = edge[2]; } for(int w = 0; w &lt; n; w++) { dist[w][w] = 0; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { dist[i][j] = min(dist[i][j], dist[i][w] + dist[w][j]); } } } } void addEdge(vector&lt;int&gt; edge) { if(dist[edge[0]][edge[1]] &lt;= edge[2]) return; dist[edge[0]][edge[1]] = edge[2]; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { dist[i][j] = min(dist[i][j], dist[i][edge[0]] + dist[edge[1]][j] + edge[2]); } } } int shortestPath(int node1, int node2) { return dist[node1][node2] == (INT_MAX &gt;&gt; 2) ? -1 : dist[node1][node2]; }};/** * Your Graph object will be instantiated and called as such: * Graph* obj = new Graph(n, edges); * obj-&gt;addEdge(edge); * int param_2 = obj-&gt;shortestPath(node1,node2); */ 最快的还是每次求最短路时dijkstra现算 93. 复原 IP 地址 用dots数组表示在字符串位置i后面加点.，加入四个点后，且第四个点在最好一个字符后面，就是合法的 如果遇到0，只能在其后加一个点，不考虑有前导0 1234567891011121314151617181920212223242526272829303132333435class Solution {public: vector&lt;string&gt; restoreIpAddresses(string s) { vector&lt;string&gt; ans; int dots[4] = {-1}; int len = s.length(); function&lt;void(int, int)&gt; dfs = [&amp;](int i, int n) { if(n == 4) { if(dots[3] == len - 1) ans.push_back( s.substr(0, dots[0] + 1) + &quot;.&quot; + s.substr(dots[0] + 1, dots[1] - dots[0]) + &quot;.&quot; + s.substr(dots[1] + 1, dots[2] - dots[1]) + &quot;.&quot; + s.substr(dots[2] + 1, len - dots[2] - 1)); return; } if(s[i] == '0') { dots[n] = i; dfs(i+1, n+1); return; } int x = 0; for(int j = i; j &lt; len; j++) { x *= 10; x += s[j] - '0'; if(s[j] &gt; '9' || s[j] &lt; '0') break; if(x &gt; 255 || x &lt; 0) break; dots[n] = j; dfs(j+1, n+1); } }; dfs(0, 0); return ans; }}; 96. 不同的二叉搜索树 假设i为当前根节点，将数组分成两部分，一部分是左子树，一部分是右子树子树重复上面的操作再加上记忆优化 123456789101112131415161718class Solution { vector&lt;vector&lt;int&gt;&gt; mem; int numTrees(int l, int r) { if(mem[l][r] != -1) return mem[l][r]; if(l &gt;= r) return 1; int ans = 0; for(int i = l; i &lt; r; i++) { ans += numTrees(l, i) * numTrees(i+1, r); } mem[l][r] = ans; return ans; }public: int numTrees(int n) { mem = vector&lt;vector&lt;int&gt;&gt;(n+1, vector&lt;int&gt;(n+1, -1)); return numTrees(0, n); }}; 95. 不同的二叉搜索树 II 返回值返回所有可能的树的情况 1234567891011121314151617181920class Solution { vector&lt;TreeNode*&gt; findAllBST(int l, int r) { if(l &gt;= r) return { nullptr }; vector&lt;TreeNode*&gt; trees; for(int i = l; i &lt; r; i++) { vector&lt;TreeNode*&gt; leftTree = findAllBST(l, i); vector&lt;TreeNode*&gt; rightTree = findAllBST(i+1, r); for(TreeNode *left : leftTree) { for(TreeNode *right : rightTree) { trees.push_back(new TreeNode(i, left, right)); } } } return trees; }public: vector&lt;TreeNode*&gt; generateTrees(int n) { return findAllBST(1, n + 1); }}; 97. 交错字符串 dp123456789101112131415161718192021class Solution {public: bool isInterleave(string s1, string s2, string s3) { int n1 = s1.length(), n2 = s2.length(); if(s3.length() != n1 + n2) return false; vector&lt;vector&lt;bool&gt;&gt; dp(n1+1, vector&lt;bool&gt;(n2+1, false)); dp[0][0] = true; for(int i = 1; i &lt;= n1; i++) { dp[i][0] = dp[i-1][0] &amp;&amp; s1[i-1] == s3[i-1]; } for(int i = 1; i &lt;= n2; i++) { dp[0][i] = dp[0][i-1] &amp;&amp; s2[i-1] == s3[i-1]; } for(int i = 1; i &lt;= n1; i++) { for(int j = 1; j &lt;= n2; j++) { dp[i][j] = dp[i][j] || (s1[i-1] == s3[i + j - 1] &amp;&amp; dp[i-1][j]) || (s2[j-1] == s3[i + j - 1] &amp;&amp; dp[i][j-1]); } } return dp[n1][n2]; }}; 98. 验证二叉搜索树1234567891011class Solution { bool isValidBST(TreeNode* root, long long l, long long r) { if(!root) return true; if(root-&gt;val &lt;= l || root-&gt;val &gt;= r) return false; return isValidBST(root-&gt;left, l, root-&gt;val) &amp;&amp; isValidBST(root-&gt;right, root-&gt;val, r); }public: bool isValidBST(TreeNode* root) { return isValidBST(root, LLONG_MIN, LLONG_MAX); }}; 99. 恢复二叉搜索树123456789101112131415161718192021222324252627class Solution { vector&lt;TreeNode*&gt; arr; void midOrder(TreeNode *root) { if(!root) return; midOrder(root-&gt;left); arr.push_back(root); midOrder(root-&gt;right); }public: void recoverTree(TreeNode* root) { midOrder(root); int n = arr.size(); int x = 0; for(int i = 0; i &lt; n - 1; i++) { if(arr[i]-&gt;val &gt; arr[i+1]-&gt;val) { x = i; break; } } for(int i = n-1; i &gt; 0; i--) { if(arr[i]-&gt;val &lt; arr[i-1]-&gt;val) { swap(arr[i]-&gt;val, arr[x]-&gt;val); break; } } }}; O(1)空间 12345678910111213141516171819202122232425class Solution { TreeNode* prev = nullptr; TreeNode* node1 = nullptr; TreeNode* node2 = nullptr; void midOrder(TreeNode *root) { if(!root) return; midOrder(root-&gt;left); if(prev &amp;&amp; root-&gt;val &lt; prev-&gt;val) { if(node1 == nullptr &amp;&amp; node2 == nullptr) { node1 = prev; node2 = root; } else { node2 = root; return; } } prev = root; midOrder(root-&gt;right); }public: void recoverTree(TreeNode* root) { midOrder(root); swap(node1-&gt;val, node2-&gt;val); }}; 51. N 皇后 递归，用四个数组表示当前行列主对角线上是否有皇后 挑选四个方向都没有皇后的格子放置皇后 12345678910111213141516171819202122232425class Solution {public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) { vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; cur(n, string(n, '.')); vector&lt;bool&gt; col(n, false), row(n, false), main_diag((n &lt;&lt; 1) - 1, false), sub_diag((n &lt;&lt; 1) - 1, false); function&lt;void(int)&gt; dfs = [&amp;](int i) { if(i == n) { res.push_back(cur); return; } for(int j = 0; j &lt; n; j++) { if(!row[i] &amp;&amp; !col[j] &amp;&amp; !main_diag[i - j + n - 1] &amp;&amp; !sub_diag[i + j]) { cur[i][j] = 'Q'; row[i] = col[j] = main_diag[i - j + n - 1] = sub_diag[i + j] = true; dfs(i+1); row[i] = col[j] = main_diag[i - j + n - 1] = sub_diag[i + j] = false; cur[i][j] = '.'; } } }; dfs(0); return res; }}; 52. N 皇后 II123456789101112131415161718192021222324class Solution { int const static constexpr MAX_N = 10; int const static constexpr MAX_DIAG = (MAX_N &lt;&lt; 1) - 1;public: int totalNQueens(int n) { int res = 0; bool col[MAX_N] = {false}, row[MAX_N] = {false}, main_diag[MAX_DIAG] = {false}, sub_diag[MAX_DIAG] = {false}; function&lt;void(int)&gt; dfs = [&amp;](int i) { if(i == n) { res++; return; } for(int j = 0; j &lt; n; j++) { if(!row[i] &amp;&amp; !col[j] &amp;&amp; !main_diag[i - j + n - 1] &amp;&amp; !sub_diag[i + j]) { row[i] = col[j] = main_diag[i - j + n - 1] = sub_diag[i + j] = true; dfs(i+1); row[i] = col[j] = main_diag[i - j + n - 1] = sub_diag[i + j] = false; } } }; dfs(0); return res; }}; 2580. 统计将重叠区间合并成组的方案数 要求将区间分成两组，且相互重叠的区间在同一组 数一下按照是否重叠区分，一共能分成多少组 然后就是对这些组排列组合 对区间排序，若重叠则不断扩大当前分组范围，否则遇到新的不与之前重叠的区间 12345678910111213141516171819202122232425262728293031323334353637class Solution { const static int MOD = 1000000000 + 7; int fastPow2(int n) { long long base = 2; long long ans = 1; while(n) { if(n &amp; 1) ans = (ans * base) % MOD; base = (base * base) % MOD; n &gt;&gt;= 1; } return ans; }public: int countWays(vector&lt;vector&lt;int&gt;&gt;&amp; ranges) { sort(ranges.begin(), ranges.end(), [](const vector&lt;int&gt;&amp; x, const vector&lt;int&gt;&amp; y) { if(x[0] != y[0]) return x[0] &lt; y[0]; return x[1] &lt; y[1]; }); int rangesCnt = 0; pair&lt;int, int&gt; curRange = make_pair(ranges[0][0], ranges[0][1]); for(const vector&lt;int&gt;&amp; v : ranges) { if(v[0] &gt;= curRange.first &amp;&amp; v[0] &lt;= curRange.second) { curRange.second = max(v[1], curRange.second); } else if(v[1] &gt;= curRange.first &amp;&amp; v[1] &lt;= curRange.second) { curRange.first = max(v[0], curRange.first); } else if(v[0] &gt;= curRange.first &amp;&amp; v[1] &lt;= curRange.second) { } else if (v[0] &lt;= curRange.first &amp;&amp; v[1] &gt;= curRange.second) { curRange.first = v[0]; curRange.second = v[1]; } else { rangesCnt++; curRange = make_pair(v[0], v[1]); } } return fastPow2(++rangesCnt); }}; 40. 组合总和 II39. 组合总和是每个数不限制使用次数，数字不重复，这道题是数字可能重复但是每个数只能用一次 用相同的方法暴搜，但是要加上个数上限 12345678910111213141516171819202122232425262728293031323334353637class Solution {public: int n; int target; vector&lt;vector&lt;int&gt;&gt; res; unordered_map&lt;int, int&gt; cnt; vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) { this-&gt;target = target; n = 0; for(int candidate : candidates) { cnt[candidate]++; } candidates = vector&lt;int&gt;(); for(auto ite : cnt) { candidates.push_back(ite.first); n++; } vector&lt;int&gt; vec; search(0, 0, vec, candidates); return res; } void search(int index, int sum, vector&lt;int&gt; &amp; vec, const vector&lt;int&gt;&amp; candidates) { if(sum == target) { res.push_back(vec); return; } if(index &gt;= n || sum &gt; target) return; vec.push_back(candidates[index]); cnt[candidates[index]]--; if(cnt[candidates[index]] &gt;= 0) search(index, sum+candidates[index], vec, candidates); cnt[candidates[index]]++; vec.pop_back(); if(index + 1 &lt; n) { search(index+1, sum, vec, candidates); } }};","link":"/home/2024/03/25/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9335/"},{"title":"LeetCode-34","text":"2789. 合并后数组中的最大元素1234567891011121314151617class Solution {public: long long maxArrayValue(vector&lt;int&gt;&amp; nums) { int n = nums.size(); long long ans = nums[n-1]; long long curSum = nums[n-1]; for(int i = n - 2; i &gt;= 0; i--) { if(nums[i] &lt;= curSum) { curSum += nums[i]; } else { curSum = nums[i]; } ans = max(ans, curSum); } return ans; }}; 2864. 最大二进制奇数 一次遍历原地算法 12345678910111213141516class Solution {public: string maximumOddBinaryNumber(string&amp; s) { int len = s.length(); int index = 0; for(int i = 0; i &lt; len; i++) { if(s[i] == '1') { s[i] = '0'; s[index++] = '1'; } } s[index-1] = '0'; s[len-1] = '1'; return s; }}; 1261. 在受污染的二叉树中查找元素不要额外存储，不用恢复节点值 用对应满二叉树的标号标记index 判断要查的树在第几层，将标号转为0,1,2,3,… 二进制位就是搜索方向，找到null就是不存在，找到节点就是存在 1234567891011121314151617181920212223242526272829303132333435363738394041424344class FindElements { TreeNode* root; // set&lt;int&gt; s; // void dfs(TreeNode * root) { // s.insert(root-&gt;val); // if(root-&gt;left) { // root-&gt;left-&gt;val = (root-&gt;val &lt;&lt; 1) + 1; // dfs(root-&gt;left); // } // if(root-&gt;right) { // root-&gt;right-&gt;val = (root-&gt;val &lt;&lt; 1) + 2; // dfs(root-&gt;right); // } // }public: FindElements(TreeNode* root) : root(root) { // if(!root) return; // root-&gt;val = 0; // dfs(root); } bool find(int target) { // return s.count(target) != 0; int mask = 1, x = target + 1; while(x) { x &gt;&gt;= 1; mask &lt;&lt;= 1; } mask &gt;&gt;= 1; TreeNode *node = root; int n = target - mask + 1; mask &gt;&gt;= 1; while(mask &amp;&amp; node) { if((mask &amp; n) != 0) { node = node-&gt;right; } else { node = node-&gt;left; } mask &gt;&gt;= 1; } if(node) cout &lt;&lt; node-&gt;val &lt;&lt; endl; return node != nullptr; }}; 2129. 将标题首字母大写123456789101112131415161718192021222324252627282930313233class Solution { bool isLowercase(char c) { return c &gt;= 'a' &amp;&amp; c &lt;= 'z'; } bool isUppercase(char c) { return c &gt;= 'A' &amp;&amp; c &lt;= 'Z'; } char toLowercase(char c) { return isUppercase(c) ? c - 'A' + 'a' : c; } char toUppercase(char c) { return isLowercase(c) ? c - 'a' + 'A' : c; }public: string capitalizeTitle(string title) { int len = title.length(); int i = 0; while(i &lt; len) { int start = i; while(i &lt; len &amp;&amp; title[i] != ' ') { title[i] = toLowercase(title[i]); i++; } if(i - start &gt; 2) { title[start] = toUppercase(title[start]); } while(i &lt; len &amp;&amp; title[i] == ' ') { i++; } } return title; }}; 310. 最小高度树123456789101112131415161718192021222324252627282930313233class Solution {public: vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) { if(n == 1) return {0}; vector&lt;int&gt; ans, deg(n); vector&lt;vector&lt;int&gt;&gt; g(n); for(auto &amp; edge : edges) { g[edge[0]].push_back(edge[1]); g[edge[1]].push_back(edge[0]); deg[edge[0]]++; deg[edge[1]]++; } queue&lt;int&gt; q; for(int i = 0; i &lt; n; i++) { if(deg[i] == 1) q.push(i); } while(!q.empty()) { int q_size = q.size(); ans.clear(); while(q_size--) { int node = q.front(); q.pop(); deg[node]--; for(int child : g[node]) { deg[child]--; if(deg[child] == 1) q.push(child); } ans.push_back(node); } } return ans; }}; 看了答案，拓扑排序，最后一批就是根 2684. 矩阵中移动的最大次数 暴力！暴力！ 记忆优化搜索 1234567891011121314151617181920212223242526272829class Solution { int ans = 0; int m, n; bool checkBounds(int i, int j) { return i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n; } vector&lt;vector&lt;int&gt;&gt; mem; int dfs(int i, int j, int len, vector&lt;vector&lt;int&gt;&gt;&amp; grid) { if(checkBounds(i-1, j+1) &amp;&amp; grid[i][j] &lt; grid[i-1][j+1]) { mem[i][j] = max(mem[i][j], 1 + (mem[i-1][j+1] == 0 ? (mem[i-1][j+1] = dfs(i-1, j+1, len+1, grid)) : mem[i-1][j+1])); } if(checkBounds(i+1, j+1) &amp;&amp; grid[i][j] &lt; grid[i+1][j+1]) { mem[i][j] = max(mem[i][j], 1 + (mem[i+1][j+1] == 0 ? (mem[i+1][j+1] = dfs(i+1, j+1, len+1, grid)) : mem[i+1][j+1])); } if(checkBounds(i, j+1) &amp;&amp; grid[i][j] &lt; grid[i][j+1]) { mem[i][j] = max(mem[i][j], 1 + (mem[i][j+1] == 0 ? (mem[i][j+1] = dfs(i, j+1, len+1, grid)) : mem[i][j+1])); } return mem[i][j]; }public: int maxMoves(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { m = grid.size(), n = grid[0].size(); mem = vector&lt;vector&lt;int&gt;&gt;(m, vector&lt;int&gt;(n)); for(int i = 0; i &lt; m; i++) { ans = max(ans, dfs(i, 0, 0, grid)); } return ans; }}; 303. 区域和检索 - 数组不可变1234567891011121314class NumArray { vector&lt;int&gt; prevSum;public: NumArray(vector&lt;int&gt;&amp; nums) : prevSum(nums) { int len = prevSum.size(); for(int i = 1; i &lt; len; i++) { prevSum[i] += prevSum[i-1]; } } int sumRange(int left, int right) { return left == 0 ? prevSum[right] : prevSum[right] - prevSum[left-1]; }}; 前前前前前坠河（缀和） 2671. 频率跟踪器 两个hash表 12345678910111213141516171819202122232425262728293031class FrequencyTracker { unordered_map&lt;int, int&gt; freq2num; unordered_map&lt;int, int&gt; num2freq;public: FrequencyTracker() { } void add(int number) { int oldFred = num2freq[number]; num2freq[number]++; if(oldFred &gt; 0) { freq2num[oldFred]--; } freq2num[oldFred+1]++; } void deleteOne(int number) { int oldFred = num2freq[number]; if(oldFred &gt; 0) { num2freq[number]--; freq2num[oldFred]--; if(oldFred &gt; 1) freq2num[oldFred-1]++; } } bool hasFrequency(int frequency) { return freq2num[frequency] != 0; }}; 1969. 数组元素的最小非零乘积 根据小学知识，若a+b=Constant，则abs(a-b)越大，a*b越小 对于两个互补的数，如10101和01010可以变成00001和11110，这样他们差距最大，乘积最小 00000和11111互补但是00000不考虑，最后还要成员它 只要计算有多少对互补数N，互补数的最小乘积A，答案等于A^N*(全1) 12345678910111213141516class Solution { const long long MOD = 1e9 + 7; long long pow(long long base, long long index) { long long ans = 1; while(index) { if(index &amp; 1) ans = (ans * base) % MOD; base = (base * base) % MOD; index &gt;&gt;= 1; } return ans; }public: int minNonZeroProduct(int p) { return (pow(((1LL &lt;&lt; p) - 2) % MOD, ((1LL &lt;&lt; (p - 1)) - 1)) * (((1LL &lt;&lt; p) - 1) % MOD)) % MOD; }}; 取模的时候要注意优先级*/%是同级的，要加括号 1793. 好子数组的最大分数 一眼单调栈1234567891011121314151617181920212223242526272829303132class Solution {public: int maximumScore(vector&lt;int&gt;&amp; nums, int k) { int len = nums.size(); vector&lt;int&gt; leftPos(len), rightPos(len); stack&lt;int&gt; monoStack; for(int i = 0; i &lt; len; i++) { leftPos[i] = i; int top = -1; while(!monoStack.empty() &amp;&amp; nums[monoStack.top()] &gt;= nums[i]) { top = monoStack.top(); monoStack.pop(); } if(top != -1) leftPos[i] = leftPos[top]; monoStack.push(i); } monoStack = stack&lt;int&gt;(); int ans = 0; for(int i = len - 1; i &gt;= 0; i--) { int top = -1; rightPos[i] = i; while(!monoStack.empty() &amp;&amp; nums[monoStack.top()] &gt;= nums[i]) { top = monoStack.top(); monoStack.pop(); } if(top != -1) rightPos[i] = rightPos[top]; if(rightPos[i] &gt;= k &amp;&amp; k &gt;= leftPos[i]) ans = max(ans, (rightPos[i] - leftPos[i] + 1) * nums[i]); monoStack.push(i); } return ans; }}; 蚂蚁2024年3月23日测评第二题 给一个数组，对其中一个数自增0-1次，数组乘积最最多有几个012345678910111213141516171819202122232425262728293031323334//// Created by jingtian on 2024/3/23.//#include &lt;bits/stdc++.h&gt;using namespace std;int cntOf(int n, int divisor) { int cnt = 0; while(n % divisor == 0) { cnt++; n /= divisor; } return cnt;}int main() { int n; while(cin &gt;&gt; n) { vector&lt;int&gt; arr(n); int cntOf2 = 0, cntOf5 = 0; for(int i = 0; i &lt; n; i++) { cin &gt;&gt; arr[i]; cntOf2 += cntOf(arr[i], 2); cntOf5 += cntOf(arr[i], 5); } int ans = min(cntOf2, cntOf5); for(int i = 0; i &lt; n; i++) { ans = max(ans, min(cntOf2 - cntOf(arr[i], 2) + cntOf(arr[i]+1, 2), cntOf5 - cntOf(arr[i], 5) + cntOf(arr[i]+1, 5))); } cout &lt;&lt; ans &lt;&lt; endl; } return 0;} 第三题 不知道AC没 给一颗数，每次将有公共点的两条边涂色，最多能涂色多少次，输出每次涂色的三个节点 贪心，对于倒数第二层的节点，两种情况 偶数个子节点 两两配对涂色 奇数个子节点 剩下一个和父节点涂色 其他层类似 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import java.io.ByteArrayOutputStream;import java.io.PrintStream;import java.util.*;public class Main { private final ByteArrayOutputStream bos = new ByteArrayOutputStream(); private final PrintStream output = new PrintStream(bos); private static class TreeNode { public List&lt;TreeNode&gt; child; private int tag; private final int val; public TreeNode(int val) { child = new ArrayList&lt;&gt;(); tag = 0; this.val = val; } public void addChild(TreeNode node) { child.add(node); } } private int ans = 0; private void postOrder(TreeNode node) { for(int i = 0; i &lt; node.child.size(); i++) { postOrder(node.child.get(i)); } int cntOK = 0; int last = -1; for(int i = 0; i &lt; node.child.size(); i++) { if(node.child.get(i).tag == 1) { cntOK++; output.printf(&quot;%d %d %d\\n&quot;, node.val+1, node.child.get(i).val+1, node.child.get(i).child.get(node.child.get(i).child.size()-1).val+1); ans++; } else { if(last == -1) { last = i; } else { output.printf(&quot;%d %d %d\\n&quot;, node.child.get(last).val + 1, node.val+1, node.child.get(i).val+1); last = -1; ans++; } } } int remain = node.child.size() - cntOK; node.tag = remain &amp; 1; } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while(scanner.hasNext()) { Main main = new Main(); int n = scanner.nextInt(); TreeNode[] treeNodes = new TreeNode[n]; boolean[] visited = new boolean[n]; Arrays.fill(visited, false); Map&lt;Integer, List&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; i++) { treeNodes[i] = new TreeNode(i); } for(int i = 0; i &lt; n - 1; i++) { int x, y; x = scanner.nextInt() - 1; y = scanner.nextInt() - 1; if(!graph.containsKey(x)) { graph.put(x, new ArrayList&lt;&gt;()); } if(!graph.containsKey(y)) { graph.put(y, new ArrayList&lt;&gt;()); } graph.get(x).add(y); graph.get(y).add(x); } Deque&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;(); queue.add(0); while (!queue.isEmpty()) { int node = queue.getFirst(); visited[node] = true; queue.removeFirst(); for(int child : graph.get(node)) { if(visited[child]) continue; treeNodes[node].addChild(treeNodes[child]); queue.addLast(child); } } main.postOrder(treeNodes[0]); System.out.println(main.ans); System.out.print(main.bos); } }} 2549. 统计桌面上的不同数字 记忆优化搜索 123456789101112131415161718class Solution { vector&lt;bool&gt; visited = vector&lt;bool&gt;(100+1); int ans = 1;public: int distinctIntegers(int n) { if(visited[n]) { return ans; } visited[n] = true; for(int i = n - 1; i &gt; 1; i--) { if(!visited[i] &amp;&amp; n % i == 1) { distinctIntegers(i); ans++; } } return ans; }};","link":"/home/2024/03/14/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9334/"},{"title":"LeetCode-33","text":"232. 用栈实现队列 两个栈倒腾一下可以得到队列 一个栈用来入队 一个栈用来出队，如果出队栈空，将另一个栈全倒腾过来，如果不空，就出栈一个元素 1234567891011121314151617181920212223242526272829303132333435363738class MyQueue { stack&lt;int&gt; inStk, outStk;public: MyQueue() { } void push(int x) { inStk.push(x); } int pop() { if(outStk.empty()) { while(!inStk.empty()) { outStk.push(inStk.top()); inStk.pop(); } } int top = outStk.top(); outStk.pop(); return top; } int peek() { if(outStk.empty()) { while(!inStk.empty()) { outStk.push(inStk.top()); inStk.pop(); } } int top = outStk.top(); return top; } bool empty() { return inStk.empty() &amp;&amp; outStk.empty(); }}; 1976. 到达目的地的方案数dijkstra 数据范围很大，枚举所有路径是不现实的 由于我们只要求两点之间的最短路，所以用dijkstra就好 应该是dp吧，每次选取最小路径的点更新邻接节点 若使其路径变小了，则到达该节点最短路径数等于根节点到达当前节点的最短路径数 若路径长度等于该节点，则到达该节点最短路径数在原来数量上加上根节点到达当前节点的最短路径数 1234567891011121314151617181920212223242526272829303132333435class Solution {public: int countPaths(int n, vector&lt;vector&lt;int&gt;&gt;&amp; roads) { vector&lt;bool&gt; visited(n, false); int ans = 0; vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; g(n); for(auto&amp; road : roads) { g[road[0]].emplace_back(road[1], road[2]); g[road[1]].emplace_back(road[0], road[2]); } vector&lt;long long&gt; minCostArr(n, 0x7fffffffffffffff); vector&lt;int&gt; costCnt(n, 0); minCostArr[0] = 0; costCnt[0] = 1; for(int i = 0; i &lt; n; i++) { int node = -1; for(int j = 0; j &lt; n; j++) { if(!visited[j] &amp;&amp; (node == -1 || minCostArr[j] &lt; minCostArr[node])) { node = j; } } if(node == -1) break; visited[node] = true; for(auto [child, childCost] : g[node]) { if(minCostArr[child] &gt; minCostArr[node] + childCost) { costCnt[child] = costCnt[node]; minCostArr[child] = minCostArr[node] + childCost; } else if (minCostArr[child] == minCostArr[node] + childCost) { costCnt[child] = (costCnt[node] + costCnt[child]) % 1000000007; } } } return costCnt[n-1]; }}; 2917. 找出数组中的 K-or 值12345678910111213class Solution { public int findKOr(int[] nums, int k) { int[] bitCnt = new int[32]; int ans = 0; for(int i = 0, mask = 1; i &lt; 32; i++, mask &lt;&lt;= 1) { for(int n : nums) { if((mask &amp; n) != 0)bitCnt[i]++; } if(bitCnt[i] &gt;= k) ans |= mask; } return ans; }} 2575. 找出字符串的可整除数组 题解 123456789101112131415class Solution {public: vector&lt;int&gt; divisibilityArray(string word, int m) { int len = word.length(); vector&lt;int&gt; res(len, 0); long long number = 0; for(int i = 0; i &lt; len; i++) { number = (number * 10 + word[i] - '0') % m; if(number == 0) { res[i] = 1; } } return res; }}; 299. 猜数字游戏123456789101112131415161718char* getHint(char* secret, char* guess) { int ACnt = 0, ABCnt = 0; int cntSecret[10] = {0}, cntGuess[10] = {0}; while(*secret) { if(*secret == *guess) ACnt++; cntSecret[*secret - '0']++; cntGuess[*guess - '0']++; secret++; guess++; } for(int i = 0; i &lt; 10; i++) { ABCnt += (cntSecret[i] &gt; cntGuess[i] ? cntGuess[i] : cntSecret[i]); } int len = snprintf(NULL, 0, &quot;%dA%dB&quot;, ACnt, ABCnt - ACnt) + 1; char *ret = malloc(sizeof(char) * (len)); snprintf(ret, len, &quot;%dA%dB&quot;, ACnt, ABCnt - ACnt); return ret;}","link":"/home/2024/03/04/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9333/"},{"title":"LeetCode-2","text":"20. 有效的括号思路 创建一个栈 遍历字符串 如果是左半部分，把这个字符压栈 如果是右半部分，先看一下栈顶元素和它是否配对，如果配对，弹栈，不配对，结束，返回false 字符串遍历结束后，看栈是否已经空了，如果没空，说明左右括号数量不对应false AC代码123456789101112131415161718192021222324static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: bool isValid(string s) { int p[128] = {0}; p['('] = ')'; p[')'] = 0; p['['] = ']'; p[']'] = 0; p['{'] = '}'; p['}'] = 0; stack&lt;char&gt; sta; for (int i = 0; i &lt; s.length(); i++) { if (p[s[i]]) { sta.push(s[i]); } else { if (sta.empty() || p[sta.top()] != s[i]) return false; sta.pop(); } } return sta.empty(); }}; 26. 删除排序数组中的重复项第一次AC代码1234567class Solution {public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { nums.erase(unique(nums.begin(), nums.end()), nums.end()); return nums.size(); }}; 我知道这样很不道德，所以 思路 双指针法 一个数用来遍历一遍数组，一个用来记录当前不重复的数的位置 每次循环把j指向的数赋值给i 当j指向的数与当前数不等的时候，i++，这样下一个不重复的数放到了它的后面 第二次AC代码12345678910111213class Solution {public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { if (!nums.size()) return 0; int i = 0; for (int j = 1; j &lt; nums.size(); j++) { if (nums[i] != nums[j]) i++; nums[i] = nums[j]; } return i + 1; }}; 27. 移除元素思路1类似上一题的双指针法i用于循环变量当i指向的值不是要删除的元素时，把i的值赋值给当前的j，j再自增每次循环，i自增 思路2把要删除的值移动到数组的末尾 一个n，记录数组的长度 遍历数组，每找到一个要删除的值，把它和n-1指向的元素赋值给它，数组长度n自减，这个时候指针不要移动，因为要判断刚才末尾的那个数是不是也是要删除的 思路3iterator遍历，调用vector的erase直接删 AC代码（从上到下依次是三个思路）1234567891011121314class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int j = 0; for (int i = 0; i &lt; nums.size(); i++) { if (nums[i] != val) { nums[j] = nums[i]; j++; } } return j; }}; 12345678910111213141516class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int n = nums.size(); int i = 0; while (i &lt; n) { if (nums[i] == val) { nums[i] = nums[n-1]; n--; } else { i++; } } return n; }}; 123456789101112class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { for (vector&lt;int&gt;::iterator i = nums.begin(); i != nums.end(); i++) { if (*i == val) { nums.erase(i); i--; } } return nums.size(); }}; 28. 实现strStr()AC代码1234567891011121314class Solution {public: int strStr(string haystack, string needle) { if (!needle.length()) return 0; if (haystack.length() &lt; needle.length()) return -1; int n = needle.length(); for (int i = 0; i &lt; haystack.length() - n + 1; i++) { if (haystack.substr(i, n) == needle) { return i; } } return -1; }}; 35. 搜索插入位置思路就是遍历搜索+插入排序，两个算法混合起来就完了 AC代码123456789101112131415161718class Solution {public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) { if (target &gt; *(nums.end() - 1)) { nums.insert(nums.end(), target); return nums.size() - 1; } for (int i = 0; i &lt; nums.size(); i++) { if (nums[i] &gt;= target) { if (nums[i] &gt; target) { nums.insert(nums.begin() + i, target); } return i; } } return nums.size(); }}; 38. 报数思路和之前的1084 外观数列(PAT (Basic Level) Practice)是一样的，不同点是外观数列是a有x个，这道题是x个a AC代码1234567891011121314151617181920212223242526272829303132static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: string countAndSay(int n) { return ItWasPAT(n); } void add(string&amp; str, char c, int&amp; n) { char toNum[1024] = {0}; sprintf(toNum, &quot;%d&quot;, n); str.append(toNum); str.append(&amp;c, 1); n = 0; } string ItWasPAT (int n) { string d = &quot;1&quot;; string&amp; temp = d; for (int i = 0, count = 1; i &lt; n - 1; i++, count = 1) { string next = &quot;&quot;; for (int j = 1; j &lt; temp.length(); j++, count++) if (temp[j - 1] != temp[j]) add(next, temp[j - 1], count); add(next, temp[temp.length() - 1], count); temp = next; } return temp; }}; 53. 最大子序和思路这道题不会，直接抄的评论区代码。大一上，还没学动态规划 AC代码1234567891011121314class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { if (!nums.size()) return 0; int ans = nums[0]; int sum = nums[0]; for (int i = 1; i &lt; nums.size(); i++) { if (sum &gt; 0) sum += nums[i]; else sum = nums[i]; ans = ans &lt; sum ? sum : ans; } return ans; }}; 83. 删除排序链表中的重复元素思路 链表是有序的 两个指针，一个指针i指向不重复的位置，一个j用来遍历 当j的值和i不一样时，让i的next指向j的next，j再往后移，由于这时候要访问j-&gt;next，要判断是否为NULL，如果是的话，说明结束了，让i-&gt;next为NULL 这时不要移动i，最后几个元素重复的话，这样会非法访问 这个算法放在java上更好，因为这样做没有delete，内存泄漏可是重罪 AC代码123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: ListNode* deleteDuplicates(ListNode* head) { if (head == NULL) return NULL; ListNode *i = head, *j = head-&gt;next; int n = 0; while (j != NULL) { if (i-&gt;val == j-&gt;val) { if (j-&gt;next != NULL) { i-&gt;next = j-&gt;next; j = j-&gt;next; } else { i-&gt;next = NULL; break; } } else { i = j; j = j-&gt;next; } } return head; }}; AC代码（内存不泄漏版本）123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: ListNode* deleteDuplicates(ListNode* head) { ListNode *i = head, *de; if (i == NULL || i-&gt;next == NULL) return head; while (i-&gt;next != NULL) { if (i-&gt;val == i-&gt;next-&gt;val) { de = i-&gt;next; i-&gt;next = i-&gt;next-&gt;next; delete de; } else { i = i-&gt;next; } } return head; }};","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932/"},{"title":"LeetCode-37","text":"698. 划分为k个相等的子集1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution { class Solve { vector&lt;int&gt;&amp; nums; int k; int n; vector&lt;int&gt; bucket; int target; int sum; bool canPartition; bool dfs(int index) { if(index &gt;= n) { // 所有数都放进来了，且没有超过target // 说明一定全等于target // 如果有桶&lt;target, 则一定有桶&gt;target，所以所有桶一定&gt;=target // 如果有桶&gt;target, 则一定有桶&lt;target，所以所有桶一定&lt;=target // 所以所有桶一定==target return true; } for(int i = 0; i &lt; k; i++) { if(i&gt;0 &amp;&amp; bucket[i] == bucket[i-1]) continue; if(bucket[i] + nums[index] &lt;= target) { bucket[i] += nums[index]; if(dfs(index+1)) { return true; } bucket[i] -= nums[index]; } } return false; } public: Solve(vector&lt;int&gt;&amp; nums, int k):nums(nums), k(k), bucket(k) { n = nums.size(); sum = accumulate(nums.begin(), nums.end(), 0); target = sum / k; sort(nums.begin(), nums.end(), greater&lt;int&gt;()); if(sum % k != 0) { canPartition = false; return; } canPartition = dfs(0); } bool solve() { return canPartition; } };public: bool canPartitionKSubsets(vector&lt;int&gt;&amp; nums, int k) { return Solve(nums, k).solve(); }}; 硬搜 690. 员工的重要性12345678910111213141516171819class Solution {public: int getImportance(vector&lt;Employee*&gt; employees, int id) { int len = employees.size(); unordered_map&lt;int, Employee*&gt; id2Node; for(Employee *employee : employees) { id2Node[employee-&gt;id] = employee; } function&lt;int(int)&gt; dfs = [&amp;](int currentId) { Employee *node = id2Node[currentId]; int ans = node-&gt;importance; for(int child : node-&gt;subordinates) { ans += dfs(child); } return ans; }; return dfs(id); }}; 699. 掉落的方块12345678910111213141516171819202122232425262728class Solution {public: vector&lt;int&gt; fallingSquares(vector&lt;vector&lt;int&gt;&gt;&amp; positions) { int len = positions.size(); vector&lt;int&gt; height(len); vector&lt;int&gt; right(len); for(int i = 0; i &lt; len; i++) { right[i] = positions[i][0] + positions[i][1]; } for(int i = 0; i &lt; len; i++) { int maxHeight = 0; int lefti = positions[i][0]; int righti = right[i]; for(int j = 0; j &lt; i; j++) { int leftj = positions[j][0]; int rightj = right[j]; if(lefti &gt;= rightj) continue; if(righti &lt;= leftj) continue; maxHeight = max(maxHeight, height[j]); } height[i] = maxHeight + positions[i][1]; } for(int i = 1; i &lt; len; i++) { height[i] = max(height[i-1], height[i]); } return height; }}; 数据规模略小，直接暴力 1186. 删除一次得到子数组最大和先了解Maximum Subarray Sum - Kadane’s Algorithm 123456789101112131415class Solution {public: int maximumSum(vector&lt;int&gt;&amp; arr) { int n = arr.size(); int dp0 = arr[0], dp1 = 0; int maxx = arr[0]; for(int i = 1; i &lt; n; i++) { dp1 = max(dp1 + arr[i], dp0); dp0 = max(dp0, 0) + arr[i]; maxx = max(maxx, dp0); maxx = max(maxx, dp1); } return maxx; }}; 3144. 分割字符频率相等的最少子字符串123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution { bool allEqualsExceptZero(int *arr, int len) { if(len &lt;= 0) return true; int i = 0; while(i &lt; len &amp;&amp; arr[i] == 0) i++; if(i == len) return true; const int val = arr[i]; for(; i &lt; len; i++) { if(0 != arr[i] &amp;&amp; val != arr[i]) return false; } return true; } int bfs(const vector&lt;vector&lt;bool&gt;&gt;&amp; balance, int n) { queue&lt;int&gt; q; q.push(0); int level = 0; vector&lt;bool&gt; visited(n, false); while(!q.empty()) { level++; int len = q.size(); while(len--) { int node = q.front(); q.pop(); for(int i = node; i &lt; n; i++) { if(balance[node][i]) { if(i + 1 == n) { return level; } else if(!visited[i+1]) { q.push(i + 1); visited[i + 1] = true; } } } } } return level; }public: int minimumSubstringsInPartition(string s) { int len = s.length(); vector&lt;vector&lt;bool&gt;&gt; balance(len, vector&lt;bool&gt;(len, false)); for(int i = 0; i &lt; len; i++) { int charCnt[26] = {0}; for(int j = i; j &lt; len; j++) { charCnt[s[j] - 'a']++; balance[i][j] = allEqualsExceptZero(charCnt, 26); } } return bfs(balance, len); } void test() { // cout &lt;&lt; minimumSubstringsInPartition(&quot;ababcc&quot;) &lt;&lt; &quot; == 1&quot;&lt;&lt; endl; // cout &lt;&lt; minimumSubstringsInPartition(&quot;fabccddg&quot;) &lt;&lt; &quot; == 3&quot; &lt;&lt; endl; // cout &lt;&lt; minimumSubstringsInPartition(&quot;abababaccddb&quot;) &lt;&lt; &quot; == 2&quot; &lt;&lt; endl; cout &lt;&lt; minimumSubstringsInPartition(&quot;fabccddg&quot;) &lt;&lt; &quot; == 3&quot; &lt;&lt; endl; }}; 找出任意区间(i...j)是否为平衡字符串，从0开始bfs搜索，直到第一个达到n的节点 3142. 判断矩阵是否满足条件12345678910111213141516171819202122232425class Solution {public: bool satisfiesConditions(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = grid.size(); int n = grid[0].size(); for(int i = 0; i &lt; m - 1; i++) { for(int j = 0; j &lt; n - 1; j++) { if(grid[i][j] != grid[i+1][j] || grid[i][j] == grid[i][j+1]) { return false; } } } for(int i = 0; i &lt; m - 1; i++) { if(grid[i][n-1] != grid[i+1][n-1]) { return false; } } for(int j = 0; j &lt; n - 1; j++) { if(grid[m-1][j] == grid[m-1][j+1]) { return false; } } return true; }}; 这种题请一次性给让我答10张 3144. 分割字符频率相等的最少子字符串这次用dp哦 123456789101112131415161718192021222324252627282930313233343536class Solution { bool allEqualsExceptZero(int *arr, int len) { if(len &lt;= 0) return true; int i = 0; while(i &lt; len &amp;&amp; arr[i] == 0) i++; if(i == len) return true; const int val = arr[i]; for(; i &lt; len; i++) { if(0 != arr[i] &amp;&amp; val != arr[i]) return false; } return true; }public: int minimumSubstringsInPartition(string s) { int n = s.length(); vector&lt;vector&lt;bool&gt;&gt; isBalance(n, vector&lt;bool&gt;(n)); for(int i = 0; i &lt; n; i++) { int charCnt[26] = {0}; for(int j = i; j &lt; n; j++) { charCnt[s[j] - 'a']++; isBalance[i][j] = allEqualsExceptZero(charCnt, 26); } } vector&lt;int&gt; dp(n, INT_MAX); dp[0] = 1; for(int i = 1; i &lt; n; i++) { if(isBalance[0][i]) dp[i] = min(dp[i], 1); for(int j = 1; j &lt;= i; j++) { if(isBalance[j][i]) dp[i] = min(dp[i], dp[j-1] + 1); } } return dp[n-1]; }}; 3127. 构造相同颜色的正方形123456789101112class Solution {public: bool canMakeSquare(vector&lt;vector&lt;char&gt;&gt;&amp; grid) { function&lt;int(int, int)&gt; gridValue = [&amp;](int i, int j) { return grid[i][j] == 'W' ? 1 : 0; }; function&lt;bool(int, int)&gt; judge = [&amp;](int i, int j) { return 2 != gridValue(i, j) + gridValue(i + 1, j) + gridValue(i, j + 1) + gridValue(i + 1, j + 1); }; return judge(0, 0) || judge(0, 1) || judge(1, 0) || judge(1, 1); }}; 3153. 所有数对中数位差之和123456789101112131415161718192021222324252627class Solution {public: long long sumDigitDifferences(vector&lt;int&gt;&amp; nums) { int len = nums.size(); vector&lt;vector&lt;int&gt;&gt; digitCnt(10, vector&lt;int&gt;(10)); // digitCnt[i][j], nums中第i位为j的数的个数 auto cntDigitNumPerPos = [&amp;]() { for(int index = 0; index &lt; len; index++) { int n = nums[index]; for(int i = 0; n; i++, n /= 10) { digitCnt[i][n % 10]++; } } }; cntDigitNumPerPos(); auto cntDiffsAndAdd = [&amp;]() { long long diffCnt = 0; for(int index = 0; index &lt; len; index++) { int n = nums[index]; for(int i = 0; n; i++, n /= 10) { diffCnt += len - digitCnt[i][n % 10]; // 数出有多少数和当前数的第i位不同 } } return diffCnt; }; return cntDiffsAndAdd() / 2; }}; 89. 格雷编码1234567891011class Solution {public: vector&lt;int&gt; grayCode(int n) { int len = 1 &lt;&lt; n; vector&lt;int&gt; ans(len); for(int i = 1; i &lt; len; i++) { ans[i] = (i &gt;&gt; 1) ^ i; } return ans; }}; 证明推导一下公式为什么时正确的 要证明公式 $ a_i = (i &gt;&gt; 1) \\oplus i $ 是格雷码，就要证明 $ a_{i+1} \\oplus a_{i} = 2^{k_i} $ , 其中 $ k_i $ 是整数 设 $ i $的二进制从低位到高位第一个$ 0 $的位置是$ n $, 则 $ i \\oplus (i + 1) = 2^{n+1} - 1$，原因参考二进制自增计数器的原理 $ a_{i+1} \\oplus a_{i} $$ = (i &gt;&gt; 1) \\oplus i \\oplus ((i + 1) &gt;&gt; 1) \\oplus (i + 1) $$ = (i \\oplus (i + 1)) \\oplus ((i \\oplus (i + 1)) &gt;&gt; 1)$$ = (2^{n+1} - 1) \\oplus (2^{n} - 1) $$ = 2^{n+1} $ 2708. 一个小组的最大实力值12345678910111213141516171819202122232425262728293031323334class Solution {public: long long maxStrength(vector&lt;int&gt;&amp; nums) { long long ans = 1; bool has2Neg = false; bool hasPositive = false; bool hasZero = false; long long negProduct = 1; int len = nums.size(); sort(nums.begin(), nums.end()); int i = 0; while(i &lt; len &amp;&amp; nums[i] &lt; 0) { negProduct *= nums[i]; if(negProduct &gt; 0) { ans *= negProduct; negProduct = 1; has2Neg = true; } i++; } while(i &lt; len &amp;&amp; nums[i] &lt;= 0) { hasZero = true; i++; } while(i &lt; len){ ans *= nums[i]; i++; hasPositive = true; } return (has2Neg || hasPositive) ? ans : (hasZero) ? 0 : nums[0]; }}; 除了0，全乘起来，如果负数有奇数个，去掉最大的负数 如果没有正数也没有成对的负数，但是有0，返回0 如果没有正数也没有成对的负数，没有0，返回唯一的负数 数据规模好小，给人一种很难的感觉 2024. 考试的最大困扰度123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution { int _maxConsecutiveAnswers(const string&amp; answerKey, int k) { int ans = 0; int len = answerKey.size(); int i = 0; while(i &lt; len &amp;&amp; k &gt; 0) { while(i &lt; len &amp;&amp; answerKey[i] == 'T') { i++; ans++; } while(i &lt; len &amp;&amp; k &gt; 0 &amp;&amp; answerKey[i] == 'F') { i++; k--; ans++; } } int j = 0; int cur = ans; while(i &lt; len) { while(i &lt; len &amp;&amp; answerKey[i] == 'T') { i++; cur++; } // cout &lt;&lt; i &lt;&lt; &quot;, &quot; &lt;&lt; ans &lt;&lt; &quot;, &quot; &lt;&lt; cur &lt;&lt; endl; ans = max(ans, cur); if(i &lt; len &amp;&amp; answerKey[i] == 'F') { int k = j; while(k &lt; i &amp;&amp; answerKey[k] == 'T') { k++; } cur = cur - (k - j + 1) + 1; // cout &lt;&lt; ans &lt;&lt; &quot;, &quot; &lt;&lt; cur &lt;&lt; endl; ans = max(ans, cur); j = k + 1; i++; } } return ans; }public: int maxConsecutiveAnswers(string&amp; answerKey, int k) { int res = _maxConsecutiveAnswers(answerKey, k); for(auto&amp; x : answerKey) { x = 'T' + 'F' - x; } return max(res, _maxConsecutiveAnswers(answerKey, k)); }}; 要么把k步全都用在T变F上，要么k步全部是F变T 对于”TTFTTFTTFTT”，可以翻译成[2T, 1F, 2T, 1F, 2T, 1F, 2T], 假设k=2，我们只需要考虑选前两个1F或后两个1F的情况，其他不连续的F的组合不需要考虑 经过上面的分析，可以使用双指针窗口 先把k消耗光 指针i每遇到一个F，前面的指针j就要向前移动，找到一个F把这个F变成T，移动几步，就减少了多少个T（包括j当前指向的F，已经在前面被变成T了）","link":"/home/2024/08/26/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9337/"},{"title":"LeetCode-6","text":"3. 无重复字符的最长子串思路双指针 如果字符串长度为1的话，直接返回1 建立哈希表，储存字符所在的位置（从1开始数） i，j两个指针，i用来遍历字符串（位置靠前），j用来记录当前不重复的字符的位置 每次循环，先查询map中s[i]的位置，如果在j的字符之前，说明从i到j没有重复字符 如果位置在j或j之后，说明出现重复字符，那么先不移动j，i-j的值就是一个非重复子串的长度 然后让j指向s[i]的下一个位置，这样就又变成了一个不重复的子串 循环结束，但是最后一次的统计没有记录，再记录一次。 AC代码123456789101112131415161718192021222324class Solution {public: int lengthOfLongestSubstring(string s) { if (s.length() == 1) return 1; unordered_map&lt;char, int&gt; m; int len = s.length(); int count = 0; int max = 0; int i = 0, j = 0; for ( ; i &lt; len; i++) { if (m[s[i]] &lt; j + 1) { m[s[i]] = i + 1; } else { count = i - j; j = m[s[i]]; max = max &gt; count ? max : count; m[s[i]] = i + 1; } } count = i - j; max = max &gt; count ? max : count; return max; }}; 8. 字符串转换整数 (atoi)AC代码12345678910111213141516171819202122232425class Solution {public: int myAtoi(string str) { int len = str.length(); int i = 0; while(i &lt; len &amp;&amp; str[i] == ' ')i++; int ans = 0; int nage = 1; if (i &lt; len &amp;&amp; str[i] == '-') { nage = -1; i++; } else if (i &lt; len &amp;&amp; str[i] == '+') { i++; } while (i &lt; len &amp;&amp; isdigit(str[i])) { if (ans*10ll &gt; INT_MAX) return nage == 1 ? INT_MAX : INT_MIN; ans *= 10; if (ans+(long long)(str[i] - '0') &gt; INT_MAX) return nage == 1 ? INT_MAX : INT_MIN; ans += str[i] - '0'; i++; } ans *= nage; return ans; }}; 11. 盛最多水的容器思路双指针 两个指针分别指向首尾 比较两个指针的大小，计算面积 把刚才较小的指针移动一格 AC代码123456789101112131415161718class Solution {public: int maxArea(vector&lt;int&gt;&amp; height) { int i = 0, j = height.size() - 1; int max = 0, a; while (i &lt; j) { if (height[i] &lt; height[j]) { a = height[i]*(j - i); i++; } else { a = height[j]*(j - i); j--; } max = max &gt; a ? max : a; } return max; }}; 12. 整数转罗马数字思路把所有的符号和对应的数字存起来，然后转化 AC代码123456789101112131415class Solution {public: string intToRoman(int num) { vector&lt;int&gt; vals = {1000,900,500,400,100,90,50,40,10,9,5,4,1}; vector&lt;string&gt; romans = {&quot;M&quot;, &quot;CM&quot;,&quot;D&quot;,&quot;CD&quot;,&quot;C&quot;,&quot;XC&quot;,&quot;L&quot;,&quot;XL&quot;,&quot;X&quot;,&quot;IX&quot;,&quot;V&quot;,&quot;IV&quot;,&quot;I&quot;}; string ans; for (int i = 0; i &lt; 13;i++) { while (num &gt;= vals[i]) { ans += romans[i]; num -= vals[i]; } } return ans; }}; 19. 删除链表的倒数第N个节点思路 vector保存结点地址，然后用数组访问下标愉快的操作 两次遍历，第一次计算链表长度，这样就可以计算出指针移动多少次可以到达要删除的位置，这样就可以删除了 一次遍历，两个指针（a， b）。创建一个哑结点指向头结点，a指向哑结点，b先向后移动n次，然后a，b一起移动，直到b移动到结尾。这样a就移动到了要删除的结点的前面。然后删除。然后返回哑结点的next。 AC代码12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { vector&lt;ListNode*&gt; v; ListNode* temp = head; while (temp != NULL) { v.push_back(temp); temp = temp-&gt;next; } int len = v.size(); if (len == n) { temp = head; head = head-&gt;next; delete temp; return head; } temp = v[len - n]; ListNode* x = v[len - n - 1]; x-&gt;next = temp-&gt;next; delete temp; return head; }}; AC代码12345678910111213141516171819202122232425class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* temp = head; int len = 0; while (temp != NULL) { temp = temp-&gt;next; len++; } int pos = len - n; temp = head; if (pos) { for (int i = 0; i &lt; pos - 1; i++) { temp = temp-&gt;next; } ListNode* del = temp-&gt;next; temp-&gt;next = temp-&gt;next-&gt;next; delete del; } else { head = head-&gt;next; delete temp; } return head; }}; AC代码1234567891011121314151617181920class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode *a, *b = head; a = new ListNode(0);//哑结点 a-&gt;next = head; head = a;//让head指向哑结点，最后return的接口统一 for (int i = 0; i &lt; n; i++) { b = b-&gt;next;//b指针先走 } while (b != NULL) { a = a-&gt;next; b = b-&gt;next; } ListNode* del = a-&gt;next; a-&gt;next = a-&gt;next-&gt;next; delete del; return head-&gt;next; }}; 31. 下一个排列思路 没思路，不过以前用过的代码找出来了 不知道为啥自己写的reverse函数效率比stl的reverse慢 AC代码12345678910111213141516171819202122232425262728293031class Solution {public: void nextPermutation(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int i = len - 1; int j = i - 1; while (j &gt;= 0 &amp;&amp; nums[j] &gt;= nums[j+1]) { j--; } if (j &lt; 0) { std::reverse(nums.begin(), nums.end()); return; } i = len - 1; while (i &gt;= 0 &amp;&amp; nums[i] &lt;= nums[j]) { i--; } swap(nums[i], nums[j]); std::reverse(nums.begin()+j+1, nums.end()); } void swap(int&amp; a, int&amp; b) { int t = a; a = b; b = t; } void reverse(vector&lt;int&gt;&amp; nums, int beg, int end) { for (int i = beg, j = end - 1; i &lt; j; i++, j--) { swap(nums[i], nums[j]); } }}; 123456class Solution {public: void nextPermutation(vector&lt;int&gt;&amp; nums) { next_permutation(nums.begin(), nums.end()); }}; 50. Pow(x, n)思路 直接算肯定不行的 如果算$x^4$，可以看做是$(x^2)^2$ 同样的$x^y = (x^2)^\\frac{y}{2}$，以此类推$x^y = (x^{2m})^{\\frac{y}{2m}}$ AC代码12345678910111213class Solution {public: double myPow(double x, int n) { double ans = 1; for (int i = n; i != 0; i /= 2) { if (i % 2 != 0) { ans *= x; } x *= x; } return n &lt; 0 ? 1/ans : ans; }}; 46. 全排列思路把上次31. 下一个排列的代码复制过来，改一改或者直接调用next_permutation AC代码123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; ans; do { ans.push_back(nums); } while (nextPermutation(nums)); return ans; } bool nextPermutation(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int i = len - 1; int j = i - 1; while (j &gt;= 0 &amp;&amp; nums[j] &gt;= nums[j+1]) { j--; } if (j &lt; 0) { std::reverse(nums.begin(), nums.end()); return false; } i = len - 1; while (i &gt;= 0 &amp;&amp; nums[i] &lt;= nums[j]) { i--; } swap(nums[i], nums[j]); std::reverse(nums.begin()+j+1, nums.end()); return true; }};","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%936/"},{"title":"LeetCode-5","text":"350. 两个数组的交集 II思路 两个map分别统计在两个数组中一个元素的出现次数 把其中一个数组排序去重，然后查询两个map 取这个元素在两个数组里出现次数的最小值n，往ans里面push该元素n次 AC代码1234567891011121314151617181920212223class Solution {public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { map&lt;int, int&gt; v,n; vector&lt;int&gt; ans; for (int x : nums1) { v[x]++; } for (int x : nums2) { n[x]++; } sort(nums1.begin(), nums1.end()); nums1.erase(unique(nums1.begin(), nums1.end()), nums1.end()); for (int x : nums1) { if (v[x] &amp;&amp; n[x]) { int l = v[x] &gt; n[x] ? n[x] : v[x]; for (int i = 0; i &lt; l; i++) ans.push_back(x); } } return ans; }}; 大佬思路双指针法 两个数组排序 两个指针指向第0个元素 循环比较，如果某一个指针的元素小，指针后移，知道值相等时，push一次 大佬代码1234567891011121314151617181920212223242526class Solution {public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { sort(nums1.begin(), nums1.end()); sort(nums2.begin(), nums2.end()); int n1Size = nums1.size(); int n2Size = nums2.size(); int i = 0; int j = 0; vector&lt;int&gt; intersect; while((i &lt; n1Size) &amp;&amp; (j &lt; n2Size)) { if (nums1[i] &lt; nums2[j]) ++i; else if (nums1[i] &gt; nums2[j]) ++j; else { intersect.push_back(nums1[i]); ++i; ++j; } } return intersect; }}; 367. 有效的完全平方数思路自己没好好研究这题的算法 AC代码123456class Solution {public: bool isPerfectSquare(int num) { return (int)sqrt(num) == sqrt(num); }}; 大佬思路 自己写一个搞笑的mySqrt函数，用类似二分查找法实现，毕竟这道题的输入只有整数 暴力搜索 大佬代码123456789101112131415161718192021222324class Solution {public: bool isPerfectSquare(int num) { int sqrt = mySqrt(num); return sqrt*sqrt == num; } int mySqrt(int x) { int lo,hi; long mid; lo = 0; hi = x; while(lo&lt;=hi){ mid = lo + (hi-lo)/2; if(mid*mid&gt;x){ hi = mid-1; } else if ((mid+1)*(mid+1)&gt;x) { return mid; } else{ lo = mid+1; } } return lo;} 371. 两整数之和思路 用位运算 不会 AC代码123456789101112class Solution {public: int getSum(int a, int b) { int temp = 0; while(a &amp; b){ temp = a; a ^= b; b = (temp &amp; b) &lt;&lt; 1; } return a|b; }}; 374. 猜数字大小思路 暴力搜索不可取，二分查找保平安 不要mid = (high + low) / 2，会溢出12345678910111213141516171819202122232425// Forward declaration of guess API.// @param num, your guess// @return -1 if my number is lower, 1 if my number is higher, otherwise return 0int guess(int num);class Solution {public: int guessNumber(int n) { int left = 1, right = n, mid = (n + 1)/2; while (left &lt;= right) { mid = (left - right)/2 + right; switch (guess(mid)) { case -1 : right = mid - 1; break; case 1 : left = mid + 1; break; case 0 : return mid; } } return -1; }}; 383. 赎金信思路 两个表，分别记录每个字母出现次数 遍历26个字母，magazine中字母出现次数大于等于ransom就可以 AC代码1234567891011121314151617class Solution {public: bool canConstruct(string ransomNote, string magazine) { int m[26] = {0}, n[26] = {0}; for (char x : ransomNote) { m[x-'a']++; } for (char x : magazine) { n[x-'a']++; } for (char x : ransomNote) { if (m[x-'a'] &gt; n[x-'a']) return false; } return true; }}; 387. 字符串中的第一个唯一字符思路记录每个字母出现次数，遍历字符串，看谁第一个出现次数是0 AC代码1234567891011121314class Solution {public: int firstUniqChar(string s) { int n[26] = {0}; for (char x : s) { n[x - 'a']++; } int len = s.length(); for (int i = 0; i &lt; len; i++) { if (n[s[i] - 'a'] == 1) return i; } return -1; }}; 389. 找不同思路 记录次数，遍历一遍t，看谁出现次数多一次 异或运算，抵消相同的 AC代码12345678910111213141516class Solution {public: char findTheDifference(string s, string t) { int m[26] = {0}, n[26] = {0}; for (char x : s) { m[x - 'a']++; } for (char x : t) { n[x - 'a']++; } for (char x : t) { if (m[x - 'a'] &lt; n[x - 'a']) return x; } return -1; }}; AC代码123456789101112class Solution {public: char findTheDifference(string s, string t) { int len = s.length(); char c = t[0]; for (int i = 0; i &lt; len; i++) { c ^= s[i]; c ^= t[i + 1];//t只比s多一个 } return c; }}; 400. 第N个数字思路 把 $10^1$,$10^2$, $10^3$…之前的数算出来，存到数组里 查询数组，得到这个数对应的数量级之前有多少数，然后算出这个数具体是几 AC代码1234567891011121314151617class Solution {public: int findNthDigit(int n) { unsigned long long m[10] = {0, 9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889}; //10^i之前的数字个数。10之前有9个数，100之前有189个数 int index = 0; for (; index &lt; 10; index++) { if (m[index] &gt;= n) { break; } }//找到n所在的范围，index是它的位数len n -= m[index - 1];//从例如189对应的100后的第几个数字 long long ans = pow(10, index - 1) + (n - 1) / (index);//对应的数 string t = to_string(ans); return t[(n - 1) % (index)] - '0'; }}; 405. 数字转换为十六进制数思路 用一个unsigned char指针指向int，循环4次，每次取值是两个16进制数，然后存起来 注意局部变量存在栈里，倒着输出 忽略前导0 AC代码12345678910111213141516171819202122class Solution {public: string toHex(int num) { if (!num) return &quot;0&quot;; char m[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'}; unsigned char *c = (unsigned char *)&amp;num; unsigned int n[8] = {0}; for (int i = 0; i &lt; 8; i+=2) { n[i] = (*c) % 16; n[i + 1] = (*c/16) % 16; c++; } string ans; int i = 7; while (i &gt;= 0 &amp;&amp; n[i] == 0) i--; for (; i &gt;= 0; i--) { ans += m[n[i]]; } return ans; }}; 412. Fizz Buzz思路额，，算就是了 AC代码123456789101112131415161718192021class Solution { public: vector&lt;string&gt; fizzBuzz(int n) { vector&lt;string&gt; v; for (int i = 1; i &lt;= n; i++) { if (i % 15 == 0) { v.push_back(&quot;FizzBuzz&quot;); } else if (i % 3 == 0) { v.push_back(&quot;Fizz&quot;); } else if (i % 5 == 0) { v.push_back(&quot;Buzz&quot;); } else { v.push_back(to_string(i)); } } return v; }}; 414. 第三大的数思路 搜索三次 第一次最大值 第二次不等于第一次的最大值 第三次不等于前两次的最大值 AC代码1234567891011121314151617181920212223class Solution {public: int thirdMax(vector&lt;int&gt;&amp; nums) { long i = LONG_MIN, j = LONG_MIN, k = LONG_MIN; for (int x : nums) { if (x &gt; i) { i = x; } } for (int x : nums) { if (x &gt; j &amp;&amp; x != i) { j = x; } } for (int x : nums) { if (x &gt; k &amp;&amp; x != i &amp;&amp; x != j) { k = x; } } if (k == LONG_MIN) return i; else return k; }}; 大佬思路 搜索一次找最大值 如果有最大值且大于最大的最大值，就把当前值先给了第二大值，第二大值给了第三大值 如果有最大值且小于最大的最大值大于第二大，往后顺延 如果有最大值且小于第二大的最大值大于第三大，往后顺延 大佬代码12345678910111213141516171819class Solution {public: int thirdMax(vector&lt;int&gt;&amp; nums) { long first = LONG_MIN, second = LONG_MIN, third = LONG_MIN; for (int num : nums) { if (num &gt; first) { third = second; second = first; first = num; } else if (num &gt; second &amp;&amp; num &lt; first) { third = second; second = num; } else if (num &gt; third &amp;&amp; num &lt; second) { third = num; } } return (third == LONG_MIN || third == second) ? first : third; }}; 415. 字符串相加思路 找到最长字符串的长度，用这个长度分别给两个字符串添加前导0 倒着遍历字符串，对应相加模拟就行了 别网站最后一位的进位 AC代码1234567891011121314151617181920212223242526class Solution {public: string addStrings(string num1, string num2) { int carry = 0; int len1 = num1.length(); int len2 = num2.length(); int len = len1 &gt; len2 ? len1 : len2; string zero; for (int i = 0; i &lt; len - len1; i++) { zero += '0'; } num1.insert(0, zero); zero.clear(); for (int i = 0; i &lt; len - len2; i++) { zero += '0'; } num2.insert(0, zero); for (int i = len - 1; i &gt;= 0; i--) { int n = carry + num1[i] + num2[i] - 2*'0'; num1[i] = n % 10 + '0'; carry = n / 10; } if (carry) num1.insert(0, 1, carry + '0'); return num1; }}; 434. 字符串中的单词数思路stl大法好 AC代码123456789101112class Solution {public: int countSegments(string s) { stringstream ss(s); string buf; int count = 0; while (ss &gt;&gt; buf) { count++; } return count; }}; 447. 回旋镖的数量思路 把所有点两两配对，计算距离 累加n(n-1)排列数$2A_n^2$ AC代码1234567891011121314151617181920class Solution {public: int numberOfBoomerangs(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) { unordered_map&lt;int ,int&gt; m; int ans = 0; int len = points.size(); for (int i = 0; i &lt; len; i++) { for (int j = 0; j &lt; len; j++) { int dx = points[i].first - points[j].first; int dy = points[i].second - points[j].second; m[dx*dx + dy*dy]++; } for (auto c : m) { ans += c.second*(c.second-1); } m.clear(); } return ans; }}; 441. 排列硬币思路 直接解方程 AC代码123456class Solution {public: int arrangeCoins(int n) { return (sqrt(1 + 8ll * n) - 1) / 2; }}; 大佬思路类似二分查找 计算当前mid对应的楼梯数q 如果q&lt;=总数，查找右边 否则查找左边 大佬代码1234567891011121314151617class Solution {public: int arrangeCoins(int n) { if (n &lt;= 0) return 0; unsigned long long i = 1, j = n + 1; while (j - i&gt;= 1) { long long mid = i + (j - i) / 2; long long q = mid*(mid + 1) / 2; if (q &lt;= n) { i = mid + 1; } else { j = mid; } } return i - 1; }}; 443. 压缩字符串思路遍历数次数，然后把次数编程string存起来，最后一个字符一个字符的存到vector数组里，返回 AC代码12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;char&gt; ans; int compress(vector&lt;char&gt;&amp; chars) { int len = chars.size(); vector&lt;string&gt; s; int j = 0; int count = 0; for (int i = 1; i &lt; len; i++) { if (chars[j] != chars[i]) { j++; chars[j] = chars[i]; s.push_back(to_string(count + 1)); count = 0; } else { count++; } } s.push_back(to_string(count + 1)); for (int i = 0; i &lt; j + 1; i++) { ans.push_back(chars[i]); if (s[i] == &quot;1&quot;) continue; int num = s[i].length(); for (int k = 0; k &lt; num; k++) { ans.push_back(s[i][k]); } } chars = ans; return chars.size(); }}; 大佬思路遍历一遍，数个数，然后都存到一个string里面（充分利用string重载的operator+），最后分解成char数组，返回 大佬代码123456789101112131415161718192021222324252627282930313233343536class Solution { public: int compress(vector&lt;char&gt; &amp;chars) { int count = 1; string str = &quot;&quot;; for (int i = 1; i &lt; chars.size(); i++) { if (chars[i] == chars[i - 1]) { count++; } else { if (count != 1) { str += chars[i - 1] + to_string(count); } else { str += chars[i - 1]; } count = 1; } } if (count != 1) { str += chars[chars.size() - 1] + to_string(count); } else { str += chars[chars.size() - 1]; } for (int i = 0; i &lt; str.size(); i++) { if (i &lt; chars.size()) { chars[i] = str[i]; } else { chars.push_back(str[i]); } } return str.size(); }}; 448. 找到所有数组中消失的数字思路记录每个数的出现次数，最后返回出现次数为0的那些数 AC代码1234567891011121314151617class Solution {public: vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) { unordered_map&lt;int, int&gt; m; vector&lt;int&gt; ans; int len = nums.size(); for (int x : nums) { m[x]++; } for (int i = 1; i &lt;= len; i++) { if (m[i] == 0) { ans.push_back(i); } } return ans; }}; 大佬思路 i从0开始遍历数组，取nums[i]的绝对值Q（后期正数可能变负数） 把Q-1作为下标，把nums[Q-1]这个数编程负的（自己的绝对值的相反数） 最后正数出现的位置就是1~n没出现过的数 大佬代码12345678910111213141516class Solution {public: vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; ans; int len = nums.size(); for (int i = 0; i &lt; len; i++) { nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1]); } for (int i = 0; i &lt; len; i++) { if (nums[i] &gt; 0) { ans.push_back(i + 1); } } return ans; }}; 455. 分发饼干思路贪心算法 + 双指针法 把所有小孩的胃口的出现次数统计出来，放到哈希表里面 把所有饼干能满足的最大胃口的出现次数统计出来，放到另一个哈希表里面 不用unordered_map，要排序的 遍历一遍孩子，如果当前饼干能满足胃口，就尽量多的喂 直到这个孩子的胃口被满足后，i++，不要j++，也许当前饼干还没有用完，而且足够下一个孩子的胃口 如果不能满足胃口，由于map是排序过的，所以也一定不能满足后面的孩子的要求，就j++看下一块饼干的情况 AC代码1234567891011121314151617181920212223242526272829class Solution {public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) { map&lt;int, int&gt; bit, chi; for (int x : g) { chi[x]++; } for (int x : s) { bit[x]++; } int ans = 0; auto i = chi.begin(), j = bit.begin(); for (; i != chi.end() &amp;&amp; j != bit.end(); ) { if (i-&gt;first &lt;= j-&gt;first &amp;&amp; j-&gt;second &gt; 0) { int a = i-&gt;second; int b = j-&gt;second; int min = a &gt; b ? b : a; i-&gt;second -= min; j-&gt;second -= min; ans += min; if (i-&gt;second == 0) i++; } else { j++; } } return ans; }}; 大佬思路贪心 + 双指针 排序两个数组 其他思路和我的基本一样，但是人家的代码又简洁效率又高 大佬代码12345678910111213141516class Solution {public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) { sort(g.begin(), g.end()); sort(s.begin(), s.end()); int ans = 0; int i = 0, j = 0; int len1 = g.size(), len2 = s.size(); for (; i &lt; len1 &amp;&amp; j &lt; len2;j++) { if (g[i] &lt;= s[j]) { i++; } } return i; }}; 461. 汉明距离思路位运算 异或，相同为1，不同为0 两个数异或，转二进制，把二进制位直接加起来就行 AC代码123456789101112class Solution {public: int hammingDistance(int x, int y) { int ans = x ^ y; int num = 0; while (ans) { num += ans % 2; ans /= 2; } return num; }}; 463. 岛屿的周长思路 只能暴搜了，如果一个格子上有颜色，总边数+=4 如果下方有格子，总边数-=2（不管上面，防止两条边重复计数） 如果右边有格子，总边数-=2（同理，不管左边） AC代码12345678910111213141516171819202122class Solution {public: int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int ans = 0; int len = grid.size(); int wide = grid[0].size(); for(int i = 0; i &lt; len; i++) { for (int j = 0; j &lt; wide; j++) { if (grid[i][j]) { ans += 4; if (i + 1 &lt; len &amp;&amp; grid[i + 1][j]) { ans -= 2; } if (j + 1 &lt; wide &amp;&amp; grid[i][j + 1]) { ans -= 2; } } } } return ans; }}; 476. 数字的补数思路 转二进制数 (num%2+1)%2能让1变0，0变1 AC代码12345678910111213class Solution {public: int findComplement(int num) { int n = 0; long long i = 1; while (num) { n += i * ((num % 2 + 1) % 2); i *= 2; num /= 2; } return n; }}; 大佬思路位运算，不懂 大佬代码123456789101112class Solution {public: int findComplement(int num) { int temp = num; int c = 0; while ( temp &gt; 0 ) { temp &gt;&gt;= 1; c = ( c &lt;&lt; 1 ) + 1; } return num ^ c; }}; 482. 密钥格式化思路 把'-'全都变成' ' stringstream把字符串拼起来 倒着遍历每K个加一个'-'，并且注意前面是不是头 AC代码1234567891011121314151617181920212223class Solution {public: string licenseKeyFormatting(string S, int K) { string ans, buf; for (int i = 0; i &lt; S.length(); i++) { if (S[i] == '-') { S[i] = ' '; } else { S[i] = toupper(S[i]); } } stringstream ss(S); while (ss &gt;&gt; buf) { ans += buf; } for (int i = ans.length() - 1, count = 1; i &gt; 0; i--, count++) { if (count % K == 0 &amp;&amp; i != 0) { ans.insert(i, 1, '-'); } } return ans; }}; 思路 遍历，判断是不是字母，是字母，变大写，然后push到新的string里面 同时记录字符数，每K个加一个负号 清除前后的负号 反转 AC代码123456789101112131415161718192021222324class Solution {public: string licenseKeyFormatting(string S, int K) { string ans; int count = 0; int len = S.length(); for (int i = len; i &gt;= 0; i--) { char t = S[i]; t = toupper(t); if (t != '-') { ans.push_back(t); if (count == K /*&amp;&amp; i != 0 &amp;&amp; i != len*/) { ans.push_back('-'); count = 0; } count++; } } if (ans.back() == '-') ans.pop_back(); reverse(ans.begin(), ans.end()); if (ans.back() == '-') ans.pop_back(); return ans; }}; 485. 最大连续1的个数AC代码123456789101112131415161718class Solution {public: int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int count = 0, max = 0; for (int x : nums) { if (x) { count++; } else { //max = max &gt; count ? max : count; if (max &lt; count) max = count; count = 0; } } if (max &lt; count) max = count; return max; }}; 500. 键盘行思路 建立哈希表，把每个字母对应的键盘行数标号 遍历所有字符串，看是不是同一行，统计，记录 按照要求输出 AC代码12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;string&gt; findWords(vector&lt;string&gt;&amp; words) { string keyBoard[3] = {&quot;QWERTYUIOP&quot;, &quot;ASDFGHJKL&quot;, &quot;ZXCVBNM&quot;}; unordered_map&lt;char, char&gt; m; for (int i = 0; i &lt; 3; i++) { int len = keyBoard[i].length(); for (int j = 0; j &lt; len; j++) { m[keyBoard[i][j]] = i; m[keyBoard[i][j] - 'A' + 'a'] = i; } } int n = words.size(); vector&lt;string&gt; ans; for (int i = 0; i &lt; n; i++) { int len = words[i].length(); int cmp = m[words[i][0]]; bool find = true; for (int j = 0; j &lt; len; j++) { if (cmp != m[words[i][j]]) { find = false; break; } } if (find) { ans.push_back(words[i]); } } return ans; }}; 504. 七进制数思路就是普通进制转换问题 AC代码123456789101112131415161718class Solution {public: string convertToBase7(int num) { string ans; bool nagetive = num &lt; 0; if (nagetive) { num *= -1; } do { ans = (char)(num % 7 + '0') + ans; num /= 7; } while (num); if (nagetive){ ans = &quot;-&quot; + ans; } return ans; }}; 506. 相对名次思路 拷贝一份，排序，map记录排名 遍历原来的数组，输出 AC代码12345678910111213141516171819202122class Solution {public: vector&lt;string&gt; findRelativeRanks(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; copy = nums; string rank[3] = {&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;}; map&lt;int, int&gt; m; sort(copy.begin(), copy.end(), greater&lt;int&gt;()); int len = nums.size(); for (int i = 0; i &lt; len; i++) { m[copy[i]] = i; } vector&lt;string&gt; ans; for (auto x : nums) { if (m[x] &gt;= 0 &amp;&amp; m[x] &lt; 3) { ans.push_back(rank[m[x]]); } else { ans.push_back(to_string(m[x] + 1)); } } return ans; }}; 507. 完美数思路AC代码12345678910111213class Solution {public: bool checkPerfectNumber(int num) { if (num &lt;= 1) return false; int ans = 1; for (int i = 2; i &lt; sqrt(num); i++) { if (num % i == 0) { ans += i + num/i; } } return ans == num; }}; 思路$1*10^8$的完美数只有6,28,496,8128,33550336 AC代码12345678910111213class Solution { public boolean checkPerfectNumber(int num) { switch(num) { case 6: case 28: case 496: case 8128: case 33550336: return true; } return false; }} 509. 斐波那契数思路居然真的只是求斐波那契数列，还只要前30位 AC代码123456789101112class Solution {public: int fib(int N) { int a = 0, b = 1; for (int i = 0; i &lt; N; i++) { int c = a + b; b = a; a = c; } return a; }}; 520. 检测大写字母思路 先把前导的大写字母跳过 如果当前指针正好指在0或1，那么只要后面有大写字母，就算错（除非长度只有1） 如果指在1后面，那么后面有小写字母就算错 AC代码class Solution { public: bool detectCapitalUse(string word) { int len = word.length(); int i = 0; while (i &lt; len &amp;&amp; word[i] &gt;= 'A' &amp;&amp; word[i] &lt;= 'Z') i++; if (i &gt; 1) { for ( ; i &lt; len; i++) { if (word[i] &gt;= 'a' &amp;&amp; word[i] &lt;= 'z') { return false; } } } else { if (len &lt;= 1) { return true; } else { for ( ; i &lt; len; i++) { if (word[i] &gt;= 'A' &amp;&amp; word[i] &lt;= 'Z') { return false; } } } } return true; } };","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%935/"},{"title":"LeetCode-4","text":"172. 阶乘后的零思路把2，5的倍数拆成2，5，数5的个数（2一定比5多），这样5一定和2配对，所以5的个数就是末尾0的个数 AC代码1234567891011class Solution {public: int trailingZeroes(int n) { int ans = 0; while (n) { n /= 5; ans += n; } return ans; }}; 123456class Solution {public: int trailingZeroes(int n) { return n == 0 ? 0 : n/5 + trailingZeroes(n / 5); }}; 189. 旋转数组思路（递归） k %= nums.size();取余数，不要循环好多圈 把前k个数和后k个数交换 把从下标k到结束的数作为源数据调用本函数 AC代码1234567891011121314151617181920212223class Solution {public: void rotate(vector&lt;int&gt;&amp; nums, int k) { go(0, k, nums); /* 时间复杂度O(n^2/k) 空间复杂度O(1) */ } void go(int beg, int k, vector&lt;int&gt;&amp; nums) { k %= nums.size() - beg; if (k == 0) return; for (int i = beg; i &lt; beg + k; i++) { swap(nums[i], nums[nums.size() - k + i - beg]); } go(beg + k, k, nums); } void swap(int&amp; a, int&amp; b) { int t = a; a = b; b = t; }}; 思路 把整个数组反转一次 前0到k-1反转一次 后k到结束反转一次 AC代码12345678910111213141516171819202122class Solution {public: void rotate(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); k %= n; reverse(nums, 0, n - 1); reverse(nums, 0, k - 1); reverse(nums, k, n - 1); /* 时间复杂度O(n) 空间复杂度O(1) */ /*------------------------------*/ } void reverse(vector&lt;int&gt;&amp; nums, int begin, int end) { while (begin &lt; end) { int n = nums[begin]; nums[begin++] = nums[end]; nums[end--] = n; } }}; 190. 颠倒二进制位思路 循环模2，2进制转2进制 注意原来的数的前导0也要添加到后面，所以循环条件是循环次数32次（因为给的是32位无符号数） AC代码1234567891011121314class Solution {public: uint32_t reverseBits(uint32_t n) { uint32_t ans = 0; int i = 32; while (i--) { ans *= 2; ans += n % 2; n /= 2; } return ans; }}; 191. 位1的个数AC代码1234567891011class Solution {public: int hammingWeight(uint32_t n) { int c = 0; while (n) { if (n % 2 == 1)c++; n/=2; } return c; }}; 202. 快乐数思路 计算，看有没有重复，有重复就说明不是快乐数 计算，出现4就不是快乐数（不是快乐数的数称为不快乐数（unhappy number），所有不快乐数的数位平方和计算，最後都会进入 4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4 的循环中。） AC代码1234567891011121314151617181920class Solution {public: bool isHappy(int n) { map&lt;int, int&gt; m; while (n != 1) { m[n]++; if (m[n] &gt; 1) break; n = get(n); } return n == 1; } int get(int n) { int ans = 0; while (n) { ans += (n % 10) * (n % 10); n /= 10; } return ans; }}; AC代码1234567891011121314151617181920class Solution {public: bool isHappy(int n) { while (n != 1) { if (n == 4) { return false; } n = get(n); } return true; } int get(int n) { int ans = 0; while (n) { ans += (n % 10) * (n % 10); n /= 10; } return ans; }}; 203. 移除链表元素思路如果头结点是要删的元素，进行的操作不太一样，要单独考虑，然后进行后面的删除。评论区好多用c++的都不管内存泄漏。不是好习惯，坚决杜绝！ AC代码123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* removeElements(ListNode* head, int val) { ListNode* move = head, *last = head; while (head != NULL &amp;&amp; head-&gt;val == val) { head = head-&gt;next; delete last; last = head; } move = head; while (move != NULL) { if (move-&gt;val == val){ last-&gt;next = move-&gt;next; delete move; } else { last = move; } move = last-&gt;next; } return head; }}; 204. 计数质数思路用筛法两个for循环把不是素数的都筛出来但是要提升性能: 忽略偶数 如果当前数已经算过了，就不要算 用bool的vector，bool一字节，比int短，也可以加速 AC代码1234567891011121314151617181920212223242526272829303132333435class Solution{ public: int countPrimes(int n) { if (n &lt;= 2) return 0; int count = 1; vector&lt;bool&gt; notPrime(n,0); for (int i = 3; i &lt; sqrt(n); i += 2) { if (notPrime[i] == 1)continue; for (int j = 3; j * i &lt;= n; j += 2) { notPrime[i * j] = 1; } } notPrime[0] = 1; notPrime[1] = 1; notPrime[3] = 0; notPrime[4] = 1; notPrime[5] = 0; notPrime[6] = 1; notPrime[7] = 0; notPrime[8] = 1; notPrime[9] = 1; for (int i = 1; i &lt; n; i += 2) { if (notPrime[i] == 0) count++; } return count; }}; 最快大佬的代码思路看不懂123456789101112131415161718192021222324252627282930313233class Solution {public: int countPrimes(int n) { if (n &lt; 3) return 0; size_t len = (n-2) &gt;&gt; 1; //cout &lt;&lt; len &lt;&lt; endl; vector&lt;char&gt; v(len, 0); int count = 1; uint i = 0; auto m = min(len, 0x7FFEuL); while (i &lt; m) { if (!v[i]) { ++count; uint p = (i &lt;&lt; 1) + 3; //if (p &lt; 0x10000) { uint pp = p * p; uint j = (pp - 3) &gt;&gt; 1; while(j &lt; len) { v[j] = true; j += p; } } ++i; } while (i &lt; len) { if (!v[i]) ++count; ++i; } return count; }}; 205. 同构字符串思路不太会，抄的评论区代码，但是要注意，一个字母a如果替换成b，就不能替换为c AC代码1234567891011121314151617181920212223static const int boost = [](){ ios::sync_with_stdio(false); cin.tie(nullptr); return 0;}();class Solution {public: bool isIsomorphic(string s, string t) { int alphabetS[256], alphabetT[256], num = 0; memset(alphabetS, 0, sizeof(alphabetS)); memset(alphabetT, 0, sizeof(alphabetT)); int len = s.length(); for (int pos = 0; pos &lt; len; pos++) { if(alphabetS[s[pos]] != alphabetT[t[pos]]) return false; else if (alphabetS[s[pos]] == 0) alphabetS[s[pos]] = alphabetT[t[pos]] = ++num; } return true; }}; 206. 反转链表思路 把结点全都存到数组里 递归，调用自己，再把头结点变成尾巴结点 AC代码1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseList(ListNode* head) { vector&lt;ListNode*&gt; v; ListNode *temp = head; while (temp != NULL) { v.push_back(temp); temp = temp-&gt;next; } int len = v.size(); for (int i = 0; i &lt; len / 2; i++) { int swap = v[i]-&gt;val; v[i]-&gt;val = v[len - 1 - i]-&gt;val; v[len - 1 - i]-&gt;val = swap; } return head; }}; 12345678910class Solution {public: ListNode* reverseList(ListNode* head) { if (head == NULL || head-&gt;next == NULL) return head; ListNode *temp = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return temp; }}; 217. 存在重复元素思路 调用api，先sort，再调用unique，判断返回值是不是end()迭代器，是则没有重复 AC代码12345678class Solution {public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); return unique(nums.begin(), nums.end()) != nums.end(); }}; 123456789101112class Solution {public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); int len = nums.size(); for (int i = 1; i &lt; len; i++) { if (nums[i - 1] == nums[i]) return true; } return false; }}; 225. 用队列实现栈思路queue是先进先出，stack是后进先出。 用deque实现 每次push的元素后，让队列循环pop出来再push回去，使得刚刚push的元素变成第一个 AC代码1234567891011121314151617181920212223242526class MyStack {public: queue&lt;int&gt; data; MyStack() { } void push(int x) { data.push(x); int len = data.size() - 1; while (len--) { data.push(data.front()); data.pop(); } } int pop() { int x = data.front(); data.pop(); return x; } int top() { return data.front(); } bool empty() { return data.empty(); }}; 1234567891011121314151617181920class MyStack {public: deque&lt;int&gt; data; MyStack() { } void push(int x) { data.push_front(x); } int pop() { int x = data.front(); data.pop_front(); return x; } int top() { return data.front(); } bool empty() { return data.empty(); }}; 226. 翻转二叉树思路 递归 深度优先 广度优先 AC代码12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* invertTree(TreeNode* root) { go(root); return root; } void go(TreeNode* root) { if (root == NULL) return; TreeNode* temp = root-&gt;left; root-&gt;left = root-&gt;right; root-&gt;right = temp;//广度优先 go(root-&gt;left); go(root-&gt;right); }}; 123456789101112class Solution {public: TreeNode* invertTree(TreeNode* root) { if (root == NULL) return root; TreeNode*left = invertTree(root-&gt;right);//深度优先 TreeNode*right = invertTree(root-&gt;left); root-&gt;right = right; root-&gt;left = left; return root; }}; 231. 2的幂思路 取2对数看是不是整数 利用二进制位运算 假设一个无符号数是全1的，那么它是2^k-1 假设2^k = n，那么只要一个数满足(n)&amp;(n-1) == 0，按位相与 AC代码123456class Solution {public: bool isPowerOfTwo(int n) { return (int)log2(n) == log2(n); }}; 1234567class Solution {public: bool isPowerOfTwo(int n) { if (n &gt; 0 &amp;&amp; ((n)&amp;(n-1)) == 0) return true; return false; }}; 232. 用栈实现队列思路 创建两个栈s、m，每次push存到s里面，然后再逐个弹出s中的元素压到m中（这个过程中s要先拷贝一份） 每次pop的时候，从m中pop，然后再逐个弹出m中的元素压到s中（这个过程中s要先拷贝一份） m用来对顶部元素操作，s来保持队形 AC代码123456789101112131415161718192021222324252627282930313233class MyQueue {public: stack&lt;int&gt; s; stack&lt;int&gt; m; MyQueue() { } void push(int x) { s.push(x); update(s,m); } void update(stack&lt;int&gt; a, stack&lt;int&gt;&amp; b) { int len = a.size(); while (!b.empty()){ b.pop(); } while (len--) { b.push(a.top()); a.pop(); } } int pop() { int x = m.top(); m.pop(); update(m,s); return x; } int peek() { return m.top(); } bool empty() { return m.empty(); }}; 234. 回文链表思路（暂时没有达到空间O(1)）vector存结点地址AC代码123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: bool isPalindrome(ListNode* head) { /*ListNode* temp = head; vector&lt;ListNode*&gt; v; while (temp != NULL) { v.push_back(temp); temp = temp-&gt;next; } int len = v.size(); for (int i = 0; i &lt; len / 2; i++) { if (v[i]-&gt;val != v[len - 1 - i]-&gt;val) return false; } return true;*/ }}; 292. Nim游戏思路巴什博奕，n%(m+1)!=0时，先手总是会赢的m为每次抽排的最大张数 AC代码123456class Solution {public: bool canWinNim(int n) { return n%4 != 0; }}; 242. 有效的字母异位词思路就是看每个字母的使用次数一不一样一个数组，记录字母的使用次数，最后次数一样就行。 AC代码1234567891011121314class Solution {public: bool isAnagram(string s, string t) { int a[26] = {0}, b[26] = {0}; for (int i = 0; i &lt; s.length(); i++) a[s[i] - 'a']++; for (int i = 0; i &lt; t.length(); i++) b[t[i] - 'a']++; for (int i = 0; i &lt; 26; i++) { if (a[i] != b[i]) return false; } return true; }}; 258. 各位相加###AC代码 123456789101112131415class Solution {public: int addDigits(int num) { while (num/10 != 0) { int ans = 0; while (num) { ans += num%10; num /= 10; } num = ans; } return num; return num == 0 ? 0 : num - 9 * ((num - 1) / 9) ; }}; 263. 丑数思路如果n % m == 0,说明n中至少有一个m的因数，循环n%m == 0时重复n /= m，可以去除所有的m的因数，根据这个思路，如果是丑数，把所有2，3，5的因数去除以后，就是1了 AC代码12345678910class Solution {public: bool isUgly(int num) { if (num &lt;= 0) return false; while (num%2 == 0) num /= 2; while (num%3 == 0) num /= 3; while (num%5 == 0) num /= 5; return num == 1; }}; 268. 缺失数字思路 0-n 11 个数中缺了一个，可以先算出等差数列的sum(0,n)，然后变量数组减去所有元素，最后的差就是缺少的元素 看不懂的位运算，异或抵消 AC代码1234567891011class Solution {public: int missingNumber(vector&lt;int&gt;&amp; nums) { int ans = nums.size(); ans = ans*(ans+1)/2; for (int x : nums) { ans -= x; } return ans; }}; 123456789101112class Solution {public: int missingNumber(vector&lt;int&gt;&amp; nums) { int sum = nums.size(); int len = sum; for (int i = 0; i &lt; len; i++) { sum ^= nums[i]; sum ^= i; } return sum; }}; 278. 第一个错误的版本思路暴力搜索不可取，二分查找保平安 AC代码12345678910111213141516171819202122// Forward declaration of isBadVersion API.bool isBadVersion(int version);class Solution {public: int firstBadVersion(int n) { long long mid , a = 1, b = n; if (isBadVersion(1)) return 1; while (a &lt;= b) { mid=a+(b-a)/2; bool bad, left, right; bad = isBadVersion(mid); left = isBadVersion(mid - 1); right = isBadVersion (mid + 1); if (bad &amp;&amp; !left) return mid; else if (bad &amp;&amp; right) b = mid - 1; else a = mid + 1; } if (isBadVersion(n)) return n; return -1; }}; 283. 移动零思路 冒泡排序的思想，不过条件换成左边的数是0，则交换一次 双指针，从左往右遍历 AC代码123456789101112131415class Solution {public: void moveZeroes(vector&lt;int&gt;&amp; nums) { int len = nums.size(); for (int i = len - 1; i &gt;= 0; i--) { for (int j = len - 2; j &gt;= 0; j--) { if (nums[j] == 0) { int temp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = temp; } } } }}; 123456789101112131415class Solution {public: void moveZeroes(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int pos = 0; for (int i = 0; i &lt; len; i++) { if (nums[i] != 0) { nums[pos++] = nums[i]; } } for (int i = pos; i &lt; len; i++) { nums[i] = 0; } }}; 290. 单词模式思路 建立两个map，验证映射是一一映射 如果当前值在a-&gt;b且b-&gt;a的映射都是空，那么添加这两个映射 如果有一个是存在的，看两个映射的结果与当前值是否相等，不相等返回false 循环安全结束，返回true AC代码1234567891011121314151617181920212223242526class Solution {public: bool wordPattern(string pattern, string str) { unordered_map&lt;char, string&gt; m; unordered_map&lt;string, char&gt; n; vector&lt;string&gt; strs; stringstream ss(str); string buf; while (ss &gt;&gt; buf) { strs.push_back(buf); } if (strs.size() != pattern.length()) return false; int len = pattern.length(); for (int i = 0; i &lt; len; i++) { if (m[pattern[i]] == &quot;&quot; &amp;&amp; n[strs[i]] == 0) { m[pattern[i]] = strs[i]; n[strs[i]] = pattern[i]; } else { if (m[pattern[i]] != strs[i] || n[strs[i]] != pattern[i]) { return false; } } } return true; }}; 303. 区域和检索 - 数组不可变思路题目保证数组不会改变，且要多次调用sumRange()，采用以下方法提高效率 类比数列的知识，创建一个vector，存放前i项和 在构造对象时，变量一遍数组O(N)，得到所有的前n项和 每次调用函数时，直接返回两个sj和si-1的差即可 为了减少if-else的执行，数据的第一个地方存一个0，这样返回sj+1 - si即可 AC代码1234567891011121314151617class NumArray {public: vector&lt;int&gt; s; NumArray(vector&lt;int&gt; nums) { int sum = 0; int len = nums.size(); s.push_back(0); for (int i = 0; i &lt; nums.size(); i++) { sum += nums[i]; s.push_back(sum); } } int sumRange(int i, int j) { return s[j + 1] - s[i]; }}; 326. 3的幂思路 看3^log3(n)取整 是否等于n本身 用到了数论的知识，3的幂次的质因子只有3，而所给出的n如果也是3的幂次，故而题目中所给整数范围内最大的3的幂次的因子只能是3的幂次，1162261467是3的19次幂，是整数范围内最大的3的幂次 AC代码1234567class Solution {public: bool isPowerOfThree(int n) { if (n &lt;= 0) return false; return (int)pow(3, round((log(n) / log(3)))) == n; }}; 123456class Solution {public: bool isPowerOfThree(int n) { return n &gt; 0 &amp;&amp; 1162261467%n == 0; }}; 342. 4的幂思路 看以log2(num)是否为偶数 查看二进制的所有奇数位，全是0即可（参见二进制转10进制公式，奇数为上的2的指数都是奇数） AC代码1234567class Solution { public: bool isPowerOfFour(long long num) { double n = log2(num); return (int)n == n ? (int)n % 2 == 0 : false; }}; 123456789class Solution { public: bool isPowerOfFour(long long num) { if (num &lt; 0 || num &amp; (num-1)){//check(is or not) a power of 2. return false; } return num &amp; 0x55555555;//check 1 on odd bits }}; 344. 反转字符串AC代码123456class Solution {public: void reverseString(vector&lt;char&gt;&amp; s) { reverse(s.begin(), s.end()); }}; 345. 反转字符串中的元音字母AC代码1234567891011121314151617181920212223242526272829class Solution {public://双指针法 string reverseVowels(string s) { int left = 0; int right = s.length() - 1; char m[128] = {0}; m['a'] = 1; m['e'] = 1; m['i'] = 1; m['o'] = 1; m['u'] = 1; m['A'] = 1; m['E'] = 1; m['O'] = 1; m['I'] = 1; m['U'] = 1; while (left &lt; right) { while (left &lt; right &amp;&amp; !m[s[left]]) left++; while (left &lt; right &amp;&amp; !m[s[right]]) right--; //加上left&lt;right的判断 条件，防止把换过来的字母换回去 char m = s[left]; s[left] = s[right]; s[right] = m; left++; right--; } return s; }}; 349. 两个数组的交集思路 先把两个数组排序去重，然后map记录出现次数，然后把出现次数大于1的挑出来作为返回值返回 AC代码12345678910111213141516171819202122class Solution {public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { unordered_map&lt;int, int&gt; m; vector&lt;int&gt; v; sort(nums1.begin(), nums1.end()); nums1.erase(unique(nums1.begin(), nums1.end()), nums1.end()); sort(nums2.begin(), nums2.end()); nums2.erase(unique(nums2.begin(), nums2.end()), nums2.end()); for (int x : nums1) { m[x]++; } for (int x : nums2) { m[x]++; } for (auto x : m) { if (x.second &gt; 1) v.push_back(x.first); } return v; }};","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%934/"},{"title":"LeetCode-32","text":"1185. 一周中的第几天 Tomohiko Sakamoto算法 虽然是简单题也有很多知识点呢 解释 1234567891011121314class Solution {public: string dayOfTheWeek(int day, int month, int year) { // array with leading number of days values static int t[] = { 0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4 }; // if month is less than 3 reduce year by 1 if (month &lt; 3) year -= 1; return vector&lt;string&gt;{&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;} [((year + year / 4 - year / 100 + year / 400 + t[month - 1] + day) % 7)]; }}; 2583. 二叉树中的第 K 大层和12345678910111213141516171819202122232425class Solution {public: long long kthLargestLevelSum(TreeNode* root, int k) { if(!root) return -1; priority_queue&lt;long long&gt; level_sum_q; queue&lt;TreeNode *&gt; q; q.push(root); while(!q.empty()) { int q_size = q.size(); long long level_sum = 0; while(q_size--) { TreeNode *node = q.front(); q.pop(); level_sum += node-&gt;val; if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); } level_sum_q.push(level_sum); } while(--k &amp;&amp; !level_sum_q.empty()) { level_sum_q.pop(); } return !level_sum_q.empty() ? level_sum_q.top() : -1; }}; 用ranges获取第k大的数 1234567891011121314151617181920212223242526class Solution {public: long long kthLargestLevelSum(TreeNode* root, int k) { if(!root) return -1; vector&lt;long long&gt; level_sums; queue&lt;TreeNode *&gt; q; q.push(root); int level_cnt = 0; while(!q.empty()) { int q_size = q.size(); long long level_sum = 0; while(q_size--) { TreeNode *node = q.front(); q.pop(); level_sum += node-&gt;val; if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); } level_sums.push_back(level_sum); level_cnt++; } if(level_cnt &lt; k) return -1; ranges::nth_element(level_sums, level_sums.end() - k); return level_sums[level_sums.size() - k]; }}; LCP 30. 魔塔游戏 当遇到HP不够的时候，考虑贪心，依次将已经遇到过的房间中最小的房间向后移动 移动后放入delay中，最后加上delay看HP够不够就好了 12345678910111213141516171819202122232425262728class Solution {public: int magicTower(vector&lt;int&gt;&amp; nums) { int n = nums.size(); long long HP = 1; int swapCnt = 0; auto cmp = [&amp;nums](int i, int j){ return nums[i] &gt; nums[j]; }; long long delay = 0; priority_queue&lt;int, vector&lt;int&gt;, decltype(cmp)&gt; q(cmp); for(int i = 0; i &lt; n; i++) { int room = nums[i]; if(room &lt; 0)q.push(i); int chance = n - i - 1; while(HP + room &lt;= 0 &amp;&amp; !q.empty() &amp;&amp; chance--) { int minIndex = q.top(); q.pop(); int room_min = nums[minIndex]; HP -= nums[minIndex]; delay += nums[minIndex]; swapCnt++; } HP += room; if(HP &lt;= 0) break; } HP += delay; return HP &gt; 0 ? swapCnt : -1; }}; 1696. 跳跃游戏 VI 看提示就会了12345678910111213141516171819class Solution {public: int maxResult(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); vector&lt;int&gt; dp(n, INT_MIN); auto cmp = [&amp;dp](int i, int j) {return dp[i] &lt; dp[j];}; priority_queue&lt;int, vector&lt;int&gt;, decltype(cmp)&gt; q(cmp); dp[0] = nums[0]; q.push(0); for(int i = 1; i &lt; n; i++) { while(q.top() &lt; i - k) q.pop(); int maxDp = dp[q.top()]; dp[i] = max(dp[i], maxDp + nums[i]); q.push(i); } return dp.back(); }}; 292. Nim 游戏 用dp[i]表示i个石头是否存在必胜策略，已知i = 1, 2, 3时，一定有必胜策略 那么对于4，无论我拿多少，对手都有必胜策略，那么我必输 对于5，6，7，我分别拿1，2，3就会得到4，对手陷入必输，那么我必胜 也就是前三个数全true，我就是false，前三个数有false，我就是true 可以证明，4的倍数一定输 连续三个true后必跟一个false 每个false后面一定有3个true 1234567891011121314151617class Solution {public: bool canWinNim(int n) { return n % 4 != 0; // 下面是推理过程 vector&lt;bool&gt; dp(n+1); dp[0] = dp[1] = dp[2] = dp[3] = true; bool last1 = true, last2 = true, last3 = true; for(int i = 4; i &lt;= n; i++) { dp[i] = !(last1 &amp;&amp; last2 &amp;&amp; last3); last1 = last2; last2 = last3; last3 = dp[i]; if(!dp[i]) cout &lt;&lt; i &lt;&lt; &quot;,&quot;; } return dp[n]; }}; 2476. 二叉搜索树最近节点查询中序+二分12345678910111213141516171819202122class Solution { void inorder(TreeNode *root, vector&lt;int&gt;&amp; ans) { if(!root) return; inorder(root-&gt;left, ans); ans.push_back(root-&gt;val); inorder(root-&gt;right, ans); }public: vector&lt;vector&lt;int&gt;&gt; closestNodes(TreeNode* root, vector&lt;int&gt;&amp; queries) { vector&lt;int&gt; v; vector&lt;vector&lt;int&gt;&gt; ans; auto miniCmp = [](int x, int y) { return x &gt;= y;}; auto maxiCmp = [](int x, int y) { return x &lt;= y;}; inorder(root, v); for(int query : queries) { auto mini = upper_bound(v.rbegin(), v.rend(), query, miniCmp); auto maxi = upper_bound(v.begin(), v.end(), query, maxiCmp); ans.push_back({mini == v.rend() ? -1 : *mini, maxi == v.end() ? -1 : *maxi}); } return ans; }}; 235. 二叉搜索树的最近公共祖先 这道题与236. 二叉树的最近公共祖先不同，这道题是在二叉搜索树上寻找 对于根节点，如果两个数分别大于等于和小于等于这个节点，说明当前根节点就是公共祖先 如果都大于或小于当前根节点，说明要向左子树或右子树移动，继续寻找123456789101112131415class Solution { TreeNode* _lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root-&gt;val &gt;= p-&gt;val &amp;&amp; root-&gt;val &lt;= q-&gt;val) return root; else if(root-&gt;val &gt; p-&gt;val) { return lowestCommonAncestor(root-&gt;left, p, q); } else { return lowestCommonAncestor(root-&gt;right, p, q); } }public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { // p q一定在root中，root一定不空 if(p-&gt;val &gt; q-&gt;val) swap(p, q); //保证p &lt; q; return _lowestCommonAncestor(root, p, q); }}; 938. 二叉搜索树的范围和 如果当前节点大于high，则不考虑右子树和当前节点，直接转移到左子树，小于low同理 如果当前节点在high和low之间，则返回当前节点值加上左右两棵子树的和 12345678910111213class Solution {public: int rangeSumBST(TreeNode* root, int low, int high) { if(!root) return 0; if(root-&gt;val &gt; high) { return rangeSumBST(root-&gt;left, low, high); } else if(root-&gt;val &lt; low) { return rangeSumBST(root-&gt;right, low, high); } else { return root-&gt;val + rangeSumBST(root-&gt;left, low, high) + rangeSumBST(root-&gt;right, low, high); } }}; 2867. 统计树中的合法路径数目思路 首先题目说是树，所以要考虑最广泛的n叉树的情况 涉及到素数，所以可以先素数筛把需要用到的素数缓存起来 最笨的方法是，依次从所有素数出发，dfs直到遇到下一个素数或者遇到没有未访问节点位置，统计总共的路线数 一个素数的所有孩子可以看成一个子树，到达每个节点的路径数就是节点数 总路线数就是 N个子树按照上面的要求dfs时所遇到的节点数之和($\\sum_{i=1}^N(A_i)$) 考虑到dfs过程中遇到的都是非素数，那么任意两个子树之间的任意两点之间的路径也是题目所求路径，总数为N个子树节点数两两相乘再相加($\\sum_{i=1}^N\\sum_{j=i+1}^N(A_i \\times A_j)$) 为了减少重复的统计，使用并查集，将素数节点去除得到X个子树，计算X个子树的节点个数 根据公式$(\\sum_{i=1}^N(A_i))^2 - \\sum_{i=1}^N(A_i^2) = 2 \\times \\sum_{i=1}^N\\sum_{j=i+1}^N(A_i \\times A_j)$，可以将二重循环简化为一重循环 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution { int find(int x, vector&lt;int&gt;&amp; arr) { return arr[x] != x ? (arr[x] = find(arr[x], arr)) : x; } void Union(int x, int y, vector&lt;int&gt;&amp; arr) { arr[find(x, arr)] = find(y, arr); } unordered_set&lt;int&gt; primeSet{2}; bool is_prime(int val) { return primeSet.count(val) != 0; } long long ans = 0;public: long long countPaths(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) { if(n &lt;= 1) return 0; for(int i = 3; i &lt;= n; i+=2) { bool flag = true; for(int j = 3; j*j&lt;=i; j+=2) { if(i % j == 0) { flag = false; break; } } if(flag) { primeSet.insert(i); } } vector&lt;int&gt; disjointSet(n+1), cnt(n+1); iota(disjointSet.begin(), disjointSet.end(), 0); vector&lt;vector&lt;int&gt;&gt; g(n+1); for(auto&amp; edge:edges) { bool is_prime0 = is_prime(edge[0]), is_prime1 = is_prime(edge[1]); if(!is_prime0 &amp;&amp; !is_prime1) { // 两个节点都不是素数，合并到同一个集合 Union(edge[0], edge[1], disjointSet); } if(is_prime0 ^ is_prime1) { // 两个节点中一个素数，一个非素数，记录非素数子树 g[edge[0]].push_back(edge[1]); g[edge[1]].push_back(edge[0]); } } for(int i = 1; i &lt;= n; i++) { cnt[find(i, disjointSet)]++; } for(auto ite = primeSet.begin(); ite != primeSet.end(); ite++) { long long cntSum = 0, cntSquareSum = 0; for(int child : g[*ite]) { cntSum += (long long)cnt[disjointSet[child]]; cntSquareSum += (long long)cnt[disjointSet[child]] * cnt[disjointSet[child]]; // 防止溢出 } ans += (cntSum * cntSum - cntSquareSum) / 2 + cntSum; } return ans; }}; 2673. 使二叉树所有路径值相等的最小代价思路 计算每个节点从根到当前节点的路径和 计算每个节点的子路径的最大值 对每个节点，计算两个子节点的子路径最大值之差，给较小的节点增加这个差值 代码1234567891011121314151617181920212223242526272829class Solution { int ans = 0; void solve(int n, int node, int extra, vector&lt;int&gt;&amp; childMax) { int parentMax = childMax[(node+1)/2-1]; ans += parentMax - childMax[node]; extra += parentMax - childMax[node]; if(2*(node+1)-1 &lt; n) solve(n, 2*(node+1)-1, extra, childMax); if(2*(node+1) &lt; n) solve(n, 2*(node+1), extra, childMax); }public: int minIncrements(int n, vector&lt;int&gt;&amp; cost) { vector&lt;int&gt; pathSum(n), childMax(n); pathSum[0] = cost[0]; for(int i = 1; i &lt; n; i++) { pathSum[i] = cost[i] + pathSum[(i+1)/2-1]; } for(int i = n-1; i &gt;= n/2; i--) { childMax[i] = pathSum[i]; } for(int i = n/2 - 1; i &gt;= 0; i--) { childMax[i] = max( (i+1)*2-1 &lt; n ? childMax[(i+1)*2-1] : 0, (i+1)*2 &lt; n ? childMax[(i+1)*2] : 0); } solve(n, 1, 0, childMax); solve(n, 2, 0, childMax); return ans; }}; 去掉不必要的判断 123456789101112131415161718192021222324252627inline int leftChildOf(int node) { return ((node + 1) &lt;&lt; 1) - 1; }inline int rightChildOf(int node) { return ((node + 1) &lt;&lt; 1); }inline int parentOf(int node) { return ((node + 1) &gt;&gt; 1) - 1; }class Solution { int solve(int n, int node, vector&lt;int&gt;&amp; childMax) { int ans = childMax[parentOf(node)] - childMax[node]; if(leftChildOf(node) &lt; n /*&amp;&amp; rightChildOf(node) &lt; n*/) { ans += solve(n, leftChildOf(node), childMax) + solve(n, rightChildOf(node), childMax); } return ans; }public: int minIncrements(int n, vector&lt;int&gt;&amp; cost) { vector&lt;int&gt; pathSum(n), childMax(n); pathSum[0] = cost[0]; for(int i = 1; i &lt; n; i++) { pathSum[i] = cost[i] + pathSum[parentOf(i)]; } for(int i = n-1; i &gt;= n/2; i--) { childMax[i] = pathSum[i]; } for(int i = n/2 - 1; i &gt;= 0; i--) { childMax[i] = max(childMax[leftChildOf(i)], childMax[rightChildOf(i)]); } return solve(n, 1, childMax) + solve(n, 2, childMax); }}; 一行流1inline int leftChildOf(int node) { return ((node + 1) &lt;&lt; 1) - 1; } inline int rightChildOf(int node) { return ((node + 1) &lt;&lt; 1); } inline int parentOf(int node) { return ((node + 1) &gt;&gt; 1) - 1; } class Solution { int solve(int n, int node, vector&lt;int&gt;&amp; childMax) { return childMax[parentOf(node)] - childMax[node] + (leftChildOf(node) &lt; n ? solve(n, leftChildOf(node), childMax) + solve(n, rightChildOf(node), childMax) : 0);} public: int minIncrements(int n, vector&lt;int&gt;&amp; cost) { vector&lt;int&gt; pathSum(n), childMax(n); pathSum[0] = cost[0]; for(int i = 1; i &lt; n; i++) pathSum[i] = cost[i] + pathSum[parentOf(i)]; for(int i = n-1; i &gt;= n/2; i--) childMax[i] = pathSum[i]; for(int i = n/2 - 1; i &gt;= 0; i--) childMax[i] = max(childMax[leftChildOf(i)], childMax[rightChildOf(i)]); return solve(n, 1, childMax) + solve(n, 2, childMax); }}; 2487. 从链表中移除节点单调栈12345678910111213141516171819202122class Solution {public: ListNode* removeNodes(ListNode* head) { ListNode dummy, *move = head; stack&lt;ListNode*&gt; monoStack; monoStack.push(&amp;dummy); while(move) { while(!monoStack.empty() &amp;&amp; monoStack.top()-&gt;val &lt; move-&gt;val) { monoStack.pop(); } monoStack.push(move); move = move-&gt;next; } while(!monoStack.empty()) { ListNode *node = monoStack.top(); monoStack.pop(); node-&gt;next = dummy.next; dummy.next = node; } return dummy.next; }}; 不用stack123456789101112131415161718192021222324252627class Solution {public: ListNode* removeNodes(ListNode* head) { ListNode dummy, *move = head; int len = 0; while(move) { while(dummy.next != nullptr &amp;&amp; dummy.next-&gt;val &lt; move-&gt;val) { dummy.next = dummy.next-&gt;next; len--; } ListNode *tmp = move-&gt;next; move-&gt;next = dummy.next; dummy.next = move; move = tmp; len++; } move = dummy.next; dummy.next = nullptr; while(len--) { ListNode *node = move-&gt;next; move-&gt;next = dummy.next; dummy.next = move; move = node; } return dummy.next; }}; 2397. 被列覆盖的最多行数状态压缩1234567891011121314151617181920212223242526272829303132333435class Solution { int m, n, ans = 0; vector&lt;int&gt; row; void checker(int x) { int cnt = 0; for(int i = 0; i &lt; m; i++) { if((row[i] &amp; ~x) == 0) cnt++; } ans = max(ans, cnt); } int toInt(vector&lt;int&gt;&amp; vec, int len) { int x = 0; for(int i = 0; i &lt; len; i++) { x &lt;&lt;= 1; x += vec[i]; } return x; }public: int maximumRows(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int numSelect) { m = matrix.size(), n = matrix[0].size(); vector&lt;int&gt; vec(n); fill(vec.rbegin(), vec.rbegin() + numSelect, 1); for(int i = 0; i &lt; m; i++) { row.push_back(toInt(matrix[i], n)); } for(int x = 0; x &lt; (1 &lt;&lt; n); x++) { if (__builtin_popcount(x) != numSelect) { continue; } checker(x); } return ans; }}; 全排列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution { int toInt(vector&lt;int&gt;&amp; vec, int len) { int x = 0; for(int i = 0; i &lt; len; i++) { x &lt;&lt;= 1; x += vec[i]; } return x; } int setZero(int x, int i) { return x &amp; (~(1 &lt;&lt; i)); } int setOne(int x, int i) { return x | (1 &lt;&lt; i); } int swap(int x, int i, int j) { int a = (x &gt;&gt; i) &amp; 1; int b = (x &gt;&gt; j) &amp; 1; x = a ? setOne(x, j) : setZero(x, j); x = b ? setOne(x, i) : setZero(x, i); return x; } bool swapOK(int x, int i, int n) { int lastBit = (x &amp; (1 &lt;&lt; (n-1))) &gt;&gt; (n-1); for(int j = i; j &lt; n-1; j++) { if(((x &amp; (1 &lt;&lt; j)) &gt;&gt; j) == lastBit) return false; } return true; } void permutation(int x, int j, int n, function&lt;void(int)&gt; checker) { if(j == n-1) { checker(x); return; } for(int i = j; i &lt; n; i++) { if(!swapOK(x, j, i+1)) continue; x = swap(x, i, j); permutation(x, j + 1, n, checker); x = swap(x, i, j); } }public: int maximumRows(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int numSelect) { int m = matrix.size(), n = matrix[0].size(), ans = 0; vector&lt;int&gt; row(m), vec(n); fill(vec.rbegin(), vec.rbegin() + numSelect, 1); for(int i = 0; i &lt; m; i++) { row[i] = toInt(matrix[i], n); } auto checker = [&amp;row, &amp;m, &amp;ans](int x) { int cnt = 0; for(int i = 0; i &lt; m; i++) { if((row[i] &amp; ~x) == 0) cnt++; } ans = max(ans, cnt); }; permutation(toInt(vec, n), 0, n, checker); return ans; }}; 2581. 统计可能的树根数目 看题解的思路 树形dp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution { vector&lt;vector&lt;int&gt;&gt; g; vector&lt;unordered_set&lt;int&gt;&gt; guessesGraph; vector&lt;bool&gt; visited; int k, ans = 0; void dfs(int root, int cnt) { if(cnt &gt;= k) ans++; visited[root] = true; for(int child : g[root]) { if(visited[child]) continue; int newCnt = cnt; if(guessesGraph[root].count(child)) { newCnt--; } if(guessesGraph[child].count(root)) { newCnt++; } dfs(child, newCnt); } }public: int rootCount(vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;vector&lt;int&gt;&gt;&amp; guesses, int k) { int n = edges.size() + 1; this-&gt;k = k; g = vector&lt;vector&lt;int&gt;&gt;(n); guessesGraph = vector&lt;unordered_set&lt;int&gt;&gt;(n); for(auto&amp; edge : edges) { g[edge[0]].push_back(edge[1]); g[edge[1]].push_back(edge[0]); } visited = vector&lt;bool&gt;(n, false); vector&lt;int&gt; parent(n, -1); queue&lt;int&gt; q; q.push(0); while(!q.empty()) { int node = q.front(); q.pop(); visited[node] = true; for(int child : g[node]) { if(visited[child]) continue; parent[child] = node; q.push(child); } } int cnt = 0; for(auto&amp; guesse:guesses) { if(guesse[0] == parent[guesse[1]]) cnt++; guessesGraph[guesse[0]].insert(guesse[1]); } fill(visited.begin(), visited.end(), false); dfs(0, cnt); return ans; }}; 1944. 队列中可以看到的人数 还好，就是单调栈的简单应用1234567891011121314151617181920class Solution {public: vector&lt;int&gt; canSeePersonsCount(vector&lt;int&gt;&amp; heights) { int n = heights.size(); vector&lt;int&gt; ans(n); stack&lt;int&gt; monoStack; for(int i = 0; i &lt; n; i++) { while(!monoStack.empty() &amp;&amp; heights[monoStack.top()] &lt; heights[i]) { int top = monoStack.top(); monoStack.pop(); ans[top]++; } if(!monoStack.empty()) { ans[monoStack.top()]++; } monoStack.push(i); } return ans; }}; 2807. 在链表中插入最大公约数1234567891011class Solution {public: ListNode* insertGreatestCommonDivisors(ListNode* head) { ListNode* move = head; while(move-&gt;next) { move-&gt;next = new ListNode(gcd(move-&gt;val, move-&gt;next-&gt;val), move-&gt;next); move = move-&gt;next-&gt;next; } return head; }}; 383. 赎金信12345678910111213class Solution {public: bool canConstruct(string ransomNote, string magazine) { int cnt[26] = {0}; for(char c : magazine) { cnt[c - 'a']++; } for(char c : ransomNote) { if(cnt[c - 'a']-- == 0) return false; } return true; }}; 447. 回旋镖的数量123456789101112131415161718192021222324class Solution {public: int numberOfBoomerangs(vector&lt;vector&lt;int&gt;&gt;&amp; points) { int n = points.size(); vector&lt;unordered_map&lt;int, int&gt;&gt; data(n); for(int i = 0; i &lt; n; i++) { for(int j = i + 1; j &lt; n; j++) { int distance = (points[i][0] - points[j][0])*(points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]); data[i][distance]++; data[j][distance]++; } } int ans = 0; for(int i = 0; i &lt; n; i++) { for(auto ite = data[i].begin(); ite != data[i].end(); ite++) { ans += ite-&gt;second * (ite-&gt;second - 1); } } return ans; }}; 2707. 字符串中的额外字符 很常规的dp123456789101112131415161718class Solution {public: int minExtraChar(string s, vector&lt;string&gt;&amp; dictionary) { int len = s.length(); unordered_set&lt;string&gt; dict; for(auto&amp; d : dictionary) { dict.insert(d); } vector&lt;int&gt; dp(len + 1, INT_MAX); dp[0] = 0; for(int i = 1; i &lt;= len; i++) { for(int j = 0; j &lt; i; j++) { dp[i] = min(dp[j] + (dict.count(s.substr(j, i - j)) ? 0 : i-j), dp[i]); } } return dp[len]; }}; 2696. 删除子串后的字符串最小长度 括号匹配的思路 123456789101112131415161718class Solution {public: int minLength(string s) { int length = s.length(); stack&lt;char&gt; stk; for(int i = 0; i &lt; length; i++) { if(!stk.empty()) { char top = stk.top(); if((top == 'A' &amp;&amp; s[i] == 'B') || (top == 'C' &amp;&amp; s[i] == 'D')) { stk.pop(); continue; } } stk.push(s[i]); } return stk.size(); }}; 2645. 构造有效字符串的最少插入数1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: int addMinimum(string word) { int len = word.length(); int ans = 0; for(int i = 0; i &lt; len; i++) { switch(word[i]) { case 'a' : { if(!(i + 1 &lt; len &amp;&amp; word[i+1] == 'b')) { ans++; } else { i++; } if(!(i + 1 &lt; len &amp;&amp; word[i+1] == 'c')) { ans++; } else { i++; } } break; case 'b' : { ans++; if(!(i + 1 &lt; len &amp;&amp; word[i+1] == 'c')) { ans++; } else { i++; } } break; case 'c' : { ans += 2; } break; } } return ans; }}; 2085. 统计出现过一次的公共字符串1234567891011121314151617class Solution {public: int countWords(vector&lt;string&gt;&amp; words1, vector&lt;string&gt;&amp; words2) { unordered_map&lt;string, int&gt; cnt1, cnt2; int ans = 0; for(auto&amp; s : words1) { cnt1[s]++; } for(auto&amp; s : words2) { cnt2[s]++; } for(auto ite = cnt1.begin(); ite != cnt1.end(); ite++) { if(ite-&gt;second == 1 &amp;&amp; cnt2[ite-&gt;first] == 1) ans++; } return ans; }}; 2182. 构造限制重复的字符串1234567891011121314151617181920212223242526class Solution {public: string repeatLimitedString(string s, int repeatLimit) { int cnt[26] = {0}; string ans; for(char c : s) { cnt[c - 'a']++; } char cur = 'z' - 'a', next; while(cur &gt;= 0) { while(cur &gt;= 0 &amp;&amp; cnt[cur] == 0) cur--; if(cur &lt; 0) break; next = cur - 1; while(next &gt;= 0 &amp;&amp; cnt[next] == 0) next--; int cost = min(cnt[cur], repeatLimit); cnt[cur] -= cost; ans += string(cost, cur + 'a'); if(cnt[cur] &gt; 0) { if(next &lt; 0) break; ans += next + 'a'; cnt[next]--; } } return ans; }}; 83. 删除排序链表中的重复元素123456789101112131415class Solution {public: ListNode* deleteDuplicates(ListNode* head) { if(!head) return nullptr; ListNode *move = head; while(move-&gt;next) { if(move-&gt;val == move-&gt;next-&gt;val) { move-&gt;next = move-&gt;next-&gt;next; } else { move = move-&gt;next; } } return head; }}; 82. 删除排序链表中的重复元素 II1234567891011121314151617181920class Solution {public: ListNode* deleteDuplicates(ListNode* head) { if(!head) return nullptr; ListNode dummy(0, head), *move = &amp;dummy; while(move-&gt;next &amp;&amp; move-&gt;next-&gt;next) { if(move-&gt;next-&gt;val == move-&gt;next-&gt;next-&gt;val) { ListNode *cur = move-&gt;next; while(cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val) { cur = cur-&gt;next; } cur = cur-&gt;next; move-&gt;next = cur; } else { move = move-&gt;next; } } return dummy.next; }}; 2368. 受限条件下可到达节点的数目dfs 我的评价是，平平无奇 123456789101112131415161718192021222324class Solution {public: int reachableNodes(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;int&gt;&amp; restricted) { vector&lt;vector&lt;int&gt;&gt; g(n); vector&lt;bool&gt; restricted_map(n, false); int ans = 0; for(int i = 0; i &lt; n-1; i++) { g[edges[i][0]].push_back(edges[i][1]); g[edges[i][1]].push_back(edges[i][0]); } for(int rest_node : restricted) { restricted_map[rest_node] = true; } function&lt;void(int,int)&gt; visitTree = [&amp;](int grandpa, int father) { ans++; for(int child : g[father]) { if(restricted_map[child] || child == grandpa) continue; visitTree(father, child); } }; visitTree(-1, 0); return ans; }}; 非递归dfs12345678910111213141516171819202122232425262728class Solution {public: int reachableNodes(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;int&gt;&amp; restricted) { vector&lt;vector&lt;int&gt;&gt; g(n); vector&lt;bool&gt; restricted_map(n, false); int ans = 0; for(int i = 0; i &lt; n-1; i++) { g[edges[i][0]].push_back(edges[i][1]); g[edges[i][1]].push_back(edges[i][0]); } for(int rest_node : restricted) { restricted_map[rest_node] = true; } queue&lt;pair&lt;int, int&gt;&gt; q; q.emplace(-1, 0); while(!q.empty()) { auto [parent, node] = q.front(); q.pop(); ans++; for(int child : g[node]) { if(restricted_map[child] || child == parent) continue; q.emplace(node, child); } } return ans; }}; 并查集1234567891011121314151617181920212223242526272829303132333435class Solution { class UFDSet { vector&lt;int&gt; vec; public: UFDSet(int n) : vec(n) { iota(vec.begin(), vec.end(), 0); } int find(int x) { return vec[x] == x ? x : (vec[x] = find(vec[x])); } void Union(int x, int y) { vec[find(x)] = find(y); } };public: int reachableNodes(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;int&gt;&amp; restricted) { int ans = 0; UFDSet ufdSet(n); vector&lt;bool&gt; isRestricted(n, false); for(int restricted_node : restricted) { isRestricted[restricted_node] = true; } for(int i = 0; i &lt; n-1; i++) { if(!isRestricted[edges[i][0]] &amp;&amp; !isRestricted[edges[i][1]]) ufdSet.Union(edges[i][0], edges[i][1]); } for(int i = 0; i &lt; n; i++) { if(ufdSet.find(0) == ufdSet.find(i)) { ans++; } } return ans; }}; 238. 除自身以外数组的乘积 虽然但是，空间O(1)不是应该原地修改吗？ 12345678910111213141516class Solution {public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; res(n, 1); for(int i = n-2; i &gt;= 0; i--) { res[i] = nums[i+1] * res[i+1]; } int left = 1; for(int i = 0; i &lt; n; i++) { res[i] *= left; left *= nums[i]; } return res; }}; 225. 用队列实现栈1234567891011121314151617181920212223242526272829303132class MyStack { queue&lt;int&gt; q; int len;public: MyStack() : len(0) { } void push(int x) { q.push(x); for(int i = 0; i &lt; len; i++) { q.push(q.front()); q.pop(); } len++; } int pop() { int ret = q.front(); q.pop(); len--; return ret; } int top() { return q.front(); } bool empty() { return len == 0; }};","link":"/home/2024/02/23/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9332/"},{"title":"LeetCode-单调栈","text":"739. 每日温度 简单，通过单调栈，弹出栈中小于当前元素的元素，可以找到弹出元素的第一个大于其的位置 1234567891011121314151617class Solution {public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) { stack&lt;int&gt; monoStk; int len = temperatures.size(); vector&lt;int&gt; res(len); for(int i = 0; i &lt; len; i++) { while(!monoStk.empty() &amp;&amp; temperatures[monoStk.top()] &lt; temperatures[i]) { int top = monoStk.top(); res[top] = i - top; monoStk.pop(); } monoStk.push(i); } return res; }}; 42. 接雨水AC1思路 构造了一个这样的测试用例1234vector&lt;int&gt; testcase = {3,2,1,0,1,2,1,0,1,3};// | |// | | | |// | | | _ | | | _ | | 如果构造一个递增的栈，那么栈顶元素比我大时，就要把他们全弹出，显然不合理 构造一个递减的栈，从栈顶弹出小于当前长度的元素，那么被弹出的区间内能装水的最大量就是min(i, top) - height[j] 这样虽然用了单调栈，但复杂度还是高 代码12345678910111213141516171819202122232425262728293031class Solution {public: int trap(vector&lt;int&gt;&amp; height) { int len = height.size(); stack&lt;int&gt; monoStk; vector&lt;int&gt; rain(len, 0); for(int i = 0; i &lt; len; i++) { int top = len; while(!monoStk.empty() &amp;&amp; height[monoStk.top()] &lt; height[i]) { top = monoStk.top(); monoStk.pop(); } if(!monoStk.empty()) top = monoStk.top(); for(int j = top; j &lt; i; j++) { rain[j] = min(height[top], height[i]); } monoStk.push(i); } int rainSum = 0; for(int i = 0; i &lt; len; i++) { if(rain[i] &gt; height[i]) { rainSum += rain[i] - height[i]; } } return rainSum; }};// | |// | | | |// | | | _ | | | _ | | 优化 如何在弹栈过程中计算接水量呢 i把x弹出后，此时top（若存在）与i就是两个墙壁，取其最小值，减去被弹栈元素的高度，乘以宽度，就是两个墙壁之间的储水量 如果有更高的两面墙将其包围，由于单调栈的性质，计算的是墙与被弹元素的差值，不会重复计算底部的雨水 123456789101112131415161718192021222324class Solution {public: int trap(vector&lt;int&gt;&amp; height) { int len = height.size(); int rainSum = 0; stack&lt;int&gt; monoStk; for(int i = 0; i &lt; len; i++) { int top = len; while(!monoStk.empty() &amp;&amp; height[monoStk.top()] &lt; height[i]) { top = monoStk.top(); monoStk.pop(); if (monoStk.empty()) { break; } int left = monoStk.top(); int currWidth = i - left - 1; int currHeight = min(height[left], height[i]) - height[top]; rainSum += currWidth * currHeight; } monoStk.push(i); } return rainSum; }}; 456. 132 模式思路 已知这道题用单调栈，但是构造递增的栈还是递减栈呢，so hard to tell 通过尝试，最后使用递减栈 将小于当前元素的所有栈內元素弹出后，如果栈内还存在元素，则满足nums[k] &lt; nums[j] (当前元素是nums[k]) 现在只要保证nums[j]左侧存在元素nums[i] &lt; nums[k]，开一个数组保存当前最小值即可 ac代码123456789101112131415161718192021222324class Solution {public: bool find132pattern(vector&lt;int&gt;&amp; nums) { int len = nums.size(); stack&lt;int&gt; monoStack; vector&lt;int&gt; minArr(len + 1, INT_MAX); for(int i = 1; i &lt;= len; i++) { minArr[i] = min(minArr[i-1], nums[i-1]); } for(int i = 0; i &lt; len; i++) { while(!monoStack.empty() &amp;&amp; nums[monoStack.top()] &lt;= nums[i]) { monoStack.pop(); } if(!monoStack.empty()) { int top = monoStack.top(); if(nums[i] &gt; minArr[top]) { return true; } } monoStack.push(i); } return false; }}; 581. 最短无序连续子数组思路 创建一个单调递增栈，当有元素被弹出时，说明后面的元素被放到前面了，当前元素下标和栈顶元素下标需要被排序 由于题目要求一个最大的连续子数组，所以要求下标的最大范围 对于特殊情况，即数组中有连续相等的数字时，需要判断这些元素是否也需要参与排序，即增大子数组的范围 需要记录被弹出元素的最大值，如果小于它，则需要参与排序。 代码12345678910111213141516171819202122class Solution {public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) { stack&lt;int&gt; monoStk; int len = nums.size(), l = len, r = -1; int maxPop = INT_MIN; for(int i = 0; i &lt; len; i++) { while(!monoStk.empty() &amp;&amp; nums[monoStk.top()] &gt; nums[i]) { l = min(l, monoStk.top()); r = i; maxPop = max(maxPop, nums[monoStk.top()]); monoStk.pop(); } monoStk.push(i); } while(!monoStk.empty()) { if(nums[monoStk.top()] &lt; maxPop) r = max(r, monoStk.top()); monoStk.pop(); } return max(r - l + 1, 0); }}; 654. 最大二叉树笨蛋做法1234567891011class Solution {public: TreeNode* constructMaximumBinaryTree(vector&lt;int&gt; nums) { if(nums.size() == 0) return nullptr; auto max_ite = max_element(nums.begin(), nums.end()); TreeNode *node = new TreeNode(*max_ite); node-&gt;left = constructMaximumBinaryTree({nums.begin(), max_ite}); node-&gt;right = constructMaximumBinaryTree({++max_ite, nums.end()}); return node; }}; 笨蛋方法2123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: TreeNode* constructMaximumBinaryTree(vector&lt;int&gt; nums) { int len = nums.size(); auto cmp = [&amp;nums](int i, int j) { return nums[i] &lt; nums[j]; }; priority_queue&lt;int, vector&lt;int&gt;, decltype(cmp)&gt; q(cmp); for(int i = 0; i &lt; len; i++) { q.push(i); } map&lt;TreeNode*, int&gt; m; TreeNode *root = nullptr; if(!q.empty()) { int top = q.top(); root = new TreeNode(nums[top]); m[root] = top; q.pop(); } while(!q.empty()) { int top = q.top(); q.pop(); TreeNode *node = root, *p = nullptr; while(node) { p = node; if(m[node] &lt; top) { node = node-&gt;right; } else { node = node-&gt;left; } } if(p) { TreeNode *tmp = new TreeNode(nums[top]); m[tmp] = top; if(m[p] &lt; top) { p-&gt;right = tmp; } else { p-&gt;left = tmp; } } } return root; }}; 单调栈思路 [3,2,1,6,0,5] 观察这个测试用例生成的二叉树 如果构造一个递减的单调栈，在6进入前，从栈顶开始栈內元素依次为 [1,2,3] 6入栈时，会将他们三个弹出，他们三个刚好依次为下一个的右子树 6入栈后，被弹出的最后一个元素为6的左子树 观察6的右子树，发现也满足这个规律 尝试利用这个规律编码，果然对了！！哈哈，开心 代码1234567891011121314151617181920212223242526class Solution {public: TreeNode* constructMaximumBinaryTree(vector&lt;int&gt; nums) { nums.push_back(INT_MAX); int len = nums.size(); stack&lt;int&gt; monoStack; vector&lt;TreeNode *&gt; nodes(len); for(int i = 0; i &lt; len; i++) { nodes[i] = new TreeNode(nums[i]); } for(int i = 0; i &lt; len; i++) { int top = len; while(!monoStack.empty() &amp;&amp; nums[monoStack.top()] &lt; nums[i]) { top = monoStack.top(); monoStack.pop(); if(!monoStack.empty() &amp;&amp; nums[monoStack.top()] &lt; nums[i]) { nodes[monoStack.top()]-&gt;right = nodes[top]; } } if(top &lt; len) nodes[i]-&gt;left = nodes[top]; monoStack.push(i); } TreeNode *root = nodes.back(); return root-&gt;left; }}; 769. 最多能完成排序的块 wow amazing！^v^ 12345678910111213141516class Solution {public: int maxChunksToSorted(vector&lt;int&gt;&amp; arr) { int len = arr.size(), ret = 0; stack&lt;int&gt; monoStack; for(int i = 0; i &lt; len; i++) { int top = !monoStack.empty() &amp;&amp; monoStack.top() &gt; arr[i] ? monoStack.top() : -1; while(!monoStack.empty() &amp;&amp; monoStack.top() &gt; arr[i]) { monoStack.pop(); } if(top != -1) monoStack.push(top); else monoStack.push(arr[i]); } return monoStack.size(); }}; 768. 最多能完成排序的块 II yes, yes, yes, you no 看错，和上一题相同的代码 amazing! wow! ^v^# 12345678910111213141516class Solution {public: int maxChunksToSorted(vector&lt;int&gt;&amp; arr) { int len = arr.size(), ret = 0; stack&lt;int&gt; monoStack; for(int i = 0; i &lt; len; i++) { int top = !monoStack.empty() &amp;&amp; monoStack.top() &gt; arr[i] ? monoStack.top() : -1; while(!monoStack.empty() &amp;&amp; monoStack.top() &gt; arr[i]) { monoStack.pop(); } if(top != -1) monoStack.push(top); else monoStack.push(arr[i]); } return monoStack.size(); }}; 901. 股票价格跨度 我太聪明啦，几分钟就写出来啦 创建一个递减栈，将小于它的数全都弹出，此时与栈顶的距离就是span 1234567891011121314151617181920212223242526class StockSpanner { stack&lt;pair&lt;int, int&gt;&gt; monoStack; int day = 0;public: StockSpanner() { } int next(int price) { day++; while(!monoStack.empty() &amp;&amp; monoStack.top().second &lt;= price) { monoStack.pop(); } int span = day; if(!monoStack.empty()) { span = day - monoStack.top().first; } monoStack.emplace(day, price); return span; }};/** * Your StockSpanner object will be instantiated and called as such: * StockSpanner* obj = new StockSpanner(); * int param_1 = obj-&gt;next(price); */ 907. 子数组的最小值之和单调栈 我真聪明！！！！！ 用单调栈找到当前元素左右两侧第一个比他小的元素位置，分别记录到left[i], right[i] 由元素arr[i]为最小值的子数组个数为 (right[i] - i + 1l) * (i - left[i] + 1l) 由于构造的是递减栈，为了防止世界被破坏比被弹出元素更大的元素已经被弹出了，赋值时使用被弹出元素的left/right 1234567891011121314151617181920212223242526272829303132class Solution { static constexpr int MOD = 1000000007;public: int sumSubarrayMins(vector&lt;int&gt;&amp; arr) { stack&lt;int&gt; monoStack; int len = arr.size(); int res = 0; vector&lt;int&gt; left(len), right(len, len - 1); for(int i = 0; i &lt; len; i++) { left[i] = right[i] = i; while(!monoStack.empty() &amp;&amp; arr[monoStack.top()] &gt;= arr[i]) { int top = monoStack.top(); left[i] = left[top]; monoStack.pop(); } monoStack.push(i); } monoStack = move(stack&lt;int&gt;()); for(int i = len - 1; i &gt;= 0; i--) { while(!monoStack.empty() &amp;&amp; arr[monoStack.top()] &gt; arr[i]) { int top = monoStack.top(); right[i] = right[top]; monoStack.pop(); } monoStack.push(i); } for(int i = 0; i &lt; len; i++) { res = (res + (right[i] - i + 1l) * (i - left[i] + 1l) * arr[i]) % MOD; } return res; }}; 2865. 美丽塔 I这道题与2866. 美丽塔 II相同，只是数据规模更小一点，当时用枚举山峰做的，这次用单调栈 思路 根据提示，每一个位置都有可能是山峰（其实只有局部最大值有可能），那么假设i为山峰时，要计算出总和，需要三个数据： i左侧上升的最大和 i右侧下降（反过来看也是上升）的最大和 i的最大值 将以上三个值相加，就是最终结果 所以需要两个数据，存放所有i对应的左侧山坡最大和，右侧山峰最大和 使用单调栈的思想，创建一个递增栈，当栈顶元素大于当前元素时，弹出其中元素 将数组想想成一座座山峰 如果当前元素没有弹出栈中元素，说明当前处于上升阶段，那么其左侧/右侧的最大和就可以是左侧/右侧的元素的值 如果弹出了元素，且栈被弹空了，说明当前元素是从左/右开始到当前最小的元素，那么到目前为止的所有元素都只能取最小值 如果弹出了元素，且栈没有被弹空，当前栈顶元素就是当前元素与其之间能建造的最大值，都取该栈顶元素建造塔，就能满足这个区间内的和最大，而且由于是递增栈，取栈顶元素为这个区间的值也不会破坏山脉的递增/递减性质，那么这个区间的和加上栈顶元素的高度和栈顶元素之和的最大和，就是到当前元素的最大和 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution { int monoStack[1000 + 1]; int stackPtr; void initStack() { stackPtr = 0; } int pop() { return monoStack[--stackPtr]; } int top() { return monoStack[stackPtr - 1]; } void push(int val) { monoStack[stackPtr++] = val; } bool empty() { return stackPtr == 0; }public: long long maximumSumOfHeights(vector&lt;int&gt;&amp; maxHeights) { int len = maxHeights.size(); long long ans = INT_MIN; vector&lt;long long&gt; leftHill(len), rightHill(len); initStack(); for(int i = 0; i &lt; len; i++) { int topVal = len; while(!empty() &amp;&amp; maxHeights[top()] &gt; maxHeights[i]) { topVal = pop(); } if(empty()) leftHill[i] = (i + 0ll) * maxHeights[i] + leftHill[0]; else if(topVal &lt; len) leftHill[i] = (i - top() - 1ll) * maxHeights[i] + maxHeights[top()] + leftHill[top()]; else if(i &gt; 0) leftHill[i] = leftHill[i-1] + maxHeights[i-1]; push(i); } initStack(); for(int i = len - 1; i &gt;= 0; i--) { int topVal = len; while(!empty() &amp;&amp; maxHeights[top()] &gt; maxHeights[i]) { topVal = pop(); } if(empty()) rightHill[i] = (len - 1ll - i) * maxHeights[i] + rightHill[len - 1]; else if(topVal &lt; len) rightHill[i] = (top() - i - 1ll) * maxHeights[i] + maxHeights[top()] + rightHill[top()]; else if(i &lt; len - 1) rightHill[i] = rightHill[i+1] + maxHeights[i+1]; push(i); ans = max(ans, leftHill[i] + rightHill[i] + maxHeights[i]); } return ans; }}; 496. 下一个更大元素 I emm，其实就是找nums2中每个元素右侧第一个比它大的元素，只是要映射到nums1中 需求真的很绕，看清这一点这题就很简单，用一个map映射元素到nums1中的下标即可 123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { unordered_map&lt;int, int&gt; m; int len1 = nums1.size(), len2 = nums2.size(); vector&lt;int&gt; monoStack(len2), ret(len1, -1); int stackPtr = 0; for(int i = 0; i &lt; len1; i++) { m[nums1[i]] = i; } for(int i = 0; i &lt; len2; i++) { while(stackPtr &gt; 0 &amp;&amp; nums2[monoStack[stackPtr - 1]] &lt; nums2[i]) { int top = monoStack[stackPtr - 1]; if(m.count(nums2[top])) { int index = m[nums2[top]]; ret[index] = nums2[i]; } stackPtr--; } monoStack[stackPtr++] = i; } return ret; }}; 503. 下一个更大元素 II这个比上一题更简单了？只是多一个需要循环比较而已根据以前的经验，需要循环寻找的一般可以将数组扩大一倍，并复制一份 12345678910111213141516171819202122class Solution {public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) { int len = nums.size(); vector&lt;int&gt; monoStack(2*len), ret(len, -1); nums.resize(2*len); for(int i = 0; i &lt; len; i++) { nums[i+len] = nums[i]; } int stackPtr = 0; for(int i = 0; i &lt; 2*len; i++) { while(stackPtr &gt; 0 &amp;&amp; nums[monoStack[stackPtr - 1]] &lt; nums[i]) { int top = monoStack[stackPtr - 1]; if(top &gt;= len) top -= len; ret[top] = nums[i]; stackPtr--; } monoStack[stackPtr++] = i; } return ret; }}; 1019. 链表中的下一个更大节点 没意思，链表 12345678910111213141516171819class Solution {public: vector&lt;int&gt; nextLargerNodes(ListNode* head) { stack&lt;pair&lt;int, int&gt;&gt; monoStack; vector&lt;int&gt; res; int index = 0; while(head) { res.push_back(0); while(!monoStack.empty() &amp;&amp; monoStack.top().first &lt; head-&gt;val) { res[monoStack.top().second] = head-&gt;val; monoStack.pop(); } monoStack.emplace(head-&gt;val, index); index++; head = head-&gt;next; } return res; }}; 2454. 下一个更大元素 IV单调栈+小顶堆 构造单调递减栈，当一个数被弹栈时，说明遇到了比他大的第一个数，此时被弹出元素放入一个小顶堆中 每个元素入栈前，先查看小顶堆中有没有比自己小的元素，如果有，则第二个比他大的数就找到了 123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; secondGreaterElement(vector&lt;int&gt;&amp; nums) { int len = nums.size(); vector&lt;int&gt; res(len, -1); stack&lt;int&gt; monoStack; auto cmp = [&amp;nums](int i, int j) { return nums[i] &gt; nums[j]; }; priority_queue&lt;int, vector&lt;int&gt;, decltype(cmp)&gt; monoQueue(cmp); for(int i = 0; i &lt; len; i++) { while(!monoQueue.empty() &amp;&amp; nums[monoQueue.top()] &lt; nums[i]) { int top1 = monoQueue.top(); monoQueue.pop(); res[top1] = nums[i]; } while(!monoStack.empty() &amp;&amp; nums[monoStack.top()] &lt; nums[i]) { int top = monoStack.top(); monoStack.pop(); monoQueue.push(top); } monoStack.push(i); } return res; }}; 单调栈+栈 其实不必用小顶堆，被弹出的元素反序插入另一个栈即可 1234567891011121314151617181920212223242526272829303132333435363738394041int init_io = []() { cin.tie(nullptr)-&gt;sync_with_stdio(false); return 0;}();class Solution { class Stack { // 用数组，快一点 int stack[100000 + 1] = {0}; int stackPtr = 0; public: Stack() { } Stack(size_t len, int val) { if(len &gt; 0) fill(stack, stack + len, val); } void clear() { stackPtr = 0; } bool empty() { return stackPtr == 0; } int top() { return stack[stackPtr - 1]; } int pop() { return stack[--stackPtr]; } void push(int val) { stack[stackPtr++] = val; } int ptr() { return stackPtr; } int get(int index) { return stack[index]; } };public: vector&lt;int&gt; secondGreaterElement(vector&lt;int&gt;&amp; nums) { int len = nums.size(); vector&lt;int&gt; res(len, -1); Stack monoStack; Stack seen; for(int i = 0; i &lt; len; i++) { while(!seen.empty() &amp;&amp; nums[seen.top()] &lt; nums[i]) res[seen.pop()] = nums[i]; int ptr = monoStack.ptr(); while(!monoStack.empty() &amp;&amp; nums[monoStack.top()] &lt; nums[i]) monoStack.pop(); for(int j = monoStack.ptr(); j &lt; ptr; j++) seen.push(monoStack.get(j)); monoStack.push(i); } return res; }}; 85. 最大矩形转化为单调栈问题 直接在图内搜索矩形的复杂度是m*m*n*n 可以计算每个点(i, j)的右侧有几个连续的1 对于某一列，右侧分别有[2,3,1]个连续的1，那么可能的矩形为2, 3, 1, 2+2, 1+1+1 构建一个递增栈，弹出所有大于当前元素的值后，以当前元素为高度的矩形就确定了 每个点入栈后，栈內元素是递增的，计算两两之间形成的矩形面积 复杂度O(n*m*m) 思路112345678910111213141516171819202122232425262728293031323334353637383940class Solution {public: int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) { int m = matrix.size(), n = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; left1Cnt(m, vector&lt;int&gt;(n, 0)); for(int i = 0; i &lt; m; i++) { left1Cnt[i][n - 1] = matrix[i][n - 1] - '0'; for(int j = n - 2; j &gt;= 0; j--) { if(matrix[i][j] == '1') left1Cnt[i][j] = 1 + left1Cnt[i][j+1]; } } int ret = INT_MIN; for(int j = 0; j &lt; n; j++) { vector&lt;int&gt; monoStack(m); vector&lt;int&gt; left(m, 0); int stackPtr = 0; int minCnt = INT_MAX; for(int i = 0; i &lt; m; i++) { int top = -1; left[i] = i; minCnt = min(minCnt, left1Cnt[i][j]); ret = max(ret, (i + 1) * minCnt); while(stackPtr != 0 &amp;&amp; left1Cnt[monoStack[stackPtr - 1]][j] &gt; left1Cnt[i][j]) { top = monoStack[stackPtr - 1]; stackPtr--; } if(top != -1) { ret = max(ret, (i - left[top] + 1) * left1Cnt[i][j]); left[i] = left[top]; } monoStack[stackPtr++] = i; for(int ptr = 0; ptr &lt; stackPtr; ptr++) { ret = max(ret, (i - left[monoStack[ptr]] + 1) * left1Cnt[monoStack[ptr]][j]); } } } return ret; }}; 参考907. 子数组的最小值之和，找到每个节点作为最小值的区间长度，计算矩形面积，取最大值 复杂度,m*n 思路2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) { int m = matrix.size(), n = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; left1Cnt(m, vector&lt;int&gt;(n, 0)); for(int i = 0; i &lt; m; i++) { left1Cnt[i][n - 1] = matrix[i][n - 1] - '0'; for(int j = n - 2; j &gt;= 0; j--) { if(matrix[i][j] == '1') left1Cnt[i][j] = 1 + left1Cnt[i][j+1]; } } int ret = INT_MIN; for(int j = 0; j &lt; n; j++) { vector&lt;int&gt; monoStack(m); vector&lt;int&gt; left(m, 0), right(m, 0); int stackPtr = 0; for(int i = 0; i &lt; m; i++) { int top = -1; while(stackPtr != 0 &amp;&amp; left1Cnt[monoStack[stackPtr - 1]][j] &gt;= left1Cnt[i][j]) { top = monoStack[--stackPtr]; } if(stackPtr == 0) left[i] = i; else { top = monoStack[stackPtr - 1]; left[i] = i - top - 1; } monoStack[stackPtr++] = i; } stackPtr = 0; for(int i = m-1; i &gt;= 0; i--) { int top = -1; while(stackPtr != 0 &amp;&amp; left1Cnt[monoStack[stackPtr - 1]][j] &gt;= left1Cnt[i][j]) { top = monoStack[--stackPtr]; } if(stackPtr == 0) right[i] = m-1 - i; else { top = monoStack[stackPtr - 1]; right[i] = top - i - 1; } monoStack[stackPtr++] = i; } for(int i = 0; i &lt; m; i++) { ret = max(ret, (left[i] + right[i] + 1) * left1Cnt[i][j]); } } return ret; }}; 1504. 统计全 1 子矩形笨蛋栈(两次单调栈) 参考907. 子数组的最小值之和，找到每个节点作为最小值的左右两侧区间长度 以当前元素i为最小值区间范围为[l, r]，则正方形个数是 (r - i + 1) * (i - l + 1) * mat[i][j] 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {public: int numSubmat(vector&lt;vector&lt;int&gt;&gt;&amp; mat) { int m = mat.size(), n = mat[0].size(); int ret = 0; for(int i = 0; i &lt; m; i++) { for(int j = n - 2; j &gt;= 0; j--) { if(mat[i][j]) mat[i][j] = mat[i][j+1] + mat[i][j]; } } vector&lt;int&gt; monoStack(m); vector&lt;int&gt; left(m), right(m); int stackTop = 0; for(int j = 0; j &lt; n; j++) { stackTop = 0; for(int i = 0; i &lt; m; i++) { int top = m; while(stackTop != 0 &amp;&amp; mat[monoStack[stackTop - 1]][j] &gt;= mat[i][j]) { top = monoStack[--stackTop]; } if(top &lt; m) left[i] = left[top]; else if(stackTop != 0) left[i] = i; else left[i] = 0; monoStack[stackTop++] = i; } stackTop = 0; for(int i = m - 1; i &gt;= 0; i--) { int top = m; while(stackTop != 0 &amp;&amp; mat[monoStack[stackTop - 1]][j] &gt; mat[i][j]) { top = monoStack[--stackTop]; } if(top &lt; m) right[i] = right[top]; else if(stackTop != 0) right[i] = i; else right[i] = m-1; monoStack[stackTop++] = i; ret += ((right[i] - i + 1) * (i - left[i] + 1)) * mat[i][j]; } } return ret; }}; 聪明栈(一次单调栈) 题解，看不懂","link":"/home/2023/12/22/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%E4%BD%8D%E5%8D%95%E8%B0%83%E6%A0%88/"},{"title":"LeetCode-8","text":"581. 最短无序连续子数组思路 拷贝把备份排序，然后两个指针，依次从头到尾（i），从尾到头（j）比较排序前后两个数组相同下标的值，把第一次不同的下标值记录，最后返回j - i + 1，如果为负数返回0。 AC代码123456789101112131415161718192021class Solution {public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; cpy(nums.begin(), nums.end()); sort(cpy.begin(), cpy.end()); int len = nums.size(); int j = len - 1, i = 0; for ( ; j &gt;= 0; j--) { if (nums[j] != cpy[j]) { break; } } for (; i &lt; len; i++) { if (nums[i] != cpy[i]) { break; } } int ans = j - i + 1; return ans &gt; 0 ? ans : 0; }}; 思路 从前到后遍历，一边找最大值，一边找当前值是不是最大值，如果不是，记录当前下标 从后向前遍历，一边找最小值，一边找当前值是不是最小值，如果不是，记录当前下标 返回下标之间的元素数，注意差值为0返回1 AC代码1234567891011121314151617181920212223242526static int pr = []() { std::ios::sync_with_stdio(false); cin.tie(NULL); return 0; }();class Solution {public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int j = len - 1, i = 0; int max = INT_MIN, min = INT_MAX; int pre = 0, back = len - 1; for (;i &lt; len;i++, j--) { max = max &gt; nums[i] ? max : nums[i]; if (max != nums[i]) { pre = i; } min = min &lt; nums[j] ? min : nums[j]; if (min != nums[j]) { back = j; } } int ans = pre - back + 1; return ans &gt; 1 ? ans : 0; }}; 大佬思路没看懂,为毛遍历这么多次可以这么快？ 大佬代码12345678910111213141516171819202122232425262728293031static int pr = []() { std::ios::sync_with_stdio(false); cin.tie(NULL); return 0; }();class Solution {public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int left = 0; int right = n - 1; while (left &lt; n - 1 &amp;&amp; nums[left] &lt;= nums[left + 1]) left += 1; if (left == n - 1) return 0; while (right &gt; 0 &amp;&amp; nums[right] &gt;= nums[right - 1]) right -= 1; int min_value = INT32_MAX; int max_value = INT32_MIN; for (int i = left; i &lt; right + 1; i++) { min_value = min(nums[i], min_value); max_value = max(nums[i], max_value); } while (left &gt; -1 &amp;&amp; nums[left] &gt; min_value) left -= 1; while (right &lt; n &amp;&amp; nums[right] &lt; max_value) right += 1; return right - left - 1; }}; 541. 反转字符串 II思路每次反转k或者小于k个字符，然后指针+=2*k AC代码12345678910111213class Solution {public: string reverseStr(string s, int k) { int i = 0; int len = s.length(); while (i &lt; len) { int l = len - i &gt; k ? k : len - i;//每次算长度 reverse(s.begin() + i, s.begin() + i + l); i += 2*k; } return s; }}; 589. N叉树的前序遍历思路 递归 AC代码123456789101112131415161718192021222324252627282930/*// Definition for a Node.class Node {public: int val; vector&lt;Node*&gt; children; Node() {} Node(int _val, vector&lt;Node*&gt; _children) { val = _val; children = _children; }};*/class Solution {public: vector&lt;int&gt; preorder(Node* root) { vector&lt;int&gt; ans; go(root, ans); return ans; } void go(Node* root, vector&lt;int&gt;&amp; v) { if (root == NULL) return; v.push_back(root-&gt;val); for (auto x : root-&gt;children) { go(x, v); } }}; 大佬思路大佬代码123456789101112131415161718192021222324252627282930313233class Solution {public: vector&lt;int&gt; preorder(Node* root) { if (!root) { return vector&lt;int&gt;(); } stack&lt;Node*&gt; s; s.push(root); vector&lt;int&gt; ret; while (!s.empty()) { Node* p = s.top(); s.pop(); ret.push_back(p-&gt;val); int n = (p-&gt;children).size(); for (int i = n - 1; i &gt;= 0; --i) { if (p-&gt;children[i]) { s.push((p-&gt;children)[i]); } } } return ret; }};static auto _ = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); return 0;}(); 590. N叉树的后序遍历AC代码123456789101112131415class Solution {public: vector&lt;int&gt; postorder(Node* root) { vector&lt;int&gt; ans; go(root, ans); return ans; } void go(Node* root, vector&lt;int&gt;&amp; v) { if (root == NULL) return; for (auto x : root-&gt;children) { go(x, v); } v.push_back(root-&gt;val); }}; 598. 范围求和 II思路每次操作，左上角一定是重叠最大的，直接找最小的x，y就可以了 AC代码1234567891011class Solution {public: int maxCount(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; ops) { int minFirst = m, minSecond = n; for (auto x : ops) { minSecond = minSecond &gt; x[1] ? x[1] : minSecond; minFirst = minFirst &gt; x[0] ? x[0] : minFirst; } return minFirst*minSecond; }}; 599. 两个列表的最小索引总和思路 一个map记录第一个数组的下标+1，然后遍历第二个数组，搞一个map，记录下标和对应的餐厅数组 优化，遍历第二个数组的时候，查询，计算下标和，如果下标和小于当前的最小值，那么就clear当前数组，重新把当前这个餐厅push进去，如果等于，直接push餐厅，大于则不管 AC代码12345678910111213141516171819class Solution {public: vector&lt;string&gt; findRestaurant(vector&lt;string&gt;&amp; list1, vector&lt;string&gt;&amp; list2) { unordered_map&lt;string, int&gt; m; map&lt;int, vector&lt;string&gt;&gt; ans; int len1 = list1.size(); int len2 = list2.size(); for (int i = 0; i &lt; len1; i++) { m[list1[i]] = i + 1; } for (int i = 0; i &lt; len2 ; i++) { int pos = m[list2[i]]; if (pos) { ans[pos - 1 + i].push_back(list2[i]); } } return ans.begin()-&gt;second; }}; AC代码（优化）123456789101112131415161718192021222324252627class Solution {public: vector&lt;string&gt; findRestaurant(vector&lt;string&gt;&amp; list1, vector&lt;string&gt;&amp; list2) { unordered_map&lt;string, int&gt; m; vector&lt;string&gt; ans; int len1 = list1.size(); int len2 = list2.size(); int min = INT_MAX; for (int i = 0; i &lt; len1; i++) { m[list1[i]] = i + 1; } for (int i = 0; i &lt; len2 ; i++) { int pos = m[list2[i]]; if (pos) { int sum = pos - 1 + i; if (sum &lt; min) { ans.clear(); min = sum; ans.push_back(list2[i]); } else if (sum == min) { ans.push_back(list2[i]); } } } return ans; }}; 605. 种花问题思路 遍历每一个花盆，看它前后有没有花盆，枚举判断，注意如果n == 0时要退出循环 优化：把第一个和最后一个单独拿出来，简化循环时的判断数目 AC代码1234567891011121314151617181920212223242526272829class Solution {public: bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) { int len = flowerbed.size(); for (int i = 0; i &lt; len &amp;&amp; n &gt; 0; i++) { if (flowerbed[i]) { } else { if (i == 0) { if (len == 1 || (i + 1 &lt; len &amp;&amp; !flowerbed[i + 1])) { n--; flowerbed[i] = 1; } } else if (i == len - 1) { if (i - 1 &gt;= 0 &amp;&amp; !flowerbed[i - 1]) { n--; flowerbed[i] = 1; } } else { if (!flowerbed[i - 1] &amp;&amp; !flowerbed[i + 1]) { n--; flowerbed[i] = 1; } } } } return n == 0; }}; AC代码（优化）12345678910111213141516171819202122232425class Solution {public: bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) { if (n &lt;= 0) return true; int len = flowerbed.size(); if (len &lt;= 0) return false; if (len == 1) return n &lt;= 1 &amp;&amp; !flowerbed[0]; int sum = 0; if (!flowerbed[0] &amp;&amp; !flowerbed[1]) { sum++; flowerbed[0] = 1; } for (int i = 1; i &lt; len - 2; i++) { if (!flowerbed[i] &amp;&amp; !flowerbed[i - 1] &amp;&amp; !flowerbed[i + 1]) { flowerbed[i] = 1; sum++; } } if (!flowerbed[len - 2] &amp;&amp; !flowerbed[len - 1]) { sum++; flowerbed[len - 1] = 1; } return n &lt;= sum; }}; 628. 三个数的最大乘积思路 参考414. 第三大的数的思路，用一次遍历，得到第一，第二第三大的数（a、b、c），和第一，第二小的数（m1，m2） 分别计算$abc$和$am1m2$，返回较大的一个 AC代码123456789101112131415161718192021222324252627class Solution {public: int maximumProduct(vector&lt;int&gt;&amp; nums) { int first = INT_MIN, second = INT_MIN, third = INT_MIN; int min1 = INT_MAX, min2 = INT_MAX; for (auto x : nums) { if (x &gt;= first) { third = second; second = first; first = x; } else if (x &lt; first &amp;&amp; x &gt;= second) { third = second; second = x; } else if (x &lt; second &amp;&amp; x &gt;= third) { third = x; } if (x &lt; min1) { min2 = min1; min1 = x; } else if (x &gt;= min1 &amp;&amp; x &lt; min2) { min2 = x; } } int ans1 = first*second*third, ans2 = first*min1*min2; return ans1 &gt; ans2 ? ans1 : ans2; }}; 633. 平方数之和思路 脑袋里想一个只有整数点的坐标系，取第一象限，用$y = x$分成两半，看一半，包括$y = x$和另一个坐标轴，在这个三角区域里选取的的不会重复 选取点，从0~$\\sqrt{\\frac{c}{2}}$中选整数，如果满足$\\sqrt{c - i^2}$为整数，那么就可以 优化，类似二分查找 AC代码12345678910111213class Solution {public: bool judgeSquareSum(int c) { double n = sqrt(c/2.0); for (int i = 0; i &lt;= n; i++) { double x = sqrt(c - i*i); if (int(x) == x) { return true; } } return false; }}; AC代码（优化）1234567891011121314151617class Solution {public: bool judgeSquareSum(int c) { int a = 0, b = sqrt(c); while (a &lt;= b) { double sum = (double)a*a + b*b; if (sum == c) { return true; } else if (sum &gt; c) { b--; } else { a++; } } return false; }}; 637. 二叉树的层平均值思路改造二叉树的层次遍历的代码完事儿 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;double&gt; averageOfLevels(TreeNode* root) { if (!root) return {}; vector&lt;double&gt; ans; TreeNode *root1 = new TreeNode(0), *root2 = new TreeNode(0); root2-&gt;left = root; root1-&gt;left = root2; TreeNode* temp = root1; vector&lt;TreeNode*&gt; m = {root1}; vector&lt;TreeNode*&gt;&amp; father = m; vector&lt;TreeNode*&gt; fatherTemp; while (father.size()) { fatherTemp.clear(); double sum = 0, count = 0; for (TreeNode* x : father) { if (x-&gt;left != NULL) { fatherTemp.push_back(x-&gt;left); if (x-&gt;left-&gt;left != NULL) { count++; sum += x-&gt;left-&gt;left-&gt;val; } if (x-&gt;left-&gt;right != NULL) { sum += x-&gt;left-&gt;right-&gt;val; count++; } } if (x-&gt;right != NULL) { fatherTemp.push_back(x-&gt;right); if (x-&gt;right-&gt;left != NULL) { sum += x-&gt;right-&gt;left-&gt;val; count++; } if (x-&gt;right-&gt;right != NULL) { sum += x-&gt;right-&gt;right-&gt;val; count++; } } } if (count) ans.push_back(sum/count); father = fatherTemp; } return ans; }}; 643. 子数组最大平均数 I思路先算前k个数的和，然后i从k+1个数开始，把尾巴上的数减掉，上i指向的数，跟当前值比大小，储存最大和。 AC代码123456789101112131415161718192021222324class Solution {public: double findMaxAverage(vector&lt;int&gt;&amp; nums, int k) { int len = nums.size(); int sum = 0; double maxSum = 0; for (int i = 0; i &lt; k; i++) { sum += nums[i]; } maxSum = sum; for (int i = k; i &lt; len; i++) { sum -= nums[i - k]; sum += nums[i]; maxSum = maxSum &gt; sum ? maxSum : sum; } return maxSum*1.0/k; }};static const int _ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0;}(); 645. 错误的集合思路一个vector，初始化为false，一次循环，每出现一个元素，把false变成true，如果已经是true，说明它是重复的元素，同时计算所有元素的和，最后根据等差数列求和公式等一系列计算计算出两个数 AC代码123456789101112131415161718192021class Solution {public: vector&lt;int&gt; findErrorNums(vector&lt;int&gt;&amp; nums) { int n = 0; int sum = 0, len = nums.size(); vector&lt;bool&gt; m(len, false); for (auto x : nums) { if (!m[x])m[x] = true; else n = x; sum += x; } int add = len*(len + 1) / 2 - sum;//相比正常缺少的部分 return {n, n + add}; }};static const int _ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0;}(); 657. 机器人能否返回原点AC代码123456789101112131415161718192021222324class Solution {public: bool judgeCircle(string moves) { int u = 0 ,d = 0 ,r = 0 ,l = 0; for (auto x : moves) { switch(x) { case 'U': u++; break; case 'D' : d++; break; case 'R' : r++; break; case 'L' : l++; break; } } return u == d &amp;&amp; l == r; }};static int desyncio = []() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }(); AC代码（优化）1234567891011121314151617class Solution {public: bool judgeCircle(string moves) { int movex[26] = {0}, movey[26] = {0}; movey['U' - 'A'] = 1; movey['D' - 'A'] = -1; movex['L' - 'A'] = -1; movex['R' - 'A'] = 1; int x = 0, y = 0; for (auto c : moves) { y += movey[c - 'A']; x += movex[c - 'A']; } return x == 0 &amp;&amp; y == 0; }};static int desyncio = []() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }(); 661. 图片平滑器思路暴力干死这破题 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution {public: vector&lt;vector&lt;int&gt;&gt; imageSmoother(vector&lt;vector&lt;int&gt;&gt;&amp; M) { int r = M.size(); int c = M[0].size(); if (r &lt;= 1 &amp;&amp; c &lt;= 1) return M; vector&lt;vector&lt;int&gt;&gt; ans(r, vector&lt;int&gt;(c)); if (c == 1 || r == 1) { if (c == 1) { ans[0][0] = (M[0][0] + M[1][0])/2; ans[r - 1][0] = (M[r - 1][0] + M[r - 2][0])/2; for (int i = 1; i &lt; r - 1; i++) { ans[i][0] = (M[i][0] + M[i - 1][0] + M[i + 1][0])/3; } } else { ans[0][0] = (M[0][0] + M[0][1])/2; ans[0][c - 1] = (M[0][c - 1] + M[0][c - 2])/2; for (int i = 1; i &lt; c - 1; i++) { ans[0][i] = (M[0][i] + M[0][i - 1] + M[0][i + 1])/3; } } return ans; } ans[0][0] = (M[0][0] + M[1][1] + M[1][0] + M[0][1])/4; ans[0][c - 1] = (M[0][c - 1] + M[0][c - 2] + M[1][c - 1] + M[1][c - 2])/4; ans[r - 1][0] = (M[r - 1][0] + M[r-1][1] + M[r - 2][0] + M[r - 2][1])/4; ans[r - 1][c - 1] = (M[r - 1][c - 1] + M[r - 1][c - 2] + M[r - 2][c - 1] + M[r - 2][c - 2])/4; for (int i = 1; i &lt; r - 1; i++) { ans[i][0] = (M[i][0] + M[i - 1][0] + M[i + 1][0] + M[i][1] + M[i - 1][1] + M[i + 1][1])/6; ans[i][c - 1] = (M[i][c - 1] + M[i + 1][c - 1] + M[i - 1][c - 1] + M[i][c - 2] + M[i + 1][c - 2] + M[i - 1][c - 2])/6; } for (int i = 1; i &lt; c - 1; i++) { ans[0][i] = (M[0][i] + M[0][i + 1] + M[0][i - 1] + M[1][i] + M[1][i + 1] + M[1][i - 1]) / 6; ans[r - 1][i] = (M[r - 1][i] + M[r - 1][i + 1] + M[r - 1][i - 1] + M[r - 2][i] + M[r - 2][i + 1] + M[r - 2][i - 1]) / 6; } for (int i = 1; i &lt; r - 1; i++) { for (int j = 1; j &lt; c - 1; j++) { ans[i][j] = (M[i][j] + M[i + 1][j] + M[i - 1][j] + M[i][j + 1] + M[i + 1][j + 1] + M[i - 1][j + 1] + M[i][j - 1] + M[i + 1][j - 1] + M[i - 1][j - 1])/9; } } return ans; }};static const int _ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0;}();","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%938/"},{"title":"LeetCode-38","text":"2181. 合并零之间的节点12345678910111213141516171819202122class Solution {public: ListNode* mergeNodes(ListNode* head) { int sum = 0; ListNode dummy; ListNode *move_dummy = &amp;dummy; ListNode *move = head; while(move-&gt;next) { sum = 0; while(move-&gt;next &amp;&amp; move-&gt;next-&gt;val != 0) { sum += move-&gt;next-&gt;val; move = move-&gt;next; } move-&gt;val = sum; move_dummy-&gt;next = move; move_dummy = move_dummy-&gt;next; move = move-&gt;next; move_dummy-&gt;next = nullptr; } return dummy.next; }}; 977. 有序数组的平方123456789101112131415161718class Solution {public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) { int len = nums.size(); vector&lt;int&gt; merged_array(len); int i = 0, j = len - 1; for(int k = len - 1; k &gt;= 0; k--) { if(abs(nums[i]) &gt; abs(nums[j])) { merged_array[k] = nums[i] * nums[i]; i++; } else { merged_array[k] = nums[j] * nums[j]; j--; } } return merged_array; }}; 按照绝对值归并 双指针，从左右两端开始移动， 3174. 清除数字1234567891011121314class Solution {public: string clearDigits(string s) { string res; for(char c : s) { if(!(c &gt;= '0' &amp;&amp; c &lt;= '9')) { res.push_back(c); } else { res.pop_back(); } } return res; }}; 模拟 2860. 让所有学生保持开心的分组方法数1234567891011121314151617181920212223242526class Solution {public: int countWays(vector&lt;int&gt;&amp; nums) { map&lt;int, int&gt; cnt; for(int n : nums) { cnt[n]++; } vector&lt;int&gt; arr; int len = 0; for(auto [num, total] : cnt) { arr.push_back(num); len++; } int i = 0; int ans = 0; int preSum = 0; while(i &lt; len - 1) { preSum += cnt[arr[i]]; if(preSum &lt; arr[i+1] &amp;&amp; preSum &gt; arr[i]) { ans++; } i++; } return ans + 1 + (arr[0] == 0 ? 0 : 1); }}; 思路 假设选择了第i个学生，他的开心条件是cnt &gt; nums[i]，那么 所有满足nums[j] &lt;= nums[i]的学生都必须被选择 如果存在学生j，nums[j] == nums[i] + 1，nums[k] == nums[j]那么满足的学生k都必须被选择 其他情况都不需要考虑，是一定无法满足条件的 只要统计每个num对应多少学生，按照num排序， 对于第i个num，如果选择他，他之前的学生必须选择 如果num[i+1] == num[i] + 1，那么无法满足，是空集 如果num[i+1] &gt; num[i] + 1，那么只要累计学生足够条件，就能满足，满足的情景+1 利用前缀和，记录num以及小于num的学生数，学生数大于num 3176. 求出最长好子序列 I二维dp123456789101112131415161718192021222324252627282930class Solution {public: int maximumLength(vector&lt;int&gt;&amp; nums, int k) { int len = nums.size(); vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(k + 1)); int maxLen = 0; for(int i = 0; i &lt; len; i++) { dp[i][0] = 1; for(int j = 0; j &lt; i; j++) { if(nums[i] == nums[j]) { dp[i][0] = max(dp[i][0], dp[j][0] + 1); } } maxLen = max(maxLen, dp[i][0]); } for(int i = 0; i &lt; len; i++) { for(int j = 1; j &lt;= k; j++) { for(int m = 0; m &lt; i; m++) { if(nums[i] == nums[m]) { dp[i][j] = max(dp[i][j], dp[m][j] + 1); } else { dp[i][j] = max(dp[i][j], dp[m][j - 1] + 1); } } maxLen = max(maxLen, dp[i][j]); } } return maxLen; }}; dp[i][j]代表到第i个数为止，恰好有j个不同的数的长度 转移方程 如果nums[i] == nums[m]，不同的数相同，j相同, dp[i][j] = max(dp[i][j], dp[m]p[j]) 如果nums[i] != nums[m]，不同的数相同，j不同，相差1, dp[i][j] = max(dp[i][j], dp[m][j-1]) 2552. 统计上升四元组123456789101112131415161718192021222324252627282930class Solution {public: long long countQuadruplets(vector&lt;int&gt;&amp; nums) { long long ans = 0; int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; numsCnt(n, vector&lt;int&gt;(n+1, 0)); for(int i = n - 1; i &gt;= 0; i--) { for(int j = n - 1; j &gt; i; j--) { numsCnt[i][nums[j]]++; } } for(int i = 0; i &lt; n; i++) { for(int j = 1; j &lt;= n; j++) { numsCnt[i][j] += numsCnt[i][j-1]; } } for(int i = 0; i &lt; n; i++) { int smallerThanMe = 0; int cntOfBiggerAfterMe = 0; for(int j = i - 1; j &gt;= 0; j--) { if(nums[j] &gt; nums[i]) { cntOfBiggerAfterMe += (n - i - 1) - numsCnt[i][nums[j]]; } else if(nums[j] &lt; nums[i]) { ans += cntOfBiggerAfterMe; } } } return ans; }}; 想用单调递增栈，这样栈内两个相邻元素之间都是比两个数大的，在找到第三个元素后面有多少比第二个元素大的数，就可以了 这样只比栈顶两个元素会导致遗漏，直接找nums[i]前比nums[i]小的数nums[j1]，和他们之间比nums[i]大的数nums[j]，再找出每个数在i后有多少比nums[j]大的数，可以统计到到比nums[j1]还小的数的组合情况 numsCnt[i][j]表示在开区间(i, n)中，有多少比nums[j]大的数 2555. 两个线段获得的最多奖品123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution {public: int maximizeWin(vector&lt;int&gt;&amp; prizePositions, int k) { int i = 0, j = 0; int n = prizePositions.size(); vector&lt;int&gt; windowSum; vector&lt;int&gt; windowStart; int prizeCnt = 0; while(i &lt; n) { int start = prizePositions[i]; int end = prizePositions[i] + k; while(j &lt; n &amp;&amp; prizePositions[j] &lt;= end) { j++; prizeCnt++; } windowSum.push_back(prizeCnt); windowStart.push_back(start); while(i &lt; n &amp;&amp; prizePositions[i] == start) { i++; prizeCnt--; } } int windowSize = windowSum.size(); int curMaxTail = windowSum[windowSize - 1]; int curMaxStart = windowStart[windowSize - 1]; vector&lt;int&gt; maxTail(windowSize); for(int i = windowSize - 2; i &gt;= 0; i--) { maxTail[i] = curMaxTail; if(windowSum[i] &gt; curMaxTail) { curMaxTail = windowSum[i]; curMaxStart = windowStart[i]; } } int ans = 0; j = 0; for(int i = 0; i &lt; windowSize; i++) { while(j &lt; windowSize &amp;&amp; windowStart[i] + k &gt;= windowStart[j]) { j++; } j--; if(j &lt; n) ans = max(ans, windowSum[i] + maxTail[j]); } return ans; }}; 虽然两个线段可以重叠，但是重叠部分的奖品不能重复拿，所以问题就变成了长度最长为k的情况下，不想交的两个线段内礼物总数和最大的情况 找出所有长度为k的线段的礼物数（start相同的不重复记录），记录在windowSum中，用windowStart记录区间的起点 用maxTail[i]记录起始点为windowStart[i]的线段后方，礼物多的线段的礼物个数 最后对于每一个线段，双指针找到不重叠的下一个线段及其后面的最大礼物数，加起来，求最大值 2332. 坐上公交的最晚时间二分123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: int latestTimeCatchTheBus(vector&lt;int&gt;&amp; buses, vector&lt;int&gt;&amp; passengers, int capacity) { sort(buses.begin(), buses.end()); sort(passengers.begin(), passengers.end()); int busNum = buses.size(); int passengersNum = passengers.size(); vector&lt;int&gt; insertPoints(passengersNum); insertPoints[0] = 0; for(int i = 1; i &lt; passengersNum; i++) { if(passengers[i] - passengers[i - 1] &gt; 1) { insertPoints[i] = i; // 不和前一个连号，更新最晚上车位置 } else { insertPoints[i] = insertPoints[i - 1]; // 上车时间不能和别人重复，如果连号，找到前面第一个不连号的位置 } } int lastestTime = 0; int j = 0; int i = 0; for(; i &lt; busNum &amp;&amp; j &lt; passengersNum; i++) { // 遍历公交车 int firstCantGetOn = upper_bound(passengers.begin() + j, passengers.end(), buses[i]) - passengers.begin(); // 二分找到第一个，时间上无法上车的人 int getOnCnt = min(firstCantGetOn - j, capacity); if(getOnCnt == 0 &amp;&amp; capacity &gt; 0) { // 如果没有人能上，且车容量大于0 lastestTime = buses[i]; // 最晚就是公交车到站时间 } else if(getOnCnt &lt; capacity &amp;&amp; buses[i] - passengers[j + getOnCnt - 1] &gt; 0) { // 如果上车数量小于容量，最晚可以在发车前到达，且最后一个人不是在发车时到达 lastestTime = buses[i]; } else if(insertPoints[j + getOnCnt - 1] &gt;= j) { // 如果前一个可插入点在j或其之后，也就是这批人中有插入点 lastestTime = passengers[insertPoints[j + getOnCnt - 1]] - 1; } // else: 没有插入点，无法上车，什么都不做 j += getOnCnt; } if(i &lt; busNum) { return buses.back(); } return lastestTime; }}; 1184. 公交站间的距离dijkstra1234567891011121314151617181920212223class Solution {public: int distanceBetweenBusStops(vector&lt;int&gt;&amp; distance, int start, int destination) { int n = distance.size(); vector&lt;int&gt; dis(n, INT_MAX / 2); dis[start] = 0; vector&lt;bool&gt; visited(n, false); for(int i = 0; i &lt; n; i++) { int firstClosestAndNotVisited = -1; for(int j = 0; j &lt; n; j++) { if(!visited[j] &amp;&amp; (firstClosestAndNotVisited == -1 || dis[j] &lt; dis[firstClosestAndNotVisited])) { firstClosestAndNotVisited = j; } } int next = firstClosestAndNotVisited; visited[next] = true; dis[(next + 1) % n] = min(dis[(next + 1) % n], distance[next] + dis[next]); dis[(next - 1 + n) % n] = min(dis[(next - 1 + n) % n], distance[(next - 1 + n) % n] + dis[next]); } return dis[destination]; }}; 一次遍历123456789101112131415161718192021class Solution {public: int distanceBetweenBusStops(vector&lt;int&gt;&amp; distance, int start, int destination) { int n = distance.size(); int counterClockWiseSum = 0; int clockWiseSum = 0; if(start &gt; destination) { swap(start, destination); } for(int i = 0; i &lt; start; i++) { counterClockWiseSum += distance[i]; } for(int i = start; i &lt; destination; i++) { clockWiseSum += distance[i]; } for(int i = destination; i &lt; n; i++) { counterClockWiseSum += distance[i]; } return min(clockWiseSum, counterClockWiseSum); }}; 由于只有两个路径到达destination，只要计算顺时针和逆时针的总和，取最小值就好 2848. 与车相交的点差分数组1234567891011121314151617181920class Solution {public: int numberOfPoints(vector&lt;vector&lt;int&gt;&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; diff(102); for(int i = 0; i &lt; n; i++) { diff[nums[i][0]]++; diff[nums[i][1] + 1]--; } int curVal = 0; int cnt = 0; for(int i = 1; i &lt;= 100; i++) { curVal += diff[i]; if(curVal &gt; 0) { cnt++; } } return cnt; }}; 排序贪心1234567891011121314151617181920class Solution {public: int numberOfPoints(vector&lt;vector&lt;int&gt;&gt;&amp; nums) { int n = nums.size(); sort(nums.begin(), nums.end(), [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b){ return a[0] &lt; b[0]; }); int curStart = nums[0][0], curEnd = nums[0][1]; int i = 0; int cnt = 0; for(; i &lt; n; i++) { if(nums[i][0] &gt; curEnd) { cnt += curEnd - curStart + 1; curStart = nums[i][0]; curEnd = nums[i][1]; } else { curEnd = max(curEnd, nums[i][1]); } } return cnt + (curEnd - curStart + 1); }};","link":"/home/2024/09/09/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9338/"},{"title":"LeetCode-36","text":"551. 学生出勤记录 I1234567891011121314151617181920class Solution {public: bool checkRecord(string s) { int count = 0; int max_seq_late = 0; int seq_late = 0; for(char c : s) { if(c == 'A') count++; if(c == 'L') { seq_late++; } else { max_seq_late = max(max_seq_late, seq_late); seq_late = 0; } } max_seq_late = max(max_seq_late, seq_late); return count &lt; 2 &amp;&amp; max_seq_late &lt; 3; }}; 连续相同的值的个数 统计元素出现的次数 3137. K 周期字符串需要的最少操作次数123456789101112131415class Solution {public: int minimumOperationsToMakeKPeriodic(string word, int k) { unordered_map&lt;string, int&gt; subStrCount; int len = word.length(); for(int i = 0; i &lt; len; i += k) { subStrCount[word.substr(i, k)]++; } int minOpCnt = len / k; for(auto&amp; ite : subStrCount) { minOpCnt = min(minOpCnt, len / k - ite.second); } return minOpCnt; }}; 翻译一下规则，就是把长度为nk的字符串切割成n个长度为k的子串，一次操作可以把一个子串替换成另一个字串，求如何替换，将所有字串都相同。 翻译好需求，就很清楚了，直接统计每个字串出现的次数，取出现次数最大的，替换次数最少，为n - cnt[i] 3117. 划分数组得到最小的值之和超时暴搜123456789101112131415161718192021222324252627282930313233class Solution { int n; int m; unsigned int minSum = -1;public: int minimumValueSum(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; andValues) { n = nums.size(); m = andValues.size(); vector&lt;vector&lt;unsigned int&gt;&gt; andMat(n, vector&lt;unsigned int&gt;(n, INT_MAX)); for(int i = 0; i &lt; n; i++) { andMat[i][i] = nums[i]; for(int j = i + 1; j &lt; n; j++) { andMat[i][j] = andMat[i][j-1] &amp; nums[j]; } } search(andMat, andValues, 0, 0, 0); return minSum; } void search(const vector&lt;vector&lt;unsigned int&gt;&gt;&amp; andMat, const vector&lt;int&gt;&amp; andValues, int depth, int start, unsigned int sum) { if(depth + 1 == m) { if(andMat[start][n-1] == andValues[m-1]) { minSum = min(minSum, sum + andMat[n-1][n-1]); } return; } for(int i = start + 1; i &lt; n - m + depth + 2; i++) { if(andMat[start][i-1] == andValues[depth]) { search(andMat, andValues, depth + 1, i, sum + andMat[i-1][i-1]); } } }}; 3148. 矩阵中的最大得分1234567891011121314151617class Solution {public: int maxScore(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = grid.size(), n = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; mat(m, vector&lt;int&gt;(n, INT_MIN)); int maxScore = INT_MIN; mat[0][0] = 0; for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; n; j++) { if(i &gt; 0) mat[i][j] = max(max(mat[i][j], grid[i][j] - grid[i-1][j]), mat[i-1][j] + grid[i][j] - grid[i-1][j]); if(j &gt; 0) mat[i][j] = max(max(mat[i][j], grid[i][j] - grid[i][j-1]), mat[i][j-1] + grid[i][j] - grid[i][j-1]); if(i &gt; 0 || j &gt; 0) maxScore = max(maxScore, mat[i][j]); } } return maxScore; }}; 只能向下或向右走，所以右下方的格子不会影响左上方格子的最终结果，直接拿上方格子和左方格子的值计算，并存储到达每个格子的最小值就好。 3152. 特殊数组 II二分123456789101112131415161718192021222324class Solution {public: vector&lt;bool&gt; isArraySpecial(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; queries) { int n = nums.size(); vector&lt;int&gt; startIndex, endIndex; vector&lt;bool&gt; ans; int s = 0; for(int i = 1; i &lt; n; i++) { if(((nums[i] &amp; 1) ^ (nums[i-1] &amp; 1)) == 0) { startIndex.push_back(s); endIndex.push_back(i - 1); s = i; } } startIndex.push_back(s); endIndex.push_back(n - 1); for(auto &amp;query : queries) { int start = query[0], end = query[1]; int findIndex = upper_bound(startIndex.begin(), startIndex.end(), start) - startIndex.begin() - 1; ans.push_back(endIndex[findIndex] &gt;= end); } return ans; }}; lower_bound: 直译是下界，实际上是上确界，也就是可以等于被查找的元素 upper_bound: 直译是上界，也就是不可以等于被查找的元素 模仿线段树1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Solution { class SegTree { vector&lt;int&gt;&amp; nums; vector&lt;bool&gt; segTree; int n; int alignedSize; unsigned int alignment(unsigned int n) { unsigned int mask = 0x80000000; while(mask &amp;&amp; !(mask &amp; n)) mask &gt;&gt;= 1; return (n &amp; (n-1)) != 0 ? (mask &lt;&lt; 1) : mask; // 得到大于等于n的2的幂 } void initSegTreeLeaf() { if(n &lt;= 1) return; for(int i = 0; i &lt; n - (n &amp; 1); i+=2) { int leftIndex = alignedSize + i - 1; int rightIndex = alignedSize + i; leftIndex = (leftIndex - 1) &gt;&gt; 1; segTree[leftIndex] = ((nums[i] &amp; 1) ^ (nums[i+1] &amp; 1)); } } bool initSegTree(int start, int end, int index) { int mid = (end - start) / 2 + start; if(start &gt;= end) return true; if(index &gt;= alignedSize / 2) return segTree[index]; if(mid &gt;= 0 &amp;&amp; mid + 1 &lt; n) { segTree[index] = (nums[mid] &amp; 1) ^ (nums[mid+1] &amp; 1); } segTree[index] = segTree[index] &amp; initSegTree(start, mid, 2 * index + 1) &amp; initSegTree(mid+1, end, 2 * index + 2); return segTree[index]; } bool query(int i , int j, int start, int end, int index) { int mid = (end - start) / 2 + start; if(start == end) return true; if(i &lt;= start &amp;&amp; end &lt;= j) { return segTree[index]; } if(mid &gt;= i &amp;&amp; mid + 1 &lt;= j &amp;&amp; !((nums[mid] &amp; 1) ^ (nums[mid+1] &amp; 1))) return false; if(mid &gt;= i &amp;&amp; !query(i, j, start, mid, 2 * index + 1)) { return false; } if(mid + 1 &lt;= j &amp;&amp; !query(i, j, mid+1, end, 2 * index + 2)) { return false; } return true; } public: SegTree(vector&lt;int&gt;&amp; nums): \\ nums(nums), n(nums.size()), \\ alignedSize(alignment(n)) { segTree = vector&lt;bool&gt;(alignedSize, true); // 不用乘2，因为叶子节点全是true initSegTreeLeaf(); initSegTree(0, alignedSize - 1, 0); } bool query(int i , int j) { return query(i, j, 0, alignedSize - 1, 0); } };public: vector&lt;bool&gt; isArraySpecial(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; queries) { vector&lt;bool&gt; ans; SegTree segTree(nums); for(auto&amp; q : queries) { bool result = segTree.query(q[0], q[1]); ans.push_back(result); } return ans; }}; 哎，速度不是很快279ms 击败13.48% dp3151. 特殊数组 I1234567891011121314class Solution {public: bool isArraySpecial(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int odd = nums[0] &amp; 1; for(int i = 1; i &lt; len; i++) { if((nums[i] &amp; 1) == odd) { return false; } odd = !odd; } return true; }}; 676. 实现一个魔法字典1234567891011121314151617181920212223242526272829class MagicDictionary { vector&lt;string&gt; dictionary;public: MagicDictionary() { } void buildDict(vector&lt;string&gt; dictionary) { this-&gt;dictionary = dictionary; } bool search(string searchWord) { for(auto&amp; word : dictionary) { if(word.size() != searchWord.size()) { continue; } int diff = 0; for(int i = 0; i &lt; word.size(); i++) { if(word[i] != searchWord[i]) { diff++; } } if(diff == 1) { return true; } } return false; }}; 1035. 不相交的线1 3132. 找出与数组相加的整数 II123456789101112131415161718192021222324252627282930class Solution {public: int minimumAddedInteger(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { sort(nums1.begin(), nums1.end()); sort(nums2.begin(), nums2.end()); int len2 = nums2.size(); int x = INT_MAX; for(int start = 0; start &lt; 3; start++) { int skip = 2 - start; int diff = nums2[0] - nums1[start]; bool flag = true; for(int i = 1, j = 1; i &lt; len2; j++) { if(nums2[i] - nums1[start+j] != diff) { if(skip &gt; 0) { skip--; } else { flag = false; break; } } else { i++; } } if(flag) { x = min(x, diff); } } return x; }}; 先排序，计算差值，看是否所有差值都相同 由于数组1的长度比数组2长2，所以比时给数组1一个偏移 由于需要删除两个，且删除的位置不同，比较时如果遇到不相等的情况，则根据情况跳过一个 3131. 找出与数组相加的整数 I123456class Solution {public: int addedInteger(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { return *max_element(nums2.begin(), nums2.end()) - *max_element(nums1.begin(), nums1.end()); }}; 3129. 找出所有稳定的二进制数组 I12345678910111213141516171819202122232425262728293031323334class Solution { const long long MOD = 1e9 + 7;public: int numberOfStableArrays(int zero, int one, int limit) { // 连续的0和1的个数不超过limit vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp0 = vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;(zero + 1, vector&lt;vector&lt;int&gt;&gt;(one + 1, vector&lt;int&gt;(limit+1, 0))); vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp1 = vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;(zero + 1, vector&lt;vector&lt;int&gt;&gt;(one + 1, vector&lt;int&gt;(limit+1, 0))); for(int z = 1; z &lt;= min(zero, limit); z++) { dp0[z][0][z] = 1; } for(int o = 1; o &lt;= min(one, limit); o++) { dp1[0][o][o] = 1; } for(int z = 1; z &lt;= zero; z++) { for(int o = 1; o &lt;= one; o++) { int dp01 = 0; int dp11 = 0; for(int l = 1; l &lt;= limit; l++) { dp01 = (dp01 + dp1[z-1][o][l]) % MOD; // 含有z-1个0，o个1，末尾连续1的个数为l，的数后面加一个0，变成z+1个0，o个1，末尾连续0的个数为1的数 dp11 = (dp11 + dp0[z][o-1][l]) % MOD; // 含有z个0，o-1个1，末尾连续0的个数为l，的数后面加一个1，变成z个0，o+1个1，末尾连续1的个数为1的数 dp0[z][o][l] += dp0[z-1][o][l-1]; // 含有z-1个0，o个1，末尾连续0的个数为l-1，的数后面再加一个0，变成z+1个0，o个1，末尾连续0的个数为l的数 dp1[z][o][l] += dp1[z][o-1][l-1]; // 含有z-1个0，o个1，末尾连续0的个数为l-1，的数后面再加一个1，变成z个0，o+1个1，末尾连续1的个数为l的数 } dp0[z][o][1] += dp01; dp1[z][o][1] += dp11; } } int ans = 0; for(int l = limit; l &gt;= 1; l--) { ans = (ans + (dp0[zero][one][l] + dp1[zero][one][l]) % MOD) % MOD; } return ans; }}; 答案还可以降维 600. 不含连续1的非负整数123456789101112131415161718class Solution { int cnt = 0; void search(int i, int n) { if(i &gt; n) { return; } cnt++; if(!(i &amp; 1)) { search((i &lt;&lt; 1) | 1, n); } search((i &lt;&lt; 1) | 0, n); }public: int findIntegers(int n) { search(1, n); return cnt + 1; }}; 572. 另一棵树的子树12345678910111213141516171819202122232425262728293031class Solution { void findNode(TreeNode* root, int val, vector&lt;TreeNode*&gt;&amp; result) { if(root == nullptr) { return; } if(root-&gt;val == val) { result.push_back(root); } findNode(root-&gt;left, val, result); findNode(root-&gt;right, val, result); } bool _isSubTree(TreeNode *root, TreeNode* subRoot) { if(root == nullptr || subRoot == nullptr) { return root == subRoot; } if(root-&gt;val != subRoot-&gt;val) { return false; } return _isSubTree(root-&gt;left, subRoot-&gt;left) &amp;&amp; _isSubTree(root-&gt;right, subRoot-&gt;right); }public: bool isSubtree(TreeNode* root, TreeNode* subRoot) { vector&lt;TreeNode*&gt; nodes; findNode(root, subRoot-&gt;val, nodes); for(TreeNode* node : nodes) { if(_isSubTree(node, subRoot)) return true; } return false; }}; 3143. 正方形中的最多点数123456789101112131415161718192021222324252627282930313233343536373839class Solution {public:public: int maxPointsInsideSquare(vector&lt;vector&lt;int&gt;&gt;&amp; points, string s) { auto getLineLen = [](const vector&lt;int&gt;&amp; point) { // 点所在正方形的边长/2，用来代表一个正方形 return max(abs(point[0]), abs(point[1])); }; int len = points.size(); vector&lt;int&gt; sortedIndex(len); iota(sortedIndex.begin(), sortedIndex.end(), 0); sort(sortedIndex.begin(), sortedIndex.end(), [&amp;points, &amp;getLineLen](int a, int b){ return getLineLen(points[a]) &lt; getLineLen(points[b]); }); // 按照点所在正方形的边长排序 unordered_set&lt;char&gt; labelSet; // 记录出现过的label，不允许出现相同的label int cnt = 0; int maxcnt = 0; int i = 0; bool valid = true; while(i &lt; len &amp;&amp; valid) { int index = sortedIndex[i]; int lineLen = getLineLen(points[index]); while(i &lt; len &amp;&amp; lineLen == getLineLen(points[index = sortedIndex[i]])) { // 遍历所有相同边长的点 char label = s[index]; if(labelSet.count(label)) { valid = false; // 这个正方形的边上遇到了出现过的label，这个正方形失效，更大的正方形也失效 break; } else { cnt++; } labelSet.insert(label); i++; } if(valid) { // 对于合法正方形，更新点数 maxcnt = cnt; } } return maxcnt; }}; 3128. 直角三角形四次前缀和12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution {public: long long numberOfRightTriangles(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { long long number = 0; int m = grid.size(), n = grid[0].size(); vector&lt;int&gt; verticalSum; verticalSum = vector&lt;int&gt;(n); for(int i = 0; i &lt; m; i++) { int horSum = 0; for(int j = 0; j &lt; n; j++) { if(!grid[i][j]) continue; verticalSum[j] += grid[i][j]; horSum += grid[i][j]; number += (horSum - 1) * (verticalSum[j] - 1); } } verticalSum = vector&lt;int&gt;(n); for(int i = m - 1; i &gt;= 0; i--) { int horSum = 0; for(int j = 0; j &lt; n; j++) { if(!grid[i][j]) continue; verticalSum[j] += grid[i][j]; horSum += grid[i][j]; number += (horSum - 1) * (verticalSum[j] - 1); } } verticalSum = vector&lt;int&gt;(n); for(int i = m - 1; i &gt;= 0; i--) { int horSum = 0; for(int j = n - 1; j &gt;= 0; j--) { if(!grid[i][j]) continue; verticalSum[j] += grid[i][j]; horSum += grid[i][j]; number += (horSum - 1) * (verticalSum[j] - 1); } } verticalSum = vector&lt;int&gt;(n); for(int i = 0; i &lt; m; i++) { int horSum = 0; for(int j = n - 1; j &gt;= 0; j--) { if(!grid[i][j]) continue; verticalSum[j] += grid[i][j]; horSum += grid[i][j]; number += (horSum - 1) * (verticalSum[j] - 1); } } return number; }}; LCP 40. 心算挑战贪心123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution {public: int maximumScore(vector&lt;int&gt;&amp; cards, int cnt) { vector&lt;int&gt; odd, even; sort(cards.begin(), cards.end()); for(int card : cards) { ((card &amp; 1) ? odd : even).push_back(card); // 三目运算符的这种用法终于被我用上了 } int score = 0; int odd_index = odd.size() - 1; int even_index = even.size() - 1; while(cnt) { bool has2_odd = odd_index &gt;= 1; bool has2_even = even_index &gt;= 1; bool cnt_at_least_2 = cnt &gt;= 2; if(has2_odd &amp;&amp; has2_even &amp;&amp; cnt_at_least_2) { if(even[even_index] &gt;= odd[odd_index] + odd[odd_index - 1]) { goto do_even; } else if(odd[odd_index] + odd[odd_index - 1] &gt;= even[even_index] + even[even_index - 1]) { goto do_odd; } else { goto do2_even; } } else { if((cnt == 1 || odd_index == 0) &amp;&amp; even_index &gt;= 0) { // odd或cnt为1，even大于0, 取even goto do_even; } else if(odd_index &lt; 0 &amp;&amp; even_index &gt;= 0 &amp;&amp; cnt &gt; 1) { // odd为0，even不为0，cnt大于1，取even goto do_even; } else if(even_index == 0 &amp;&amp; odd_index &gt;= 1 &amp;&amp; cnt &gt;= 2) { if(cnt == 2) { goto do_odd; } else if(even[even_index] &gt; odd[odd_index] + odd[odd_index - 1]) { goto do_even; } else { goto do_odd; } } else if(even_index &lt; 0 &amp;&amp; odd_index &gt;= 1 &amp;&amp; cnt &gt;= 2) { goto do_odd; } break; } do_odd: score += odd[odd_index] + odd[odd_index - 1]; cnt -= 2; odd_index -= 2; goto next; do2_even: score += even[even_index] + even[even_index - 1]; cnt -= 2; even_index -= 2; goto next; do_even: score += even[even_index]; cnt -= 1; even_index -= 1; next: } return cnt == 0 ? score : 0; }}; 先排序，然后按照奇偶性分成两个数组 贪心，每次从奇数数组中取出两个奇数，或者从偶数数组中取数，直到取完数组，或者奇数数组剩一个，或者取够了cnt个数 如何选取： 由于奇数数组每次取两个，占用两个cnt资源，而偶数数组可以取一个也可以取两个，导致前面的取法会影响后续cnt能否刚好取够。 是连续取两个偶数，还是取两个奇数，还是只取一个偶数？ odd=[...,3,7], even=[...,12],由于偶数数组中12大于奇数数组的3+7，所以取12,(一个偶数完胜) odd=[...,3,7], even=[...,6,6],这次6小于3+7,可是连续取两个6的得分大于3+7，所以取6+6。(两个奇数拉低了平均值) odd=[...,3,7], even=[...,2,6],这次6小于3+7，连续两次都选择偶数2+6也比选择3+7两个奇数小，所以选两个奇数 以上选取策略需要len(odd) &gt;= 2 and len(even) &gt;= 2 and ret &gt;= 2 下面讨论不满足以上情况，也就是len(odd),len(even),ret不会同时大于等于2的情况 由于可能的情况太多太复杂，列表讨论 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*odd even cnt do// odd或cnt为1，even大于0,只能取even2+ 2+ 1 even2 2+ 1 even1 2+ 2+ even1 2+ 2 even1 2+ 1 even0 2+ 1 even2+ 2 1 even2 2 1 even1 2 2+ even1 2 2 even1 2 1 even0 2 1 even2+ 1 1 even2 1 1 even1 1 2+ even1 1 2 even1 1 1 even0 1 1 even// odd为0，even不为0，cnt大于1，取even0 2+ 2+ even0 2+ 2 even0 2 2+ even0 2 2 even0 1 2+ even0 1 2 even// even只剩一个, cnt剩两个，不能取even，odd大于等于2个，取odd2+ 1 2 odd2 1 2 odd// even只剩一个, cnt大于两个，可以取even，但需要和odd比较2+ 1 2+ even, odd1+odd2比较2 1 2+ even, odd1+odd2比较// even用完了, odd还有两个以上, 取odd2+ 0 2+ odd2+ 0 2 odd2 0 2+ odd2 0 2 odd// even,odd都取完了，无法取够cnt，break0 0 2+ break0 0 2 break// cnt或odd为1，没有even可取，无法满足条件，break2+ 0 1 break2 0 1 break1 0 2+ break1 0 2 break1 0 1 break0 0 1 break*/ 2+代表个数大于2 排序1234567891011121314151617181920212223242526272829303132class Solution {public: int maximumScore(vector&lt;int&gt;&amp; cards, int cnt) { int odd = -1, even = -1; int tmp = 0; int n = cards.size(); sort(cards.begin(), cards.end()); for(int i = n - 1; i &gt; n - cnt - 1; i--) { ((cards[i] &amp; 1) ? odd : even) = cards[i]; tmp += cards[i]; cout &lt;&lt; cards[i] &lt;&lt; endl; } if(!(tmp &amp; 1)) return tmp; bool flag = false; int ans = 0; for(int i = n - cnt - 1; i &gt;= 0; i--) { if(cards[i] &amp; 1) { if(even != -1) { flag = true; ans = max(ans, tmp - even + cards[i]); } } else { if(odd != -1) { ans = max(ans, tmp - odd + cards[i]); flag = true; } } } return ans; }}; 排序后前cnt个数加起来，如果是偶数，则是所求最大的情况，直接返回 否则，前cnt个和加起来是奇数，用后面的数替换前面的数，使和变成偶数 如果后面的数是奇数，则减去最后一个偶数，这样和为偶数 如果后面的数是偶数，则减去最后一个奇数，这样和为奇数 哈希和上一个想法思路一致，1&lt;=cards[i]&lt;=1000，可以把他映射到一个长度1000的数组中，记录下标早cards中出现的次数，可以避免排序。 123456789101112131415161718192021222324252627282930313233class Solution {public: int maximumScore(vector&lt;int&gt;&amp; cards, int cnt) { int hash[1001] = {0}; int n = cards.size(); for(int i = 0; i &lt; n; i++) { hash[cards[i]]++; } int i = 1000; int tmp = 0; int odd = -1, even = -1; for(int j = 0; j &lt; cnt &amp;&amp; i &gt; 0; j++) { while(i &gt; 0 &amp;&amp; hash[i] == 0) i--; if(i == 0) break; // will never happen tmp += i; hash[i]--; ((i &amp; 1) ? odd : even) = i; } if(!(tmp &amp; 1)) return tmp; int ans = 0; while(i &gt; 0) { while(i &gt; 0 &amp;&amp; hash[i] == 0) i--; if(i == 0) break; if((i &amp; 1) == 1 &amp;&amp; even != -1) { ans = max(ans, tmp - even + i); } else if((i &amp; 1) == 0 &amp;&amp; odd != -1) { ans = max(ans, tmp - odd + i); } hash[i]--; } return ans; }}; 3111. 覆盖所有点的最少矩形数目1234567891011121314151617class Solution {public: int minRectanglesToCoverPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, int w) { sort(points.begin(), points.end(), [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b){ return a[0] &lt; b[0]; }); int len = points.size(); int i = 1; int cnt = 1; int lastx = points[0][0]; while(i &lt; len) { while(i &lt; len &amp;&amp; points[i][0] - lastx &lt;= w) i++; if(i &gt;= len) break; cnt++; lastx = points[i][0]; } return cnt; }}; 啊?这是中等题吗 3007. 价值和小于等于 K 的最大数字公式法1234567891011121314151617181920212223242526272829class Solution { long long accumulatedValueOf(long long k, int x) { long long value = 0; for(int mask_off = 63; mask_off &gt;= 1; mask_off--) { long long mask = 1l &lt;&lt; (mask_off - 1); if(!(mask &amp; k)) continue; k = k &amp; ~mask; if(mask_off % x == 0) { value += ((k|mask) - mask + 1); } value += mask / 2 * ((mask_off - 1) / x); } return value; }public: long long findMaximumNumber(long long k, int x) { long long l = 1, r = 1e15; while(l &lt; r) { long long mid = (r - l + 1) / 2 + l; long long accuValue = accumulatedValueOf(mid, x); if(accuValue &lt;= k) { l = mid; } else { r = mid - 1; } } return l; }}; 思路 记$ price_n(x) = bit_count(n, x) $ 记$ accumulated_n(x) = \\sum_{i=1}^nprice_i(x) $ bit_count, price是n的价值，也就是下标被x整除的位数和 对于n&gt;0, 函数bit_count, 是恒大于零的。 所以数列$ {accumulated_n(x)} $是单调递增的，如果能找到计算$ {accumulated_n(x)} $的公式，利用二分查找即可快速找到答案 公式推导 以n = 7, x = 1为例 1234567800000001001000110100010101100111 可以观察到0 + 7 = 1 + 6 = 2 + 5 = 3 + 4 = 二进制的111总价值为: 3*4=12 也就是对于$ n = 0 … (2^i-1) $时，他们的总价值为$ i * 2^{i-1} $ $ a_{2^i}(1) = i * 2^{i-1}$ 以n = 10, x = 1为例 123456789101100000001001000110100010101100111100010011010 先计算n = 0...7的总价值，为12$ a_{2^i-1}(1) = i * 2^{i-1}$, $i = 3$的情况 组成部分为n = 0...7和n = 8...10 对于n = 8...10先数出最高位的情况，也就是$n - (2^i - 1)$，再去掉最高位，变成以下情况 123000110 也就是n = 2, x = 1的情况，重复上面的操作也就是 $ b_n(i) = n%2^{i+1} - (2^i - 1) $ 对于更复杂的情况如: n = 1001101, x = 1总价值为$ a_{2^6-1}(1) + b_n(6) + $$ a_{2^3-1}(1) + b_n(3) + $$ a_{2^2-1}(1) + b_n(2) + $$ a_{2^0-1}(1) + b_n{0}$ 对于x != 1的情况，也就是$ a_{2^i}(x) = \\lfloor\\frac{i}{x}\\rfloor * 2^{i-1}$$ b_n(i, x) = n%2^{i+1} - (2^i - 1) $ $(i % x = 0)$$ b_n(i, x) = 0 $ $(i % x \\not ={0})$ 2961. 双模幂运算快速幂秒了！ 1234567891011121314151617181920212223242526class Solution { int fastPow(int a, int n, int mod) { int res = 1; while(n) { if(n&amp;1) { res = (res * a) % mod; } a = (a * a) % mod; n &gt;&gt;= 1; } return res; }public: vector&lt;int&gt; getGoodIndices(vector&lt;vector&lt;int&gt;&gt;&amp; variables, int target) { vector&lt;int&gt; goodIndices; int len = variables.size(); for(int i = 0; i &lt; len; i++) { int n = fastPow(variables[i][0], variables[i][1], 10); n = fastPow(n, variables[i][2], variables[i][3]); if(n == target) { goodIndices.push_back(i); } } return goodIndices; }}; 682. 棒球比赛12345678910111213141516171819202122232425class Solution {public: int calPoints(vector&lt;string&gt;&amp; operations) { int n = operations.size(); vector&lt;int&gt; scores; int scoreCnt = 0; for(int i = 0; i &lt; n; i++) { int score = 0; if (operations[i] == &quot;+&quot;) { score = scores[scoreCnt - 1] + scores[scoreCnt - 2]; } else if (operations[i] == &quot;D&quot;) { score = scores[scoreCnt - 1] * 2; } else if (operations[i] == &quot;C&quot;) { scores.pop_back(); scoreCnt--; continue; } else { sscanf(operations[i].c_str(), &quot;%d&quot;, &amp;score); } scores.push_back(score); scoreCnt++; } return accumulate(scores.begin(), scores.end(), 0); }}; 3106. 满足距离约束且字典序最小的字符串12345678910111213141516171819202122232425class Solution { public: int charDistance(char a, char b) { int d = abs(a - b); return min(d, 26 - d); }public: string getSmallestString(string s, int k) { int n = s.length(); for(int i = 0; i &lt; n &amp;&amp; k &gt; 0; i++) { int target = 'z'; if(k &gt; 12) { target = 'a'; } else { for(int j = 0; j &lt;= k; j++) { target = min(target, (s[i] + j - 'a') % 26 + 'a'); target = min(target, (s[i] - j - 'a' + 26) % 26 + 'a'); } } k -= charDistance(s[i], target); s[i] = target; } return s; }}; 实际上就是26进制数，在有限步骤内，将其转化为同位数下尽量小的数 尽量多的将当前最高位变小，高位使用1步的减少量是地位使用一步的26倍 简单计算可知，两个字母最大距离为12 当k &gt; 12时，一定可以变成a 当k &lt;= 12时，一定可以变成a，寻找k步内能实现的最小字符 2740. 找出分区值123456789101112class Solution {public: int findValueOfPartition(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); int len = nums.size(); int minDiff = INT_MAX; for(int i = 1; i &lt; len; i++) { minDiff = min(minDiff, abs(nums[i] - nums[i-1])); } return minDiff; }}; 2844. 生成特殊数字的最少操作12345678910111213141516171819202122232425262728class Solution {public: int minimumOperations(string num) { int len = num.length(); int first0 = len, first5 = len; int i = len - 1; int minOp = len; while(i &gt;= 0) { if(num[i] == '0' &amp;&amp; first0 == len) { first0 = i; } else if(num[i] == '5' &amp;&amp; first5 == len) { first5 = i; } if(num[i] == '0' &amp;&amp; first0 != len &amp;&amp; i &lt; first0) { minOp = min(minOp, len - first0 - 1 + first0 - i - 1); } else if(num[i] == '2' &amp;&amp; first5 != len &amp;&amp; i &lt; first5) { minOp = min(minOp, len - first5 - 1 + first5 - i - 1); } else if(num[i] == '5' &amp;&amp; first0 != len &amp;&amp; i &lt; first0) { minOp = min(minOp, len - first0 - 1 + first0 - i - 1); } else if(num[i] == '7' &amp;&amp; first5 != len &amp;&amp; i &lt; first5) { minOp = min(minOp, len - first5 - 1 + first5 - i - 1); } i--; } if(first0 != len) minOp = min(minOp, len - 1); return minOp; }}; 对于所有25的倍数，举例可知，结尾两位为00,25,50,75 一个字符串可能有多种方式到达变成25的倍数 如果最后以00结尾，先倒着找到第一个0，删去后面的所有数，在找第二个0，删掉两个0中间的数 25,50,75同理 返回删除数字最少的情况 特殊情况 没有找到00,25,50,75，可以把整个字符串删掉 没有找到00,25,50,75，只找到了一个0，可以把0以外的数全删掉 2766. 重新放置石块123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; relocateMarbles(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; moveFrom, vector&lt;int&gt;&amp; moveTo) { unordered_map&lt;int, bool&gt; pos2rock; for(int rockPos : nums) { pos2rock[rockPos] = true; } int opNum = moveFrom.size(); for(int i = 0; i &lt; opNum; i++) { if(moveTo[i] == moveFrom[i]) continue; pos2rock[moveTo[i]] = true; // pos2rock[moveFrom[i]] = 0; pos2rock.erase(moveFrom[i]); } vector&lt;int&gt; res; for(const auto&amp; [pos, num] : pos2rock) { // if(num) { // 不需要判断，都是true res.push_back(pos); // } } sort(res.begin(), res.end()); return res; }}; 2101. 引爆最多的炸弹1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution { class Solve { unordered_map&lt;int, vector&lt;int&gt;&gt; graph; vector&lt;vector&lt;int&gt;&gt;&amp; bombs; int bombsNum; int isICanBoomJ(int i, int j) { return ((long long)bombs[i][0] - bombs[j][0]) * (bombs[i][0] - bombs[j][0]) + ((long long)bombs[i][1] - bombs[j][1]) * (bombs[i][1] - bombs[j][1]) &lt;= (long long)bombs[i][2] * bombs[i][2]; } int cntNodes(int start) { vector&lt;bool&gt; visited = vector&lt;bool&gt;(bombsNum, false); return cntNodes(start, visited); } int cntNodes(int start, vector&lt;bool&gt;&amp; visited) { visited[start] = true; int child = 0; for(int subNode : graph[start]) { if(!visited[subNode]) { visited[subNode] = true; child += cntNodes(subNode, visited); } } return 1+child; } public: Solve(vector&lt;vector&lt;int&gt;&gt;&amp; bombs) : bombs(bombs), bombsNum(bombs.size()) {} int solve() { for(int i = 0; i &lt; bombsNum; i++) { for(int j = 0; j &lt; bombsNum; j++) { if(i == j) continue; if(isICanBoomJ(i, j)) { graph[i].push_back(j); } } } int maxBoom = INT_MIN; for(int i = 0; i &lt; bombsNum; i++) { maxBoom = max(maxBoom, cntNodes(i)); } return maxBoom; } };public: int maximumDetonation(vector&lt;vector&lt;int&gt;&gt;&amp; bombs) { return Solve(bombs).solve(); }}; 1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: int maximumDetonation(vector&lt;vector&lt;int&gt;&gt;&amp; bombs) { int bombsNum = bombs.size(); auto isICanBoomJ = [&amp;](int i, int j) { return ((long long)bombs[i][0] - bombs[j][0]) * (bombs[i][0] - bombs[j][0]) + ((long long)bombs[i][1] - bombs[j][1]) * (bombs[i][1] - bombs[j][1]) &lt;= (long long)bombs[i][2] * bombs[i][2]; }; unordered_map&lt;int, vector&lt;int&gt;&gt; graph; function&lt;int(int, vector&lt;bool&gt;&amp;)&gt; _cntNodes = [&amp;](int start, vector&lt;bool&gt;&amp; visited) { visited[start] = true; int child = 0; for(int subNode : graph[start]) { if(!visited[subNode]) { visited[subNode] = true; child += _cntNodes(subNode, visited); } } return 1+child; }; auto cntNodes = [&amp;](int start) { vector&lt;bool&gt; visited = vector&lt;bool&gt;(bombsNum, false); return _cntNodes(start, visited); }; for(int i = 0; i &lt; bombsNum; i++) { for(int j = 0; j &lt; bombsNum; j++) { if(i == j) continue; if(isICanBoomJ(i, j)) { graph[i].push_back(j); } } } int maxBoom = INT_MIN; for(int i = 0; i &lt; bombsNum; i++) { maxBoom = max(maxBoom, cntNodes(i)); } return maxBoom; }}; 注意计算距离时int可能会溢出 1186. 删除一次得到子数组最大和3133. 数组最后一个元素的最小值123456789101112131415161718192021222324252627282930313233class Solution {public: long long minEnd(int n, int x) { long long res = 0; int mask_n = 1; int mask_x = 1; long long mask_res = 1l; n--; while(mask_n &lt; 0x8000'0000 &amp;&amp; mask_x &lt; 0x8000'0000) { if(x &amp; mask_x) { res |= mask_res; } else { if(n &amp; mask_n) res |= mask_res; mask_n &lt;&lt;= 1; } mask_res &lt;&lt;= 1; mask_x &lt;&lt;= 1; } while(mask_n &lt; 0x8000'0000) { if(n &amp; mask_n) res |= mask_res; mask_res &lt;&lt;= 1; mask_n &lt;&lt;= 1; } while(mask_x &lt; 0x8000'0000) { if(x &amp; mask_x) { res |= mask_res; } mask_res &lt;&lt;= 1; mask_x &lt;&lt;= 1; } return res; }}; 思路首先所有的数相与后的结果需要为x,先随便来一个二进制数，看看满足这样的数有什么规律 以x = 001101101001为例 对于数组中的二进制数，如果x的第i位为0，则对应数组中的数的第i位可以是0也可以是1；如果果x的第i位为1，则对应数组中的数的第i位必须是1 也就是数组中的数满足 $ a_i = ??11?11?1??1 $ 现在希望数组中有n个数 以n = 9 = 000000001001为例，先不管相与为x的限制，数组中的数可以是 123456789000100100011010001010110011110001001 前面提到数组中的数必须满足$ a_i = ??11?11?1??1 $, 可以把这些数安排到?处，这样可以保证相与为x，也可以保证数目那么数组中最大数9，把他填入?处可得:001111101011那么数组中最小数1，把他填入?处可得:001101101011 考虑到x&amp;x = x, 所以数组中最小数可以是0，所以对于x = 001101101001, n = 9 = 000000001001, 数组中最小数为x，最大数为将8填入?处，得001111101001 2850. 将石头分散到网格图的最少移动次数暴力分子123456789101112131415161718192021222324252627282930313233343536373839class Solution { int minMove = INT_MAX; void move(vector&lt;vector&lt;int&gt;&gt; grid, int moveCnt) { bool flag = true; int minDist = INT_MAX; for(int i = 0; i &lt; 9; i++) { if(grid[i/3][i%3] &lt;= 1) continue; for(int j = 0; j &lt; 9; j++) { if(i == j) continue; if(grid[j/3][j%3] == 0) { flag = false; minDist = min(minDist, abs(i/3 - j/3) + abs(i%3 - j%3)); } } } if(flag) { minMove = min(minMove, moveCnt); return; } for(int i = 0; i &lt; 9; i++) { if(grid[i/3][i%3] &lt;= 1) continue; for(int j = 0; j &lt; 9; j++) { if(i == j) continue; if(grid[j/3][j%3] == 0 &amp;&amp; abs(i/3 - j/3) + abs(i%3 - j%3) == minDist) { grid[j/3][j%3]++; grid[i/3][i%3]--; move(grid, moveCnt + abs(i/3 - j/3) + abs(i%3 - j%3)); grid[j/3][j%3]--; grid[i/3][i%3]++; } } } }public: int minimumMoves(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { move(grid, 0); return minMove; }}; 硬搜 枚举123456789101112131415161718192021222324252627282930313233343536373839404142434445464748unordered_map&lt;long long, int&gt; m; // int64表示的grid to 到达 初始状态的最小步数const long long initState = 0x00'00'00'01'11'11'11'11;static const int initMap = [](){ queue&lt;long long&gt; q; q.push(initState); m[initState] = 0; while(!q.empty()) { long long state = q.front(); int step = m[state]; q.pop(); for(int i = 0; i &lt; 9; i++) { int numI = (state &gt;&gt; (i &lt;&lt; 2)) &amp; 0x0f; if(numI != 1) continue; for(int j = 0; j &lt; 9; j++) { if(i == j) continue; long long numJ = (state &gt;&gt; (j &lt;&lt; 2)) &amp; 0x0f; if(numJ == 0) continue; int newStep = step + abs(i / 3 - j / 3) + abs(i % 3 - j % 3); numJ++; long long newState = state; newState = newState &amp; ~(0x0fl &lt;&lt; (i &lt;&lt; 2)); newState = newState &amp; ~(0x0fl &lt;&lt; (j &lt;&lt; 2)); newState = newState | (numJ &lt;&lt; (j &lt;&lt; 2)); if(!m.count(newState) || m[newState] &gt; newStep) { q.push(newState); m[newState] = newStep; } } } } return 0;}();class Solution { long long grid2Int64(const vector&lt;vector&lt;int&gt;&gt;&amp; grid) { long long int64Grid = 0; for(int i = 0; i &lt; 3; i++) { for(int j = 0; j &lt; 3; j++) { int64Grid &lt;&lt;= 4; int64Grid += grid[i][j]; } } return int64Grid; }public: int minimumMoves(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { return m[grid2Int64(grid)]; }}; 用longlong表示grid，从全1的grid开始，找出所有grid情况，计算出他变成全1的step，缓存起来，用的时候查 全排列1234567891011121314151617181920212223242526class Solution {public: int minimumMoves(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { vector&lt;int&gt; more, less; for(int i = 0; i &lt; 9; i++) { int num = grid[i / 3][i % 3]; if(num &gt; 1) { for(int j = 1; j &lt; num; j++) { more.push_back(i); } } else if(num == 0) { less.push_back(i); } } int len = more.size(); int minStep = INT_MAX; do { int step = 0; for(int i = 0; i &lt; len; i++) { step += abs(more[i] / 3 - less[i] / 3) + abs(more[i] % 3 - less[i] % 3); } minStep = min(minStep, step); } while(next_permutation(more.begin(), more.end())); return minStep; }}; 抄的题解 每个大于1的格子最后都会变成1，填补到0上，大于1的格子的值-1之和等于0的格子数量是相等的 构造两个数组，一个存全0的格子下标，一个将大于1的格子存n-1次，两个数组长度一致 (more[i],less[i])表示将i格子上的一块石头搬到less上，只要对more进行全排列，就可以找出所有移动的方法，然后算出所需的总步数，然后算出最小步数 3096. 得到更多分数的最少关卡数目又是博弈问题，不会 3112. 访问消失节点的最少时间123456789101112131415161718192021222324252627282930313233class Solution {public: vector&lt;int&gt; minimumTime(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;int&gt;&amp; disappear) { vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph(n); for(const auto&amp; edge : edges) { graph[edge[0]].emplace_back(edge[1], edge[2]); graph[edge[1]].emplace_back(edge[0], edge[2]); } vector&lt;int&gt; ans(n, INT_MAX / 2); auto cmp = [](const pair&lt;int, int&gt;&amp; i , const pair&lt;int, int&gt;&amp; j){ return i.second &gt; j.second; }; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(cmp)&gt; q(cmp); q.emplace(0, 0); ans[0] = 0; while(!q.empty()) { auto [min_index, len] = q.top(); q.pop(); if(len &gt; ans[min_index]) continue; for(auto [child, len] : graph[min_index]) { int newLen = ans[min_index] + len &gt;= disappear[child] ? INT_MAX / 2 : ans[min_index] + len; if(newLen &lt; ans[child] &amp;&amp; newLen &lt; INT_MAX / 2) { ans[child] = newLen; q.emplace(child, ans[child]); } } } for(int i = 0; i &lt; n; i++) { if(ans[i] &gt;= INT_MAX / 2) ans[i] = -1; } return ans; }}; 就是带限制的dijkstra，但是很坑 两个顶点之间可能存在多个长度不同的边，显然要选最小的，但不能用n*n的vector存图，会超内存 必须用优先队列选点，否则时间超 3145. 大数组元素的乘积1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283typedef unsigned long long uint64;class Solution { uint64 fastPower(uint64 a, uint64 n, uint64 mod) { uint64 res = 1; while(n) { if(n &amp; 1) { res = (res * a) % mod; } a = (a * a) % mod; n &gt;&gt;= 1; } return res % mod; } // 快速幂 uint64 powerOfproduct(uint64 k) { long long value = 0; for(int mask_off = 64; mask_off &gt;= 1; mask_off--) { uint64 mask = 1l &lt;&lt; (mask_off - 1); if(!(mask &amp; k)) continue; k = k &amp; ~mask; value += ((k|mask) - mask + 1) * (mask_off - 1); value += mask / 2 * ((mask_off - 1)*(mask_off - 2)/2); } return value; } // 小于等于k的所有数的指数和 uint64 totalOneOf(uint64 k) { long long value = 0; for(int mask_off = 64; mask_off &gt;= 1; mask_off--) { uint64 mask = 1l &lt;&lt; (mask_off - 1); if(!(mask &amp; k)) continue; k = k &amp; ~mask; value += ((k|mask) - mask + 1); value += mask / 2 * (mask_off - 1); } return value; } // 小于等于k的所有数的1的个数 uint64 findLeftRange(uint64 pos) { uint64 l = 0, r = pos; while(l &lt; r) { uint64 mid = (r - l + 1) / 2 + l; uint64 totalOnOfPos = totalOneOf(mid); if(totalOnOfPos &lt; pos) { l = mid; } else { r = mid - 1; } } return l; } // 二分查找下标在数组中对应的数的前一个数 uint64 powerSumTo(uint64 k, uint64 pos) { uint64 powerSum = 0; int cnt = 0; for(int off = 0; off &lt; 64; off++) { uint64 mask = 1l &lt;&lt; off; if(k &amp; mask) { cnt++; if(cnt &lt;= pos) { powerSum += off; } else { break; } } } return powerSum; } // 计算k的前pos个1对应的指数和public: vector&lt;int&gt; findProductsOfElements(vector&lt;vector&lt;long long&gt;&gt;&amp; queries) { vector&lt;int&gt; anwser; for(const auto&amp; query: queries) { uint64 leftRange0 = findLeftRange(query[0]+1) + 1; uint64 leftRange1 = findLeftRange(query[1]+1) + 1; uint64 totalOneOf0 = totalOneOf(leftRange0 - 1); uint64 totalOneOf1 = totalOneOf(leftRange1 - 1); uint64 powerSum0 = powerSumTo(leftRange0, query[0] - totalOneOf0); uint64 powerSum1 = powerSumTo(leftRange1, query[1]+1 - totalOneOf1); uint64 power = (powerOfproduct(leftRange1 - 1) - powerOfproduct(leftRange0 - 1) + powerSum1 - powerSum0); anwser.push_back(fastPower(2, power, query[2])); } return anwser; }}; 使用和3007. 价值和小于等于 K 的最大数字相同的思路，找到O(1)的计算小于等于N的1的个数 通过二分查找就可以找到big_nums下标对应的数，由于所求数是2的幂的积，所以再计算这个数之前的所有数的乘积的指数，两个指数相减，再模n快速幂即可求得最终答案 2956. 找到两个数组中的公共元素12345678910111213141516171819202122class Solution {public: vector&lt;int&gt; findIntersectionValues(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { int ans1 = 0, ans2 = 0; unordered_map&lt;int, int&gt; m1, m2; for(int num1 : nums1) { m1[num1]++; } for(int num2 : nums2) { if(m1.count(num2)) { ans2++; } m2[num2]++; } for(int num1 : nums1) { if(m2.count(num1)) { ans1++; } } return {ans1, ans2}; }};","link":"/home/2024/08/18/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9336/"},{"title":"LeetCode-9","text":"92. 反转链表 II思路 两个指针a、b，分别找到被反转的第一个结点的前一个结点，被反转的结点的最后一个结点，（在开头设置一个哑结点，防止被反转的第一个结点是头结点） 再来一个指针c，保存被反转的最后一个结点的next，然后把最后一个结点的next设为null 反转链表，然后把新链表的head接回去，把c接回到末尾 返回哑结点的next，不能返回head，因为反转以后，head有可能不是head了 AC代码1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseBetween(ListNode* head, int m, int n) { ListNode* dummy = new ListNode(0), *a, *b, *c; dummy-&gt;next = head; a = b = c = dummy; for (int i = 0; i &lt; m - 1; i++) { a = a-&gt;next; b = b-&gt;next; } for (int i = 0; i &lt; n - m + 1; i++) { b = b-&gt;next; } c = b-&gt;next; b-&gt;next = NULL; a-&gt;next = reverseList(a-&gt;next); while (a-&gt;next != NULL) { a = a-&gt;next; } a-&gt;next = c; return dummy-&gt;next; } ListNode* reverseList(ListNode* head) { if (head == NULL || head-&gt;next == NULL) return head; ListNode *temp = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return temp; }}; 15. 三数之和思路 遍历数组，取每个值的相反数作为target，然后转化为两数之和的问题，去重时要注意 保证target只查找一次 保证第二个循环j = i + 1开始 保证查找到的数的下标 c &gt; j 保证第二次循环的相同元素对应的值不会被反复查找，即变量find AC代码1234567891011121314151617181920212223242526272829303132class Solution {public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); int len = nums.size(); vector&lt;vector&lt;int&gt;&gt; ans; map&lt;int, int&gt; m; for (int i = 0; i &lt; len; i++) { m[nums[i]] = i + 1; } for (int i = 0; i &lt; len; ) { int target = -nums[i]; for (int j = i + 1; j &lt; len;) { int find = target - nums[j]; if (m.count(find)) { int c = m[find] - 1; //cout &lt;&lt; nums[i] &lt;&lt; nums[j] &lt;&lt; nums[c] &lt;&lt; endl; if (c &gt; j) { ans.push_back({nums[i], nums[j], nums[c]}); } } while (j &lt; len &amp;&amp; nums[j] == target - find) { j++; } } while (i &lt; len &amp;&amp; nums[i] == -target) { i++; } } return ans; }}; 大佬思路二分查找大佬代码123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { set&lt;vector&lt;int&gt;&gt; ans; if(nums.size()&lt;3)return vector&lt;vector&lt;int&gt;&gt;(ans.begin(),ans.end()); sort(nums.begin(),nums.end()); int left,right,target; for(int i=0;i&lt;nums.size()-2;++i){ if(nums[i] &gt; 0) { break; } if(nums[i] == nums[i - 1] &amp;&amp; i &gt; 0) continue; left=i+1,right=nums.size()-1,target=-nums[i]; while(left&lt;right){ if(nums[left]+nums[right]==target){ ans.insert({nums[i], nums[left], nums[right]}); ++left; --right; }else if(nums[left]+nums[right]&gt;target){ --right; }else { ++left; } } } return vector&lt;vector&lt;int&gt;&gt;(ans.begin(),ans.end()); }}; 43. 字符串相乘思路两层for循环相乘，把相乘的结果全都加起来 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution {public: string multiply(string num1, string num2) { int len1 = num1.length(), len2 = num2.length(); int len = len1 &gt; len2 ? len1 : len2; string zero(len - len1, '0'); num1 = zero + num1; zero = string(len - len2, '0'); num2 = zero + num2; string ans = &quot;0&quot;; for (int i = len - 1; i &gt;= 0; i--) { string temp = num1; int carry = 0; zero = string(len - 1 - i, '0'); for (int j = len - 1; j &gt;= 0; j--) { temp[j] = ((num1[j] - '0')*(num2[i] - '0') + carry)%10+ '0'; carry = ((num1[j] - '0')*(num2[i] - '0') + carry)/10; } temp = string(1, carry + '0') + temp + zero; ans = addStrings(ans, temp); } int i = 0; while (ans[i] == '0') i++; len = ans.length(); return i == len ? &quot;0&quot; : ans.substr(i, len - i); } string addStrings(string&amp; num1, string&amp; num2) { int carry = 0; int len1 = num1.length(); int len2 = num2.length(); int len = len1 &gt; len2 ? len1 : len2; string zero = string(len - len1, '0'); num1 = zero + num1; zero = string(len - len2, '0'); num2 = zero + num2; for (int i = len - 1; i &gt;= 0; i--) { int n = carry + num1[i] + num2[i] - 2*'0'; num1[i] = n % 10 + '0'; carry = n / 10; } if (carry) num1.insert(0, 1, carry + '0'); return num1; }}; 73. 矩阵置零思路想写出来很简单，目前是空间O(M+N)的算法 AC代码12345678910111213141516171819202122232425class Solution {public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int r = matrix.size(), c = matrix[0].size(); unordered_map&lt;int, bool&gt; rows, cols; for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { if (matrix[i][j] == 0) { rows[i] = true; cols[j] = true; } } } for (auto x : rows) { for (int i = 0; i &lt; c; i++) { matrix[x.first][i] = 0; } } for (auto x : cols) { for (int i = 0; i &lt; r; i++) { matrix[i][x.first] = 0; } } }}; 60. 第k个排列思路没研究这个，stl直接调用 AC代码12345678910111213class Solution {public: string getPermutation(int n, int k) { string ans; for (int i = 1; i &lt;= n; i++) { ans += char(i + '0'); } for (int i = 0; i &lt; k - 1; i++) { next_permutation(ans.begin(), ans.end()); } return ans; }}; 大佬代码123456789101112131415161718192021222324252627282930static const auto io_sync_off = [](){ // turn off sync std::ios::sync_with_stdio(false); // untie in/out streams std::cin.tie(nullptr); return nullptr;}();class Solution {public: string recursive(int n, int k, int * order, string &amp;str) { if (n == 0) return &quot;&quot;; int num = (k - 1) / order[n - 1]; char c = str[num]; str.erase(str.begin() + num); return c + recursive(n - 1, k - num * order[n - 1], order, str); } string getPermutation(int n, int k) { int order[n + 1] = {1}; string str; for (int i = 1; i &lt; n + 1; i++) { order[i] = i * order[i - 1]; str.push_back(48 + i); } return recursive(n, k, order, str); }}; 34. 在排序数组中查找元素的第一个和最后一个位置思路一次二分查找，然后向前向后遍历，找到开始和结束，但是最坏情况下，算法从$O(log_2n)$变成$O(n)$ AC代码123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) { int len = nums.size(); if (!len) return {-1, -1}; int low = 0, high = len - 1; bool find = false; int pos = 0; while (low &lt;= high) { int mid = low + (high - low)/2; if (nums[mid] == target) { find = true; pos = mid; break; } else if (nums[mid] &gt; target) { high = mid - 1; } else { low = mid + 1; } } if (!find) { return {-1, -1}; } int beg , end; beg = end = pos; while (beg &gt;= 0 &amp;&amp; nums[pos] == nums[beg]) beg--; while (end &lt; len &amp;&amp; nums[pos] == nums[end]) end++; return {beg + 1, end - 1}; }}; 24. 两两交换链表中的节点AC代码12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* swapPairs(ListNode* head) { ListNode dummy(0), *h; dummy.next = head;//哑结点定义为局部变量，防止内存泄漏 h = &amp;dummy; while (h-&gt;next != NULL) { if (h-&gt;next-&gt;next != NULL) { ListNode *a = h-&gt;next, *b = h-&gt;next-&gt;next; a-&gt;next = b-&gt;next; b-&gt;next = a; h-&gt;next = b; h = h-&gt;next-&gt;next; } else { break; } } return dummy.next; }}; 47. 全排列 IIAC代码123456789101112class Solution {public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; ans; do { ans.push_back(nums); }while (next_permutation(nums.begin(), nums.end())); ans.erase(unique(ans.begin(), ans.end()),ans.end()); return ans; }}; 大佬代码12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;bool&gt; b; vector&lt;int&gt; v; void dfs(int i, const vector&lt;int&gt;&amp; nums) { if(i == nums.size()){ ans.push_back(v); return; } for(int j = 0; j &lt; nums.size(); ++j){ if(j &gt; 0 &amp;&amp; nums[j - 1] == nums[j] &amp;&amp; !b[j - 1])continue; if(!b[j]){ b[j] = 1; v[i] = nums[j]; dfs(i + 1, nums); b[j] = 0; } } return; } vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); v.resize(nums.size()); b.resize(nums.size()); dfs(0, nums); return ans; }}; 49. 字母异位词分组思路 stl使劲套，要用multiset，两个单词字符集相同但是字符个数不同 优化，不用set，map变成string，字符集的字符串排序后对应唯一的“特征字符串” AC代码1234567891011121314151617181920212223class Solution {public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) { map&lt;multiset&lt;char&gt;, vector&lt;string&gt;&gt; m; int num = strs.size(); for (auto &amp;x : strs) { multiset&lt;char&gt; s(x.begin(), x.end()); m[s].push_back(x); } vector&lt;vector&lt;string&gt;&gt; ans; for (auto &amp;x : m) { ans.push_back(x.second); } return ans; }};static const auto io_sync_off = []() { // turn off sync std::ios::sync_with_stdio(false); // untie in/out streams std::cin.tie(nullptr); return nullptr;}(); AC代码（优化）12345678910111213141516class Solution {public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) { unordered_map&lt;string, vector&lt;string&gt;&gt; m; for (auto &amp;x : strs) { string temp = x; sort(x.begin(), x.end()); m[x].push_back(temp); } vector&lt;vector&lt;string&gt;&gt; ans; for (auto &amp;x : m) { ans.push_back(x.second); } return ans; }}; 80. 删除排序数组中的重复项 II思路双指针遍历一遍数组， AC代码123456789101112131415class Solution { public: int removeDuplicates(vector&lt;int&gt; &amp;nums) { int i = 0, j = 0; int len = nums.size(); while (i &lt; len) { if (j &lt; 2 || nums[i] &gt; nums[j - 2]) { int n = nums[i]; nums[j++] = n; } i++; } return j; }};","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%939/"},{"title":"LeetCode-7","text":"532. 数组中的K-diff数对思路 map，保存每个数出现的次数 遍历map，如果要找差为0的数对，那么如果出现次数大于1，说明有一对儿 如果差不是0，算出另一个数，在map里面查询，查询到了就是一对儿 AC代码12345678910111213141516171819202122class Solution {public: int findPairs(vector&lt;int&gt;&amp; nums, int k) { if (k &lt; 0) return 0; map&lt;int, int&gt; m; for (int x : nums) { m[x]++; } int ans = 0; auto ite = m.begin(); while (ite != m.end()) { if (k) { int sum = ite-&gt;first + k; if (m.count(sum)) ans++;//这里要用count函数查询是否存在元素，直接访问会超时 } else { if (ite-&gt;second &gt; 1) ans++; } ite++; } return ans; }}; 70. 爬楼梯思路 在纸上计算，可以发现是斐波那契数列的第n+1项 AC代码123456789101112131415class Solution {public: int climbStairs(int n) { return fib(n + 1); } int fib(int N) { int a = 0, b = 1; for (int i = 0; i &lt; N; i++) { int c = a + b; b = a; a = c; } return a; }}; 429. N叉树的层序遍历思路遍历爷爷辈的数组，每次把孙子辈们全都放在一个sub数组里面，如果push完以后非空，就push到ans里面，然后把父亲辈放到fatherTemp数组里面，作为下一次的爷爷辈。为了处理第1第2辈，建立两个哑节点，统一算法 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445/*// Definition for a Node.class Node {public: int val; vector&lt;Node*&gt; children; Node() {} Node(int _val, vector&lt;Node*&gt; _children) { val = _val; children = _children; }};*/class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) { if (!root) return {}; Node *root1 = new Node(); Node *root2 = new Node(); root2-&gt;children.push_back(root); root1-&gt;children.push_back(root2); vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; sub; vector&lt;Node*&gt; m = {root1}; vector&lt;Node*&gt;&amp; father = m; while (father.size()) { sub.clear(); vector&lt;Node*&gt; fatherTemp; for (Node* x : father) { for (Node* y : x-&gt;children) { for (Node* z : y-&gt;children) { sub.push_back(z-&gt;val); } fatherTemp.push_back(y); } } if (sub.size()) ans.push_back(sub); father = fatherTemp; } return ans; }}; 大佬思路大佬代码1234567891011121314151617181920static auto x = []() { std::ios::sync_with_stdio(false);std::cin.tie(nullptr);return 0;}();class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) { vector&lt;vector&lt;int&gt;&gt; ans; queue&lt;Node*&gt; que; if(!root) return ans; que.push(root); while(!que.empty()){ int k=que.size(); ans.resize(ans.size()+1); for(int i=0;i&lt;k;i++){ ans[ans.size()-1].push_back(que.front()-&gt;val); for(Node* node:que.front()-&gt;children) que.push(node); que.pop(); } } return ans; }}; 102. 二叉树的层次遍历思路和上一题429. N叉树的层序遍历一个想法 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { if (!root) return {}; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; sub; TreeNode *root1 = new TreeNode(0), *root2 = new TreeNode(0); root2-&gt;left = root; root1-&gt;left = root2; TreeNode* temp = root1; vector&lt;TreeNode*&gt; m = {root1}; vector&lt;TreeNode*&gt;&amp; father = m; vector&lt;TreeNode*&gt; fatherTemp; while (father.size()) { fatherTemp.clear(); sub.clear(); for (TreeNode* x : father) { if (x-&gt;left != NULL) { fatherTemp.push_back(x-&gt;left); if (x-&gt;left-&gt;left != NULL) sub.push_back(x-&gt;left-&gt;left-&gt;val); if (x-&gt;left-&gt;right != NULL) sub.push_back(x-&gt;left-&gt;right-&gt;val); } if (x-&gt;right != NULL) { fatherTemp.push_back(x-&gt;right); if (x-&gt;right-&gt;left != NULL) sub.push_back(x-&gt;right-&gt;left-&gt;val); if (x-&gt;right-&gt;right != NULL) sub.push_back(x-&gt;right-&gt;right-&gt;val); } } if (sub.size()) ans.push_back(sub); father = fatherTemp; } return ans; }}; 404. 左叶子之和思路 递归 如果左边的左边和左边的右边都是空，那么我的左边就是个叶子 改进，不用vector存结点的指针，直接加起来 AC代码1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int sumOfLeftLeaves(TreeNode* root) { vector&lt;TreeNode*&gt; leaves; int ans = 0; getLeaves(root, leaves); for (auto x : leaves) { ans += x-&gt;val; } return ans; } void getLeaves(TreeNode* root, vector&lt;TreeNode*&gt;&amp; leaves) { if (root == NULL) return; if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) return; if (root-&gt;left != NULL) { if (root-&gt;left-&gt;left == NULL &amp;&amp; root-&gt;left-&gt;right == NULL) { leaves.push_back(root-&gt;left); } } getLeaves(root-&gt;left, leaves); getLeaves(root-&gt;right, leaves); }}; AC代码（改进）1234567891011121314151617181920class Solution {public: int sumOfLeftLeaves(TreeNode* root) { vector&lt;TreeNode*&gt; leaves; int ans = 0; getLeaves(root, ans); return ans; } void getLeaves(TreeNode* root, int&amp; sum) {//传入引用 if (root == NULL) return; if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) return; if (root-&gt;left != NULL) { if (root-&gt;left-&gt;left == NULL &amp;&amp; root-&gt;left-&gt;right == NULL) { sum += root-&gt;left-&gt;val; } } getLeaves(root-&gt;left, sum); getLeaves(root-&gt;right, sum); }}; 492. 构造矩形思路 两个变量a，b,a = sqrt(area)，a++不断搜索，直到第一个为整数，然后a = sqrt(area)开始不断a–搜索，得到两组可能的答案，比较谁的差距小，然后输出 优化，只搜索一半就行 AC代码12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;int&gt; constructRectangle(int area) { int a1 = sqrt(area); int b1 = 0; int a2 = a1; int b2 = 0; while (area % a1) { a1--; } b1 = area / a1; while (area % a2) { a2++; } b2 = area / a2; int ansa, ansb; if (abs(a1 - b1) &gt; abs(a2 - b2)) { ansa = a2; ansb = b2; } else { ansa = a1; ansb = b1; } if (ansa &gt; ansb) { int t = ansa; ansa = ansb; ansb = t; } return {ansb, ansa}; }}; AC代码（优化）1234567891011121314class Solution {public: vector&lt;int&gt; constructRectangle(int area) { int a1 = sqrt(area); int b1 = 0; int a2 = a1; int b2 = 0; while (area % a1) { a1--; } b1 = area / a1; return {b1, a1}; }}; 453. 最小移动次数使数组元素相等思路 没思路，评论说可以推导公式，就推出来了 $ans = \\Sigma_{i=0}^{nums.size() - 1}[nums[i] - min(nums)]$ 公式推导思路（以下字母ASCII越大，代表的值就越大） {a}——0 {b, a}——b - a {c, b, a}——b - a + c - a 从a开始，先让a等于b，然后让两个b等于第三小的数，让三个第三小的数等于第四小的数… AC代码12345678910111213141516class Solution {public: int minMoves(vector&lt;int&gt;&amp; nums) { int min = INT_MAX; for (int x : nums) { if (x &lt; min) { min = x; } } int ans = 0; for (int x : nums) { ans += x - min; } return ans; }}; AC代码（优化）1234567891011121314class Solution {public: int minMoves(vector&lt;int&gt;&amp; nums) { long long min = INT_MAX, ans = 0, len = nums.size(), sum = 0; for (int x : nums) { if (x &lt;= min) { min = x; } sum += x; } return sum - min*len; }}; 551. 学生出勤记录 I思路把统计连续相同字符个数和统计某一个字符出现次数的算法结合在一起就行 AC代码1234567891011121314151617181920212223class Solution {public: bool checkRecord(string s) { int maxL = 0, numA = 0; int len = s.length(); for (int i = 0; i &lt; len;) { int count = 0; if (s[i] == 'A') { numA++; i++;//统计'A'的个数 } else if (s[i] == 'L') { while (s[i] == 'L') { i++; count++;//统计连续的'L'的个数 } maxL = maxL &gt; count ? maxL : count; } else { i++; } } return numA &lt;= 1 &amp;&amp; maxL &lt;= 2; }}; 557. 反转字符串中的单词 III思路一个指针，进去以后保存一次指针位置，然后指针后移，移动到空格或者结束为止，保存一次指针的位置，reverse两个指针 AC代码123456789101112131415class Solution {public: string reverseWords(string s) { int i = 0; int len = s.length(); while (i &lt; len) { int beg = i; while (i &lt; len &amp;&amp; s[i] != ' ') i++; int end = i; reverse(s.begin() + beg, s.begin() + end); i++; } return s; }}; 559. N叉树的最大深度思路 把之前429. N叉树的层序遍历的代码直接拿来用 简化代码 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*// Definition for a Node.class Node {public: int val; vector&lt;Node*&gt; children; Node() {} Node(int _val, vector&lt;Node*&gt; _children) { val = _val; children = _children; }};*/class Solution {public: int maxDepth(Node* root) { return levelOrder(root).size(); } vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) { if (!root) return {}; Node *root1 = new Node(); Node *root2 = new Node(); root2-&gt;children.push_back(root); root1-&gt;children.push_back(root2); vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; sub; vector&lt;Node*&gt; m = {root1}; vector&lt;Node*&gt;&amp; father = m; while (father.size()) { sub.clear(); vector&lt;Node*&gt; fatherTemp; for (Node* x : father) { for (Node* y : x-&gt;children) { for (Node* z : y-&gt;children) { sub.push_back(z-&gt;val); } fatherTemp.push_back(y); } } if (sub.size()) ans.push_back(sub); father = fatherTemp; } return ans; }}; AC代码（简化）123456789101112131415161718192021222324252627class Solution {public: int maxDepth(Node* root) { if (!root) return {}; Node *root1 = new Node(); Node *root2 = new Node(); root2-&gt;children.push_back(root); root1-&gt;children.push_back(root2); vector&lt;Node*&gt; m = {root1}; vector&lt;Node*&gt;&amp; father = m; int count = 0; while (father.size()) { vector&lt;Node*&gt; fatherTemp; bool empty = true; for (Node* x : father) { for (Node* y : x-&gt;children) { if (y-&gt;children.size()) empty = false; fatherTemp.push_back(y); } } father = fatherTemp; if (!empty) count++; } return count; }}; 561. 数组拆分 I思路 排个序，把下标为偶数的项全都加起来 AC代码1234567891011class Solution {public: int arrayPairSum(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); int len = nums.size(), ans = 0; for (int i = 0; i &lt; len; i+=2) { ans += nums[i]; } return ans; }}; 566. 重塑矩阵思路 先把不能转换的排除 两个下标m，n，指向原来数组的行和列，当n为原来数组的c时，m++，n = 0 AC代码1234567891011121314151617181920212223class Solution {public: vector&lt;vector&lt;int&gt;&gt; matrixReshape(vector&lt;vector&lt;int&gt;&gt;&amp; nums, int r, int c) { int hight = nums.size(), width = nums[0].size(); if (r*c != hight*width) { return nums; } vector&lt;vector&lt;int&gt;&gt; ans; int m = 0,n = 0; for (int i = 0; i &lt; r; i++) { vector&lt;int&gt; temp; for (int j = 0; j &lt; c; j++) { if (n == width) { m++; n = 0; } temp.push_back(nums[m][n++]); } ans.push_back(temp); } return ans; }}; 575. 分糖果思路 map或者数组（已知数据范围）记录是否出现，一边遍历一边数 AC代码123456789101112131415class Solution {public: int distributeCandies(vector&lt;int&gt;&amp; candies) { int m[200001] = {0}; int len = candies.size(); int count = 0; for (auto x : candies) { if (m[x + 100000] == 0) { m[x + 100000] = 1; count++; } } return min(count, len / 2); }};","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%937/"},{"title":"LeetCode-dp","text":"leetcode 101的动态规划专题 基本动态规划：一维70. 爬楼梯12345678910111213class Solution {public: int climbStairs(int n) { int a=1,b=2; if(n&lt;2) return 1; for(int i = 2; i &lt;n ; i++) { int c = a+b; a=b; b=c; } return b; }}; dp数组表示上n层楼有几种可能转移方程是 $ dp[i] = dp[i-1] + dp[i-2] $上到第i层有可能从第i-1层或i-2层上来，则上到i层的可能数目就是 $ dp[i-1] + dp[i-2] $由于dp[i]只需要前两个数的数据，所以可以优化掉dp数组，用两个变量代替，节省数组空间 198. 打家劫舍状态记录1234567891011121314151617class Solution {public: int n; vector&lt;int&gt; mem; int rob(vector&lt;int&gt;&amp; nums) { this-&gt;n = nums.size(); mem = vector&lt;int&gt;(n+2, -1); return maxRob(nums, -2); } int maxRob(const vector&lt;int&gt;&amp; nums, int i) { if(i &lt; n &amp;&amp; mem[i+2] != -1) return mem[i+2]; int a = (i+2 &lt; n ? maxRob(nums, i+2) + nums[i+2] : 0); int b = (i+3 &lt; n ? maxRob(nums, i+3) + nums[i+3] : 0); mem[i+2] = (a &gt; b? a : b); return mem[i+2]; }}; 这是之前实习时写的代码思路不是dp，而是自上而下的带有状态记录的优先搜索思路相同，就是，若打劫i，则一定不能打劫i+1，考虑是打劫i+2还是i+3状态转移方程 $ dp[i] = nums[i] + max(dp[i+2], dp[i+3]) $ dp12345678910111213141516171819class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { int len = nums.size(); vector&lt;int&gt; dp(len); if(len == 1) { return nums[len-1]; } else if(len == 2) { return max(nums[len-1], nums[len-2]); } dp[len-1] = nums[len-1]; dp[len-2] = max(nums[len-1], nums[len-2]); dp[len-3] = max(nums[len-2], nums[len-3] + dp[len-1]); for(int i = len-4; i &gt;= 0; i--) { dp[i] = nums[i] + max(dp[i+3], dp[i+2]); } return max(dp[0], dp[1]); }}; 由于第0家可以打劫，也可以跳过，所以最终结果是 $ max(dp[0], dp[1]) $ 同上，也可以优化存储空间 1234567891011121314151617class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { int len = nums.size(); if(len == 1) { return nums[len-1]; } else if(len == 2) { return max(nums[len-1], nums[len-2]); } int a = nums[len-1],b = max(nums[len-1], nums[len-2]), c = max(nums[len-2], nums[len-3] + nums[len-1]); for(int i = len-4; i &gt;= 0; i--) { int d = nums[i] + max(a, b); a = b;b = c;c = d; } return max(b, c); }}; 121. 买卖股票的最佳时机1234567891011121314151617class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int len = prices.size(); int minPos = len-1; int maxx = prices[len-1]; int maxx1 = prices[len-1]; for(int i = len-2; i &gt;= 0; i--) { maxx1 = max(prices[i], maxx1); if(maxx1 - prices[i] &gt; maxx - prices[minPos]) { minPos = i; maxx = maxx1; } } return maxx - prices[minPos]; }}; 记maxx数组中 $ maxx[i] $ 表示 $ max(prices[j]); j = i,i+1,…,n-1 $假设在第i天买入，则应该在第i天后售价最高的一天卖出，也就是 $ maxx[i] $再把maxx数组优化掉 413. 等差数列划分1234567891011121314151617181920212223242526class Solution {public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; nums) { int len = nums.size(); if(len &lt; 3) return 0; int i = 2; int ans = 0; int count = 2; while(i &lt; len) { while(i &lt; len &amp;&amp; nums[i] - nums[i-1] == nums[i-1] - nums[i-2]) { i++; count++; } if(count &gt;= 3) { ans += (count-2)*(count-1)/2; } if(i &lt; len-1) { i += 1; count = 2; } else { break; } } return ans; }}; 由于求的是连续子数组中为等差数列的个数，可以把nums看作多个公差不同的等差数列拼接在一起只需要找到每段最长的等差数列，计算它有多少个子等差数列也就是 $$ \\sum_{i=3}^n(n+1-i) = (n-2) \\times (n-1)/2 $$ 其中n是等差数列的长度。应该没有用dp的思想吧？ dp版1234567891011int numberOfArithmeticSlices(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if (n &lt; 3) return 0; vector&lt;int&gt; dp(n, 0); for (int i = 2; i &lt; n; ++i) { if (nums[i] - nums[i-1] == nums[i-1] - nums[i-2]) { dp[i] = dp[i-1] + 1; } } return accumulate(dp.begin(), dp.end(), 0);} 举个例子可以看出若nums = [1,2,3,4,5,7,9,11]则dp = [0,0,1,2,3,0,1,2]一个等差数列中的 $ \\sum(dp[i]) $ 和我上面分析的 $ \\sum(n+1-i) $ 一样的 基本动态规划：二维64. 最小路径和12345678910111213141516171819class Solution {public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = grid.size(); int n = grid[0].size(); for(int i = 1; i &lt; m; i++) { grid[i][0] += grid[i-1][0]; } for(int i = 1; i &lt; n; i++) { grid[0][i] += grid[0][i-1]; } for(int i = 1; i &lt; m; i++) { for(int j = 1; j &lt; n; j++) { grid[i][j] += min(grid[i-1][j], grid[i][j-1]); } } return grid[m-1][n-1]; }}; 比较好想，因为只能向右或向下走，那么 对于 $ grid[i][j] (i &gt; 0 , j &gt; 0) $ ， 到达它的最短路径是 $ grid[i][j] + min(grid[i-1][j], grid[i][j-1]) $ 对于 $ grid[i][j] (i = 0 , j &gt; 0) $ ， 到达它的最短路径是 $ grid[i][j] + grid[i][j-1] $ 对于 $ grid[i][j] (i &gt; 0 , j = 0) $ ， 到达它的最短路径是 $ grid[i][j] + grid[i-1][j] $ dp数组压缩12345678910111213141516171819class Solution {public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = grid.size(); int n = grid[0].size(); vector&lt;int&gt; dp(n); dp[0] = grid[0][0]; for(int i = 1; i &lt; n; i++) { dp[i] = grid[0][i] + dp[i-1]; } for(int i = 1; i &lt; m; i++) { dp[0] += grid[i][0]; for(int j = 1; j &lt; n; j++) { dp[j] = grid[i][j] + min(dp[j], dp[j-1]); } } return dp[n-1]; }}; 每次只更新同一行也是可以的，因为每次只需要左边的和上一行的，其他的不需要 542. 01 矩阵未ac代码1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; mat) { int m = mat.size(), n = mat[0].size(); vector&lt;vector&lt;int&gt;&gt; ans(m, vector&lt;int&gt;(n, 20000)); for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; n; j++) { if(mat[i][j] == 0) { ans[i][j] = 0; } if(i-1 &gt;= 0) { ans[i][j] = min(ans[i-1][j]+1, ans[i][j]); } if(j-1 &gt;= 0) { ans[i][j] = min(ans[i][j-1]+1, ans[i][j]); } if(i+1 &lt; m) { ans[i][j] = min(ans[i+1][j]+1, ans[i][j]); } if(j+1 &lt; n) { ans[i][j] = min(ans[i][j+1]+1, ans[i][j]); } if(i-1 &gt;= 0) { ans[i-1][j] = min(ans[i-1][j], 1 + ans[i][j]); } if(j-1 &gt;= 0) { ans[i][j-1] = min(ans[i][j-1], 1 + ans[i][j]); } if(i+1 &lt; m) { ans[i+1][j] = min(ans[i+1][j], 1 + ans[i][j]); } if(j+1 &lt; n) { ans[i][j+1] = min(ans[i][j+1], 1 + ans[i][j]); } } } return ans; }}; 这个的想法和答案已经很接近了，但我只从一个方向上进行了更新，应该从四个角开始分别进行更新一次 ac代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution {public: vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int m = matrix.size(), n = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dist(m, vector&lt;int&gt;(n, INT_MAX / 2)); for (int i = 0; i &lt; m; ++i) { for (int j = 0; j &lt; n; ++j) { if (matrix[i][j] == 0) { dist[i][j] = 0; } } } for (int i = 0; i &lt; m; ++i) { for (int j = 0; j &lt; n; ++j) { if (i - 1 &gt;= 0) { dist[i][j] = min(dist[i][j], dist[i - 1][j] + 1); } if (j - 1 &gt;= 0) { dist[i][j] = min(dist[i][j], dist[i][j - 1] + 1); } } } for (int i = m - 1; i &gt;= 0; --i) { for (int j = 0; j &lt; n; ++j) { if (i + 1 &lt; m) { dist[i][j] = min(dist[i][j], dist[i + 1][j] + 1); } if (j - 1 &gt;= 0) { dist[i][j] = min(dist[i][j], dist[i][j - 1] + 1); } } } for (int i = 0; i &lt; m; ++i) { for (int j = n - 1; j &gt;= 0; --j) { if (i - 1 &gt;= 0) { dist[i][j] = min(dist[i][j], dist[i - 1][j] + 1); } if (j + 1 &lt; n) { dist[i][j] = min(dist[i][j], dist[i][j + 1] + 1); } } } for (int i = m - 1; i &gt;= 0; --i) { for (int j = n - 1; j &gt;= 0; --j) { if (i + 1 &lt; m) { dist[i][j] = min(dist[i][j], dist[i + 1][j] + 1); } if (j + 1 &lt; n) { dist[i][j] = min(dist[i][j], dist[i][j + 1] + 1); } } } return dist; }}; 101 其实从左上和右下两个方向就可以了 1234567891011121314151617181920212223242526272829303132vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { if (matrix.empty()) return {}; int n = matrix.size(), m = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(m, INT_MAX - 1)); for (int i = 0; i &lt; n; ++i) { for (int j = 0; j &lt; m; ++j) { if (matrix[i][j] == 0) { dp[i][j] = 0; } else { if (j &gt; 0) { dp[i][j] = min(dp[i][j], dp[i][j-1] + 1); } if (i &gt; 0) { dp[i][j] = min(dp[i][j], dp[i-1][j] + 1); } } } } for (int i = n - 1; i &gt;= 0; --i) { for (int j = m - 1; j &gt;= 0; --j) { if (matrix[i][j] != 0) { if (j &lt; m - 1) { dp[i][j] = min(dp[i][j], dp[i][j+1] + 1); } if (i &lt; n - 1) { dp[i][j] = min(dp[i][j], dp[i+1][j] + 1); } } } } return dp;} 221. 最大正方形1234567891011121314151617181920212223242526272829class Solution {public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) { int m = matrix.size(); if(m &lt;= 0) return 0; int n = matrix[0].size(); if(n &lt;= 0) return 0; int maxx = 0; vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); for(int i = m-1; i &gt;= 0; i--) { dp[i][n-1] = matrix[i][n-1] - '0'; maxx = max(maxx, dp[i][n-1]); } for(int i = n-1; i &gt;= 0; i--) { dp[m-1][i] = matrix[m-1][i] - '0'; maxx = max(maxx, dp[m-1][i]); } for(int i = m-2; i &gt;= 0; i--) { for(int j = n-2; j &gt;= 0; j--) { if(matrix[i][j] != '0') { int x = min(dp[i][j+1], min(dp[i+1][j], dp[i+1][j+1])); dp[i][j] = 1 + x + 2*sqrt(x); maxx = max(maxx, dp[i][j]); } } } return maxx; }}; 从右下角到左上角，dp表示以(i, j)为左上角顶点的最大正方形大小看点(i+1, j) (i, j+1) (i+1, j+1)三个点的最小值，在最小值的基础上增加一圈也就是边长+1，由于dp[i][j]表示的是面积， $ dp[i][j] = (sqrt(min)+1)^2 = min + 2 \\times sqrt(min) + 1 $在计算过程中记录max(dp[i][j]) 分割类型题279. 完全平方数12345678910111213141516class Solution {public: int numSquares(int n) { vector&lt;int&gt; dp(n+1, 0); for(int i = 1; i &lt;= n; i++) { int min = INT_MAX-1; for(int j = 1; i-j*j &gt;= 0; j++) { if(dp[i-j*j] &lt; min) { min = dp[i - j*j]; } } dp[i] = min+1; } return dp[n]; }}; dp[i]保存数字i的最少平方数之和，假设 $ i $ 由 $ j \\times j $ 和 $ i - j \\times j $ 相加而得，那么$$ dp[i] = min_{ j=1 }^{ \\sqrt i }(dp[i-j \\times j]) + 1 $$ 91. 解码方法123456789101112131415class Solution {public: int numDecodings(string s) { s = &quot;(&quot; + s + &quot;)&quot;; int n = s.size(); vector&lt;int&gt; dp(n, 0); dp[n-2] = 1; for(int i = n-3; i &gt;= 0; i--) { int number = s[i+1]*10 + s[i+2] - '0'*11; int number1 = s[i+1] - '0'; dp[i] = ((number &gt;= 10 &amp;&amp; number &lt;= 26) ? dp[i+2] : 0) + ((number1 &gt;= 1 &amp;&amp; number1 &lt;= 9) ? dp[i+1] : 0); } return dp[0]; }}; 在两个数之间添加隔板，并计算两个隔板之间数字是否合法dp[i]表示在数字i后添加一个隔板后，s[i…n-1]共有几种插入隔板的方式如果s[i+1]在1到9之间，则可以在i+1后加入一个隔板如果s[i+1…i+2]在10到26之间，则可以在i+1后不插入隔板而在i+2后加入隔板考虑到隔一个或两个数插入一个隔板，不需要考虑字符串更长的情况则转移方程为$ dp[i] = dp[i+1] + dp[i+2] \\quad if \\quad 1&lt;=s[i+1]&lt;=9 \\quad and \\quad 10&lt;=s[i+1…i+2]&lt;=26 $$ dp[i] = dp[i+2] \\quad if \\quad not \\quad 1&lt;=s[i+1]&lt;=9 \\quad and \\quad 10&lt;=s[i+1…i+2]&lt;=26 $$ dp[i] = dp[i+1] \\quad if \\quad 1&lt;=s[i+1]&lt;=9 \\quad and \\quad not \\quad 10&lt;=s[i+1…i+2]&lt;=26 $$ dp[i] = 0 \\quad if \\quad not \\quad 1&lt;=s[i+1]&lt;=9 \\quad and \\quad not \\quad 10&lt;=s[i+1…i+2]&lt;=26 $在s前后加入括号是为了避免反复写重复的逻辑，否则代码很冗余 123456789101112131415161718192021class Solution {public: int numDecodings(string s) { int n = s.size(); vector&lt;int&gt; dp(n, 0); if(n &lt; 1) return n; if(n == 1) return s[0] == '0' ? 0 : 1; int number = (s[n-2] - '0')*10 + (s[n-1] - '0'); int number1 = (s[n-1] - '0'); dp[n-1] = 1; dp[n-2] = ((number1 &gt;= 1 &amp;&amp; number1 &lt;= 9) ? dp[n-1] : 0); for(int i = n-3; i &gt;= 0; i--) { number = (s[i+1] - '0')*10 + (s[i+2] - '0'); number1 = (s[i+1] - '0'); dp[i] = ((number &gt;= 10 &amp;&amp; number &lt;= 26) ? dp[i+2] : 0) + ((number1 &gt;= 1 &amp;&amp; number1 &lt;= 9) ? dp[i+1] : 0); } number = (s[0] - '0')*10 + (s[1] - '0'); number1 = (s[0] - '0'); return ((number &gt;= 10 &amp;&amp; number &lt;= 26) ? dp[1] : 0) + ((number1 &gt;= 1 &amp;&amp; number1 &lt;= 9) ? dp[0] : 0); }}; 139. 单词拆分12345678910111213141516171819202122232425262728class Solution {public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) { unordered_map&lt;string, bool&gt; dict; for(string&amp; s : wordDict) { dict[s] = true; } int len = s.size(); vector&lt;int&gt; dp(len+1,0); dp[0] = 1; for(int i = 1; i &lt;= len; i++) { int j = i-1; bool flag = false; while(j &gt;= 0 &amp;&amp; !flag) { flag = dict[s.substr(dp[j]-1, i - dp[j] + 1)]; if(flag) break; while(j &gt; 0 &amp;&amp; dp[j-1] == dp[j]) j--; j--; } if(flag) { dp[i] = i+1; } else { dp[i] = dp[i-1]; } } return dp[len] == len+1; }}; 还是分割问题思路是判断在位置i之前插入一个隔板，用dp[i]记录最近一次匹配到字典中的单词的位置如leetcode， 对于 l,le,lee, 都没有匹配到，那么dp[i] = 0leet匹配到了，dp[i] = 4，通过dp[i-1]就可以知道要匹配 0-4的字串leetc,leetco,leetcod, 根据 dp[i-1] = 4，发现c，co，cd都不是字典中的串,dp[i] = dp[i-1];leetcode根据 dp[i-1] = 4，发现code是字串，那么dp[i] = i+1;最后检查dp[len]是否等于len + 1 上面的思路的一个问题是，对于字典中，子串也在字典内的串，不能只根据dp[i-1]决定子串范围要看dp[0]到dp[i-1]所有子串 1011234567891011121314151617class Solution {public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) { int len = s.size(); vector&lt;bool&gt; dp(len, false); dp[0] = true; for(int i = 0; i &lt;= len; i++) { for(string&amp; w : wordDict) { int length = w.size(); if(i &gt;= length &amp;&amp; w == s.substr(i-length, length)) { dp[i] = dp[i] || dp[i-length]; } } } return dp[len]; }}; 子序列问题300. 最长递增子序列123456789101112131415161718class Solution {public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; dp(n, 1); for(int i = 1; i &lt; n; i++) { int maxx = 0; for(int j = i-1; j &gt;= 0; j--) { if(nums[i] &gt; nums[j]) { dp[i] += dp[j]; break; } } dp[i] += maxx; } return *max_element(dp.begin(), dp.end()); }}; 这是最简单的方法，还可以用类似单调栈优化 1234567891011121314151617181920212223242526class Solution {public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if(n &lt;= 1) return n; vector&lt;int&gt; dp(n); dp[0] = nums[0]; int count = 1; for(int i = 1; i &lt; n; i++) { if(dp[count-1] &lt; nums[i]) { dp[count] = nums[i]; count++; } else { int pos = -1; for(int j = count-1; j &gt;= 0; j--) { if(dp[j] &lt; nums[i]) { pos = j; break; } } dp[pos+1] = nums[i]; } } return count; }}; 1143. 最长公共子序列1234567891011121314151617181920class Solution {public: int longestCommonSubsequence(string text1, string text2) { int m = text2.size(), n = text1.size(); vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n)); dp[0][0] = text1[0] == text2[0]; for(int i = 1; i &lt; m; i++) { dp[i][0] = max(dp[i-1][0], int(text1[0] == text2[i]) ); } for(int i = 1; i &lt; n; i++) { dp[0][i] = max(dp[0][i-1] , int(text1[i] == text2[0])); } //初始化 for(int i = 1; i &lt; m; i++) { for(int j = 1; j &lt; n; j++) { dp[i][j] = max(dp[i-1][j-1] + (text1[j] == text2[i]), max(dp[i-1][j], dp[i][j-1])); } } return dp[m-1][n-1]; }}; 稍微看了一下答案， $ dp[i][j] $ 表示遍历到 $ text1[i] $ , $ text2[j] $ 为止，最长子序列是多少 背包问题板子0-1背包123456789101112131415int knapsack(vector&lt;int&gt; weights, vector&lt;int&gt; values, int N, int W) { vector&lt;vector&lt;int&gt;&gt; dp(N + 1, vector&lt;int&gt;(W + 1, 0)); for (int i = 1; i &lt;= N; ++i) { int w = weights[i - 1], v = values[i - 1]; for (int j = 1; j &lt;= W; ++j) { if (j &gt;= w) { dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w] + v); } else { dp[i][j] = dp[i - 1][j]; } } } return dp[N][W];} 用自己的话说，问题就是有n种物品，每种物品有1个，背包有总容量限制，每种物品有一定价值。怎样装入物品，在容量限制下，尽量让背包价值最大$ dp[i][j] $ 表示当遍历到第i个物品时，背包容量为j时（可以不满），背包的最大价值所以状态转移函数是$$dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w_{i-1}] + v_{i-1}), \\quad j&gt;=w_{i-1} $$$$dp[i][j] = dp[i - 1][j], \\quad j &lt; w_{i-1}$$ 0-1背包的压缩 12345678910int knapsack(vector&lt;int&gt; weights, vector&lt;int&gt; values, int N, int W) { vector&lt;int&gt; dp(W + 1, 0); for (int i = 1; i &lt;= N; ++i) { int w = weights[i - 1], v = values[i - 1]; for (int j = W; j &gt;= w; --j) { dp[j] = max(dp[j], dp[j - w] + v); } } return dp[W];} 完全背包123456789101112131415int knapsack(vector&lt;int&gt; weights, vector&lt;int&gt; values, int N, int W) { vector&lt;vector&lt;int&gt;&gt; dp(N + 1, vector&lt;int&gt;(W + 1, 0)); for (int i = 1; i &lt;= N; ++i) { int w = weights[i - 1], v = values[i - 1]; for (int j = 1; j &lt;= W; ++j) { if (j &gt;= w) { dp[i][j] = max(dp[i - 1][j], dp[i][j - w] + v); } else { dp[i][j] = dp[i - 1][j]; } } } return dp[N][W];} 和0-1背包不同的是，每个物品有无限个，因此也需要正向遍历，且状态转移函数中，应该是同列中+物品价值，这样才能向背包中放入多个物品状态转移函数是$$dp[i][j] = max(dp[i - 1][j], dp[i][j - w_{i-1}] + v_{i-1}), \\quad j&gt;=w_{i-1} $$$$dp[i][j] = dp[i - 1][j], \\quad j &lt; w_{i-1}$$ 完全背包的空间压缩12345678910int knapsack(vector&lt;int&gt; weights, vector&lt;int&gt; values, int N, int W) { vector&lt;int&gt; dp(W + 1, 0); for (int i = 1; i &lt;= N; ++i) { int w = weights[i - 1], v = values[i - 1]; for (int j = w; j &lt;= W; ++j) { dp[j] = max(dp[j], dp[j - w] + v); } } return dp[W];} 101书中说 “0-1 背包对物品的迭代放在外层，里层的体积或价值逆向遍历；完全背包对物品的迭代放在里层，外层的体积或价值正向遍历。” 但我认为，完全背包正向遍历体积，0-1背包反向遍历体积，内层和外层遍历物品还是容量并没有影响 416. 分割等和子集1234567891011121314151617class Solution {public: bool canPartition(vector&lt;int&gt;&amp; nums) { int sum = accumulate(nums.begin(), nums.end(), 0); if(sum &amp; 1) return false; int target = sum/2; int n = nums.size(); vector&lt;int&gt; dp(target+1, 0); for(int i = 1; i &lt;= n; i++) { int w = nums[i-1], v = nums[i-1]; for(int j = target; j&gt;=w; j--) { dp[j] = max(dp[j], dp[j-w] + v); } } return dp[target] == sum-target; }}; 看了一眼答案的思路，知道背包总容量是 $ sum/2 $ 才写出来 101123456789101112131415161718class Solution {public: bool canPartition(vector&lt;int&gt;&amp; nums) { int sum = accumulate(nums.begin(), nums.end(), 0); if(sum &amp; 1) return false; int target = sum/2; int n = nums.size(); vector&lt;bool&gt; dp(target+1, false); dp[0] = true; for(int i = 1; i &lt;= n; i++) { int w = nums[i-1]; for(int j = target; j&gt;=w; j--) { dp[j] = dp[j] || dp[j-w]; } } return dp[target]; }}; 如果放入数nums[i]后，背包容量变成0了，那么说明可以装满背包 474. 一和零123456789101112131415161718class Solution {public: int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) { int strnum = strs.size(); vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for(int i = 1; i &lt;= strnum; i++) { int strlen = strs[i-1].size(); int count0, count1 = accumulate(strs[i-1].begin(), strs[i-1].end(), -strlen*'0'); count0 = strlen-count1; for(int j = m; j &gt;= count0; j--) { for(int k = n; k &gt;= count1; k--) { dp[j][k] = max(dp[j][k], dp[j-count0][k-count1]+1); } } } return dp[m][n]; }}; 喵了一眼答案说要用二维背包，就写了，就过了但是还是晕晕的，感觉只是在套模板 322. 零钱兑换123456789101112131415161718192021class Solution {public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { int coinTypes = coins.size(); vector&lt;vector&lt;int&gt;&gt; dp(coinTypes+1, vector&lt;int&gt;(amount+1, 0)), dp1(coinTypes+1, vector&lt;int&gt;(amount+1, 0)); for(int i = 1; i &lt;= coinTypes; i++) { dp[i][0] = amount; int w = coins[i-1]; for(int j = 1; j &lt;= amount; j++) { if(j &gt;= w) { dp[i][j] = max(dp[i-1][j], dp[i][j-w]-1); dp1[i][j] = max(dp1[i-1][j], dp1[i][j-w]+w); } else { dp[i][j] = dp[i-1][j]; dp1[i][j] = dp1[i-1][j]; } } } return (dp1[coinTypes][amount] == amount) ? amount - dp[coinTypes][amount] : -1; }}; 太慢了，非常简单的想法，一个记录用了多少硬币，一个记录当前背包内总价值 空间压缩12345678910111213141516class Solution {public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { int coinTypes = coins.size(); vector&lt;int&gt; dp(amount+1, 0), dp1(amount+1, 0); dp[0] = amount; for(int i = 1; i &lt;= coinTypes; i++) { int w = coins[i-1]; for(int j = w; j &lt;= amount; j++) { dp[j] = max(dp[j], dp[j-w]-1); dp1[j] = max(dp1[j], dp1[j-w]+w); } } return (dp1[amount] == amount) ? amount - dp[amount] : -1; }}; 101123456789101112131415class Solution {public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { int coinTypes = coins.size(); vector&lt;int&gt; dp(amount+1, amount+1); dp[0] = 0; for(int i = 1; i &lt;= amount; i++) { for(int j = 1; j &lt;= coinTypes; j++) { int w = coins[j-1]; if(i &gt;= w) dp[i] = min(dp[i], dp[i-w]+1); } } return (dp[amount] == amount+1) ? -1 : dp[amount]; }}; 硬币的价值不用-1而用1，dp表示硬币数，找min，那么dp初值就不能是0无限背包，外层容量，内层物品, 这里没有理解如果dp[amount]是amount+1，说明没有填满，如果填满了，硬币数量一定小于amount+1 123456789101112131415class Solution {public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { int coinTypes = coins.size(); vector&lt;int&gt; dp(amount+1, amount+1); dp[0] = 0; for(int i = 1; i &lt;= coinTypes; i++) { int w = coins[i-1]; for(int j = w; j &lt;= amount; j++) { dp[j] = min(dp[j], dp[j-w]+1); } } return (dp[amount] == amount+1) ? -1 : dp[amount]; }}; 内层容量，外层物品也能过，还可以快一点 字符串编辑72. 编辑距离1234567891011121314151617181920class Solution {public: int minDistance(string word1, string word2) { int len1 = word1.size(), len2 = word2.size(); vector&lt;vector&lt;int&gt;&gt; dp(len1+1, vector&lt;int&gt;(len2+1, 0)); for(int i = 0; i &lt;= len1; i++) { dp[i][0] = i; } for(int i = 0; i &lt;= len2; i++) { dp[0][i] = i; } for(int i = 1; i &lt;= len1; i++) { for(int j = 1; j &lt;= len2; j++) { int x = int(word1[i-1] != word2[j-1]); dp[i][j] = min(x + dp[i-1][j-1], min(dp[i-1][j]+1, dp[i][j-1]+1)); } } return dp[len1][len2]; }}; 650. 只有两个键的键盘123456789101112131415class Solution {public: int minSteps(int n) { vector&lt;int&gt; dp(n+1, 0); for(int i = 2; i &lt;= n; i++) { dp[i] = i; for(int j = 2; j &lt;= i; j++) { if(i%j == 0) { dp[i] = min(dp[i], dp[j]+i/j); } } } return dp[n]; }}; 复杂度为 $ n^2 $ 123456789101112131415class Solution {public: int minSteps(int n) { vector&lt;int&gt; dp(n+1, 0); for(int i = 2; i &lt;= n; i++) { dp[i] = i; for(int j = 2; j*j &lt;= i; j++) { if(i%j == 0) { dp[i] = dp[j] + dp[i/j]; } } } return dp[n]; }}; 如果j 可以被i 整除，那么长度i 就可以由长度j 操作得到，其操作次数等价于把一个长度为1的A 延展到长度为i/j","link":"/home/2022/11/08/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93dp/"},{"title":"LeetCode-数据库-1","text":"181. 超过经理收入的员工思路 Employee表中给出员工id，员工的manager的id 按照managerid和员工id自连接一下，使用内连接去掉null 筛选员工工资大于管理员工资的 知识点 判断相等用单引号 代码12345SELECT E1.name AS EmployeeFROM Employee E1 INNER JOIN Employee E2 ON E1.managerId = E2.id AND E1.salary &gt; E2.salary 182. 查找重复的电子邮箱知识点 group by 根据元组进行分组 having 根据条件将聚合后的分组进行筛选（可否理解为对分组整体的where语句？） 代码1234SELECT EmailFROM PersonGROUP BY emailHAVING count(email) &gt; 1; 183. 从不订购的客户思路 一个顾客表，一个订单表 顾客表和订单表左连接，按照顾客id连接 没有订单的顾客通过左连接会产生null，用where找出含有null的行 知识点 左连接，右边存在null依然保留左边，左边有null就不保留 右连接，右边存在null不保留左边，右边有null就不保留 内连接，不论左右，有null就不保留 代码123SELECT name AS CustomersFROM Customers LEFT JOIN Orders O ON O.customerId = Customers.id WHERE O.customerId IS NULL; 196. 删除重复的电子邮箱思路 对于有重复的email，保留id最小的一项，删除剩余的重复项 依照email进行group by 使用min找到每个email的最小值 将上面的结果作为子查询，若id不在其中，则删除 不允许删除表时对表作查询，需要再嵌套一层子查询 知识点 子查询必须指定别名紧跟在子查询的括号后面 一般来说，DELETE FROM XXX WHERE &lt;-condition-&gt; 代码12345678DELETE FROM PersonWHERE id NOT IN (SELECT T.id FROM (SELECT MIN(id) as id FROM Person GROUP BY email) T);-- 不允许删除与查询在同一个表上DELETE FROM PersonWHERE id NOT IN (SELECT MIN(id) as id FROM Person GROUP BY email); 197. 上升的温度思路 如果第二天温度比第一天高，就输出 同一张表自连接，筛选出日期相差一天且温度升高的 知识点1FROM A, B, C, ... WHERE &lt;-condition-&gt; 相当于对所有表全连接，然后根据WHERE筛选 1FROM A XXX JOIN B ON &lt;-condition1-&gt; XXX JOIN C ON &lt;-condition2-&gt; ... 相当依次连接各个表，且可以控制连接的方式（左、右、全），并根据条件筛选 timestampdiff(expr, date1, date2) 根据expr计算两个date的差值 如果expr是day，就是算差距多少天 代码1234SELECT W2.idFROM Weather W1 JOIN Weather W2ON timestampdiff(day, W2.recordDate, W1.recordDate) = -1AND W2.temperature &gt; W1.temperature; 1234SELECT W2.idFROM Weather W1, Weather W2WHERE timestampdiff(day, W2.recordDate, W1.recordDate) = -1AND W2.temperature &gt; W1.temperature; 511. 游戏玩法分析 I思路 找到每个用户第一次登录的时间 group by用户id，然后通过min计算最小日期 代码123SELECT player_id, min(event_date) AS first_loginFROM ActivityGROUP BY player_id 550. 游戏玩法分析 IV思路 判断有多少用户在第一次登录后的第二天也登录游戏了 创建子查询查找每个用户的第一次登录时间 子查询与用户登录时间表左连接，按照用户id 找到登录日期与第一次登录时间相差1天的行，如果第二天登陆了，则登录时间非空，否则登录时间为空 统计登录时间为空的个数，除以总用户个数 知识点 ADDDATE(date, expr) 根据expr在date的基础上相加 expr = INTERVAL 1 DAY表示在date的基础上加一天 ROUND(number, n) number精确到小数点后n位 代码12345678SELECT ROUND(count(event_date)/count(First_Login.player_id), 2) AS fractionFROM ( SELECT player_id, min(event_date) AS first_login FROM Activity GROUP BY player_id) First_Login LEFT JOIN ActivityON First_Login.player_id = Activity.player_idAND ADDDATE(First_Login.first_login, INTERVAL 1 DAY) = Activity.event_date 180. 连续出现的数字思路 表格自连接三次，筛选出id递增且num一样的 代码12345678910SELECT DISTINCT L3.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3WHERE L1.id = L2.id-1 AND L1.num = L2.num AND L2.id = L3.id-1 AND L2.num = L3.num 178. 分数排名 对分数进行排序，并给出排名，同分同排 思路1+知识点 row_number() + over(ORDER BY column_name [desc])函数可以按照列排序，并给出行号 但行号不能实现同分同排 按照分数GROUP BY，然后row_number + over计算出每个分数对应的排序 将上面的内容作为子查询，与成绩表相连接，就可以得到同分同排名了 代码1234567SELECT T.score, T.rank FROM ( SELECT score, (row_number() over(ORDER BY score DESC)) AS 'rank' FROM Scores GROUP BY score ORDER BY score DESC) T INNER JOIN Scores on T.score = Scores.scoreORDER BY score DESC 思路2+知识点 dense_rank() + over() 可以给出同分同排名 123SELECT score, dense_rank() over(ORDER BY score DESC) AS 'rank'FROM ScoresORDER BY score DESC 184. 部门工资最高的员工思路1 子查询，通过group by找出每个部门最大salary 与员工表连接，筛选出部门id相同，薪资与部门最高薪资相同的行 12345678SELECT T.Department, E.name AS Employee, T.SalaryFROM Employee E INNER JOIN ( SELECT D.id as DID, D.name AS Department, E.name AS Employee, MAX(E.salary) AS Salary FROM Employee E JOIN Department D ON E.departmentId = D.id GROUP BY E.departmentId) T ON T.Salary = E.salary AND T.DID = E.departmentId; 思路2 子查询，通过group by找出每个部门最大salary 员工表啊与部门表合并，若(员工薪水, 部门id)存在于子查询中，则筛选出来 12345678910111213141516SELECT Department.name AS 'Department', Employee.name AS 'Employee', SalaryFROM Employee JOIN Department ON Employee.DepartmentId = Department.IdWHERE (Employee.DepartmentId , Salary) IN ( SELECT DepartmentId, MAX(Salary) FROM Employee GROUP BY DepartmentId ) 176. 第二高的薪水思路1 + 知识点 IFNULL(a, b) 如果a是NULL则值替换为b LIMIT N，只选出前N个（最多N个） LIMIT M OFFSET M，从第M个开始选出N个（最多N个） LIMIT 1 OFFSET 1则表示第二个，如果没有第二个，返回空列表 子查询根据salary排序，使用LIMIT 1 OFFSET 1找出第二个 如果没有第二个需要返回NULL，则根据 题目需要返回列表为指定名称，通过AS 别名可以为列取别名 1234SELECT IFNULL( (SELECT DISTINCT salary FROM Employee ORDER BY salary DESCLIMIT 1 OFFSET 1), NULL) AS SecondHighestSalary 思路2 + 知识点 子查询通过max找到最大的 同where筛选所有小于max的 对所有小于max的行，再次使用max，获得第二大的12SELECT MAX(salary) AS SecondHighestSalary FROM EmployeeWHERE salary &lt; (SELECT MAX(salary) FROM Employee) 177. 第N高的薪水 这道题需要我们实现一个函数，参数是N 与上一题一样，通过LIMIT 1 OFFSET M OFFSET后面不能跟表达式 需要声明一个新变量MDECLARE M INT; 并置值为N-1SET M = N-1; 通过return语句返回12345678CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGINDECLARE M INT; SET M = N-1; RETURN ( SELECT IFNULL((SELECT DISTINCT salary FROM Employee ORDER BY salary DESC LIMIT 1 OFFSET M), NULL) );END 185. 部门工资前三高的所有员工知识点 count(column_name): 计算列中非null的个数 count(distinct column_name): 计算列中非null的互不相同的个数 count(*): 统计总行数，包括NULL和重复的 count(1), count(2), … 1,2,… 表示恒真表达式 记录总数，包括重复和NULL having count(xxx) &gt; 0 相当于将值为NULL的筛选出去，如果整个分组空了，就移除整个分组 having count(xxx) &lt;= N 相当于将组内多于N个的行删除 ?: having相当于，若组满足条件，则整组留下，若不满足，则去掉不满足的行，直到组满足为止 思路 找出各部门前三高的不同工资 通过having筛选 代码12345SELECT D.name AS Department, E.name AS Employee, E.salary AS SalaryFROM Employee E, Department AS D, Employee E2WHERE D.id = E.departmentId AND E2.departmentId = E.departmentId AND E.salary &lt;= E2.salarygroup by D.ID,E.Name having count(distinct E2.Salary) &lt;= 3order by D.Name, E.Salary desc 262. 行程和用户知识点1count(CASE WHEN condition THEN A ELSE B END) 根据条件，若某一行满足条件，则该行统计是，按照值A，否则按照值B 统计非NULL的个数，所以一般A和B中一个为NULL一个为非NULL 思路 先将路程表，用户表根据司机id，乘客id和用户id进行连接，排除被禁用户的订单，排除掉时间在2023-10-01到2013-10-03之外的订单 使用count(status)筛选出分母 使用count(case when then else end)筛选出分子 代码1234567891011SELECT T.request_at AS Day, ROUND(sum(CASE WHEN T.status = 'completed' THEN 0 ELSE 1 END) / count(T.status), 2) AS 'Cancellation Rate'FROM Trips T LEFT JOIN Users U1ON T.client_id = U1.users_idLEFT JOIN Users U2ON T.driver_id = U2.users_idWHERE U1.banned = 'No' AND U2.banned = 'No'AND T.request_at BETWEEN DATE(&quot;2013-10-01&quot;) AND DATE(&quot;2013-10-03&quot;)GROUP BY T.request_at SQL性能优化 神奇的 SQL 之性能优化 → 让 SQL 飞起来 用EXISTS代替IN 使用IN会产生一张临时表（内联视图），且在匹配时会扫描全表 使用EXISTS不会产生临时表，在匹配时不会扫描全表，满足条件则停止 用连接替代IN 在有索引时，连接与EXISTS性能相近 没有索引，EXISTS更好 避免排序 很多关键字都存在排序的过程 ORDER BY GROUP BY DISTINCT 聚合函数(MIN,MAX,SUM,AVG,COUNT) 集合函数(UNION,INTERSECT,EXCEPT) 为了去重而排序 使用(UNION ALL,INTERSECT ALL,EXCEPT ALL)不去重 窗口函数(row_number, rank等) 使用 EXISTS 代替 DISTINCT能写在where中的条件不要写在having里在极值函数中使用索引 min，max会全表扫描+排序 对需要求min,max的列创建索引，加快查找速度 在 GROUP BY 子句和 ORDER BY 子句中使用索引使用索引 神奇的 SQL 之擦肩而过 → 真的用到索引了吗 减少临时表 临时表会消耗内存资源 临时表有时无法继承索引，导致效率低下 尽量使用having而不是临时表需要对多个字段使用IN谓词时，将它们汇总到一处12345678910111213141516171819202122232425262728293031select Afrom tableA A1where col1 in ( select col1 from tableA A2 where A1.xxx = A2.xxx) and col2 in ( select col2 from tableA A2 where A1.xxx = A2.xxx) and col3 in ( select col2 from tableA A2 where A1.xxx = A2.xxx)-- 可以优化为select Afrom tableA A1where col1 || col2 || col3in ( select col1 || col2 || col3 from tableA A2)-- orselect Afrom tableA A1where (col1, col2, col3)in ( select col1, col2, col3 from tableA A2) 先进行连接再进行聚合定义视图时避免集合函数和聚合函数","link":"/home/2024/03/03/LeetCode/LeetCode-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%931/"},{"title":"LeetCode-多线程-1","text":"1115. 交替打印 FooBar信号量12345678910111213141516171819202122232425262728293031class FooBar { private int n; private Semaphore fooSem, barSem; public FooBar(int n) { this.n = n; fooSem = new Semaphore(1); barSem = new Semaphore(0); } public void foo(Runnable printFoo) throws InterruptedException { for (int i = 0; i &lt; n; i++) { // printFoo.run() outputs &quot;foo&quot;. Do not change or remove this line. fooSem.acquire(); printFoo.run(); barSem.release(); } } public void bar(Runnable printBar) throws InterruptedException { for (int i = 0; i &lt; n; i++) { // printBar.run() outputs &quot;bar&quot;. Do not change or remove this line. barSem.acquire(); printBar.run(); fooSem.release(); } }} 条件变量12345678910111213141516171819202122232425262728293031323334353637383940414243class FooBar { private int n; Lock lock; Condition condition; boolean fooOrBar = true; public FooBar(int n) { this.n = n; lock = new ReentrantLock(); condition = lock.newCondition(); } public void foo(Runnable printFoo) throws InterruptedException { for (int i = 0; i &lt; n; i++) { // printFoo.run() outputs &quot;foo&quot;. Do not change or remove this line. lock.lock(); while(!fooOrBar) { condition.await(); } printFoo.run(); fooOrBar = !fooOrBar; condition.signalAll(); lock.unlock(); } } public void bar(Runnable printBar) throws InterruptedException { for (int i = 0; i &lt; n; i++) { // printBar.run() outputs &quot;bar&quot;. Do not change or remove this line. lock.lock(); while(fooOrBar) { condition.await(); } printBar.run(); fooOrBar = !fooOrBar; condition.signalAll(); lock.unlock(); } }} 1116. 打印零与奇偶数条件变量12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class ZeroEvenOdd { private int n; private int state; private int curValue; final private Lock lock; final private Condition condition; public ZeroEvenOdd(int n) { this.n = n; lock = new ReentrantLock(); condition = lock.newCondition(); state = 0; curValue = 0; } // printNumber.accept(x) outputs &quot;x&quot;, where x is an integer. public void zero(IntConsumer printNumber) throws InterruptedException { for(int i = 0; i &lt; n; i++) { lock.lock(); while(state != 0 &amp;&amp; state != 2) { condition.await(); } printNumber.accept(0); condition.signalAll(); state = (state + 1) % 4; lock.unlock(); } } public void even(IntConsumer printNumber) throws InterruptedException { for(int i = 2; i &lt;= n; i+=2) { lock.lock(); while(state != 3) { condition.await(); } printNumber.accept(++curValue); condition.signalAll(); state = (state + 1) % 4; lock.unlock(); } } public void odd(IntConsumer printNumber) throws InterruptedException { for(int i = 1; i &lt;= n; i+=2) { lock.lock(); while(state != 1) { condition.await(); } printNumber.accept(++curValue); condition.signalAll(); state = (state + 1) % 4; lock.unlock(); } }} synchronized1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class ZeroEvenOdd { private int n; private int state; final private Lock lock; final private Condition condition; public ZeroEvenOdd(int n) { this.n = n; lock = new ReentrantLock(); condition = lock.newCondition(); state = 0; } // printNumber.accept(x) outputs &quot;x&quot;, where x is an integer. public void zero(IntConsumer printNumber) throws InterruptedException { for(int i = 0; i &lt; n; i++) { synchronized (this) { while(state != 0 &amp;&amp; state != 2) { this.wait(); } printNumber.accept(0); state = (state + 1) % 4; this.notifyAll(); } } } public void even(IntConsumer printNumber) throws InterruptedException { for(int i = 2; i &lt;= n; i+=2) { synchronized (this) { while(state != 3) { this.wait(); } printNumber.accept(i); state = (state + 1) % 4; this.notifyAll(); } } } public void odd(IntConsumer printNumber) throws InterruptedException { for(int i = 1; i &lt;= n; i+=2) { synchronized (this) { while(state != 1) { this.wait(); } printNumber.accept(i); state = (state + 1) % 4; this.notifyAll(); } } }} 1195. 交替打印字符串synchronized1234567891011121314151617181920212223242526272829303132333435363738394041class FizzBuzz { private int n; private int curNum; public FizzBuzz(int n) { this.n = n; curNum = 1; } private void runner(Predicate&lt;Integer&gt; test, IntConsumer consumer) throws InterruptedException { while(curNum &lt;= n) { synchronized (this) { while (!test.test(curNum) &amp;&amp; curNum &lt;= n) { this.wait(); } if(curNum &lt;= n) { consumer.accept(curNum); curNum++; this.notifyAll(); } } } } // printFizz.run() outputs &quot;fizz&quot;. public void fizz(Runnable printFizz) throws InterruptedException { runner((n)-&gt;n % 3 == 0 &amp;&amp; n % 5 != 0, (n)-&gt;printFizz.run()); } // printBuzz.run() outputs &quot;buzz&quot;. public void buzz(Runnable printBuzz) throws InterruptedException { runner((n)-&gt;n % 3 != 0 &amp;&amp; n % 5 == 0, (n)-&gt;printBuzz.run()); } // printFizzBuzz.run() outputs &quot;fizzbuzz&quot;. public void fizzbuzz(Runnable printFizzBuzz) throws InterruptedException { runner((n)-&gt;n % 3 == 0 &amp;&amp; n % 5 == 0, (n)-&gt;printFizzBuzz.run()); } // printNumber.accept(x) outputs &quot;x&quot;, where x is an integer. public void number(IntConsumer printNumber) throws InterruptedException { runner((n)-&gt;n % 3 != 0 &amp;&amp; n % 5 != 0, printNumber); }} condition123456789101112131415161718192021222324252627282930313233343536373839404142434445class FizzBuzz { private int n; final private Lock lock; final private Condition condition; private int curNum; public FizzBuzz(int n) { this.n = n; curNum = 1; lock = new ReentrantLock(); condition = lock.newCondition(); } private void runner(Predicate&lt;Integer&gt; test, IntConsumer consumer) throws InterruptedException { while(curNum &lt;= n) { lock.lock(); while (!test.test(curNum) &amp;&amp; curNum &lt;= n) { condition.await(); } if(curNum &lt;= n) { consumer.accept(curNum); curNum++; condition.signalAll(); } lock.unlock(); } } // printFizz.run() outputs &quot;fizz&quot;. public void fizz(Runnable printFizz) throws InterruptedException { runner((n)-&gt;n % 3 == 0 &amp;&amp; n % 5 != 0, (n)-&gt;printFizz.run()); } // printBuzz.run() outputs &quot;buzz&quot;. public void buzz(Runnable printBuzz) throws InterruptedException { runner((n)-&gt;n % 3 != 0 &amp;&amp; n % 5 == 0, (n)-&gt;printBuzz.run()); } // printFizzBuzz.run() outputs &quot;fizzbuzz&quot;. public void fizzbuzz(Runnable printFizzBuzz) throws InterruptedException { runner((n)-&gt;n % 3 == 0 &amp;&amp; n % 5 == 0, (n)-&gt;printFizzBuzz.run()); } // printNumber.accept(x) outputs &quot;x&quot;, where x is an integer. public void number(IntConsumer printNumber) throws InterruptedException { runner((n)-&gt;n % 3 != 0 &amp;&amp; n % 5 != 0, printNumber); }} 1117. H2O 生成1234567891011121314151617181920212223class H2O { Semaphore semH, semO; public H2O() { semH = new Semaphore(2); semO = new Semaphore(0); } public void hydrogen(Runnable releaseHydrogen) throws InterruptedException { // releaseHydrogen.run() outputs &quot;H&quot;. Do not change or remove this line. semH.acquire(); releaseHydrogen.run(); semO.release(); } public void oxygen(Runnable releaseOxygen) throws InterruptedException { // releaseOxygen.run() outputs &quot;O&quot;. Do not change or remove this line. semO.acquire(2); releaseOxygen.run(); semH.release(2); }} 1114. 按序打印信号量1234567891011121314151617181920212223242526272829class Foo { Semaphore a, b; public Foo() { a = new Semaphore(0); b = new Semaphore(0); } public void first(Runnable printFirst) throws InterruptedException { // printFirst.run() outputs &quot;first&quot;. Do not change or remove this line. printFirst.run(); a.release(); } public void second(Runnable printSecond) throws InterruptedException { // printSecond.run() outputs &quot;second&quot;. Do not change or remove this line. a.acquire(); printSecond.run(); b.release(); } public void third(Runnable printThird) throws InterruptedException { // printThird.run() outputs &quot;third&quot;. Do not change or remove this line. b.acquire(); printThird.run(); }} 条件12345678910111213141516171819202122232425262728293031323334353637383940class Foo { private int seq; public Foo() { seq = 0; } public void first(Runnable printFirst) throws InterruptedException { // printFirst.run() outputs &quot;first&quot;. Do not change or remove this line. synchronized (this) { printFirst.run(); seq++; notifyAll(); } } public void second(Runnable printSecond) throws InterruptedException { // printSecond.run() outputs &quot;second&quot;. Do not change or remove this line. synchronized (this) { while (seq != 1) { wait(); } printSecond.run(); seq++; notifyAll(); } } public void third(Runnable printThird) throws InterruptedException { // printThird.run() outputs &quot;third&quot;. Do not change or remove this line. synchronized (this) { while (seq != 2) { wait(); } printThird.run(); } }} CountDownLatchCountDownLatch的理解和使用 当每一个线程完成自己任务后，计数器的值就会减一。当计数器的值为0时，表示所有的线程都已经完成一些任务，然后在CountDownLatch上等待的线程就可以恢复执行接下来的任务。 12345678910111213141516171819202122232425262728class Foo { private CountDownLatch count1; private CountDownLatch count2; public Foo() { count1 = new CountDownLatch(1); count2 = new CountDownLatch(1); } public void first(Runnable printFirst) throws InterruptedException { // printFirst.run() outputs &quot;first&quot;. Do not change or remove this line. printFirst.run(); count1.countDown(); } public void second(Runnable printSecond) throws InterruptedException { count1.await(); // printSecond.run() outputs &quot;second&quot;. Do not change or remove this line. printSecond.run(); count2.countDown(); } public void third(Runnable printThird) throws InterruptedException { count2.await(); // printThird.run() outputs &quot;third&quot;. Do not change or remove this line. printThird.run(); }} 1226. 哲学家进餐调整拿筷子的顺序 奇数序号：先拿左手再拿右手 偶数序号：先拿右手再拿左手 1234567891011121314151617181920212223242526272829303132333435363738class DiningPhilosophers { Lock[] lock; public DiningPhilosophers() { lock = new Lock[5]; for(int i = 0; i &lt; 5; i++) { lock[i] = new ReentrantLock(); } } // call the run() method of any runnable to execute its code public void wantsToEat(int philosopher, Runnable pickLeftFork, Runnable pickRightFork, Runnable eat, Runnable putLeftFork, Runnable putRightFork) throws InterruptedException { if(philosopher % 2 == 0) { lock[philosopher].lock(); lock[(philosopher+1)%5].lock(); } else { lock[(philosopher+1)%5].lock(); lock[philosopher].lock(); } try { pickLeftFork.run(); pickRightFork.run(); eat.run(); putLeftFork.run(); putRightFork.run(); } finally { lock[philosopher].unlock(); lock[(philosopher+1)%5].unlock(); } }} 12345678910111213141516171819202122232425262728293031323334353637class DiningPhilosophers { Object[] lock; public DiningPhilosophers() { lock = new Object[5]; for(int i = 0; i &lt; 5; i++) { lock[i] = new Object(); } } // call the run() method of any runnable to execute its code public void wantsToEat(int philosopher, Runnable pickLeftFork, Runnable pickRightFork, Runnable eat, Runnable putLeftFork, Runnable putRightFork) throws InterruptedException { Object obj1, obj2; if(philosopher % 2 == 0) { obj1 = lock[philosopher]; obj2 = lock[(philosopher+1)%5]; } else { obj1 = lock[(philosopher+1)%5]; obj2 = lock[philosopher]; } synchronized(obj1) { synchronized(obj2) { pickLeftFork.run(); pickRightFork.run(); eat.run(); putLeftFork.run(); putRightFork.run(); } } }} 条件 一个数组保存每个筷子是否使用 检查需要的两个筷子，如果筷子可用，改为false，释放锁，开始吃 吃完后，释放两个筷子，通知其他线程 1234567891011121314151617181920212223242526272829303132333435363738394041class DiningPhilosophers { Lock lock; boolean[] ready; Condition condition; public DiningPhilosophers() { lock = new ReentrantLock(); ready = new boolean[5]; Arrays.fill(ready, true); condition = lock.newCondition(); } // call the run() method of any runnable to execute its code public void wantsToEat(int philosopher, Runnable pickLeftFork, Runnable pickRightFork, Runnable eat, Runnable putLeftFork, Runnable putRightFork) throws InterruptedException { boolean leftChopstick = false; boolean rightChopstick = false; lock.lock(); while(!ready[philosopher] || !ready[(philosopher+1) % 5]) { condition.await(); } ready[philosopher] = false; ready[(philosopher+1) % 5] = false; pickLeftFork.run(); pickRightFork.run(); lock.unlock(); eat.run(); lock.lock(); putLeftFork.run(); putRightFork.run(); ready[philosopher] = true; ready[(philosopher+1) % 5] = true; condition.signalAll(); lock.unlock(); }} 5个条件 这样可以减少唤醒的线程个数12345678910111213141516171819202122232425262728293031323334353637383940414243class DiningPhilosophers { Lock lock; boolean[] ready; Condition[] conditions; public DiningPhilosophers() { lock = new ReentrantLock(); ready = new boolean[5]; Arrays.fill(ready, true); conditions = new Condition[5]; for (int i = 0; i &lt; conditions.length; i++) { conditions[i] = lock.newCondition(); } } // call the run() method of any runnable to execute its code public void wantsToEat(int philosopher, Runnable pickLeftFork, Runnable pickRightFork, Runnable eat, Runnable putLeftFork, Runnable putRightFork) throws InterruptedException { lock.lock(); while(!ready[philosopher] || !ready[(philosopher+1) % 5]) { conditions[philosopher].await(); } ready[philosopher] = false; ready[(philosopher+1) % 5] = false; pickLeftFork.run(); pickRightFork.run(); lock.unlock(); eat.run(); lock.lock(); putLeftFork.run(); putRightFork.run(); ready[philosopher] = true; ready[(philosopher+1) % 5] = true; conditions[(philosopher+1) % 5].signalAll(); conditions[(philosopher-1 + 5) % 5].signalAll(); lock.unlock(); }} 烦死了，这五个哲学家吃饭就不能准备10根筷子吗 1279. 红绿灯路口 睾贵的会员题，不过本科的时候学过 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package leetcode;import java.util.Random;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class TrafficLight { private int road = 0; private final Semaphore lockNS; private final Semaphore lockSW; private static final int NS = 1; private static final int SW = 2; private int carNumber = 0; public TrafficLight() { lockNS = new Semaphore(1); lockSW = new Semaphore(1); } public void carArrived(int carId, // ID of the car int roadId, // ID of the road the car travels on. Can be 1 (road A) or 2 (road B) int direction, // Direction of the car Runnable turnGreen, // Use turnGreen.run() to turn light to green on current road Runnable crossCar // Use crossCar.run() to make car cross the intersection ) { Semaphore lockOur, lockOther; if(roadId == NS) { lockOur = lockNS; lockOther = lockSW; } else { lockOur = lockSW; lockOther = lockNS; } try { lockOur.acquire(); if(roadId != road) { lockOther.acquire(); road = roadId; turnGreen.run(); } carNumber++; lockOur.release(); crossCar.run(); lockOur.acquire(); carNumber--; if(carNumber == 0) { lockOther.release(); } lockOur.release(); } catch (InterruptedException e) { } }}public class TestTrafficLight { public static void main(String[] args) { final TrafficLight trafficLight = new TrafficLight(); Random random = new Random(System.currentTimeMillis()); int carNumber = random.nextInt(100, 200); try(ExecutorService executor = Executors.newCachedThreadPool()) { for(int i = 0; i &lt; carNumber; i++) { final int carId = i; final int roadId = random.nextInt(1,3); final int direction = random.nextInt(1,3); executor.submit(()-&gt;trafficLight.carArrived( carId, roadId, direction, ()-&gt; System.out.printf(&quot;car:%d, onRoad:%d, direction:%d, turn traffic light green\\n&quot;, carId, roadId, direction), ()-&gt; System.out.printf(&quot;car:%d, onRoad:%d, direction:%d, running\\n&quot;, carId, roadId, direction) )); } } }} 1188. 设计有限阻塞队列 又是睾贵的会员题目 生产者消费者模型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package leetcode;import java.util.*;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;import static leetcode.Tools.printf;import static leetcode.Tools.runCatching;class BoundedBlockingQueue { Semaphore consumer, producer; Lock mutex; final private int capacity; private LinkedList&lt;Integer&gt; q = new LinkedList&lt;&gt;(); public BoundedBlockingQueue(int capacity) { this.capacity = capacity; consumer = new Semaphore(0); producer = new Semaphore(capacity); mutex = new ReentrantLock(); } public void enqueue(int element) { try { producer.acquire(); mutex.lock(); q.add(element); } catch (Exception e) { producer.release(); throw new RuntimeException(e); } finally { mutex.unlock(); consumer.release(); } } public int dequeue() { int ret; try { consumer.acquire(); mutex.lock(); ret = q.remove(0); } catch (Exception e) { consumer.release(); throw new RuntimeException(e); } finally { mutex.unlock(); producer.release(); } return ret; } public int size() { return q.size(); }}public class TestBoundedBlockingQueue { static final int MIN_THREAD_NUM = 2; static final int MAX_THREAD_NUM = 50; static final int MIN_CAPACITY = 1; static final int MAX_CAPACITY = 50; static final int MIN_OP_NUM = 20; static final int MAX_OP_NUM = 100; static Random random = new Random(System.currentTimeMillis()); static int produceTotal; // 生产者生产总数 static int consumerTotal; // 消费者总数 static void getOps(int[] producerNum, int[] consumerNum, int maxRemainNum) { produceTotal = consumerTotal = 0; for(int i = 0; i &lt; producerNum.length; i++){ int opNum = random.nextInt(MIN_OP_NUM, MAX_OP_NUM + 1); producerNum[i] = opNum; produceTotal += opNum; } for(int i = consumerNum.length-1; produceTotal - maxRemainNum - consumerTotal &gt; 0; i--) { int opNum = random.nextInt((produceTotal - maxRemainNum - consumerTotal) / (i*i + 1), (produceTotal - maxRemainNum - consumerTotal) / (i + 1) + 1); consumerNum[i] = opNum; consumerTotal += opNum; } } public static void main(String[] args) { int threadNum = random.nextInt(MIN_THREAD_NUM, MAX_THREAD_NUM + 1); int capacity = random.nextInt(MIN_CAPACITY, MAX_CAPACITY + 1); int maxRemainNum = random.nextInt(0, capacity + 1); int[] producerNum = new int[random.nextInt(1, threadNum)]; int[] consumerNum = new int[threadNum - producerNum.length]; getOps(producerNum, consumerNum, maxRemainNum); System.out.printf(&quot;producerNum=%s\\nconsumerNum=%s\\nthreadNum=%d\\ncapacity=%d\\nproducerTotal=%d\\nconsumerTotal=%d\\nsize=%d\\nmaxRemainNum=%d\\n&quot;, Arrays.toString(producerNum), Arrays.toString(consumerNum), threadNum, capacity, produceTotal, consumerTotal, produceTotal - consumerTotal, maxRemainNum); BoundedBlockingQueue boundedBlockingQueue = new BoundedBlockingQueue(capacity); try(ExecutorService executorService = Executors.newFixedThreadPool(threadNum)) { for(int i = 0; i &lt; producerNum.length; i++) { final int id = i; executorService.submit(runCatching(() -&gt; { for(int j = 0; j &lt; producerNum[id]; j++) { System.out.printf(&quot;%s, enqueue\\n&quot;, Thread.currentThread().getName()); boundedBlockingQueue.enqueue(id); } })); } for(int i = 0; i &lt; consumerNum.length; i++) { final int id = i; executorService.submit(runCatching(() -&gt; { for(int j = 0; j &lt; consumerNum[id]; j++) { int front = boundedBlockingQueue.dequeue(); System.out.printf(&quot;%s, dequeue, front = %d\\n&quot;, Thread.currentThread().getName(), front); } })); } } if(produceTotal - consumerTotal == boundedBlockingQueue.size()) { System.out.printf(&quot;ok!, size = %d\\n&quot;, produceTotal - consumerTotal); } else { throw new RuntimeException(printf(&quot;fail, you are foolish, correct size = %d, q.size = %d\\n&quot;, produceTotal - consumerTotal, boundedBlockingQueue.size())); } }} 12345678910111213141516171819package leetcode;import java.io.ByteArrayOutputStream;import java.io.PrintStream;public class Tools { interface ExceptionRunnable { void run() throws Exception; } static Runnable runCatching(ExceptionRunnable r) { return () -&gt; {try {r.run();} catch (Exception e) { e.printStackTrace(); }}; } static public String printf(String format, Object ... args) { ByteArrayOutputStream byteArrayOutputStream; PrintStream printStream = new PrintStream((byteArrayOutputStream = new ByteArrayOutputStream())); printStream.printf(format, args); return byteArrayOutputStream.toString(); }}","link":"/home/2024/03/04/LeetCode/LeetCode-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%931/"},{"title":"LeetCode-数据库-2","text":"584. 寻找用户推荐人12345678SELECT nameFROM CustomerWHERE referee_id &lt;&gt; 2 OR referee_id IS NULL 577. 员工奖金1234567891011SELECT E.name, B.bonusFROM Employee E LEFT JOIN Bonus B ON E.empId = B.empIdWHERE B.bonus &lt; 1000 OR B.bonus IS NULL 570. 至少有5名直接下属的经理12345678910SELECT E1.nameFROM Employee E1 LEFT JOIN Employee E2 ON E1.id = E2.managerIdGROUP BY E1.idHAVING COUNT(E1.id) &gt;= 5 596. 超过5名学生的课12345678SELECT classFROM CoursesGROUP BY classHAVING COUNT(class) &gt;= 5 595. 大的国家12345678910SELECT name, population, areaFROM WorldWHERE population &gt;= 25000000 OR area &gt;= 3000000 586. 订单最多的客户123456789SELECT customer_numberFROM OrdersGROUP BY customer_numberORDER BY COUNT(customer_number) DESCLIMIT 1 585. 2016年的投资思路1 join两个Insurance表，连接方式为pid不同 通过where筛选出2015投资相等的行 再来一个子查询找出所有location只出现一次的id 通过where筛选出满足条件的id sql12345678910111213141516171819202122232425262728SELECT ROUND(SUM(T.tiv_2016), 2) as tiv_2016FROM( SELECT MAX(I1.tiv_2016) as tiv_2016 FROM Insurance I1 LEFT JOIN Insurance I2 ON I1.pid != I2.pid WHERE I1.pid IN ( SELECT pid FROM Insurance GROUP BY lat, lon HAVING COUNT(*) = 1 ) AND I1.tiv_2015 = I2.tiv_2015 GROUP BY I1.pid) T 错误分析 ON和 WHERE的条件可以互换吗？123456789101112131415161718192021222324252627SELECT ROUND(SUM(T.tiv_2016), 2) as tiv_2016FROM( SELECT I1.pid, MAX(I1.tiv_2016) as tiv_2016 FROM Insurance I1 LEFT JOIN Insurance I2 ON I1.pid != I2.pid AND I1.tiv_2015 = I2.tiv_2015 AND I1.pid IN ( SELECT pid FROM Insurance GROUP BY lat, lon HAVING COUNT(*) = 1 ) GROUP BY I1.pid) T 发现上面的结果不对，原因是使用了LEFT JOIN, 导致On后的条件没有满足，但是左侧都被保留了下来，需要改成内连接 123456789101112131415161718192021222324252627SELECT ROUND(SUM(T.tiv_2016), 2) as tiv_2016FROM( SELECT I1.pid, MAX(I1.tiv_2016) as tiv_2016 FROM Insurance I1 JOIN Insurance I2 ON I1.pid != I2.pid AND I1.tiv_2015 = I2.tiv_2015 AND I1.pid IN ( SELECT pid FROM Insurance GROUP BY lat, lon HAVING COUNT(*) = 1 ) GROUP BY I1.pid) T 思路2 count() + over(parition by) count计算个数 partition by指定计算时的聚合方法 sql123456789101112131415SELECT ROUND(SUM(T.tiv_2016), 2) as tiv_2016FROM( SELECT tiv_2016, COUNT(1) OVER(PARTITION BY tiv_2015) AS tiv_2015_cnt, COUNT(1) OVER(PARTITION BY lat, lon) AS pos_cnt FROM Insurance) TWHERE T.tiv_2015_cnt &gt; 1 AND T.pos_cnt = 1 602. 好友申请 II ：谁有最多的好友思路1 a向b申请好友，通过后，a-b都互为好友 所以需要把requester和accepter互换后，使用UNION ALL连接 然后group by + count() 12345678910111213141516171819202122SELECT id, COUNT(friend_id) AS numFROM( SELECT accepter_id AS id, requester_id AS friend_id FROM RequestAcceptedUNION ALL SELECT requester_id AS id, accepter_id AS friend_id FROM RequestAccepted) TGROUP BY idORDER BY COUNT(friend_id) DESCLIMIT 1 思路2 题目的意思是不存在重复添加好友的情况，比如a加b，a删b，b加回a等情况 所以可以直接在子查询中计数，然后在外面求和，可以快一点 1234567891011121314151617181920212223242526SELECT id, SUM(num) AS numFROM( SELECT accepter_id AS id, COUNT(requester_id) AS num FROM RequestAccepted GROUP BY accepter_idUNION ALL SELECT requester_id AS id, COUNT(accepter_id) AS num FROM RequestAccepted GROUP BY requester_id) TGROUP BY idORDER BY SUM(num) DESCLIMIT 1 1661. 每台机器的进程平均运行时间 union前后必须加括号 1234567891011121314SELECT A1.machine_id, ROUND(AVG(A2.timestamp - A1.timestamp), 3) AS processing_timeFROM Activity A1 JOIN Activity A2 ON A1.machine_id = A2.machine_id AND A1.process_id = A2.process_id AND A1.activity_type = 'start' AND A2.activity_type = 'end'GROUP BY A1.machine_id 1341. 电影评分123456789101112131415161718192021222324252627282930313233( SELECT name AS results FROM Users JOIN MovieRating ON Users.user_id = MovieRating.user_id GROUP BY Users.user_id ORDER BY COUNT(rating) DESC,name LIMIT 1)UNION ALL( SELECT title AS results FROM Movies JOIN MovieRating ON Movies.movie_id = MovieRating.movie_id WHERE created_at BETWEEN DATE(&quot;2020-02-01&quot;) AND DATE(&quot;2020-02-29&quot;) GROUP BY Movies.movie_id ORDER BY AVG(rating) DESC, title LIMIT 1) 1141. 查询近30天活跃用户数 笨蛋，最近30天是往前数29天 12345678910111213SELECT activity_date AS 'day', COUNT(DISTINCT user_id) AS 'active_users'FROM ActivityWHERE activity_date BETWEEN DATE_SUB(&quot;2019-07-27&quot;, INTERVAL 29 DAY) AND DATE(&quot;2019-07-27&quot;)GROUP BY activity_date 1731. 每位经理的下属员工数量12345678910111213141516# Write your MySQL query statement belowSELECT E1.employee_id, E1.name, COUNT(E2.reports_to) AS reports_count, ROUND(AVG(E2.age), 0) AS average_ageFROM Employees E1 JOIN Employees E2 ON E1.employee_id = E2.reports_toGROUP BY employee_idORDER BY employee_id 1527. 患某种疾病的患者LIKE1234567891011# Write your MySQL query statement belowSELECT patient_id, patient_name, conditionsFROM PatientsWHERE conditions LIKE '% DIAB1%' OR conditions LIKE 'DIAB1%' REGEXP 写不出这个正则 \\b:匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B:匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’ 123456789# Write your MySQL query statement belowSELECT patient_id, patient_name, conditionsFROM PatientsWHERE conditions REGEXP '\\\\bDIAB1' 1070. 产品销售分析 III123456789101112131415161718192021SELECT Sales.product_id, T.first_year, Sales.quantity, Sales.priceFROM Sales JOIN ( SELECT product_id, MIN(year) AS first_year FROM Sales GROUP BY product_id ) T ON Sales.year = T.first_year AND Sales.product_id = T.product_id rank over里面既能partition by, 也能order by 123456789101112131415161718SELECT T.product_id, T.first_year, T.quantity, T.priceFROM ( SELECT product_id, year AS first_year, quantity, price, rank() OVER(PARTITION BY product_id ORDER BY year) AS 'year_rank' FROM Sales ) TWHERE T.year_rank = 1","link":"/home/2024/03/04/LeetCode/LeetCode-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932/"},{"title":"LeetCode-位运算","text":"位运算常见技巧 位运算计算 a op b res x xor 0x00 x x xor 0xff ~x x xor x 0 x and 0x00 0 x and 0xff x x and x x x or 0x00 x x or 0xff 0xff x or x x x and x-1 去掉最低位 x and -x 得到最低位 状态压缩 用二进制位表示状态 268. 丢失的数字1234567891011class Solution {public: int missingNumber(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int ans = n; for(int i = 0; i &lt; n; i++) { ans ^= nums[i]^i; } return ans; }}; 思路模仿136. 只出现一次的数字，将下标和所有数字进行异或。 693. 交替位二进制数神经病做法 0x5555555 是最低位为1的01交替 0xaaaaaaa 是最低位为0的01交替 n分别与两个数相与，结果不同时大于0或不同时为0的话，说明没有连续的0 对n取反，即可判断有无连续的0123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: bool hasAlternatingBits(int n) { if(!(((0x55555555 &amp; n) &amp;&amp; !(0xaaaaaaaa &amp; n)) || (!(0x55555555 &amp; n) &amp;&amp; (0xaaaaaaaa &amp; n)))) return false; if(n == 1) return true; // for(int i = 1; i &lt; 32; i++) { // printf( // &quot;if(!(n &amp; 0x%x)) return &quot; // &quot;((0x55555555 &amp; 0x%x &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x%x &amp; ~n)) || (!(0x55555555 &amp; 0x%x &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x%x &amp; ~n)); else\\n&quot;, // (0xffffffffffffffff &lt;&lt; i), // ~(0xffffffffffffffff &lt;&lt; i), ~(0xffffffffffffffff &lt;&lt; i), ~(0xffffffffffffffff &lt;&lt; i), ~(0xffffffffffffffff &lt;&lt; i) // ); // } // printf(&quot;return false; // unreachable\\n&quot;); if(!(n &amp; 0xfffffffe)) return ((0x55555555 &amp; 0x1 &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x1 &amp; ~n)) || (!(0x55555555 &amp; 0x1 &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x1 &amp; ~n)); else if(!(n &amp; 0xfffffffc)) return ((0x55555555 &amp; 0x3 &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x3 &amp; ~n)) || (!(0x55555555 &amp; 0x3 &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x3 &amp; ~n)); else if(!(n &amp; 0xfffffff8)) return ((0x55555555 &amp; 0x7 &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x7 &amp; ~n)) || (!(0x55555555 &amp; 0x7 &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x7 &amp; ~n)); else if(!(n &amp; 0xfffffff0)) return ((0x55555555 &amp; 0xf &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0xf &amp; ~n)) || (!(0x55555555 &amp; 0xf &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0xf &amp; ~n)); else if(!(n &amp; 0xffffffe0)) return ((0x55555555 &amp; 0x1f &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x1f &amp; ~n)) || (!(0x55555555 &amp; 0x1f &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x1f &amp; ~n)); else if(!(n &amp; 0xffffffc0)) return ((0x55555555 &amp; 0x3f &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x3f &amp; ~n)) || (!(0x55555555 &amp; 0x3f &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x3f &amp; ~n)); else if(!(n &amp; 0xffffff80)) return ((0x55555555 &amp; 0x7f &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x7f &amp; ~n)) || (!(0x55555555 &amp; 0x7f &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x7f &amp; ~n)); else if(!(n &amp; 0xffffff00)) return ((0x55555555 &amp; 0xff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0xff &amp; ~n)) || (!(0x55555555 &amp; 0xff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0xff &amp; ~n)); else if(!(n &amp; 0xfffffe00)) return ((0x55555555 &amp; 0x1ff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x1ff &amp; ~n)) || (!(0x55555555 &amp; 0x1ff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x1ff &amp; ~n)); else if(!(n &amp; 0xfffffc00)) return ((0x55555555 &amp; 0x3ff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x3ff &amp; ~n)) || (!(0x55555555 &amp; 0x3ff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x3ff &amp; ~n)); else if(!(n &amp; 0xfffff800)) return ((0x55555555 &amp; 0x7ff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x7ff &amp; ~n)) || (!(0x55555555 &amp; 0x7ff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x7ff &amp; ~n)); else if(!(n &amp; 0xfffff000)) return ((0x55555555 &amp; 0xfff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0xfff &amp; ~n)) || (!(0x55555555 &amp; 0xfff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0xfff &amp; ~n)); else if(!(n &amp; 0xffffe000)) return ((0x55555555 &amp; 0x1fff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x1fff &amp; ~n)) || (!(0x55555555 &amp; 0x1fff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x1fff &amp; ~n)); else if(!(n &amp; 0xffffc000)) return ((0x55555555 &amp; 0x3fff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x3fff &amp; ~n)) || (!(0x55555555 &amp; 0x3fff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x3fff &amp; ~n)); else if(!(n &amp; 0xffff8000)) return ((0x55555555 &amp; 0x7fff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x7fff &amp; ~n)) || (!(0x55555555 &amp; 0x7fff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x7fff &amp; ~n)); else if(!(n &amp; 0xffff0000)) return ((0x55555555 &amp; 0xffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0xffff &amp; ~n)) || (!(0x55555555 &amp; 0xffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0xffff &amp; ~n)); else if(!(n &amp; 0xfffe0000)) return ((0x55555555 &amp; 0x1ffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x1ffff &amp; ~n)) || (!(0x55555555 &amp; 0x1ffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x1ffff &amp; ~n)); else if(!(n &amp; 0xfffc0000)) return ((0x55555555 &amp; 0x3ffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x3ffff &amp; ~n)) || (!(0x55555555 &amp; 0x3ffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x3ffff &amp; ~n)); else if(!(n &amp; 0xfff80000)) return ((0x55555555 &amp; 0x7ffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x7ffff &amp; ~n)) || (!(0x55555555 &amp; 0x7ffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x7ffff &amp; ~n)); else if(!(n &amp; 0xfff00000)) return ((0x55555555 &amp; 0xfffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0xfffff &amp; ~n)) || (!(0x55555555 &amp; 0xfffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0xfffff &amp; ~n)); else if(!(n &amp; 0xffe00000)) return ((0x55555555 &amp; 0x1fffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x1fffff &amp; ~n)) || (!(0x55555555 &amp; 0x1fffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x1fffff &amp; ~n)); else if(!(n &amp; 0xffc00000)) return ((0x55555555 &amp; 0x3fffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x3fffff &amp; ~n)) || (!(0x55555555 &amp; 0x3fffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x3fffff &amp; ~n)); else if(!(n &amp; 0xff800000)) return ((0x55555555 &amp; 0x7fffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x7fffff &amp; ~n)) || (!(0x55555555 &amp; 0x7fffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x7fffff &amp; ~n)); else if(!(n &amp; 0xff000000)) return ((0x55555555 &amp; 0xffffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0xffffff &amp; ~n)) || (!(0x55555555 &amp; 0xffffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0xffffff &amp; ~n)); else if(!(n &amp; 0xfe000000)) return ((0x55555555 &amp; 0x1ffffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x1ffffff &amp; ~n)) || (!(0x55555555 &amp; 0x1ffffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x1ffffff &amp; ~n)); else if(!(n &amp; 0xfc000000)) return ((0x55555555 &amp; 0x3ffffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x3ffffff &amp; ~n)) || (!(0x55555555 &amp; 0x3ffffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x3ffffff &amp; ~n)); else if(!(n &amp; 0xf8000000)) return ((0x55555555 &amp; 0x7ffffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x7ffffff &amp; ~n)) || (!(0x55555555 &amp; 0x7ffffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x7ffffff &amp; ~n)); else if(!(n &amp; 0xf0000000)) return ((0x55555555 &amp; 0xfffffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0xfffffff &amp; ~n)) || (!(0x55555555 &amp; 0xfffffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0xfffffff &amp; ~n)); else if(!(n &amp; 0xe0000000)) return ((0x55555555 &amp; 0x1fffffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x1fffffff &amp; ~n)) || (!(0x55555555 &amp; 0x1fffffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x1fffffff &amp; ~n)); else if(!(n &amp; 0xc0000000)) return ((0x55555555 &amp; 0x3fffffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x3fffffff &amp; ~n)) || (!(0x55555555 &amp; 0x3fffffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x3fffffff &amp; ~n)); else if(!(n &amp; 0x80000000)) return ((0x55555555 &amp; 0x7fffffff &amp; ~n) &amp;&amp; !(0xaaaaaaaa &amp; 0x7fffffff &amp; ~n)) || (!(0x55555555 &amp; 0x7fffffff &amp; ~n) &amp;&amp; (0xaaaaaaaa &amp; 0x7fffffff &amp; ~n)); else return false; // unreachable }}; 正常做法 n ^ (n&gt;&gt;1) ，某一位为1，相当于这一位和其前一位不一样 任何结果形如 0b000_..._011...111的，都是正确 考虑到 0b000_..._011...111 + 1 就是 0b00..00100..00， 只要(n ^ (n&gt;&gt;1)) + 1中只有一个1就好了 (x &amp; (x-1))相当于去掉最低位的1 只要((n ^ (n&gt;&gt;1)) + 1) &amp; ((n ^ (n&gt;&gt;1)))是0就好了1234567class Solution {public: bool hasAlternatingBits(int n) { int a = n ^ (n &gt;&gt; 1); return a == INT_MAX || (a &amp; (a+1)) == 0; }}; 正常做法2暴力打表 1234567891011121314151617181920212223242526272829class Solution {public: bool hasAlternatingBits(int n) { // int x = 0; // for(int i = 0; i &lt; 16; i++) { // x &lt;&lt;= 2; // x++; // printf(&quot;if(n == 0x%x || n == 0x%x) return true; else\\n&quot;, x, ~x &amp; ((1 &lt;&lt; (i &lt;&lt; 1)) - 1)); // } // printf(&quot;return false;&quot;); if(n == 0x1 || n == 0x0) return true; else if(n == 0x5 || n == 0x2) return true; else if(n == 0x15 || n == 0xa) return true; else if(n == 0x55 || n == 0x2a) return true; else if(n == 0x155 || n == 0xaa) return true; else if(n == 0x555 || n == 0x2aa) return true; else if(n == 0x1555 || n == 0xaaa) return true; else if(n == 0x5555 || n == 0x2aaa) return true; else if(n == 0x15555 || n == 0xaaaa) return true; else if(n == 0x55555 || n == 0x2aaaa) return true; else if(n == 0x155555 || n == 0xaaaaa) return true; else if(n == 0x555555 || n == 0x2aaaaa) return true; else if(n == 0x1555555 || n == 0xaaaaaa) return true; else if(n == 0x5555555 || n == 0x2aaaaaa) return true; else if(n == 0x15555555 || n == 0xaaaaaaa) return true; else if(n == 0x55555555 || n == 0x2aaaaaaa) return true; else return false; }}; 476. 数字的补数12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution {public: int findComplement(int num) { // for(int i = 1; i &lt; 32; i++) { // printf( // &quot;if(!(num &amp; 0x%x)) return &quot; // &quot;0x%x &amp; ~num; else\\n&quot;, // (0xffffffffffffffff &lt;&lt; i), // ~(0xffffffffffffffff &lt;&lt; i), ~(0xffffffffffffffff &lt;&lt; i), ~(0xffffffffffffffff &lt;&lt; i), ~(0xffffffffffffffff &lt;&lt; i) // ); // } // printf(&quot;return 0;\\n&quot;); if(!(num &amp; 0xfffffffe)) return 0x1 &amp; ~num; else if(!(num &amp; 0xfffffffc)) return 0x3 &amp; ~num; else if(!(num &amp; 0xfffffff8)) return 0x7 &amp; ~num; else if(!(num &amp; 0xfffffff0)) return 0xf &amp; ~num; else if(!(num &amp; 0xffffffe0)) return 0x1f &amp; ~num; else if(!(num &amp; 0xffffffc0)) return 0x3f &amp; ~num; else if(!(num &amp; 0xffffff80)) return 0x7f &amp; ~num; else if(!(num &amp; 0xffffff00)) return 0xff &amp; ~num; else if(!(num &amp; 0xfffffe00)) return 0x1ff &amp; ~num; else if(!(num &amp; 0xfffffc00)) return 0x3ff &amp; ~num; else if(!(num &amp; 0xfffff800)) return 0x7ff &amp; ~num; else if(!(num &amp; 0xfffff000)) return 0xfff &amp; ~num; else if(!(num &amp; 0xffffe000)) return 0x1fff &amp; ~num; else if(!(num &amp; 0xffffc000)) return 0x3fff &amp; ~num; else if(!(num &amp; 0xffff8000)) return 0x7fff &amp; ~num; else if(!(num &amp; 0xffff0000)) return 0xffff &amp; ~num; else if(!(num &amp; 0xfffe0000)) return 0x1ffff &amp; ~num; else if(!(num &amp; 0xfffc0000)) return 0x3ffff &amp; ~num; else if(!(num &amp; 0xfff80000)) return 0x7ffff &amp; ~num; else if(!(num &amp; 0xfff00000)) return 0xfffff &amp; ~num; else if(!(num &amp; 0xffe00000)) return 0x1fffff &amp; ~num; else if(!(num &amp; 0xffc00000)) return 0x3fffff &amp; ~num; else if(!(num &amp; 0xff800000)) return 0x7fffff &amp; ~num; else if(!(num &amp; 0xff000000)) return 0xffffff &amp; ~num; else if(!(num &amp; 0xfe000000)) return 0x1ffffff &amp; ~num; else if(!(num &amp; 0xfc000000)) return 0x3ffffff &amp; ~num; else if(!(num &amp; 0xf8000000)) return 0x7ffffff &amp; ~num; else if(!(num &amp; 0xf0000000)) return 0xfffffff &amp; ~num; else if(!(num &amp; 0xe0000000)) return 0x1fffffff &amp; ~num; else if(!(num &amp; 0xc0000000)) return 0x3fffffff &amp; ~num; else if(!(num &amp; 0x80000000)) return 0x7fffffff &amp; ~num; else return 0; }}; 137. 只出现一次的数字 II 没做出来，再接再厉 260. 只出现一次的数字 III没做出来，再接再厉 29. 两数相除 在LeetCode写过，当时没有意识到是位运算 大体思路就是类似快速幂 67. 二进制求和 对二进制的理解，和位运算关系不大 78. 子集递归法 每层递归向指定集合中依次加入一个剩余元素，并再次递归 首先加入空集，第一层递归在空集的基础上加入一个元素 第二层递归加入第二个元素 12345678910111213141516171819class Solution {public: vector&lt;vector&lt;int&gt;&gt; res; int n; vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { n = nums.size(); res.push_back(move(vector&lt;int&gt;())); insert(0, res[0], nums); return res; } void insert(int i, vector&lt;int&gt; v, const vector&lt;int&gt;&amp; nums) { for(int j = i; j &lt; n; j++) { vector&lt;int&gt; vv = v; vv.push_back(nums[j]); res.push_back(vv); insert(j+1, vv, nums); } }}; 二进制状态 利用0到1 &lt;&lt; N的所有状态，刚好对应N个元素的所有状态 状态第i位表示第i个元素是否在集合中 1234567891011121314151617181920212223class Solution {public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { int state = 0; int n = nums.size(); int len = 1 &lt;&lt; n; vector&lt;vector&lt;int&gt;&gt; res; while(state &lt; len) { int s = state, j = 0; vector&lt;int&gt; v; while(s) { if(s &amp; 1) { v.push_back(nums[j]); } s &gt;&gt;= 1; j++; } res.push_back(v); state++; } return res; }}; 格雷码优化 利用格雷码每次只改变一个元素的特性，利用异或找出变化的元素，并判断应该加入元素还是删去元素 这样可以优化为非递归算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution {public: vector&lt;vector&lt;int&gt;&gt; stateSubsets(vector&lt;int&gt;&amp; nums) { int state = 0; int n = nums.size(); int len = 1 &lt;&lt; n; vector&lt;vector&lt;int&gt;&gt; res; while(state &lt; len) { int s = state, j = 0; vector&lt;int&gt; v; while(s) { if(s &amp; 1) { v.push_back(nums[j]); } s &gt;&gt;= 1; j++; } res.push_back(v); state++; } return res; } vector&lt;vector&lt;int&gt;&gt; graySubsets(vector&lt;int&gt;&amp; nums) { int state = 0; int n = nums.size(); int len = 1 &lt;&lt; n; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; v; res.push_back(v); int lastGray = 0; for(int i = 1; i &lt; len; i++) { int gray = i ^ (i &gt;&gt; 1); int diff = gray ^ lastGray; int l = 0, r = n-1; int mid = (r - l)/2 + l; while(l &lt;= r) { mid = (r - l)/2 + l; if((1&lt;&lt;mid) == diff) { break; } else if((1&lt;&lt;mid) &gt; diff) { r = mid - 1; } else { l = mid + 1; } } if((1 &lt;&lt; mid) &amp; gray) { v.push_back(nums[mid]); } else { v.erase(find(v.begin(), v.end(), nums[mid])); } res.push_back(v); lastGray = gray; } return res; } vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { // return stateSubsets(nums); return graySubsets(nums); }}; 89. 格雷编码需要生成格雷码，格雷码每相邻两位都不同gi = i ^ (i &gt;&gt; 1) 若i为偶数，i与i+1仅最低位不同，i&gt;&gt;1和(i+1)&gt;&gt;1相等，gi^g(i+1) = i^(i+1) = 1若i为奇数，i最低位的0是第k位， i^(i+1) = k个1， (i &gt;&gt; 2)^((i+1) &gt;&gt; 2) = k-1个1，gi^g(i+1) = 仅第k位为1 1234567891011class Solution {public: vector&lt;int&gt; grayCode(int n) { int len = 1 &lt;&lt; n; vector&lt;int&gt; res(len, 0); for(int i = 0; i &lt; len; i++) { res[i] = i ^ (i &gt;&gt; 1); } return res; }}; 90. 子集 II 不具有不重复性，但具有无序性的特殊集合 统计每个元素的出现次数，将原数组去重 利用状态二进制位表示是否出现某某元素，对于每个元素，要考虑不同的出现次数，这个地方利用递归 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution {public: vector&lt;vector&lt;int&gt;&gt; res; void push(vector&lt;int&gt;&amp; nums, int state, int j, vector&lt;int&gt; vv) { while(state) { if(state &amp; 1) { for(int i = 0; i &lt; numsCnt[j]; i++) { vv.push_back(nums[j]); if(state &gt;&gt; 1)push(nums, state &gt;&gt; 1, j+1, vv); else res.push_back(vv); } break; } state &gt;&gt;= 1; j++; } } vector&lt;vector&lt;int&gt;&gt; stateSubsets(vector&lt;int&gt;&amp; nums, int n) { int state = 0; int len = 1 &lt;&lt; n; res.push_back({}); while(state &lt; len) { push(nums, state, 0, {}); state++; } return res; } vector&lt;int&gt; numsCnt; vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); int i = 0, j = 0; int n = nums.size(); while(i &lt; n) { nums[j] = nums[i]; int cnt = i; while(i &lt; n &amp;&amp; nums[i] == nums[j]) i++; cnt = i - cnt; numsCnt.push_back(cnt); j++; } return stateSubsets(nums, j); }}; 187. 重复的DNA序列 将ATGC编码，通过编码之间的比较代替字符串比较 由于有四个状态，考虑使用两位来表示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution {public: vector&lt;string&gt; findRepeatedDnaSequences(string s) { auto code = make_pair(0, 0); int len = s.length(); map&lt;pair&lt;int, int&gt;, int&gt; m; for(int i = 0; i &lt; 10; i++) { code.first &lt;&lt;= 1; code.second &lt;&lt;= 1; if(s[i] == 'A') { code.first |= 0; code.second |= 0; } else if(s[i] == 'C') { code.first |= 1; code.second |= 0; } else if(s[i] == 'G') { code.first |= 0; code.second |= 1; } else if(s[i] == 'T') { code.first |= 1; code.second |= 1; } else { // unreachable } } m[code]++; vector&lt;string&gt; res; // cout &lt;&lt; code[0].first &lt;&lt; &quot;, &quot; &lt;&lt; code[0].second &lt;&lt; endl; for(int i = 10; i &lt; len; i++) { int mask = 1024-1; code.first &lt;&lt;= 1; code.second &lt;&lt;= 1; code.first &amp;= mask; code.second &amp;= mask; if(s[i] == 'A') { code.first |= 0; code.second |= 0; } else if(s[i] == 'C') { code.first |= 1; code.second |= 0; } else if(s[i] == 'G') { code.first |= 0; code.second |= 1; } else if(s[i] == 'T') { code.first |= 1; code.second |= 1; } else { // unreachable } // cout &lt;&lt; codei.first &lt;&lt; &quot;, &quot; &lt;&lt; codei.second &lt;&lt; endl; m[code]++; if(m[code] == 2) { res.push_back(s.substr(i - 9, 10)); } } return res; }}; 由于一次只存储长度为10的子串，编码时全都编码到同一个int，避免使用pair 12345678910111213141516171819202122232425262728class Solution {public: unordered_map&lt;char, int&gt; bin = {{'A', 0}, {'C', 1}, {'G', 2}, {'T', 3}}; vector&lt;string&gt; findRepeatedDnaSequences(string s) { auto code = 0; int len = s.length(); unordered_map&lt;int, int&gt; m; for(int i = 0; i &lt; 10; i++) { code &lt;&lt;= 2; code |= bin[s[i]]; } m[code]++; // cout &lt;&lt; code[0].first &lt;&lt; &quot;, &quot; &lt;&lt; code[0].second &lt;&lt; endl; vector&lt;string&gt; res; int mask = (1 &lt;&lt; 20) - 1; for(int i = 10; i &lt; len; i++) { code &lt;&lt;= 2; code &amp;= mask; code |= bin[s[i]]; // cout &lt;&lt; codei.first &lt;&lt; &quot;, &quot; &lt;&lt; codei.second &lt;&lt; endl; m[code]++; if(m[code] == 2) { res.push_back(s.substr(i - 9, 10)); } } return res; }}; 190. 颠倒二进制位191. 位1的个数这两个题没什么好说的， 123456789101112131415161718192021class Solution { unordered_map&lt;uint32_t, int&gt; cache; unordered_map&lt;uint32_t, int&gt; cache_len;public: int hammingWeight(uint32_t n) { uint32_t nn = n; if (cache[nn]) return cache[nn]; while (n) { if (cache[n]) { cache[nn] += cache[n]; cache_len[nn] += cache_len[n]; n &gt;&gt;= cache_len[n]; } else if (n &amp; 1) { cache[nn]++; cache_len[nn]++; } n &gt;&gt;= 1; } return cache[nn]; }}; 201. 数字范围按位与将区间内的所有数字相与，得到结果 考虑特殊值，即二的幂次 如果[left, right]区间内出现了一个二的幂次，如[3, 7]内只出现了4，那么对于 小于4的数，3=011，与4相与的结果都为0 大于4的数，5=101，6=110，7=111，与4向与只有一个1 之前出现过0，所以结果为0 如果区间内出现了大于一个二的幂次，a, b（a &lt; b利用上面的结论，也可以得到结果为0 如果区间内没有出现2的幂次，也说明left, right之间的所有数字最高位都为1，结果至少为1，抛弃最高位，重复以上过程，可以依次找到后续位相与后是否有1 1234567891011121314151617181920class Solution {public: inline unsigned highestBit(int n) { return 1 &lt;&lt; (sizeof(unsigned) * CHAR_BIT - 1 - __builtin_clz(n)); } int rangeBitwiseAnd(int left, int right) { int ret = 0; // printf(&quot;%x, %x\\n&quot;, left, right); while (left) { unsigned highest = highestBit(left); // cout &lt;&lt; highest &lt;&lt; endl; if ((highest &lt;&lt; 1) &lt;= right) return ret; ret |= highest; left &amp;= ~highest; right &amp;= ~highest; } return ret; }}; 222. 完全二叉树的节点个数一般方法遍历全部节点计数 123456class Solution {public: int countNodes(TreeNode* root) { return (root ? (1 + countNodes(root-&gt;left) + countNodes(root-&gt;right)): 0); }}; 二分 完全二叉树的高度很好算，然后就可以算出满二叉树的节点个数 对于满二叉树，节点标号的二进制序列就是从root到节点的路径 利用二分查找，寻找最右侧存在的节点，利用第二点的性质查找节点，复杂度为O(log^2(N)) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int getMaxDepth(TreeNode *root) { int maxDepth = 0; while(root) { root = root-&gt;left; maxDepth++; } return maxDepth; } bool contains(TreeNode *root, int n, int maxDepth) { int mask = 1 &lt;&lt; (maxDepth - 1); while(root) { mask &gt;&gt;= 1; if(mask &amp; n) { root = root-&gt;right; } else { root = root-&gt;left; } } return mask == 0; } int countNodes(TreeNode* root) { int maxDepth = getMaxDepth(root); if(maxDepth &lt;= 0) return 0; int l = ((1 &lt;&lt; (maxDepth-1))), r = ((1 &lt;&lt; (maxDepth)) - 1); while(l &lt; r) { int mid = (r - l + 1) / 2 + l; if(contains(root, mid, maxDepth)) { l = mid; } else { r = mid - 1; } } return l; }}; 231. 2 的幂 判断一个数是否数2的幂，也就是只有一个二进制位，且为正数 123456class Solution {public: bool isPowerOfTwo(int n) { return n &gt; 0 &amp;&amp; (n &amp;(n-1)) == 0; }}; 342. 4的幂 也就是只有一个二进制位，且是偶数次幂的位，且不是第0位，而且是正数 123456class Solution {public: bool isPowerOfFour(int n) { return (!(n&amp;0xaaaaaaaa) &amp;&amp; n &gt; 0 &amp;&amp; !(n&amp;(n-1))); }}; 287. 寻找重复数 没做出来，再接再厉 318. 最大单词长度乘积 要求不包含相同字母 可以将字符串含有的字符编码成二进制，利用与运算的结果判断是否有相同字符 1234567891011121314151617181920212223class Solution {public: int maxProduct(vector&lt;string&gt;&amp; words) { int n = words.size(); map&lt;int, int&gt; bitMap; for(int i = 0; i &lt; n; i++) { int mask = 0; for(auto ite = words[i].rbegin(); ite != words[i].rend(); ite++) { mask |= 1 &lt;&lt; (*ite - 'a'); } bitMap[mask] = max(bitMap[mask], (int)words[i].length()); } int maxRes = 0; for(auto ite = bitMap.begin(); ite != bitMap.end(); ite++) { map&lt;int, int&gt;::iterator jte = ite; jte++; for(; jte != bitMap.end(); jte++) { if((ite-&gt;first &amp; jte-&gt;first) == 0) maxRes = max(maxRes, ite-&gt;second * jte-&gt;second); } } return maxRes; }}; 338. 比特位计数 要求寻找[0,n]中所有数的比特位数 没做出来，再接再厉 dp，对于偶数，二进制数等于(i &gt;&gt; 2),对于奇数，等于(i &gt;&gt; 2) + 1 12345678910class Solution {public: vector&lt;int&gt; countBits(int num) { vector&lt;int&gt; ans(num+1, 0); for(int i = 1; i &lt;= num; i++) { ans[i] = ans[i &gt;&gt; 1] + (i &amp; 1); } return ans; }}; 371. 两整数之和 复习一下数电的知识就好啦 1234567891011// 0 0 0 0 0// 0 0 1 1 0// 0 1 0 1 0// 0 1 1 0 1 ~abc// 1 0 0 1 0// 1 0 1 0 1 a~bc// 1 1 0 0 1 ab~c// 1 1 1 1 1 abc// ~abc + a~bc + ab~c + abc// bc + a(~bc+b~c)// bc + a(b^c) 123456789101112131415class Solution {public: int getSum(int a, int b) { int carry = 0; int sum = 0; int mask = 1; for(int i = 0; i &lt; 32; i++) { sum |= (a ^ b ^ carry) &amp; mask; carry = (b&amp;carry) | (a &amp; (b ^ carry)); carry &lt;&lt;= 1; mask &lt;&lt;= 1; } return sum; }}; 389. 找不同居然没想到，长大后再试试吧 393. UTF-8 编码验证主要是应用位运算，还是关系不大 123456789101112131415161718192021222324252627class Solution {public: bool validUtf8(vector&lt;int&gt;&amp; data) { int n = data.size(); for(int i = 0; i &lt; n; i++) { int cnt = (0xf8 &amp; data[i]) &gt;&gt; 3; // printf(&quot;%x, %x\\n&quot;, cnt, data[i]); if(cnt &lt; 0x10) { cnt = 0; } else if(cnt &gt;= 0x18 &amp;&amp; cnt &lt; 0x1c) { cnt = 1; } else if(cnt &gt;= 0x1c &amp;&amp; cnt &lt; 0x1e) { cnt = 2; } else if(cnt == 0x1e) { cnt = 3; } else { return false; } while(cnt--) { i++; if(i &gt;= n) return false; if((data[i] &amp; 0xc0) != 0x80) return false; } } return true; }}; 397. 整数替换暴力+记忆优化1234567891011class Solution { unordered_map&lt;int, int&gt; cnt;public: int integerReplacement(int n) { if(cnt.count(n)) return cnt[n]; if(n == 1) cnt[n] = 0; else if(n&amp;1) cnt[n] = 2 + min(integerReplacement(n&gt;&gt;1), integerReplacement((n&gt;&gt;1) + 1)); else cnt[n] = 1 + integerReplacement(n &gt;&gt; 1); return cnt[n]; }}; 贪心 偶数，直接除以2 奇数，除以4余数为1，-1，相当于尽量避免奇数的出现，延迟奇数的出现，因为奇数操作数是2，偶数是1 奇数，除以4余数为3，+1，相当于尽量避免奇数的出现，延迟奇数的出现，因为奇数操作数是2，偶数是1123456789101112131415161718192021222324252627282930class Solution { unordered_map&lt;int, int&gt; cnt;public: int integerReplacement(int n) { cnt[3] = 2; if(cnt.count(n)) return cnt[n]; int nn = n; while(n &gt; 1) { int add = 0; if(!(n&amp;1)) { add = 1; n &gt;&gt;= 1; } else { add = 2; if((n &gt;&gt; 1) &amp; 1) { n &gt;&gt;= 1; n++; } else { n &gt;&gt;= 1; } } if(cnt.count(n)) { cnt[nn] += add + cnt[n]; break; } cnt[nn] += add; } return cnt[nn]; }}; 401. 二进制手表利用二进制做状态 状态+检查bitCount12345678910111213141516171819202122232425class Solution {public: int bitCount(int n) { int cnt = 0; while(n) { if(n &amp; 1) cnt++; n &gt;&gt;= 1; } return cnt; } vector&lt;string&gt; readBinaryWatch(int turnedOn) { vector&lt;string&gt; res; for(int h = 0; h &lt; 16; h++) { for(int m = 0; m &lt; 64; m++) { if(bitCount(h) + bitCount(m) != turnedOn) continue; char time[6]; if(h &gt;= 0 &amp;&amp; h &lt; 12 &amp;&amp; m &gt;= 0 &amp;&amp; m &lt; 60) { sprintf(time, &quot;%d:%02d&quot;, h, m); res.push_back(time); } } } return res; }}; 格雷码用格雷码的特性，bitcount每次只会加1或减一，省去bitcounts的计算 1234567891011121314151617181920212223242526272829303132class Solution {public: vector&lt;string&gt; readBinaryWatch(int turnedOn) { vector&lt;string&gt; res; int hBitCount = 0; int H = 0; int lastH = 0, lastM = 0; for(int h = 0; h &lt; 16; h++) { int M = 0; int mBitCount = 0; lastH = H; H = h^(h &gt;&gt; 1); if(H &amp; (lastH ^ H)) hBitCount++; else if(h) hBitCount--; // printf(&quot;H=%x, hBitCount=%d\\n&quot;, H, hBitCount); for(int m = 0; m &lt; 64; m++) { lastM = M; M = m^(m &gt;&gt; 1); if(M &amp; (lastM ^ M)) mBitCount++; else if(m) mBitCount--; // printf(&quot;M=%x, mBitCount=%d\\n&quot;, M, mBitCount); if(hBitCount + mBitCount != turnedOn) continue; char time[6]; if(H &gt;= 0 &amp;&amp; H &lt; 12 &amp;&amp; M &gt;= 0 &amp;&amp; M &lt; 60) { sprintf(time, &quot;%d:%02d&quot;, H, M); res.push_back(time); } } } return res; }}; 405. 数字转换为十六进制数1234567891011121314class Solution { static constexpr int m[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};public: string toHex(int num) { int cnt = 8; string res; while(cnt-- &amp;&amp; !(0xf &amp; (num &gt;&gt; (cnt * 4)))); if(cnt &gt;= 0) do { res.push_back(m[0xf &amp; (num &gt;&gt; (cnt * 4))]); } while(cnt--); else return &quot;0&quot;; return res; }}; 421. 数组中两个数的最大异或值没写出来，题解也是一位一位的算 总结 技巧一：利用二进制做状态码 技巧二：计科基础，加法器、数电 技巧三：利用二进制减少计算量，对状态少的数据进行编码，用位运算一次计算多个数据 技巧四：考察常用技巧 技巧五：利用格雷码优化 技巧六：逐位计算结果","link":"/home/2023/11/05/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"title":"PTA-Advance-1001","text":"PROBLEMCalculate a+b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits). Input Specification:Each input file contains one test case. Each case contains a pair of integers a and b where $−10^6≤a,b≤10^6$. The numbers are separated by a space. Output Specification:For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format. Sample Input:1-1000000 9 Sample Output:1-999,991 ACCEPTED CODE12345678910111213141516#include &lt;iostream&gt;using namespace std;int main () { int a, b; string ans; char temp[32] = {0}; scanf (&quot;%d%d&quot;, &amp;a, &amp;b); int c = a + b; sprintf(temp, &quot;%d&quot;, c); ans = temp; for (int i = ans.length() - 1, count = 1; i &gt; 0; i--, count++) if (count % 3 == 0 &amp;&amp; ans[i - 1] != '-') ans.insert(i, 1, ','); printf (&quot;%s&quot;, ans.data()); return 0;} THINKING AND NOTICE Insert a comma every 3 character. Traversal the string from the end of it. If the result of a+b is negative, check that there are no negative sign - before inserting a comma,. REFLECTION AND COMMENTS Relatively easy. Hope that I can stick to using English to write articles.","link":"/home/2019/07/13/PAT-(Advanced-Level)-Practice/1001-A+B-Format(PAT-(Advanced-Level)-Practice)/"},{"title":"PAT-Basic-1014","text":"题目 大侦探福尔摩斯接到一张奇怪的字条：我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间星期四 14:04，因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 D，代表星期四；第 2 对相同的字符是 E ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示）；后面两字符串第 1 对相同的英文字母 s 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。 输入格式： 输入在 4 行中分别给出 4 个非空、不包含空格、且长度不超过 60 的字符串。 输出格式： 在一行中输出约会的时间，格式为 DAY HH:MM，其中 DAY 是某星期的 3 字符缩写，即 MON 表示星期一，TUE 表示星期二，WED 表示星期三，THU 表示星期四，FRI 表示星期五，SAT 表示星期六，SUN 表示星期日。题目输入保证每个测试存在唯一解。 输入样例：3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm 输出样例：THU 14:04 通过代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;int main() { string clue[4]; int day, hour, minute; string week[7] = {&quot;MON&quot;, &quot;TUE&quot;, &quot;WED&quot;, &quot;THU&quot;, &quot;FRI&quot;, &quot;SAT&quot;, &quot;SUN&quot;}; for (int i = 0; i &lt; 4; i++) { cin &gt;&gt; clue[i]; } int count = -1; int y = 0; char c[2]; for (int i = 0; i &lt; min(clue[0].length(), clue[1].length()); i++) { if (count == -1 &amp;&amp; clue[0][i] == clue[1][i] &amp;&amp; (clue[0][i] &gt;= 'A' &amp;&amp; clue[0][i] &lt;= 'G')) { c[++count] = clue[0][i]; } if (count == 0 &amp;&amp; clue[0][i] == clue[1][i]) { if ((clue[0][i] &gt;= '0' &amp;&amp; clue[0][i] &lt;= '9') || (clue[0][i] &gt;= 'A' &amp;&amp; clue[0][i] &lt;= 'N')) { y++; } if (y == 2) { c[++count] = clue[0][i]; } } if (count == 1) { break; } } day = c[0] - 'A' + 1; if (c[1] &gt;= '0' &amp;&amp; c[1] &lt;= '9') { hour = c[1] - '0'; } else { hour = c[1] - 'A' + 10; } int pos = 0; for (int i = 0; i &lt; min(clue[2].length(), clue[3].length()); i++) { if (clue[2][i] == clue[3][i] &amp;&amp; ((clue[2][i] &gt;= 'a' &amp;&amp; clue[2][i] &lt;= 'z') || (clue[2][i] &gt;= 'A' &amp;&amp; clue[2][i] &lt;= 'Z'))) { pos = i; break; } } minute = pos; printf(&quot;%s %02d:%02d\\n&quot;, week[day - 1].data(), hour, minute); return 0;} 思路与注意 这道题实在是太咬文嚼字了！！ 第一个线索必须是’A’ 到 ‘G’ \b相同，因为一周只有7天 第二个线索必须是第二个相同的字符，而且必须是’0’-‘9’或’A’-‘N’的，因为一天只有24个小时（感觉题目自己和自己矛盾，题目不太严谨） 第二个线索必须在第一个线索的位置后面开始找（\b？？？\b反正我从题里面很难读出来） 反思与评价 很讨厌的一道题，纯属浪费人时间，做不出来也不纠结它也可以的。","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1014-%E7%A6%8F%E5%B0%94%E6%91%A9%E6%96%AF%E7%9A%84%E7%BA%A6%E4%BC%9A(PAT-(Basic-Level)-Practice)/"},{"title":"LeetCode-排序","text":"复习排序算法 稳定性容易记错的是选择排序 选择排序是从未排序中选择最小的，直接与未排序的第一个交换，所以不稳定 选择排序是从未排序中选择最小的，插入到已排序的后面，就是稳定的 先手写一遍常见排序算法 比较排序 交换排序 冒泡 快排 插入排序 简单插入 希尔排序 选择排序 简单选择 堆排序 归并排序 二路归并 多路归并 非比较排序 计数排序 桶排序 基数排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#include &lt;random&gt;using namespace std;template &lt;typename T&gt;void printVec(const vector&lt;T&gt;&amp; vec, function&lt;string(const T&amp;)&gt; toString);template&lt;typename T&gt;void bubbleSort(vector&lt;T&gt;&amp; vec, function&lt;int(const T&amp;, const T&amp;)&gt; compare) { int len = vec.size(); for(int i = 0; i &lt; len; i++) { for(int j = 0; j &lt; len - i - 1; j++) { if(compare(vec[j], vec[j+1]) &gt; 0) { swap(vec[j], vec[j+1]); } } }}template&lt;typename T&gt;void selectSort(vector&lt;T&gt;&amp; vec, function&lt;int(const T&amp;, const T&amp;)&gt; compare) { int len = vec.size(); for(int i = 0; i &lt; len; i++) { int minIndex = i; for(int j = i+1; j &lt; len; j++) { if(compare(vec[minIndex], vec[j]) &gt; 0) { minIndex = j; } } swap(vec[i], vec[minIndex]); }}template&lt;typename T&gt;void stableSelectSort(vector&lt;T&gt;&amp; vec, function&lt;int(const T&amp;, const T&amp;)&gt; compare) { int len = vec.size(); for(int i = 0; i &lt; len; i++) { int minIndex = i; for(int j = i+1; j &lt; len; j++) { if(compare(vec[minIndex], vec[j]) &gt; 0) { minIndex = j; } } T t = vec[minIndex]; for(int j = minIndex; j &gt; i; j--) { vec[j] = vec[j-1]; } vec[i] = t; }}template&lt;typename T&gt;void insertSort(vector&lt;T&gt;&amp; vec, function&lt;int(const T&amp;, const T&amp;)&gt; compare) { int len = vec.size(); for(int i = 0; i &lt; len-1; i++) { // 下面是i+1，这里要len-1 for(int j = i+1; j &gt; 0; j--) { if(compare(vec[j], vec[j-1]) &lt; 0) { swap(vec[j], vec[j-1]); } else { break; } } }}template&lt;typename T&gt;void mergeSort(vector&lt;T&gt;&amp; vec, function&lt;int(const T&amp;, const T&amp;)&gt; compare, int start, int end) { if(end - start &lt;= 1) return; int mid = (end - start) / 2 + start; mergeSort(vec, compare, start, mid); mergeSort(vec, compare, mid, end); // merge vector&lt;T&gt; tmp(end - start); int cur = 0, i = start, j = mid; while(i &lt; mid &amp;&amp; j &lt; end) { if(compare(vec[i], vec[j]) &lt;= 0) { // 稳定性 tmp[cur++] = vec[i++]; } else { tmp[cur++] = vec[j++]; } } while(i &lt; mid) { tmp[cur++] = vec[i++]; } while(j &lt; end) { tmp[cur++] = vec[j++]; } for(i = start; i &lt; end; i++) { vec[i] = tmp[i - start]; }}template&lt;typename T&gt;void mergeSort(vector&lt;T&gt;&amp; vec, function&lt;int(const T&amp;, const T&amp;)&gt; compare) { int len = vec.size(); mergeSort(vec, compare, 0, len);}template&lt;typename T&gt;void quickSort(vector&lt;T&gt;&amp; vec, function&lt;int(const T&amp;, const T&amp;)&gt; compare, int start, int end) { if(end - start &lt;= 1) return; int i = start, j = end - 1; while(i &lt; j) { while(i &lt; j &amp;&amp; compare(vec[i], vec[j]) &lt;= 0) j--; swap(vec[j], vec[i]); while(i &lt; j &amp;&amp; compare(vec[i], vec[j]) &lt;= 0) i++; swap(vec[i], vec[j]); } quickSort(vec, compare, start, i); quickSort(vec, compare, i+1, end); // i + 1, 已排序的枢轴就不用了}template&lt;typename T&gt;void quickSort(vector&lt;T&gt;&amp; vec, function&lt;int(const T&amp;, const T&amp;)&gt; compare) { int len = vec.size(); quickSort(vec, compare, 0, len);}template&lt;typename T&gt;void heapAdjust(vector&lt;T&gt;&amp; vec, int i, int end, function&lt;int(const T&amp;, const T&amp;)&gt; compare) { for(int j = i; ; ) { int largest = j; if(j*2+1 &lt; end &amp;&amp; compare(vec[largest], vec[j*2+1]) &lt; 0) { largest = j*2+1; } if(j*2+2 &lt; end &amp;&amp; compare(vec[largest], vec[j*2+2]) &lt; 0) { largest = j*2+2; } if(j == largest) break; swap(vec[j], vec[largest]); j = largest; }}template&lt;typename T&gt;void heapSort(vector&lt;T&gt;&amp; vec, function&lt;int(const T&amp;, const T&amp;)&gt; compare) { int len = vec.size(); // heapAdjust// for(int i = len-1; i &gt; 0; i--) {// if(compare(vec[i], vec[(i+1)/2-1]) &gt; 0) {// swap(vec[i], vec[(i+1)/2-1]);// }// } //wrong for(int i = len/2; i &gt;= 0; i--) { heapAdjust(vec, i, len, compare); } // sort for(int i = len-1; i &gt; 0; i--) { swap(vec[0], vec[i]); heapAdjust(vec, 0, i, compare); }}const int MAX_NUMBER = 1000;const int MIN_NUMBER = -1000;const int MAX_LEN = 2000000;template &lt;typename T&gt;int compare(const T&amp; a, const T&amp; b) { if(a == b) return 0; else if(a &gt; b) return 1; else return -1;}template &lt;typename T&gt;void printVec(const vector&lt;T&gt;&amp; vec, function&lt;string(const T&amp;)&gt; toString) { cout &lt;&lt; &quot;[&quot;; if(vec.size() &gt; 0) cout &lt;&lt; toString(vec[0]); for(size_t i = 1; i &lt; vec.size(); i++) { cout &lt;&lt; &quot;, &quot; &lt;&lt; toString(vec[i]); } cout &lt;&lt; &quot;]\\n&quot;;}clock_t execTime(const function&lt;void(vector&lt;pair&lt;int, int&gt;&gt; &amp;)&gt;&amp; f, vector&lt;pair&lt;int, int&gt;&gt; &amp;vec) { clock_t start = clock(); f(vec); clock_t end = clock(); return end - start;}void speedTest(decltype(bubbleSort&lt;pair&lt;int, int&gt;&gt;) sort, vector&lt;pair&lt;int, int&gt;&gt; &amp;a, vector&lt;pair&lt;int, int&gt;&gt; b) { auto cmp = [](const pair&lt;int, int&gt;&amp; x, const pair&lt;int, int&gt;&amp; y){ return compare(x.first, y.first); }; clock_t our = execTime([&amp;](vector&lt;pair&lt;int, int&gt;&gt; &amp; vec) {sort(vec, cmp);}, a); clock_t libc = execTime([](vector&lt;pair&lt;int, int&gt;&gt; &amp; vec) {std::sort(vec.begin(), vec.end());}, b); cout &lt;&lt; &quot;our: &quot; &lt;&lt; our &lt;&lt; &quot;, libc: &quot; &lt;&lt; libc &lt;&lt; &quot;, promoted: &quot; &lt;&lt; double(libc - our) / double(libc) * 100 &lt;&lt; &quot;%&quot; &lt;&lt; endl;}void test(decltype(bubbleSort&lt;pair&lt;int, int&gt;&gt;) sort, bool is_stable) { int len = rand() % MAX_LEN; vector&lt;pair&lt;int, int&gt;&gt; vec; map&lt;int, int&gt; cnt; for(int i = 0; i &lt; len; i++) { int num = rand() % (MAX_NUMBER - MIN_NUMBER) + MIN_NUMBER; vec.emplace_back(num, ++cnt[num]); } speedTest(sort, vec, vec); bool stability = true, ok = true; for(int i = 0; i &lt; len - 1; i++) { cnt[vec[i].first]--; if(compare(vec[i].first, vec[i+1].first) &gt; 0) { ok = false; } else if(compare(vec[i].first, vec[i+1].first) == 0) { if(vec[i].second + 1 != vec[i+1].second) { stability = false; } } } if(len &gt; 0) cnt[vec[len-1].first]--; for(auto &amp; ite : cnt) { if(ite.second != 0) { ok = false; break; } }// cout &lt;&lt; &quot;ok: &quot; &lt;&lt; ok &lt;&lt; &quot;, stable: &quot; &lt;&lt; stability &lt;&lt; endl; if(!ok) { printVec&lt;pair&lt;int, int&gt;&gt;(vec, [](const pair&lt;int, int&gt;&amp; item) { stringstream ss; ss &lt;&lt; &quot;{&quot; &lt;&lt; item.first &lt;&lt; &quot;, &quot; &lt;&lt; item.second &lt;&lt; &quot;}&quot;; return ss.str(); }); throw runtime_error(&quot;sort failed!\\n&quot;); } if(is_stable &amp;&amp; !stability) { throw runtime_error(&quot;stability not match&quot;); }}int main() { srand(time(NULL)); test(bubbleSort, true); test(selectSort, false); test(stableSelectSort, true); test(insertSort, true); test(mergeSort, true); test(quickSort, false); test(heapSort, false);}","link":"/home/2024/03/17/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%E6%8E%92%E5%BA%8F/"},{"title":"PTA-Advance-1002","text":"PROBLEMThis time, you are supposed to find A+B where A and B are two polynomials. Input Specification:Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1,2,⋯,K) are the exponents and coefficients, respectively. It is given that 1≤K≤10，0≤NK&lt;⋯&lt;N2&lt;N1≤1000. Output Specification:For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place. Sample Input:122 1 2.4 0 3.22 2 1.5 1 0.5 Sample Output:13 2 1.5 1 2.9 0 3.2 ACCEPTED CODE1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int main () { map&lt;int , double, greater&lt;int&gt;&gt; m; int k, count = 0; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) { double exp , cof; cin &gt;&gt; exp &gt;&gt; cof; m[exp] += cof; } cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) { double exp , cof; cin &gt;&gt; exp &gt;&gt; cof; m[exp] += cof; if (m[exp] == 0) count++;//if this item is zero, count++ } printf (&quot;%d&quot;, m.size() - count);//print the nonzero item num, if result is zero, print zero for (map&lt;int, double&gt;::iterator ite = m.begin(); ite != m.end(); ite++) { if (ite-&gt;second != 0)//if this item is zero, do not print printf (&quot; %d %.1lf&quot;, ite-&gt;first, ite-&gt;second); } return 0;} THINKING AND NOTICES Creating a map from the exponents to coefficients. Add up the two coefficients of each exponents. Print a zero(the total number of nonzero items) if the result of a+b is zero. Map will sort your data by the keys in declining order, but you should print it in increasing order, so give map the third parameter – the class or struct name which has a member function like this:bool operator() (const double&amp; str1, const double&amp; str2);, a function (I’m not sure.) greater&lt;int&gt; ,or you can simply traversal the map from the end of it. REFLECTION AND COMMENT Noting to reflect.","link":"/home/2019/07/13/PAT-(Advanced-Level)-Practice/1002-A+B-for-Polynomials(PAT-(Advanced-Level)-Practice)/"},{"title":"PAT-Basic-1005","text":"题目 卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。 当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 n=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”，如果 n 不能被数列中的其他数字所覆盖。 现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。 输入格式： 每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 K (&lt;100)，第 2 行给出 K 个互不相同的待验证的正整数 n (1&lt;n≤100)的值，数字间用空格隔开。 输出格式： 每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。 输入样例：1263 5 6 7 8 11 输出样例：17 6 通过代码（极致压行版）12345678910111213141516#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int arr[999999], brr[999999], n;int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n &amp;&amp; cin &gt;&gt; brr[i]; i++) for (int t = brr[i]; t != 1;) if (t % 2 == 0) arr[t /= 2] = 1; else arr[t = (3 * t + 1) / 2] = 1; sort(brr, brr + n, greater&lt;int&gt;()); for (int i = 0, count = 0; i &lt; n; i++) if (!arr[brr[i]] &amp;&amp; count++ == 0) cout &lt;&lt; brr[i]; else if (!arr[brr[i]])cout &lt;&lt; &quot; &quot; &lt;&lt; brr[i]; return 0;} 通过代码123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int arr[999999];int main() { int n; cin &gt;&gt; n; int brr[n] = {0}; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; brr[i]; for (int t = brr[i]; t != 1;) { if (t % 2 == 0) { arr[t/=2] = 1; } else { arr[t = (3*t + 1)/2] = 1; } } } sort(brr, brr+n, greater&lt;int&gt;()); for (int i = 0, count = 0; i &lt; n; i++) { if (!arr[brr[i]]) { if (count++ == 0) cout &lt;&lt; brr[i]; else cout &lt;&lt; &quot; &quot; &lt;&lt; brr[i]; } } return 0;} 思路 数字当引索的数组存是否存在的真假值","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1005-%E7%BB%A7%E7%BB%AD(3n+1)%E7%8C%9C%E6%83%B3(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1018","text":"题目 大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示： 现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。 输入格式： 输入第 1 行给出正整数 N（≤10^5），即双方交锋的次数。随后 N 行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C 代表“锤子”、J 代表“剪刀”、B 代表“布”，第 1 个字母代表甲方，第 2 个代表乙方，中间有 1 个空格。 输出格式： 输出第 1、2 行分别给出甲、乙的胜、平、负次数，数字间以 1 个空格分隔。第 3 行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有 1 个空格。如果解不唯一，则输出按字母序最小的解。 输入样例：10 C J J B C B B B B C C C C B J B B C J J 输出样例：5 3 2 2 3 5 B B 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;using namespace std;class Player { private: int win; int equal; int lose; int cw; int jw; int bw; char op; public: Player() { win = 0; lose = 0; equal = 0; cw = 0; jw = 0; bw = 0; op = 'n'; } void setOp(char a) { op = a; } static void game(Player &amp;a, Player &amp;b) { if (a.op == 'C') { if (b.op == 'C') { a.equal++; b.equal++; } else if (b.op == 'J') { a.win++; a.cw++; b.lose++; } else if (b.op == 'B') { a.lose++; b.win++; b.bw++; } } else if (a.op == 'J') { if (b.op == 'C') { a.lose++; b.win++; b.cw++; } else if (b.op == 'J') { a.equal++; b.equal++; } else if (b.op == 'B') { a.win++; a.jw++; b.lose++; } } else if (a.op == 'B') { if (b.op == 'C') { a.win++; b.lose++; a.bw++; } else if (b.op == 'J') { a.lose++; b.win++; b.jw++; } else if (b.op == 'B') { a.equal++; b.equal++; } } } void showCondition() { cout &lt;&lt; win &lt;&lt; &quot; &quot; &lt;&lt; equal &lt;&lt; &quot; &quot; &lt;&lt; lose &lt;&lt; endl; } char showMost() { if (jw &gt; cw) { if (jw &gt; bw) return 'J'; else return 'B'; } else if (jw == cw) { if (jw &gt; bw) return 'C'; else return 'B'; } else { if (cw &lt;= bw) return 'B'; else return 'C'; } }};int main(){ int n; cin &gt;&gt; n; cin.ignore(); Player a, b; for (int i = 0; i &lt; n; i++) { char aop, bop; cin &gt;&gt; aop; cin.ignore(); cin &gt;&gt; bop; cin.ignore(); a.setOp(aop); b.setOp(bop); Player::game(a, b); } a.showCondition(); b.showCondition(); cout &lt;&lt; a.showMost() &lt;&lt; &quot; &quot; &lt;&lt; b.showMost() &lt;&lt; endl; return 0;} 思路与注意 没什么好主意的，简单题 反思与评价 没什么好反思的 非要反思的话，压行是门技术活","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1018-%E9%94%A4%E5%AD%90%E5%89%AA%E5%88%80%E5%B8%83(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1020","text":"题目 月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。 注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45/2 = 94.5（亿元）。 输入格式： 每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 D 表示市场最大需求量。随后一行给出 N 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 N 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。 输出格式： 对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。 输入样例：1233 2018 15 1075 72 45 输出样例：194.50 通过代码1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct moonCake {double storage, money, price;};bool cmp(moonCake&amp; a, moonCake&amp; b) {return a.price &gt; b.price;}int main () { int n, m, i;//月饼种类，市场需求，循环变量（压行） cin &gt;&gt; n &gt;&gt; m; moonCake data[n]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; data[i].storage;//输入 for (int i = 0; i &lt; n; i++) {//输入 cin &gt;&gt; data[i].money; data[i].price = data[i].money/data[i].storage; } sort(data, data + n, cmp); double sale = 0, temp; for (i = 0; i != n &amp;&amp; m; i++, m-= temp) {//每次循环，m减去卖出去的质量 temp = m &lt; data[i].storage ? m : data[i].storage; sale += temp/data[i].storage * data[i].money; } printf(&quot;%.2lf\\n&quot;, sale); return 0;} 思路与注意 贪心算法，在限制出售的总质量一定时，卖出的货物的平均单价越大，利润越高，即尽量多卖出存量/总售价大的月饼 输入数据，计算出单价（存量/总售价），根据单价降序排序 卖月饼，尽量多的买，如果存量小于等于m，则全部卖出，如果存量大于m，就卖出m，即卖出m与存量的最最小值 计算售价，加起来 输出 注意：把数据全改成double，也许是int会溢出 反思与评价 这题挺好 刚开始还想暴力求解，还TMD写不出来n个for循环嵌套（手动笑哭） 原来我学会贪心算法了啊，哈哈哈 压行压上瘾了","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1020-%E6%9C%88%E9%A5%BC%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1033","text":"题目 旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及坏掉的那些键，打出的结果文字会是怎样？ 输入格式： 输入在 2 行中分别给出坏掉的那些键、以及应该输入的文字。其中对应英文字母的坏键以大写给出；每段文字是不超过 10^5个字符的串。可用的字符包括字母 [a-z, A-Z]、数字 0-9、以及下划线 **_（代表空格）、,、.、-、+**（代表上档键）。题目保证第 2 行输入的文字串非空。注意：如果上档键坏掉了，那么大写的英文字母无法被打出。 输出格式： 在一行中输出能够被打出的结果文字。如果没有一个字符能被打出，则输出空行。 输入样例：7+IE. 7_This_is_a_test. 输出样例：_hs_s_a_tst 通过代码12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;int main () { string err; string origin; int chart[200] = {0}; char temp[100010] = {0}; cin.getline(temp, sizeof(temp)); err = temp; cin.getline(temp, sizeof(temp)); origin = temp; bool shift = false; for (int i = 0; i &lt; err.length(); i++) { chart[err[i]] = -1; if (err[i] == '+') {shift = true;} else { if (err[i] &gt;= 'a' &amp;&amp; err[i] &lt;= 'z'){ chart[err[i] - 'a' + 'A'] = -1; } if (err[i] &gt;= 'A' &amp;&amp; err[i] &lt;= 'Z') { chart[err[i] - 'A' + 'a'] = -1; } } } if (shift) { for (int i = 'A'; i &lt;= 'Z'; i++) chart[i] = -1; } for (int i = 0; i &lt; origin.length(); i++) { if (chart[origin[i]] != -1) cout &lt;&lt; origin[i]; } cout &lt;&lt; endl; return 0;} 思路与注意 这道题又是很坑的一道题 121. 输入样例后的'.'不知道是算shift键还是普通键2. 实际代码中只有'+'才是shift，其他都不是 要明确如果一个键坏掉，那么它对应的大小写都不能用了，如果shift键不能用了，所有的大写字母都不能用了 采用查表法，把不能用的键都变成-1，其他都是0 反思与评价 又是坑题，很讨厌","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1033-%E6%97%A7%E9%94%AE%E7%9B%98%E6%89%93%E5%AD%97(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1025","text":"题目 给定一个常数 K 以及一个单链表 L，请编写程序将 L 中每 K 个结点反转。例如：给定 L 为 1→2→3→4→5→6，K 为 3，则输出应该为 3→2→1→6→5→4；如果 K 为 4，则输出应该为 4→3→2→1→5→6，即最后不到 K 个元素不反转。 输入格式： 每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1 个结点的地址、结点总个数正整数 N (≤10^5)、以及正整数 K (≤N)，即要求反转的子链结点的个数。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。接下来有 N 行，每行格式为：Address Data Next其中 Address 是结点地址，Data 是该结点保存的整数数据，Next 是下一结点的地址。 输出格式： 对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。 输入样例：00100 6 4 00000 4 99999 00100 1 12309 68237 6 -1 33218 3 00000 99999 5 68237 12309 2 33218 输出样例：00000 4 33218 33218 3 12309 12309 2 00100 00100 1 99999 99999 5 68237 68237 6 -1 通过代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct node { int add; int next; int data;};int main () { int first, num, k; scanf (&quot;%d%d%d&quot;, &amp;first, &amp;num, &amp;k); vector&lt;node&gt; v(100005); node temp; for (int i = 0; i &lt; num; i++) { scanf (&quot;%d%d%d&quot;, &amp;temp.add, &amp;temp.data, &amp;temp.next); v[temp.add] = temp; } int find = first; vector&lt;node&gt; x; while (find != -1) { x.push_back(v[find]); find = v[find].next; } num = (int)x.size(); for (int i = 0; i &lt; num/k; i++) { for (int j = (i+1)*k - 1,m = 0; m &lt; k/2; m++) { temp = x[j-m]; x[j-m] = x[j-k+1+m]; x[j-k+1+m] = temp; } } for (int i = 0; i &lt; num - 1; i++) { printf (&quot;%05d %d %05d\\n&quot;, x[i].add, x[i].data, x[i+1].add); } printf (&quot;%05d %d -1\\n&quot;, x[num - 1].add, x[num - 1].data); return 0;} 思路与注意 原来的思路是malloc创建数组，然后node结构体搞成指针的样子，搞成一个既是数组又是链表的东西，结果啊，越高越复杂。 搞一个vector数组，用于查表，把地址\b作为引索 然后根据\b首地址一直查找到结束，按顺序搞到一个vector里面 处理反转关系 输出 反思与评价 用之前的想法写不出来很\b不开心，不过stl真心牛逼！","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1025-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1044","text":"题目 火星人是以 13 进制计数的： 地球人的 0 被火星人称为 tret。 地球人数字 1 到 12 的火星文分别为：jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec。 火星人将进位以后的 12 个高位数字分别称为：tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou。 例如地球人的数字 29 翻译成火星文就是 hel mar；而火星文 elo nov 对应地球数字 115。为了方便交流，请你编写程序实现地球和火星数字之间的互译。 输入格式： 输入第一行给出一个正整数 N（&lt;100），随后 N 行，每行给出一个 [0, 169) 区间内的数字 —— 或者是地球文，或者是火星文。 输出格式： 对应输入的每一行，在一行中输出翻译后的另一种语言的数字。 输入样例：123454295elo novtam 输出样例：1234hel marmay11513 通过代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;ctype.h&gt;using namespace std;string num[2][13] = { {&quot;tret&quot;, &quot;jan&quot;, &quot;feb&quot;, &quot;mar&quot;, &quot;apr&quot;, &quot;may&quot;, &quot;jun&quot;, &quot;jly&quot;, &quot;aug&quot;, &quot;sep&quot;, &quot;oct&quot;, &quot;nov&quot;, &quot;dec&quot;}, {&quot;tret&quot;, &quot;tam&quot;, &quot;hel&quot;, &quot;maa&quot;, &quot;huh&quot;, &quot;tou&quot;, &quot;kes&quot;, &quot;hei&quot;, &quot;elo&quot;, &quot;syy&quot;, &quot;lok&quot;, &quot;mer&quot;, &quot;jou&quot;}};void C(string&amp; str) { int n = atoi(str.data()); string ans; int count = 0; for (int tn = n; tn; tn /= 13, count++); if (count == 1 || count == 0) ans = num[0][n]; else ans = num[1][n / 13] + ((n % 13 != 0) ? (&quot; &quot; + num[0][n % 13]) : &quot;&quot;); cout &lt;&lt; ans &lt;&lt; endl;}int D(string&amp; str) { if (str == &quot;tret&quot;) return 0; string a, b; a = str.substr(0, 3); if (str.length() &gt; 3) b = str.substr(4, str.length() - 3); if (b == &quot;&quot;) { for (int i = 0; i &lt; 13; i++) if (a == num[0][i]) return i; for (int i = 0; i &lt; 13; i++) if (a == num[1][i]) return i * 13; } else { int n = 0; for (int i = 0; i &lt; 13; i++) if (a == num[1][i]) n += i * 13; for (int i = 0; i &lt; 13; i++) if (b == num[0][i]) n += i; return n; }}int main() { int n; cin &gt;&gt; n; getchar(); for (int i = 0; i &lt; n; i++) { string temp; getline(cin, temp); if (!isalpha(temp[0])) C(temp); else cout &lt;&lt; D(temp) &lt;&lt; endl; } return 0;} 思路与注意 13, 26, 39…转换为13进制后，tret不输出 题目说数是属于[0,169)的，所以翻译以后最多有两位。根据这个性质，只算两位就好。","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1044-%E7%81%AB%E6%98%9F%E6%95%B0%E5%AD%97(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1040","text":"题目 字符串 APPAPT 中包含了两个单词 PAT，其中第一个 PAT 是第 2 位(P)，第 4 位(A)，第 6 位(T)；第二个 PAT 是第 3 位(P)，第 4 位(A)，第 6 位(T)。 现给定字符串，问一共可以形成多少个 PAT？ 输入格式： 输入只有一行，包含一个字符串，长度不超过105，只包含 P、A、T 三种字母。 输出格式： 在一行中输出给定字符串中包含多少个 PAT。由于结果可能比较大，只输出对 1000000007 取余数的结果。 输入样例：1APPAPT 输出样例：12 通过代码1234567891011121314#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { char n[100100] = {0}; scanf(&quot;%s&quot;, n); int len = strlen(n); long long pat = 0, at = 0, t = 0; for (int i = len - 1; i &gt;= 0; i--) { if (n[i] == 'T') t++; if (n[i] == 'A') at = (at + t) % 1000000007; if (n[i] == 'P') pat = (pat + at) % 1000000007; } printf(&quot;%lld\\n&quot;, pat % 1000000007);} 思路与注意 题目限制150ms，应该只有O(N)的算法才可以 没思路 有几个PAT（25）看这里 反思与评价 这题挺好 这道题没思路，看题目要求150ms就知道这题用O(N)的方法才行，果断问度娘找了思路。有几个PAT（25） 可能是自己脑子不够用吧","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1040-%E6%9C%89%E5%87%A0%E4%B8%AAPAT(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1045","text":"题目 著名的快速排序算法里有一个经典的划分过程：我们通常采用某种方法取一个元素作为主元，通过交换，把比主元小的元素放到它的左边，比主元大的元素放到它的右边。 给定划分后的 N 个互不相同的正整数的排列，请问有多少个元素可能是划分前选取的主元？ 例如给定 $N = 5$, 排列是1、3、2、4、5。则： 1 的左边没有元素，右边的元素都比它大，所以它可能是主元； 尽管 3 的左边元素都比它小，但其右边的 2 比它小，所以它不能是主元； 尽管 2 的右边元素都比它大，但其左边的 3 比它大，所以它不能是主元； 类似原因，4 和 5 都可能是主元。 因此，有 3 个元素可能是主元。 输入格式： 输入在第 1 行中给出一个正整数 N（≤105）； 第 2 行是空格分隔的 N 个不同的正整数，每个数不超过 109。 输出格式： 在第 1 行中输出有可能是主元的元素个数；在第 2 行中按递增顺序输出这些元素，其间以 1 个空格分隔，行首尾不得有多余空格。 输入样例：1251 3 2 4 5 输出样例：1231 4 5 通过代码 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int arr[1000000], brr[1000000], crr[1000000];int main () { int n, m = 0; scanf (&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) { scanf (&quot;%d&quot;, &amp;arr[i]); brr[i] = arr[i]; } sort(brr, brr + n); int max = -999999; for (int i = 0; i &lt; n; i++) { if (max &lt; arr[i]) max = arr[i]; if (arr[i] == brr[i] &amp;&amp; max == arr[i]) { crr[m++] = arr[i]; } } printf (&quot;%d\\n&quot;, m); if (m &gt; 0) printf(&quot;%d&quot;, crr[0]); for (int i = 1; i &lt; m ; i++) { printf (&quot; %d&quot;, crr[i]); } printf (&quot;\\n&quot;); return 0;} 思路与注意 只要满足一个数的左边没有数或者数都比它小，右边没有元素或者都比它大，它就可能是主元。根据这个思路，写一个O(N^2)的算法肯定会超时 根据快速排序的思想，挑选一个数作为主元，把比它小的数放左边，比它大的放右边，这样然后以主元为分界线，两边视为两个数组重新进行以上操作，直到不能再细分。排序完成。我们可以得到主元在排序前后位置不变且左边的数都比它小，这样，算法就变成了 对数组进行排序，比较那些元素的位置没有变 判断这个数是不是从左往右的最大值 这样就O(N)了 反思与评价 快速排序(25)参考了这个教程，希望以后能更多的独立思考，锻炼思考能力 加油小天天ヾ(◍°∇°◍)ﾉﾞ，你是最胖的！","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1045-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1015","text":"题目 宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”现给出一批考生的德才分数，请根据司马光的理论给出录取排名。 输入格式： 输入第一行给出 3 个正整数，分别为：N（≤10^5），即考生总数；L（≥60），为录取最低分数线，即德分和才分均不低于 L 的考生才有资格被考虑录取；H（&lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 L 的考生也按总分排序，但排在第三类考生之后。 随后 N 行，每行给出一位考生的信息，包括：准考证号 德分 才分，其中准考证号为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。 输出格式： 输出第一行首先给出达到最低分数线的考生人数 M，随后 M 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。 输入样例：14 60 80 10000001 64 90 10000002 90 60 10000011 85 80 10000003 85 80 10000004 80 85 10000005 82 77 10000006 83 76 10000007 90 78 10000008 75 79 10000009 59 90 10000010 88 45 10000012 80 100 10000013 90 99 10000014 66 60 输出样例：12 10000013 90 99 10000012 80 100 10000003 85 80 10000011 85 80 10000004 80 85 10000007 90 78 10000006 83 76 10000005 82 77 10000002 90 60 10000014 66 60 10000008 75 79 10000001 64 90 通过代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct stu { long id; int modest; int skill;};bool cmp(stu a, stu b) { if (a.modest + a.skill != b.modest + b.skill) return a.modest + a.skill &gt; b.modest + b.skill; else if (a.modest != b.modest) return a.modest &gt; b.modest; else return a.id &lt; b.id;}int main() { vector&lt;stu&gt; class1; vector&lt;stu&gt; class2; vector&lt;stu&gt; class3; vector&lt;stu&gt; class4; stu temp; int n, l, h; cin &gt;&gt; n &gt;&gt; l &gt;&gt; h; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; temp.id &gt;&gt; temp.modest &gt;&gt; temp.skill; if (temp.modest &gt;= l &amp;&amp; temp.skill &gt;= l) { if (temp.modest &gt;= h &amp;&amp; temp.skill &gt;= h) class1.push_back(temp); else if (temp.modest &gt;= h &amp;&amp; temp.skill &lt; h) class2.push_back(temp); else if (temp.modest &lt; h &amp;&amp; temp.skill &lt; h &amp;&amp; temp.modest &gt;= temp.skill) class3.push_back(temp); else class4.push_back(temp); } } sort(class1.begin(), class1.end(), cmp); sort(class2.begin(), class2.end(), cmp); sort(class3.begin(), class3.end(), cmp); sort(class4.begin(), class4.end(), cmp); cout &lt;&lt; class1.size() + class2.size() + class3.size() + class4.size() &lt;&lt; endl; for (vector&lt;stu&gt;::iterator ite = class1.begin(); ite != class1.end(); ite++) {printf(&quot;%08ld %d %d\\n&quot;, (*ite).id, (*ite).modest, (*ite).skill);} for (vector&lt;stu&gt;::iterator ite = class2.begin(); ite != class2.end(); ite++) {printf(&quot;%08ld %d %d\\n&quot;, (*ite).id, (*ite).modest, (*ite).skill);} for (vector&lt;stu&gt;::iterator ite = class3.begin(); ite != class3.end(); ite++) {printf(&quot;%08ld %d %d\\n&quot;, (*ite).id, (*ite).modest, (*ite).skill);} for (vector&lt;stu&gt;::iterator ite = class4.begin(); ite != class4.end(); ite++) {printf(&quot;%08ld %d %d\\n&quot;, (*ite).id, (*ite).modest, (*ite).skill);} return 0;} 思路与注意 本质上还是统计数据，用\bstl会很方便。 \b必须及格的考生才能参与排序。 注意题真的很难读懂，长长的一大片。 大概分四类考生 第一类是两科都超过优胜线的。 第二类是德分过优胜线，才分及格的。 第三类是两科都及格，但都不到优胜线，且德分高于才分的。 第四类是两科过了及格线但不属于以上任何一种的考生 反思与评价 我觉得我这个代码完美，不需要反思","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1015-%E5%BE%B7%E6%89%8D%E8%AE%BA(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1048","text":"题目 本题要求实现一种数字加密方法。首先固定一个加密用正整数 A，对任一正整数 B，将其每 1 位数字与 A 的对应位置上的数字进行以下运算： 对奇数位，对应位的数字相加后对 13 取余——这里用 J 代表 10、Q 代表 11、K 代表 12；对偶数位，用 B 的数字减去 A 的数字，若结果为负数，则再加 10。这里令个位为第 1 位。 输入格式： 输入在一行中依次给出 A 和 B，均为不超过 100 位的正整数，其间以空格分隔。 输出格式： 在一行中输出加密后的结果。 输入样例：1234567 368782971 输出样例：3695Q8118 通过代码12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.*;public class Main { static Scanner sc;\b static { sc = new Scanner(System.in); } static int max(int a, int b) { return a &gt; b ? a : b; } public static void main(String[] args) { // code here String in = sc.nextLine(); StringBuffer a = new StringBuffer(in.substring(0, in.indexOf(' '))); StringBuffer b = new StringBuffer(in.substring(in.indexOf(' ') + 1, in.length())); StringBuffer ans = new StringBuffer(); //字符和数字互转 char[] num = new char[13]; for (int i = 0; i &lt; 10; i++) { num[i] = (char) (i + '0'); } num[10] = 'J'; num[11] = 'Q'; num[12] = 'K'; int[] Char = new int[128]; for (char i = '0'; i &lt;= '9'; i++) {Char[i] = i - '0';} Char['J'] = 10;Char['Q'] = 11;Char['K'] = 12; int len = max(a.length(), b.length()); StringBuffer temp = new StringBuffer(); for (int i = 0; i &lt; len - a.length(); i++) { temp.append('0'); } a.insert(0, temp.toString()); temp = new StringBuffer(); for (int i = 0; i &lt; len - b.length(); i++) { temp.append('0'); } b.insert(0, temp.toString()); int cmp = len % 2; for (int i = 0; i &lt; len; i++) { char x; if ((i + 1) % 2 == cmp) { x = num[(Char[a.charAt(i)] + Char[b.charAt(i)]) % 13]; ans.append(x); } else { int n = (Char[b.charAt(i)] - Char[a.charAt(i)]); x = num[n &gt;= 0 ? n : n + 10]; ans.append(x); } } System.out.println(ans); }} 反思与评价反思        这道题是用Java写的，总体来说没有什么难度，但是\b题目中规定各位为第一位，我直接用for从0开始循环判断(i+1)的\b\b奇偶性，这就导致最长位数如果是奇数，那么个位就是奇数位，反之则为偶数位。        为了解决这个缺陷，考虑到如果最长位数为偶数\b，\b操作跟原来互换就好\b，就要把0变成1，\b1变成0，所以我定义了一个整型cmp，\b它的值为len%2，这样就解决了。 评价    题目简单，没什么好说的，但是代码看起来还是太复杂。","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1048-%E6%95%B0%E5%AD%97%E5%8A%A0%E5%AF%86(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1050","text":"题目 本题要求将给定的 N 个正整数按非递增的顺序，填入“螺旋矩阵”。所谓“螺旋矩阵”，是指从左上角第 1 个格子开始，按顺时针螺旋方向填充。要求矩阵的规模为 m 行 n 列，满足条件：m×n 等于 N；m≥n；且 m−n 取所有可能值中的最小值。 输入格式： 输入在第 1 行中给出一个正整数 N，第 2 行给出 N 个待填充的正整数。所有数字不超过 104，相邻数字以空格分隔。 输出格式： 输出螺旋矩阵。每行 n 个数字，共 m 行。相邻数字以 1 个空格分隔，行末不得有多余空格。 输入样例：121237 76 20 98 76 42 53 95 60 81 58 93 输出样例：123498 95 9342 37 8153 20 7658 60 76 通过代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void get_mn(int* m, int* n, int N) { int i = 0; do { *n = sqrt(N) - i; *m = N / (*n); i++; } while ((*m) * (*n) != N);}int main() { int n; int t; vector&lt;int&gt; arr; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; t; arr.push_back(t); } sort(arr.begin(), arr.end()); int count = n - 1; int N, M; get_mn(&amp;M, &amp;N, n); vector&lt;vector&lt;int&gt; &gt; a; vector&lt;int&gt; temp(N); for (int i = 0; i &lt; M; i++) { a.push_back(temp); } int i = 0; while (count &gt;= 0) { for (int j = i; j &lt; N - 1 - i &amp;&amp; i &lt; M; j++)//①从下标i开始，直到N - 1 - i a[i][j] = arr[count--]; for (int j = i; j &lt; M - i &amp;&amp; i &lt; N; j++)//②从下标i开始，直到M - i a[j][N - 1 - i] = arr[count--]; for (int j = N - 1 - i - 1; j &gt; i - 1 &amp;&amp; i &lt; M; j--)//①的倒序 a[M - 1 - i][j] = arr[count--]; if (N - 1 - i &gt; i) for (int j = M - 1 - i - 1; j &gt; i &amp;&amp; i &lt; N; j--)//②的倒序 a[j][i] = arr[count--]; i++; } for (int i = 0; i &lt; M; i++) { cout &lt;&lt; a[i][0]; for (int j = 1; j &lt; N; j++) cout &lt;&lt; &quot; &quot; &lt;&lt; a[i][j]; cout &lt;&lt; endl; }} 思路与注意 先把数储存，再顺序输出 以一圈为单位，4个循环填好一圈 记录第几圈，以这个数确定每次从哪里开始填数 最后要判断( N - 1 - i &gt; i ) 计算MN时要注意(n/N)*N 不一定等于 n 反思与评价 一直没有考虑到判断( N - 1 - i &gt; i ) 计算MN的时候想的太简单","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1050-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1055","text":"题目 拍集体照时队形很重要，这里对给定的 N 个人 K 排的队形设计排队规则如下： 每排人数为 N/K（向下取整），多出来的人全部站在最后一排； 后排所有人的个子都不比前排任何人矮； 每排中最高者站中间（中间位置为 m/2+1，其中 m 为该排人数，除法向下取整）； 每排其他人以中间人为轴，按身高非增序，先右后左交替入队站在中间人的两侧（例如5人身高为190、188、186、175、170，则队形为175、188、190、186、170。这里假设你面对拍照者，所以你的左边是中间人的右边）； 若多人身高相同，则按名字的字典序升序排列。这里保证无重名。 现给定一组拍照人，请编写程序输出他们的队形。 输入格式： 每个输入包含 1 个测试用例。每个测试用例第 1 行给出两个正整数 N（≤104，总人数）和 K（≤10，总排数）。随后 N 行，每行给出一个人的名字（不包含空格、长度不超过 8 个英文字母）和身高（[30, 300] 区间内的整数）。 输出格式： 输出拍照的队形。即K排人名，其间以空格分隔，行末不得有多余空格。注意：假设你面对拍照者，后排的人输出在上方，前排输出在下方。 输入样例：123456789101110 3Tom 188Mike 170Eva 168Tim 160Joe 190Ann 168Bob 175Nick 186Amy 160John 159 输出样例：123Bob Tom Joe NickAnn Mike EvaTim Amy John 通过代码1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct data { string name; int hight; };bool cmp(data&amp; a, data&amp; b) { if (a.hight != b.hight) return a.hight &gt; b.hight; else return a.name &lt; b.name;}int main () { int n, k; cin &gt;&gt; n &gt;&gt; k; int cmin = n / k; int cmax = n % k + cmin; data arr[k][cmax], in[n]; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; in[i].name &gt;&gt; in[i].hight; } sort(in, in + n, cmp); int i = 0, c = cmax; for (int K = 0; K &lt; k; K++) { arr[K][c / 2] = in[i++]; for (int j = 0; j &lt; c / 2; j++) { if (c / 2 - j - 1 &gt;= 0) arr[K][c / 2 - j - 1] = in[i++]; if (c / 2 + j + 1 &lt; c) arr[K][c / 2 + j + 1] = in[i++]; } c = cmin; } c = cmax; for (int i = 0; i &lt; k; i++) { cout &lt;&lt; arr[i][0].name; for (int j = 1; j &lt; c; j++) cout &lt;&lt; &quot; &quot; &lt;&lt; arr[i][j].name; cout &lt;&lt; endl; c = cmin; }} 思路与注意 输入，排序（按身高降序，身高一样按名字的ASCII值升序） 计算每排人数cmin，最后一排人数cmax。然后往里面存。 存和输出时，最后一排和其他排人数不一样，所以令列数c = cmax，每次循环完令c = cmin 由于把最后一排和其他排都统一起来考虑，所以每次存的时候要判断下标有没有越界 反思与评价 开心，题目越做越顺手","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1055-%E9%9B%86%E4%BD%93%E7%85%A7(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1058","text":"题目 批改多选题是比较麻烦的事情，本题就请你写个程序帮助老师批改多选题，并且指出哪道题错的人最多。 输入格式： 输入在第一行给出两个正整数 N（≤ 1000）和 M（≤ 100），分别是学生人数和多选题的个数。随后 M 行，每行顺次给出一道题的满分值（不超过 5 的正整数）、选项个数（不少于 2 且不超过 5 的正整数）、正确选项个数（不超过选项个数的正整数）、所有正确选项。注意每题的选项从小写英文字母 a 开始顺次排列。各项间以 1 个空格分隔。最后 N 行，每行给出一个学生的答题情况，其每题答案格式为 (选中的选项个数 选项1 ……)，按题目顺序给出。注意：题目保证学生的答题情况是合法的，即不存在选中的选项数超过实际选项数的情况。 输出格式： 按照输入的顺序给出每个学生的得分，每个分数占一行。注意判题时只有选择全部正确才能得到该题的分数。最后一行输出错得最多的题目的错误次数和编号（题目按照输入的顺序从 1 开始编号）。如果有并列，则按编号递增顺序输出。数字间用空格分隔，行首尾不得有多余空格。如果所有题目都没有人错，则在最后一行输出 Too simple。 输入样例：3 4 3 4 2 a c 2 5 1 b 5 3 2 b c 1 5 4 a b d e (2 a c) (2 b d) (2 a c) (3 a b e) (2 a c) (1 b) (2 a b) (4 a b d e) (2 b d) (1 e) (2 b c) (4 a b c d) 输出样例：3 6 5 2 2 3 4 通过代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Option { public: int score; int optionNum; int corOptionNum; int FalseNum; int num; vector&lt;char&gt; correctOption; Option() { score = 0; optionNum = 0; corOptionNum = 0; FalseNum = 0; num = 0; } Option(Option &amp;other) { score = other.score; optionNum = other.optionNum; corOptionNum = other.corOptionNum; correctOption = other.correctOption; } friend istream &amp;operator&gt;&gt;(istream &amp;file, Option &amp;object);};istream &amp;operator&gt;&gt;(istream &amp;file, Option &amp;object) { file &gt;&gt; object.score &gt;&gt; object.optionNum &gt;&gt; object.corOptionNum; for (int i = 0; i &lt; object.corOptionNum; i++) { file.ignore(); char temp; file &gt;&gt; temp; object.correctOption.push_back(temp); } return file;}class choose { public: int num; vector&lt;char&gt; option; friend istream &amp;operator&gt;&gt;(istream &amp;file, choose &amp;object); friend ostream &amp;operator&lt;&lt;(ostream &amp;file, choose &amp;object); void clear() { option.clear(); num = 0; }};istream &amp;operator&gt;&gt;(istream &amp;file, choose &amp;object) { char x; cin &gt;&gt; x; file &gt;&gt; object.num; for (int i = 0; i &lt; object.num; i++) { file.ignore(); char temp; file &gt;&gt; temp; object.option.push_back(temp); } file.ignore(); return file;}class Stu { public: vector&lt;choose&gt; cho; int score; Stu() { score = 0; } Stu(Stu &amp;other) { cho = other.cho; score = other.score; }};int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; Stu student[n]; Option op[m]; choose choTemp; bool hasFalse = false; for (int i = 0; i &lt; m; i++) { cin &gt;&gt; op[i]; op[i].num = i + 1; } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { choTemp.clear(); cin &gt;&gt; choTemp; cin.ignore(); student[i].cho.push_back(choTemp); } for (int j = 0; j &lt; m; j++) { if (student[i].cho[j].option == op[j].correctOption) { student[i].score += op[j].score; } else { hasFalse = true; op[j].FalseNum++; } } } for (int i = 0; i &lt; n; i++) { cout &lt;&lt; student[i].score &lt;&lt; endl; } if (hasFalse) { int max = op[0].FalseNum; for (int i = 0; i &lt; m; i++) { if (max &lt; op[i].FalseNum) { max = op[i].FalseNum; } } cout &lt;&lt; max; for (int i = 0; i &lt; m; i++) { if (op[i].FalseNum == max) { cout &lt;&lt; ' ' &lt;&lt; op[i].num; } } cout &lt;&lt; endl; } else { cout &lt;&lt; &quot;Too simple&quot; &lt;&lt; endl; } return 0;} 思路与注意 利用\b类来储存信息，注意构造函数里初始化变量。 注意输入字符类型时，利用ignore()等函数跳过空白符\b 最后一行的输出是最大值 最大值的序号列表，不是最大值+序号+最大值+序号。在这里被坑住了。 输入choose类的时候用了一个choTemp输入，choose类内部采用了vector，那么每次输入完成要清空一次。 反思与评价\b这道题其实不用写这么多类，运算符重载，构造函数什么的，代码可以\b更加精简。但是这样写的好处有： 数据处理方便，不会导致main函数里面定义过多变量导致代码可读性变差。 main函数更加简洁，可以把\b思路放在\b逻辑算法上而不是数据的处理上，就像\b我们使用vector，set，map等模板时，并不需要知道其内部如何实现，使得编码效率提高。","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1058-%E9%80%89%E6%8B%A9%E9%A2%98(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1054","text":"题目 本题的基本要求非常简单：给定 N 个实数，计算它们的平均值。但复杂的是有些输入数据可能是非法的。一个“合法”的输入是 [−1000,1000] 区间内的实数，并且最多精确到小数点后 2 位。当你计算平均值的时候，不能把那些非法的数据算在内。 输入格式： 输入第一行给出正整数 N（≤100）。随后一行给出 N 个实数，数字间以一个空格分隔。 输出格式： 对每个非法输入，在一行中输出 ERROR: X is not a legal number，其中 X 是输入。最后在一行中输出结果：The average of K numbers is Y，其中 K 是合法输入的个数，Y 是它们的平均值，精确到小数点后 2 位。如果平均值无法计算，则用 Undefined 替换 Y。如果 K 为 1，则输出 The average of 1 number is Y。 输入样例 1：1275 -3.2 aaa 9999 2.3.4 7.123 2.35 输出样例 1：12345ERROR: aaa is not a legal numberERROR: 9999 is not a legal numberERROR: 2.3.4 is not a legal numberERROR: 7.123 is not a legal numberThe average of 3 numbers is 1.38 输入样例 2：122aaa -9999 输出样例 2：123ERROR: aaa is not a legal numberERROR: -9999 is not a legal numberThe average of 0 numbers is Undefined 通过代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;iomanip&gt;using namespace std;bool check(string t, double* x) { int dot = -1; int dotNum = 0; bool ok = true; int i = 0; if (t[i] == '-')i++; for ( ; i &lt; t.length(); i++) { if (!(t[i] &gt;= '0' &amp;&amp; t[i] &lt;= '9')) { if (t[i] == '.') { dotNum++; if (dotNum == 1) dot = i; } else { ok = false; break; } } } if (dotNum &gt; 1) ok = false; if (dot != -1 &amp;&amp; t.length() - dot - 1 &gt; 2)ok = false; if (ok) { *x = atof(t.data()); if (fabs(*x) &gt; 1000) ok = false; } return ok;}int main() { int n; cin &gt;&gt; n; int count = 0; double sum = 0; string str; for (int j = 0; j &lt; n; j++) { double StrToNum = 0; cin &gt;&gt; str; if (check(str, &amp;StrToNum)) { sum += StrToNum; count++; } else { cout &lt;&lt; &quot;ERROR: &quot; &lt;&lt; str &lt;&lt; &quot; is not a legal number&quot; &lt;&lt; endl; } } if (count == 1) { cout &lt;&lt; &quot;The average of &quot; &lt;&lt; count &lt;&lt; &quot; number is &quot; &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; sum / count &lt;&lt; endl; } else if (count == 0) { cout &lt;&lt; &quot;The average of 0 numbers is Undefined&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;The average of &quot; &lt;&lt; count &lt;&lt; &quot; numbers is &quot; &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; sum / count &lt;&lt; endl; }} 思路与注意 判断输入是否符合题目要求 利用成员函数data()把string转为char*， 再利用atof()转化为实数 统计并计算 反思与评价 没有考虑没有小数点的时候，不用计算小数点位数，一直错。","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1054-%E6%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1060","text":"题目 英国天文学家爱丁顿很喜欢骑车。据说他为了炫耀自己的骑车功力，还定义了一个“爱丁顿数” E ，即满足有 E 天骑车超过 E 英里的最大整数 E。据说爱丁顿自己的 E 等于87。 现给定某人 N 天的骑车距离，请你算出对应的爱丁顿数 E（≤N）。 输入格式： 输入第一行给出一个正整数 N (≤105)，即连续骑车的天数；第二行给出 N 个非负整数，代表每天的骑车距离。 输出格式： 在一行中给出 N 天的爱丁顿数。 输入样例：12106 7 6 9 3 10 8 2 7 8 输出样例：16 通过代码12345678910111213141516171819#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int num[1001000];int main() { int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; num[i]; } sort(num, num + n, greater&lt;int&gt;()); for (int i = 0; i &lt; n; i++) { if (i + 1 &gt;= num[i] - 1) { cout &lt;&lt; num[i] - 1 &lt;&lt; endl; break; } } return 0;} 思路与注意 不能两层循环求出所有值再倒叙找满足的值，会超时 先排序，对于输入样例有： 110 9 8 8 7 7 6 6 3 2 通过观察可知 第1个数代表有1天超过(10-1) 第2个数代表有2天超过(9-1) 第3个数代表有3天超过(8-1) 第4个数代表有4天超过(8-1) 第5个数代表有5天超过(7-1) 第6个数代表有6天超过(7-1) 所以答案为6 根据以上方法模拟即可 反思与评价 这题挺好","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1060-%E7%88%B1%E4%B8%81%E9%A1%BF%E6%95%B0(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1034","text":"题目 本题要求编写程序，计算 2 个有理数的和、差、积、商。 输入格式： 输入在一行中按照 a1/b1 a2/b2 的格式给出两个分数形式的有理数，其中分子和分母全是整型范围内的整数，负号只可能出现在分子前，分母不为 0。 输出格式： 分别在 4 行中按照 有理数1 运算符 有理数2 = 结果 的格式顺序输出 2 个有理数的和、差、积、商。注意输出的每个有理数必须是该有理数的最简形式 k a/b，其中 k 是整数部分，a/b 是最简分数部分；若为负数，则须加括号；若除法分母为 0，则输出 Inf。题目保证正确的输出中没有超过整型范围的整数。 输入样例 1：2/3 -4/2 输出样例 1：2/3 + (-2) = (-1 1/3) 2/3 - (-2) = 2 2/3 2/3 * (-2) = (-1 1/3) 2/3 / (-2) = (-1/3) 输入样例 2：5/3 0/6 输出样例 2：1 2/3 + 0 = 1 2/3 1 2/3 - 0 = 1 2/3 1 2/3 * 0 = 0 1 2/3 / 0 = Inf 通过代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;string toString (ll a) { string ans; while (a) { ans.append(1,(char)(a%10 + '0')); a/=10; } reverse(ans.begin(), ans.end()); return ans;}class Main {private: ll ans1,ans2, pos;public: Main(ll a, ll b) { pos = 1; ans1 = a; ans2 = b; if (a &lt; 0) { ans1 *= -1; pos*=-1; } if (b &lt; 0) { ans2 *= -1; pos*=-1; } } Main(Main&amp; ob) { ans1 = ob.ans1; ans2 = ob.ans2; pos = ob.pos; } void set(ll a, ll b) { pos = 1; ans1 = a; ans2 = b; if (a &lt; 0) { ans1 *= -1; pos*=-1; } if (b &lt; 0) { ans2 *= -1; pos*=-1; } } string toString() { string ans; if (ans1 == 0 &amp;&amp; ans2 != 0) { ans.append(&quot;0&quot;); return ans; } if (ans2 == 0) { ans.append(&quot;Inf&quot;); return ans; } getSmall(); if (pos == -1) { ans.append(&quot;(-&quot;); } if (ans2 != 1) { if (ans1 &lt; ans2) { ans.append(::toString(ans1)); ans.append(&quot;/&quot;); ans.append(::toString(ans2)); } else if (ans1 == ans2) { ans.append(&quot;1&quot;); } else { ll y = ans1 / ans2; ll ta1 = ans1; ta1 -= y * ans2; ans.append(::toString(y)); ans.append(&quot; &quot;); ans.append(::toString(ta1)); ans.append(&quot;/&quot;); ans.append(::toString(ans2)); } } else { ans.append(::toString(ans1)); } if (pos == -1) { ans.append(&quot;)&quot;); } return ans; } void getSmall() { ll ta = ans1, tb = ans2; while (tb != 0) { ll temp = ta % tb; ta = tb; tb = temp; } ans1 /= ta; ans2 /= ta; } static void add(Main* a, Main* b, Main* ans) { ll ans1 = a-&gt;ans1 * b-&gt;ans2 * a-&gt;pos + a-&gt;ans2 * b-&gt;ans1 * b-&gt;pos; ll ans2 = a-&gt;ans2 * b-&gt;ans2; ans-&gt;set(ans1, ans2); } static void sub(Main* a, Main* b, Main* ans) { ll ans1 = a-&gt;ans1 * b-&gt;ans2*a-&gt;pos - a-&gt;ans2 * b-&gt;ans1*b-&gt;pos; ll ans2 = a-&gt;ans2 * b-&gt;ans2; ans-&gt;set(ans1, ans2); } static void mul(Main* a, Main* b, Main* ans) { ll ans1 = a-&gt;pos * b-&gt;pos * a-&gt;ans1 * b-&gt;ans1; ll ans2 = a-&gt;ans2 * b-&gt;ans2; ans-&gt;set(ans1, ans2); } static void dev(Main* a, Main* b, Main* ans) { ll ans1 = a-&gt;pos * b-&gt;pos * a-&gt;ans1 * b-&gt;ans2; ll ans2 = a-&gt;ans2 * b-&gt;ans1; ans-&gt;set(ans1, ans2); }};int main() { ll a1,a2,b1,b2; scanf(&quot;%lld/%lld %lld/%lld&quot;, &amp;a1, &amp;a2, &amp;b1, &amp;b2); Main x(a1, a2); Main y(b1, b2); Main ans(0,0); Main::add(&amp;x, &amp;y, &amp;ans); cout &lt;&lt; x.toString() &lt;&lt; &quot; + &quot; &lt;&lt; y.toString() &lt;&lt; &quot; = &quot; &lt;&lt; ans.toString() &lt;&lt; endl; Main::sub(&amp;x, &amp;y, &amp;ans); cout &lt;&lt; x.toString() &lt;&lt; &quot; - &quot; &lt;&lt; y.toString() &lt;&lt; &quot; = &quot; &lt;&lt; ans.toString() &lt;&lt; endl; Main::mul(&amp;x, &amp;y, &amp;ans); cout &lt;&lt; x.toString() &lt;&lt; &quot; * &quot; &lt;&lt; y.toString() &lt;&lt; &quot; = &quot; &lt;&lt; ans.toString() &lt;&lt; endl; Main::dev(&amp;x, &amp;y, &amp;ans); cout &lt;&lt; x.toString() &lt;&lt; &quot; / &quot; &lt;&lt; y.toString() &lt;&lt; &quot; = &quot; &lt;&lt; ans.toString() &lt;&lt; endl; return 0;} 思路与注意 写一个对分数的处理类，分别记录分子，分母和符号 计算什么的直接算，等最后要输出之前求一下最大公倍数约分一下就好了，（原谅我不会约分的英文，只好写成getSmall了，hhh） 这道题题目上说输入和结构都在int范围，但是不保证中间过程也在int范围，所以要用long 注意第二个数为0时的要特判 反思与评价 这次把Java移植成C++，把以下问题都解决了，个人认为这题大概就是给C++设计的吧？12&gt;* 处理加和减的函数有点臃肿\b，有待提高&gt;* 这个代码在超时的边缘疯狂试探，有时候能全部通过，有时候会运行超时。好神奇，而且越压行，越超时。 在移植的时候，构造函数写成只有参数为负才会赋值，一直算不出来，折腾很久，以后移植的时候要小心。 移植过程中有很多内存泄漏的问题，后来也都改了。Java根本不用考虑内存的问题，以后移植的时候这一点也要注意。","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1034-%E6%9C%89%E7%90%86%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1059","text":"题目 C 语言竞赛是浙江大学计算机学院主持的一个欢乐的竞赛。既然竞赛主旨是为了好玩，颁奖规则也就制定得很滑稽： 0、冠军将赢得一份“神秘大奖”（比如很巨大的一本学生研究论文集……）。 1、排名为素数的学生将赢得最好的奖品 —— 小黄人玩偶！ 2、其他人将得到巧克力。 给定比赛的最终排名以及一系列参赛者的 ID，你要给出这些参赛者应该获得的奖品。 输入格式： 输入第一行给出一个正整数 N（≤104），是参赛者人数。随后 N 行给出最终排名，每行按排名顺序给出一位参赛者的 ID（4 位数字组成）。接下来给出一个正整数 K 以及 K 个需要查询的 ID。 输出格式： 对每个要查询的 ID，在一行中输出 ID: 奖品，其中奖品或者是 Mystery Award（神秘大奖）、或者是 Minion（小黄人）、或者是 Chocolate（巧克力）。如果所查 ID 根本不在排名里，打印 Are you kidding?（耍我呢？）。如果该 ID 已经查过了（即奖品已经领过了），打印 ID: Checked（不能多吃多占）。 输入样例：123456789101112131461111666688881234555500016888800011111222288882222 输出样例：1234568888: Minion0001: Chocolate1111: Mystery Award2222: Are you kidding?8888: Checked2222: Are you kidding? 通过代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;int prime[10005] = {0, 1, 2, 2, 3};void get_prime() { for (int i = 5; i &lt; 10005; i++) { prime[i] = 2; for (int j = 2; j * j &lt;= i; j++) { if (i % j == 0) { prime[i] = 3; break; } } }}int main() { get_prime(); int rank[10005] = {0}; string str[4] = {&quot;Are you kidding?&quot;, &quot;Mystery Award&quot;, &quot;Minion&quot;, &quot;Chocolate&quot;}; string checked = &quot;Checked&quot;; int has[10005] = {0}; int n, id; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; id; rank[id] = i + 1; } cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; id; int RANK = rank[id], HAS = has[id]; if (!HAS || RANK == 0) { printf (&quot;%04d: %s\\n&quot;, id, str[prime[RANK]].data()); has[id] = 1; } else { printf (&quot;%04d: %s\\n&quot;, id, checked.data()); } } return 0;} 思路与注意 先把需要输出的字符串存起来，分别为0，1，2，3 根据题意，搞一个数组，如果是0，1，则值为0，1，其他数如果是素数为2（对应million），不是素数为3，对应chocolate 再搞一个数组，以编号为引索，记录排名 搞一个has数组，记录是否输出过 反思与评价 这道题挺简单的 通过打表记录是否为素数，可以减少计算次数","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1059-C%E8%AF%AD%E8%A8%80%E7%AB%9E%E8%B5%9B(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1065","text":"题目 “单身狗”是中文对于单身人士的一种爱称。本题请你从上万人的大型派对中找出落单的客人，以便给予特殊关爱。 输入格式： 输入第一行给出一个正整数 N（≤ 50 000），是已知夫妻/伴侣的对数；随后 N 行，每行给出一对夫妻/伴侣——为方便起见，每人对应一个 ID 号，为 5 位数字（从 00000 到 99999），ID 间以空格分隔；之后给出一个正整数 M（≤ 10 000），为参加派对的总人数；随后一行给出这 M 位客人的 ID，以空格分隔。题目保证无人重婚或脚踩两条船。 输出格式： 首先第一行输出落单客人的总人数；随后第二行按 ID 递增顺序列出落单的客人。ID 间用 1 个空格分隔，行的首尾不得有多余空格。 输入样例：123456311111 2222233333 4444455555 66666755555 44444 10000 88888 22222 11111 23333 输出样例：12510000 23333 44444 55555 88888 通过代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;using namespace std;struct people { int id; bool pair;} c[10100];bool cmp (people&amp;a, people&amp; b) { return a.id &lt; b.id;}int p[100100], x, y, n, num;int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; x &gt;&gt; y; p[x] = y; p[y] = x; } cin &gt;&gt; num; for (int i = 0; i &lt; num; i++) { cin &gt;&gt; c[i].id; c[i].pair = false; } int count = 0; for (int i = 0; i &lt; num; i++) { for (int j = 0; j &lt; num; j++) { if (p[c[i].id] == c[j].id) { c[i].pair = true; count++; } } } cout &lt;&lt; num - count &lt;&lt; endl; sort(c, c + num, cmp); int i = 0; while (c[i++].pair &amp;&amp; i &lt;= num); if (i &lt;= num)//这里是i&lt;=num cout &lt;&lt; setw(5) &lt;&lt; setfill('0') &lt;&lt; c[i - 1].id; //注意这里是i-1 for (; i &lt; num; i++) { if (!c[i].pair) { cout &lt;&lt; &quot; &quot; &lt;&lt; setw(5) &lt;&lt; setfill('0') &lt;&lt; c[i].id; } }} 思路与注意 因为给的数很小，所以可以列一个表格，把两个id一个作为值，一个作为引索 两层for循环，第一层固定要判断的对象，第二次逐个遍历其他人，比较id 输出，注意要五位数输出，不足前面补0 反思与评价 最后输出的条件是i&lt;=num 不是 i&lt;num, 因为我把i++写在了while的括号里面 输出第一个的时候下标要i-1,因为我把i++写在了while的括号里面","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1065-%E5%8D%95%E8%BA%AB%E7%8B%97(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1062","text":"题目 一个分数一般写成两个整数相除的形式：N/M，其中 M 不为0。最简分数是指分子和分母没有公约数的分数表示形式。 现给定两个不相等的正分数 N1/M1 和 N2/M2，要求你按从小到大的顺序列出它们之间分母为 K 的最简分数。 输入格式： 输入在一行中按 N/M 的格式给出两个正分数，随后是一个正整数分母 K，其间以空格分隔。题目保证给出的所有整数都不超过 1000。 输出格式： 在一行中按 N/M 的格式列出两个给定分数之间分母为 K 的所有最简分数，按从小到大的顺序，其间以 1 个空格分隔。行首尾不得有多余空格。题目保证至少有 1 个输出。 输入样例：17/18 13/20 12 输出样例：15/12 7/12 通过代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;typedef long long ll;class Main {private: ll ans1, ans2, pos;public: Main(ll a, ll b) { set(a, b); } void set(ll a, ll b) { pos = 1; ans1 = a; ans2 = b; if (a &lt; 0) { ans1 *= -1; pos *= -1; } if (b &lt; 0) { ans2 *= -1; pos *= -1; } } void getSmall() { ll ta = ans1, tb = ans2; while (tb != 0) { ll temp = ta % tb; ta = tb; tb = temp; } ans1 /= ta; ans2 /= ta; } static void swap(Main&amp; a, Main&amp; b) {Main temp = a; a = b; b = temp; } static void add(Main* a, Main* b, Main* ans) { ll ans1 = a-&gt;ans1 * b-&gt;ans2 * a-&gt;pos + a-&gt;ans2 * b-&gt;ans1 * b-&gt;pos; ll ans2 = a-&gt;ans2 * b-&gt;ans2; ans-&gt;set(ans1, ans2); ans-&gt;getSmall(); } double toDouble() { return 1.0 * pos * ans1 / ans2; } ll getSon() { return ans1; } ll getMother() { return ans2; }};int main() { ll a1, a2, b1, b2, n; scanf(&quot;%lld/%lld %lld/%lld %lld&quot;, &amp;a1, &amp;a2, &amp;b1, &amp;b2, &amp;n); Main x(a1, a2), y(b1, b2), ans(1, n), one(1, n); if (x.toDouble() &gt; y.toDouble()) Main::swap(x, y); int count = 0; while (1) { if (ans.toDouble() &gt; x.toDouble() &amp;&amp; ans.toDouble() &lt; y.toDouble()) { if (ans.getMother() == n) { if (count++ == 0) cout &lt;&lt; ans.getSon() &lt;&lt; &quot;/&quot; &lt;&lt; n; else cout &lt;&lt; &quot; &quot; &lt;&lt; ans.getSon() &lt;&lt; &quot;/&quot; &lt;&lt; n; } } else if (ans.toDouble() &gt; y.toDouble()) { break; } Main::add(&amp;ans, &amp;one, &amp;ans); } return 0;} 思路与注意 copy并精简上一次写的分数处理类（传送门PAT乙级题–1034 有理数四则运算）1. 添加了转换成double（toDouble()）函数2. 得到分子分母（getSon(), getMother()）函数 3. 交换值的（swap()）函数。4. 输入后，保证x&lt;=y 得到K(我的代码中的n)，构造两个分数1/n，然后循环相加 如果数在前两个数之间（注意为开区间，不包括区间的端点），并且分母为n(每次运算后就约分一次，只挑约分后分母还是n的)，则按照要求输出。 反思与评价 代码积累很重要","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1062-%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1052","text":"题目萌萌哒表情符号通常由“手”、“眼”、“口”三个主要部分组成。简单起见，我们假设一个表情符号是按下列格式输出的： 1[左手]([左眼][口][右眼])[右手] 现给出可选用的符号集合，请你按用户的要求输出表情。 输入格式：输入首先在前三行顺序对应给出手、眼、口的可选符号集。每个符号括在一对方括号 []内。题目保证每个集合都至少有一个符号，并不超过 10 个符号；每个符号包含 1 到 4 个非空字符。 之后一行给出一个正整数 K，为用户请求的个数。随后 K 行，每行给出一个用户的符号选择，顺序为左手、左眼、口、右眼、右手——这里只给出符号在相应集合中的序号（从 1 开始），数字间以空格分隔。 输出格式：对每个用户请求，在一行中输出生成的表情。若用户选择的序号不存在，则输出 Are you kidding me? @\\/@。 输入样例：12345678[╮][╭][o][~\\][/~] [&lt;][&gt;] [╯][╰][^][-][=][&gt;][&lt;][@][⊙][Д][▽][_][ε][^] ...41 1 2 2 26 8 1 5 53 3 4 3 32 10 3 9 3 输出样例：1234╮(╯▽╰)╭&lt;(@Д=)/~o(^ε^)oAre you kidding me? @\\/@ 通过代码123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main () { vector&lt;string&gt; data[3]; string line; for (int j = 0; j &lt; 3; j++) { getline(cin, line); for (int i = 0, k = 0, count = 0; i &lt; line.length(); count++) { while ( i &lt; line.length() &amp;&amp; line[i] != '[')i++; while ( k &lt; line.length() &amp;&amp; line[k] != ']')k++; if (i &lt; line.length() &amp;&amp; k &lt; line.length()) { data[j].push_back(line.substr(i + 1, k - 1 - i)); k++; i = k; } else { break; } } } int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { int a[5]; for (int j = 0; j &lt; 5; j++) { cin &gt;&gt; a[j]; a[j]--; } if (a[0] &lt; data[0].size() &amp;&amp; a[1] &lt; data[1].size() &amp;&amp; a[2] &lt; data[2].size() &amp;&amp; a[3] &lt; data[1].size() &amp;&amp; a[4] &lt; data[0].size()) cout &lt;&lt; data[0][a[0]] &lt;&lt; &quot;(&quot; &lt;&lt; data[1][a[1]] &lt;&lt; data[2][a[2]] &lt;&lt; data[1][a[3]] &lt;&lt; &quot;)&quot; &lt;&lt; data[0][a[4]] &lt;&lt; endl; else printf(&quot;Are you kidding me? @\\\\/@\\n&quot;); }} 思路与注意 这道题其实就是分析字符串，把所有[]内的字符串全都存起来，然后用户输入序号，根据序号按照条件输出就可以了 注意[]内不一定只有一个字符，而且可能是宽字符（直接保存成string就行） 注意用户输入的序号是从1开始的 注意输出格式（左手右边、右手左边有半角括号） 1[左手]([左眼][口][右眼])[右手] 反思与评价 这道题思路很清晰，利用vector会很方便 写题的时候一直认为substr()函数的两个参数都是index，一直出错（手动笑哭）","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1052-%E5%8D%96%E4%B8%AA%E8%90%8C(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1067","text":"题目 当你试图登录某个系统却忘了密码时，系统一般只会允许你尝试有限多次，当超出允许次数时，账号就会被锁死。本题就请你实现这个小功能。 输入格式： 输入在第一行给出一个密码（长度不超过 20 的、不包含空格、Tab、回车的非空字符串）和一个正整数 N（≤ 10），分别是正确的密码和系统允许尝试的次数。随后每行给出一个以回车结束的非空字符串，是用户尝试输入的密码。输入保证至少有一次尝试。当读到一行只有单个 # 字符时，输入结束，并且这一行不是用户的输入。 输出格式： 对用户的每个输入，如果是正确的密码且尝试次数不超过 N，则在一行中输出 Welcome in，并结束程序；如果是错误的，则在一行中按格式输出 Wrong password: 用户输入的错误密码；当错误尝试达到 N 次时，再输出一行 Account locked，并结束程序。 输入样例 1：123456Correct%pw 3correct%pwCorrect@PWwhatisthepassword!Correct%pw# 输出样例 1：1234Wrong password: correct%pwWrong password: Correct@PWWrong password: whatisthepassword!Account locked 输入样例 2：123456cool@gplt 3coolman@gpltcoollady@gpltcool@gplttry again# 输出样例 2：123Wrong password: coolman@gpltWrong password: coollady@gpltWelcome in 通过代码123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main () { string corPwd; string pwd; int time; cin &gt;&gt; corPwd &gt;&gt; time; int i; getline(cin, pwd); for (i = 0; i &lt; time; i++) { getline(cin, pwd); if (pwd == corPwd) {cout &lt;&lt; &quot;Welcome in&quot; &lt;&lt; endl; break;} else if (pwd == &quot;#&quot;) {break;} else {cout &lt;&lt; &quot;Wrong password: &quot; &lt;&lt; pwd &lt;&lt; endl;} } if (i == time) cout &lt;&lt; &quot;Account locked&quot; &lt;&lt; endl; return 0;} 思路与注意 按照要求，输入，判断，输出结果 注意第一次输入用了cin的提取运算符&gt;&gt;，后面用了getline()函数，注意吃掉第一行输入剩下的换行符。 反思与评价 简单","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1067-%E8%AF%95%E5%AF%86%E7%A0%81(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1072","text":"题目 下图是上海某校的新学期开学寄语：天将降大任于斯人也，必先删其微博，卸其 QQ，封其电脑，夺其手机，收其 ipad，断其 wifi，使其百无聊赖，然后，净面、理发、整衣，然后思过、读书、锻炼、明智、开悟、精进。而后必成大器也！本题要求你写个程序帮助这所学校的老师检查所有学生的物品，以助其成大器。 输入格式： 输入第一行给出两个正整数 N（≤ 1000）和 M（≤ 6），分别是学生人数和需要被查缴的物品种类数。第二行给出 M 个需要被查缴的物品编号，其中编号为 4 位数字。随后 N 行，每行给出一位学生的姓名缩写（由 1-4 个大写英文字母组成）、个人物品数量 K（0 ≤ K ≤ 10）、以及 K 个物品的编号。 输出格式： 顺次检查每个学生携带的物品，如果有需要被查缴的物品存在，则按以下格式输出该生的信息和其需要被查缴的物品的信息（注意行末不得有多余空格）： 1姓名缩写: 物品编号1 物品编号2 …… 最后一行输出存在问题的学生的总人数和被查缴物品的总数。 输入样例：1234564 22333 6666CYLL 3 1234 2345 3456U 4 9966 6666 8888 6666GG 2 2333 7777JJ 3 0012 6666 2333 输出样例：1234U: 6666 6666GG: 2333JJ: 6666 23333 5 通过代码12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int main () { int n, m, stu = 0, item = 0; cin &gt;&gt; n &gt;&gt; m; string ob[n]; for (int i = 0; i &lt; m; i++) cin &gt;&gt; ob[i]; for (int i = 0; i &lt; n; i++) { string name, object; int num, count = 0; cin &gt;&gt; name &gt;&gt; num; for (int j = 0; j &lt; num; j++) { cin &gt;&gt; object; for (int k = 0; k &lt; m; k++) { if (object == ob[k]) { if (count++ == 0) cout &lt;&lt; name &lt;&lt; &quot;:&quot;; cout &lt;&lt; &quot; &quot; &lt;&lt; object; break; } } } item += count; stu += count &gt; 0 ? 1 : 0; if (count) cout &lt;&lt; endl; } cout &lt;&lt; stu &lt;&lt; &quot; &quot; &lt;&lt; item &lt;&lt; endl; return 0;}","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1072-%E5%BC%80%E5%AD%A6%E5%AF%84%E8%AF%AD(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1073","text":"题目 批改多选题是比较麻烦的事情，有很多不同的计分方法。有一种最常见的计分方法是：如果考生选择了部分正确选项，并且没有选择任何错误选项，则得到 50% 分数；如果考生选择了任何一个错误的选项，则不能得分。本题就请你写个程序帮助老师批改多选题，并且指出哪道题的哪个选项错的人最多。 输入格式： 输入在第一行给出两个正整数 N（≤1000）和 M（≤100），分别是学生人数和多选题的个数。随后 M 行，每行顺次给出一道题的满分值（不超过 5 的正整数）、选项个数（不少于 2 且不超过 5 的正整数）、正确选项个数（不超过选项个数的正整数）、所有正确选项。注意每题的选项从小写英文字母 a 开始顺次排列。各项间以 1 个空格分隔。最后 N 行，每行给出一个学生的答题情况，其每题答案格式为 (选中的选项个数 选项1 ……)，按题目顺序给出。注意：题目保证学生的答题情况是合法的，即不存在选中的选项数超过实际选项数的情况。 输出格式： 按照输入的顺序给出每个学生的得分，每个分数占一行，输出小数点后 1 位。最后输出错得最多的题目选项的信息，格式为：错误次数 题目编号（题目按照输入的顺序从1开始编号）-选项号。如果有并列，则每行一个选项，按题目编号递增顺序输出；再并列则按选项号递增顺序输出。行首尾不得有多余空格。如果所有题目都没有人错，则在最后一行输出 Too simple。 输入样例 1：123456783 4 3 4 2 a c2 5 1 b5 3 2 b c1 5 4 a b d e(2 a c) (3 b d e) (2 a c) (3 a b e)(2 a c) (1 b) (2 a b) (4 a b d e)(2 b d) (1 e) (1 c) (4 a b c d) 输出样例 1：1234563.56.02.52 2-e2 3-a2 3-b 输入样例 2：123452 2 3 4 2 a c2 5 1 b(2 a c) (1 b)(2 a c) (1 b) 输出样例 2：1235.05.0Too simple 通过代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;using namespace std;class Option {//用于统计正确选项的信息public: double score = 0;int optionNum = 0, corOptionNum = 0, num = 0, maxFalseNum = -1, FalseNum[6] = {0}; //正确选项的分数,选项个数,正确选项的个数,题目的编号，从1开始,错误次数的最大值,每一个选项的错误次数 vector&lt;char&gt; correctOption, FalseMostOp;//记录正确选项,记录错误次数最多的选项 int check(vector&lt;char&gt; select) { //0错，1对，2半对 bool want1 = false, want2 = false; for (int i = 0; i &lt; select.size(); i++) {//第一次查找，有没有多选的 bool found = false; for (int j = 0; j &lt; correctOption.size(); j++) { if (correctOption[j] == select[i]) { found = true; break; } } if (!found) { //学生选了，不是正确选项 want1 = true; FalseNum[select[i]-'a']++; } } for (int i = 0; i &lt; correctOption.size(); i++) {//第二次查找，有没有漏选的 bool found = false; for (int j = 0; j &lt; select.size(); j++) { if (correctOption[i] == select[j]) { found = true; break; } } if (!found) { //本身是正确选项，学生没选 want2 = true; FalseNum[correctOption[i]-'a']++; } } if (want1) return 0;//学生的选择有正确选择中没有的，错！ //学生的选择是正确选项的子集 if (want2) return 2;//学生的选择正确选项都有，但是正确选项中有学生没选的，半对！ //正确选项是学生选择的子集 return 1;//两个互为子集，则选择相同，对！ } friend istream &amp;operator&gt;&gt;(istream &amp;file, Option &amp;object); void caculate () {//计算错误次数的最大值，并记录错的多的选项 maxFalseNum = FalseNum[0]; for (int i = 0; i &lt; optionNum; i++) if (FalseNum[i] &gt; maxFalseNum) maxFalseNum = FalseNum[i]; for (int i = 0; i &lt; optionNum; i++) if (FalseNum[i] == maxFalseNum) FalseMostOp.push_back(i + 'a'); } int getAllFalseNum() { return maxFalseNum; }};istream &amp;operator&gt;&gt;(istream &amp;file, Option &amp;object) {//正确选项信息 file &gt;&gt; object.score &gt;&gt; object.optionNum &gt;&gt; object.corOptionNum; for (int i = 0; i &lt; object.corOptionNum; i++) { file.ignore(); char temp; file &gt;&gt; temp; object.correctOption.push_back(temp); } return file;}class choose {//记录某个题学生的选择信息public: int num = 0; vector&lt;char&gt; option; friend istream &amp;operator&gt;&gt;(istream &amp;file, choose &amp;object); void clear() { option.clear(); num = 0; }};istream &amp;operator&gt;&gt;(istream &amp;file, choose &amp;object) {//输入学生的选择 char x; cin &gt;&gt; x; file &gt;&gt; object.num; for (int i = 0; i &lt; object.num; i++) { file.ignore(); char temp; file &gt;&gt; temp; object.option.push_back(temp); } file.ignore(); return file;}struct Stu { vector&lt;choose&gt; cho; double score = 0; };//记录学生选择和得分int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; Stu student[n]; Option op[m]; choose choTemp;//用于暂时储存输入，由于用了vector，每次要clear() for (int i = 0; i &lt; m; i++) { cin &gt;&gt; op[i]; op[i].num = i + 1; } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { choTemp.clear(); cin &gt;&gt; choTemp; cin.ignore(); student[i].cho.push_back(choTemp); }//一个学生的选择输入完成 for (int j = 0; j &lt; m; j++) {//对刚刚输入的这个学生进行判分 int n = op[j].check(student[i].cho[j].option); if (n == 1) student[i].score += op[j].score; else if (n == 2) student[i].score += op[j].score*0.5; } } for (int i = 0; i &lt; n; i++)//输出分数 cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; student[i].score &lt;&lt; endl; for (int i = 0; i &lt; m; i++)//计算错的最多的选项 op[i].caculate(); int max = 0; for (int i = 0; i &lt; m; i++)//查找最大值 if (max &lt; op[i].getAllFalseNum()) max = op[i].getAllFalseNum(); if (max &gt; 0) {//输出 for (int i = 0; i &lt; m; i++) if (op[i].getAllFalseNum() == max) for (int j = 0; j &lt; op[i].FalseMostOp.size(); j++) cout &lt;&lt; max &lt;&lt; ' ' &lt;&lt; op[i].num &lt;&lt; '-' &lt;&lt; op[i].FalseMostOp[j] &lt;&lt; endl; } else { cout &lt;&lt; &quot;Too simple&quot; &lt;&lt; endl; } return 0;} 思路与注意 这道题是题目：PAT乙级题–1058 选择题，的升级版，其中输入一样，只是给分方式变成了：全对给全分，部分对给一半分，有错不得分 判分方式 判分思想：a是b的子集，且b是a的子集，那么a，b两个集合相等 定义一个判分函数，属于Option类，全对返回1，有错返回0，半对返回2。 两次遍历查找，第一遍查找学生的选择中有没有不是正确选项的，如果有，记录这个选项错了一次。第二次查找正确选项中是否存在学生没有选的，如果有记录这个选项错了一次 第一次查找就有错，返回0。（如果没错，说明：学生的选择是正确选项的子集） 如果第二次查找有错而第一次没有，说明学生没选全，返回2。（如果没错，说明：正确选项是学生的子集） 如果两次遍历都没错，说明学生选择就是正确答案，返回1。（说明：两个集合互为子集，两个集合相等） 统计错误选项 定义了一个calculate()函数，用于统计那个题错的最多，最多的选项有哪些 在所有学生的题判完以后，所有选项的错误次数也就统计完整了，这时调用计算一下 注意 不能一边找最大值一边计算，我也不知道为啥，一定要先计算一边错误最多的选项，再找最大值。 反思与评价 这道题其实不用写这么多类，运算符重载，构造函数什么的，代码可以更加精简。但是这样写的好处有： 数据处理方便，不会导致main函数里面定义过多变量导致代码可读性变差。 main函数更加简洁，可以把思路放在逻辑算法上而不是数据的处理上，就像我们使用vector，set，map等模板时，并不需要知道其内部如何实现，使得编码效率提高。 这道题很努力的在压行，如果用Astyle风格format一下的话能有200行","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1073-%E5%A4%9A%E9%80%89%E9%A2%98%E5%B8%B8%E8%A7%81%E8%AE%A1%E5%88%86%E6%B3%95(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1071","text":"题目 常言道“小赌怡情”。这是一个很简单的小游戏：首先由计算机给出第一个整数；然后玩家下注赌第二个整数将会比第一个数大还是小；玩家下注 t 个筹码后，计算机给出第二个数。若玩家猜对了，则系统奖励玩家 t 个筹码；否则扣除玩家 t 个筹码。 注意：玩家下注的筹码数不能超过自己帐户上拥有的筹码数。当玩家输光了全部筹码后，游戏就结束。 输入格式： 输入在第一行给出 2 个正整数 T 和 K（≤ 100），分别是系统在初始状态下赠送给玩家的筹码数、以及需要处理的游戏次数。随后 K 行，每行对应一次游戏，顺序给出 4 个数字： 1n1 b t n2 其中 n1 和 n2 是计算机先后给出的两个[0, 9]内的整数，保证两个数字不相等。b 为 0 表示玩家赌小，为 1 表示玩家赌大。t 表示玩家下注的筹码数，保证在整型范围内。 输出格式： 对每一次游戏，根据下列情况对应输出（其中 t 是玩家下注量，x 是玩家当前持有的筹码量）： 玩家赢，输出 Win t! Total = x.； 玩家输，输出 Lose t. Total = x.； 玩家下注超过持有的筹码量，输出 Not enough tokens. Total = x.； 玩家输光后，输出 Game Over. 并结束程序。 输入样例 1：12345100 48 0 100 23 1 50 15 1 200 67 0 200 8 输出样例 1：1234Win 100! Total = 200.Lose 50. Total = 150.Not enough tokens. Total = 150.Not enough tokens. Total = 150. 输入样例 2：12345100 48 0 100 23 1 200 15 1 200 67 0 200 8 输出样例 2：123Win 100! Total = 200.Lose 200. Total = 0.Game Over. 通过代码12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main () { int T, K; cin &gt;&gt; T &gt;&gt; K; for (int i = 0; i &lt; K; i++) { int n1, b, t, n2; cin &gt;&gt; n1 &gt;&gt; b &gt;&gt; t &gt;&gt; n2; if (T &amp;&amp; t &lt;= T) { if ((n2 &gt; n1) == b) { T += t; cout &lt;&lt; &quot;Win &quot; &lt;&lt; t &lt;&lt; &quot;! Total = &quot; &lt;&lt; T &lt;&lt; &quot;.&quot; &lt;&lt; endl; } else { T -= t; cout &lt;&lt; &quot;Lose &quot; &lt;&lt; t &lt;&lt; &quot;. Total = &quot; &lt;&lt; T &lt;&lt; &quot;.&quot; &lt;&lt; endl; } } else if (T &amp;&amp; t &gt; T) { cout &lt;&lt; &quot;Not enough tokens. Total = &quot; &lt;&lt; T &lt;&lt; &quot;.&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;Game Over.&quot; &lt;&lt; endl; break; } } return 0;} 思路与注意 这道题又坑人了，输出的时候要以输出样例为准，Total与前面的 ! 或 . 直接有两个空格，题干上只有一个。","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1071-%E5%B0%8F%E8%B5%8C%E6%80%A1%E6%83%85(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1074","text":"题目 地球人习惯使用十进制数，并且默认一个数字的每一位都是十进制的。而在 PAT 星人开挂的世界里，每个数字的每一位都是不同进制的，这种神奇的数字称为“PAT数”。每个 PAT 星人都必须熟记各位数字的进制表，例如“……0527”就表示最低位是 7 进制数、第 2 位是 2 进制数、第 3 位是 5 进制数、第 4 位是 10 进制数，等等。每一位的进制 d 或者是 0（表示十进制）、或者是 [2，9] 区间内的整数。理论上这个进制表应该包含无穷多位数字，但从实际应用出发，PAT 星人通常只需要记住前 20 位就够用了，以后各位默认为 10 进制。 在这样的数字系统中，即使是简单的加法运算也变得不简单。例如对应进制表“0527”，该如何计算“6203 + 415”呢？我们得首先计算最低位：3 + 5 = 8；因为最低位是 7 进制的，所以我们得到 1 和 1 个进位。第 2 位是：0 + 1 + 1（进位）= 2；因为此位是 2 进制的，所以我们得到 0 和 1 个进位。第 3 位是：2 + 4 + 1（进位）= 7；因为此位是 5 进制的，所以我们得到 2 和 1 个进位。第 4 位是：6 + 1（进位）= 7；因为此位是 10 进制的，所以我们就得到 7。最后我们得到：6203 + 415 = 7201。 输入格式： 输入首先在第一行给出一个 N 位的进制表（0 &lt; N ≤ 20），以回车结束。 随后两行，每行给出一个不超过 N 位的非负的 PAT 数。 输出格式： 在一行中输出两个 PAT 数之和。 输入样例：1233052706203415 输出样例：17201 通过代码1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main () { string a, b, n, ans; getline(cin, n); getline(cin, a); getline(cin, b); int len = a.length() &gt; b.length() ? a.length() : b.length(); len = len &gt; n.length() ? len : n.length(); a.insert(0, (len - a.length() &gt; 0 ? len - a.length() : 0), '0'); b.insert(0, (len - b.length() &gt; 0 ? len - b.length() : 0), '0'); n.insert(0, (len - n.length() &gt; 0 ? len - n.length() : 0), '0'); int carry = 0; for (int i = len - 1, count = 0; i &gt;= 0; i--, count++) { int c = (a[i] + b[i] - '0' * 2) + carry; carry = c / ((n[i] - '0') == 0 ? 10 : (n[i] - '0')); c %= ((n[i] - '0') == 0 ? 10 : (n[i] - '0')); ans.insert(0, 1, c + '0'); } ans.insert(0, 1, carry + '0'); int i = 0; bool zero = true; while (ans[i] == '0' || ans[i] == 0)i++; for (; i &lt; ans.length(); i++) { cout &lt;&lt; ans[i]; zero = false; } if (zero) cout &lt;&lt; &quot;0&quot; &lt;&lt; endl; return 0;} 注意 注意计算结果为0 注意计算结果可能大于输入的最大长度","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1074-%E5%AE%87%E5%AE%99%E6%97%A0%E6%95%8C%E5%8A%A0%E6%B3%95%E5%99%A8(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1069","text":"题目 小明 PAT 考了满分，高兴之余决定发起微博转发抽奖活动，从转发的网友中按顺序每隔 N 个人就发出一个红包。请你编写程序帮助他确定中奖名单。 输入格式： 输入第一行给出三个正整数 M（≤ 1000）、N 和 S，分别是转发的总量、小明决定的中奖间隔、以及第一位中奖者的序号（编号从 1 开始）。随后 M 行，顺序给出转发微博的网友的昵称（不超过 20 个字符、不包含空格回车的非空字符串）。 注意：可能有人转发多次，但不能中奖多次。所以如果处于当前中奖位置的网友已经中过奖，则跳过他顺次取下一位。 输出格式： 按照输入的顺序输出中奖名单，每个昵称占一行。如果没有人中奖，则输出 Keep going...。 输入样例 1：123456789109 3 2Imgonnawin!PickMePickMeMeMeeeLookHereImgonnawin!TryAgainAgainTryAgainAgainImgonnawin!TryAgainAgain 输出样例 1：123PickMeImgonnawin!TryAgainAgain 输入样例 2：1232 3 5Imgonnawin!PickMe 输出样例 2：1Keep going... 通过代码12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;int main () { map&lt;string, int&gt; check; vector&lt;string&gt; v; bool out = false; int m, n, s; cin &gt;&gt; m &gt;&gt; n &gt;&gt; s; for (int i = 0; i &lt; m; i++) { string name; cin &gt;&gt; name; check[name] = 1; v.push_back(name); } for (int i = s - 1; i &lt; v.size(); i += n) { while (!check[v[i]]) i++; cout &lt;&lt; v[i] &lt;&lt; endl; out = true; check[v[i]] = 0; } if (!out) cout &lt;&lt; &quot;Keep going...&quot; &lt;&lt; endl; return 0;} 反思与评价 stl牛逼","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1069-%E5%BE%AE%E5%8D%9A%E8%BD%AC%E5%8F%91%E6%8A%BD%E5%A5%96(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1075","text":"题目 给定一个单链表，请编写程序将链表元素进行分类排列，使得所有负值元素都排在非负值元素的前面，而 [0, K] 区间内的元素都排在大于 K 的元素前面。但每一类内部元素的顺序是不能改变的。例如：给定链表为 18→7→-4→0→5→-6→10→11→-2，K 为 10，则输出应该为 -4→-6→-2→7→0→5→10→18→11。 输入格式： 每个输入包含一个测试用例。每个测试用例第 1 行给出：第 1 个结点的地址；结点总个数，即正整数N (≤105)；以及正整数K (≤103)。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。 接下来有 N 行，每行格式为： 1Address Data Next 其中 Address 是结点地址；Data 是该结点保存的数据，为 [−105,105] 区间内的整数；Next 是下一结点的地址。题目保证给出的链表不为空。 输出格式： 对每个测试用例，按链表从头到尾的顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。 输入样例：1234567891000100 9 1023333 10 2777700000 0 9999900100 18 1230968237 -6 2333333218 -4 0000048652 -2 -199999 5 6823727777 11 4865212309 7 33218 输出样例：12345678933218 -4 6823768237 -6 4865248652 -2 1230912309 7 0000000000 0 9999999999 5 2333323333 10 0010000100 18 2777727777 11 -1 通过代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;using namespace std;struct node { int add; int next; int data;};int first, num, k;node v[100005];node x[100005];node a[100005], b[100005], c[100005];void print(node* m, int size) { for (int i = 0; i &lt; size - 1; i++) printf (&quot;%05d %d %05d\\n&quot;, m[i].add, m[i].data, m[i + 1].add); printf (&quot;%05d %d -1\\n&quot;, m[size - 1].add, m[size - 1].data);}int get() { scanf (&quot;%d%d%d&quot;, &amp;first, &amp;num, &amp;k); node temp; for (int i = 0; i &lt; num; i++) { scanf (&quot;%d%d%d&quot;, &amp;temp.add, &amp;temp.data, &amp;temp.next); v[temp.add] = temp; } int find = first; int c = 0; while (find != -1) { x[c++] = (v[find]); find = v[find].next; } return c;}int main () { int real = get(); int an = 0, bn = 0, cn = 0; for (int i = 0; i &lt; real; i++) { if (x[i].data &lt; 0) a[an++] = (x[i]); else if (x[i].data &gt; k) c[cn++] = (x[i]); else b[bn++] = (x[i]); } int count = 0; for (int i = 0; i &lt; an; i++) x[count++] = a[i]; for (int i = 0; i &lt; bn; i++) x[count++] = b[i]; for (int i = 0; i &lt; cn; i++) x[count++] = c[i]; print(x, real); return 0;} 思路与注意 输入数据（由于后面要还原链表，为了降低复杂度，把addr当做引索） 把链表先还原，同时返回还原后的节点个数（因为有可能某些节点不在链表上） 分类统计，最后再重新排回去 输出（输出的时候最好把它变成一个整体，不要分块输出（可能存在某一部分空的情况）） 反思与评价 这道题就是改了改反转链表 思想实际上是德才论和反转链表的综合，简单题 反转链表用vector可以过，但是这个题用vector就会段错误，所以用普通数组","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1075-%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E5%88%86%E7%B1%BB(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1078","text":"题目 文本压缩有很多种方法，这里我们只考虑最简单的一种：把由相同字符组成的一个连续的片段用这个字符和片段中含有这个字符的个数来表示。例如 ccccc 就用 5c 来表示。如果字符没有重复，就原样输出。例如 aba 压缩后仍然是 aba。 解压方法就是反过来，把形如 5c 这样的表示恢复为 ccccc。 本题需要你根据压缩或解压的要求，对给定字符串进行处理。这里我们简单地假设原始字符串是完全由英文字母和空格组成的非空字符串。 输入格式： 输入第一行给出一个字符，如果是 C 就表示下面的字符串需要被压缩；如果是 D 就表示下面的字符串需要被解压。第二行给出需要被压缩或解压的不超过 1000 个字符的字符串，以回车结尾。题目保证字符重复个数在整型范围内，且输出文件不超过 1MB。 输出格式： 根据要求压缩或解压字符串，并在一行中输出结果。 输入样例 1：12CTTTTThhiiiis isssss a tesssst CAaaa as 输出样例 1：15T2h4is i5s a3 te4st CA3a as 输入样例 2：12D5T2h4is i5s a3 te4st CA3a as10Z 输出样例 2：1TTTTThhiiiis isssss a tesssst CAaaa asZZZZZZZZZZ 通过代码（极致压行版）12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;ctype.h&gt;using namespace std;void Cprint(int&amp; count, char a) {//注意count是引用变量 if (count != 1) cout &lt;&lt; count; cout &lt;&lt; a; count = 0;}int main () { string str, c; int i = 0, count = 1;//i是解码的循环变量，控制下标。count是压缩过程中记录重复字符出现次数的 getline(cin, c); getline(cin, str);//输入 if (c == &quot;C&quot;) { for (int j = 1; j &lt; str.length(); j++, count++)//每次循环count++ if (str[j - 1] != str[j]) Cprint(count, str[j - 1]);//如果遇到一个字符和前一个不一样，输出，让count归零 Cprint(count, str[str.length() - 1]);//输出最末尾的一个或一串 } else if (c == &quot;D&quot;) { if (!isdigit(str[i])) cout &lt;&lt; str[i++];//第一个不是数字，直接输出，i++访问下一个字符 for (int n = 0; i &lt; str.length(); n = 0, i++) {//n为每个字符前的数字 for (; i &lt; str.length() &amp;&amp; isdigit(str[i]); n *= 10, n += (str[i++] - '0'));//如果是数字，就把数字字符转换成数，这里不是双层for循环嵌套，这个for循环后有一个分号 for (int j = 0; j &lt; (n == 0 ? 1 : n); j++) cout &lt;&lt; str[i];//循环输出字符，如果没有遇到数字，n为0，就输出一次 } } return 0;} 通过代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;ctype.h&gt;using namespace std;struct out { char c; int n; };void C () { string str; getline(cin, str); int n = str.length(); out data[n] = {0}; char last = -1; int count = -1; for (int i = 0; i &lt; n; i++) { if (str[i] != last) data[++count].c = str[i]; data[count].n++; last = str[i]; } for (int i = 0; i &lt; count + 1; i++) { if (data[i].n != 1) cout &lt;&lt; data[i].n; cout &lt;&lt; data[i].c; }}void D () { string str; getline(cin, str); int i = 0; if (!isdigit(str[i])) cout &lt;&lt; str[i++]; while (i &lt; str.length()) { int n = 0; while (i &lt; str.length() &amp;&amp; isdigit(str[i])) { n *= 10; n += str[i++] - '0'; } for (int j = 0; j &lt; n; j++) cout &lt;&lt; str[i]; i++; while ( i &lt; str.length() &amp;&amp; !isdigit(str[i])) cout &lt;&lt; str[i++]; }}int main () { char c; scanf(&quot;%c%*c&quot;, &amp;c); if (c == 'C') C(); else D(); return 0;} 思路与注意 coding（压缩）一个函数，decoding（解压）一个函数分别处理 两个函数统一使用getline，main函数里面要吃掉第一行的换行符 对于coding过程 定义一个结构体数组，储存字符与个数。数组长度为输入string的长度（如果输入的string不能压缩，正好够用） 遍历一遍string，如果字符和前一个字符一样，那么当前结构体（变量）的字符个数++，一旦改变，存到下一个结构体中。 输出结构体，先输出个数（大于1才输出），再输出这个字符 对于decoding过程 先判断第一个字符，如果是字母直接输出这个字母，然后字符串的“指针”向后移。 进入循环，循环的操作为，得到数字，输出数字后的字母，然后输出后面的单个字母，直到遇到下一个数字，进入下一次循环，或者遇到字符串结束，那就结束。 注意不要用isalpha()函数（考虑空格的存在） 反思与评价 嗯","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1078-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1079","text":"题目 给定一个 k+1 位的正整数 N，写成 ak⋯a1a0 的形式，其中对所有 i 有 0≤ai&lt;10 且 ak&gt;0。N 被称为一个回文数，当且仅当对所有 i 有 ai=ak−i。零也被定义为一个回文数。 非回文数也可以通过一系列操作变出回文数。首先将该数字逆转，再将逆转数与该数相加，如果和还不是一个回文数，就重复这个逆转再相加的操作，直到一个回文数出现。如果一个非回文数可以变出回文数，就称这个数为延迟的回文数。（定义翻译自 https://en.wikipedia.org/wiki/Palindromic_number ） 给定任意一个正整数，本题要求你找到其变出的那个回文数。 输入格式： 输入在一行中给出一个不超过1000位的正整数。 输出格式： 对给定的整数，一行一行输出其变出回文数的过程。每行格式如下 1A + B = C 其中 A 是原始的数字，B 是 A 的逆转数，C 是它们的和。A 从输入的整数开始。重复操作直到 C 在 10 步以内变成回文数，这时在一行中输出 C is a palindromic number.；或者如果 10 步都没能得到回文数，最后就在一行中输出 Not found in 10 iterations.。 输入样例 1：197152 输出样例 1：12397152 + 25179 = 122331122331 + 133221 = 255552255552 is a palindromic number. 输入样例 2：1196 输出样例 2：1234567891011196 + 691 = 887887 + 788 = 16751675 + 5761 = 74367436 + 6347 = 1378313783 + 38731 = 5251452514 + 41525 = 9403994039 + 93049 = 187088187088 + 880781 = 10678691067869 + 9687601 = 1075547010755470 + 07455701 = 18211171Not found in 10 iterations. 通过代码12345678910111213141516171819202122232425262728293031323334import java.util.*;import java.math.*;class Main { static BigInteger getReverseNum(BigInteger a) { StringBuffer bf = new StringBuffer(a.toString()); bf.reverse(); BigInteger b = new BigInteger(bf.toString()); return b; } static boolean isPalindromicNumber(BigInteger a) { String n = a.toString(); int len = n.length(); for (int i = 0; i &lt; len / 2; i++) if (n.charAt(i) != n.charAt(len - i - 1)) return false; return true; } public static void main (String[] args) { Scanner sc = new Scanner(System.in); boolean ok = false; BigInteger a = sc.nextBigInteger(); for (int i = 0; i &lt; 10; i++) { if (isPalindromicNumber(a)) { System.out.println(a + &quot; is a palindromic number.&quot;); ok = true; break; } BigInteger b = getReverseNum(a); BigInteger c = a.add(b); System.out.println(a + &quot; + &quot; + b + &quot; = &quot; + c); a = c; } if (!ok) System.out.println(&quot;Not found in 10 iterations.&quot;); }} 思路与注意 题目中说是1000位的整数，所以一般的long解决不了，要用到java.math.*;中的BigInteger类 根据题目要求计算就好 要在10步内出结果，适合用for循环 循环的时候要先判断是否为Palindromic Number，有可能输入的第一个数就是Palindromic Number。 反思与评价 选择语言很重要，Java提供的BigInteger完美解决 c++写的话可以在网上找一份大整型的模板来用","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1079-%E5%BB%B6%E8%BF%9F%E7%9A%84%E5%9B%9E%E6%96%87%E6%95%B0(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1080","text":"题目 对于在中国大学MOOC（http://www.icourse163.org/ ）学习“数据结构”课程的学生，想要获得一张合格证书，必须首先获得不少于200分的在线编程作业分，然后总评获得不少于60分（满分100）。总评成绩的计算公式为 G=(Gmid−term×40%+Gfinal×60%)，如果 Gmid−term&gt;Gfinal；否则总评 G 就是 Gfinal。这里 Gmid−term 和 Gfinal 分别为学生的期中和期末成绩。 现在的问题是，每次考试都产生一张独立的成绩单。本题就请你编写程序，把不同的成绩单合为一张。 输入格式： 输入在第一行给出3个整数，分别是 P（做了在线编程作业的学生数）、M（参加了期中考试的学生数）、N（参加了期末考试的学生数）。每个数都不超过10000。 接下来有三块输入。第一块包含 P 个在线编程成绩 Gp；第二块包含 M 个期中考试成绩 Gmid−term；第三块包含 N 个期末考试成绩 Gfinal。每个成绩占一行，格式为：学生学号 分数。其中学生学号为不超过20个字符的英文字母和数字；分数是非负整数（编程总分最高为900分，期中和期末的最高分为100分）。 输出格式： 打印出获得合格证书的学生名单。每个学生占一行，格式为： 学生学号 Gp Gmid−term Gfinal G 如果有的成绩不存在（例如某人没参加期中考试），则在相应的位置输出“−1”。输出顺序为按照总评分数（四舍五入精确到整数）递减。若有并列，则按学号递增。题目保证学号没有重复，且至少存在1个合格的学生。 输入样例：12345678910111213141516171819206 6 701234 880a1903 199ydjh2 200wehu8 300dx86w 220missing 400ydhfu77 99wehu8 55ydjh2 98dx86w 88a1903 8601234 39ydhfu77 88a1903 6601234 58wehu8 84ydjh2 82missing 99dx86w 81 输出样例：1234missing 400 -1 99 99ydjh2 200 98 82 88dx86w 220 88 81 84wehu8 300 55 84 84 通过代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;class data {public: double Gp, GmidTerm, Gfinal, G; string name; data() { G = -1; Gfinal = -1; Gp = -1; GmidTerm = -1; } void setGp(double a) {Gp = a;} void setGmidTerm(double a) {GmidTerm = a;} void setGfinal(double a) {Gfinal = a;} void setName(string n) { name = n; } void final() { if (GmidTerm &gt; Gfinal) G = GmidTerm * 0.4 + Gfinal * 0.6; else G = Gfinal; G = round(G); GmidTerm = round(GmidTerm); Gfinal = round(Gfinal); Gp = round(Gp); }};typedef pair&lt;string, data&gt; PAIR;bool cmp1(PAIR&amp; a, PAIR&amp; b) { if (a.second.G != b.second.G) return a.second.G &gt; b.second.G; else return a.second.name &lt; b.second.name;}int main () { map&lt;string, data&gt; m; int a, b, c; double score; string name; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; for (int i = 0; i &lt; a; i++) { cin &gt;&gt; name &gt;&gt; score; m[name].setGp(score); m[name].setName(name); } for (int i = 0; i &lt; b; i++) { cin &gt;&gt; name &gt;&gt; score; m[name].setGmidTerm(score); } for (int i = 0; i &lt; c; i++) { cin &gt;&gt; name &gt;&gt; score; m[name].setGfinal(score); m[name].final(); } vector&lt;PAIR&gt; v; int i = 0; for (map&lt;string, data&gt;::iterator ite = m.begin(); ite != m.end(); ite++, i++) v.push_back(*ite); sort(v.begin(), v.end(), cmp1); for (int i = 0; i &lt; v.size(); i++) if (v[i].second.Gp &gt;= 200 &amp;&amp; v[i].second.G &gt;= 60) printf (&quot;%s %.0lf %.0lf %.0lf %.0lf\\n&quot;, v[i].second.name.data(), v[i].second.Gp, v[i].second.GmidTerm, v[i].second.Gfinal, v[i].second.G); return 0;} 思路与注意 利用类来管理数据，比较方便 第一个难点在于ID不是纯数字，不能把ID当做数组引索，想到使用map 第二个难点在于对map排序，map是默认以key排序的，这道题要对map的value进行排序 注意，数据输入并计算好以后，先四舍五入（round() 函数），再排序输出。 反思与评价 学到了很多关于map的知识 刚开始不用vector用普通数组的时候，最后一个测试点出现段错误，不知道是什么问题。 收获 map的排序 map默认按照key进行升序排序，和输入的顺序无关。如果是int/double等数值型为key，那么就按照大小排列；如果是string类型，那么就按照字符串的字典序进行排列 我们在定义map类模板的时候不是只有两个参数吗~（map&lt;string, int&gt;）~~其实map一共有4个参数，后面省略的，或者说是默认的第三个参数就是关于排序规则的 具体而言，它有四个参数，其中我们比较熟悉的有两个: Key 和 Value。第三个是class Compare = less&lt;Key&gt;(排序方式)，第四个是 Allocator，用来定义存储分配模型的。 对key进行自定义排序 map不能调用sort排序，是因为：map是个关联容器，不是序列容器。像是一些序列容器list, vector都是可以排序的。 对map的value排序的想法 首先，map中的&lt;key, value&gt;是pair形式的，那么我们就可以把一个pair作为vector中的元素； 然后，调用vetor容器中的sort函数，sort函数也是可以用户指定比较类型的。 对key进行自定义排序 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;map&gt;using namespace std;struct cmp //自定义比较规则{ bool operator() (const string&amp; str1, const string&amp; str2) { return str1.length() &lt; str2.length(); }};int main(){ map&lt;string, int, cmp &gt; scoreMap; //这边调用cmp map&lt;string, int, cmp &gt;::iterator iter; scoreMap[&quot;LiMin&quot;] = 90; scoreMap[&quot;ZZihsf&quot;] = 95; scoreMap[&quot;Kim&quot;] = 100; scoreMap.insert(map&lt;string, int&gt;::value_type(&quot;Jack&quot;, 88)); for (iter = scoreMap.begin(); iter != scoreMap.end(); iter++) cout &lt;&lt; iter-&gt;first &lt;&lt; ' ' &lt;&lt; iter-&gt;second &lt;&lt; endl; return 0;} 根据value排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;vector&gt;using namespace std; typedef pair&lt;string, int&gt; PAIR; struct cmp //自定义比较规则{ bool operator() (const PAIR&amp; P1, const PAIR&amp; P2) //注意是PAIR类型，需要.firt和.second。这个和map类似 { return P1.second &lt; P2.second; }}; int main(){ map&lt;string, int&gt; scoreMap; //这边调用cmp map&lt;string, int&gt;::iterator iter; scoreMap[&quot;LiMin&quot;] = 90; scoreMap[&quot;ZZihsf&quot;] = 95; scoreMap[&quot;Kim&quot;] = 100; scoreMap.insert(map&lt;string, int&gt;::value_type(&quot;Jack&quot;, 88)); vector&lt;PAIR&gt;scoreVector; for(iter=scoreMap.begin(); iter!=scoreMap.end();iter++) //这边本来是使用vector直接初始化的，当时由于vc 6.0 编译器问题，只能这样写，而且还有非法内存。。 scoreVector.push_back(*iter); //转化为PAIR的vector sort(scoreVector.begin(), scoreVector.end(), cmp()); //需要指定cmp for(int i=0; i&lt;=scoreVector.size(); i++) //也要按照vector的形式输出 cout&lt;&lt; scoreVector[i].first&lt;&lt;' '&lt;&lt;scoreVector[i].second &lt;&lt;endl; /* for(iter=scoreMap.begin(); iter!=scoreMap.end(); iter++) cout&lt;&lt;iter-&gt;first&lt;&lt;' '&lt;&lt;iter-&gt;second&lt;&lt;endl; */ return 0; } 四舍五入函数（其实早就学过，偷懒没有记） round(); 头文件 cmath 参考文献CSDN——STL容器（三）——对map排序","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1080-MOOC%E6%9C%9F%E7%BB%88%E6%88%90%E7%BB%A9(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1068","text":"题目 对于计算机而言，颜色不过是像素点对应的一个 24 位的数值。现给定一幅分辨率为 M×N 的画，要求你找出万绿丛中的一点红，即有独一无二颜色的那个像素点，并且该点的颜色与其周围 8 个相邻像素的颜色差充分大。 输入格式： 输入第一行给出三个正整数，分别是 M 和 N（≤ 1000），即图像的分辨率；以及 TOL，是所求像素点与相邻点的颜色差阈值，色差超过 TOL 的点才被考虑。随后 N 行，每行给出 M 个像素的颜色值，范围在 [0,224) 内。所有同行数字间用空格或 TAB 分开。 输出格式： 在一行中按照 (x, y): color 的格式输出所求像素点的位置以及颜色值，其中位置 x 和 y 分别是该像素在图像矩阵中的列、行编号（从 1 开始编号）。如果这样的点不唯一，则输出 Not Unique；如果这样的点不存在，则输出 Not Exist。 输入样例 1：12345678 6 2000 0 0 0 0 0 0 065280 65280 65280 16711479 65280 65280 65280 6528016711479 65280 65280 65280 16711680 65280 65280 6528065280 65280 65280 65280 65280 65280 165280 16528065280 65280 16777015 65280 65280 165280 65480 16528016777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 输出样例 1：1(5, 3): 16711680 输入样例 2：1234564 5 20 0 0 00 0 3 00 0 0 00 5 0 00 0 0 0 输出样例 2：1Not Unique 输入样例 3：12343 3 51 2 33 4 55 6 7 输出样例 3：1Not Exist 通过代码1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;int main () { int m, n, t; cin &gt;&gt; n &gt;&gt; m &gt;&gt; t; int dot[1005][1005] = {0}; map&lt;int, int&gt; check; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { cin &gt;&gt; dot[i][j]; check[dot[i][j]]++; } } int count = 0, x, y; for (int i = 0; i &lt; m &amp;&amp; count &lt;= 1; i++) for (int j = 0; j &lt; n &amp;&amp; count &lt;= 1; j++) if (abs(dot[i][j] - dot[i + 1][j]) &gt; t &amp;&amp; abs(dot[i][j] - dot[i][j + 1]) &gt; t &amp;&amp; abs(dot[i][j] - dot[i - 1][j]) &gt; t &amp;&amp; abs(dot[i][j] - dot[i][j - 1]) &gt; t) if (abs(dot[i][j] - dot[i + 1][j + 1]) &gt; t &amp;&amp; abs(dot[i][j] - dot[i + 1][j - 1]) &gt; t &amp;&amp; abs(dot[i][j] - dot[i - 1][j + 1]) &gt; t &amp;&amp; abs(dot[i][j] - dot[i - 1][j - 1]) &gt; t) if (check[dot[i][j]] == 1) { count++; x = i; y = j; } if (count &gt; 1) cout &lt;&lt; &quot;Not Unique&quot; &lt;&lt; endl; else if (count == 1) cout &lt;&lt; &quot;(&quot; &lt;&lt; y + 1 &lt;&lt; &quot;, &quot; &lt;&lt; x + 1 &lt;&lt; &quot;): &quot; &lt;&lt; dot[x][y] &lt;&lt; endl; else cout &lt;&lt; &quot;Not Exist&quot; &lt;&lt; endl; return 0;} 注意 注意，满足题目条件的点出来要和周围8个差距大于tol以外，这个点的数值只能出现一次 由于数字最大2^24，int足够 数组要大于输入的m，n，最后一个测试点和倒数第二个测试点容易挂","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1068-%E4%B8%87%E7%BB%BF%E4%B8%9B%E4%B8%AD%E4%B8%80%E7%82%B9%E7%BA%A2(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1082","text":"题目 本题目给出的射击比赛的规则非常简单，谁打的弹洞距离靶心最近，谁就是冠军；谁差得最远，谁就是菜鸟。本题给出一系列弹洞的平面坐标(x,y)，请你编写程序找出冠军和菜鸟。我们假设靶心在原点(0,0)。 输入格式： 输入在第一行中给出一个正整数 N（≤ 10 000）。随后 N 行，每行按下列格式给出： 1ID x y 其中 ID 是运动员的编号（由 4 位数字组成）；x 和 y 是其打出的弹洞的平面坐标(x,y)，均为整数，且 0 ≤ |x|, |y| ≤ 100。题目保证每个运动员的编号不重复，且每人只打 1 枪。 输出格式： 输出冠军和菜鸟的编号，中间空 1 格。题目保证他们是唯一的。 输入样例：123430001 5 71020 -1 30233 0 -1 输出样例：10233 0001 通过代码1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;struct shoot { int id; double x; double y; double len; };bool cmp(shoot&amp; a, shoot&amp; b) { return a.len &lt; b.len;}int main () { int n; cin &gt;&gt; n; shoot v[n]; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; v[i].id &gt;&gt; v[i].x &gt;&gt; v[i].y; v[i].len = sqrt(v[i].x * v[i].x + v[i].y * v[i].y); } sort(v, v + n, cmp); printf (&quot;%04d %04d\\n&quot;, v[0].id, v[n - 1].id); return 0;} 思路与注意 没有难度 反思与评价 没有难度 附（刚学C一个月时写的代码）（当时结构体都不会）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt; bool find_max (double, double *, int);bool find_min (double, double *, int);int main () { int n; scanf (&quot;%d&quot;, &amp;n); int num[n] = {0}; double x = 0; double y = 0; double distance[n] = {0}; for (int i = 0; i &lt; n; i++) { scanf (&quot;%d%lf%lf&quot;, &amp;num[i], &amp;x, &amp;y); distance[i] = sqrt(x*x+ y*y); } //std::sort(distance, distance+n); int max_n = 0, min_n = 0; for (int i = 0; i &lt; n; i++) { if (find_max(distance[i], distance, n)) { max_n = i; } if (find_min(distance[i], distance, n)) { min_n = i; } } printf (&quot;%04d %04d&quot;, num[min_n], num[max_n]); return 0;}bool find_max (double a, double * arr, int len) { for (int i = 0; i &lt; len; i++) { if (a &gt;= arr[i]) { if (i == len - 1) { return true; } } else { break; } } return false;}bool find_min (double a, double * arr, int len) { for (int i = 0; i &lt; len; i++) { if (a &lt;= arr[i]) { if (i == len - 1) { return true; } } else { break; } } return false;}","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1082-%E5%B0%84%E5%87%BB%E6%AF%94%E8%B5%9B(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1086","text":"题目 做作业的时候，邻座的小盆友问你：“五乘以七等于多少？”你应该不失礼貌地围笑着告诉他：“五十三。”本题就要求你，对任何一对给定的正整数，倒着输出它们的乘积。#### 输入格式：输入在第一行给出两个不超过 1000 的正整数 A 和 B，其间以空格分隔。 输出格式： 在一行中倒着输出 A 和 B 的乘积。 输入样例：15 7 输出样例：153 通过代码（极致压行版）123456789#include &lt;stdio.h&gt;int main () { int a, b; scanf (&quot;%d%d&quot;, &amp;a, &amp;b); int c = a * b; while (c &amp;&amp; c % 10 == 0)c /= 10;//忽略前导0，ab == 0则不循环 do printf (&quot;%d&quot;, c % 10); while (c /= 10);//do-while，先输出，再除10，ab == 0则只输出一个0 return 0;} 通过代码（正常版）1234567891011121314#include &lt;stdio.h&gt;int main () { int a, b; scanf (&quot;%d%d&quot;, &amp;a, &amp;b); int c = a * b; while (c &amp;&amp; c % 10 == 0) { c /= 10; }//忽略前导0，ab == 0则不循环 do { printf (&quot;%d&quot;, c % 10); c /= 10; } while (c);//do-while，先输出，再除10，ab == 0则只输出一个0 return 0;} 思路与注意 简单 反思与评价 简单","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1086-%E5%B0%B1%E4%B8%8D%E5%91%8A%E8%AF%89%E4%BD%A0(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1085","text":"题目 每次 PAT 考试结束后，考试中心都会发布一个考生单位排行榜。本题就请你实现这个功能。 输入格式： 输入第一行给出一个正整数 N（≤10^5），即考生人数。随后 N 行，每行按下列格式给出一个考生的信息： 1准考证号 得分 学校 其中准考证号是由 6 个字符组成的字符串，其首字母表示考试的级别：B代表乙级，A代表甲级，T代表顶级；得分是 [0, 100] 区间内的整数；学校是由不超过 6 个英文字母组成的单位码（大小写无关）。注意：题目保证每个考生的准考证号是不同的。 输出格式： 首先在一行中输出单位个数。随后按以下格式非降序输出单位的排行榜： 1排名 学校 加权总分 考生人数 其中排名是该单位的排名（从 1 开始）；学校是全部按小写字母输出的单位码；加权总分定义为乙级总分/1.5 + 甲级总分 + 顶级总分*1.5的整数部分；考生人数是该属于单位的考生的总人数。学校首先按加权总分排行。如有并列，则应对应相同的排名，并按考生人数升序输出。如果仍然并列，则按单位码的字典序输出。 输入样例：123456789101110A57908 85 AuB57908 54 LanXA37487 60 auT28374 67 CMUT32486 24 hypuA66734 92 cmuB76378 71 AUA47780 45 lanxA72809 100 pkuA03274 45 hypu 输出样例：12345651 cmu 192 21 au 192 33 pku 100 14 hypu 81 24 lanx 81 2 通过代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct data { int count; double score;};typedef pair&lt;string, data&gt; PAIR;bool cmp(PAIR &amp;a, PAIR &amp;b) { //比较，三个排序关键词 if (a.second.score != b.second.score) return a.second.score &gt; b.second.score; else if (a.second.count != b.second.count) return a.second.count &lt; b.second.count; else return a.first &lt; b.first;}void input(map&lt;string, data&gt; &amp;m) { //输入并计算分数 int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { string id, school; int score; cin &gt;&gt; id &gt;&gt; score &gt;&gt; school; transform(school.begin(), school.end(), school.begin(), ::tolower); //变成小写 if (id[0] == 'B') m[school].score += score / 1.5; else if (id[0] == 'A') m[school].score += score; else if (id[0] == 'T') m[school].score += score * 1.5; m[school].count++; }}void mapToVector(map&lt;string, data&gt; &amp;m, vector&lt;PAIR&gt; &amp;v) { //放进vector来利用sort排序 for (map&lt;string, data&gt;::iterator ite = m.begin(); ite != m.end(); ite++) { ite-&gt;second.score = floor(ite-&gt;second.score); //根据题意要floor向左取整 v.push_back(*ite); }}void print(vector&lt;PAIR&gt; &amp;v) { //按要求排名并输出数据 cout &lt;&lt; v.size() &lt;&lt; endl; int now = v[0].second.score, r = 1; for (int i = 0; i &lt; v.size(); i++) { if (v[i].second.score != now) r = i + 1; cout &lt;&lt; r &lt;&lt; &quot; &quot; &lt;&lt; v[i].first &lt;&lt; &quot; &quot; &lt;&lt; v[i].second.score &lt;&lt; &quot; &quot; &lt;&lt; v[i].second.count &lt;&lt; endl; now = v[i].second.score; }}int main() { map&lt;string, data&gt; m; vector&lt;PAIR&gt; v; input(m); //输入并计算分数 mapToVector(m, v); //放进vector来利用sort排序 sort(v.begin(), v.end(), cmp); //排序 print(v); //按要求排名并输出数据 return 0;} 思路与注意 这道题不用考虑同一人参与多场考试 由于不想太多变量，所以只有一个总分变量，所以要用double，最后要floor向左取整。 map是关联容器不能sort排序，要放进vector里面再排序 详见PAT乙级题–1080 MOOC期终成绩，里面有对map排序的笔记 排序的时候注意有三个关键词，分数（降序）、人数（升序）和学校名称（ASCII升序） 利用引用传递变量，浅拷贝，避免深拷贝 关于排名，思想是：先排序，排序后，令一个值now为第一个数，循环只要是和第一个数相同的就还是这个排名，一旦不等，说明后一名出现了，这是让now为当前这个数，然后让排名 = i+1（根据需要，有时是排名++）。后来为了压行，进一步提炼，每次循环让now = v[i].second.score，即让now记录上一次循环的值，比较与上次循环的分数是否相同，相同则排名相同，不同则排名按照需要改变 反思与评价 很好的利用了STL，希望能尽快用纯C写出来 开心嘿嘿，终于进入前1000了，加油！这个寒假刷完乙级题！","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1085-PAT%E5%8D%95%E4%BD%8D%E6%8E%92%E8%A1%8C(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1088","text":"题目 子曰：“三人行，必有我师焉。择其善者而从之，其不善者而改之。” 本题给定甲、乙、丙三个人的能力值关系为：甲的能力值确定是 2 位正整数；把甲的能力值的 2 个数字调换位置就是乙的能力值；甲乙两人能力差是丙的能力值的 X 倍；乙的能力值是丙的 Y 倍。请你指出谁比你强应“从之”，谁比你弱应“改之”。 输入格式： 输入在一行中给出三个数，依次为：M（你自己的能力值）、X 和 Y。三个数字均为不超过 1000 的正整数。 输出格式： 在一行中首先输出甲的能力值，随后依次输出甲、乙、丙三人与你的关系：如果其比你强，输出 Cong；平等则输出 Ping；比你弱则输出 Gai。其间以 1 个空格分隔，行首尾不得有多余空格。 注意：如果解不唯一，则以甲的最大解为准进行判断；如果解不存在，则输出 No Solution。 输入样例 1：48 3 7 输出样例 1：48 Ping Cong Gai 输入样例 2：48 11 6 输出样例 2：No Solution 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.*;class Main { static Scanner sc; static { sc = new Scanner(System.in); } static String print(double a, double b) { if (a &lt; b) { return &quot;Cong&quot;; } else if (a == b) { return &quot;Ping&quot;; } else { return &quot;Gai&quot;; } } public static void main(String[] args) { int m = sc.nextInt(); int x = sc.nextInt(); int y = sc.nextInt(); boolean find = false; for (int a = 99; a &gt;= 10; a--) { double b = a % 10 * 10 + a / 10; double c = b / y; if (c != Math.abs((a - b) / x)) { continue; } else { find = true; System.out.print(a + &quot; &quot; + Main.print(m, a) + &quot; &quot; + Main.print(m, b) + &quot; &quot; + Main.print(m, c)); break; } } if (!find) { System.out.println(&quot;No Solution&quot;); } }}/* * a b c * c/x = a-b * c/y = b * c(1/x+1/y) = a * */ 思路与注意 abc\b三个变量代表甲乙丙，由于a已知是两位数，且需要\b解中甲最大的情况，所以就for循环从99到10 \b2. 注意b，c要的是精确值，不是\b整型取商的结果 反思与评价反思       好像是一遍过的吧？ 评价       无","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1088-%E4%B8%89%E4%BA%BA%E8%A1%8C(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1093","text":"题目 给定两个字符串 A 和 B，本题要求你输出 A+B，即两个字符串的并集。要求先输出 A，再输出 B，但重复的字符必须被剔除。 输入格式： 输入在两行中分别给出 A 和 B，均为长度不超过 106的、由可见 ASCII 字符 (即码值为32~126)和空格组成的、由回车标识结束的非空字符串。 输出格式： 在一行中输出题面要求的 A 和 B 的和。 输入样例：12This is a sample testto show you_How it works 输出样例：1This ampletowyu_Hrk 通过代码123456789101112131415#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main () { char arr[128] = {0}; memset(arr, -1, sizeof(arr)); char c; while ((c = getchar()) != -1) { if (c == '\\n') continue; if (arr[c] == -1) { putchar(c); arr[c] = 1; } }} 思路与注意 观察输入与输出 换行不输出 某个字符如果前面出现过，就不输出 搞一个数组，ASCII值为引索，初始化为-1，每打一个字，把对应的值改成非-1的值 注意要让程序结束，通过第二个回车判断，或者EOF 的-1判断","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1093-%E5%AD%97%E7%AC%A6%E4%B8%B2A+B(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1092","text":"题目 月饼是久负盛名的中国传统糕点之一，自唐朝以来，已经发展出几百品种。 若想评比出一种“最好吃”的月饼，那势必在吃货界引发一场腥风血雨…… 在这里我们用数字说话，给出全国各地各种月饼的销量，要求你从中找出销量冠军，认定为最好吃的月饼。 输入格式： 输入首先给出两个正整数 N（≤1000）和 M（≤100），分别为月饼的种类数（于是默认月饼种类从 1 到 N 编号）和参与统计的城市数量。接下来 M 行，每行给出 N 个非负整数（均不超过 1 百万），其中第 i 个整数为第 i 种月饼的销量（块）。数字间以空格分隔。 输出格式： 在第一行中输出最大销量，第二行输出销量最大的月饼的种类编号。如果冠军不唯一，则按编号递增顺序输出并列冠军。数字间以 1 个空格分隔，行首尾不得有多余空格。 输入样例：5 3 1001 992 0 233 6 8 0 2018 0 2008 36 18 0 1024 4 输出样例：2018 3 5 通过代码12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int main() { int n, m, max = -10000, count = 0, temp; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int sale[n] = {0}; for (int i = 0; i &lt; m - 1; i++) { for (int j = 0; j &lt; n; j++) { scanf(&quot;%d&quot;, &amp;temp); sale[j] += temp; } } for (int i = 0; i &lt; n; i++) { scanf(&quot;%d&quot;, &amp;temp); sale[i] += temp; if (sale[i] &gt; max) max = sale[i]; } printf(&quot;%d\\n&quot;, max); for (int i = 0; i &lt; n; i++) { if (sale[i] == max) { if (count++ == 0) printf(&quot;%d&quot;, i + 1); else printf(&quot;%s%d&quot;, &quot; &quot;, (i + 1)); } } return 0;} 评价与反思没有难度，按照题意统计计算就好","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1092-%E6%9C%80%E5%A5%BD%E5%90%83%E7%9A%84%E6%9C%88%E9%A5%BC(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1091","text":"题目 如果某个数 K 的平方乘以 N 以后，结果的末尾几位数等于 K，那么就称这个数为“N-自守数”。例如 3×922 = 25392，而 25392 的末尾两位正好是 92，所以 92 是一个 3-自守数。 本题就请你编写程序判断一个给定的数字是否关于某个 N 是 N-自守数。 输入格式： 输入在第一行中给出正整数 M（≤20），随后一行给出 M 个待检测的、不超过 1000 的正整数。 输出格式： 对每个需要检测的数字，如果它是 N-自守数就在一行中输出最小的 N 和 NK^2 的值，以一个空格隔开；否则输出 No。注意题目保证 N&lt;10。 输入样例：3 92 5 233 输出样例：3 25392 1 25 No 通过代码12345678910111213141516171819202122232425262728293031323334import java.util.*;class Main { static Scanner sc; static { sc = new Scanner(System.in); } public static void main(String[] args) { int n = sc.nextInt(); int arr = 0; for (int i = 0; i &lt; n; i++) { arr = sc.nextInt(); Integer temp = arr; int len = temp.toString().length(); boolean find = false; for (int j = 1; j &lt; 10; j++) { temp = arr * arr * j; String y = temp.toString().substring(temp.toString().length() - len, temp.toString().length()); temp = arr; if (y.equals(temp.toString())) { System.out.println(j + &quot; &quot; + arr * arr * j); find = true; break; } } if (!find) { System.out.println(&quot;No&quot;); } } }} 错误反思与代码评价错误反思好像是一遍过的吧？ 代码评价java的类都有一个toString方法真的超级方便哦，直接平方，赋值给Integer调用toString再截取后面一段，跟原来的数比较，So easy!","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1091-N-%E8%87%AA%E5%AE%88%E6%95%B0(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1090","text":"题目 集装箱运输货物时，我们必须特别小心，不能把不相容的货物装在一只箱子里。比如氧化剂绝对不能跟易燃液体同箱，否则很容易造成爆炸。 本题给定一张不相容物品的清单，需要你检查每一张集装箱货品清单，判断它们是否能装在同一只箱子里。 输入格式： 输入第一行给出两个正整数：N (≤104) 是成对的不相容物品的对数；M (≤100) 是集装箱货品清单的单数。 随后数据分两大块给出。第一块有 N 行，每行给出一对不相容的物品。第二块有 M 行，每行给出一箱货物的清单，格式如下： 1K G[1] G[2] ... G[K] 其中 K (≤1000) 是物品件数，G[i] 是物品的编号。简单起见，每件物品用一个 5 位数的编号代表。两个数字之间用空格分隔。 输出格式： 对每箱货物清单，判断是否可以安全运输。如果没有不相容物品，则在一行中输出 Yes，否则输出 No。 输入样例：123456789106 320001 2000220003 2000420005 2000620003 2000120005 2000420004 200064 00001 20004 00002 200035 98823 20002 20003 20006 100103 12345 67890 23333 输出样例：123NoYesYes 通过代码12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;int main() { int n, k; map&lt;int, vector&lt;int&gt;&gt; m; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 0; i &lt; n; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); m[x].push_back(y); m[y].push_back(x); } while (k--) { int K, has[100000] = {0}; scanf(&quot;%d&quot;, &amp;K); vector&lt;int&gt; v(K); for (int i = 0; i &lt; K; i++) { scanf(&quot;%d&quot;, &amp;v[i]); has[v[i]] = 1; } bool find = false; for (int i = 0; i &lt; v.size(); i++) for (int j = 0; j &lt; m[v[i]].size(); j++) if (has[m[v[i]][j]]) find = true; if (find) printf(&quot;No\\n&quot;); else printf (&quot;Yes\\n&quot;); } return 0;} 思路与注意 搞一个数组has，用id当引索，储存是否存在这个物品 搞一个map映射，从id到一个vector，vector为与这个物品不共存的物品编号（可能存在多个不共存物体） 两层for循环，利用has数组，跟自己不共存的物品穿上有没有，如果有，就结束 反思与评价 这道题本身想用二维数组记录是否配对，这样复杂度为n * n，一直过不了 这道题挺有难度的，也是看了网上的大神才写出来的","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1090-%E5%8D%B1%E9%99%A9%E5%93%81%E8%A3%85%E7%AE%B1(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1094","text":"题目 2004 年 7 月，谷歌在硅谷的 101 号公路边竖立了一块巨大的广告牌（如下图）用于招聘。内容超级简单，就是一个以 .com 结尾的网址，而前面的网址是一个 10 位素数，这个素数是自然常数 e 中最早出现的 10 位连续数字。能找出这个素数的人，就可以通过访问谷歌的这个网站进入招聘流程的下一步。 自然常数 e 是一个著名的超越数，前面若干位写出来是这样的：e = 2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427427466391932003059921… 其中粗体标出的 10 位数就是答案。 本题要求你编程解决一个更通用的问题：从任一给定的长度为 L 的数字中，找出最早出现的 K 位连续数字所组成的素数。 输入格式： 输入在第一行给出 2 个正整数，分别是 L（不超过 1000 的正整数，为数字长度）和 K（小于 10 的正整数）。接下来一行给出一个长度为 L 的正整数 N。 输出格式： 在一行中输出 N 中最早出现的 K 位连续数字所组成的素数。如果这样的素数不存在，则输出 404。注意，原始数字中的前导零也计算在位数之内。例如在 200236 中找 4 位素数，0023 算是解；但第一位 2 不能被当成 0002 输出，因为在原始数字中不存在这个 2 的前导零。 输入样例 1：1220 523654987725541023819 输出样例 1：149877 输入样例 2：1210 32468024680 输出样例 2：1404 通过代码1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;bool isPrime[10] = {false, false, true, true, false, true, false, true, false};bool Prime(int i) { if (i &lt; 9 &amp;&amp; i &gt;= 0) return isPrime[i]; if (i % 2 == 0) return false; else for (int j = 3; j * j &lt;= i; j += 2)//只能&gt;=9的奇数 if (i % j == 0) return false; return true;}int main () { int a, b; string bf; bool ok = false; cin &gt;&gt; a &gt;&gt; b &gt;&gt; bf; for (int i = 0; i &lt;= a - b; i++) { string n = bf.substr(i, b); int x = atoi(n.data()); if (Prime(x)) { printf (&quot;%s\\n&quot;, n.data()); ok = true; break; } } if (!ok) printf (&quot;404\\n&quot;); return 0;} 思路与注意 按照题意算就可以，注意需要判断哪个是素数再算哪个 反思与评价 这道题不难，但是写了一个下午，因为脑袋很轴，非要把所有0~`999999999`的素数全算出来","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1094-%E8%B0%B7%E6%AD%8C%E7%9A%84%E6%8B%9B%E8%81%98(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1081","text":"题目 本题要求你帮助某网站的用户注册模块写一个密码合法性检查的小功能。该网站要求用户设置的密码必须由不少于6个字符组成，并且只能有英文字母、数字和小数点 .，还必须既有字母也有数字。 输入格式： 输入第一行给出一个正整数 N（≤ 100），随后 N 行，每行给出一个用户设置的密码，为不超过 80 个字符的非空字符串，以回车结束。 输出格式： 对每个用户的密码，在一行中输出系统反馈信息，分以下5种： 如果密码合法，输出Your password is wan mei.； 如果密码太短，不论合法与否，都输出Your password is tai duan le.； 如果密码长度合法，但存在不合法字符，则输出Your password is tai luan le.； 如果密码长度合法，但只有字母没有数字，则输出Your password needs shu zi.； 如果密码长度合法，但只有数字没有字母，则输出Your password needs zi mu.。 输入样例：1234565123szheshi.wodepw1234.5678WanMei23333pass*word.6 输出样例：12345Your password is tai duan le.Your password needs shu zi.Your password needs zi mu.Your password is wan mei.Your password is tai luan le. 通过代码12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int main () { string pwd; getline(cin, pwd); while (getline(cin, pwd)) { if (pwd.length() &gt;= 6) { bool alpha = false, num = false, dot = false, other = false; for (int i = 0; i &lt; pwd.length(); i++) { if (isalpha(pwd[i])) alpha = true; else if (isdigit(pwd[i])) num = true; else if (pwd[i] == '.') dot = true; else other = true; } if (!other &amp;&amp; alpha &amp;&amp; num) cout &lt;&lt; &quot;Your password is wan mei.&quot; &lt;&lt; endl; else if (other) cout &lt;&lt; &quot;Your password is tai luan le.&quot; &lt;&lt; endl; else if (!num &amp;&amp; alpha) cout &lt;&lt; &quot;Your password needs shu zi.&quot; &lt;&lt; endl; else if (num &amp;&amp; !alpha) cout &lt;&lt; &quot;Your password needs zi mu.&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;Your password is tai duan le.&quot; &lt;&lt; endl; } } return 0;}","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1081-%E6%A3%80%E6%9F%A5%E5%AF%86%E7%A0%81(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1095","text":"题目 PAT 准考证号由 4 部分组成： 第 1 位是级别，即 T 代表顶级；A 代表甲级；B 代表乙级； 第 2~4 位是考场编号，范围从 101 到 999； 第 5~10 位是考试日期，格式为年、月、日顺次各占 2 位； 最后 11~13 位是考生编号，范围从 000 到 999。 现给定一系列考生的准考证号和他们的成绩，请你按照要求输出各种统计信息。 输入格式： 输入首先在一行中给出两个正整数 N（≤104）和 M（≤100），分别为考生人数和统计要求的个数。 接下来 N 行，每行给出一个考生的准考证号和其分数（在区间 [0,100] 内的整数），其间以空格分隔。 考生信息之后，再给出 M 行，每行给出一个统计要求，格式为：类型 指令，其中 类型 为 1 表示要求按分数非升序输出某个指定级别的考生的成绩，对应的 指令 则给出代表指定级别的字母； 类型 为 2 表示要求将某指定考场的考生人数和总分统计输出，对应的 指令 则给出指定考场的编号； 类型 为 3 表示要求将某指定日期的考生人数分考场统计输出，对应的 指令 则给出指定日期，格式与准考证上日期相同。 输出格式： 对每项统计要求，首先在一行中输出 Case #: 要求，其中 # 是该项要求的编号，从 1 开始；要求 即复制输入给出的要求。随后输出相应的统计结果： 类型 为 1 的指令，输出格式与输入的考生信息格式相同，即 准考证号 成绩。对于分数并列的考生，按其准考证号的字典序递增输出（题目保证无重复准考证号）； 类型 为 2 的指令，按 人数 总分 的格式输出； 类型 为 3 的指令，输出按人数非递增顺序，格式为 考场编号 总人数。若人数并列则按考场编号递增顺序输出。 如果查询结果为空，则输出 NA。 输入样例：123456789101112138 4B123180908127 99B102180908003 86A112180318002 98T107150310127 62A107180908108 100T123180908010 78B112160918035 88A107180908021 981 A2 1073 1809082 999 输出样例：123456789101112Case 1: 1 AA107180908108 100A107180908021 98A112180318002 98Case 2: 2 1073 260Case 3: 3 180908107 2123 2102 1Case 4: 2 999NA 通过代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#define map unordered_map#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct POS { int Num = 0; int Score = 0;};struct STU { string id; int score;};typedef pair&lt;string, POS&gt; PAIR;map&lt;string, POS&gt; Pos;map&lt;char, vector&lt;STU&gt;&gt; type;map&lt;string, POS&gt; PosWithTime;vector&lt;PAIR&gt; vPosWithTime;void update(STU* ob) { string pos = ob-&gt;id.substr(1, 3); Pos[pos].Num++; Pos[pos].Score += ob-&gt;score; pos = ob-&gt;id.substr(1, 9); PosWithTime[pos].Num++; PosWithTime[pos].Score++; type[ob-&gt;id[0]].push_back(*ob);}bool cmp1(STU&amp; a, STU&amp; b) { return (a.score != b.score ? a.score &gt; b.score : a.id &lt; b.id);}bool cmp2(PAIR&amp; a, PAIR&amp; b) { return (a.second.Num != b.second.Num ? a.second.Num &gt; b.second.Num : a.first &lt; b.first);}void final() { for (map&lt;char, vector&lt;STU&gt;&gt;::iterator ite = type.begin(); ite != type.end(); ite++) sort(ite-&gt;second.begin(), ite-&gt;second.end(), cmp1); for (map&lt;string, POS&gt;::iterator ite = PosWithTime.begin(); ite != PosWithTime.end(); ite++) vPosWithTime.push_back(*ite); sort(vPosWithTime.begin(), vPosWithTime.end(), cmp2);}int one(int num) { char grade; cin &gt;&gt; grade; printf(&quot;Case %d: 1 %c\\n&quot;, num, grade); vector&lt;STU&gt;&amp; temp = type[grade]; if (!temp.size()) return 1; for (int i = 0; i &lt; temp.size(); i++) printf(&quot;%s %d\\n&quot;, temp[i].id.data(), temp[i].score); return 0;}int two(int num) { string pos; cin &gt;&gt; pos; printf(&quot;Case %d: 2 %s\\n&quot;, num, pos.data()); POS&amp; temp = Pos[pos]; if (!temp.Num) return 1; printf(&quot;%d %d\\n&quot;, temp.Num, temp.Score); return 0;}int three(int num) { string date; cin &gt;&gt; date; printf(&quot;Case %d: 3 %s\\n&quot;, num, date.data()); int n = 0; for (vector&lt;PAIR&gt;::iterator ite = vPosWithTime.begin(); ite != vPosWithTime.end(); ite++) { if (ite-&gt;first.substr(3, 6) == date) { printf(&quot;%s %d\\n&quot;, ite-&gt;first.substr(0, 3).data(), ite-&gt;second.Num); n++; } } if (!n) return 1; return 0;}int main() { int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); STU temp; for (int i = 0; i &lt; n; i++) { char str[1024]; scanf (&quot;%s%d&quot;, str, &amp;temp.score); temp.id = str; update(&amp;temp); } final(); for (int i = 0; i &lt; m; i++) { int ins, result; scanf (&quot;%d&quot;, &amp;ins); getchar(); if (ins == 1) result = one(i + 1); else if (ins == 2) result = two(i + 1); else result = three(i + 1); if (result) printf(&quot;NA\\n&quot;); } return 0;} 思路与注意 建立两个结构体 考场POS，储存考场人数Num，所有人的总分Score 学生STU，储存考号id，分数score 建立三个映射map Pos考场号（string）-&gt;考场（POS），给第二个功能用的，引索是考场号 type等级（char）-&gt;学生（STU）向量（vector），每个等级对应一个vector PosWithTime考场号+时间（string）-&gt;考场（POS），引索是考场+时间，这样可以保证是某一天的某教室的人数。 不单独创建vector储存学生信息，每次输入后，利用updata()函数，向以上三个映射map中更新数据（增加POS 的Score、某一等级的学生信息） 最后一次性把所有数据全部排好序（利用final()函数）（vPosWithTime就是为了给PosWithTime排序的）（type这个map中的所有vector按照要求排序），防止数据反复拷贝、遍历。 每个功能一个函数，计算输出 使用printf和scanf，防止后两个测试点超时 反思与评价这道题写了一下午，主要犯了以下错误 逻辑问题。对于类型二的输出，没有考虑到一间考场可以对应多场考试。刚开始想要用类，搞一个类的静态变量（从考场号到考场结构体变量的map映射），在一遍输入，一边构造了对象，就利用该对象的数据进行分析，然后统计。这时犯了逻辑错误，认为这个map统计的考生数就是某一天的考生数。本地运行的时候也没注意检查。 阅读问题。这两道题的最后两个测试点一直超时（之前使用cin，cout的时候），然后去看了csdn上一位大佬的代码。没发现跟自己的算法的区别。后来仔细读了TA的文章后，才反应过来是由于cin和cout的巴拉巴拉巴拉的原因。然后我把所有的cin和cout换成printf和scanf，就不超时了。 真·真开心！（不认识“真”了）","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1095-%E8%A7%A3%E7%A0%81PAT%E5%87%86%E8%80%83%E8%AF%81(PAT-(Basic-Level)-Practice)/"},{"title":"gallery","text":".galleria{ width: 100%; height: 100vh; } (function() { Galleria.loadTheme('https://cdnjs.cloudflare.com/ajax/libs/galleria/1.5.7/themes/classic/galleria.classic.min.js'); Galleria.run('.galleria', { extend: function() { var gallery = this; // \"this\" is the gallery instance $('.galleria').click(function() { console.log(\"click\"); gallery.playToggle(1000).toggleFullscreen(); // call the play method }); } }); }());","link":"/home/2024/04/23/gallery/index/"},{"title":"MIUISupermarket移植","text":"VerifyError1java.lang.VerifyError: Verifier rejected class com.xiaomi.market.util.UIUtils: void com.xiaomi.market.util.UIUtils.setStatusBarDarkMode(android.app.Activity, boolean) failed to verify: void com.xiaomi.market.util.UIUtils.setStatusBarDarkMode(android.app.Activity, boolean): [0x15] type Undefined unexpected as arg to if-eqz/if-nez (declaration of 'com.xiaomi.market.util.UIUtils' appears in /data/app/~~pH0reBrzyfvMag1T-TAoDw==/com.xiaomi.market-EzZXS_MznmhQs5NCCbvqfA==/base.apk!classes2.dex) 一般出现VerifyError都是因为对smali代码修改，导致无法通过验证。当前遇到过的情况有： 插入代码时无意覆盖了下面会用到的寄存器的值，导致寄存器类型不匹配等问题。 对方法参数类型修改但未修改调用时传入的参数 传递参数时传递了类型不匹配的参数 ClassNotFound在xiaomi商店中使用了Lmiui/os/Build类，该类继承Landroid/os/Build，且存在于小米系统中，导致类找不到。导致运行时闪退。 对于这类小米系统中才能获取到的类，采用等价替换的方法进行修复。如在Lmiui/os/Build中有： IS_INTERNATIONAL_BUILD IS_ALPHA_BUILD IS_DEVELOPMENT_VERSION IS_INTERNATIONAL_BUILD getRegion()等字段和方法，可以在miui中查看一下对应的值，然后手动修改smali代码，将值替换为对应的值。 Dex方法数限制1org.jf.util.ExceptionWithContext: Error while writing instruction at code offset 0x2 在apktools打包smali时报错，对smali修改时添加了很多方法，导致一个dex内方法数超过65,535，导致打包失败。 解决方法：在smali源码目录中新建文sources_dex${n}目录，将代码放入该位置，重新编译，即可将代码打包入新的dex文件中。 应用无法安装MIUI魔改了PackageInstaller当使用packageinstaller获取session写入安装包后，使用commit传入一个PendingIntent对象，用于接收应用安装结果的广播。而该通知的内容被魔改，导致收到原生系统的广播时，无法正确处理后续的逻辑，导致安装失败。 中间还尝试过使用ACTION_VIEW或ACTION_INSTALL_PACKAGEstartActivity启动安装器，但这两个ACTION在安卓10后被废弃了，导致没有Activity响应该Intent，无法进行安装。 使用ACTION安装apk时，如果apk文件在私有存储空间内，要使用FileProvider。 未解决的问题 无法卸载 无法暂停任务 安装后没有调用session的abandon()方法 首页顶部标题栏与系统状态栏之间存在空白部分 另外中间还有一个MIUISettingsProvider的类找不到，我当时直接把miui中的SettingsProvider替换到PixelOS的SettingsProvider中，导手机致变砖，救砖救了好久。","link":"/home/2024/07/13/misc/MIUISupermarket%E7%A7%BB%E6%A4%8D/"},{"title":"qq.md","text":"我的QQ123&quot;&quot;&quot; -... .- . -.. --. .... -.-. .--- -... -...&quot;&quot;&quot;","link":"/home/2022/10/22/social/qq/"},{"title":"c语言函数绘图","text":"代码 github 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402#define _XOPEN_SOURCE 500#define _C99_SOURCE#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;stdbool.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdarg.h&gt;#include &lt;float.h&gt;//#define LOG_LEVEL DEBUG_LOG#define DEBUG_LOG 7#define INFO_LOG 5#define ERR_LOG 4#ifndef LOG_LEVEL#define LOG_LEVEL INFO_LOG#endif#ifndef GREATER_CHAR#define GREATER_CHAR ' '#endif#ifndef SMALLER_CHAR#define SMALLER_CHAR '+'#endifvoid logger(int level, const char *format, ...) { if(level &gt; LOG_LEVEL) return; va_list args; va_start(args, format); int len = vsnprintf(NULL, 0, format, args)+1; va_end(args); va_start(args, format); char *str = malloc(len); vsprintf(str, format, args); va_end(args); fprintf(stderr, &quot;%s\\n&quot;, str); free(str);}double x1, x2, _y1, _y2, s1, s2;#define PUSH(s, n) (s[s##_ptr++] = (n))#define POP(s, n) (n = s[--s##_ptr])#define TOP(s, n) (n = s[s##_ptr-1])#define EMPTY(s) (s##_ptr == 0)enum { op_acos = 48, op_asin , op_atan , op_cos , op_cosh , op_sin , op_sinh , op_tan , op_tanh , op_exp , op_log , op_floor , op_sqrt , op_fabs , op_ceil};const static int op_min = op_acos;const static int op_max = op_ceil;static double stack[1024];static char op_stack[1024];static int priv[128] = { [0 ... 39] = 0, ['('] = 1, [')'] = 2, ['*'] = 3, ['+'] = 2, [44] = 0, ['-'] = 2, [46] = 0, ['/'] = 3, [48 ... 93] = 0, ['^'] = 4, [95 ... 127] = 0};static int stack_ptr = 0;static int op_stack_ptr = 0;void logStack() { logger(DEBUG_LOG, &quot;op_stack: &quot;); for(int cnt = 0; cnt &lt; op_stack_ptr; cnt++) { logger(DEBUG_LOG, &quot;%c &quot;, op_stack[cnt]); } logger(DEBUG_LOG, &quot;stack: &quot;); for(int cnt = 0; cnt &lt; stack_ptr; cnt++) { logger(DEBUG_LOG, &quot;%lf &quot;, stack[cnt]); } logger(DEBUG_LOG, &quot;&quot;);}void biCheck() { if(EMPTY(stack)) { logger(ERR_LOG, &quot;empty stack!&quot;); exit(1); }}void pushOP(char cur_op) { double n1, n2; char op; while(!EMPTY(op_stack) &amp;&amp; priv[TOP(op_stack, op)] &gt;= priv[cur_op]) { POP(op_stack, op); double res = 0; POP(stack, n2); if(!EMPTY(stack))POP(stack, n1); else n1 = 0; switch(op) { case '+': res = n1 + n2; break; case '-': res = n1 - n2; break; case '*': res = n1 * n2; break; case '/': if(n2 == 0) { logger(ERR_LOG, &quot;divisor is zeor!&quot;);// exit(1); } res = n1 / n2; break; case '^': res = pow(n1, n2); break; default: break; } PUSH(stack, res); }}int len_strncmp(const char *a, const char *b) { return strncmp(a, b, strlen(b));}double eval(double y, double x, const char *expr) { int len = strlen(expr); int i = 0; stack_ptr = 0; op_stack_ptr = 0; while(i &lt; len) { switch(expr[i]) { case '^': biCheck(); pushOP(expr[i]); // if(EMPTY(stack)) PUSH(stack, 0); PUSH(op_stack, expr[i]); break; case 'x': case 'X': PUSH(stack, x); break; case 'y': case 'Y': PUSH(stack, y); break; case '(': PUSH(op_stack, '('); break; case ')': { double n1, n2; char op; if(EMPTY(op_stack)) { logger(ERR_LOG, &quot;no match ')'&quot;); exit(1); } pushOP(')'); POP(op_stack, op); if(TOP(op_stack, op) &gt;= op_min &amp;&amp; TOP(op_stack, op) &lt;= op_max) { POP(op_stack, op); double n; if(!EMPTY(stack)) { POP(stack, n); } else { logger(ERR_LOG, &quot;Error : no opvalue&quot;); exit(1); } double (*op_func)(double); switch(op) { case op_acos: if(n &gt; 1 || n &lt; -1) return DBL_MAX; op_func = acos; break; case op_asin: if(n &gt; 1 || n &lt; -1) return DBL_MAX; op_func = asin; break; case op_atan: op_func = atan; break; case op_cos: op_func = cos; break; case op_cosh: op_func = cosh; break; case op_sin: op_func = sin; break; case op_sinh: op_func = sinh; break; case op_tan: op_func = tan; break; case op_tanh: op_func = tanh; break; case op_exp: op_func = exp; break; case op_log: if(n &lt; 0) return DBL_MAX; op_func = log; break; case op_sqrt: if(n &lt; 0) return DBL_MAX; op_func = sqrt; break; case op_fabs: op_func = fabs; break; case op_ceil: op_func = ceil; break; case op_floor: op_func = floor; break; } PUSH(stack, op_func(n)); } } break; case '+':case '-': { if((i &gt; 0 &amp;&amp; expr[i-1] != '(')) { // fix： a-(-b) // if stack is empty or last op is '(', ‘-’ is an Unary operator // else it's a Binary operator biCheck(); pushOP(expr[i]); } else { PUSH(stack, 0); } PUSH(op_stack, expr[i]); } break; case '*': case '/': biCheck(); pushOP(expr[i]); // if(EMPTY(stack)) PUSH(stack, 0); PUSH(op_stack, expr[i]); break; case 'p': // p1 = 3.14 if(i + 1 &lt; len &amp;&amp; expr[i + 1] == 'i') { PUSH(stack, M_PI); i++; } else { logger(ERR_LOG, &quot;Error 'pi': unknown char(%c)&quot;, expr[i]); exit(1); } break; case 'e': // e = 2.7 PUSH(stack, M_E); break; case '0':case '1':case '2':case '3':case '4':case '5':case '6':case '7':case '8':case '9':case '.': { double n = 0; double n1 = 1; while(i &lt; len) { if(expr[i] &lt; '0' || expr[i] &gt; '9') { break; } n *= 10; n += expr[i] - '0'; i++; } if(expr[i] == '.') { i++; while(i &lt; len &amp;&amp; expr[i] != '.') { if(expr[i] &lt; '0' || expr[i] &gt; '9') { break; } n1 /= 10.0; n += n1 * (expr[i] - '0'); i++; } }if(expr[i] == '.') { logger(ERR_LOG, &quot;error : two '.' in one number&quot;); exit(1); } PUSH(stack, n); i--; } break; default: if(!len_strncmp(expr + i, &quot;ACOS&quot;)) { PUSH(op_stack, op_acos); i+=3; } else if(!len_strncmp(expr + i, &quot;ASIN&quot;)) { PUSH(op_stack, op_asin); i+=3; } else if(!len_strncmp(expr + i, &quot;ATAN&quot;)) { PUSH(op_stack, op_atan); i+=3; } else if(!len_strncmp(expr + i, &quot;COS&quot;)) { if(expr[i+3] == 'H') { PUSH(op_stack, op_cosh); i+=3; } else { PUSH(op_stack, op_cos); i+=2; } } else if(!len_strncmp(expr + i, &quot;SIN&quot;)) { if(expr[i+3] == 'H') { PUSH(op_stack, op_sinh); i+=3; } else { PUSH(op_stack, op_sin); i+=2; } } else if(!len_strncmp(expr + i, &quot;TAN&quot;)) { if(expr[i+3] == 'H') { PUSH(op_stack, op_tanh); i+=3; } else { PUSH(op_stack, op_tan); i+=2; } } else if(!len_strncmp(expr + i, &quot;EXP&quot;)) { PUSH(op_stack, op_exp); i+=2; } else if(!len_strncmp(expr + i, &quot;LOG&quot;)) { PUSH(op_stack, op_log); i+=2; } else if(!len_strncmp(expr + i, &quot;SQRT&quot;)) { PUSH(op_stack, op_sqrt); i+=3; } else if(!len_strncmp(expr + i, &quot;FABS&quot;)) { PUSH(op_stack, op_fabs); i+=3; } else if(!len_strncmp(expr + i, &quot;CEIL&quot;)) { PUSH(op_stack, op_ceil); i+=3; } else if(!len_strncmp(expr + i, &quot;FLOOR&quot;)) { PUSH(op_stack, op_floor); i+=4; } else { logger(ERR_LOG, &quot;Error: unknown char(%c)&quot;, expr[i]); exit(1); } break; } i++; logStack(); } biCheck(); pushOP(0); logStack(); return stack[0];}void INIT(char **argv) { int i = 0; _y1 = eval(0, 0, argv[i++]); _y2 = eval(0, 0, argv[i++]); s1 = eval(0, 0, argv[i++]); x1 = eval(0, 0, argv[i++]); x2 = eval(0, 0, argv[i++]); s2 = eval(0, 0, argv[i++]); logger(DEBUG_LOG, &quot;%lf, %lf, %lf, %lf, %lf, %lf\\n&quot;, _y1, _y2, s1, x1, x2, s2);}int main(int argc, char **argv) { if(argc &lt; 8) { logger(INFO_LOG, &quot;Usage: %s y1 y2 sy x1 x2 sy expression&quot;, argv[0]); logger(INFO_LOG, &quot;example: %s -1 1 0.125 -1 1 0.0625 \\&quot;x*x+y*y-1\\&quot; 2&gt;errs.log&quot;, argv[0]); logger(INFO_LOG, &quot;example: %s \\&quot;-pi/2\\&quot; \\&quot;pi/2\\&quot; 0.25 \\&quot;-3*pi\\&quot; \\&quot;2*pi\\&quot; 0.125 \\&quot;y^2-SIN(x+y)^2\\&quot; 2&gt;errs.log&quot;, argv[0]); logger(INFO_LOG, &quot;example: %s \\&quot;-pi/2\\&quot; \\&quot;pi/2\\&quot; 0.25 \\&quot;-3*pi\\&quot; \\&quot;2*pi\\&quot; 0.125 \\&quot;y^2-SIN(x)^2\\&quot; 2&gt;errs.log&quot;, argv[0]); logger(INFO_LOG, &quot;example: %s \\&quot;-2\\&quot; \\&quot;ACOS(1/2)-pi/4\\&quot; 0.125 \\&quot;-pi/2\\&quot; \\&quot;pi/2\\&quot; 0.0625 \\&quot;y*y+x*x+y-SQRT(y*y+x*x)\\&quot; 2&gt;errs.log&quot;, argv[0]); logger(INFO_LOG, &quot;example: %s \\&quot;-pi\\&quot; \\&quot;1\\&quot; 0.125 \\&quot;-2\\&quot; \\&quot;2\\&quot; 0.0625 \\&quot;(ACOS(1-FABS(x))-pi)-y\\&quot; \\&quot;y-SQRT(1-(FABS(x)-1)^2)\\&quot; 2&gt;errs.log&quot;, argv[0]); logger(INFO_LOG, &quot;example: %s \\&quot;-1\\&quot; \\&quot;pi/2\\&quot; 0.125 \\&quot;-1\\&quot; \\&quot;1\\&quot; 0.0625 \\&quot;x*x+(y-FABS(x)^(2.0/3.0))^2-1\\&quot; 2&gt;errs.log&quot;, argv[0]); exit(0); } INIT(argv + 1); for(double i = _y2; i &gt;= _y1; ) { for(double j = x1; j &lt;= x2; ) { logger(DEBUG_LOG, &quot;x = %lf, y = %lf&quot;, j, i); bool ok = true; for(char **expr = argv + 7; *expr; expr++) { if(eval(i, j, *expr) &gt;= 0) { ok = false; break; } } if(ok) { printf(&quot;%c&quot;, SMALLER_CHAR); } else { printf(&quot;%c&quot;, GREATER_CHAR); } j+=s2; } printf(&quot;\\n&quot;); i-=s1; }} example圆1234567891011121314151617..........................................+++++++++++++++...............+++++++++++++++++++++..........+++++++++++++++++++++++++.......+++++++++++++++++++++++++++.....+++++++++++++++++++++++++++++...+++++++++++++++++++++++++++++++..+++++++++++++++++++++++++++++++..+++++++++++++++++++++++++++++++..+++++++++++++++++++++++++++++++..+++++++++++++++++++++++++++++++...+++++++++++++++++++++++++++++.....+++++++++++++++++++++++++++.......+++++++++++++++++++++++++..........+++++++++++++++++++++...............+++++++++++++++.......................................... 糖葫芦12345678910111213............................................................................................................................................................................................................................................................................................................................................................................................+++++++++................+++++++++................++++++++++...............++++++++++...............++++++++++...............+++++++++++++++..........+++++++++++++++..........+++++++++++++++..........++++++++++++++++.........++++++++++++++++..........+++++++++++++++++++......++++++++++++++++++++.....++++++++++++++++++++.....++++++++++++++++++++.....++++++++++++++++++++......+++++++++++++++++++++++..++++++++++++++++++++++++.++++++++++++++++++++++++.++++++++++++++++++++++++.++++++++++++++++++++++++....+++++++++++++++++++++++...++++++++++++++++++++++...++++++++++++++++++++++...++++++++++++++++++++++...++++++++++++++++++++++.......+++++++++++++++++++.......++++++++++++++++++.......++++++++++++++++++.......++++++++++++++++++.......++++++++++++++++++............+++++++++++++............+++++++++++++............+++++++++++++............+++++++++++++............++++++++++++++.................+++++++...................++++++...................++++++...................++++++...................++++++.............................................................................................................................................................................................................................................................. 这个手机上的mathlab都画不了 糖葫芦112345678910111213..................................................................................................................................................................................................................................................................................................................................................................................................++++++++++...............++++++++++...............++++++++++................+++++++++................+++++++++.............++++++++++++++++.........++++++++++++++++..........+++++++++++++++..........+++++++++++++++..........+++++++++++++++........++++++++++++++++++++.....++++++++++++++++++++.....++++++++++++++++++++......+++++++++++++++++++......++++++++++++++++++++...++++++++++++++++++++++++.++++++++++++++++++++++++.++++++++++++++++++++++++.++++++++++++++++++++++++..++++++++++++++++++++++++..++++++++++++++++++++++...++++++++++++++++++++++...++++++++++++++++++++++...+++++++++++++++++++++++..+++++++++++++++++++++++.....++++++++++++++++++.......++++++++++++++++++.......++++++++++++++++++.......++++++++++++++++++........++++++++++++++++++.........++++++++++++++............+++++++++++++............+++++++++++++............+++++++++++++............+++++++++++++................++++++...................++++++...................++++++...................++++++....................++++++..................................................................................................................................................................................................................................................................... 笛卡尔心12345678910111213141516171819...............................................................++++++++++++...++++++++++++......................+++++++++++++++++++++++++++++++..................+++++++++++++++++++++++++++++++++++...............+++++++++++++++++++++++++++++++++++++.............+++++++++++++++++++++++++++++++++++++++...........+++++++++++++++++++++++++++++++++++++++++..........+++++++++++++++++++++++++++++++++++++++++..........+++++++++++++++++++++++++++++++++++++++++..........+++++++++++++++++++++++++++++++++++++++++..........+++++++++++++++++++++++++++++++++++++++++...........+++++++++++++++++++++++++++++++++++++++.............++++++++++++++++++++++++++++++++++++++..............++++++++++++++++++++++++++++++++++++................+++++++++++++++++++++++++++++++++....................++++++++++++++++++++++++++++++.......................+++++++++++++++++++++++++.............................+++++++++++++++++++.......................................+++++....................... 心12345678910111213141516171819202122232425262728293031323334..........................................................................+++++++++++++++.................+++++++++++++++...............+++++++++++++++++++++...........+++++++++++++++++++++..........+++++++++++++++++++++++++.......+++++++++++++++++++++++++.......+++++++++++++++++++++++++++.....+++++++++++++++++++++++++++.....+++++++++++++++++++++++++++++...+++++++++++++++++++++++++++++...+++++++++++++++++++++++++++++++.+++++++++++++++++++++++++++++++..+++++++++++++++++++++++++++++++.+++++++++++++++++++++++++++++++..+++++++++++++++++++++++++++++++.+++++++++++++++++++++++++++++++..+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++..+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++...+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++....+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++......+++++++++++++++++++++++++++++++++++++++++++++++++++++++++.........+++++++++++++++++++++++++++++++++++++++++++++++++++++++...........+++++++++++++++++++++++++++++++++++++++++++++++++++++..............+++++++++++++++++++++++++++++++++++++++++++++++++..................+++++++++++++++++++++++++++++++++++++++++++++.....................+++++++++++++++++++++++++++++++++++++++++++........................+++++++++++++++++++++++++++++++++++++++............................+++++++++++++++++++++++++++++++++++................................+++++++++++++++++++++++++++++++....................................+++++++++++++++++++++++++++........................................+++++++++++++++++++++++............................................+++++++++++++++++++................................................+++++++++++++++....................................................+++++++++++.......................................................+++++++++.........................................................+++++++...........................................................+++++.............................................................+++...............................................................+................................................................+................................................................+................................ 还是心123456789101112131415161718192021....................................++++++++...........++++++++.....+++++++++++.......+++++++++++...++++++++++++++...++++++++++++++..+++++++++++++++.+++++++++++++++..+++++++++++++++++++++++++++++++..+++++++++++++++++++++++++++++++..+++++++++++++++++++++++++++++++...+++++++++++++++++++++++++++++....+++++++++++++++++++++++++++++.....+++++++++++++++++++++++++++.......+++++++++++++++++++++++++.........+++++++++++++++++++++++............+++++++++++++++++++...............+++++++++++++++++.................+++++++++++++++....................+++++++++++.......................+++++++++..........................+++++.............................+++...............................+................ 九心连珠12345678N=5size=1for i in `seq $N`; do ./a.out &quot;-pi&quot; &quot;1&quot; 0.04 &quot;-2/$size&quot; &quot;2/$size&quot; 0.02 &quot;(ACOS(1-FABS($size*x))-pi)-$size*y&quot; &quot;$size*y-SQRT(1-(FABS($size*x)-1)^2)&quot; 2&gt;errs.log 1&gt;out.$i size=$(echo &quot;scale = 8; $size * sqrt(2)&quot; | bc) echo $sizedonepaste `for i in $(seq $N | tr ' ' '\\n'| tac | tr '\\n' ' '); do echo out.$i; done;for i in $(seq 2 $N); do echo out.$i; done` &gt; out.paste 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 +++++++++++++++++++++++ +++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++ ++++++ +++++++ ++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++ ++++++ +++++++ ++++++++++++++++++++ ++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++ ++++++++++++++++++++ +++++++++++++++++++++++++++ +++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++ +++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++ +++++++++++++ ++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++ +++++++++++++ +++++++++++++ ++++++++++++++++++++ ++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++ ++++++++++++++++++++ +++++++ ++++++ ++++++++++++++++++++++++ +++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++ +++++++++++++++++++++++++ +++++++ ++++++ ++++++++++++++ ++++++++++++++ ++++++++++++++++++++++++++++ +++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++ +++++++++++++++++++++++++++ ++++++++++++++ ++++++++++++++ ++++++++ +++++++ +++++++++++++++++++ ++++++++++++++++++ ++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++ +++++++++++++++++++ ++++++++++++++++++ ++++++++ +++++++ +++++++++++++ +++++++++++++ +++++++++++++++++++++ +++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++ +++++++++++++++++++++ +++++++++++++++++++++ +++++++++++++ +++++++++++++ +++++++++++++++ +++++++++++++++ +++++++++++++++++++++++ ++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++ +++++++++++++++++++++++ ++++++++++++++++++++++ +++++++++++++++ +++++++++++++++ +++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++ +++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++ ++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++ ++++++++++++++++++ ++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++ ++++++++++++++++++ ++++++++++++++ +++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++ ++++++++++++++ ++++++++++ ++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++ ++++++++++ ++++++ ++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++ ++++++ ++++ ++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++ ++++ ++ ++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++ ++ ++++++++++++ ++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++ ++++++++++++ ++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ ++++++++ ++++++ ++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++ ++++++ ++++ ++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++ ++++ ++ ++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++ ++ +++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++ ++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++ ++++++++++ ++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++ ++++++++++ ++++++++ ++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++ ++++++++ ++++++ ++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++ ++++++ ++++ ++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ ++++ ++ +++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++ ++ + +++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++ + +++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++ ++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++ +++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++ ++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++ +++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++ +++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++ +++++ ++++++++++++++++++++++++++++++++++++++++++++++ +++++ +++ ++++++++++++++++++++++++++++++++++++++++++ +++ ++ +++++++++++++++++++++++++++++++++++++++ ++ + +++++++++++++++++++++++++++++++++++ + + ++++++++++++++++++++++++++++++++ + ++++++++++++++++++++++++++++ +++++++++++++++++++++++++ ++++++++++++++++++++++ +++++++++++++++++++ ++++++++++++++++ ++++++++++++++ ++++++++++++ ++++++++++ ++++++++ ++++++ ++++ +++ ++ + 支持生成png支持生成图片，精确度大大提高了，可以考虑绘制曲线而不是区域了 设置一个精确度，计算结果绝对值小于他的都被认为是0，就可以画曲线了 问题1$y-sqrt(x)=0$在$x=0$附近断断续续 实际上是这个地方变化率太高，x、y的轻微变化导致超出了精确度，有些地方$\\frac{dz}{dy}$过大而$\\frac{dz}{dx}$不大时（或二者都很大时），也会断断续续，然而当计算时的xy坐标选取在当前像素点内的某个位置时，可能就可以小于精确度。令$z=y-sqrt(x)$，分别计算z对x，y的偏导，计算上下左右四个方向的取最大值。计算点$(x+i/max(\\frac{dz}{dx},\\frac{dz}{dy}),y+i/max(\\frac{dz}{dx},\\frac{dz}{dy}))$处的函数值，若小于精确度，对该像素点绘制，否则不绘制其中$1&lt;i&lt;max(\\frac{dz}{dx},\\frac{dz}{dy})$ 问题2在某些曲线的交点处，如$y^2-sin(x)^2=0$，当$x=k*pi$时，线条很粗 实际上是这个地方变化率太低，x或y的变化无法引起z的变化超过设定的变化率时，就会出现这种情况，令$z=y^2-sin(x)^2$，分别计算z对x，y的变化量的绝对值$|z(x_0+dx,y_0) - z(x_0,y_0)$,$|z(x_0,y_0+dy) - z(x_0,y_0)$,$|z(x_0-dx,y_0) - z(x_0,y_0)$,$|z(x_0,y_0-dy) - z(x_0,y_0)$，将精确度设置为变化量绝对值的最大值即可,对于导数非常大的位置，会导致精确度被无限放大，此时精确度不许大于$max(dx,dy)$","link":"/home/2023/10/22/misc/c%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E7%BB%98%E5%9B%BE/"},{"title":"git的使用","text":"版本控制发展历史本地代码版本控制RCS: 只能保存本地的变化情况，无法协同合作 集中式版本控制SVN: 远端服务器维护版本，本地不保存代码版本 分布式版本控制git: 每个仓库都记录版本历史，解决一个服务器挂掉导致所有历史版本丢失的问题 cherry-pickfast-forward","link":"/home/2024/05/07/misc/git%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"PAT-Basic-1084","text":"题目 外观数列是指具有以下特点的整数序列： 1d, d1, d111, d113, d11231, d112213111, ... 它从不等于 1 的数字 d 开始，序列的第 n+1 项是对第 n 项的描述。比如第 2 项表示第 1 项有 1 个 d，所以就是 d1；第 2 项是 1 个 d（对应 d1）和 1 个 1（对应 11），所以第 3 项就是 d111。又比如第 4 项是 d113，其描述就是 1 个 d，2 个 1，1 个 3，所以下一项就是 d11231。当然这个定义对 d = 1 也成立。本题要求你推算任意给定数字 d 的外观数列的第 N 项。 输入格式： 输入第一行给出 [0,9] 范围内的一个整数 d、以及一个正整数 N（≤ 40），用空格分隔。 输出格式： 在一行中给出数字 d 的外观数列的第 N 项。 输入样例：11 8 输出样例：11123123111 通过代码12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;void add(string&amp; str, char c, int&amp; n) { char toNum[1024] = {0}; str.append(&amp;c, 1);//这样可以“骗”append函数c是只有一个字符的字符串 sprintf(toNum, &quot;%d&quot;, n); str.append(toNum); n = 0;}int main () { string d; int n; cin &gt;&gt; d &gt;&gt; n; string&amp; temp = d;//建立一个对字符串的引用，循环的时候可以避免拷贝 for (int i = 0, count = 1; i &lt; n - 1; i++, count = 1) { string next = &quot;&quot;; for (int j = 1; j &lt; temp.length(); j++, count++) if (temp[j - 1] != temp[j]) add(next, temp[j - 1], count); add(next, temp[temp.length() - 1], count); temp = next; } cout &lt;&lt; temp &lt;&lt; endl; return 0;} 思路和注意 读懂题很关键第n+1项是对第n项的描述 就是遍历前一项，数出连续的某个字符c有几个，然后自己就变成了c + c的个数 这道题的核心算法和PAT乙级题–1078 字符串压缩与解压的压缩部分的算法类似","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1084-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97(PAT-(Basic-Level)-Practice)/"},{"title":"显卡驱动踩坑","text":"nvidia显卡驱动踩坑 之前更新了一次linux的内核，导致内核的显卡冲突了，hdmi没有输出，nvidia-smi命令也没了 重装了nvidia的显卡，发现默认使用核显，动画非常卡 后来屏蔽了linux自带的驱动nouveau，hdmi终于有输出了，显卡驱动的daemon也可以使用了(nvidia-smi输出正常)，但是自带的显示器却不能用了 解决方法 /etc/X11/xorg.conf文件不知道什么原因出现了错误，把这个文件内容清空，就好了 重启后发现这个文件里面本身就没东西","link":"/home/2022/10/28/linux/%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8%E8%B8%A9%E5%9D%91/"},{"title":"shell的使用","text":"shell fuction函数定义 定义1xxx.sh123function funcName() { # do sth} 定义2xxx.sh1234f2() { value=$(($1+$2+1)) echo $1 &quot;+&quot; $2 &quot;=&quot; $value} 传参xxx.sh1234function funcName() { echo $1 # 打印第一个参数 echo $2 # 打印第二个参数} 调用 直接在脚本中调用 xxx.sh12345function funcName() { echo $1 # 打印第一个参数 echo $2 # 打印第二个参数}funcName 刘喵喵 大帅哥 在shell中调用 shell12. xxx.sh # import导入其中的函数funcName 刘喵喵 大帅哥 如果function写在/etc/profile、~/.bashrc下，则可以直接调用 应用 有了以上方法，在bashrc中将自己常用但容易遗忘的命令写成函数，就可以方便的调用了 如果函数忘了，，那就可以去~/.bashrc下看看😅x1 如果忘记去哪里看了，，，那就来看看这篇文章😅x2 如果忘记这篇文章，，，那我直接😅x3 ~/.bashrc12345678function setgitproxy() { git config --global http.proxy 'socks5h://localhost:7890' git config --global https.proxy 'socks5h://localhost:7890'}function unsetgitproxy() { git config --global --unset http.proxy git config --global --unset https.proxy} ubuntu中创建unitsystemctlsystemctl 提供了一组子命令来管理单个的 unit，其命令格式为： 1systemctl [command] [unit] 创建unit 编写.service文件1sudo vim /etc/systemd/system/xxx.service xxx.service1234567891011[Unit]Description=clash daemon[Service]Type=simpleUser=rootExecStart=/opt/xxx/xxx -d /etc/xxx/ #start时执行的命令Restart=on-failure[Install]WantedBy=multi-user.target 重新加载systemctl daemon 1sudo systemctl daemon-reload 启动service 1sudo systemctl start xxx.service 设置为开机启动 1sudo systemctl enable xxx.service","link":"/home/2022/10/27/linux/shell/"},{"title":"shell编程相关","text":"kill僵尸进程 强制kill掉其父进程，但是会导致shell也死掉1ps -ef | grep defunct | awk '{ len=split($0, a, &quot; &quot;);print a[3]; }' | xargs kill -9","link":"/home/2023/04/20/misc/shell%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3/"},{"title":"geth搭建私链","text":"主要工作参考go-ethereum官网的Private Networks文档搭建了一个私有链，并总结出几个脚本，可以半自动化地实现geth网络的搭建，脚本已上传至github仓库DLCCB setup.sh 这一步使用了以下几个工具 geth命令，用于生成初始两个节点的账户，使用创世块配置文件对两个账户进行初始化 puppeth 用于生成创世块的配置文件，这个命令是交互式的，编写了一个puppeth.txt作为其输入，默认生成一个基于pow的区块链 bootnode 用于生成启动bootnode 这一步使用了以下几个linux命令 sed 非交互式的文本编辑器，用于读取生成的账户的区块链地址，写入puppeth.txt中，使得puppeth工具能为初始的两个节点分配一定的以太币 awk，用于对文本的处理 setup.sh123456789101112131415161718mkdir node1 node2geth --datadir node1 account new &lt; password.txtgeth --datadir node2 account new &lt; password.txtsed -i &quot;5i$(cat node1/keystore/UTC--* | awk '{split($0, arr, &quot;\\&quot;&quot;); print arr[4]}')&quot; puppeth.txt sed -i &quot;5i$(cat node2/keystore/UTC--* | awk '{split($0, arr, &quot;\\&quot;&quot;); print arr[4]}')&quot; puppeth.txt puppeth &lt; puppeth.txtsed -i &quot;5d&quot; puppeth.txtsed -i &quot;5d&quot; puppeth.txtgeth init --datadir node1 tianer.jsongeth init --datadir node2 tianer.jsoncat password.txt | head -n 1 | tee node1/password.txtcat password.txt | head -n 1 | tee node2/password.txtbootnode -genkey boot.keybootnode -nodekey boot.key -addr :30305 两个输入文件的内容password.txt1212345678901234567890 这里两个节点的密码是相同的，也可以单独为每个节点写一个密码文件，但是密码文件必须两行相同，因为创建账户时需要输入两次密码 puppeth.txt123456789101112tianer211yes123452223 从上到下依次对配置创世块的配置文件进行创建，导出保存，删除。会使用sed命令在第五行临时插入刚刚生成的账户文件的区块链地址，这样puppeth命令就知道要给哪些地址分配初始的以太币 sed命令sed 命令是一个面向行处理的工具，它以“行”为处理单位，针对每一行进行处理，处理后的结果会输出到标准输出（STDOUT）。你会发现 sed 命令是很懂礼貌的一个命令，它不会对读取的文件做任何贸然的修改，而是将内容都输出到标准输出中。 基本用法 1sed [选项] &quot;指令&quot; 文件 选项，如果希望sed命令对文件直接进行更改，需要添加-i参数， 以下是几个查那个用的参数 -e –它告诉sed将下一个参数解释为一个sed指令，只有当命令行上给出多个sed指令时使用 -f –后跟保存了sed指令的文件 -i –直接对内容进行修改，不加 i 时默认只是预览，不会对文件进行实际修改 -n –取消默认输出，sed默认会输出所有文本内容，使用 -n 参数后只显示处理过的行 指令，类似vim，sed也有编辑命令 a –追加，向匹配行后插入内容 c –更改，更改匹配行的内容 i –插入，向匹配行前插入内容 d –删除，删除匹配的内容 s –替换，替换匹配到的内容 p –打印，打印匹配到的内容，通常与 -n 和用 = –用来打印被匹配到的行的行号 n –读取下一行，遇到n时会自动跳入下一行 r,w –读和写，r用于将内容读入文件，w用于将匹配内容写入到文件 其中s命令后跟正则串和目标串，可以起到文本的匹配替换sed的指令使用/作为定界符，转义符为\\ 例子： 1234sed -i 's/book/books/' filesed -i 's/book/books/g' file # 后缀g对每行的所有匹配进行替换sed -i '2d' file #删除指定行sed -i '5ixxxxx' file #在指定行插入xxxxx 具体可以参考这里 awk命令AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。之所以叫 AWK 是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符linux中有三剑客之称：三剑客之首就是 AWK三剑客功能:grep ： 过滤文本sed : 修改文本awk : 处理文本 语法格式 1awk [参数] [处理内容] [操作对象] 具体可以参考这里 mine.sh用于启动创建的两个节点 mine.sh12345678NODE=$2ENODE=$1AUTHRPCPORT=$(($2+8554))PORT=$(($2+30308))echo geth --datadir node$NODE --port $PORT --bootnodes $ENODE --networkid 12345 --unlock 0x$(cat node$NODE/keystore/UTC--* | awk '{split($0, arr, &quot;\\&quot;&quot;); print arr[4]}') --password node1/password.txt --authrpc.port $AUTHRPCPORTgeth --datadir node$NODE --port $PORT --bootnodes $ENODE --networkid 12345 --unlock 0x$(cat node$NODE/keystore/UTC--* | awk '{split($0, arr, &quot;\\&quot;&quot;); print arr[4]}') --password node1/password.txt --authrpc.port $AUTHRPCPORT --mine 前一个脚本执行后，会输出enode， 将其复制下来，打开两个新的terminal窗口，enode作为这个脚本的第一个参数，第二个参数是希望启动的节点的编号 attach.sh用于让两个节点开始挖矿，使用geth attach打开js交互界面，miner.txt作为输入文件，执行命令miner.start(1)开始挖矿 attach.sh123NODE=$1echo geth attach node$NODE/geth.ipcgeth attach node$NODE/geth.ipc &lt; miner.txt 参数为希望开始挖矿的节点编号，也需要打开新的terminal执行 miner.txt123net.peerCounteth.getBalance(eth.accounts[0])miner.start(1) sk.js用于获取节点的私钥，在开发时私钥很重要 sk.js1234567var keythereum = require(&quot;keythereum&quot;);var datadir = &quot;/home/tt/eth/net/node2/&quot;;var address= &quot;e43b98ac32beb344c94b15b9af5b46674d6c3e6d&quot;;//要小写const password = &quot;1234567890&quot;;var keyObject = keythereum.importFromFile(address, datadir);var privateKey = keythereum.recover(password, keyObject);console.log(privateKey.toString('hex')); 需要节点的datadir和节点的address","link":"/home/2023/01/10/misc/geth%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E9%93%BE/"},{"title":"hexo配置&amp;踩坑&amp;自定义","text":"git deplyerref 文章目录 icarus的文章目录只有二级标题开始才可以跳转 阅读更多按钮 安装hexo-excerpt插件 live2d 安装这个hexo-helper-live2d 代码块123{% codeblock filename lang:code-lang %} your code here...{% endcodeblock %} gittalk 按照教程创建gittalk，填写配置文件 官方教程 注意这里的repo是仓库名字，不是repo的url，不是repo的名称 通过f12的network发现发送的是apiurl+repo _config.icaruc.yml12345678910111213141516comment: type: gitalk client_id: xxxxxxxxxxxxxxxxxxxx client_secret: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx repo: Some-of-Your-GitHub-Repo # 这里是repo的名字，不是url owner: you_github_name admin: - you_github_name per_page: 20 # 可选填 distraction_free_mode: false # 可选填 pager_direction: last # 可选填 create_issue_manually: false # 可选填 proxy: # 可选填 flip_move_options: # 可选填 enable_hotkey: true # 可选填 language: zh-CN # 可选填 同时，在_config.yml下配置gitalk _config.yml12345678gitalk: enable: true #默认的是false，没有打开 owner: 'github name' repo: 'repo name' oauth: clientId: 'clientId' clientSecret: 'clientSecret' admin: ['githubname'] fairyDust 鼠标特效在source/js下创建文件fairyDustCursor.js source/js/fairyDustCursor.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123(function fairyDustCursor() { var possibleColors = [&quot;#D61C59&quot;, &quot;#E7D84B&quot;, &quot;#1B8798&quot;] var width = window.innerWidth; var height = window.innerHeight; var cursor = { x: width / 2, y: width / 2 }; var particles = []; function init() { bindEvents(); loop(); } // Bind events that are needed function bindEvents() { document.addEventListener('mousemove', onMouseMove); document.addEventListener('touchmove', onTouchMove); document.addEventListener('touchstart', onTouchMove); window.addEventListener('resize', onWindowResize); } function onWindowResize(e) { width = window.innerWidth; height = window.innerHeight; } function onTouchMove(e) { if (e.touches.length &gt; 0) { for (var i = 0; i &lt; e.touches.length; i++) { addParticle(e.touches[i].clientX, e.touches[i].clientY, possibleColors[Math.floor(Math.random() * possibleColors.length)]); } } } function onMouseMove(e) { cursor.x = e.clientX; cursor.y = e.clientY; addParticle(cursor.x, cursor.y, possibleColors[Math.floor(Math.random() * possibleColors.length)]); } function addParticle(x, y, color) { var particle = new Particle(); particle.init(x, y, color); particles.push(particle); } function updateParticles() { for (var i = 0; i &lt; particles.length; i++) { particles[i].update(); } for (var i = particles.length - 1; i &gt;= 0; i--) { if (particles[i].lifeSpan &lt; 0) { particles[i].die(); particles.splice(i, 1); } } } function loop() { requestAnimationFrame(loop); updateParticles(); } function Particle() { this.character = &quot;*&quot;; this.lifeSpan = 120; //ms this.initialStyles = { &quot;position&quot;: &quot;fixed&quot;, &quot;top&quot;: &quot;0&quot;, //必须加 &quot;display&quot;: &quot;block&quot;, &quot;pointerEvents&quot;: &quot;none&quot;, &quot;z-index&quot;: &quot;10000000&quot;, &quot;fontSize&quot;: &quot;20px&quot;, &quot;will-change&quot;: &quot;transform&quot; }; this.init = function (x, y, color) { this.velocity = { x: (Math.random() &lt; 0.5 ? -1 : 1) * (Math.random() / 2), y: 1 }; this.position = { x: x - 10, y: y - 20 }; this.initialStyles.color = color; console.log(color); this.element = document.createElement('span'); this.element.innerHTML = this.character; applyProperties(this.element, this.initialStyles); this.update(); document.body.appendChild(this.element); }; this.update = function () { this.position.x += this.velocity.x; this.position.y += this.velocity.y; this.lifeSpan--; this.element.style.transform = &quot;translate3d(&quot; + this.position.x + &quot;px,&quot; + this.position.y + &quot;px,0) scale(&quot; + (this.lifeSpan / 120) + &quot;)&quot;; } this.die = function () { this.element.parentNode.removeChild(this.element); } } function applyProperties(target, properties) { for (var key in properties) { target.style[key] = properties[key]; } } init();})(); 修改node_modules/hexo-theme-icarus/layout下的layout.jsx，在body中引用这个js文件 node_modules/hexo-theme-icarus/layout/layout.jsx1&lt;script type=&quot;text/javascript&quot; src=&quot;/home/js/fairyDustCursor.js&quot;&gt;&lt;/script&gt; 点击特效编写产生点击特效的js文件 source/js/textPopup.js12345678910111213141516171819202122232425262728293031323334var colors = new Array(&quot;#FF0000&quot;,&quot;#FF7F00&quot;,&quot; #FFFF00&quot;,&quot;#00FF00&quot;,&quot;#00FFFF&quot;,&quot;#0000FF&quot;,&quot;#8B00FF&quot;,&quot;#FF0000&quot;,&quot;#FF7F00&quot;,&quot; #FFFF00&quot;,&quot;#00FF00&quot;,&quot;#00FFFF&quot;,&quot;#0000FF&quot;,&quot;#8B00FF&quot;);var fnTextPopup = function (arr, options) { // arr参数是必须的 if (!arr || !arr.length) { return; } // 主逻辑 var index = 0; document.documentElement.addEventListener('click', function (event) { var x = event.pageX, y = event.pageY; var eleText = document.createElement('span'); eleText.className = 'text-popup'; this.appendChild(eleText); if (arr[index]) { eleText.innerHTML = arr[index]; } else { index = 0; eleText.innerHTML = arr[0]; } // 动画结束后删除自己 eleText.addEventListener('animationend', function () { eleText.parentNode.removeChild(eleText); }); // 位置 eleText.style.left = (x - eleText.clientWidth / 2) + 'px'; eleText.style.top = (y - eleText.clientHeight) + 'px'; //设置颜色 eleText.style.color = colors[index%14] // index递增 index++; });};fnTextPopup(['富强', '民主', '文明', '和谐', '自由', '平等', '公正', '法治', '爱国', '敬业', '诚信', '友善']); 编写css文件 source/css/textPopup.css123456789101112131415161718.text-popup { animation: textPopup 1s; user-select: none; white-space: nowrap; position: absolute; z-index: 99;}@keyframes textPopup { 0%, 100% { opacity: 0; } 5% { opacity: 1; } 100% { transform: translateY(-50px); }} 在layout.jsx中引用 node_modules/hexo-theme-icarus/layout/layout.jsx12&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/home/css/textPopup.css&quot; /&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/home/js/textPopup.js&quot;&gt;&lt;/script&gt; RSS生成插件，增加RSS订阅按钮 安装一个插件，用来生成atom.xml文件 1npm install --save hexo-generator-feed 配置插件 head下增加rss配置_config.icarus.yml12head: rss: /atom.xml 增加对插件的配置_config.yml123456789# Extensionsplugins: hexo-generator-feed#Feed Atomfeed: type: atom path: atom.xml limit: 20rss: /atom.xml 配置RSS按钮_config.icarus.yml1234social_links: RSS: icon: fa fa-rss url: /atom.xml 优化RSS按钮上面配置点击rss按钮，如果浏览器没有安装rss相关插件，会直接显示atom.xml的原始样式，不美观，利用js实现点击rss按钮将订阅链接复制到剪切板 source/js/clickClipBoard.js123456789101112131415161718192021222324function copyToClipboard(text, callBack) { navigator.clipboard.writeText(text).then( value =&gt; { // fulfillment callBack() }, reason =&gt; { // rejection alert(&quot;fail: &quot; + reason) } )}$(document).ready(function() { var buttons = document.getElementsByClassName(&quot;button&quot;) for (let i = 0; i &lt; buttons.length; i++) { if (buttons[i].getAttribute(&quot;title&quot;) == &quot;RSS&quot;) { var url = document.baseURI + &quot;atom.xml&quot; buttons[i].href = &quot;javascript:;&quot; buttons[i].target = &quot;_self&quot; buttons[i].setAttribute('onclick', &quot;copyToClipboard(\\&quot;&quot; + url + &quot;\\&quot;, function() { alert(\\&quot;copied to clipboard\\&quot;) })&quot;) break } }}) 修复插件的问题 插件生成的xml文件中，博客的baseUrl不对，应该是jingtianer.github.io 它生成的是github.com/jingtianer 生成后使用脚本替换 其实是配置文件里写错了 deploy.sh1sed -i 's/github.com\\/jingtianer/jingtianer.github.io/g' public/atom.xml 代码块复制按钮优化 icarus的代码块复制按钮点击后只会选中代码，希望点击后能自动复制到剪切板 source/js/clickClipBoard.js12345678910111213141516171819202122232425262728293031323334353637function copyToClipboard(text, callBack) { navigator.clipboard.writeText(text).then( value =&gt; { // fulfillment callBack() }, reason =&gt; { // rejection alert(&quot;fail: &quot; + reason) } )}$(document).ready(function() { $(&quot;.copy&quot;).click(function() { copyCode(this) })})function copyCode(element) { if (element instanceof Element) { var elemt = element while(elemt.tagName != &quot;FIGURE&quot;) { elemt = elemt.parentElement } elemt = elemt.getElementsByClassName(&quot;code&quot;)[0] var text =elemt.innerText copyToClipboard(text, function() { var node = $(element.childNodes[0]) node.attr('class', &quot;fa fa-check&quot;) setTimeout(function () { node.attr('class', &quot;fas fa-copy&quot;) } ,1000) }) } } hexo-pdf 地址 usage1{% pdf ./bash_freshman.pdf %} mermaid.js支持安装hexo-filter-mermaid-diagrams1npm install hexo-filter-mermaid-diagrams 编写mermaidInitializer.js，并添加到layout.jsx中source/js/mermaidInitializer.js12345import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.6.0/+esm'function initMermaid() { mermaid.initialize({ startOnLoad: true })}initMermaid() layout.jsx1&lt;script type=&quot;module&quot; src=&quot;/home/js/mermaidInitializer.js&quot;&gt;&lt;/script&gt; 测试一下graph TD A[开始] --> B{条件判断} B -->|是| C[执行操作] B -->|否| D[结束] C --> D","link":"/home/2022/10/26/misc/hexo%E9%85%8D%E7%BD%AE&%E8%B8%A9%E5%9D%91&%E8%87%AA%E5%AE%9A%E4%B9%89/"},{"title":"牛客刷题-1","text":"小米2019秋招安卓开发笔试题（B）21. 最少立方数之和给出一个数字N（0&lt;N&lt;1000000）,将N写成立方数和的形式，求出需要的最少立方数个数。例如N=17，1+8+8 = 17，最少需要3个立方数，则输出3。N= 28,1+1+1+1+8+8+8=28, 需要7个立方数，1+27=28,需要2个立方数，所以最少立方数为2，则输出2。 12345678910111213141516171819202122232425262728293031323334353637import java.util.*; // 注意类名必须为 Main, 不要有任何 package xxx 信息public class Main { private static final List&lt;Integer&gt; cubs; private static final int cubNum; static { cubs = new ArrayList&lt;Integer&gt;(); for(int i = 1; i*i*i &lt;= 1000000; i++) { cubs.add(i*i*i); } cubNum = cubs.size(); } public static void main(String[] args) { Scanner in = new Scanner(System.in); // 注意 hasNext 和 hasNextLine 的区别 while (in.hasNextInt()) { // 注意 while 处理多个 case int n = in.nextInt(); int index = Collections.binarySearch(cubs, n); if(index &lt; 0) { index = -index - 2; } if(index &lt; 0) { throw new RuntimeException(&quot;unreachable&quot;); } int[] dp = new int[n+1]; Arrays.fill(dp, Integer.MAX_VALUE); dp[0] = 0; for(int j = 1; j &lt;= index+1; j++) { for(int i = cubs.get(j-1); i &lt;= n; i++) { dp[i] = Math.min(dp[i], dp[i - cubs.get(j-1)] + 1); } } System.out.println(dp[n]); } }} 完全背包，从所有立方数里选数，取数目最小的情况 资产包打包在金融资产交易中，经常涉及到资产包的挑选打包。在资产包打包过程中，每种类型的资产有固定的数量与价值，需选择某几种资产打包，使得资产包总价值最大。打包时每种资产只能整体打包，不能分割。假设现有可容纳M条资产的资产包，另外有N种资产。资产Na数量为Ta条，总价值为Va元；资产Nb数量为Tb条，总价值为Vb元；资产Nc数量为Tc条，总价值为Vc元……；资产Nn数量为Tn，总价值为Vn。编写算法，挑选哪些类型资产放入资产包可使得资产包总价值最大？ 12345678910111213141516171819202122232425262728293031import java.util.Scanner;// 注意类名必须为 Main, 不要有任何 package xxx 信息public class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); while (in.hasNext()) { String[] input = in.nextLine().split(&quot;,&quot;); int index = 0; int W = Integer.parseInt(input[index++], 10); int N = Integer.parseInt(input[index++], 10); int[][] properties = new int[N][2]; String[] weights = input[index++].split(&quot; &quot;); for (int i = 0; i &lt; N; i++) { properties[i][0] = Integer.parseInt(weights[i], 10); } String[] values = input[index++].split(&quot; &quot;); for (int i = 0; i &lt; N; i++) { properties[i][1] = Integer.parseInt(values[i], 10); } int[] dp = new int[W + 1]; for (int i = 1; i &lt;= N; i++) { for (int j = W; j &gt;= properties[i - 1][0]; j--) { dp[j] = Math.max(dp[j], dp[j - properties[i - 1][0]] + properties[i - 1][1]); } } System.out.println(dp[W]); } }} 0-1背包，要注意0-1背包和完全背包的区别 无压缩情况 0-1背包转移方程为： dp[i][j] = max(dp[i][j], dp[i-1][j-wi]+vi) (当j &gt;= wi时) dp[i][j] = dp[i][j] (当j &lt; wi时) 完全背包转移方程为： dp[i][j] = max(dp[i][j], dp[i][j-wi]+vi) (当j &gt;= wi时) 这里是dp[i] dp[i][j] = dp[i][j] (当j &lt; wi时) 有压缩情况 0-1背包对容量是逆向遍历 完全背包是正向遍历 super和this关键字 this()和super()不可以同时出现在同一个构造函数中 this()或super()要放在构造函数第一行 Android数据存储方式 SharedPreference File SQLite Content Provider 网络 题目中说Bundle也可以，但是应该不对Bundle是可以序列化，但是一般不作为存储数据的方式 广播 × 当静态注册的广播设置的优先级高于动态注册的广播时，静态注册将先接收到广播 动态广播跟随Activity/Application的生命周期，静态广播不受限制。 非有序广播的情况下，动态广播总是要优先于静态广播 每次广播被接收后会重新创建BroadcastReceiver对象，并在onReceive方法中执行完时销毁 Android动画分类IntentService（已经弃用） 对Service的包装 默认实现onBind，返回null 包含一个HandlerThread(的looper)，（Service本身不包括线程，运行在主线程） 持有一个handler，每次start把intent放入msg的obj里，用handler发送 12@Deprecatedpublic abstract class IntentService extends Service { 12345678910111213141516171819202122232425262728private final class ServiceHandler extends Handler { public ServiceHandler(Looper looper) { super(looper); } @Override public void handleMessage(Message msg) { onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); }}@WorkerThreadprotected abstract void onHandleIntent(@Nullable Intent intent); //运行在WorkerThread中@Overridepublic void onStart(@Nullable Intent intent, int startId) { Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg);}@Overridepublic int onStartCommand(@Nullable Intent intent, int flags, int startId) { onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;} 小米2019秋招安卓开发笔试题（A）进制间转换设计一个函数， 可以将任意十进制的数， 转换成任意2到9的进制表示的形式 123456789101112131415161718192021222324import java.util.Scanner;// 注意类名必须为 Main, 不要有任何 package xxx 信息public class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 注意 hasNext 和 hasNextLine 的区别 while (in.hasNext()) { // 注意 while 处理多个 case long n = in.nextLong(); int base = in.nextInt(); if(n == 0) { System.out.println(&quot;0&quot;); continue; } StringBuilder sb = new StringBuilder(); while(n &gt; 0) { sb.append(n % base); n /= base; } sb.reverse(); System.out.println(sb); } }} CCNumberCC最近对一种整数比较感兴趣，我们暂且把这种整数称为C Number, C Number是指一个整数{C0, C1 … Cn-1} (C0 &gt; 0 , n &gt;= 3)， 存在一个Cm（0&lt;m&lt;n-1）满足以下条件: Ci-1 &lt; Ci (0&lt;i&lt;=m), Ci代表这个整数中的第i位数字 Ci&gt;Ci+1(m&lt;=i&lt;n-1) 如果一个整数里面有相邻的2个C Number的话，我们称这个整数为CC Number（2个C Number不可以有公用的数字Ci，并且2个C Number要紧紧相邻）。 请在[A,B]区间内找出找出score最大的CCNumber 并输出这个score.(score：CC Number中所有数字的和) Activity跳转FirstActivity跳转到SecondActivity后，然后点击返回键，以下执行顺序不可能出现的是： SecondActivity的onPause()-&gt;SecondActivity的onStop()-&gt;SecondActivity的onDestroy()-&gt;FirstActivity的onRestart()-&gt;FirstActivity的onResume() 不会在下一个Activity可见前，把当前Activity变成不可见的，（进入stop/destroy） ANRinput事件在5s内没有处理完成会发生ANR前台广播的onReceive处理事务时超过10s会发生ANR后台Service在200s内没有处理完成会发生ANR前台Service在20s内没有处理完成会发生ANR在Activity中，Main线程消息队列中的消息在5秒内没有得到响应 APP进程 一个APP可以运行在多个进程 在Activity/Service中添加不同的进程名android:process=&quot;processName&quot; 每个进程会有一个Application对象 多个APP可以运行在同一进程 在Manifest中添加android:sharedUserId=&lt;java package&gt; 在Manifest中添加android:sharedUserLabel=@string/id 在Application中添加android:process=&quot;processName&quot; 顺丰科技2019秋招安卓开发工程师笔试客观题合集select into和insert into1SELECT xxx INTO target_table FROM origin_table 要求执行前表不存在，会自动创建 1INSERT INTO target_table (filed1, field2, ...) VALUES (val1, val2, ...) 要求执行前表已经存在 EventBus简单实现一套view的注入框架（）度小满校招Android研发工程师第2批近似周期串小明发现有的字符串中蕴含着一些规律，但是它们又和普通的周期串有点不一样。例如:ABCABDABDABE。如果以3为周期，可以看到其中 包含“ABC”、“ABD”和“ABE”等子串，其中“ABD”出现了两次。 这些子串两两之间最多只有某一位上的字符不相同，其他位置上的字符都一样。小明将其称为“近似串”，由多个“近似串”组成的字符串称为“近 似周期串”。“近似周期串”中的每一个“近似串”的长度需大于等于2。 需要注意的是“ABCABBACD”并不是一个“近似周期串”。如果以3为周期，其子串包 括“ABC”、“ABB”和“ACD”，“ABB”与“ACD”、“ABC”与“ACD”均存在两个位置上的字符不相同，因此不是“近似周期串”。特别 的，“AAAAAA”也是一个“近似周期串”，因为它满足上述“近似周期串”的定义。 现在给你一个字符串，请编写一个程序判断该字符串是否是以3为周期的“近似周期串”。 1234567891011121314151617181920212223242526import java.util.Scanner; // 注意类名必须为 Main, 不要有任何 package xxx 信息public class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 注意 hasNext 和 hasNextLine 的区别 while (in.hasNextInt()) { // 注意 while 处理多个 case int n = in.nextInt(); while(n-- &gt; 0) { String s = in.nextLine(); int i = 0; int ans = 0; while(i &lt; s.length()) { ans = ans ^ ((s.charAt(i) - 'A') &lt;&lt; 2) + ((s.charAt(i+1) - 'A') &lt;&lt; 1) + (s.charAt(i+2) - 'A'); i += 3; } if((ans &amp; (ans-1)) != 0) { System.out.println(&quot;No&quot;); } else { System.out.println(&quot;Yes&quot;); } } } }} DNSDNS辅助服务器与DNS主服务器通讯时使用TCP协议 Android题库onNewIntent()的触发时机设备管理器权限sleep,wait,yield,join的区别sleep,yield: 让渡cpu使用权，不释放锁wait: 相当于条件变量，释放锁join: 底层调用了wait Hook框架xposed,Substrate,Cydia,frida dex焦点toast没有焦点 View绘制流程ContentProviderdrawable-xxhdpi等目录携程笔试算法1 给n个数1 &lt;= ai &lt;= 1e6， 求PI(ai!)ai的阶乘的积中因数的个数 分解质因数 质因数出现次数+1的积就是原来数字的因数个数 对数组排序，计算每个数在阶乘中出现的次数，计算每个数的质因数，质因数个数为出现次数 计算所有数的质因数出现次数*该数在阶乘中出现的次数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.*;import java.util.function.UnaryOperator;public class Main { private static final int MOD = 1000000000 + 7; private static final int MAX_VAL = 1000000; private static &lt;K, V&gt; void mapReplace(Map&lt;K, V&gt; map, K key, V def, UnaryOperator&lt;V&gt; operator) { V old = map.get(key); map.put(key, operator.apply(old == null ? def : old)); } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); List&lt;Integer&gt; primes = new ArrayList&lt;&gt;(List.of(2, 3)); for(int i = 5; i &lt;= MAX_VAL; i+=2) { boolean flag = true; for(int j = 3; j*j &lt;= i; j++) { if(i % j == 0) { flag = false; break; } } if (flag) { primes.add(i); } } while(scanner.hasNext()) { int n = scanner.nextInt(); int[] arr = new int[n]; Map&lt;Integer, Integer&gt; cnt = new HashMap&lt;&gt;(); for(int i = 0; i &lt; n; i++) { arr[i] = scanner.nextInt(); } Arrays.sort(arr); for(int j = 1; j &lt;= arr.length; j++) { final int incr = (arr.length - j + 1); if(Collections.binarySearch(primes, arr[j-1]) &gt;= 0) { mapReplace(cnt, arr[j-1], 0, (old) -&gt; (old + incr) % MOD); continue; } for(int i = 1; i &lt;= primes.size(); i++) { int val = arr[j-1]; int prime = primes.get(i-1); while(val % prime == 0) { val = val / prime; mapReplace(cnt, prime, 0, (old) -&gt; (old + incr) % MOD); } } } long ans = 1; for(var entry : cnt.entrySet()) { ans = (ans * (entry.getValue() + 1)) % MOD; } System.out.println(ans); } }} 刷题 账号塔子哥有n个账号，每个账号粉丝数为ai 这天他又创建了一个新账号，他希望新账号的粉丝数恰好等于x。为此他可以向自己已有账号的粉丝们推荐自己的新账号，这样以来新账号就得到了之前粉丝的关注。他想知道，他最少需要在几个旧账号发“推荐新账号”的文章，可以使得他的新账号粉丝数恰好为 x，除此以外，他可以最多从中选择一个账号多次发“推荐新账号”的文章。 假设一个旧账号粉丝数为ai，如果仅推荐一次，那么新账号粉丝数增加ai/2，如果多以推荐，则粉丝数增加ai 读题读错了，只能选一个账号推广多次 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int main() { int n, x; while(cin &gt;&gt; n &gt;&gt; x) { vector&lt;int&gt; accounts(n); for(int i = 0; i &lt; n; i++) { cin &gt;&gt; accounts[i]; } vector&lt;int&gt; dp(x+1, n+1); // 一次 vector&lt;int&gt; dp1(x+1, n+1); // 有某一个账号是多次的情况 dp[0] = 0; dp1[0] = 0; for(int i = 1; i &lt;= n; i++) { for(int j = x; j &gt;= 1; j--) { if(j &gt;= accounts[i-1]) dp1[j] = min(dp1[j], dp[j - accounts[i-1]] + 1); // 该账号多次发布 if(j &gt;= accounts[i-1]/2) dp1[j] = min(dp1[j], dp1[j - accounts[i-1]/2] + 1); // 上一个账号多次发布，该账号不多次发布 if(j &gt;= accounts[i-1]/2) dp[j] = min(dp[j], dp[j - accounts[i-1]/2] + 1); } } cout &lt;&lt; (min(dp[x], dp1[x]) &gt; n ? -1 : min(dp[x], dp1[x])) &lt;&lt; &quot;\\n&quot;; } return 0;} 题目一个正整教x，在区间[l, r]中选样一个数y，满定x*y是完全平万数。想知道有多少种选择方案?一共有q次询问 1 &lt;= q &lt;= 1e41 &lt;= x &lt;= 1e141 &lt;= l, r &lt;= 1e14 思路 我们要找所有y*x == t*t的数y，也就是找所有的y=t*t/x 且 t*t%x == 0 所有满足t*t%x == 0的数(t*t/x)，(t*t/x)在[1, 1e14]范围内 也就是t*t=q*x 因为t,q,x都是整数，所以sqrt(q*x)是整数也就是q可以写成i*i*x的形式 也就是t=i*x 也就是找到所有i*i*x，且在[1, 1e14]范围内 12345678910111213141516171819202122232425import java.util.*;public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while(scanner.hasNext()) { int q = scanner.nextInt(); long x = scanner.nextLong(); List&lt;Long&gt; isSquare = new ArrayList&lt;&gt;(); for(long i = 1; i*i*x &lt;= 1e14; i++) { isSquare.add(i*i*x); } for(int i = 0; i &lt; q; i++) { long l = scanner.nextLong(); long r = scanner.nextLong(); int leftIndex = Collections.binarySearch(isSquare, l); int rightIndex = Collections.binarySearch(isSquare, r); if(leftIndex &lt; 0) leftIndex = -leftIndex-1; if(rightIndex &lt; 0) rightIndex = -rightIndex-1; else rightIndex++; System.out.println(rightIndex - leftIndex); } } }} 2024.3.31 问题5方阵里面上下左右走找tencent 问题4数组分成k组，每组内部异或，求k组异或和最大 问题3一个图，加一个边恰好可以连通有几种加法 问题2一个数组，分成两段（可空），是否恰好可以重新排列成递增 问题1边有RW两色如果一个点周围的边全都是R，则是好点，统计好点的个数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188import java.util.*;import java.util.stream.IntStream;import java.util.stream.Stream;public class Main { private static final Scanner scanner = new Scanner(System.in); private static final String match = &quot;tencent&quot;; private static final int[] pos = {0, 1, 0, -1, 0}; private static int dfs5(int i, int j, int n, int m, int len, String[] map) { if(i &gt;= n || j &gt;= m || i &lt; 0 || j &lt; 0) return 0; if(match.charAt(len) != map[i].charAt(j)) return 0; if(len == 6) return 1; int ans = 0; for(int k = 0; k &lt; pos.length - 1; k++) { ans += dfs5(i + pos[k], j + pos[k+1], n, m, len + 1, map); } return ans; } private static void problem5() { int n = scanner.nextInt(); int m = scanner.nextInt(); String[] map = new String[n]; scanner.nextLine(); for(int i = 0; i &lt; n; i++) { map[i] = scanner.nextLine(); } int ans = 0; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; m; j++) { ans += dfs5(i, j, n, m, 0,map); } } System.out.println(ans); } private static class UnionSet { private final int[] set; public UnionSet(int n) { set = IntStream.iterate(0, (prev)-&gt;prev+1).limit(n).toArray(); } public int find(int i) { return i == set[i] ? i : (set[i] = find(set[i])); } public void union(int i, int j) { set[find(i)] = find(j); } } private static void problem3() { int n = scanner.nextInt(); int m = scanner.nextInt(); UnionSet unionSet = new UnionSet(n); for(int i = 0; i &lt; m; i++) { int u = scanner.nextInt(); int v = scanner.nextInt(); unionSet.union(u-1, v-1); } Map&lt;Integer, Integer&gt; setCnt = new HashMap&lt;&gt;(); for(int i = 0; i &lt; n; i++) { int part = unionSet.find(i); if(!setCnt.containsKey(part)) { setCnt.put(part, 0); } setCnt.put(part, setCnt.get(part) + 1); } if(setCnt.size() != 2) { System.out.println(0); } else { int ans = 0; int diff = 0; for (var entry : setCnt.entrySet()) { diff += entry.getValue(); ans += (n - diff) * entry.getValue(); } // a1 a2 a3 ... an // a1*(a2 + a3 + a4 + ... + an) // a2*(a3 + a4 + a5 + ... + an) System.out.println(ans); } } private static void problem2() { char[] input = scanner.nextLine().toCharArray(); int i = 0; while(i &lt; input.length) { if(input[i] == '[' || input[i] == ']') { System.out.print(input[i]); i++; continue; } List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(input[i] == '{') { i++; while (i &lt; input.length) { int cur = 0; while(i &lt; input.length &amp;&amp; input[i] &gt;= '0' &amp;&amp; input[i] &lt;= '9') { cur *= 10; cur += input[i] - '0'; i++; } list.add(cur); if(i &lt; input.length) { i++; if(input[i-1] == '}') { if(input[i] == ',') i++; break; } } } } int seg1 = 1, seg2; while(seg1 &lt; list.size() &amp;&amp; list.get(seg1) &gt; list.get(seg1-1)) { seg1++; } seg2 = seg1 + 1; while(seg2 &lt; list.size() &amp;&amp; list.get(seg2) &gt; list.get(seg2-1)) { seg2++; } if(seg1 == list.size()) { System.out.print(&quot;true&quot;); } else if (seg2 != list.size()){ System.out.print(&quot;false&quot;); } else { if(list.get(list.size() - 1) &lt; list.get(0)) { System.out.print(&quot;true&quot;); } else { System.out.print(&quot;false&quot;); } } if(i &lt; input.length) { if(input[i] != ']') { System.out.print(&quot;,&quot;); } } } System.out.println(); } private static void problem1() { int node = scanner.nextInt(); int edge = scanner.nextInt(); boolean[] res = new boolean[node]; Arrays.fill(res, true); for(int i = 0; i &lt; edge; i++) { int u = scanner.nextInt(); int v = scanner.nextInt(); String c = scanner.next(); if(c.equals(&quot;R&quot;)) { } else { res[u-1] = res[v-1] = false; } } int ans = 0; for(int i = 0; i &lt; res.length; i++) { if(res[i]) ans++; } System.out.println(ans); } private static void problem4() { int n = scanner.nextInt(); int k = scanner.nextInt(); int[] arr = new int[n]; int[][] dp = new int[n+1][k+1]; int[] xorSum = new int[n+1]; for(int i = 0; i &lt; n; i++) { arr[i] = scanner.nextInt(); xorSum[i+1] = arr[i] ^ xorSum[i]; dp[i+1][1] = xorSum[i+1]; } for(int j = 2; j &lt;= k; j++) { for(int i = j; i &lt;= n; i++) { for(int m = j-1; m &lt; i; m++) { dp[i][j] = Math.max(dp[i][j], dp[m][j-1] + (xorSum[i] ^ xorSum[m])); } } } int ans = 0; for(int i = k; i &lt;= n; i++) { ans = Math.max(ans, dp[i][k]); } System.out.println(ans); } public static void main(String[] args) { while(scanner.hasNext()) { problem5(); problem4(); problem3(); problem2(); problem1(); } }}","link":"/home/2024/03/27/%E7%89%9B%E5%AE%A2/%E7%89%9B%E5%AE%A2%E5%88%B7%E9%A2%98-1/"},{"title":"牛客刷题-2","text":"1.小美的平衡矩阵 1. 小美的平衡矩阵 小美拿到了一个n∗nn*nn∗n的矩阵，其中每个元素是 0 或者 1。 小美认为一个矩形区域是完美的，当且仅当该区域内 0 的数量恰好等于 1 的数量。 现在，小美希望你回答有多少个i∗ii*ii∗i的完美矩形区域。你需要回答1≤i≤n1\\leq i \\leq n1≤i≤n的所有答案。 时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 256M，其他语言512M 输入描述： 第一行输入一个正整数，代表矩阵大小。接下来的行，每行输入一个长度为的 01 串，用来表示矩阵。 输出描述： 输出行，第行输出的完美矩形区域的数量。 示例1 输入例子： 4 1010 0101 1100 0011 输出例子： 0 7 0 1 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() { int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; preSum(n, vector&lt;int&gt;(n+1)); for(int i = 0; i &lt; n; i++) { string s; cin &gt;&gt; s; for(int j = 0; j &lt; n; j++) { preSum[i][j+1] = preSum[i][j] + (s[j] - '0'); } } for(int window = 1; window &lt;= n; window++) { if(window &amp; 1) { cout &lt;&lt; &quot;0\\n&quot;; continue; } int perfect = 0; for(int j = 0; j &lt;= n - window; j++) { int sum = 0; for(int i = 0; i &lt; window; i++) { sum += preSum[i][window + j] - preSum[i][j]; } if(sum * 2 == window * window) { perfect++; } for(int i = window; i &lt; n; i++) { sum -= preSum[i - window][window + j] - preSum[i - window][j]; sum += preSum[i][window + j] - preSum[i][j]; if(sum * 2 == window * window) { perfect++; } } } cout &lt;&lt; perfect &lt;&lt; &quot;\\n&quot;; }} 2.小美的数组询问 2. 小美的数组询问 小美拿到了一个由正整数组成的数组，但其中有一些元素是未知的（用 0 来表示）。 现在小美想知道，如果那些未知的元素在区间[l,r][l,r][l,r]范围内随机取值的话，数组所有元素之和的最小值和最大值分别是多少？ 共有qqq次询问。 时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 256M，其他语言512M 输入描述： 第一行输入两个正整数，代表数组大小和询问次数。第二行输入个整数，其中如果输入的为 0，那么说明是未知的。接下来的行，每行输入两个正整数 ，代表一次询问。 输出描述： 输出行，每行输出两个正整数，代表所有元素之和的最小值和最大值。 示例1 输入例子： 3 2 1 0 3 1 2 4 4 输出例子： 5 6 8 8 例子说明： 只有第二个元素是未知的。第一次询问，数组最小的和是 1+1+3=5，最大的和是 1+2+3=6。第二次询问，显然数组的元素和必然为 8。 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main() { int n, q; cin &gt;&gt; n &gt;&gt; q; long long sum = 0; long long zeroCnt = 0; for(int i = 0; i &lt; n; i++) { int ai; cin &gt;&gt; ai; zeroCnt += (ai == 0 ? 1 : 0); sum += ai; } for(int i = 0; i &lt; q; i++) { int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; sum + zeroCnt*l &lt;&lt; &quot; &quot; &lt;&lt; sum + zeroCnt*r &lt;&lt; &quot;\\n&quot;; }} 3.小美的 MT 3. 小美的 MT MT 是美团的缩写，因此小美很喜欢这两个字母。 现在小美拿到了一个仅由大写字母组成字符串，她可以最多操作kkk次，每次可以修改任意一个字符。小美想知道，操作结束后最多共有多少个'M'和'T'字符？ 时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 256M，其他语言512M 输入描述： 第一行输入两个正整数，代表字符串长度和操作次数。第二行输入一个长度为的、仅由大写字母组成的字符串。 输出描述： 输出操作结束后最多共有多少个'M'和'T'字符。 示例1 输入例子： 5 2 MTUAN 输出例子： 4 例子说明： 修改第三个和第五个字符，形成的字符串为 MTTAM，这样共有 4 个'M'和'T'。 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; int cnt = 0; cin.get(); for(int i = 0; i &lt; n; i++) { char c = cin.get(); if(c != 'M' &amp;&amp; c != 'T') cnt++; } cout &lt;&lt; n - cnt + min(k, cnt) &lt;&lt; endl; return 0;}// 64 位输出请用 printf(&quot;%lld&quot;) 4. 小美的朋友关系1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;class UnionSet { vector&lt;int&gt; array; public: UnionSet(vector&lt;set&lt;int&gt;&gt; graph, int n): array(n) { iota(array.begin(), array.end(), 0); for(int u = 0; u &lt; n; u++) { for(int v : graph[u]) { Union(u, v); } } } UnionSet(const vector&lt;set&lt;int&gt;&gt;&amp; graph): UnionSet(graph, graph.size()) {} UnionSet(int n): array(n) { iota(array.begin(), array.end(), 0); } int Find(int u) { return u == array[u] ? u : (array[u] = Find(array[u])); } void Union(int u, int v) { array[Find(u)] = Find(v); } bool Query(int u, int v) { return Find(u) == Find(v); }};int main() { int n, m, q; cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; vector&lt;set&lt;int&gt;&gt; graph(n); for(int i = 0; i &lt; m; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; u--; v--; graph[u].insert(v); graph[v].insert(u); } vector&lt;tuple&lt;int, int, int&gt;&gt; ops; for(int i = 0; i &lt; q; i++) { int op, u, v; cin &gt;&gt; op &gt;&gt; u &gt;&gt; v; u--; v--; ops.emplace_back(op, u, v); if(op == 1) { graph[u].erase(v); graph[v].erase(u); } } UnionSet unionSet(graph, n); vector&lt;int&gt; ans; for(auto ite = ops.rbegin(); ite != ops.rend(); ite++) { auto [op, u, v] = *ite; if(op == 1) { unionSet.Union(u, v); } else if(op == 2) { ans.push_back(unionSet.Query(u, v)); } } for(auto ite = ans.rbegin(); ite != ans.rend(); ite++) { cout &lt;&lt; (*ite ? &quot;Yes\\n&quot; : &quot;No\\n&quot;); } return 0;} 反向并查集，倒着计算答案 先把要删除的关系全部删除，然后倒序将删除的关系还原 5 小美的区间删除 5. 小美的区间删除 小美拿到了一个大小为nnn的数组，她希望删除一个区间后，使得剩余所有元素的乘积末尾至少有kkk个 0。小美想知道，一共有多少种不同的删除方案？ 时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 256M，其他语言512M 输入描述： 第一行输入两个正整数。第二行输入个正整数，代表小美拿到的数组。 输出描述： 一个整数，代表删除的方案数。 示例1 输入例子： 5 2 2 5 3 4 20 输出例子： 4 例子说明： 第一个方案，删除[3]。第二个方案，删除[4]。第三个方案，删除[3,4]。第四个方案，删除[2]。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;int cntOfFact(long long n, long long fact) { int cnt = 0; long long facts[32] = {0}; int base = 0; facts[0] = fact; while(facts[base] &lt; n) { base++; facts[base] = facts[base-1] * facts[base-1]; } for(; base &gt;= 0; base--) { if(n / facts[base] &gt; 0 &amp;&amp; n % facts[base] == 0) { cnt += 1 &lt;&lt; base; n /= facts[base]; } } return cnt;}int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; arr(n); vector&lt;int&gt; cntOf2(n+1), cntOf5(n+1); for(int i = 0; i &lt; n; i++) { cin &gt;&gt; arr[i]; cntOf2[i+1] = cntOfFact(arr[i], 2) + cntOf2[i]; cntOf5[i+1] = cntOfFact(arr[i], 5) + cntOf5[i]; } int canDelete2 = cntOf2[n] - k; int canDelete5 = cntOf5[n] - k; int start = 0; long long ans = 0; for(int end = 1; end &lt;= n; end++) { while(start &lt; end &amp;&amp; (cntOf2[end] - cntOf2[start] &gt; canDelete2 || cntOf5[end] - cntOf5[start] &gt; canDelete5)) { start++; } ans += end - start; } cout &lt;&lt; ans &lt;&lt; endl; return 0;}// 64 位输出请用 printf(&quot;%lld&quot;)","link":"/home/2024/09/03/%E7%89%9B%E5%AE%A2/%E7%89%9B%E5%AE%A2%E5%88%B7%E9%A2%98-2/"},{"title":"实验-使用动态优先权的进程调度算法模拟","text":"1、实验目的通过动态优先权算法的模拟加深对进程概念进程调度过程的理解。 2、实验内容 用C语言来实现对N个进程采用动态优先权优先算法的进程调度。 每个用来标识进程的进程控制块PCB用结构来描述，包括以下字段： 进程标识数 ID。 进程优先数 PRIORITY，并规定优先数越大的进程，其优先权越高。 进程已占用的CPU时间CPUTIME。 进程还需占用的CPU时间ALLTIME。当进程运行完毕时，ALLTIME变为0。•••• 进程的阻塞时间STARTBLOCK，表示当进程再运行STARTBLOCK个时间片后，将进入阻塞状态。 进程被阻塞的时间BLOCKTIME，表示已足赛的进程再等待BLOCKTIME个时间片后，将转换成就绪状态。 进程状态START。 队列指针NEXT，用来将PCB排成队列。 优先数改变的原则： 进程在就绪队列中呆一个时间片，优先数加1。 进程每运行一个时间片，优先数减3。 假设在调度前，系统中有5个进程，它们的初始状态如下：1234567ID 0 1 2 3 4PRIORITY 9 38 30 29 0CPUTIME 0 0 0 0 0ALLTIME 3 3 6 3 4STARTBLOCK 2 -1 -1 -1 -1BLOCKTIME 3 0 0 0 0STATE READY READY READY READY READY 为了清楚的观察各进程的调度过程，程序应将每个时间片内的情况显示出来，参照的具体格式如下：1234567891011RUNNING PROG：iREADY-QUEUE：-〉id1-〉id2BLOCK-QUEUE：-〉id3-〉id4= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = == = =ID 0 1 2 3 4PRIORITY P0 P1 P2 P3 P4CUPTIME C0 C1 C2 C3 C4ALLTIME A0 A1 A2 A3 A4STARTBLOCK T0 T1 T2 T3 T4BLOCKTIME B0 B1 B2 B3 B4STATE S0 S1 S2 S3 S4 实验代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include&lt;queue&gt;#include&lt;iostream&gt;#include&lt;iomanip&gt; using namespace std;typedef int ID;typedef int Priority;typedef int Time;enum State { sready, sblocked, sruning, sstop};struct PCB{ ID id; Priority priority; Time cpu_time; Time all_time; Time start_block; Time block_time; State state; public: PCB( ID id0, Priority priority0, Time cpu_time0, Time all_time0, Time start_block0, Time block_time0, State state0 ): id(id0), priority(priority0), cpu_time(cpu_time0), all_time(all_time0), start_block(start_block0), block_time(block_time0), state(state0) { }};struct cmp //��д�º���{ bool operator() (PCB* a, PCB* b) { return a-&gt;priority &lt; b-&gt;priority; //�󶥶� }};typedef priority_queue&lt;PCB*, vector&lt;PCB*&gt;, cmp&gt; mqueue;const int width = 10;void show_PCB(PCB* pcb) { string state = &quot;&quot;; switch(pcb-&gt;state) { case sready: state = &quot;ready&quot;; break; case sblocked : state = &quot;blocked&quot;;break; case sruning : state = &quot;runing&quot;;break; case sstop: state = &quot;stop&quot;;break; defalut:state=&quot;unknown&quot;;break; } cout &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; pcb-&gt;id &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; pcb-&gt;priority &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; pcb-&gt;cpu_time &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; pcb-&gt;all_time &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; pcb-&gt;start_block &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; pcb-&gt;block_time &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; state &lt;&lt; &quot;|&quot; &lt;&lt; endl; }void show_queue(queue&lt;PCB*&gt; q){ cout &lt;&lt; left &lt;&lt; setw(7*width+7) &lt;&lt; setfill('-') &lt;&lt; &quot;&quot; &lt;&lt; &quot;\\n&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;id&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;priority&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;cpuTime&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;allTime&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;startBlock&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;blockTime&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;state&quot; &lt;&lt; &quot;|&quot; &lt;&lt; endl; while(!q.empty()) { PCB* t = q.front(); q.pop(); show_PCB(t); } cout &lt;&lt; left &lt;&lt; setw(7*width+7) &lt;&lt; setfill('-') &lt;&lt; &quot;&quot; &lt;&lt; &quot;\\n&quot;;}void show_queue(mqueue q){ cout &lt;&lt; left &lt;&lt; setw(7*width+7) &lt;&lt; setfill('-') &lt;&lt; &quot;&quot; &lt;&lt; &quot;\\n&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;id&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;priority&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;cpuTime&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;allTime&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;startBlock&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;blockTime&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;state&quot; &lt;&lt; &quot;|&quot; &lt;&lt; endl; while(!q.empty()) { PCB* t = q.top(); q.pop(); show_PCB(t); } cout &lt;&lt; left &lt;&lt; setw(7*width+7) &lt;&lt; setfill('-') &lt;&lt; &quot;&quot; &lt;&lt; &quot;\\n&quot;;}queue&lt;PCB*&gt; finished;void run_a_time(mqueue&amp; ready,mqueue&amp; blocked,PCB* runing) { mqueue t_ready, t_blocked; runing = ready.top(); ready.pop(); runing-&gt;priority -= 3; runing-&gt;cpu_time += 1; runing-&gt;all_time -= 1; runing-&gt;start_block -= 1; if(runing-&gt;start_block == 0) { t_blocked.push(runing); runing-&gt;state = sruning; } else { if(runing-&gt;all_time &gt; 0) { t_ready.push(runing); } else { finished.push(runing); runing-&gt;state = sstop; } } mqueue t_queue = blocked; while(!t_queue.empty()) { PCB* t = t_queue.top(); t_queue.pop(); t-&gt;block_time -= 1; if(t-&gt;block_time == 0) { t_ready.push(t); t-&gt;block_time = 0; t-&gt;start_block = -1; t-&gt;state = sready; } else { t_blocked.push(t); t-&gt;state = sblocked; } } t_queue = ready; while(!t_queue.empty()) { PCB* t = t_queue.top(); t_queue.pop(); t-&gt;priority += 1; t-&gt;start_block -= 1; if(t-&gt;start_block == 0) { t_blocked.push(t); t-&gt;state = sblocked; } else { t_ready.push(t); t-&gt;state = sready; } } ready = t_ready; blocked = t_blocked; }int main() { mqueue ready, blocked; PCB* runing = nullptr; PCB* pcbs[] = { new PCB(0,9,0,3,2,3, sready), new PCB(1,38,0,3,-1,0, sready), new PCB(2,30,0,6,-1,0, sready), new PCB(3,29,0,3,-1,0, sready), new PCB(4,0,0,4,-1,0, sready) }; int pcb_num = sizeof(pcbs)/sizeof(PCB*); for(int i = 0; i &lt; pcb_num; i++) { ready.push(pcbs[i]); } show_queue(ready); int clock_ = 1; while(!ready.empty() || !blocked.empty()) { cout &lt;&lt; &quot;clock = &quot; &lt;&lt; clock_ &lt;&lt; endl; run_a_time(ready, blocked, runing); cout &lt;&lt; &quot;ready queue:&quot; &lt;&lt; endl; show_queue(ready); cout &lt;&lt; &quot;blocked queue:&quot; &lt;&lt; endl; show_queue(blocked); //system(&quot;pause&quot;); clock_++; } show_queue(finished); //delete for(int i = 0; i &lt; pcb_num; i++) { delete pcbs[i]; }}","link":"/home/2020/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C-%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E4%BC%98%E5%85%88%E6%9D%83%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/"},{"title":"实验-简单文件系统的实现","text":"1、实验目的通过具体的文件存储空间的管理、文件的物理结构、目录结构和文件操作的实现，加深对文件系统内部功能和实现过程的理解。 2、实验内容 在内存中开辟一个虚拟磁盘空间作为文件存储器，在上面实现一个简单单用户文件系统。退出时应该将该虚拟文件系统保存到磁盘上，以便下次可以再将它恢复到内存对虚拟磁盘空间中。 文件存储空间对分配可以采用显式链接分配或者其他的办法。 空闲空间的管理可以选择位示图或者其他的办法。如果采用位示图来管理文件存储空间，并采用显式链接分配方式，那么可以将位示图合并到FAT中。 文件目录结构采用多级目录结构。为了简单起见，可以不使用索引结点，其中的每个目录项应包含文件名、物理地址、长度等信息，还可以通过目录项实现对文件对读和写的保护。 要求提供以下有关的操作：1234567891011√format：对文件存储器进行格式化，即按照文件系统对结构对虚拟磁盘空间进行布局，并在其上创建根目录以及用于管理文件存储空间等的数据结构。√mkdir：用于创建子目录；√rmdir：用于删除目录；√ls：用于显示目录；√cd：用于更改当前目录；√create：用于创建文件；√open：用于打开文件；√close：用于关闭文件；√write：用于写文件；√read：用于读文件√rm：用于删除文件。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iomanip&gt;#include &lt;fstream&gt;using std::string;using std::vector;using std::cout;using std::endl;using std::cin;using std::ifstream;using std::ofstream;using std::ios;class FCB{public: int first_block; string fileName; int size; int real_size; FCB(int first_block0,const string &amp;fileName0, int size0, int real_size0): first_block(first_block0), fileName(fileName0), size(size0), real_size(real_size0*4) { }}; //文件控制块class DirItem { //文件树 string name; vector&lt;FCB*&gt; files; //目录下的文件 vector&lt;DirItem*&gt; dirs; //目录下的文件夹，树节点public: DirItem(const string&amp; name0):name(name0) {} void addFile(int first_block, const string&amp; fileName,int size, int real_size) { for (auto i = files.begin(); i != files.end(); i++) { if ((*i)-&gt;fileName == fileName) { cout &lt;&lt; &quot;same file name&quot; &lt;&lt; endl; return; } } files.push_back(new FCB(first_block, fileName, size, real_size)); } void addDir(DirItem* dir) { dirs.push_back(dir); } vector&lt;DirItem*&gt; getDirs() { return dirs; } vector&lt;FCB*&gt; getFiles() { return files; } string getName() { return name; } void del_file(const string&amp; fileName) { for (auto i = files.begin(); i != files.end(); i++) { if ((*i)-&gt;fileName == fileName) { files.erase(i); break; } } } void del_dir(const string&amp; fileName) { for (auto i = dirs.begin(); i != dirs.end(); i++) { if ((*i)-&gt;getName() == fileName) { dirs.erase(i); break; } } } void clear() { for (DirItem* item : dirs) { delete item; } for (FCB* item : files) { delete item; } dirs.clear(); files.clear(); } //递归删除时用到，删除当前目录下的目录和文件的指针};class diskMgr { //磁盘 vector&lt;int&gt; blocks; //fat表 int n = 16; int block_num = n*n; int block_size = 4; //每块4B int disk_capacity = block_num * block_size; //1M vector&lt;vector&lt;int&gt;&gt; bit_map; //0空，1有，位视图public: vector&lt;char&gt; disk; diskMgr() { disk = vector&lt;char&gt;(disk_capacity, '\\0'); blocks = vector&lt;int&gt;(block_num, -1); bit_map = vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(n, 0)); } int getSize(int blockNum) { int n = 0; while (blockNum != -1) { n++; blockNum = blocks[blockNum]; } return n; } //当前块号开始的文件一个有多少块儿 int find_empty_block() { for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (bit_map[i][j] == 0) { return n*i+j; } } } return -1; }//找到一个空闲盘块，从位视图 void update_bit_map(int x, int notempty) { int i = x / n,j = x % n; bit_map[i][j] = notempty; }//更新位视图 void del(int blockNum) { while (blockNum != -1) { for(int i = 0; i &lt; block_size; i++) { disk[blockNum * block_size + i] = '\\0'; } update_bit_map(blockNum, 0); int t = blocks[blockNum]; blocks[blockNum] = -1; blockNum = t; } } //删除文件 vector&lt;char&gt; read(int blockNum) { vector&lt;char&gt; data; while (blockNum != -1) { for(int i = 0; i &lt; block_size; i++) { data.push_back(disk[blockNum * block_size + i]); } blockNum = blocks[blockNum]; } return data; } //读取文件 int write(vector&lt;char&gt; data) { int first_block = find_empty_block(); //找到初始位置 if (first_block == -1) return -1; int len = int(data.size()); int blockn = len%block_size == 0 ? len/block_size : len/block_size+1; //一共需要的盘块儿数 int next_block = first_block; int temp = next_block; int fix = (block_size - len % block_size) % block_size; for (int i = 0; i &lt; fix; ++i) { //数据长度对齐 data.push_back('*'); } for (int i = 0; i &lt; blockn; i++) { //存数据 if (temp == -1) { break; } next_block = temp; for (int j = 0; j &lt; block_size; j++) { disk[next_block*block_size+j] = data[i*block_size+j]; } update_bit_map(next_block, 1); temp = find_empty_block(); blocks[next_block] = temp; } blocks[next_block] = -1; return first_block; }};#define chart_head std::left &lt;&lt; std::setw(len+1) &lt;&lt; std::setfill('-') &lt;&lt; &quot;&quot;#define chart_cell &quot;|&quot; &lt;&lt; std::left &lt;&lt; std::setw(len) &lt;&lt; std::setfill(' ')class fileMgr { DirItem * root; //根节点 diskMgr dm;//磁盘管理器 DirItem * cur; //当前命令行执的工作目录 string cur_path; //工作命令 DirItem* addmdir(DirItem * node, string name) { DirItem* newNode = new DirItem(name); node-&gt;addDir(newNode); return newNode; }public: fileMgr() { root = new DirItem(&quot;/&quot;); DirItem * temp = addmdir(addmdir(root, &quot;apps&quot;), &quot;tencent&quot;); addmdir(temp, &quot;qq&quot;); addmdir(temp, &quot;qqgame&quot;); addmdir(temp, &quot;qqmusic&quot;); temp = addmdir(root, &quot;docs&quot;); addmdir(temp, &quot;words&quot;); addmdir(temp, &quot;ppts&quot;); addmdir(temp, &quot;excels&quot;); root-&gt;addDir(new DirItem(&quot;pics&quot;)); root-&gt;addDir(new DirItem(&quot;musics&quot;)); cur = root; cur_path = &quot;/&quot;; cout_hint(); } //初始化一些文件夹 void ls() { int len = 20; cout &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; endl &lt;&lt; chart_cell &lt;&lt; &quot;file/dir name&quot; &lt;&lt; chart_cell &lt;&lt; &quot;type&quot; &lt;&lt; chart_cell &lt;&lt; &quot;size&quot; &lt;&lt; chart_cell &lt;&lt; &quot;real size&quot; &lt;&lt; &quot;|&quot; &lt;&lt; std::endl &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; endl; vector&lt;DirItem*&gt; dirs = cur-&gt;getDirs(); for (auto i = dirs.begin(); i != dirs.end(); i++) { cout &lt;&lt; chart_cell &lt;&lt; (*i)-&gt;getName() &lt;&lt; chart_cell &lt;&lt; &quot;directory&quot; &lt;&lt; chart_cell &lt;&lt; &quot;--&quot; &lt;&lt; chart_cell &lt;&lt; &quot;--&quot; &lt;&lt; &quot;|&quot; &lt;&lt; std::endl; } vector&lt;FCB*&gt; files = cur-&gt;getFiles(); for (auto i = files.begin(); i != files.end(); i++) { cout &lt;&lt; chart_cell &lt;&lt; (*i)-&gt;fileName &lt;&lt; chart_cell &lt;&lt; &quot;file&quot; &lt;&lt; chart_cell &lt;&lt; (*i)-&gt;size &lt;&lt; chart_cell &lt;&lt; (*i)-&gt;real_size &lt;&lt; &quot;|&quot; &lt;&lt; std::endl; } cout &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; endl; cout_hint(); } void cout_hint() { cout &lt;&lt; &quot;\\n&quot; &lt;&lt; cur_path &lt;&lt; &quot;&gt; &quot;; } //输出命令行提示符 void cd(string name) { if (name == &quot;..&quot;) { if(cur_path == &quot;/&quot;) { cout_hint(); } else { if (*cur_path.rbegin() == '/') { cur_path.pop_back(); } cur_path = cur_path.substr(0, cur_path.rfind('/')); if (cur_path.length() == 0) { cur_path = &quot;/&quot;; } cur = find_dir_node(cur_path); cout_hint(); return; } } DirItem* node = cur; for(DirItem* item : node-&gt;getDirs()){ if (item-&gt;getName() == name) { cur = item; cur_path += name+&quot;/&quot;; cout_hint(); return; } } cout &lt;&lt; &quot;no such dir&quot;; cout_hint(); } void cdn(string path) { cur = find_dir_node(path); if (*path.rbegin() != '/') { path.push_back('/'); } if (*path.begin() != '/') { path = &quot;/&quot; + path; } cur_path = path; cout_hint(); } DirItem* find_dir_node(string path) { if (path[0] == '/') { path = path.substr(1, path.length()-1); } if (*path.rbegin() != '/') { path.push_back('/'); } int r = 0; DirItem* node = root; if (path == &quot;/&quot;) return node; while (r != -1) { r = path.find('/'); if (r != -1) { string dir = path.substr(0, r); bool find = false; for(DirItem* item : node-&gt;getDirs()){ if (item-&gt;getName() == dir) { node = item; find = true; break; } } if (!find) { return nullptr; } path = path.substr(r+1, path.length() - r - 1); } else { break; } } return node; } void create_file(const string&amp; fileName, const vector&lt;char&gt;&amp; data) { DirItem *node = cur; if (node != nullptr) { int fb = dm.write(data); if(fb == -1) { cout &lt;&lt; &quot;no enough disk storage&quot;; cout_hint(); } int size = dm.getSize(fb); node-&gt;addFile(fb, fileName, data.size(), size); } cout_hint(); } void create_file(string path, const string&amp; fileName, const vector&lt;char&gt;&amp; data) { DirItem *node = find_dir_node(path); if (node != nullptr) { int fb = dm.write(data); int size = dm.getSize(fb); node-&gt;addFile(fb, fileName, data.size(), size); } } void create_dir(const string&amp; dirName) { if (cur != nullptr) { cur-&gt;addDir(new DirItem(dirName)); } cout_hint(); } void create_dir(string path, const string&amp; dirName) { DirItem * node = find_dir_node(path); if (node != nullptr) { node-&gt;addDir(new DirItem(dirName)); } } void del_dir(DirItem* node) { if (node != nullptr) { for(FCB* fcb : node-&gt;getFiles()) { dm.del(fcb-&gt;first_block); node-&gt;del_file(fcb-&gt;fileName); } for(auto i : node-&gt;getDirs()) { del_dir(i); } node-&gt;clear(); } } void del_dir(const string&amp; fileName) { if (cur != nullptr) { for (auto i : cur-&gt;getDirs()) { if(i-&gt;getName() == fileName) { del_dir(i); cur-&gt;del_dir(i-&gt;getName()); cout_hint(); return; } } } cout &lt;&lt; &quot;no such directory&quot;; cout_hint(); } void del_file(const string&amp; fileName) { DirItem*node = cur; if (node != nullptr) { for(FCB* fcb : node-&gt;getFiles()) { if (fcb-&gt;fileName == fileName) { dm.del(fcb-&gt;first_block); node-&gt;del_file(fileName); cout_hint(); return; } } } } void del_file(string path, const string&amp; fileName) { DirItem*node = find_dir_node(path); if (node != nullptr) { for(FCB* fcb : node-&gt;getFiles()) { if (fcb-&gt;fileName == fileName) { dm.del(fcb-&gt;first_block); node-&gt;del_file(fileName); return; } } } } void show(const vector&lt;char&gt;&amp; v) { for (char i : v) { cout &lt;&lt; i; } } void read(const string&amp; fileName) { if (cur != nullptr) { for(FCB* fcb : cur-&gt;getFiles()) { if (fcb-&gt;fileName == fileName) { vector&lt;char&gt; data = dm.read(fcb-&gt;first_block); show(data); cout_hint(); return; } } } cout &lt;&lt; &quot;file not found&quot;; cout_hint(); } vector&lt;char&gt; read(string path, const string&amp; fileName) { DirItem*node = find_dir_node(path); if (node != nullptr) { for(FCB* fcb : node-&gt;getFiles()) { if (fcb-&gt;fileName == fileName) { return dm.read(fcb-&gt;first_block); } } } return {}; }};int main() { fileMgr fm; /*ifstream Myfile2; Myfile2.open(&quot;file_sys.disk&quot;,ios::binary); //二进制打开，缺省为文本，ios::out,ios::in,文本输入输出用&lt;&lt;,&gt;&gt; Myfile2.read((char *)&amp;fm,sizeof(fileMgr)); Myfile2.close();*/ string ins, para; while(cin &gt;&gt; ins) { if(ins == &quot;ls&quot;) { fm.ls(); } else if(ins == &quot;cd&quot;) { cin &gt;&gt; para; fm.cd(para); } else if (ins == &quot;read&quot;) { cin &gt;&gt; para; fm.read(para); } else if (ins == &quot;mkdir&quot;) { cin &gt;&gt; para; fm.create_dir(para); } else if (ins == &quot;rmdir&quot;) { cin &gt;&gt; para; fm.del_dir(para); } else if (ins == &quot;mkfile&quot;) { cin &gt;&gt; para; string c = &quot;&quot;; cout &lt;&lt; &quot;contents:\\n&quot;; string data; while(c != &quot;#&quot;) { data += c; std::getline(cin, c); data += '\\n'; } int k = 0; while (data[k] == '\\n') k++; data = data.substr(k, data.length()-k); vector&lt;char&gt; vdata; for(char i : data) { vdata.push_back(i); } fm.create_file(para, vdata); } else if (ins == &quot;rmfile&quot;) { cin &gt;&gt; para; fm.del_file(para); } else if (ins == &quot;exit&quot; || ins == &quot;quit&quot;) { break; } else if (ins == &quot;cdn&quot;) { cin &gt;&gt; para; fm.cdn(para); } else { string c; std::getline(cin, c); ins += &quot; &quot; + c; system(ins.c_str()); cout &lt;&lt; &quot;unknown cmd:&quot; &lt;&lt; ins &lt;&lt; endl; fm.cout_hint(); } } /*ofstream file; file.open(&quot;file_sys.disk&quot;,ios::binary); //缓存的类型是 unsigned char *，需要类型转换 file.write((char *)&amp;fm,sizeof(fileMgr)); //winServer为类对象 file.close();*/ return 0;}","link":"/home/2020/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C-%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"title":"实验-使用动态分区分配方式的模拟","text":"1、实验目的了解动态分区分配方式中使用的数据结构和分配算法，并进一步加深对动态分区存储管理方式及其实现过程的理解。 2、实验内容 用C语言分别实现采用首次适应算法和最佳适应算法的动态分区分配过程alloc( )和回收过程free( )。其中，空闲分区通过空闲分区链来管理：在进行内存分配时，系统优先使用空闲区低端的空间。 假设初始状态下，可用的内存空间为640KB，并有下列的请求序列：作业1申请130KB。作业2申请60KB。作业3申请100KB。作业2释放60KB。作业4申请200KB。作业3释放100KB。作业1释放130KB。作业5申请140KB。作业6申请60KB。作业7申请50KB。作业6释放60KB。 请分别采用首次适应算法和最佳适应算法，对内存块进行分配和回收，要求每次分配和回收后显示出空闲分区链的情况。 实验代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;iomanip&gt;using namespace std;enum Unit { KB, MB};typedef int Addr;Addr getAddr(int num, Unit unit) { return (unit == KB) ? (num) : (unit == MB) ? (num*1024) : 0;}struct mem_block { Addr start; Addr len; int task_id; mem_block(Addr start0, Addr len0, int task_id0):start(start0), len(len0), task_id(task_id0) {}};struct FF_cmp { bool operator() (mem_block a, mem_block b) { return a.start &gt; b.start; //小顶堆 }};struct BF_cmp { bool operator() (mem_block a, mem_block b) { return a.len &gt; b.len; //小顶堆 }};typedef priority_queue&lt;mem_block, vector&lt;mem_block&gt;, FF_cmp&gt; FF_Queue;typedef priority_queue&lt;mem_block, vector&lt;mem_block&gt;, BF_cmp&gt; BF_Queue;FF_Queue ffq;BF_Queue bfq;set&lt;int&gt; tasks;void init() { ffq.push(mem_block(0,getAddr(640, KB), 0)); bfq.push(mem_block(0,getAddr(640, KB), 0));}template&lt;class T&gt;void merge_mem(T&amp; q) { FF_Queue tq; while (!q.empty()) { tq.push(q.top()); q.pop(); } vector&lt;mem_block&gt; vt; while (!tq.empty()) { mem_block t = tq.top(); tq.pop(); while (!tq.empty() &amp;&amp; tq.top().task_id == t.task_id) { t.len += tq.top().len; tq.pop(); } vt.push_back(t); } for(auto item : vt) { q.push(item); }}template&lt;class T&gt;void alloc_mem(T&amp; q, int task_id, Addr num) { if (num &lt;= 0) { return; } vector&lt;mem_block&gt; vt; while (!q.empty()) { mem_block t = q.top(); q.pop(); if (t.len &gt;= num &amp;&amp; t.task_id == 0) { q.push(mem_block(t.start, num, task_id)); if (t.len &gt; num) { q.push(mem_block(t.start +num, t.len - num, 0)); } for(auto item : vt) { q.push(item); } merge_mem&lt;T&gt;(q); return; } else { vt.push_back(t); } } cout &lt;&lt; &quot;error no enough mem alloc&quot; &lt;&lt; endl; for(auto item : vt) { q.push(item); }}template&lt;class T&gt;void free_mem(T&amp; q, int task_id, Addr num) { if (num &lt;= 0) { return; } vector&lt;mem_block&gt; vt; while (!q.empty()) { mem_block t = q.top(); q.pop(); if (t.task_id == task_id) { if(t.len &gt;= num) { q.push(mem_block(t.start, num, 0)); if (t.len &gt; num) { q.push(mem_block(t.start + num, t.len - num, task_id)); } } else { num -= t.len; continue; } for(auto item : vt) { q.push(item); } merge_mem&lt;T&gt;(q); return; } else { vt.push_back(t); } } cout &lt;&lt; &quot;error no enough mem free&quot; &lt;&lt; endl; for(auto item : vt) { q.push(item); }}const int char_len = 8;#define chart_item &lt;&lt; &quot;|&quot; &lt;&lt; setw(char_len) &lt;&lt; left &lt;&lt; setfill(' ')#define chart_head &lt;&lt; setw((char_len+1)*3+1) &lt;&lt; left &lt;&lt; setfill('-')string itoa(int n) { string s; while (n) { s = char(n%10+'0') + s; n /= 10; } return s;}template&lt;class T&gt;void show(T q) { T tq; while (!q.empty()) { tq.push(q.top()); q.pop(); } cout chart_head&lt;&lt;&quot;&quot;&lt;&lt;endl chart_item &lt;&lt; &quot;start&quot; &lt;&lt; &quot;&quot; chart_item &lt;&lt; &quot;len&quot; &lt;&lt; &quot;&quot; chart_item &lt;&lt; &quot;task_id&quot; &lt;&lt; &quot;|&quot;&lt;&lt; endl chart_head&lt;&lt;&quot;&quot;&lt;&lt;endl; while (!tq.empty()) { mem_block mb = tq.top(); cout chart_item&lt;&lt; mb.start &lt;&lt; &quot;&quot; chart_item&lt;&lt; mb.len &lt;&lt; &quot;&quot; chart_item&lt;&lt; ((mb.task_id == 0) ? &quot;spare&quot; : itoa(mb.task_id)) &lt;&lt; &quot;|&quot;&lt;&lt; endl; tq.pop(); } cout chart_head&lt;&lt;&quot;&quot;&lt;&lt;endl;}int main(int argc, const char * argv[]) { init(); const int free = 0, alloc = 1; vector&lt;vector&lt;int&gt;&gt; reqs = { {1,130,alloc}, {2,60, alloc}, {3,100, alloc}, {2,60,free}, {4, 200, alloc}, {3, 100, free}, {1, 130, free}, {5, 140, alloc}, {6, 60, alloc}, {7,50, alloc}, {6, 60, free} }; for(auto req : reqs) { if (req[2] == alloc) { alloc_mem&lt;FF_Queue&gt;(ffq,req[0], req[1]); alloc_mem&lt;BF_Queue&gt;(bfq,req[0], req[1]); } else if (req[2] == free) { free_mem&lt;FF_Queue&gt;(ffq,req[0], req[1]); free_mem&lt;BF_Queue&gt;(bfq,req[0], req[1]); } else { } cout &lt;&lt; &quot;FF&quot; &lt;&lt; endl; show&lt;FF_Queue&gt;(ffq); cout &lt;&lt; &quot;BF&quot; &lt;&lt; endl; show&lt;BF_Queue&gt;(bfq); } return 0;}","link":"/home/2020/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C-%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E6%A8%A1%E6%8B%9F/"},{"title":"OI KIWI 01-倍增","text":"OI KIWI 倍增 思想 图片来源 查找小于limit的最大数字1234567891011121314int maxValueInVecSmallerThenLimit(vector&lt;int&gt;&amp; vec, int limit) { int n = vec.size(); int l = 0; int p = 1; while(p) { if(l + p &lt; n &amp;&amp; vec[l + p] &lt; limit) { l += p; p &lt;&lt;= 1; } else { p &gt;&gt;= 1; } } return vec[l];} 和二分一样，需要在有序数组上查找 对于查找区间[l, l + p) 如果vec[l+p] &gt;= limit， 则最大值就在[l, l + p)区间上,下一步查询[l, l + p / 2) 如果vec[l+p] &lt; limit， 则最大值不在[l, l + p)区间上,下一步查询[l + p, l + 3*p) 如果l+p &gt;= n, 则缩小查找范围 我们把上面的逻辑迭代两次 如果vec[l+p] &gt;= limit， 则最大值就在[l, l + p)区间上,下一步查询[l, l + p / 2) 如果vec[l+p/2] &gt;= limit， 则最大值就在[l, l + p/2)区间上,下一步查询[l, l + p / 4) 如果vec[l+p/2] &lt; limit， 则最大值不在[l, l + p/2)区间上,下一步查询[l + p/2, l + p/2 + p) 如果vec[l+p] &lt; limit， 则最大值不在[l, l + p)区间上,下一步查询[l + p, l + 3*p) 如果vec[l+3*p] &gt;= limit， 则最大值就在[l + p, l + 3*p)区间上,下一步查询[l + p, l + 2*p) 如果vec[l+3*p] &lt; limit， 则最大值不在[l + p, l + 3*p)区间上,下一步查询[l + 3 * p, l + 7 * p) RMQ区间最值Range Maximum/Minimum Query 单调栈用单调栈找到两个数组left和right left[i]代表arr[i]在[left[i], i]的区间上是最小值 right[i]代表arr[i]在[i, right[i]]的区间上是最小值 对于一个查询[l, r] 如果left[r] &lt;= l, arr[r]是区间最小值 如果right[l] &gt;= r, arr[l]是区间最小值 否则l = right[l] + 1, r = left[r] - 1，缩小查找范围 12345678910111213141516171819202122232425262728293031323334353637vector&lt;int&gt; RangeMinimumQuery(vector&lt;int&gt;&amp; arr, vector&lt;vector&lt;int&gt;&gt;&amp; queries) { stack&lt;int&gt; monoStack; int len = arr.size(); int res = 0; vector&lt;int&gt; left(len), right(len, len - 1); for(int i = 0; i &lt; len; i++) { left[i] = right[i] = i; int top = -1; while(!monoStack.empty() &amp;&amp; arr[monoStack.top()] &gt;= arr[i]) { top = monoStack.top(); monoStack.pop(); } if(top != -1) left[i] = left[top]; monoStack.push(i); } monoStack = stack&lt;int&gt;(); for(int i = len - 1; i &gt;= 0; i--) { int top = -1; while(!monoStack.empty() &amp;&amp; arr[monoStack.top()] &gt; arr[i]) { top = monoStack.top(); monoStack.pop(); } if(top != -1) right[i] = right[top]; monoStack.push(i); } vector&lt;int&gt; ans; for(const auto&amp; query : queries) { int l = query[0], r = query[1]; while(right[l] &lt; r &amp;&amp; left[r] &gt; l) { // 有可能循环n/2次，退化成O(n), 如5,4,3,2,1,2,3,4,5 l = min(len - 1, right[l] + 1); r = max(0, left[r] - 1); } ans.push_back(min(arr[l], arr[r])); } return ans;} ST表参考这里：https://oi-wiki.org/ds/sparse-table/ 适用范围：可重复贡献问题 op(x, x) = x, 一个操作重复计算等于其本身 比如max, min, gcd等操作 这样可以允许我们划分子问题时，即使子问题之间存在重叠，也可以获得正确的结果 $ ST[i][j] = min(arr[i…(i + 2^j - 1)]) $ (闭区间) 123456789101112131415/*6,5,1,4,6,1,5,3稀疏表0 1 3 70 1 2 3———————6 5 4 15 1 1 11 1 1 14 4 5 16 1 1 11 1 1 15 3 3 33 3 3 3*/ 可见构造的时间为O(nlogn) 12345678910/*0...1 1...2 2...3 3...4 4...5 5...6 6...70...3 1...4 2...5 3...6 4...7 5...7 6...70...7 1...7 2...7 3...7 4...7 5...7 6...70...2 -&gt; 0...1, 1...20...4 -&gt; 0...3, 1...40...5 -&gt; 0...3, 2...50...6 -&gt; 0...3, 3...6*/ 一个查询有可拆成同一行的两个子数组 因为 $ ST[i][j] = min(arr[i…(i + 2^j - 1)]) $ $ start = i $ , $end = i + 2^j - 1$ 解得$j = log(end - start + 1)$ 要查 $ 0 … 6 $，查询 $ (0, log(6-0+1)) $ = $ (0, 2) $ = $ 0 … 3 $下面查 $ 3 … 6 $，查询 $ (3, 2) $ = $ (6 - 2^2 + 1, 2) $公式是这么来的：$a…b$ = $(a, a + 2^j - 1)$ = $(b - 2^j + 1, b)$ 要查$0 … 5$，查询$(0, log(5-0+1))$ = $(0, 2)$ = $0 … 3$下面查$ 2 … 5 $, 查询$(2, 2)$ = $(5 - 2^2 + 1, 2)$也就是说，要查询$ a…b $相当于$ min(a…(a+2^j-1), (b - 2^j + 1)…b) $$ min(ST[a][j], ST[b-2^j+1][j]), j = log2(b-a+1)$ 如何构造ST表：$ (i, i + 2^j - 1) = (i, i + 2^{j-1} - 1), (i + 2^{j-1}, i + 2^j - 1) $$ ST[i][j] = min(ST[i][j-1], ST[i+j][j-1]) $ 123456789101112131415161718192021vector&lt;int&gt; RMQ(vector&lt;int&gt;&amp; array, vector&lt;pair&lt;int, int&gt;&gt;&amp; query) { int n = array.size(); int log_n = log2(n); vector&lt;vector&lt;int&gt;&gt; ST(n); vector&lt;int&gt; ans; for(int i = 0; i &lt; n; i++) { ST[i].push_back(array[i]); } // sum[p=1...log2(n)](n-p) = n*log2(n) - (log2(n)+1)*log2(n)/2 for(int j = 1; j &lt;= log_n + 1; j++) { int off = 1 &lt;&lt; (j - 1); for(int i = 0; i + off &lt; n; i++) { // n - j ST[i].push_back(min(ST[i][j-1], ST[i+off][j-1])); } } for(auto [start, end] : query) { int pos = log2(end - start + 1); ans.push_back(min(ST[start][pos], ST[end - (1 &lt;&lt; pos) + 1][pos])); } return ans;} 快速幂对指数进行二进制分解$ n $ = 22 = 10110 = $2^4 + 2^2 + 2^1$$ a^{n} = a^{2^4} \\times a^{2^2} \\times a^{2^1}$ 123456789int fastPow(int base, int pow, int mod) { int ans = 1 % mod; // 注意要在最初或最后对ans取mod，以应对pow = 0, mod = 1的情况 while(pow) { if(pow &amp; 1) ans = (ans * base) % mod; base = (base * base) % mod; pow &gt;&gt;= 1; } return ans;} LCA最近公共祖先遍历二叉树1234567891011class Solution {public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(!root) return nullptr; if(root == p || root == q) return root; TreeNode *l = lowestCommonAncestor(root-&gt;left, p, q); TreeNode *r = lowestCommonAncestor(root-&gt;right, p, q); if(l != nullptr &amp;&amp; r != nullptr) return root; // p和q分别在左右子树中找到 return l == nullptr ? r : l; }}; 复杂度为$ O(n) $对于$m$次查询,复杂度为$O(m \\times n)$ ST表当查找两个节点node0和node1的最近公共祖先时 如果node0和node1在同一层，深度为d 如果两个节点在深度d-k层处的祖先是同一个 那么说明最近公共祖先在[d-k, d+1] k偏大了，需要减小 如果两个节点在深度d-k层处的祖先不是同一个 那么说明最近公共祖先在[0, d-k] 将两个节点移动到各自d-k层处的祖先处 如此迭代，就可以将区间不断缩小，最后定位到最近公共祖先如果k取当前深度的一半，就可以达到log(depth)的复杂度 ST[i][j]表示节点i向上2^j层的祖先节点$ 2^j &lt; depth, j=0…floor(log2(depth))$转移方程为: 1ST[i][j] = ST[ST[i][j-1]][j-1] 这里就用到了倍增的思想 如果node0和node1在不同一层，可以先将深度较深的节点向上移动假设高度差为5=101则12node = ST[node][0] // j = 0, 2^0node = ST[node][2] // j = 2, 2^2 将高度差的二进制分解，即可以log(dep1 - dep2)的复杂度将两个节点放到同一层 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class LCA { vector&lt;vector&lt;int&gt;&gt;&amp; tree; // tree[i][j]代表节点i的第j个孩子在tree中的索引 int N; // 节点总数 vector&lt;vector&lt;int&gt;&gt; ST; // ST[i][j]表示节点i向上2^j层的祖先节点 vector&lt;int&gt; depth; // depth[i]代表节点的深度 int maxDepth = 0; // 树的深度 void dfsInit(int root, int dep) { depth[root] = dep; // 每个节点的深度 maxDepth = max(maxDepth, dep); for(int child : tree[root]) { dfsInit(child, dep + 1); ST[child][0] = root;// child节点向上2^0=1层的父节点 } } void initST() { // i向上2^j层的父节点 = i向上向上2^(j-1)层父节点再向上2^(j-1)层的父节点 for(int j = 1; (1 &lt;&lt; j) &lt;= maxDepth; j++) { for(int i = 0; i &lt; N; i++) { ST[i].push_back(ST[ST[i][j-1]][j-1]); } } } LCA(vector&lt;vector&lt;int&gt;&gt;&amp; tree, int N): tree(tree), N(N), depth(N), ST(N, vector&lt;int&gt;(1)) { dfsInit(0, 0); initST(); } public: LCA(vector&lt;vector&lt;int&gt;&gt;&amp; tree):LCA(tree, tree.size()) {} int lca(int node0, int node1) { if(depth[node0] &gt; depth[node1]) { swap(node0, node1); // node1为深度更深的节点 } int depDiff = depth[node1] - depth[node0]; for(int i = 0; depDiff; depDiff &gt;&gt;= 1, i++) { if(depDiff &amp; 1) { node1 = ST[node1][i]; // 向上移动node1，两者depth相同 } } if(node1 == node0) return node0; for(int i = log2(maxDepth); i &gt;= 0; i--) { // 每次向上查询的深度减半 if(ST[node0][i] != ST[node1][i]) { // 向上的祖先节点不同，移动到各自祖先节点上 node0 = ST[node0][i]; node1 = ST[node1][i]; } // else 向上的祖先节点相同，继续减小深度 } return ST[node0][0]; // node0或node1的父节点就是lca }}; 每次查询的复杂度为 $O(log(depth))$ 预处理的时间复杂度为 $O(log(n \\times log(depth)))$ $ m $ 次查询的复杂度为 $ O((m + n) \\times log(depth)) $","link":"/home/2024/08/23/%E7%AE%97%E6%B3%95/OI-KIWI-01-%E5%80%8D%E5%A2%9E/"},{"title":"OI KIWI 02-二分","text":"二分查找左闭右闭123456789101112131415int binarySearch(vector&lt;int&gt;&amp; vec, int target) { int len = vec.size(); int l = 0, r = len - 1; // while(l &lt;= r) { int mid = (r - l) / 2 + l; if(vec[mid] == target) { return mid; } else if(vec[mid] &gt; target) { r = mid - 1; } else { l = mid + 1; } } return -1;} 左闭右开123456789101112131415161718class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { int len = nums.size(); int l = 0, r = len; while(l &lt; r) { int mid = (r - l) / 2 + l; if(nums[mid] == target) { return mid; } else if(nums[mid] &gt; target) { r = mid; } else { l = mid + 1; } } return -1; }}; 总结 l和r代表区间，当区间内没有元素时查找结束 对于闭区间，是l &gt; r, 所以循环条件是 l &lt;= r 对于左闭右开区间，是l &gt;= r, 所以循环条件是 l &lt; r 区间左/右边界移动，移动到最小的查找区间，也就是区间不包括另一半区间和当前mid值 对于闭区间，r = mid - 1，不包括当前mid值[l, mid - 1] 对于左闭右开区间，r = mid，不包括当前mid值[l, mid) 左侧边界闭区间如果target在vec中，则找到最后一个target的下标如果target不在vec中，则找到target应该插入在哪个元素后面 123456789101112131415int binarySearch(vector&lt;int&gt;&amp; vec, int target) { int len = vec.size(); int l = 0, r = len - 1; while(l &lt;= r) { int mid = (r - l) / 2 + l; if(vec[mid] == target) { l = mid - 1; } else if(vec[mid] &gt; target) { r = mid - 1; } else { l = mid + 1; } } return l;} mid != target的情况，正常二分查找 mid == target， 找target的前驱，所以l = mid - 1（为啥不是mid）","link":"/home/2024/09/01/%E7%AE%97%E6%B3%95/OI-KIWI-02-%E4%BA%8C%E5%88%86/"},{"title":"01-Binder","text":"看源码的时候可以用uml图辅助理解 多进程为什么多进程 突破内存限制：Android系统在内存不足时，会优先杀占用内存多的进程 功能稳定性：把一些功能放到独立的进程中，保证进程功能的纯粹性和稳定性 规避系统内存泄漏：独立的WebView进程阻隔内存泄漏问题 隔离风险：不稳定功能放到子进程，保证主进程的稳定性 Android中的进程间通信 Binder aidl Socket 管道：handler 共享内存 fresco，mmkv（匿名） 信号： ANR监控 matrix、xcrash、友盟apm binder的优势 一次拷贝 将内核空间内存映射到用户空间 a发送数据到b，binder直接将数据拷贝到与b共享的内存空间中 cs架构，稳定性好 安全，有身份验证（交换pid，由内核完成 AIDL DSL aidl将dsl文件编译成Java 四大组件 init启动 zygote servicemanager bindService一共几次IPC 客户端与ServiceManager交互获得AMS的IBinder 客户端通过AMS的IBinder请求bindService AMS与服务进程通信，调用onBind，获取IBinder 服务端把IBinder交给AMS，先ServiceManager交互获得AMS的IBinder 服务端通过AMS的IBinder发布自己的IBinder给AMS AMS与客户端通信，转发服务端的IBinder（代理BinderProxy） binder数据传输的大小限制 10241024-40962 BIND_VM_SIZE = 1M - sysconf(_SC_PAGE_SIZE) * 2 aidl 异步传输：oneway，BIND_VM_SIZE/2 同步传输：BIND_VM_SIZE Binder其他知识 四棵红黑树 Binder线程池 Binder驱动binder_init通过misc_register注册特殊设备 12345678910111213141516static const struct file_operations binder_fops = { .owner = THIS_MODULE, .poll = binder_poll, .unlocked_ioctl = binder_ioctl, .compat_ioctl = binder_ioctl, .mmap = binder_mmap, .open = binder_open, .flush = binder_flush, .release = binder_release,}; // 系统调用与驱动的对应关系static struct miscdevice binder_miscdev = { .minor = MISC_DYNAMIC_MINOR, //次设备号 动态分配 .name = &quot;binder&quot;, //设备名 .fops = &amp;binder_fops //设备的文件操作结构，这是file_operations结构}; open -&gt; binder_open 创建binder_proc结构并初始化 保存进程信息 加锁，计数++，hlist_add_head filp文件指针的private_data指向binder_proc mmap -&gt; binder_mmap1234//地址偏移量 = 用户虚拟地址空间 - 内核虚拟地址空间proc-&gt;user_buffer_offset = vma-&gt;vm_start - (uintptr_t)proc-&gt;buffer;//异步可用空间大小为buffer总大小的一半。proc-&gt;free_async_space = proc-&gt;buffer_size / 2; ioctl -&gt; binder_ioctl ioctl命令 数据类型 操作 使用场景 BINDER_WRITE_READ struct binder_write_read 收发Binder IPC数据 Binder读写交互场景，IPC.talkWithDriver BINDER_SET_MAX_THREADS __u32 设置Binder线程最大个数 BINDER_SET_CONTEXT_MGR __s32 设置Service Manager节点 servicemanager进程成为上下文管理者，binder_become_context_manager() BINDER_THREAD_EXIT __s32 释放Binder线程 BINDER_VERSION struct binder_version 获取Binder版本信息 12345678910111213141516171819202122232425static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { //进入休眠状态，直到中断唤醒 ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2); binder_lock(__func__); //获取binder_thread thread = binder_get_thread(proc); switch (cmd) { case BINDER_WRITE_READ: //进行binder的读写操作 ret = binder_ioctl_write_read(filp, cmd, arg, thread); if (ret) goto err; break; // case ....: // xxxx }err: if (thread) thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_NEED_RETURN; binder_unlock(__func__); wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);err_unlocked: trace_binder_ioctl_done(ret); return ret;} binder_get_thread 从一颗红黑树上根据pid找当前线程 如果没有，则创建节点 binder_ioctl_write_read copy_from_user读取bwr 检查读写缓存中是否有数据，如果有，就执行读写 copy_to_user将bwr写回用户空间 Binder层次结构 Binder通信模型 通信码 从ICP层至内核：BC_请求码 从内核到IPC层：BR_响应码 过程 binder_thread_write循环根据cmd处理请求 BC_FREE_BUFFER 通过mmap映射内存，ServiceManager映射空间为128K，Binder应用进程为1M-8K allocated_buffers和free_buffers是两棵红黑树，分别存放已分配内存和未分配内存。分配内存时使用最佳适应算法。 BC_TRANSACTION 最常见的码，将交易转化成binder_work Client向Binder驱动发送请求数据 BC_REPLY Server向Binder驱动发送请求数据 binder_thread_read 根据work和当前状态生成响应码，接下来由用户态进行处理 ServiceManager servicemanager是操作系统的一个可执行文件，在init.rc中启动 main1234567891011int main(int argc, char **argv) { struct binder_state *bs; //打开binder驱动，申请128k字节大小的内存空间 bs = binder_open(128*1024); // 不是上面binder driver的binder_open //成为上下文管理者 binder_become_context_manager(bs); // 调用ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, 0); //进入无限循环，处理client端发来的请求 binder_loop(bs, svcmgr_handler); return 0;} binder_open1234567891011121314151617181920struct binder_state *binder_open(size_t mapsize){ struct binder_state *bs; struct binder_version vers; bs = malloc(sizeof(*bs)); //通过系统调用陷入内核，打开Binder设备驱动 bs-&gt;fd = open(&quot;/dev/binder&quot;, O_RDWR); // 调用上面驱动的binder_open，打开驱动，初始化，返回文件描述符 //通过系统调用，ioctl获取binder版本信息 // ioctl发送BINDER_VERSION，获取版本号与用户空间的版本号比较 bs-&gt;mapsize = mapsize; //通过系统调用，mmap内存映射，mmap必须是page的整数倍 bs-&gt;mapped = mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0); // 调用驱动的binder_mmap，建立内存映射 return bs;} binder_become_context_manager1234567ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, 0);-&gt;binder_ioctl()-&gt;binder_ioctl_set_ctx_mgr()-&gt;// 创建binder_new_node，weak、strong引用数++，将节点加入proc红黑树 binder_loop123456readbuf[0] = BC_ENTER_LOOPER;binder_write(bs, readbuf, sizeof(uint32_t));// 通过binider_write通知进入loopfor(;;) { res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr); res = binder_parse(bs, 0, (uintptr_t) readbuf, bwr.read_consumed, func);} binder_write123456789101112131415int binder_write(struct binder_state *bs, void *data, size_t len) { struct binder_write_read bwr; int res; bwr.write_size = len; bwr.write_consumed = 0; bwr.write_buffer = (uintptr_t) data; //此处data为BC_ENTER_LOOPER bwr.read_size = 0; bwr.read_consumed = 0; bwr.read_buffer = 0; res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr); return res;} // 就是通过ioctl传递消息，最终在驱动中找到thread，设置标志// thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED; 提供功能：注册服务、添加服务 BBinder和BpBinder12virtual BBinder* localBinder();virtual BpBinder* remoteBinder(); BpBinder负责传输数据，BBinder负责接收数据和处理数据。","link":"/home/2024/03/24/Android%E9%AB%98%E7%BA%A7/FrameWork/01-Binder/"},{"title":"实验-请求调页存储管理方式的模拟","text":"1、实验目的通过对页面、页表、地址转换和页面置换过程的模拟，加深对请求调页系统的原理和实现过程的理解。 2、实验内容 假设每个页面中可存放10条指令，分配给一作业的内存块数为4。 用C语言模拟一作业的执行过程。该作业共有320条指令，即它的地址空间为32页，目前它的所有页都还未调入内存。在模拟过程中，如果所访问的指令已经在内存中，则显示其物理地址，并转下一条指令。如果所访问的指令还未装入内存，则发生缺页，此时需记录缺页的次数，并将相应页调入内存。如果4个内存块中均已装入该作业，则需进行页面置换。最后显示其物理地址，并转下一条指令。在所有320条指令执行完毕后，请计算并显示作业运行过程中发生的缺页率。 置换算法：请分别考虑OPT、FIFO和LRU算法。 作业中指令的访问次序按下述原则生成： • 50%的指令是顺序执行的。• 25%的指令是均匀分布在前地址部分。• 25%的指令时均匀分布在后地址部分。 具体的实施办法是： ① 在[0，319]之间随机选取一条起始执行指令，其序号为m；② 顺序执行下一条指令，即序号为m+1的指令；③ 通过随机数，跳转到前地址部分[0，m-1]中的某条指令处，其序号为m1；④ 顺序执行下一条指令，即序号为m1+1的指令；⑤ 通过随机数，跳转到后地址部分[m1+2，319]中的某条指令处，其序号为m2；⑥ 顺序执行下一条指令，即序号为m2+1的指令；⑦ 重复跳转到前地址部分、顺序执行、跳转到后地址部分、顺序执行的过程，直至执行320条指令。 实验代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;random&gt;#include &lt;ctime&gt;#include &lt;iomanip&gt;#include &lt;queue&gt;#include &lt;stack&gt;using std::cout;using std::endl;#define show_progressconst int max_ins_num = 320;const int ins_per_mb = 10;const int mem_max_mb = 4;int cur_clock = 0;const int total_mb = max_ins_num/ins_per_mb;int get_inst_i(int min, int max) { static std::default_random_engine engine(time(nullptr)); //std::uniform_int_distribution&lt;int&gt;distribution(min, max); return engine() %(max - min + 1) + min;}#define chart_head std::left &lt;&lt; std::setw(len+1) &lt;&lt; std::setfill('-') &lt;&lt; &quot;&quot;#define chart_cell &quot;|&quot; &lt;&lt; std::left &lt;&lt; std::setw(len) &lt;&lt; std::setfill(' ')void show_chart(std::queue&lt;int&gt; fifo, std::stack&lt;int&gt; lru, const std::vector&lt;int&gt;&amp; opt, int ins, int block) { std::cout &lt;&lt; &quot;cur_ins = &quot; &lt;&lt; ins &lt;&lt; &quot;\\ncur_block = &quot; &lt;&lt; block &lt;&lt; std::endl; int len = 5; std::cout &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;-&quot; &lt;&lt; std::endl &lt;&lt; chart_cell &lt;&lt; &quot;fifo&quot; &lt;&lt; chart_cell&lt;&lt; &quot;lru&quot; &lt;&lt; chart_cell &lt;&lt; &quot;opt&quot; &lt;&lt; &quot;|&quot; &lt;&lt; std::endl &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;-&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; mem_max_mb; ++i) { int lru_cout = -1; int fifo_cout = -1; if (!fifo.empty()) { fifo_cout = fifo.front(); fifo.pop(); } if (!lru.empty()) { lru_cout = lru.top(); lru.pop(); } std::cout &lt;&lt; chart_cell &lt;&lt; fifo_cout &lt;&lt; chart_cell &lt;&lt; lru_cout &lt;&lt; chart_cell &lt;&lt; opt[i] &lt;&lt; &quot;|&quot; &lt;&lt; std::endl; } std::cout &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;-&quot; &lt;&lt; std::endl;}int fifo_exchange = 0;int lru_exchange = 0;int opt_exchange = 0;void exe_inst_i(int ins, const std::vector&lt;int&gt;&amp; ins_arr) { static std::queue&lt;int&gt; fifo_mem_blocks; static std::vector&lt;bool&gt; fifo_map(total_mb, false); static std::stack&lt;int&gt; lru_mem_blocks; static std::vector&lt;bool&gt; lru_map(total_mb, false); static std::vector&lt;int&gt; opt_mem_blocks(mem_max_mb, -1); static std::vector&lt;int&gt; opt_map(total_mb, max_ins_num); int cur_ins = ins; int cur_block = ins/ins_per_mb; //fifo if(!fifo_map[cur_block]) { if (fifo_mem_blocks.size() &gt;= mem_max_mb) { fifo_map[fifo_mem_blocks.front()] = false; fifo_mem_blocks.pop(); fifo_exchange++; } fifo_mem_blocks.push(cur_block); fifo_map[cur_block] = true; } else { } // lru std::stack&lt;int&gt; lru_temp; if (!lru_map[cur_block]) { while (!lru_mem_blocks.empty()) { lru_temp.push(lru_mem_blocks.top()); lru_mem_blocks.pop(); } if (lru_temp.size() &gt;= mem_max_mb) { lru_map[lru_temp.top()] = false; lru_temp.pop(); lru_exchange++; } lru_map[cur_block] = true; while (!lru_temp.empty()) { lru_mem_blocks.push(lru_temp.top()); lru_temp.pop(); } lru_mem_blocks.push(cur_block); } else { while (lru_mem_blocks.top() != cur_block) { lru_temp.push(lru_mem_blocks.top()); lru_mem_blocks.pop(); } lru_mem_blocks.pop(); while (!lru_temp.empty()) { lru_mem_blocks.push(lru_temp.top()); lru_temp.pop(); } lru_mem_blocks.push(cur_block); } //opt for (int i = cur_clock; i &lt; max_ins_num; i++) { int block_i = ins_arr[i]/ins_per_mb; opt_map[block_i] = opt_map[block_i] &lt; i ? opt_map[block_i] : i; //设置opt=从clock开始，某个块儿第一次出现的位置 } static int opt_num = 0; int opt_exchange_i = 0; for (int i = 0; i &lt; mem_max_mb; ++i) { if (opt_mem_blocks[i] == cur_block || opt_mem_blocks[i] == -1) { opt_exchange_i = i; // 需要的块儿已经在里面了，停止 break; }// 如果不在里面，分支不会执行，可以找到最远被访问的最佳替换 if (opt_map[opt_mem_blocks[i]] &gt; opt_map[opt_mem_blocks[opt_exchange_i]]) { //这里opt_exchange_i 和 i等价的，少套用了一层 opt_exchange_i = i; } } if (opt_mem_blocks[opt_exchange_i] == -1) { opt_mem_blocks[opt_num] = cur_block; opt_num++; } else if (opt_mem_blocks[opt_exchange_i] != cur_block) { opt_mem_blocks[opt_exchange_i] = cur_block; opt_exchange++; } //opt_map[cur_block] = max_ins_num; for (int i = 0; i &lt; total_mb; i++) { opt_map[i] = max_ins_num; } //执行过的块儿置为最大值，意为再也不用（可能）#ifdef show_progress show_chart(fifo_mem_blocks, lru_mem_blocks, opt_mem_blocks, cur_ins, cur_block);#endif}void show_info(int fifo, int lru, int opt) { int len = int(std::string(&quot;miss_ratio&quot;).length()+1); std::cout &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;-&quot; &lt;&lt; std::endl &lt;&lt; chart_cell &lt;&lt; &quot;item&quot; &lt;&lt; chart_cell &lt;&lt; &quot;fifo&quot; &lt;&lt; chart_cell&lt;&lt; &quot;lru&quot; &lt;&lt; chart_cell &lt;&lt; &quot;opt&quot; &lt;&lt; &quot;|&quot; &lt;&lt; std::endl &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;-&quot; &lt;&lt; std::endl &lt;&lt; chart_cell &lt;&lt; &quot;hit&quot; &lt;&lt; chart_cell &lt;&lt; max_ins_num-fifo &lt;&lt; chart_cell &lt;&lt; max_ins_num-lru &lt;&lt; chart_cell &lt;&lt; max_ins_num-opt &lt;&lt; &quot;|&quot; &lt;&lt; std::endl &lt;&lt; chart_cell &lt;&lt; &quot;hit_ratio&quot; &lt;&lt; chart_cell &lt;&lt; (1-fifo/(double)max_ins_num)*100 &lt;&lt; chart_cell &lt;&lt; (1-lru/(double)max_ins_num)*100 &lt;&lt; chart_cell &lt;&lt; (1-opt/(double)max_ins_num)*100 &lt;&lt; &quot;|&quot; &lt;&lt; std::endl &lt;&lt; chart_cell &lt;&lt; &quot;miss&quot; &lt;&lt; chart_cell &lt;&lt; fifo &lt;&lt; chart_cell &lt;&lt; lru &lt;&lt; chart_cell &lt;&lt; opt &lt;&lt; &quot;|&quot; &lt;&lt; std::endl &lt;&lt; chart_cell &lt;&lt; &quot;miss_ratio&quot; &lt;&lt; chart_cell &lt;&lt; fifo/(double)max_ins_num*100 &lt;&lt; chart_cell &lt;&lt; lru/(double)max_ins_num*100 &lt;&lt; chart_cell &lt;&lt; opt/(double)max_ins_num*100 &lt;&lt; &quot;|&quot; &lt;&lt; std::endl &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;-&quot; &lt;&lt; std::endl;}int main() { std::vector&lt;int&gt; ins_arr(max_ins_num,0); int ins; for(int i = 0; i &lt; max_ins_num; i++) { if (i%6 == 0) { ins = get_inst_i(0,max_ins_num-1); ins_arr[i] = ins; } else if (i%6 == 1 || i%6 == 3 || i%6 == 5) { ins_arr[i] = ins_arr[i-1] + 1 &lt; max_ins_num ? ins_arr[i-1] + 1 : max_ins_num-1; } else if (i%6 == 2){ ins = get_inst_i(0, ins - 1 &gt; 0 ? ins - 1 : 1); ins_arr[i] = ins; } else if (i%6 == 4) { ins = get_inst_i(ins + 2 &gt; max_ins_num-2 ? max_ins_num-2 : ins+2, max_ins_num-1); ins_arr[i] = ins; } } for (cur_clock = 0; cur_clock &lt; max_ins_num; ++cur_clock) { exe_inst_i(ins_arr[cur_clock], ins_arr); } show_info(fifo_exchange, lru_exchange, opt_exchange); return 0;} 运行结果1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783178417851786178717881789179017911792179317941795179617971798179918001801180218031804180518061807180818091810181118121813181418151816181718181819182018211822182318241825182618271828182918301831183218331834183518361837183818391840184118421843184418451846184718481849185018511852185318541855185618571858185918601861186218631864186518661867186818691870187118721873187418751876187718781879188018811882188318841885188618871888188918901891189218931894189518961897189818991900190119021903190419051906190719081909191019111912191319141915191619171918191919201921192219231924192519261927192819291930193119321933193419351936193719381939194019411942194319441945194619471948194919501951195219531954195519561957195819591960196119621963196419651966196719681969197019711972197319741975197619771978197919801981198219831984198519861987198819891990199119921993199419951996199719981999200020012002200320042005200620072008200920102011201220132014201520162017201820192020202120222023202420252026202720282029203020312032203320342035203620372038203920402041204220432044204520462047204820492050205120522053205420552056205720582059206020612062206320642065206620672068206920702071207220732074207520762077207820792080208120822083208420852086208720882089209020912092209320942095209620972098209921002101210221032104210521062107210821092110211121122113211421152116211721182119212021212122212321242125212621272128212921302131213221332134213521362137213821392140214121422143214421452146214721482149215021512152215321542155215621572158215921602161216221632164216521662167216821692170217121722173217421752176217721782179218021812182218321842185218621872188218921902191219221932194219521962197219821992200220122022203220422052206220722082209221022112212221322142215221622172218221922202221222222232224222522262227222822292230223122322233223422352236223722382239224022412242224322442245224622472248224922502251225222532254225522562257225822592260226122622263226422652266226722682269227022712272227322742275227622772278227922802281228222832284228522862287228822892290229122922293229422952296229722982299230023012302230323042305230623072308230923102311231223132314231523162317231823192320232123222323232423252326232723282329233023312332233323342335233623372338233923402341234223432344234523462347234823492350235123522353235423552356235723582359236023612362236323642365236623672368236923702371237223732374237523762377237823792380238123822383238423852386238723882389239023912392239323942395239623972398239924002401240224032404240524062407240824092410241124122413241424152416241724182419242024212422242324242425242624272428242924302431243224332434243524362437243824392440244124422443244424452446244724482449245024512452245324542455245624572458245924602461246224632464246524662467246824692470247124722473247424752476247724782479248024812482248324842485248624872488248924902491249224932494249524962497249824992500250125022503250425052506250725082509251025112512251325142515251625172518251925202521252225232524252525262527252825292530253125322533253425352536253725382539254025412542254325442545254625472548254925502551255225532554255525562557255825592560256125622563256425652566256725682569257025712572257325742575257625772578257925802581258225832584258525862587258825892590259125922593259425952596259725982599260026012602260326042605260626072608260926102611261226132614261526162617261826192620262126222623262426252626262726282629263026312632263326342635263626372638263926402641264226432644264526462647264826492650265126522653265426552656265726582659266026612662266326642665266626672668266926702671267226732674267526762677267826792680268126822683268426852686268726882689269026912692269326942695269626972698269927002701270227032704270527062707270827092710271127122713271427152716271727182719272027212722272327242725272627272728272927302731273227332734273527362737273827392740274127422743274427452746274727482749275027512752275327542755275627572758275927602761276227632764276527662767276827692770277127722773277427752776277727782779278027812782278327842785278627872788278927902791279227932794279527962797279827992800280128022803280428052806280728082809281028112812281328142815281628172818281928202821282228232824282528262827282828292830283128322833283428352836283728382839284028412842284328442845284628472848284928502851285228532854285528562857285828592860286128622863286428652866286728682869287028712872287328742875287628772878287928802881288228832884288528862887288828892890289128922893289428952896289728982899290029012902290329042905290629072908290929102911291229132914291529162917291829192920292129222923292429252926292729282929293029312932293329342935293629372938293929402941294229432944294529462947294829492950295129522953295429552956295729582959296029612962296329642965296629672968296929702971297229732974297529762977297829792980298129822983298429852986298729882989299029912992299329942995299629972998299930003001300230033004300530063007300830093010301130123013301430153016301730183019302030213022302330243025302630273028302930303031303230333034303530363037303830393040304130423043304430453046304730483049305030513052305330543055305630573058305930603061306230633064306530663067306830693070307130723073307430753076307730783079308030813082308330843085308630873088308930903091309230933094309530963097309830993100310131023103310431053106310731083109311031113112311331143115311631173118311931203121312231233124312531263127312831293130313131323133313431353136313731383139314031413142314331443145314631473148314931503151315231533154315531563157315831593160316131623163316431653166316731683169317031713172317331743175317631773178317931803181318231833184318531863187318831893190319131923193319431953196319731983199320032013202320332043205320632073208cur_ins = 222cur_block = 22-------------------|fifo |lru |opt |-------------------|22 |22 |22 ||-1 |-1 |-1 ||-1 |-1 |-1 ||-1 |-1 |-1 |-------------------cur_ins = 223cur_block = 22-------------------|fifo |lru |opt |-------------------|22 |22 |22 ||-1 |-1 |-1 ||-1 |-1 |-1 ||-1 |-1 |-1 |-------------------cur_ins = 179cur_block = 17-------------------|fifo |lru |opt |-------------------|22 |17 |22 ||17 |22 |17 ||-1 |-1 |-1 ||-1 |-1 |-1 |-------------------cur_ins = 180cur_block = 18-------------------|fifo |lru |opt |-------------------|22 |18 |22 ||17 |17 |17 ||18 |22 |18 ||-1 |-1 |-1 |-------------------cur_ins = 255cur_block = 25-------------------|fifo |lru |opt |-------------------|22 |25 |22 ||17 |18 |17 ||18 |17 |18 ||25 |22 |25 |-------------------cur_ins = 256cur_block = 25-------------------|fifo |lru |opt |-------------------|22 |25 |22 ||17 |18 |17 ||18 |17 |18 ||25 |22 |25 |-------------------cur_ins = 312cur_block = 31-------------------|fifo |lru |opt |-------------------|17 |31 |22 ||18 |25 |31 ||25 |18 |18 ||31 |17 |25 |-------------------cur_ins = 313cur_block = 31-------------------|fifo |lru |opt |-------------------|17 |31 |22 ||18 |25 |31 ||25 |18 |18 ||31 |17 |25 |-------------------cur_ins = 17cur_block = 1-------------------|fifo |lru |opt |-------------------|18 |1 |22 ||25 |31 |1 ||31 |25 |18 ||1 |18 |25 |-------------------cur_ins = 18cur_block = 1-------------------|fifo |lru |opt |-------------------|18 |1 |22 ||25 |31 |1 ||31 |25 |18 ||1 |18 |25 |-------------------cur_ins = 232cur_block = 23-------------------|fifo |lru |opt |-------------------|25 |23 |22 ||31 |1 |1 ||1 |31 |23 ||23 |25 |25 |-------------------cur_ins = 233cur_block = 23-------------------|fifo |lru |opt |-------------------|25 |23 |22 ||31 |1 |1 ||1 |31 |23 ||23 |25 |25 |-------------------cur_ins = 83cur_block = 8-------------------|fifo |lru |opt |-------------------|31 |8 |22 ||1 |23 |1 ||23 |1 |8 ||8 |31 |25 |-------------------cur_ins = 84cur_block = 8-------------------|fifo |lru |opt |-------------------|31 |8 |22 ||1 |23 |1 ||23 |1 |8 ||8 |31 |25 |-------------------cur_ins = 23cur_block = 2-------------------|fifo |lru |opt |-------------------|1 |2 |22 ||23 |8 |1 ||8 |23 |2 ||2 |1 |25 |-------------------cur_ins = 24cur_block = 2-------------------|fifo |lru |opt |-------------------|1 |2 |22 ||23 |8 |1 ||8 |23 |2 ||2 |1 |25 |-------------------cur_ins = 196cur_block = 19-------------------|fifo |lru |opt |-------------------|23 |19 |22 ||8 |2 |1 ||2 |8 |2 ||19 |23 |19 |-------------------cur_ins = 197cur_block = 19-------------------|fifo |lru |opt |-------------------|23 |19 |22 ||8 |2 |1 ||2 |8 |2 ||19 |23 |19 |-------------------cur_ins = 212cur_block = 21-------------------|fifo |lru |opt |-------------------|8 |21 |21 ||2 |19 |1 ||19 |2 |2 ||21 |8 |19 |-------------------cur_ins = 213cur_block = 21-------------------|fifo |lru |opt |-------------------|8 |21 |21 ||2 |19 |1 ||19 |2 |2 ||21 |8 |19 |-------------------cur_ins = 45cur_block = 4-------------------|fifo |lru |opt |-------------------|2 |4 |4 ||19 |21 |1 ||21 |19 |2 ||4 |2 |19 |-------------------cur_ins = 46cur_block = 4-------------------|fifo |lru |opt |-------------------|2 |4 |4 ||19 |21 |1 ||21 |19 |2 ||4 |2 |19 |-------------------cur_ins = 193cur_block = 19-------------------|fifo |lru |opt |-------------------|2 |19 |4 ||19 |4 |1 ||21 |21 |2 ||4 |2 |19 |-------------------cur_ins = 194cur_block = 19-------------------|fifo |lru |opt |-------------------|2 |19 |4 ||19 |4 |1 ||21 |21 |2 ||4 |2 |19 |-------------------cur_ins = 157cur_block = 15-------------------|fifo |lru |opt |-------------------|19 |15 |15 ||21 |19 |1 ||4 |4 |2 ||15 |21 |19 |-------------------cur_ins = 158cur_block = 15-------------------|fifo |lru |opt |-------------------|19 |15 |15 ||21 |19 |1 ||4 |4 |2 ||15 |21 |19 |-------------------cur_ins = 31cur_block = 3-------------------|fifo |lru |opt |-------------------|21 |3 |3 ||4 |15 |1 ||15 |19 |2 ||3 |4 |19 |-------------------cur_ins = 32cur_block = 3-------------------|fifo |lru |opt |-------------------|21 |3 |3 ||4 |15 |1 ||15 |19 |2 ||3 |4 |19 |-------------------cur_ins = 142cur_block = 14-------------------|fifo |lru |opt |-------------------|4 |14 |14 ||15 |3 |1 ||3 |15 |2 ||14 |19 |19 |-------------------cur_ins = 143cur_block = 14-------------------|fifo |lru |opt |-------------------|4 |14 |14 ||15 |3 |1 ||3 |15 |2 ||14 |19 |19 |-------------------cur_ins = 190cur_block = 19-------------------|fifo |lru |opt |-------------------|15 |19 |14 ||3 |14 |1 ||14 |3 |2 ||19 |15 |19 |-------------------cur_ins = 191cur_block = 19-------------------|fifo |lru |opt |-------------------|15 |19 |14 ||3 |14 |1 ||14 |3 |2 ||19 |15 |19 |-------------------cur_ins = 115cur_block = 11-------------------|fifo |lru |opt |-------------------|3 |11 |11 ||14 |19 |1 ||19 |14 |2 ||11 |3 |19 |-------------------cur_ins = 116cur_block = 11-------------------|fifo |lru |opt |-------------------|3 |11 |11 ||14 |19 |1 ||19 |14 |2 ||11 |3 |19 |-------------------cur_ins = 192cur_block = 19-------------------|fifo |lru |opt |-------------------|3 |19 |11 ||14 |11 |1 ||19 |14 |2 ||11 |3 |19 |-------------------cur_ins = 193cur_block = 19-------------------|fifo |lru |opt |-------------------|3 |19 |11 ||14 |11 |1 ||19 |14 |2 ||11 |3 |19 |-------------------cur_ins = 271cur_block = 27-------------------|fifo |lru |opt |-------------------|14 |27 |11 ||19 |19 |1 ||11 |11 |2 ||27 |14 |27 |-------------------cur_ins = 272cur_block = 27-------------------|fifo |lru |opt |-------------------|14 |27 |11 ||19 |19 |1 ||11 |11 |2 ||27 |14 |27 |-------------------cur_ins = 27cur_block = 2-------------------|fifo |lru |opt |-------------------|19 |2 |11 ||11 |27 |1 ||27 |19 |2 ||2 |11 |27 |-------------------cur_ins = 28cur_block = 2-------------------|fifo |lru |opt |-------------------|19 |2 |11 ||11 |27 |1 ||27 |19 |2 ||2 |11 |27 |-------------------cur_ins = 264cur_block = 26-------------------|fifo |lru |opt |-------------------|11 |26 |11 ||27 |2 |1 ||2 |27 |2 ||26 |19 |26 |-------------------cur_ins = 265cur_block = 26-------------------|fifo |lru |opt |-------------------|11 |26 |11 ||27 |2 |1 ||2 |27 |2 ||26 |19 |26 |-------------------cur_ins = 9cur_block = 0-------------------|fifo |lru |opt |-------------------|27 |0 |11 ||2 |26 |1 ||26 |2 |0 ||0 |27 |26 |-------------------cur_ins = 10cur_block = 1-------------------|fifo |lru |opt |-------------------|2 |1 |11 ||26 |0 |1 ||0 |26 |0 ||1 |2 |26 |-------------------cur_ins = 4cur_block = 0-------------------|fifo |lru |opt |-------------------|2 |0 |11 ||26 |1 |1 ||0 |26 |0 ||1 |2 |26 |-------------------cur_ins = 5cur_block = 0-------------------|fifo |lru |opt |-------------------|2 |0 |11 ||26 |1 |1 ||0 |26 |0 ||1 |2 |26 |-------------------cur_ins = 219cur_block = 21-------------------|fifo |lru |opt |-------------------|26 |21 |11 ||0 |0 |1 ||1 |1 |21 ||21 |26 |26 |-------------------cur_ins = 220cur_block = 22-------------------|fifo |lru |opt |-------------------|0 |22 |11 ||1 |21 |1 ||21 |0 |22 ||22 |1 |26 |-------------------cur_ins = 122cur_block = 12-------------------|fifo |lru |opt |-------------------|1 |12 |11 ||21 |22 |1 ||22 |21 |12 ||12 |0 |26 |-------------------cur_ins = 123cur_block = 12-------------------|fifo |lru |opt |-------------------|1 |12 |11 ||21 |22 |1 ||22 |21 |12 ||12 |0 |26 |-------------------cur_ins = 121cur_block = 12-------------------|fifo |lru |opt |-------------------|1 |12 |11 ||21 |22 |1 ||22 |21 |12 ||12 |0 |26 |-------------------cur_ins = 122cur_block = 12-------------------|fifo |lru |opt |-------------------|1 |12 |11 ||21 |22 |1 ||22 |21 |12 ||12 |0 |26 |-------------------cur_ins = 295cur_block = 29-------------------|fifo |lru |opt |-------------------|21 |29 |11 ||22 |12 |1 ||12 |22 |29 ||29 |21 |26 |-------------------cur_ins = 296cur_block = 29-------------------|fifo |lru |opt |-------------------|21 |29 |11 ||22 |12 |1 ||12 |22 |29 ||29 |21 |26 |-------------------cur_ins = 158cur_block = 15-------------------|fifo |lru |opt |-------------------|22 |15 |11 ||12 |29 |1 ||29 |12 |15 ||15 |22 |26 |-------------------cur_ins = 159cur_block = 15-------------------|fifo |lru |opt |-------------------|22 |15 |11 ||12 |29 |1 ||29 |12 |15 ||15 |22 |26 |-------------------cur_ins = 15cur_block = 1-------------------|fifo |lru |opt |-------------------|12 |1 |11 ||29 |15 |1 ||15 |29 |15 ||1 |12 |26 |-------------------cur_ins = 16cur_block = 1-------------------|fifo |lru |opt |-------------------|12 |1 |11 ||29 |15 |1 ||15 |29 |15 ||1 |12 |26 |-------------------cur_ins = 53cur_block = 5-------------------|fifo |lru |opt |-------------------|29 |5 |11 ||15 |1 |1 ||1 |15 |5 ||5 |29 |26 |-------------------cur_ins = 54cur_block = 5-------------------|fifo |lru |opt |-------------------|29 |5 |11 ||15 |1 |1 ||1 |15 |5 ||5 |29 |26 |-------------------cur_ins = 161cur_block = 16-------------------|fifo |lru |opt |-------------------|15 |16 |11 ||1 |5 |16 ||5 |1 |5 ||16 |15 |26 |-------------------cur_ins = 162cur_block = 16-------------------|fifo |lru |opt |-------------------|15 |16 |11 ||1 |5 |16 ||5 |1 |5 ||16 |15 |26 |-------------------cur_ins = 97cur_block = 9-------------------|fifo |lru |opt |-------------------|1 |9 |11 ||5 |16 |9 ||16 |5 |5 ||9 |1 |26 |-------------------cur_ins = 98cur_block = 9-------------------|fifo |lru |opt |-------------------|1 |9 |11 ||5 |16 |9 ||16 |5 |5 ||9 |1 |26 |-------------------cur_ins = 131cur_block = 13-------------------|fifo |lru |opt |-------------------|5 |13 |11 ||16 |9 |13 ||9 |16 |5 ||13 |5 |26 |-------------------cur_ins = 132cur_block = 13-------------------|fifo |lru |opt |-------------------|5 |13 |11 ||16 |9 |13 ||9 |16 |5 ||13 |5 |26 |-------------------cur_ins = 259cur_block = 25-------------------|fifo |lru |opt |-------------------|16 |25 |11 ||9 |13 |25 ||13 |9 |5 ||25 |16 |26 |-------------------cur_ins = 260cur_block = 26-------------------|fifo |lru |opt |-------------------|9 |26 |11 ||13 |25 |25 ||25 |13 |5 ||26 |9 |26 |-------------------cur_ins = 241cur_block = 24-------------------|fifo |lru |opt |-------------------|13 |24 |11 ||25 |26 |25 ||26 |25 |5 ||24 |13 |24 |-------------------cur_ins = 242cur_block = 24-------------------|fifo |lru |opt |-------------------|13 |24 |11 ||25 |26 |25 ||26 |25 |5 ||24 |13 |24 |-------------------cur_ins = 256cur_block = 25-------------------|fifo |lru |opt |-------------------|13 |25 |11 ||25 |24 |25 ||26 |26 |5 ||24 |13 |24 |-------------------cur_ins = 257cur_block = 25-------------------|fifo |lru |opt |-------------------|13 |25 |11 ||25 |24 |25 ||26 |26 |5 ||24 |13 |24 |-------------------cur_ins = 114cur_block = 11-------------------|fifo |lru |opt |-------------------|25 |11 |11 ||26 |25 |25 ||24 |24 |5 ||11 |26 |24 |-------------------cur_ins = 115cur_block = 11-------------------|fifo |lru |opt |-------------------|25 |11 |11 ||26 |25 |25 ||24 |24 |5 ||11 |26 |24 |-------------------cur_ins = 35cur_block = 3-------------------|fifo |lru |opt |-------------------|26 |3 |3 ||24 |11 |25 ||11 |25 |5 ||3 |24 |24 |-------------------cur_ins = 36cur_block = 3-------------------|fifo |lru |opt |-------------------|26 |3 |3 ||24 |11 |25 ||11 |25 |5 ||3 |24 |24 |-------------------cur_ins = 124cur_block = 12-------------------|fifo |lru |opt |-------------------|24 |12 |3 ||11 |3 |12 ||3 |11 |5 ||12 |25 |24 |-------------------cur_ins = 125cur_block = 12-------------------|fifo |lru |opt |-------------------|24 |12 |3 ||11 |3 |12 ||3 |11 |5 ||12 |25 |24 |-------------------cur_ins = 53cur_block = 5-------------------|fifo |lru |opt |-------------------|11 |5 |3 ||3 |12 |12 ||12 |3 |5 ||5 |11 |24 |-------------------cur_ins = 54cur_block = 5-------------------|fifo |lru |opt |-------------------|11 |5 |3 ||3 |12 |12 ||12 |3 |5 ||5 |11 |24 |-------------------cur_ins = 8cur_block = 0-------------------|fifo |lru |opt |-------------------|3 |0 |3 ||12 |5 |0 ||5 |12 |5 ||0 |3 |24 |-------------------cur_ins = 9cur_block = 0-------------------|fifo |lru |opt |-------------------|3 |0 |3 ||12 |5 |0 ||5 |12 |5 ||0 |3 |24 |-------------------cur_ins = 184cur_block = 18-------------------|fifo |lru |opt |-------------------|12 |18 |3 ||5 |0 |18 ||0 |5 |5 ||18 |12 |24 |-------------------cur_ins = 185cur_block = 18-------------------|fifo |lru |opt |-------------------|12 |18 |3 ||5 |0 |18 ||0 |5 |5 ||18 |12 |24 |-------------------cur_ins = 240cur_block = 24-------------------|fifo |lru |opt |-------------------|5 |24 |3 ||0 |18 |18 ||18 |0 |5 ||24 |5 |24 |-------------------cur_ins = 241cur_block = 24-------------------|fifo |lru |opt |-------------------|5 |24 |3 ||0 |18 |18 ||18 |0 |5 ||24 |5 |24 |-------------------cur_ins = 28cur_block = 2-------------------|fifo |lru |opt |-------------------|0 |2 |3 ||18 |24 |2 ||24 |18 |5 ||2 |0 |24 |-------------------cur_ins = 29cur_block = 2-------------------|fifo |lru |opt |-------------------|0 |2 |3 ||18 |24 |2 ||24 |18 |5 ||2 |0 |24 |-------------------cur_ins = 224cur_block = 22-------------------|fifo |lru |opt |-------------------|18 |22 |3 ||24 |2 |2 ||2 |24 |5 ||22 |18 |22 |-------------------cur_ins = 225cur_block = 22-------------------|fifo |lru |opt |-------------------|18 |22 |3 ||24 |2 |2 ||2 |24 |5 ||22 |18 |22 |-------------------cur_ins = 92cur_block = 9-------------------|fifo |lru |opt |-------------------|24 |9 |3 ||2 |22 |2 ||22 |2 |5 ||9 |24 |9 |-------------------cur_ins = 93cur_block = 9-------------------|fifo |lru |opt |-------------------|24 |9 |3 ||2 |22 |2 ||22 |2 |5 ||9 |24 |9 |-------------------cur_ins = 49cur_block = 4-------------------|fifo |lru |opt |-------------------|2 |4 |3 ||22 |9 |2 ||9 |22 |5 ||4 |2 |4 |-------------------cur_ins = 50cur_block = 5-------------------|fifo |lru |opt |-------------------|22 |5 |3 ||9 |4 |2 ||4 |9 |5 ||5 |22 |4 |-------------------cur_ins = 279cur_block = 27-------------------|fifo |lru |opt |-------------------|9 |27 |3 ||4 |5 |2 ||5 |4 |5 ||27 |9 |27 |-------------------cur_ins = 280cur_block = 28-------------------|fifo |lru |opt |-------------------|4 |28 |3 ||5 |27 |2 ||27 |5 |28 ||28 |4 |27 |-------------------cur_ins = 34cur_block = 3-------------------|fifo |lru |opt |-------------------|5 |3 |3 ||27 |28 |2 ||28 |27 |28 ||3 |5 |27 |-------------------cur_ins = 35cur_block = 3-------------------|fifo |lru |opt |-------------------|5 |3 |3 ||27 |28 |2 ||28 |27 |28 ||3 |5 |27 |-------------------cur_ins = 26cur_block = 2-------------------|fifo |lru |opt |-------------------|27 |2 |3 ||28 |3 |2 ||3 |28 |28 ||2 |27 |27 |-------------------cur_ins = 27cur_block = 2-------------------|fifo |lru |opt |-------------------|27 |2 |3 ||28 |3 |2 ||3 |28 |28 ||2 |27 |27 |-------------------cur_ins = 239cur_block = 23-------------------|fifo |lru |opt |-------------------|28 |23 |3 ||3 |2 |2 ||2 |3 |23 ||23 |28 |27 |-------------------cur_ins = 240cur_block = 24-------------------|fifo |lru |opt |-------------------|3 |24 |24 ||2 |23 |2 ||23 |2 |23 ||24 |3 |27 |-------------------cur_ins = 270cur_block = 27-------------------|fifo |lru |opt |-------------------|2 |27 |24 ||23 |24 |2 ||24 |23 |23 ||27 |2 |27 |-------------------cur_ins = 271cur_block = 27-------------------|fifo |lru |opt |-------------------|2 |27 |24 ||23 |24 |2 ||24 |23 |23 ||27 |2 |27 |-------------------cur_ins = 229cur_block = 22-------------------|fifo |lru |opt |-------------------|23 |22 |24 ||24 |27 |2 ||27 |24 |23 ||22 |23 |22 |-------------------cur_ins = 230cur_block = 23-------------------|fifo |lru |opt |-------------------|23 |23 |24 ||24 |22 |2 ||27 |27 |23 ||22 |24 |22 |-------------------cur_ins = 315cur_block = 31-------------------|fifo |lru |opt |-------------------|24 |31 |24 ||27 |23 |2 ||22 |22 |23 ||31 |27 |31 |-------------------cur_ins = 316cur_block = 31-------------------|fifo |lru |opt |-------------------|24 |31 |24 ||27 |23 |2 ||22 |22 |23 ||31 |27 |31 |-------------------cur_ins = 160cur_block = 16-------------------|fifo |lru |opt |-------------------|27 |16 |24 ||22 |31 |2 ||31 |23 |16 ||16 |22 |31 |-------------------cur_ins = 161cur_block = 16-------------------|fifo |lru |opt |-------------------|27 |16 |24 ||22 |31 |2 ||31 |23 |16 ||16 |22 |31 |-------------------cur_ins = 8cur_block = 0-------------------|fifo |lru |opt |-------------------|22 |0 |24 ||31 |16 |2 ||16 |31 |0 ||0 |23 |31 |-------------------cur_ins = 9cur_block = 0-------------------|fifo |lru |opt |-------------------|22 |0 |24 ||31 |16 |2 ||16 |31 |0 ||0 |23 |31 |-------------------cur_ins = 242cur_block = 24-------------------|fifo |lru |opt |-------------------|31 |24 |24 ||16 |0 |2 ||0 |16 |0 ||24 |31 |31 |-------------------cur_ins = 243cur_block = 24-------------------|fifo |lru |opt |-------------------|31 |24 |24 ||16 |0 |2 ||0 |16 |0 ||24 |31 |31 |-------------------cur_ins = 216cur_block = 21-------------------|fifo |lru |opt |-------------------|16 |21 |24 ||0 |24 |21 ||24 |0 |0 ||21 |16 |31 |-------------------cur_ins = 217cur_block = 21-------------------|fifo |lru |opt |-------------------|16 |21 |24 ||0 |24 |21 ||24 |0 |0 ||21 |16 |31 |-------------------cur_ins = 2cur_block = 0-------------------|fifo |lru |opt |-------------------|16 |0 |24 ||0 |21 |21 ||24 |24 |0 ||21 |16 |31 |-------------------cur_ins = 3cur_block = 0-------------------|fifo |lru |opt |-------------------|16 |0 |24 ||0 |21 |21 ||24 |24 |0 ||21 |16 |31 |-------------------cur_ins = 268cur_block = 26-------------------|fifo |lru |opt |-------------------|0 |26 |24 ||24 |0 |21 ||21 |21 |26 ||26 |24 |31 |-------------------cur_ins = 269cur_block = 26-------------------|fifo |lru |opt |-------------------|0 |26 |24 ||24 |0 |21 ||21 |21 |26 ||26 |24 |31 |-------------------cur_ins = 250cur_block = 25-------------------|fifo |lru |opt |-------------------|24 |25 |24 ||21 |26 |21 ||26 |0 |25 ||25 |21 |31 |-------------------cur_ins = 251cur_block = 25-------------------|fifo |lru |opt |-------------------|24 |25 |24 ||21 |26 |21 ||26 |0 |25 ||25 |21 |31 |-------------------cur_ins = 132cur_block = 13-------------------|fifo |lru |opt |-------------------|21 |13 |24 ||26 |25 |21 ||25 |26 |13 ||13 |0 |31 |-------------------cur_ins = 133cur_block = 13-------------------|fifo |lru |opt |-------------------|21 |13 |24 ||26 |25 |21 ||25 |26 |13 ||13 |0 |31 |-------------------cur_ins = 144cur_block = 14-------------------|fifo |lru |opt |-------------------|26 |14 |24 ||25 |13 |21 ||13 |25 |14 ||14 |26 |31 |-------------------cur_ins = 145cur_block = 14-------------------|fifo |lru |opt |-------------------|26 |14 |24 ||25 |13 |21 ||13 |25 |14 ||14 |26 |31 |-------------------cur_ins = 243cur_block = 24-------------------|fifo |lru |opt |-------------------|25 |24 |24 ||13 |14 |21 ||14 |13 |14 ||24 |25 |31 |-------------------cur_ins = 244cur_block = 24-------------------|fifo |lru |opt |-------------------|25 |24 |24 ||13 |14 |21 ||14 |13 |14 ||24 |25 |31 |-------------------cur_ins = 173cur_block = 17-------------------|fifo |lru |opt |-------------------|13 |17 |24 ||14 |24 |21 ||24 |14 |17 ||17 |13 |31 |-------------------cur_ins = 174cur_block = 17-------------------|fifo |lru |opt |-------------------|13 |17 |24 ||14 |24 |21 ||24 |14 |17 ||17 |13 |31 |-------------------cur_ins = 178cur_block = 17-------------------|fifo |lru |opt |-------------------|13 |17 |24 ||14 |24 |21 ||24 |14 |17 ||17 |13 |31 |-------------------cur_ins = 179cur_block = 17-------------------|fifo |lru |opt |-------------------|13 |17 |24 ||14 |24 |21 ||24 |14 |17 ||17 |13 |31 |-------------------cur_ins = 185cur_block = 18-------------------|fifo |lru |opt |-------------------|14 |18 |24 ||24 |17 |21 ||17 |24 |18 ||18 |14 |31 |-------------------cur_ins = 186cur_block = 18-------------------|fifo |lru |opt |-------------------|14 |18 |24 ||24 |17 |21 ||17 |24 |18 ||18 |14 |31 |-------------------cur_ins = 181cur_block = 18-------------------|fifo |lru |opt |-------------------|14 |18 |24 ||24 |17 |21 ||17 |24 |18 ||18 |14 |31 |-------------------cur_ins = 182cur_block = 18-------------------|fifo |lru |opt |-------------------|14 |18 |24 ||24 |17 |21 ||17 |24 |18 ||18 |14 |31 |-------------------cur_ins = 296cur_block = 29-------------------|fifo |lru |opt |-------------------|24 |29 |24 ||17 |18 |21 ||18 |17 |29 ||29 |24 |31 |-------------------cur_ins = 297cur_block = 29-------------------|fifo |lru |opt |-------------------|24 |29 |24 ||17 |18 |21 ||18 |17 |29 ||29 |24 |31 |-------------------cur_ins = 319cur_block = 31-------------------|fifo |lru |opt |-------------------|17 |31 |24 ||18 |29 |21 ||29 |18 |29 ||31 |17 |31 |-------------------cur_ins = 319cur_block = 31-------------------|fifo |lru |opt |-------------------|17 |31 |24 ||18 |29 |21 ||29 |18 |29 ||31 |17 |31 |-------------------cur_ins = 191cur_block = 19-------------------|fifo |lru |opt |-------------------|18 |19 |24 ||29 |31 |21 ||31 |29 |19 ||19 |18 |31 |-------------------cur_ins = 192cur_block = 19-------------------|fifo |lru |opt |-------------------|18 |19 |24 ||29 |31 |21 ||31 |29 |19 ||19 |18 |31 |-------------------cur_ins = 212cur_block = 21-------------------|fifo |lru |opt |-------------------|29 |21 |24 ||31 |19 |21 ||19 |31 |19 ||21 |29 |31 |-------------------cur_ins = 213cur_block = 21-------------------|fifo |lru |opt |-------------------|29 |21 |24 ||31 |19 |21 ||19 |31 |19 ||21 |29 |31 |-------------------cur_ins = 52cur_block = 5-------------------|fifo |lru |opt |-------------------|31 |5 |24 ||19 |21 |5 ||21 |19 |19 ||5 |31 |31 |-------------------cur_ins = 53cur_block = 5-------------------|fifo |lru |opt |-------------------|31 |5 |24 ||19 |21 |5 ||21 |19 |19 ||5 |31 |31 |-------------------cur_ins = 12cur_block = 1-------------------|fifo |lru |opt |-------------------|19 |1 |1 ||21 |5 |5 ||5 |21 |19 ||1 |19 |31 |-------------------cur_ins = 13cur_block = 1-------------------|fifo |lru |opt |-------------------|19 |1 |1 ||21 |5 |5 ||5 |21 |19 ||1 |19 |31 |-------------------cur_ins = 312cur_block = 31-------------------|fifo |lru |opt |-------------------|21 |31 |1 ||5 |1 |5 ||1 |5 |19 ||31 |21 |31 |-------------------cur_ins = 313cur_block = 31-------------------|fifo |lru |opt |-------------------|21 |31 |1 ||5 |1 |5 ||1 |5 |19 ||31 |21 |31 |-------------------cur_ins = 313cur_block = 31-------------------|fifo |lru |opt |-------------------|21 |31 |1 ||5 |1 |5 ||1 |5 |19 ||31 |21 |31 |-------------------cur_ins = 314cur_block = 31-------------------|fifo |lru |opt |-------------------|21 |31 |1 ||5 |1 |5 ||1 |5 |19 ||31 |21 |31 |-------------------cur_ins = 73cur_block = 7-------------------|fifo |lru |opt |-------------------|5 |7 |1 ||1 |31 |5 ||31 |1 |19 ||7 |5 |7 |-------------------cur_ins = 74cur_block = 7-------------------|fifo |lru |opt |-------------------|5 |7 |1 ||1 |31 |5 ||31 |1 |19 ||7 |5 |7 |-------------------cur_ins = 195cur_block = 19-------------------|fifo |lru |opt |-------------------|1 |19 |1 ||31 |7 |5 ||7 |31 |19 ||19 |1 |7 |-------------------cur_ins = 196cur_block = 19-------------------|fifo |lru |opt |-------------------|1 |19 |1 ||31 |7 |5 ||7 |31 |19 ||19 |1 |7 |-------------------cur_ins = 73cur_block = 7-------------------|fifo |lru |opt |-------------------|1 |7 |1 ||31 |19 |5 ||7 |31 |19 ||19 |1 |7 |-------------------cur_ins = 74cur_block = 7-------------------|fifo |lru |opt |-------------------|1 |7 |1 ||31 |19 |5 ||7 |31 |19 ||19 |1 |7 |-------------------cur_ins = 17cur_block = 1-------------------|fifo |lru |opt |-------------------|1 |1 |1 ||31 |7 |5 ||7 |19 |19 ||19 |31 |7 |-------------------cur_ins = 18cur_block = 1-------------------|fifo |lru |opt |-------------------|1 |1 |1 ||31 |7 |5 ||7 |19 |19 ||19 |31 |7 |-------------------cur_ins = 27cur_block = 2-------------------|fifo |lru |opt |-------------------|31 |2 |1 ||7 |1 |5 ||19 |7 |19 ||2 |19 |2 |-------------------cur_ins = 28cur_block = 2-------------------|fifo |lru |opt |-------------------|31 |2 |1 ||7 |1 |5 ||19 |7 |19 ||2 |19 |2 |-------------------cur_ins = 237cur_block = 23-------------------|fifo |lru |opt |-------------------|7 |23 |1 ||19 |2 |5 ||2 |1 |23 ||23 |7 |2 |-------------------cur_ins = 238cur_block = 23-------------------|fifo |lru |opt |-------------------|7 |23 |1 ||19 |2 |5 ||2 |1 |23 ||23 |7 |2 |-------------------cur_ins = 89cur_block = 8-------------------|fifo |lru |opt |-------------------|19 |8 |1 ||2 |23 |5 ||23 |2 |8 ||8 |1 |2 |-------------------cur_ins = 90cur_block = 9-------------------|fifo |lru |opt |-------------------|2 |9 |1 ||23 |8 |5 ||8 |23 |9 ||9 |2 |2 |-------------------cur_ins = 277cur_block = 27-------------------|fifo |lru |opt |-------------------|23 |27 |1 ||8 |9 |5 ||9 |8 |27 ||27 |23 |2 |-------------------cur_ins = 278cur_block = 27-------------------|fifo |lru |opt |-------------------|23 |27 |1 ||8 |9 |5 ||9 |8 |27 ||27 |23 |2 |-------------------cur_ins = 130cur_block = 13-------------------|fifo |lru |opt |-------------------|8 |13 |1 ||9 |27 |5 ||27 |9 |27 ||13 |8 |13 |-------------------cur_ins = 131cur_block = 13-------------------|fifo |lru |opt |-------------------|8 |13 |1 ||9 |27 |5 ||27 |9 |27 ||13 |8 |13 |-------------------cur_ins = 11cur_block = 1-------------------|fifo |lru |opt |-------------------|9 |1 |1 ||27 |13 |5 ||13 |27 |27 ||1 |9 |13 |-------------------cur_ins = 12cur_block = 1-------------------|fifo |lru |opt |-------------------|9 |1 |1 ||27 |13 |5 ||13 |27 |27 ||1 |9 |13 |-------------------cur_ins = 57cur_block = 5-------------------|fifo |lru |opt |-------------------|27 |5 |1 ||13 |1 |5 ||1 |13 |27 ||5 |27 |13 |-------------------cur_ins = 58cur_block = 5-------------------|fifo |lru |opt |-------------------|27 |5 |1 ||13 |1 |5 ||1 |13 |27 ||5 |27 |13 |-------------------cur_ins = 267cur_block = 26-------------------|fifo |lru |opt |-------------------|13 |26 |1 ||1 |5 |5 ||5 |1 |27 ||26 |13 |26 |-------------------cur_ins = 268cur_block = 26-------------------|fifo |lru |opt |-------------------|13 |26 |1 ||1 |5 |5 ||5 |1 |27 ||26 |13 |26 |-------------------cur_ins = 242cur_block = 24-------------------|fifo |lru |opt |-------------------|1 |24 |24 ||5 |26 |5 ||26 |5 |27 ||24 |1 |26 |-------------------cur_ins = 243cur_block = 24-------------------|fifo |lru |opt |-------------------|1 |24 |24 ||5 |26 |5 ||26 |5 |27 ||24 |1 |26 |-------------------cur_ins = 276cur_block = 27-------------------|fifo |lru |opt |-------------------|5 |27 |24 ||26 |24 |5 ||24 |26 |27 ||27 |5 |26 |-------------------cur_ins = 277cur_block = 27-------------------|fifo |lru |opt |-------------------|5 |27 |24 ||26 |24 |5 ||24 |26 |27 ||27 |5 |26 |-------------------cur_ins = 43cur_block = 4-------------------|fifo |lru |opt |-------------------|26 |4 |24 ||24 |27 |5 ||27 |24 |4 ||4 |26 |26 |-------------------cur_ins = 44cur_block = 4-------------------|fifo |lru |opt |-------------------|26 |4 |24 ||24 |27 |5 ||27 |24 |4 ||4 |26 |26 |-------------------cur_ins = 31cur_block = 3-------------------|fifo |lru |opt |-------------------|24 |3 |3 ||27 |4 |5 ||4 |27 |4 ||3 |24 |26 |-------------------cur_ins = 32cur_block = 3-------------------|fifo |lru |opt |-------------------|24 |3 |3 ||27 |4 |5 ||4 |27 |4 ||3 |24 |26 |-------------------cur_ins = 140cur_block = 14-------------------|fifo |lru |opt |-------------------|27 |14 |3 ||4 |3 |14 ||3 |4 |4 ||14 |27 |26 |-------------------cur_ins = 141cur_block = 14-------------------|fifo |lru |opt |-------------------|27 |14 |3 ||4 |3 |14 ||3 |4 |4 ||14 |27 |26 |-------------------cur_ins = 315cur_block = 31-------------------|fifo |lru |opt |-------------------|4 |31 |3 ||3 |14 |14 ||14 |3 |31 ||31 |4 |26 |-------------------cur_ins = 316cur_block = 31-------------------|fifo |lru |opt |-------------------|4 |31 |3 ||3 |14 |14 ||14 |3 |31 ||31 |4 |26 |-------------------cur_ins = 187cur_block = 18-------------------|fifo |lru |opt |-------------------|3 |18 |3 ||14 |31 |14 ||31 |14 |18 ||18 |3 |26 |-------------------cur_ins = 188cur_block = 18-------------------|fifo |lru |opt |-------------------|3 |18 |3 ||14 |31 |14 ||31 |14 |18 ||18 |3 |26 |-------------------cur_ins = 221cur_block = 22-------------------|fifo |lru |opt |-------------------|14 |22 |3 ||31 |18 |14 ||18 |31 |22 ||22 |14 |26 |-------------------cur_ins = 222cur_block = 22-------------------|fifo |lru |opt |-------------------|14 |22 |3 ||31 |18 |14 ||18 |31 |22 ||22 |14 |26 |-------------------cur_ins = 301cur_block = 30-------------------|fifo |lru |opt |-------------------|31 |30 |3 ||18 |22 |30 ||22 |18 |22 ||30 |31 |26 |-------------------cur_ins = 302cur_block = 30-------------------|fifo |lru |opt |-------------------|31 |30 |3 ||18 |22 |30 ||22 |18 |22 ||30 |31 |26 |-------------------cur_ins = 28cur_block = 2-------------------|fifo |lru |opt |-------------------|18 |2 |3 ||22 |30 |2 ||30 |22 |22 ||2 |18 |26 |-------------------cur_ins = 29cur_block = 2-------------------|fifo |lru |opt |-------------------|18 |2 |3 ||22 |30 |2 ||30 |22 |22 ||2 |18 |26 |-------------------cur_ins = 198cur_block = 19-------------------|fifo |lru |opt |-------------------|22 |19 |3 ||30 |2 |19 ||2 |30 |22 ||19 |22 |26 |-------------------cur_ins = 199cur_block = 19-------------------|fifo |lru |opt |-------------------|22 |19 |3 ||30 |2 |19 ||2 |30 |22 ||19 |22 |26 |-------------------cur_ins = 128cur_block = 12-------------------|fifo |lru |opt |-------------------|30 |12 |3 ||2 |19 |12 ||19 |2 |22 ||12 |30 |26 |-------------------cur_ins = 129cur_block = 12-------------------|fifo |lru |opt |-------------------|30 |12 |3 ||2 |19 |12 ||19 |2 |22 ||12 |30 |26 |-------------------cur_ins = 117cur_block = 11-------------------|fifo |lru |opt |-------------------|2 |11 |3 ||19 |12 |11 ||12 |19 |22 ||11 |2 |26 |-------------------cur_ins = 118cur_block = 11-------------------|fifo |lru |opt |-------------------|2 |11 |3 ||19 |12 |11 ||12 |19 |22 ||11 |2 |26 |-------------------cur_ins = 262cur_block = 26-------------------|fifo |lru |opt |-------------------|19 |26 |3 ||12 |11 |11 ||11 |12 |22 ||26 |19 |26 |-------------------cur_ins = 263cur_block = 26-------------------|fifo |lru |opt |-------------------|19 |26 |3 ||12 |11 |11 ||11 |12 |22 ||26 |19 |26 |-------------------cur_ins = 223cur_block = 22-------------------|fifo |lru |opt |-------------------|12 |22 |3 ||11 |26 |11 ||26 |11 |22 ||22 |12 |26 |-------------------cur_ins = 224cur_block = 22-------------------|fifo |lru |opt |-------------------|12 |22 |3 ||11 |26 |11 ||26 |11 |22 ||22 |12 |26 |-------------------cur_ins = 35cur_block = 3-------------------|fifo |lru |opt |-------------------|11 |3 |3 ||26 |22 |11 ||22 |26 |22 ||3 |11 |26 |-------------------cur_ins = 36cur_block = 3-------------------|fifo |lru |opt |-------------------|11 |3 |3 ||26 |22 |11 ||22 |26 |22 ||3 |11 |26 |-------------------cur_ins = 140cur_block = 14-------------------|fifo |lru |opt |-------------------|26 |14 |3 ||22 |3 |11 ||3 |22 |14 ||14 |26 |26 |-------------------cur_ins = 141cur_block = 14-------------------|fifo |lru |opt |-------------------|26 |14 |3 ||22 |3 |11 ||3 |22 |14 ||14 |26 |26 |-------------------cur_ins = 210cur_block = 21-------------------|fifo |lru |opt |-------------------|22 |21 |21 ||3 |14 |11 ||14 |3 |14 ||21 |22 |26 |-------------------cur_ins = 211cur_block = 21-------------------|fifo |lru |opt |-------------------|22 |21 |21 ||3 |14 |11 ||14 |3 |14 ||21 |22 |26 |-------------------cur_ins = 40cur_block = 4-------------------|fifo |lru |opt |-------------------|3 |4 |21 ||14 |21 |11 ||21 |14 |14 ||4 |3 |4 |-------------------cur_ins = 41cur_block = 4-------------------|fifo |lru |opt |-------------------|3 |4 |21 ||14 |21 |11 ||21 |14 |14 ||4 |3 |4 |-------------------cur_ins = 128cur_block = 12-------------------|fifo |lru |opt |-------------------|14 |12 |12 ||21 |4 |11 ||4 |21 |14 ||12 |14 |4 |-------------------cur_ins = 129cur_block = 12-------------------|fifo |lru |opt |-------------------|14 |12 |12 ||21 |4 |11 ||4 |21 |14 ||12 |14 |4 |-------------------cur_ins = 86cur_block = 8-------------------|fifo |lru |opt |-------------------|21 |8 |8 ||4 |12 |11 ||12 |4 |14 ||8 |21 |4 |-------------------cur_ins = 87cur_block = 8-------------------|fifo |lru |opt |-------------------|21 |8 |8 ||4 |12 |11 ||12 |4 |14 ||8 |21 |4 |-------------------cur_ins = 40cur_block = 4-------------------|fifo |lru |opt |-------------------|21 |4 |8 ||4 |8 |11 ||12 |12 |14 ||8 |21 |4 |-------------------cur_ins = 41cur_block = 4-------------------|fifo |lru |opt |-------------------|21 |4 |8 ||4 |8 |11 ||12 |12 |14 ||8 |21 |4 |-------------------cur_ins = 101cur_block = 10-------------------|fifo |lru |opt |-------------------|4 |10 |10 ||12 |4 |11 ||8 |8 |14 ||10 |12 |4 |-------------------cur_ins = 102cur_block = 10-------------------|fifo |lru |opt |-------------------|4 |10 |10 ||12 |4 |11 ||8 |8 |14 ||10 |12 |4 |-------------------cur_ins = 109cur_block = 10-------------------|fifo |lru |opt |-------------------|4 |10 |10 ||12 |4 |11 ||8 |8 |14 ||10 |12 |4 |-------------------cur_ins = 110cur_block = 11-------------------|fifo |lru |opt |-------------------|12 |11 |10 ||8 |10 |11 ||10 |4 |14 ||11 |8 |4 |-------------------cur_ins = 51cur_block = 5-------------------|fifo |lru |opt |-------------------|8 |5 |5 ||10 |11 |11 ||11 |10 |14 ||5 |4 |4 |-------------------cur_ins = 52cur_block = 5-------------------|fifo |lru |opt |-------------------|8 |5 |5 ||10 |11 |11 ||11 |10 |14 ||5 |4 |4 |-------------------cur_ins = 146cur_block = 14-------------------|fifo |lru |opt |-------------------|10 |14 |5 ||11 |5 |11 ||5 |11 |14 ||14 |10 |4 |-------------------cur_ins = 147cur_block = 14-------------------|fifo |lru |opt |-------------------|10 |14 |5 ||11 |5 |11 ||5 |11 |14 ||14 |10 |4 |-------------------cur_ins = 42cur_block = 4-------------------|fifo |lru |opt |-------------------|11 |4 |5 ||5 |14 |11 ||14 |5 |14 ||4 |11 |4 |-------------------cur_ins = 43cur_block = 4-------------------|fifo |lru |opt |-------------------|11 |4 |5 ||5 |14 |11 ||14 |5 |14 ||4 |11 |4 |-------------------cur_ins = 14cur_block = 1-------------------|fifo |lru |opt |-------------------|5 |1 |5 ||14 |4 |11 ||4 |14 |1 ||1 |5 |4 |-------------------cur_ins = 15cur_block = 1-------------------|fifo |lru |opt |-------------------|5 |1 |5 ||14 |4 |11 ||4 |14 |1 ||1 |5 |4 |-------------------cur_ins = 216cur_block = 21-------------------|fifo |lru |opt |-------------------|14 |21 |5 ||4 |1 |11 ||1 |4 |21 ||21 |14 |4 |-------------------cur_ins = 217cur_block = 21-------------------|fifo |lru |opt |-------------------|14 |21 |5 ||4 |1 |11 ||1 |4 |21 ||21 |14 |4 |-------------------cur_ins = 177cur_block = 17-------------------|fifo |lru |opt |-------------------|4 |17 |5 ||1 |21 |11 ||21 |1 |17 ||17 |4 |4 |-------------------cur_ins = 178cur_block = 17-------------------|fifo |lru |opt |-------------------|4 |17 |5 ||1 |21 |11 ||21 |1 |17 ||17 |4 |4 |-------------------cur_ins = 49cur_block = 4-------------------|fifo |lru |opt |-------------------|4 |4 |5 ||1 |17 |11 ||21 |21 |17 ||17 |1 |4 |-------------------cur_ins = 50cur_block = 5-------------------|fifo |lru |opt |-------------------|1 |5 |5 ||21 |4 |11 ||17 |17 |17 ||5 |21 |4 |-------------------cur_ins = 110cur_block = 11-------------------|fifo |lru |opt |-------------------|21 |11 |5 ||17 |5 |11 ||5 |4 |17 ||11 |17 |4 |-------------------cur_ins = 111cur_block = 11-------------------|fifo |lru |opt |-------------------|21 |11 |5 ||17 |5 |11 ||5 |4 |17 ||11 |17 |4 |-------------------cur_ins = 300cur_block = 30-------------------|fifo |lru |opt |-------------------|17 |30 |5 ||5 |11 |11 ||11 |5 |30 ||30 |4 |4 |-------------------cur_ins = 301cur_block = 30-------------------|fifo |lru |opt |-------------------|17 |30 |5 ||5 |11 |11 ||11 |5 |30 ||30 |4 |4 |-------------------cur_ins = 49cur_block = 4-------------------|fifo |lru |opt |-------------------|5 |4 |5 ||11 |30 |11 ||30 |11 |30 ||4 |5 |4 |-------------------cur_ins = 50cur_block = 5-------------------|fifo |lru |opt |-------------------|5 |5 |5 ||11 |4 |11 ||30 |30 |30 ||4 |11 |4 |-------------------cur_ins = 263cur_block = 26-------------------|fifo |lru |opt |-------------------|11 |26 |26 ||30 |5 |11 ||4 |4 |30 ||26 |30 |4 |-------------------cur_ins = 264cur_block = 26-------------------|fifo |lru |opt |-------------------|11 |26 |26 ||30 |5 |11 ||4 |4 |30 ||26 |30 |4 |-------------------cur_ins = 21cur_block = 2-------------------|fifo |lru |opt |-------------------|30 |2 |26 ||4 |26 |11 ||26 |5 |2 ||2 |4 |4 |-------------------cur_ins = 22cur_block = 2-------------------|fifo |lru |opt |-------------------|30 |2 |26 ||4 |26 |11 ||26 |5 |2 ||2 |4 |4 |-------------------cur_ins = 9cur_block = 0-------------------|fifo |lru |opt |-------------------|4 |0 |26 ||26 |2 |11 ||2 |26 |0 ||0 |5 |4 |-------------------cur_ins = 10cur_block = 1-------------------|fifo |lru |opt |-------------------|26 |1 |26 ||2 |0 |11 ||0 |2 |0 ||1 |26 |1 |-------------------cur_ins = 194cur_block = 19-------------------|fifo |lru |opt |-------------------|2 |19 |26 ||0 |1 |11 ||1 |0 |0 ||19 |2 |19 |-------------------cur_ins = 195cur_block = 19-------------------|fifo |lru |opt |-------------------|2 |19 |26 ||0 |1 |11 ||1 |0 |0 ||19 |2 |19 |-------------------cur_ins = 192cur_block = 19-------------------|fifo |lru |opt |-------------------|2 |19 |26 ||0 |1 |11 ||1 |0 |0 ||19 |2 |19 |-------------------cur_ins = 193cur_block = 19-------------------|fifo |lru |opt |-------------------|2 |19 |26 ||0 |1 |11 ||1 |0 |0 ||19 |2 |19 |-------------------cur_ins = 159cur_block = 15-------------------|fifo |lru |opt |-------------------|0 |15 |26 ||1 |19 |11 ||19 |1 |0 ||15 |0 |15 |-------------------cur_ins = 160cur_block = 16-------------------|fifo |lru |opt |-------------------|1 |16 |26 ||19 |15 |11 ||15 |19 |0 ||16 |1 |16 |-------------------cur_ins = 244cur_block = 24-------------------|fifo |lru |opt |-------------------|19 |24 |26 ||15 |16 |11 ||16 |15 |0 ||24 |19 |24 |-------------------cur_ins = 245cur_block = 24-------------------|fifo |lru |opt |-------------------|19 |24 |26 ||15 |16 |11 ||16 |15 |0 ||24 |19 |24 |-------------------cur_ins = 128cur_block = 12-------------------|fifo |lru |opt |-------------------|15 |12 |26 ||16 |24 |11 ||24 |16 |0 ||12 |15 |12 |-------------------cur_ins = 129cur_block = 12-------------------|fifo |lru |opt |-------------------|15 |12 |26 ||16 |24 |11 ||24 |16 |0 ||12 |15 |12 |-------------------cur_ins = 35cur_block = 3-------------------|fifo |lru |opt |-------------------|16 |3 |26 ||24 |12 |11 ||12 |24 |0 ||3 |16 |3 |-------------------cur_ins = 36cur_block = 3-------------------|fifo |lru |opt |-------------------|16 |3 |26 ||24 |12 |11 ||12 |24 |0 ||3 |16 |3 |-------------------cur_ins = 114cur_block = 11-------------------|fifo |lru |opt |-------------------|24 |11 |26 ||12 |3 |11 ||3 |12 |0 ||11 |24 |3 |-------------------cur_ins = 115cur_block = 11-------------------|fifo |lru |opt |-------------------|24 |11 |26 ||12 |3 |11 ||3 |12 |0 ||11 |24 |3 |-------------------cur_ins = 237cur_block = 23-------------------|fifo |lru |opt |-------------------|12 |23 |26 ||3 |11 |11 ||11 |3 |0 ||23 |12 |23 |-------------------cur_ins = 238cur_block = 23-------------------|fifo |lru |opt |-------------------|12 |23 |26 ||3 |11 |11 ||11 |3 |0 ||23 |12 |23 |-------------------cur_ins = 74cur_block = 7-------------------|fifo |lru |opt |-------------------|3 |7 |26 ||11 |23 |11 ||23 |11 |0 ||7 |3 |7 |-------------------cur_ins = 75cur_block = 7-------------------|fifo |lru |opt |-------------------|3 |7 |26 ||11 |23 |11 ||23 |11 |0 ||7 |3 |7 |-------------------cur_ins = 264cur_block = 26-------------------|fifo |lru |opt |-------------------|11 |26 |26 ||23 |7 |11 ||7 |23 |0 ||26 |11 |7 |-------------------cur_ins = 265cur_block = 26-------------------|fifo |lru |opt |-------------------|11 |26 |26 ||23 |7 |11 ||7 |23 |0 ||26 |11 |7 |-------------------cur_ins = 2cur_block = 0-------------------|fifo |lru |opt |-------------------|23 |0 |26 ||7 |26 |11 ||26 |7 |0 ||0 |23 |7 |-------------------cur_ins = 3cur_block = 0-------------------|fifo |lru |opt |-------------------|23 |0 |26 ||7 |26 |11 ||26 |7 |0 ||0 |23 |7 |-------------------cur_ins = 0cur_block = 0-------------------|fifo |lru |opt |-------------------|23 |0 |26 ||7 |26 |11 ||26 |7 |0 ||0 |23 |7 |-------------------cur_ins = 1cur_block = 0-------------------|fifo |lru |opt |-------------------|23 |0 |26 ||7 |26 |11 ||26 |7 |0 ||0 |23 |7 |-------------------cur_ins = 194cur_block = 19-------------------|fifo |lru |opt |-------------------|7 |19 |19 ||26 |0 |11 ||0 |26 |0 ||19 |7 |7 |-------------------cur_ins = 195cur_block = 19-------------------|fifo |lru |opt |-------------------|7 |19 |19 ||26 |0 |11 ||0 |26 |0 ||19 |7 |7 |-------------------cur_ins = 257cur_block = 25-------------------|fifo |lru |opt |-------------------|26 |25 |19 ||0 |19 |11 ||19 |0 |0 ||25 |26 |25 |-------------------cur_ins = 258cur_block = 25-------------------|fifo |lru |opt |-------------------|26 |25 |19 ||0 |19 |11 ||19 |0 |0 ||25 |26 |25 |-------------------cur_ins = 10cur_block = 1-------------------|fifo |lru |opt |-------------------|0 |1 |1 ||19 |25 |11 ||25 |19 |0 ||1 |0 |25 |-------------------cur_ins = 11cur_block = 1-------------------|fifo |lru |opt |-------------------|0 |1 |1 ||19 |25 |11 ||25 |19 |0 ||1 |0 |25 |-------------------cur_ins = 64cur_block = 6-------------------|fifo |lru |opt |-------------------|19 |6 |6 ||25 |1 |11 ||1 |25 |0 ||6 |19 |25 |-------------------cur_ins = 65cur_block = 6-------------------|fifo |lru |opt |-------------------|19 |6 |6 ||25 |1 |11 ||1 |25 |0 ||6 |19 |25 |-------------------cur_ins = 84cur_block = 8-------------------|fifo |lru |opt |-------------------|25 |8 |8 ||1 |6 |11 ||6 |1 |0 ||8 |25 |25 |-------------------cur_ins = 85cur_block = 8-------------------|fifo |lru |opt |-------------------|25 |8 |8 ||1 |6 |11 ||6 |1 |0 ||8 |25 |25 |-------------------cur_ins = 48cur_block = 4-------------------|fifo |lru |opt |-------------------|1 |4 |8 ||6 |8 |11 ||8 |6 |0 ||4 |1 |4 |-------------------cur_ins = 49cur_block = 4-------------------|fifo |lru |opt |-------------------|1 |4 |8 ||6 |8 |11 ||8 |6 |0 ||4 |1 |4 |-------------------cur_ins = 318cur_block = 31-------------------|fifo |lru |opt |-------------------|6 |31 |8 ||8 |4 |11 ||4 |8 |0 ||31 |6 |31 |-------------------cur_ins = 319cur_block = 31-------------------|fifo |lru |opt |-------------------|6 |31 |8 ||8 |4 |11 ||4 |8 |0 ||31 |6 |31 |-------------------cur_ins = 98cur_block = 9-------------------|fifo |lru |opt |-------------------|8 |9 |8 ||4 |31 |11 ||31 |4 |0 ||9 |8 |9 |-------------------cur_ins = 99cur_block = 9-------------------|fifo |lru |opt |-------------------|8 |9 |8 ||4 |31 |11 ||31 |4 |0 ||9 |8 |9 |-------------------cur_ins = 1cur_block = 0-------------------|fifo |lru |opt |-------------------|4 |0 |8 ||31 |9 |11 ||9 |31 |0 ||0 |4 |9 |-------------------cur_ins = 2cur_block = 0-------------------|fifo |lru |opt |-------------------|4 |0 |8 ||31 |9 |11 ||9 |31 |0 ||0 |4 |9 |-------------------cur_ins = 215cur_block = 21-------------------|fifo |lru |opt |-------------------|31 |21 |8 ||9 |0 |11 ||0 |9 |21 ||21 |31 |9 |-------------------cur_ins = 216cur_block = 21-------------------|fifo |lru |opt |-------------------|31 |21 |8 ||9 |0 |11 ||0 |9 |21 ||21 |31 |9 |-------------------cur_ins = 144cur_block = 14-------------------|fifo |lru |opt |-------------------|9 |14 |8 ||0 |21 |11 ||21 |0 |14 ||14 |9 |9 |-------------------cur_ins = 145cur_block = 14-------------------|fifo |lru |opt |-------------------|9 |14 |8 ||0 |21 |11 ||21 |0 |14 ||14 |9 |9 |-------------------cur_ins = 119cur_block = 11-------------------|fifo |lru |opt |-------------------|0 |11 |8 ||21 |14 |11 ||14 |21 |14 ||11 |0 |9 |-------------------cur_ins = 120cur_block = 12-------------------|fifo |lru |opt |-------------------|21 |12 |8 ||14 |11 |12 ||11 |14 |14 ||12 |21 |9 |-------------------cur_ins = 137cur_block = 13-------------------|fifo |lru |opt |-------------------|14 |13 |8 ||11 |12 |13 ||12 |11 |14 ||13 |14 |9 |-------------------cur_ins = 138cur_block = 13-------------------|fifo |lru |opt |-------------------|14 |13 |8 ||11 |12 |13 ||12 |11 |14 ||13 |14 |9 |-------------------cur_ins = 188cur_block = 18-------------------|fifo |lru |opt |-------------------|11 |18 |8 ||12 |13 |18 ||13 |12 |14 ||18 |11 |9 |-------------------cur_ins = 189cur_block = 18-------------------|fifo |lru |opt |-------------------|11 |18 |8 ||12 |13 |18 ||13 |12 |14 ||18 |11 |9 |-------------------cur_ins = 143cur_block = 14-------------------|fifo |lru |opt |-------------------|12 |14 |8 ||13 |18 |18 ||18 |13 |14 ||14 |12 |9 |-------------------cur_ins = 144cur_block = 14-------------------|fifo |lru |opt |-------------------|12 |14 |8 ||13 |18 |18 ||18 |13 |14 ||14 |12 |9 |-------------------cur_ins = 237cur_block = 23-------------------|fifo |lru |opt |-------------------|13 |23 |8 ||18 |14 |23 ||14 |18 |14 ||23 |13 |9 |-------------------cur_ins = 238cur_block = 23-------------------|fifo |lru |opt |-------------------|13 |23 |8 ||18 |14 |23 ||14 |18 |14 ||23 |13 |9 |-------------------cur_ins = 243cur_block = 24-------------------|fifo |lru |opt |-------------------|18 |24 |8 ||14 |23 |24 ||23 |14 |14 ||24 |18 |9 |-------------------cur_ins = 244cur_block = 24-------------------|fifo |lru |opt |-------------------|18 |24 |8 ||14 |23 |24 ||23 |14 |14 ||24 |18 |9 |-------------------cur_ins = 84cur_block = 8-------------------|fifo |lru |opt |-------------------|14 |8 |8 ||23 |24 |24 ||24 |23 |14 ||8 |14 |9 |-------------------cur_ins = 85cur_block = 8-------------------|fifo |lru |opt |-------------------|14 |8 |8 ||23 |24 |24 ||24 |23 |14 ||8 |14 |9 |-------------------cur_ins = 251cur_block = 25-------------------|fifo |lru |opt |-------------------|23 |25 |25 ||24 |8 |24 ||8 |24 |14 ||25 |23 |9 |-------------------cur_ins = 252cur_block = 25-------------------|fifo |lru |opt |-------------------|23 |25 |25 ||24 |8 |24 ||8 |24 |14 ||25 |23 |9 |-------------------cur_ins = 195cur_block = 19-------------------|fifo |lru |opt |-------------------|24 |19 |19 ||8 |25 |24 ||25 |8 |14 ||19 |24 |9 |-------------------cur_ins = 196cur_block = 19-------------------|fifo |lru |opt |-------------------|24 |19 |19 ||8 |25 |24 ||25 |8 |14 ||19 |24 |9 |-------------------cur_ins = 172cur_block = 17-------------------|fifo |lru |opt |-------------------|8 |17 |17 ||25 |19 |24 ||19 |25 |14 ||17 |8 |9 |-------------------cur_ins = 173cur_block = 17-------------------|fifo |lru |opt |-------------------|8 |17 |17 ||25 |19 |24 ||19 |25 |14 ||17 |8 |9 |-------------------cur_ins = 311cur_block = 31-------------------|fifo |lru |opt |-------------------|25 |31 |31 ||19 |17 |24 ||17 |19 |14 ||31 |25 |9 |-------------------cur_ins = 312cur_block = 31-------------------|fifo |lru |opt |-------------------|25 |31 |31 ||19 |17 |24 ||17 |19 |14 ||31 |25 |9 |-------------------cur_ins = 24cur_block = 2-------------------|fifo |lru |opt |-------------------|19 |2 |2 ||17 |31 |24 ||31 |17 |14 ||2 |19 |9 |-------------------cur_ins = 25cur_block = 2-------------------|fifo |lru |opt |-------------------|19 |2 |2 ||17 |31 |24 ||31 |17 |14 ||2 |19 |9 |--------------------------------------------------------------------|item |fifo |lru |opt |-------------------------------------------------|hit |167 |169 |204 ||hit_ratio |52.1875 |52.8125 |63.75 ||miss |153 |151 |116 ||miss_ratio |47.8125 |47.1875 |36.25 |-------------------------------------------------","link":"/home/2020/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C-%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E7%9A%84%E6%A8%A1%E6%8B%9F/"},{"title":"00-面试查漏补缺","text":"2024.3.13Handler sendMessage post 有callback的message looper循环执行 sendMessage 发送自定义的message 可以没有callback 可以有what、obj去和接收者传递消息 Message源码（仅public） Message的获取 Handler包装的runnable new Message() obtain() 推荐，Message中的recycle方法会回收不用的Message，obtain的时候如果消息池不空，可以服用消息池123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370public final class Message implements Parcelable { /** * User-defined message code so that the recipient can identify * what this message is about. Each {@link Handler} has its own name-space * for message codes, so you do not need to worry about yours conflicting * with other handlers. */ public int what; /** * arg1 and arg2 are lower-cost alternatives to using * {@link #setData(Bundle) setData()} if you only need to store a * few integer values. */ public int arg1; /** * arg1 and arg2 are lower-cost alternatives to using * {@link #setData(Bundle) setData()} if you only need to store a * few integer values. */ public int arg2; /** * An arbitrary object to send to the recipient. When using * {@link Messenger} to send the message across processes this can only * be non-null if it contains a Parcelable of a framework class (not one * implemented by the application). For other data transfer use * {@link #setData}. * * &lt;p&gt;Note that Parcelable objects here are not supported prior to * the {@link android.os.Build.VERSION_CODES#FROYO} release. */ public Object obj; @UnsupportedAppUsage /*package*/ int flags; /** * The targeted delivery time of this message. The time-base is * {@link SystemClock#uptimeMillis}. * @hide Only for use within the tests. */ @UnsupportedAppUsage @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE) public long when; /** @hide */ public static final Object sPoolSync = new Object(); /** * Return a new Message instance from the global pool. Allows us to * avoid allocating new objects in many cases. */ public static Message obtain() { synchronized (sPoolSync) { if (sPool != null) { Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; } } return new Message(); } /** * Same as {@link #obtain()}, but copies the values of an existing * message (including its target) into the new one. * @param orig Original message to copy. * @return A Message object from the global pool. */ public static Message obtain(Message orig) { Message m = obtain(); m.what = orig.what; m.arg1 = orig.arg1; m.arg2 = orig.arg2; m.obj = orig.obj; m.replyTo = orig.replyTo; m.sendingUid = orig.sendingUid; m.workSourceUid = orig.workSourceUid; if (orig.data != null) { m.data = new Bundle(orig.data); } m.target = orig.target; m.callback = orig.callback; return m; } /** * Same as {@link #obtain()}, but sets the value for the &lt;em&gt;target&lt;/em&gt; member on the Message returned. * @param h Handler to assign to the returned Message object's &lt;em&gt;target&lt;/em&gt; member. * @return A Message object from the global pool. */ public static Message obtain(Handler h) { Message m = obtain(); m.target = h; return m; } /** * Same as {@link #obtain(Handler)}, but assigns a callback Runnable on * the Message that is returned. * @param h Handler to assign to the returned Message object's &lt;em&gt;target&lt;/em&gt; member. * @param callback Runnable that will execute when the message is handled. * @return A Message object from the global pool. */ public static Message obtain(Handler h, Runnable callback) { Message m = obtain(); m.target = h; m.callback = callback; return m; } /** * Same as {@link #obtain()}, but sets the values for both &lt;em&gt;target&lt;/em&gt; and * &lt;em&gt;what&lt;/em&gt; members on the Message. * @param h Value to assign to the &lt;em&gt;target&lt;/em&gt; member. * @param what Value to assign to the &lt;em&gt;what&lt;/em&gt; member. * @return A Message object from the global pool. */ public static Message obtain(Handler h, int what) { Message m = obtain(); m.target = h; m.what = what; return m; } /** * Same as {@link #obtain()}, but sets the values of the &lt;em&gt;target&lt;/em&gt;, &lt;em&gt;what&lt;/em&gt;, and &lt;em&gt;obj&lt;/em&gt; * members. * @param h The &lt;em&gt;target&lt;/em&gt; value to set. * @param what The &lt;em&gt;what&lt;/em&gt; value to set. * @param obj The &lt;em&gt;object&lt;/em&gt; method to set. * @return A Message object from the global pool. */ public static Message obtain(Handler h, int what, Object obj) { Message m = obtain(); m.target = h; m.what = what; m.obj = obj; return m; } /** * Same as {@link #obtain()}, but sets the values of the &lt;em&gt;target&lt;/em&gt;, &lt;em&gt;what&lt;/em&gt;, * &lt;em&gt;arg1&lt;/em&gt;, and &lt;em&gt;arg2&lt;/em&gt; members. * * @param h The &lt;em&gt;target&lt;/em&gt; value to set. * @param what The &lt;em&gt;what&lt;/em&gt; value to set. * @param arg1 The &lt;em&gt;arg1&lt;/em&gt; value to set. * @param arg2 The &lt;em&gt;arg2&lt;/em&gt; value to set. * @return A Message object from the global pool. */ public static Message obtain(Handler h, int what, int arg1, int arg2) { Message m = obtain(); m.target = h; m.what = what; m.arg1 = arg1; m.arg2 = arg2; return m; } /** * Same as {@link #obtain()}, but sets the values of the &lt;em&gt;target&lt;/em&gt;, &lt;em&gt;what&lt;/em&gt;, * &lt;em&gt;arg1&lt;/em&gt;, &lt;em&gt;arg2&lt;/em&gt;, and &lt;em&gt;obj&lt;/em&gt; members. * * @param h The &lt;em&gt;target&lt;/em&gt; value to set. * @param what The &lt;em&gt;what&lt;/em&gt; value to set. * @param arg1 The &lt;em&gt;arg1&lt;/em&gt; value to set. * @param arg2 The &lt;em&gt;arg2&lt;/em&gt; value to set. * @param obj The &lt;em&gt;obj&lt;/em&gt; value to set. * @return A Message object from the global pool. */ public static Message obtain(Handler h, int what, int arg1, int arg2, Object obj) { Message m = obtain(); m.target = h; m.what = what; m.arg1 = arg1; m.arg2 = arg2; m.obj = obj; return m; } /** @hide */ public static void updateCheckRecycle(int targetSdkVersion) { if (targetSdkVersion &lt; Build.VERSION_CODES.LOLLIPOP) { gCheckRecycle = false; } } /** * Return a Message instance to the global pool. * &lt;p&gt; * You MUST NOT touch the Message after calling this function because it has * effectively been freed. It is an error to recycle a message that is currently * enqueued or that is in the process of being delivered to a Handler. * &lt;/p&gt; */ public void recycle() { if (isInUse()) { if (gCheckRecycle) { throw new IllegalStateException(&quot;This message cannot be recycled because it &quot; + &quot;is still in use.&quot;); } return; } recycleUnchecked(); } /** * Return the targeted delivery time of this message, in milliseconds. */ public long getWhen() { return when; } public void setTarget(Handler target) { this.target = target; } /** * Retrieve the {@link android.os.Handler Handler} implementation that * will receive this message. The object must implement * {@link android.os.Handler#handleMessage(android.os.Message) * Handler.handleMessage()}. Each Handler has its own name-space for * message codes, so you do not need to * worry about yours conflicting with other handlers. */ public Handler getTarget() { return target; } /** * Retrieve callback object that will execute when this message is handled. * This object must implement Runnable. This is called by * the &lt;em&gt;target&lt;/em&gt; {@link Handler} that is receiving this Message to * dispatch it. If * not set, the message will be dispatched to the receiving Handler's * {@link Handler#handleMessage(Message)}. */ public Runnable getCallback() { return callback; } /** @hide */ @UnsupportedAppUsage public Message setCallback(Runnable r) { callback = r; return this; } /** * Obtains a Bundle of arbitrary data associated with this * event, lazily creating it if necessary. Set this value by calling * {@link #setData(Bundle)}. Note that when transferring data across * processes via {@link Messenger}, you will need to set your ClassLoader * on the Bundle via {@link Bundle#setClassLoader(ClassLoader) * Bundle.setClassLoader()} so that it can instantiate your objects when * you retrieve them. * @see #peekData() * @see #setData(Bundle) */ public Bundle getData() { if (data == null) { data = new Bundle(); } return data; } /** * Like getData(), but does not lazily create the Bundle. A null * is returned if the Bundle does not already exist. See * {@link #getData} for further information on this. * @see #getData() * @see #setData(Bundle) */ public Bundle peekData() { return data; } /** * Sets a Bundle of arbitrary data values. Use arg1 and arg2 members * as a lower cost way to send a few simple integer values, if you can. * @see #getData() * @see #peekData() */ public void setData(Bundle data) { this.data = data; } /** * Chainable setter for {@link #what} * * @hide */ public Message setWhat(int what) { this.what = what; return this; } /** * Sends this Message to the Handler specified by {@link #getTarget}. * Throws a null pointer exception if this field has not been set. */ public void sendToTarget() { target.sendMessage(this); } /** * Returns true if the message is asynchronous, meaning that it is not * subject to {@link Looper} synchronization barriers. * * @return True if the message is asynchronous. * * @see #setAsynchronous(boolean) */ public boolean isAsynchronous() { return (flags &amp; FLAG_ASYNCHRONOUS) != 0; } /** * Sets whether the message is asynchronous, meaning that it is not * subject to {@link Looper} synchronization barriers. * &lt;p&gt; * Certain operations, such as view invalidation, may introduce synchronization * barriers into the {@link Looper}'s message queue to prevent subsequent messages * from being delivered until some condition is met. In the case of view invalidation, * messages which are posted after a call to {@link android.view.View#invalidate} * are suspended by means of a synchronization barrier until the next frame is * ready to be drawn. The synchronization barrier ensures that the invalidation * request is completely handled before resuming. * &lt;/p&gt;&lt;p&gt; * Asynchronous messages are exempt from synchronization barriers. They typically * represent interrupts, input events, and other signals that must be handled independently * even while other work has been suspended. * &lt;/p&gt;&lt;p&gt; * Note that asynchronous messages may be delivered out of order with respect to * synchronous messages although they are always delivered in order among themselves. * If the relative order of these messages matters then they probably should not be * asynchronous in the first place. Use with caution. * &lt;/p&gt; * * @param async True if the message is asynchronous. * * @see #isAsynchronous() */ public void setAsynchronous(boolean async) { if (async) { flags |= FLAG_ASYNCHRONOUS; } else { flags &amp;= ~FLAG_ASYNCHRONOUS; } } /** Constructor (but the preferred way to get a Message is to call {@link #obtain() Message.obtain()}). */ public Message() { }} Looper每次循环在做什么 取消息 分发消息123456789101112@SuppressWarnings({&quot;UnusedTokenOfOriginalCallingIdentity&quot;, &quot;ClearIdentityCallNotFollowedByTryFinally&quot;})private static boolean loopOnce(final Looper me, final long ident, final int thresholdOverride) { Message msg = me.mQueue.next(); // might block if (msg == null) { // No message indicates that the message queue is quitting. return false; } msg.target.dispatchMessage(msg); // 省略部分大概是和observer交互还有打log} Handler.dispatchMessage 有callback就执行callback 没有则通过mCallback对象或者子类重写handleMessage分发消息。123456789101112public void dispatchMessage(@NonNull Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); }} MessageQueueenqueue消息的操作 按照when大小入队 如果不是异步消息且队初始为空或队列中消息为异步消息或消息没有target，则wake对方12345678910111213141516171819202122232425262728293031323334353637383940414243444546boolean enqueueMessage(Message msg, long when) { if (msg.target == null) { throw new IllegalArgumentException(&quot;Message must have a target.&quot;); } synchronized (this) { if (msg.isInUse()) { throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); } msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) { // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; } else { // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) { prev = p; p = p.next; if (p == null || when &lt; p.when) { break; } if (needWake &amp;&amp; p.isAsynchronous()) { needWake = false; } } msg.next = p; // invariant: p == prev.next prev.next = msg; } // We can assume mPtr != 0 because mQuitting is false. if (needWake) { nativeWake(mPtr); } } return true;} enqueue的时候不是全部检查target不为空了吗？为什么后续还有target为空的消息？ Handler 同步屏障&amp;异步消息 Android消息机制1-Handler(Java层) 通过一个方法发送没有target的消息屏障，这样暂时屏蔽同步消息，只取出异步消息 取消息的操作 取消息 如果有消息 ready了，就返回 没ready，阻塞等着通过nativePollOnce，如果有人enqueue，则会通过nativeWake唤醒 没有消息了1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@UnsupportedAppUsageMessage next() { int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) { if (nextPollTimeoutMillis != 0) { Binder.flushPendingCommands(); } nativePollOnce(ptr, nextPollTimeoutMillis); // 如果消息还没有ready，阻塞等待一段时间 // nextPollTimeoutMillis的计算在上一次循环，看下面的代码 synchronized (this) { // 只有一个线程能拿消息 // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) { // Stalled by a barrier. Find the next asynchronous message in the queue. do { prevMsg = msg; msg = msg.next; } while (msg != null &amp;&amp; !msg.isAsynchronous()); } if (msg != null) { if (now &lt; msg.when) { // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); // nextPollTimeoutMillis的计算 } else { // Got a message. mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; // 拿到消息，返回 } } else { // No more messages. nextPollTimeoutMillis = -1; } } }} Handler实战 普通进程使用 1234567891011121314class LooperThread extends Thread { public Handler mHandler; public void run() { Looper.prepare(); mHandler = new Handler(Looper.myLooper()) { public void handleMessage(Message msg) { //处理即将发送过来的消息 System.out.println(&quot;thread id=&quot;+Thread.currentThread().getId()); } } Looper.loop(); }}// 外部开启线程、获取handler，post/sendMessage HandlerThread 1234HandlerThread handlerThread = new HandlerThread(&quot;name&quot;);handlerThread.start(); // 创建HandlerThreadHandler handler = new Handler(handlerThread.getLooper());// 拿到HandlerThread的Looper，创建handler Looper退出 quit : 删除所有消息，包括正在运行的 quitSafely() : 删除未运行的消息 AOT和JIT的对比 System.arraycopyPerformance of System.arraycopy() vs. Arrays.copyOf() arraycopy是native方法，用c实现的，可能是memcpy等方法实现的，效率因平台而不同 ANR(App Not Responding) 哪些场景导致ANR Service Timeout:Service在特定的时间内无法处理完成 BroadcastQueue Timeout：BroadcastReceiver在特定时间内无法处理完成 ContentProvider Timeout：内容提供者执行超时 inputDispatching Timeout: 按键或触摸事件在特定时间内无响应。 ServiceANRrealStartServiceLocked()-&gt;bumpServiceExecutingLocked()-&gt;scheduleServiceTimeoutLocked() 在Service启动过程中，scheduleServiceTimeoutLocked通过native层的handler发送了DelayedMessage 12345678910111213void scheduleServiceTimeoutLocked(ProcessRecord proc) { if (proc.executingServices.size() == 0 || proc.thread == null) { return; } Message msg = mAm.mHandler.obtainMessage( ActivityManagerService.SERVICE_TIMEOUT_MSG); msg.obj = proc; // 在serviceDoneExecutingLocked中会remove该SERVICE_TIMEOUT_MSG消息， // 当超时后仍没有remove SERVICE_TIMEOUT_MSG消息，则执行ActiveServices. serviceTimeout()方法； mAm.mHandler.sendMessageDelayed(msg, proc.execServicesFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT); // 前台进程中执行Service，SERVICE_TIMEOUT=20s；后台进程中执行Service，SERVICE_BACKGROUND_TIMEOUT=200s} 在Service的OnCreate结束后或启动过程抛出异常，调用serviceDoneExecutingLocked删除消息 1234if (r.app.executingServices.size() == 0) { if (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING, &quot;No more executingServices of &quot; + r.shortName);mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app); 在service的oncreate阶段不要执行过重的任务 InputDispatchingANR在分派输入事件时，InputDispatcher会检查当前是否有聚焦的窗口和应用，获取超时时间，如果当前时间大于超时时间，就弹出ANR Activity.onCreate执行耗时操作，不管用户如何操作都不会发生ANR，因为输入事件相关监听机制还没有建立起来；InputChannel通道还没有建立 应对方案 耗时操作子线程处理，结束后切回主线程更新ui Logs除了主体逻辑，发生ANR时还会输出各种类别的日志：event log：通过检索”am_anr”关键字，可以找到发生ANR的应用main log：通过检索”ANR in “关键字，可以找到ANR的信息，日志的上下文会包含CPU的使用情况dropbox：通过检索”anr”类型，可以找到ANR的信息traces：发生ANR时，各进程的函数调用栈信息 看完这篇 Android ANR 分析，就可以和面试官装逼了！ Activity/Fragment LifecycleActivity onSaveInstanceState() 与 onRestoreIntanceState() 不属于生命周期 onSaveInstanceState保存临时性的状态 onRestoreIntanceState恢复临时性的状态 调用时机 异常终止的时候才会调用 资源内存不足导致低优先级的 Activity 被杀死 高优先级：前台Activity 中优先级：可见且非前台 低优先级：后台Activity 资源相关的系统配置发生改变导致Activity被杀死并重新创建 旋转屏幕 旋转屏幕时 旧Activity：puase-&gt;onSaveInstanceState-&gt;stop-&gt;destory 新Activity：create-&gt;start-&gt;onRestoreInstanceState-&gt;onresume onCreate中也能取到onSaveInstanceState，但是官方建议使用onRestoreInstanceState恢复数据 onCreate: 创建中， onStart：可见但不可交互 onResume：可见可交互 onPause：可见不可交互 其他应用需要内存，就会Kill进程，下次回来时，进入onCreate onStop：不可见 其他应用需要内存，就会Kill进程，下次回来时，进入onCreate 一般情况下，下次回来时，调用onRestart然后onCreate onDestroy：销毁 其他Activity进入前台，当前Activity就会onPause，onStop。如果手快一点，在当前Activity没有彻底消失时就关闭下一个Activity，就不会进入onStop Fragment AAR 也是一种打包的zip文件 远程aar和本地arr R文件 资源id 编译时会生成resources.arsc，包含id到实际值的映射 都是static final，可以被内联 application module被内联了 部分不是final，是static的 library module的R文件中的常量没有被内联 aar没有被内联 压缩 AGP 4.1.0打包时，在release包中已经彻底优化掉R文件 混淆，缩短id等标识符长度 删除不需要的资源 从应用及其库依赖中检测并安全地移除不使用的类、字段、方法和属性 HTTP断点续传各种生命周期sql事务view绘制原理activity启动模式这里的都不太会2024.3.17美团笔试面向对象的各种概念 单一职责 等 编译原理相关知识 文法自动机相关知识 等 2024.3.19美团二面Service生命周期 非绑定式 -(首次startService)-&gt;onCreate() -(非首次startService)-&gt;onStartCommand() -(stopService/stopSelf)-&gt;onDestroy() 绑定式 -(首次bindService)-&gt;onCreate() -(非首次bindService)-&gt;onBind() -(unbindService/stopSelf)-&gt;onUnbind()-&gt;onDestroy() Activity与Service交互信息 非绑定式 startService时用Intent传递 绑定式 创建ServiceConnect对象，获取IBinder 通过IBinder交互 Service中创建对象，继承Binder 前台Service 前台服务，一般用来创建notification，且不可移除的通知 onCreate时通过startForeground创建通知 通过stopForeground停止前台服务 动态广播的使用sendBroadCast接受创建IntentFilter创建BroadcastReceiverregisterReceiverunregistReceiver 两个Activity之间传递消息 静态广播创建接收器在Manifest文件中注册，指定接收器类名和IntentFilter 8.0后无法接受隐式广播（intent只指定action） intent.setPackage(getPackageName()) // 接收方的包名 intent.addFlags(FLAG_RECEIVER_INCLUDE_BACKGROUND) 有序广播无序广播 无序广播 默认就是无序广播 多个接收器同时接受 有序广播 接收器依照优先级依次接受广播 通过context.sendOrderedBroadcast(intent, permission);发送 intentFilter.setPriority() sendOrderedBoradcast 在广播接收器中abortBroadcast会截断广播向低优先级的传递 setResultExtras和getResultExtras，上游接收器向下游发送消息 setResultData和getResultData，上游接收器向下游发送消息 本地广播全局广播 本地广播：仅在app内部传播 只能动态注册 LocalBroadCastReceiver（已废弃，需要手动添加依赖） 全局广播：整个系统都能接受 默认就是全局的 Java新技术（kotlin早已支持） 密封类 规定可以有哪些子类12public abstract sealed class Reference&lt;T&gt; permits PhantomReference, SoftReference, WeakReference, FinalReference { Hook技术通过反射，将某些回调字段设置成一个代理对象，代理字段中对invoke进行hook Xposed框架通过替换/system/bin/app_process程序控制zygote进程，使app_process在启动过程中加载XposedBridge.jar，从而完成对Zygote进程及其创建的Dalvik虚拟机的劫持 posed自定义模块开发1234567891011121314151617181920public class Main implements IXposedHookLoadPackage { @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable { if (!loadPackageParam.packageName.equals(&quot;com.example.pengchengxiang.inputdemo&quot;)) { return; } XposedBridge.log(&quot;Loaded app:&quot; + loadPackageParam.packageName); //Hook 类的方法 findAndHookMethod(&quot;className&quot;, loadPackageParam.classLoader, &quot;methodNAme&quot;, String.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { } }); } }","link":"/home/2024/03/13/Android%E9%AB%98%E7%BA%A7/Android%20%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/00%E9%9D%A2%E8%AF%95%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"title":"02-http","text":"格式 报文格式(Request) 请求行 eg: GET /users?id=xxxx HTTP/1.1 method path(包括参数部分) Http version headers (Host在这里) body 报文格式(Response) 状态行 eg: HTTP/1.1 200 OK Http Version status code status message headers body Requestmethod GET 获取资源 没有body POST 增加/修改资源 有body PUT 修改资源 有body DELETE 删除资源 没有body HEAD 获取资源 没有body 响应无body 用于下载时，确定文件大小，有无断点续传等信息 幂等性：指重复的请求多次向服务器传送，对服务器的没有影响。如GET和PUT,DELETE。 Responsestatus code为了方便开发人员定位错误 1xx: 临时性消息 100 当客户端传送数据过大时，将其分段发送，在最后一个请求之前，服务器每收到一个请求，返回100表示收到，客户端再发送下一个。 101 表示支持http2，浏览并尝试使用http2时，会先发送一个试探性的请求，如果返回200，说明服务器不支持http2，返回101则表示支持 2xx: 成功 3xx: 重定向 301 如，浏览器访问http时返回301，自动改用https访问 304 内容未改变 4xx: 客户端错误 400 请求有问题 401 未登录 404 没找到 5xx: 服务器出错 Header请求的数据的元数据 Host: 服务器主机(作用是区分多个域名对应同一个ip的情况，在发送之前已经解析出ip了) Content-Length: 内容长度，作用是当传送二进制数据时，确定结束位置 Content-type: 内容类型 text/html: 是html页面 application/x-www-form-urlencoded: 普通表单(html里面那个)，encoded URL格式 body中的内容和path中的参数一样，都是使用urlencoded编码的纯文本信息 multipart/form-data: 多部份，带文件的表单，二进制内容 每个part通过boundary指定 分隔 application/json image/jpeg, application/zip 传送单个文件 Chunked Transfer Encoding: 分块传输，若响应量非常大，服务器相应非常耗时时，想要每查出一部分数据后就立即返回给客户端。 body格式12345678910&lt;len1&gt;&lt;content1&gt;&lt;len2&gt;&lt;content1&gt;&lt;len3&gt;&lt;content1&gt;...more&lt;len_n&gt;&lt;content1&gt;0 #结束 Location: 重定向的目标URL User-Agent: 标识用户使用的客户端 Range / Accept-Range: 指定接收body的范围，断点续传时使用，多线程下载 Cookie / set-Cookie: Cookie Authorization: 授权信息 more Cache-Control cache和buffer的区别 Cache: 缓存，如cpu的Cache，Android的LRUCache。已经使用过的内存，未来可能还要用，暂时存起来 Buffer: 缓冲，未来一定会用，来不及使用/预读提升速度。如视频缓冲 no-cache: 可以缓存，再次访问该页面时，重新请求 no-store: 不要缓存 max-age: 请求结果具有生效时间 private/private: 消息链路上的其他路由节点是否可以缓存这个消息 Last-Modified资源最近一次更新的时间，若更新于请求之后，则资源失效 Etag类似hash值，若不一样则资源失效 REST REST 更多http相关资源","link":"/home/2023/09/23/Android%E9%AB%98%E7%BA%A7/Android%20%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/02Http/"},{"title":"00-面试查漏补缺","text":"View绘制流程图 起点：ViewRootImpl在ViewRootImpl中有一个巨长的方法performTraversals，其中会依次调用三个函数 performMeasure performLayout performDraw 通过ViewRootImpl的setView方法，ViewRootImpl对象会拥有一个mView对象 在performMeasure方法中会调用mView.measure() 1234567891011121314private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) { if (mView == null) { return; } Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;); try { mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); } finally { Trace.traceEnd(Trace.TRACE_TAG_VIEW); } mMeasuredWidth = mView.getMeasuredWidth(); mMeasuredHeight = mView.getMeasuredHeight(); mViewMeasureDeferred = false;} 在performLayout方法中会调用mView.layout() 123456789101112131415161718192021private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) { mScrollMayChange = true; mInLayout = true; final View host = mView; if (host == null) { return; } if (DEBUG_ORIENTATION || DEBUG_LAYOUT) { Log.v(mTag, &quot;Laying out &quot; + host + &quot; to (&quot; + host.getMeasuredWidth() + &quot;, &quot; + host.getMeasuredHeight() + &quot;)&quot;); } Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;layout&quot;); try { host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); // ... // todo: 后面还有一个requestLayout，后续可以了解一下 } // ...} 在performDraw方法中会通过performDraw-&gt;draw-&gt;drawSoftware-&gt;mView.draw()调用mView的draw方法 measure和onMeasureView的measure和onMeasure12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public final void measure(int widthMeasureSpec, int heightMeasureSpec) { boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) { Insets insets = getOpticalInsets(); int oWidth = insets.left + insets.right; int oHeight = insets.top + insets.bottom; widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth); heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight); } // Suppress sign extension for the low bytes long key = (long) widthMeasureSpec &lt;&lt; 32 | (long) heightMeasureSpec &amp; 0xffffffffL; if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2); final boolean forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT; // Optimize layout by avoiding an extra EXACTLY pass when the view is // already measured as the correct size. In API 23 and below, this // extra pass is required to make LinearLayout re-distribute weight. final boolean specChanged = widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec; final boolean isSpecExactly = MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY &amp;&amp; MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY; final boolean matchesSpecSize = getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec) &amp;&amp; getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec); final boolean needsLayout = specChanged &amp;&amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize); if (forceLayout || needsLayout) { // first clears the measured dimension flag mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET; resolveRtlPropertiesIfNeeded(); int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key); if (cacheIndex &lt; 0 || sIgnoreMeasureCache) { // measure ourselves, this should set the measured dimension flag back onMeasure(widthMeasureSpec, heightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } else { long value = mMeasureCache.valueAt(cacheIndex); // Casting a long to int drops the high 32 bits, no mask needed setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value); mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } // flag not set, setMeasuredDimension() was not invoked, we raise // an exception to warn the developer if ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) { throw new IllegalStateException(&quot;View with id &quot; + getId() + &quot;: &quot; + getClass().getName() + &quot;#onMeasure() did not set the&quot; + &quot; measured dimension by calling&quot; + &quot; setMeasuredDimension()&quot;); } mPrivateFlags |= PFLAG_LAYOUT_REQUIRED; } mOldWidthMeasureSpec = widthMeasureSpec; mOldHeightMeasureSpec = heightMeasureSpec; mMeasureCache.put(key, ((long) mMeasuredWidth) &lt;&lt; 32 | (long) mMeasuredHeight &amp; 0xffffffffL); // suppress sign extension} 参数1234567891011121314151617181920212223public static class MeasureSpec { private static final int MODE_SHIFT = 30; private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT; /** * Measure specification mode: The parent has not imposed any constraint * on the child. It can be whatever size it wants. */ public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; /** * Measure specification mode: The parent has determined an exact size * for the child. The child is going to be given those bounds regardless * of how big it wants to be. */ public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; /** * Measure specification mode: The child can be as large as it wants up * to the specified size. */ public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT;} spec是specification的缩写，意思是规格，三种测量规格 UNSPECIFIED: 对子view无限制 EXACTLY: 严格按照父view的限制 AT_MOST: 最大这么大 123456789101112131415161718public static int makeMeasureSpec(@IntRange(from = 0, to = (1 &lt;&lt; MeasureSpec.MODE_SHIFT) - 1) int size, @MeasureSpecMode int mode) { if (sUseBrokenMakeMeasureSpec) { return size + mode; } else { return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); }}@MeasureSpecModepublic static int getMode(int measureSpec) { //noinspection ResourceType return (measureSpec &amp; MODE_MASK);}public static int getSize(int measureSpec) { return (measureSpec &amp; ~MODE_MASK);} 0-29位是size，最高两位才是mode onMeasuremeasure方法的内容暂时不看重要的是onMeasure，他是非final的，在自定义view时，会用到 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));} ViewGroup的onMeasure函数ViewGroup本身没有重写onMeasure，以FrameLayout为例，会调用子view的measure方法,根据自身的布局规则确定子view的size和mode 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int count = getChildCount(); final boolean measureMatchParentChildren = MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY || MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY; mMatchParentChildren.clear(); int maxHeight = 0; int maxWidth = 0; int childState = 0; for (int i = 0; i &lt; count; i++) { final View child = getChildAt(i); if (mMeasureAllChildren || child.getVisibility() != GONE) { measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin); maxHeight = Math.max(maxHeight, child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin); childState = combineMeasuredStates(childState, child.getMeasuredState()); if (measureMatchParentChildren) { if (lp.width == LayoutParams.MATCH_PARENT || lp.height == LayoutParams.MATCH_PARENT) { mMatchParentChildren.add(child); } } } } // Account for padding too maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground(); maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground(); // Check against our minimum height and width maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight()); maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth()); // Check against our foreground's minimum height and width final Drawable drawable = getForeground(); if (drawable != null) { maxHeight = Math.max(maxHeight, drawable.getMinimumHeight()); maxWidth = Math.max(maxWidth, drawable.getMinimumWidth()); } setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), resolveSizeAndState(maxHeight, heightMeasureSpec, childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT)); count = mMatchParentChildren.size(); if (count &gt; 1) { for (int i = 0; i &lt; count; i++) { final View child = mMatchParentChildren.get(i); final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec; if (lp.width == LayoutParams.MATCH_PARENT) { final int width = Math.max(0, getMeasuredWidth() - getPaddingLeftWithForeground() - getPaddingRightWithForeground() - lp.leftMargin - lp.rightMargin); childWidthMeasureSpec = MeasureSpec.makeMeasureSpec( width, MeasureSpec.EXACTLY); } else { childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, getPaddingLeftWithForeground() + getPaddingRightWithForeground() + lp.leftMargin + lp.rightMargin, lp.width); } final int childHeightMeasureSpec; if (lp.height == LayoutParams.MATCH_PARENT) { final int height = Math.max(0, getMeasuredHeight() - getPaddingTopWithForeground() - getPaddingBottomWithForeground() - lp.topMargin - lp.bottomMargin); childHeightMeasureSpec = MeasureSpec.makeMeasureSpec( height, MeasureSpec.EXACTLY); } else { childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, getPaddingTopWithForeground() + getPaddingBottomWithForeground() + lp.topMargin + lp.bottomMargin, lp.height); } child.measure(childWidthMeasureSpec, childHeightMeasureSpec); } }} layout和onLayoutView的layout和onLayout1234567891011@SuppressWarnings({&quot;unchecked&quot;})public void layout(int l, int t, int r, int b) { int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); onLayout(changed, l, t, r, b);} setFrame会根据l, r, t, b的值，更新mLeft, mTop, mBottom, mRight 12protected void onLayout(boolean changed, int left, int top, int right, int bottom) {} ViewGroup的onLayout方法123@Overrideprotected abstract void onLayout(boolean changed, int l, int t, int r, int b); 子类可选实现变成子类必须实现 FrameLayout的onLayout1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@Overrideprotected void onLayout(boolean changed, int left, int top, int right, int bottom) { layoutChildren(left, top, right, bottom, false /* no force left gravity */);}void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) { final int count = getChildCount(); final int parentLeft = getPaddingLeftWithForeground(); final int parentRight = right - left - getPaddingRightWithForeground(); final int parentTop = getPaddingTopWithForeground(); final int parentBottom = bottom - top - getPaddingBottomWithForeground(); for (int i = 0; i &lt; count; i++) { final View child = getChildAt(i); if (child.getVisibility() != GONE) { final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final int width = child.getMeasuredWidth(); final int height = child.getMeasuredHeight(); int childLeft; int childTop; int gravity = lp.gravity; if (gravity == -1) { gravity = DEFAULT_CHILD_GRAVITY; } final int layoutDirection = getLayoutDirection(); final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection); final int verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK; switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) { case Gravity.CENTER_HORIZONTAL: childLeft = parentLeft + (parentRight - parentLeft - width) / 2 + lp.leftMargin - lp.rightMargin; break; case Gravity.RIGHT: if (!forceLeftGravity) { childLeft = parentRight - width - lp.rightMargin; break; } case Gravity.LEFT: default: childLeft = parentLeft + lp.leftMargin; } switch (verticalGravity) { case Gravity.TOP: childTop = parentTop + lp.topMargin; break; case Gravity.CENTER_VERTICAL: childTop = parentTop + (parentBottom - parentTop - height) / 2 + lp.topMargin - lp.bottomMargin; break; case Gravity.BOTTOM: childTop = parentBottom - height - lp.bottomMargin; break; default: childTop = parentTop + lp.topMargin; } child.layout(childLeft, childTop, childLeft + width, childTop + height); } }} 计算child的ltrb，依次调用子类的Layout draw,onDraw和dispatchDraw12345678910111213141516171819202122232425262728293031323334public void draw(Canvas canvas) { /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) * 7. If necessary, draw the default focus highlight */ drawBackground(canvas); saveCount = canvas.getSaveCount(); // Step 3, draw the content onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 5, draw the fade effect and restore layers // canvas.drawXXX canvas.restoreToCount(saveCount); // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // Step 7, draw the default focus highlight drawDefaultFocusHighlight(canvas);} 分为7步 绘制背景 获取当前画布save次数,记录状态 绘制内容，由onDraw实现 绘制子view 恢复步骤2的画布状态 绘制前景，滚动条 如果获取了焦点，绘制一个高光 1234567/** * Implement this to do your drawing. * * @param canvas the canvas on which the background will be drawn */protected void onDraw(Canvas canvas) {} 123456789/** * Called by draw to draw the child views. This may be overridden * by derived classes to gain control just before its children are drawn * (but after its own view has been drawn). * @param canvas the canvas on which to draw the view */protected void dispatchDraw(Canvas canvas) {} ViewGroup的dispatchDraw123456789101112131415@Overrideprotected void dispatchDraw(Canvas canvas) { // ... for (int i = 0; i &lt; childrenCount; i++) { // ... final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex); if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) { more |= drawChild(canvas, child, drawingTime); } // ... } // ...} 其中drawChild会调用子view的draw方法","link":"/home/2024/03/13/Android%E9%AB%98%E7%BA%A7/Android%20%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/00%E9%9D%A2%E8%AF%95%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA2/"},{"title":"01-多线程","text":"java threadsynchronized 类锁 修饰static函数和synchronized(ClassName.class)都是获取类锁 对象锁 修饰成员函数和synchronized(this|object)都是对象锁 其中修饰成员函数和synchronized(this)获取的都是当前类对象的锁 优点 简单，易用 开销少 缺点 可重入性差 大量使用可能导致性能下降 推荐用法 单例模式使用 用于计数器的自增或类似场景 Object.wait, Object.notify, Object.notifyAll函数作用顾名思义 wait: 先释放对象锁，等待notify/notifyAll后释放也就是说，可以基于他们实现条件变量, pv操作 native join: 让调用线程等待其结束 yeild: 暂时让出时间片 sleep: sleep interrupt: 打断执行 调用后，线程中的一些任务可能产生InterruptedException interrupted(): 线程中判断是否被打断，若中断，返回true，并清除标志位(下一次一定返回false),try-catch InterruptException也会导致标志位清除 isInterrupted(): 测试是否被打断，若中断，返回true，但不清除标志位(下一次一定返回与上一次相同) Callable 实现Callable，能获取返回状态 守护线程在start()前，调用setDaemon(true)即可创建。类似于守护进程，是一直存在运行的线程。由于jvm的存在，若主线程退出，其他线程运行结束后会退出， 其他 ThreadLocal 相当于pthread的每线程存储 一个包装器，包装任何类型后，调用get,set方法，获取/修改当前线程中的值 java线程生命周期 GC Roots在GC时，如何判断一个对象是否可回收，就是看其是否直接/间接被GC Roots引用，GC Roots一般包括 系统类加载器加载的类: Class: Classes loaded by a system class loader; contains references to static variables as well 当前栈中的对象: Stack Local: Local variables and parameters to methods stored on the local stack 活跃的线程: Active Java Threads: All active Java threads JNI(native代码)引用的对象: JNI References: Native code Java objects created for JNI calls; contains local variables,parameters to JNI methods, and global JNI references Additionally, there are a few more possible types of GC Roots: 监视器监视的对象: Objects used as monitors for synchronization 由JVM实现定义的特定对象: Specific objects defined by the JVM implementation that are not garbage collected for its purpose. That might contain important exception classes, system class loaders, or custom class loaders 内存泄露要注意内存泄露，非静态的内部类会持有外部的对象，若内部类是一个线程，则会导致外部对象（如Activity）无法释放，导致内存泄露 几种多线程工具的选择 AsyncTask(已弃用): 小而短的任务，后台任务需要推到前台 Executor: 推荐使用，后台任务执行，不需要推回前台 Handler: 可以把任务推到前台 HandlerThread: 把一个任务推到后台的一个线程中 Service: 不是线程，他是后台任务的活动空间（存后台任务的状态） IntentService: 线程中使用context时 isInterrupted 和 interruptd123456789101112131415161718192021public boolean isInterrupted() { return interrupted;}public static boolean interrupted() { return currentThread().getAndClearInterrupt();}boolean getAndClearInterrupt() { boolean oldValue = interrupted; // We may have been interrupted the moment after we read the field, // so only clear the field if we saw that it was set and will return // true; otherwise we could lose an interrupt. if (oldValue) { interrupted = false; clearInterruptEvent(); } return oldValue;}private static native void clearInterruptEvent();","link":"/home/2023/09/21/Android%E9%AB%98%E7%BA%A7/Android%20%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/01%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"title":"04-登录授权 Https TCP&#x2F;IP","text":"登录授权Basic在header中Authorization: Basic username:password(Base64ed, encrypted) Bearer在header中Authorization: Bearer bearer_token 这里的bearer_token就类似于github的Personal access tokens，在请求中持有token的请求，可以根据token的权限对第三方账号中的数据进行获取、修改 可以配置token的失效时间，权限大小 客户端使用Basic方式登录后获取token，之后的请求都使用该token，不必记录用户的用户名密码。 OAuth2流程在Bearer方式的授权方式中，第三方网站的token直接存储在用户端设备上是不安全的(直接将token返回给用户端设备不安全）。在OAuth2中，返回access code，用户端向自家服务器提供access code，自家服务器使用access code以安全的https信道向第三方服务器获取token，储存在服务器中，之后的对第三方账号的操作全部由服务器代劳。 HTTPShttp over ssl加密后，从传输层看，无法判断其是否是http消息。 建立过程 Client Hello Server Hello 服务器器证书 信任建⽴立 Pre-master Secret 客户端通知：将使⽤用加密通信 客户端发送：Finished 服务器器通知：将使⽤用加密通信 服务器器发送：Finished 信任建立证书为了让客户端相信我是我，需要使用数字签名，但是在不知道对方公钥的情况下，如何证明我是我呢？需要一个权威机构向其证明。证明的方式是： 使用我的公钥可以证明我是我，但是为了防止其他人生成密钥欺骗我，我在消息里添加我的证书颁布放的公钥即相关信息。使用颁布放的公钥可以验证我的证书颁布方是我的证书颁布方。但是我依然可以生成一个颁布放的密钥，颁布方的信息中需要放入根证书。每台机器上都由所有根证书的列表和根证书的公钥，使用该公钥即可验证我的颁布方的颁布方是我的颁布方的颁布方。所以只要系统中有根证书，我就是可信任的。 证书是由证书的颁布机构所签名的 流程 HMACHMAC = Hash-based Message Authenticate Code 就是一种不容易被破解的Hash，加盐，且是只有收发两方知道的盐","link":"/home/2023/09/26/Android%E9%AB%98%E7%BA%A7/Android%20%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/04%E7%99%BB%E5%BD%95%E6%8E%88%E6%9D%83_Https_TCPIP/"},{"title":"03-编码加密Hash序列化和字符集","text":"喵课程里有附带讲义，就不花时间记录了","link":"/home/2023/09/24/Android%E9%AB%98%E7%BA%A7/Android%20%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/03%E7%BC%96%E7%A0%81%E5%8A%A0%E5%AF%86Hash%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86%20copy/"},{"title":"05-Retrofit","text":"HOST验证在上节https的ca证书验证时，如果某个恶意网站直接获取整个ca证书，发给其他用户骗取信任怎么办。这个时候就需要host验证，即证书的host主机与发送证书的主机host是否是同一个域名。 fiddler如何抓包fiddler是一个中间人，通过系统代理，浏览器/应用将请求发送至fiddler，fiddler自签一个证书与浏览器/应用使用，且需要用户向操作系统安装根证书。fiddler拿到数据包后再与服务器交互。 retrofit源码阅读retrofit的使用 注解: 通过注解对Interface中的方法和参数进行标注。如@GET @POST @PUT定义HTTP的方法类型 Converter: 对请求和响应的转换，如把一个Java的File与http的Multipart互相转化 CallAdapter: 适配器，接口的返回值可能为一个Call&lt;R&gt;对象，也可能是RxJava的Single,Observale对象。适配器的作用即是将响应类型和返回类型做适配 Retrofit.create(Class&lt;T&gt;)T即为声明的接口，crate中使用反射创建了T类型的对象。 首先判断是否是Object的方法，如果是，直接调用 其次判断是否为java8的Default Method（即接口实现的方法），如果是，直接调用 如果不是，说明是接口，生成/从缓存中获取ServiceMethod&lt;?&gt; ，并调用。 方法的生成retrofit为每个method生成了一个ServiceMethod&lt;?&gt;，存储在一个concurrentMap中，调用时根据调用方法寻找对象，并调用对象的invoke方法。方法生成的东西很多，主要是： 分析注解：根据注解进行合法性检查 根据注解构造RequestFactory。用于OKHttp生成OKhttp的Call 构造CallAdaptor，把Body变成返回值 构造ResponseConverter，把响应转化为响应bodyServiceMethod&lt;?&gt;的invoke方法构造了OkHttpCall&lt;&gt;，他实现了OKhttp请求的构造，并通过okhttp发送请求，最后调用adapt方法将OKHTTP的响应做转换。adapt方法是抽象函数，由三个子类实现： SuspendForBody: 返回值不是response类型，直接返回body SuspendForResponse: 返回值是response CallAdapted: 不是kotlin的suspend方法他们三个都实现了adapt方法，使用CallAdapter进行转换 动态代理retrofit中，ExecutorCallbackCall对Call进行了代理，负责把后台任务拉回到前台。根据不同的平台，在android中使用handler。 Adaptor适配器，做转接 retrofit中，不同的CallAdaptor实现不同的转接方式 Factory根据不同的条件生产不同的对象 在retrofit中RequestFactory.Builder可以根据接口的注释，分析出请求的url，header，要不要body等信息，并根据该信息创建RequestFactory。Request Factory可以生产Okhttp.Request。 Builder有些对象很重，先构造再修改其中的值回很耗时，builder可以提前将值设置好，根据值做检查后构造对象 除了RequestFactory，Retrofit的本身也有buidler，配置不同的Converter、Adapter Abstract Factory就是有父类的工厂呗，子类工厂负责生产某一种类的产品Retrofit的各种Converter就是抽象工厂的具体实现","link":"/home/2023/09/27/Android%E9%AB%98%E7%BA%A7/Android%20%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/05Retrofit/"},{"title":"06-OKHTTP","text":"1234567891011121314151617181920212223242526272829final Dispatcher dispatcher; // 线程控制final @Nullable Proxy proxy; // 代理服务器，java.netfinal List&lt;Protocol&gt; protocols;final List&lt;ConnectionSpec&gt; connectionSpecs;final List&lt;Interceptor&gt; interceptors;final List&lt;Interceptor&gt; networkInterceptors;final EventListener.Factory eventListenerFactory;final ProxySelector proxySelector;final CookieJar cookieJar;final @Nullable Cache cache;final @Nullable InternalCache internalCache;final SocketFactory socketFactory;final SSLSocketFactory sslSocketFactory;final CertificateChainCleaner certificateChainCleaner;final HostnameVerifier hostnameVerifier;final CertificatePinner certificatePinner;final Authenticator proxyAuthenticator;final Authenticator authenticator;final ConnectionPool connectionPool;final Dns dns;final boolean followSslRedirects;final boolean followRedirects;final boolean retryOnConnectionFailure;final int callTimeout;final int connectTimeout;final int readTimeout;final int writeTimeout;final int pingInterval; websocketwikipedia: 利用tcp提供全双工通信 WebSocket is a computer communications protocol, providing full-duplex communication channels over a single TCP connection. 运行在80/443端口上 WebSocket is designed to work over HTTP ports 443 and 80 as well as to support HTTP proxies and intermediaries Dispatcher - 线程控制使用Deque控制任务 123456789101112131415private int maxRequests = 64; // 最大请求数private int maxRequestsPerHost = 5; // 每个host最大请求数private @Nullable Runnable idleCallback;/** Executes calls. Created lazily. */private @Nullable ExecutorService executorService;/** Ready async calls in the order they'll be run. */private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();/** Running asynchronous calls. Includes canceled calls that haven't finished yet. */private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();/** Running synchronous calls. Includes canceled calls that haven't finished yet. */private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); 123456789101112131415void enqueue(AsyncCall call) { synchronized (this) { readyAsyncCalls.add(call); // Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to // the same host. if (!call.get().forWebSocket) { AsyncCall existingCall = findExistingCallWithHost(call.host()); // 先从runningAsyncCall中找host，没找到再从ready中找 if (existingCall != null) call.reuseCallsPerHostFrom(existingCall); // 相同host使用同一个计数器 } } promoteAndExecute();} 123456789101112131415161718192021222324252627private boolean promoteAndExecute() { assert (!Thread.holdsLock(this)); // 当前线程没有持有this的锁 List&lt;AsyncCall&gt; executableCalls = new ArrayList&lt;&gt;(); boolean isRunning; synchronized (this) { for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) { AsyncCall asyncCall = i.next(); if (runningAsyncCalls.size() &gt;= maxRequests) break; // Max capacity. if (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) continue; // Host max capacity. i.remove(); asyncCall.callsPerHost().incrementAndGet(); executableCalls.add(asyncCall); runningAsyncCalls.add(asyncCall); } isRunning = runningCallsCount() &gt; 0; } // 把ready的请求提升为executable，条件是host没到capacity，总数没到capacity for (int i = 0, size = executableCalls.size(); i &lt; size; i++) { AsyncCall asyncCall = executableCalls.get(i); asyncCall.executeOn(executorService()); // 使用ExecutorService执行 } return isRunning;} 1234567public synchronized ExecutorService executorService() { // 单例，获取线程池 if (executorService == null) { executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false)); } return executorService;} AsyncCall - 异步请求1234final class AsyncCall extends NamedRunnable { private final Callback responseCallback; //回调 private volatile AtomicInteger callsPerHost = new AtomicInteger(0); //host计数} 承接上文的executeOn，使用线程池执行 1234567891011121314151617void executeOn(ExecutorService executorService) { assert (!Thread.holdsLock(client.dispatcher())); boolean success = false; try { executorService.execute(this); success = true; } catch (RejectedExecutionException e) { InterruptedIOException ioException = new InterruptedIOException(&quot;executor rejected&quot;); ioException.initCause(e); transmitter.noMoreExchanges(ioException); responseCallback.onFailure(RealCall.this, ioException); } finally { if (!success) { client.dispatcher().finished(this); // This call is no longer running! } }} 线程池拿到runnable，调用run，NamedRunnable调用execute 1234567891011121314151617181920212223242526272829@Override protected void execute() { boolean signalledCallback = false; transmitter.timeoutEnter(); try { Response response = getResponseWithInterceptorChain(); // 核心！调用interceptor，逐层执行，获得响应 signalledCallback = true; responseCallback.onResponse(RealCall.this, response); // 回调 } catch (IOException e) { if (signalledCallback) { // Do not signal the callback twice! Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e); } else { responseCallback.onFailure(RealCall.this, e); //回调 } } catch (Throwable t) { cancel(); if (!signalledCallback) { IOException canceledException = new IOException(&quot;canceled due to &quot; + t); canceledException.addSuppressed(t); responseCallback.onFailure(RealCall.this, canceledException); } throw t; } finally { client.dispatcher().finished(this); // 通知dispatcher结束，对两个capacity decrement // 从相应的队列中删除任务 // 再次调用promoteAndExecute，为线程池添加任务 }} 创建拦截器，并开始一层层执行 12345678910111213141516171819202122232425262728293031323334Response getResponseWithInterceptorChain() throws IOException { // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(new RetryAndFollowUpInterceptor(client)); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) { interceptors.addAll(client.networkInterceptors()); } interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, transmitter, null, 0, originalRequest, this, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); boolean calledNoMoreExchanges = false; try { Response response = chain.proceed(originalRequest); if (transmitter.isCanceled()) { closeQuietly(response); throw new IOException(&quot;Canceled&quot;); } return response; } catch (IOException e) { calledNoMoreExchanges = true; throw transmitter.noMoreExchanges(e); } finally { if (!calledNoMoreExchanges) { transmitter.noMoreExchanges(null); } }} interceptor - 拦截器RealInterceptorChain123456789101112131415161718192021@Override public Response proceed(Request request) throws IOException { return proceed(request, transmitter, exchange);}public Response proceed(Request request, Transmitter transmitter, @Nullable Exchange exchange) throws IOException { /* 检查proceed只被调用一次 */ // Call the next interceptor in the chain. RealInterceptorChain next = new RealInterceptorChain(interceptors, transmitter, exchange, index + 1, request, call, connectTimeout, readTimeout, writeTimeout); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); /* 检查proceed只被调用一次 */ /* 检查response，body不为空 */ return response;} XXXInterceptor - 对于一般的Interceptor实现12345678@Override public Response intercept(Chain chain) throws IOException { /* do task0 */ Request request = chain.request(); /* do your task1 */ Response response = chain.proceed(request); /* do your task2 */ return response;} interceptor获得chain，就是整个interceptor的链条，chain的request获取请求，对请求处理后，调用proceed，将请求处理给下一个interceptor，并返回response，在对响应处理后，将response返回。每个interceptor对象配合一个RealInterceptorChain工作。RealInterceptorChain是一个chain，（也就是interceptor的参数），RealInterceptorChain保存上一级的request interceptor通过调用RealInterceptorChain的proceed函数传递自己处理的request，proceed函数创建下一个interceptor的RealInterceptorChain，并调用interceptor的intercept，这样下一个intercept又会调用request获取request，然后调用proceed传递处理后的请求，得到response。每个interceptor调用proceed获得响应并处理后，将自己处理后的请求返回给上一级的RealInterceptorChain.proceed，上一级的RealInterceptorChain.proceed又将其返回给上一级的intercept函数 ConnectionSpec - 连接配置CertificatePinner - 自签名验证Authenticator - 登录connectionPoolDNSfollowxxxredirectpingInterval - websocket的心跳间隔 一方发ping and 一方发pong","link":"/home/2023/10/10/Android%E9%AB%98%E7%BA%A7/Android%20%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/06okhttp/"},{"title":"18-Java多线程","text":"Thread, Runnable, callable 基础 ThreadFactory123public interface ThreadFactory { Thread newThread(Runnable r);} 实现一个工厂，生成thread，方便对同类thread进行统一的初始化操作 Executor 见思维导图，《Java核心基础12卷》的笔记 synchronized 固有锁和条件 作用 控制进程之间互斥访问 保证监控中的数据被写回内存 非公平锁：先抢锁再排队 与ReentrantLock的区别两者的不同点： ReentrantLock 显示的获得、释放锁，synchronized 隐式获得释放锁 ReentrantLock 可响应中断、可轮回，synchronized 是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性 ReentrantLock 是API 级别的，synchronized 是 JVM 级别的 ReentrantLock 可以实现公平锁 ReentrantLock 通过 Condition 可以绑定多个条件 底层实现不一样， synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻塞，采用的是乐观并发策略 Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现。 synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生； 而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象， 因此使用 Lock 时需要在finally 块中释放锁。 Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用synchronized 时， 等待的线程会一直等待下去，不能够响应中断。 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。 Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等。 乐观锁和悲观锁（数据库） 乐观锁：认为很少会发生冲突，在操作时不加锁，在写入时观察数据与之前读取时是否相同，相同则直接写回，不相同则重新操作一次 悲观锁：以每次在拿数据的时候都会上锁 公平锁非公平锁 公平锁：按规则排队等锁，倾向于调度等待时间最长的线程 非公平锁：先竞争锁，再排队 ReetrentLock 获取条件 获取读写锁","link":"/home/2024/03/11/Android%E9%AB%98%E7%BA%A7/Android%20%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/18Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"title":"07-自定义view-绘制","text":"坐标轴 尺寸单位 一律为像素 apiCanvas画布 123456789101112131415drawLinedrawCircledrawOvaldrawBitmapdrawPathdrawdrawArc // 以一个矩形空间为参考，指定起始角度和终止角度，画一个弧线save // 保存画布状态（栈translate // 移动画布，其他变换还有translate,scale,rotate,skew,concat or clipRect等restore //弹栈，恢复画布// 移动画布不会影响已经绘制的图形的位置，restore也是saved = saveLayer() // 为画布新建图层，当使用xfermode融合图像时，如果直接在旧图层上绘制，旧图层会造成干扰// 在新图层上操作restoreToCount(saved) // 恢复画布到保存的状态 Path1234addRectaddCircleaddOvaladdRoundRect 通过canvas.drawPath将path绘制 绘制方向1path.setFillType 123456789101112131415161718192021222324252627public enum FillType { // these must match the values in SkPath.h /** * Specifies that &quot;inside&quot; is computed by a non-zero sum of signed * edge crossings. */ WINDING (0), /** * Specifies that &quot;inside&quot; is computed by an odd number of edge * crossings. */ EVEN_ODD (1), /** * Same as {@link #WINDING}, but draws outside of the path, rather than inside. */ INVERSE_WINDING (2), /** * Same as {@link #EVEN_ODD}, but draws outside of the path, rather than inside. */ INVERSE_EVEN_ODD(3); FillType(int ni) { nativeInt = ni; } final int nativeInt;} 作用判断一个点是否在图形内部 从该点向任意方向发射射线，路径上所有相交而非相切的位置中，若从左侧穿过射线，cnt++，右侧穿过，cnt–。若使用WINDING，最终cnt为0，则是在外部，否则在内部；若使用EVEN_ODD，最终cnt为奇数，点在内部，为偶数，点在外部 如果使用WINDING，需要两个图形相减的操作，则将两个图形的绘制方向设为相反的，这样相交部分的点就被认为在图形外部，而不会被涂色。 如果使用EVEN_ODD，需要两个图形相减的操作，不需要处理其绘制方向 View.onSizeChanged每次layout尺寸改变时会调用 PathMeasure测量一个path， 12getLength // 整个图像的周长getPosTan // 获得从起点触发，绘制某个长度后的点所咋位置的正切值 用处比如要做一个仪表盘，在某个位置画刻度，需要总长度计算刻度的间隔 misc java里也有类似kotlin的init{}，只要在类中直接使用{}即可 12345class XXX { { // init codes }} BitmapFactry.Options options.inJustDecodeBounds, 只获取长宽，不加在资源 Xfermode 是一种图像混合模式 paint画笔，定义绘制时的各种特性 12setPathEffect // 使用一个path作为绘制的效果setStyle dp2px1TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dip, Resources.getSystem().displayMetrics) 注意这里通过getSystem获取的Resources是无法获取应用中定义的colors，strings等资源的官方文档对其的描述是: Return a global shared Resources object that provides access to only system resources (no application resources), is not configured for the current screen (can not use dimension units, does not change based on orientation, etc), and is not affected by Runtime Resource Overlay. 练习PieChartDashBoardAvatarView(drawbitmap)","link":"/home/2023/10/24/Android%E9%AB%98%E7%BA%A7/Android%20%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/07%E8%87%AA%E5%AE%9A%E4%B9%89view-%E7%BB%98%E5%88%B6/"},{"title":"20-Android多线程","text":"Thread.yield() 暂时把时间片让出去，变成可运行状态(ready) handlerLooper ThreadLocal的 相当于一个线程里的大循环 在大循环里循环从messageQueue中拿消息 拿到消息后执行消息 Handler 持有messageQueue，通过post将Runnable变成Message，根据when加入到messageQueue中 messageQueue 一个队列，用链表维护的 每个消息包含runnable和对应的handler","link":"/home/2024/03/11/Android%E9%AB%98%E7%BA%A7/Android%20%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/20Android%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"title":"19-RecyclerView","text":"RecyclerView flexible: limited: 有限屏幕中显示 large: 大量内容 RecyclerView的优势 Linear, Grid, Staggered Grid三种布局 itemAnimator接口 强制实现ViewHolder 解耦设计 性能更好 listView的局限 只能纵向列表 没有动画api api设计太个性了，和其他view设计的重复 性能不好 三个帮手 LayoutManager: 负责布局Views ItemAnimator: 负责给View加动画 Adaptor: 提供views ViewHolder 一个ItemView对应一个Viewholder（缓存view，防止反复findViewById） RecycclerView缓存机制 对ViewHolder进行缓存，四级缓存，从上到下 scrap: 屏幕内的ItemView, 通过position找到，且数据依然有效，可以直接复用 cache: 默认为2,刚出屏幕的Item进行缓存，数据也是clean的，通过pos找到 ViewCacheExtension: 缓存几个固定不变的，复杂的item，每次可以重复使用 RecycledViewPool: dirty数据，需要重新绑定数据，根据view type缓存 对item展示次数的统计 ListView: getView统计 RecyclerView: onViewAttachedToWindow统计 性能优化 item监听：onCreateViewHolder时创建（全部共享一个、每个对象一个） LinearLayoutManager.setInitialPrefetchItemCount(): 需要在ItemView中创建子RecyclerView RenderThread（做渲染的线程）中，会做RecyclerView的prefetch 指定初始看到时需要显示的item数目 在内部嵌套的view中调用 RecyclerView.setHasFixedSize() RecyclerView有数据插入、删除时，根据这个flag选择是否重绘整个RecyclerView 如果Adapter数据变化不会影响RecyclerView的大小变化时，设置为true 多个RecyclerView有相同的viewType，多个RecyclerView共享RecycledViewPool DiffUtil 计算两个list的区别并生成把A列表转换为B列表的操作 解决的问题：最小化更新页面的操作，节省计算资源 notifyItemXXX不适用于所有情况 notifyDateSetChange: 整个list重新绘制+动画丢失 在列表很大时，异步计算diff Thread， handler RxJava ListAdapter， AsyncListDiffer payloadsView TypeItemDecoration 画分割线 高亮 分组 RecyclerView各种用法的demoAdvancedRecyclerView function resize_iframe(div) { const width = div.offsetWidth; div.style.height = div.offsetWidth*4.0/3.0 + 'px'; // console.log(\"resize height : \" + div.style.height) } const div = document.getElementById('RecyclerViewIframe'); resize_iframe(div); window.addEventListener('resize', function() { resize_iframe(div); });","link":"/home/2024/03/12/Android%E9%AB%98%E7%BA%A7/Android%20%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/19RecyclerView/"},{"title":"01-Flutter-快速入门实战","text":"flutter everything is a widget widget在flutter中，所有看得见的看不见的东西都是widget 目录结构 android: ios: lib: dart文件，业务逻辑 lib/main.dart: 入口 pubspec.yaml: 工程信息以及依赖 依赖声明pubspec.yaml中 123456789dependencies: package_name: [version_code] package_name: ^[version_code] # ^的作用是让系统选择更高且与version_code相兼容的版本 packge_name: [git_url] packge_name: [local path]dev_dependencies: # 仅在开发时依赖，在release时不打包 package_name: param 布局本节内容来自fluuter docs/ui/layout 简介 flutter中的layout 常见layout Center Container Baseline Row Column Stack Table 将小部件添加到布局 child: 唯一子widget children: 多个列表型的子widget(如Row, Column, Stack) build方法大多数widgets都有build方法,flutter app本身也是一个widget,通过build方法实例化并返回一个widget就会显示该widget App CupertinoApp: ios风格的app theme传入CupertinoThemeData home属性用CupertinoPageScaffold 全部Cupertino lib MaterialApp: Material风格的app home用Scaffold 可以使用ActionButton, SneakBar Container: 如果不需要Material风格或ios风格，直接返回Container Row和Colum 主轴和交叉轴(main axis, cross axis) row的主轴和交叉轴分别是水平的和垂直的 column的主轴和交叉轴反过来 MainAxisAlignment和CrossAxisAlignment提供了控制对齐方式的常量 多个children的大小 使用Expanded: 让子widget适应row/column的大小，使用Expanded的属性flex制定其大小的权重 使用mainAxisSize: MainAxisSize.min控制大小，让其紧凑的贴在一起 常用布局小组件 标准小组件Container：向小部件添加填充、边距、边框、背景颜色或其他装饰。GridView：将小部件布置为可滚动网格。ListView：将小部件布置为可滚动列表。Stack：将一个小部件重叠在另一个小部件之上。 material布局小组件Card：将相关信息组织到带有圆角和阴影的框中。ListTile：将最多 3 行文本以及可选的前导和尾随图标组织成一行。 约束ConstraintsUnderstanding constraintsFlutter的布局引擎被设计为一次通过的过程。这意味着Flutter可以非常有效地布局其小部件，但也存在一些限制: 小部件只能在父部件给它的约束范围内决定自己的大小。这意味着一个小部件通常不能有它想要的大小。 小部件不能知道也不能决定它自己在屏幕上的位置，因为决定小部件位置的是小部件的父组件。 因为父元素的大小和位置也依赖于它自己的父元素，所以不考虑整个树，就不可能精确地定义任何小部件的大小和位置。 如果子元素想要与父元素不同的大小，并且父元素没有足够的信息来对齐它，那么子元素的大小可能会被忽略。在定义alignment时要明确。 特性 若屏幕是父布局，无论该widget是否定义其大小、宽度，该widget会强制铺满屏幕 对于Align, Center, 子widget的大小不能超过父widget的情况下，子widget可以拥有任意的大小 如果父widget没有大小，他的大小由子widget决定 ConstrainedBox 如果ConstrainedBox（可以指定子widget的宽度高度的范围）的父widget是屏幕。 屏幕会约束widget大小正好等于屏幕 ConstrainedBox只能从父widget的约束中施加约束。也就是如果子widget的约束不在父widget的约束范围内，那么就只能依照父widget的约束 如果子widget要求的大小超过了ConstrainedBox的限制，只能取限制的最大值，若小于最低限制，则只能是最小值 UnconstrainedBox 允许子widget拥有任何大小，如果子widget大小超过UnconstrainedBox，则会在屏幕上显示”overflow warning” 如果子widget要求大小为double.infinity，则不会显示任何内容，且会在console中提示error信息 OverflowBox 允许子widget拥有任何大小，如果子widget大小超过UnconstrainedBox，则会尽量显示子widget的内容，不会出现”overflow warning” LimitedBox 限制子widget的大小范围，但仅在子widget设置为double.infinity时生效，如果设置不是double.infinity也不在LimitedBox限制的范围内，则显示子widget要求的大小而不应用LimitedBox的限制 FittedBox 父widget是screen,子widget是Text Text根据字体大小，字符，长度计算出宽度(intrinsic)后，根据自身宽度缩放Text填充空白，超过则缩小 父widget是Center（允许子widget有自己的大小）,子widget是Text Text根据字体大小，字符，长度计算出宽度(intrinsic)后，如果可以，FittedBox先让自己的大小适应Text，若不行，则缩放Text 只能缩放有边界的，长宽不是无穷的widget，否则什么都不会显示，且在console中报告错误。 Center+Text 不缩放，文字太长就break line Row 类似于UnconstrainedBox widget由Expanded包裹，则不允许子widget自定义宽度，由其他children决定宽度 如果所有children都被Expanded包裹，那么大家都按照Expand中分配的比例决定其宽度 Flexible允许它的子控件具有与Flexible相同或更小的宽度，而Expanded则强制它的子控件具有与Expanded完全相同的宽度 Scaffold 通过SizedBox.expand包裹子widget，可以让子widget与Scaffold有相同的大小 松紧约束(Tight Loose Constraints) Tight Constraints 最大宽度=最小宽度, 最大长度=最小长度 Losse Constraints 最小宽度 = 0, 最小长度 = 0 最大宽度 != 0, 最大长度 != 0 Center就是把收到的tight约束转换成loose约束 无限约束(unbounded constraint) 最大宽度 = double.infinite, 最大长度 = double.infinite 一般情况下会导致console中出现error 用于ListView等ScrollView的子类 滑动方向上的长/宽无限 Flex Flex Box(Row 或 Column) 若主轴上拥有有限约束，则经可能的大 若主轴上拥有无限约束，每个孩子的flex值必须为0，也就是不能在可滑动widget或flex box中使用Expand 交叉轴方向不能无限，否则无法align children Stack 常见属性 alignment 传入坐标值 原点在widget中心 水平向右为x轴，x=[-1, 1] 从左到右 竖直向下为y轴，y=[-1, 1] 从上到下 fit 传入StackFit 值有: loose, expand, passthrough overflow 空间溢出的操作: clip / visible position 一个widget, 和stack搭配使用 确定stack中子widget的位置 Container包括了: SizedBox, Center, Padding, DecoratedBox, ConstrainedBox的功能 StateFull/StateLess didUpdatedWidget widget参数发生改变时触发 AnimationInheritedWidget of方法，从当前widget向上查找，直到找到该类型的个Widget 不允许在initState调用of方法 自上而下传递状态在父widget中 updateShouldNotify 是否向下传递变化 在子widget中 didChangeDepandencies 状态同步 若一个子widget通过of获取过我的属性，那么我的属性变化时，都会重新build这些子widget 在重新build之前，会触发didChangeDepandencies initState后也会调用一次didChangeDepandencies 自下而上的消息传递父widget用NotificationListener&lt;XXXNotification&gt;包装子widget中需要传递消息时，创建一个XXXNotification，并调用dispatch 页面跳转Navigator push(Widget) widget栈中加入一个widget pop 弹出一个widget","link":"/home/2024/04/24/Android%E9%AB%98%E7%BA%A7/flutter%E5%85%A5%E9%97%A8/01-Flutter-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98/"},{"title":"基础01-Context","text":"大纲 Context类 注解 用于标注文件、SharedPreferences、数据库的打开方式的注解 用于标注bindService时，service的flags的注解 用于标注registerReceiver时，receiver的flags的注解 用于标注getService时，servicesName的注解 用于标注createPackageContext、createPackageContextAsUser、createContextAsUser、createApplicationContext时的flags的注解 常量定义 对应上面注解中限制的常量 WAL Context类Context是抽象类，具体实现在ContextImpl，Application，Service，Activity都直接或间接继承自ContextWrapper，ContextWrapper通过代理的方式调用真正的ContextImpl。 注解123456789101112131415161718192021222324252627282930/** @hide */@IntDef(flag = true, prefix = { &quot;MODE_&quot; }, value = { MODE_PRIVATE, MODE_WORLD_READABLE, MODE_WORLD_WRITEABLE, MODE_APPEND,})@Retention(RetentionPolicy.SOURCE)public @interface FileMode {}/** @hide */@IntDef(flag = true, prefix = { &quot;MODE_&quot; }, value = { MODE_PRIVATE, MODE_WORLD_READABLE, MODE_WORLD_WRITEABLE, MODE_MULTI_PROCESS,})@Retention(RetentionPolicy.SOURCE)public @interface PreferencesMode {}/** @hide */@IntDef(flag = true, prefix = { &quot;MODE_&quot; }, value = { MODE_PRIVATE, MODE_WORLD_READABLE, MODE_WORLD_WRITEABLE, MODE_ENABLE_WRITE_AHEAD_LOGGING, MODE_NO_LOCALIZED_COLLATORS,})@Retention(RetentionPolicy.SOURCE)public @interface DatabaseMode {} 123456789101112131415/** @hide */@IntDef(flag = true, prefix = { &quot;BIND_&quot; }, value = { BIND_AUTO_CREATE, BIND_DEBUG_UNBIND, BIND_NOT_FOREGROUND, BIND_ABOVE_CLIENT, BIND_ALLOW_OOM_MANAGEMENT, BIND_WAIVE_PRIORITY, BIND_IMPORTANT, BIND_ADJUST_WITH_ACTIVITY, BIND_NOT_PERCEPTIBLE, BIND_INCLUDE_CAPABILITIES})@Retention(RetentionPolicy.SOURCE)public @interface BindServiceFlags {} 123456/** @hide */@IntDef(flag = true, prefix = { &quot;RECEIVER_VISIBLE_&quot; }, value = { RECEIVER_VISIBLE_TO_INSTANT_APPS})@Retention(RetentionPolicy.SOURCE)public @interface RegisterReceiverFlags {} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/** @hide */@StringDef(suffix = { &quot;_SERVICE&quot; }, value = { POWER_SERVICE, //@hide: POWER_STATS_SERVICE, WINDOW_SERVICE, LAYOUT_INFLATER_SERVICE, ACCOUNT_SERVICE, ACTIVITY_SERVICE, ALARM_SERVICE, NOTIFICATION_SERVICE, ACCESSIBILITY_SERVICE, CAPTIONING_SERVICE, KEYGUARD_SERVICE, LOCATION_SERVICE, //@hide: COUNTRY_DETECTOR, SEARCH_SERVICE, SENSOR_SERVICE, SENSOR_PRIVACY_SERVICE, STORAGE_SERVICE, STORAGE_STATS_SERVICE, WALLPAPER_SERVICE, TIME_ZONE_RULES_MANAGER_SERVICE, VIBRATOR_MANAGER_SERVICE, VIBRATOR_SERVICE, //@hide: STATUS_BAR_SERVICE, CONNECTIVITY_SERVICE, PAC_PROXY_SERVICE, VCN_MANAGEMENT_SERVICE, //@hide: IP_MEMORY_STORE_SERVICE, IPSEC_SERVICE, VPN_MANAGEMENT_SERVICE, TEST_NETWORK_SERVICE, //@hide: UPDATE_LOCK_SERVICE, //@hide: NETWORKMANAGEMENT_SERVICE, NETWORK_STATS_SERVICE, //@hide: NETWORK_POLICY_SERVICE, WIFI_SERVICE, WIFI_AWARE_SERVICE, WIFI_P2P_SERVICE, WIFI_SCANNING_SERVICE, //@hide: LOWPAN_SERVICE, //@hide: WIFI_RTT_SERVICE, //@hide: ETHERNET_SERVICE, WIFI_RTT_RANGING_SERVICE, NSD_SERVICE, AUDIO_SERVICE, AUTH_SERVICE, FINGERPRINT_SERVICE, //@hide: FACE_SERVICE, BIOMETRIC_SERVICE, MEDIA_ROUTER_SERVICE, TELEPHONY_SERVICE, TELEPHONY_SUBSCRIPTION_SERVICE, CARRIER_CONFIG_SERVICE, EUICC_SERVICE, //@hide: MMS_SERVICE, TELECOM_SERVICE, CLIPBOARD_SERVICE, INPUT_METHOD_SERVICE, TEXT_SERVICES_MANAGER_SERVICE, TEXT_CLASSIFICATION_SERVICE, APPWIDGET_SERVICE, //@hide: VOICE_INTERACTION_MANAGER_SERVICE, //@hide: BACKUP_SERVICE, REBOOT_READINESS_SERVICE, ROLLBACK_SERVICE, DROPBOX_SERVICE, //@hide: DEVICE_IDLE_CONTROLLER, //@hide: POWER_WHITELIST_MANAGER, DEVICE_POLICY_SERVICE, UI_MODE_SERVICE, DOWNLOAD_SERVICE, NFC_SERVICE, BLUETOOTH_SERVICE, //@hide: SIP_SERVICE, USB_SERVICE, LAUNCHER_APPS_SERVICE, //@hide: SERIAL_SERVICE, //@hide: HDMI_CONTROL_SERVICE, INPUT_SERVICE, DISPLAY_SERVICE, //@hide COLOR_DISPLAY_SERVICE, USER_SERVICE, RESTRICTIONS_SERVICE, APP_OPS_SERVICE, ROLE_SERVICE, //@hide ROLE_CONTROLLER_SERVICE, CAMERA_SERVICE, //@hide: PLATFORM_COMPAT_SERVICE, //@hide: PLATFORM_COMPAT_NATIVE_SERVICE, PRINT_SERVICE, CONSUMER_IR_SERVICE, //@hide: TRUST_SERVICE, TV_INPUT_SERVICE, //@hide: TV_TUNER_RESOURCE_MGR_SERVICE, //@hide: NETWORK_SCORE_SERVICE, USAGE_STATS_SERVICE, MEDIA_SESSION_SERVICE, MEDIA_COMMUNICATION_SERVICE, BATTERY_SERVICE, JOB_SCHEDULER_SERVICE, //@hide: PERSISTENT_DATA_BLOCK_SERVICE, //@hide: OEM_LOCK_SERVICE, MEDIA_PROJECTION_SERVICE, MIDI_SERVICE, RADIO_SERVICE, HARDWARE_PROPERTIES_SERVICE, //@hide: SOUND_TRIGGER_SERVICE, SHORTCUT_SERVICE, //@hide: CONTEXTHUB_SERVICE, SYSTEM_HEALTH_SERVICE, //@hide: INCIDENT_SERVICE, //@hide: INCIDENT_COMPANION_SERVICE, //@hide: STATS_COMPANION_SERVICE, COMPANION_DEVICE_SERVICE, CROSS_PROFILE_APPS_SERVICE, //@hide: SYSTEM_UPDATE_SERVICE, //@hide: TIME_DETECTOR_SERVICE, //@hide: TIME_ZONE_DETECTOR_SERVICE, PERMISSION_SERVICE, LIGHTS_SERVICE, //@hide: PEOPLE_SERVICE, //@hide: DEVICE_STATE_SERVICE, //@hide: SPEECH_RECOGNITION_SERVICE, UWB_SERVICE, MEDIA_METRICS_SERVICE,})@Retention(RetentionPolicy.SOURCE)public @interface ServiceName {} 1234567891011/** @hide */@IntDef(flag = true, prefix = { &quot;CONTEXT_&quot; }, value = { CONTEXT_INCLUDE_CODE, CONTEXT_IGNORE_SECURITY, CONTEXT_RESTRICTED, CONTEXT_DEVICE_PROTECTED_STORAGE, CONTEXT_CREDENTIAL_PROTECTED_STORAGE, CONTEXT_REGISTER_PACKAGE,})@Retention(RetentionPolicy.SOURCE)public @interface CreatePackageOptions {} 常量定义文件创建、SP、数据库共享的的flags 1234567891011// 默认值，只能对当前app(相同user-id的进程)可见public static final int MODE_PRIVATE = 0x0000;// 允许其他app读，已弃用，强制使用会抛出SecurityException@Deprecatedpublic static final int MODE_WORLD_READABLE = 0x0001;// 允许其他app写，已弃用，强制使用会抛出SecurityException@Deprecatedpublic static final int MODE_WORLD_WRITEABLE = 0x0002; 文件创建的flag 12// append，而不是覆盖public static final int MODE_APPEND = 0x8000; SP加载的flag 12345// 不建议使用，没有进程同步的机制// 为了一个app有多个进程时使用// 跨进程数据管理方法可以用ContentProvider@Deprecatedpublic static final int MODE_MULTI_PROCESS = 0x0004; 数据库的flag 12345678910111213// write-ahead logging, WAL/** * According To: https://www.w3cschool.cn/doc_postgresql_9_4/postgresql_9_4-wal-intro.html * Briefly, WAL's central concept is that changes to data files (where tables and indexes reside) * must be written only after those changes have been logged, * that is, after log records describing the changes have been flushed to permanent storage.*/// 在对数据进行写操作前，对写操作的log要先写入到持久化存储设备// 启用WALpublic static final int MODE_ENABLE_WRITE_AHEAD_LOGGING = 0x0008;// 启用本地化的操作public static final int MODE_NO_LOCALIZED_COLLATORS = 0x0010; bindService的flags 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248/** * &lt;p&gt;Note that prior to {@link android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH}, * not supplying this flag would also impact how important the system * consider's the target service's process to be. When set, the only way * for it to be raised was by binding from a service in which case it will * only be important when that activity is in the foreground. Now to * achieve this behavior you must explicitly supply the new flag * {@link #BIND_ADJUST_WITH_ACTIVITY}. For compatibility, old applications * that don't specify {@link #BIND_AUTO_CREATE} will automatically have * the flags {@link #BIND_WAIVE_PRIORITY} and * {@link #BIND_ADJUST_WITH_ACTIVITY} set for them in order to achieve * the same result. */// 自动创建servicepublic static final int BIND_AUTO_CREATE = 0x0001;// debug，打印调用栈public static final int BIND_DEBUG_UNBIND = 0x0002;// 不允许将service进程提升到前台，绑定时在前台而目标为后台时有效public static final int BIND_NOT_FOREGROUND = 0x0004;// Service的重要程度高于客户端，OOM时有限杀掉app而不是servicepublic static final int BIND_ABOVE_CLIENT = 0x0008;/** * Flag for {@link #bindService}: allow the process hosting the bound * service to go through its normal memory management. It will be * treated more like a running service, allowing the system to * (temporarily) expunge the process if low on memory or for some other * whim it may have, and being more aggressive about making it a candidate * to be killed (and restarted) if running for a long time. */public static final int BIND_ALLOW_OOM_MANAGEMENT = 0x0010;/** * Flag for {@link #bindService}: don't impact the scheduling or * memory management priority of the target service's hosting process. * Allows the service's process to be managed on the background LRU list * just like a regular application process in the background. */public static final int BIND_WAIVE_PRIORITY = 0x0020;/** * Flag for {@link #bindService}: this service is very important to * the client, so should be brought to the foreground process level * when the client is. Normally a process can only be raised to the * visibility level by a client, even if that client is in the foreground. */public static final int BIND_IMPORTANT = 0x0040;/** * Flag for {@link #bindService}: If binding from an activity, allow the * target service's process importance to be raised based on whether the * activity is visible to the user, regardless whether another flag is * used to reduce the amount that the client process's overall importance * is used to impact it. */public static final int BIND_ADJUST_WITH_ACTIVITY = 0x0080;/** * Flag for {@link #bindService}: If binding from an app that is visible or user-perceptible, * lower the target service's importance to below the perceptible level. This allows * the system to (temporarily) expunge the bound process from memory to make room for more * important user-perceptible processes. */public static final int BIND_NOT_PERCEPTIBLE = 0x00000100;/** * Flag for {@link #bindService}: If binding from an app that has specific capabilities * due to its foreground state such as an activity or foreground service, then this flag will * allow the bound app to get the same capabilities, as long as it has the required permissions * as well. * * If binding from a top app and its target SDK version is at or above * {@link android.os.Build.VERSION_CODES#R}, the app needs to * explicitly use BIND_INCLUDE_CAPABILITIES flag to pass all capabilities to the service so the * other app can have while-use-use access such as location, camera, microphone from background. * If binding from a top app and its target SDK version is below * {@link android.os.Build.VERSION_CODES#R}, BIND_INCLUDE_CAPABILITIES is implicit. */public static final int BIND_INCLUDE_CAPABILITIES = 0x000001000;/*********** Public flags above this line ***********//*********** Hidden flags below this line ***********//** * Flag for {@link #bindService}: This flag is only intended to be used by the system to * indicate that a service binding is not considered as real package component usage and should * not generate a {@link android.app.usage.UsageEvents.Event#APP_COMPONENT_USED} event in usage * stats. * @hide */public static final int BIND_NOT_APP_COMPONENT_USAGE = 0x00008000;/** * Flag for {@link #bindService}: allow the process hosting the target service to be treated * as if it's as important as a perceptible app to the user and avoid the oom killer killing * this process in low memory situations until there aren't any other processes left but the * ones which are user-perceptible. * * @hide */public static final int BIND_ALMOST_PERCEPTIBLE = 0x000010000;/** * Flag for {@link #bindService}: allow the process hosting the target service to gain * {@link ActivityManager#PROCESS_CAPABILITY_NETWORK}, which allows it be able * to access network regardless of any power saving restrictions. * * @hide */public static final int BIND_BYPASS_POWER_NETWORK_RESTRICTIONS = 0x00020000;/** * Do not use. This flag is no longer needed nor used. * @hide */@SystemApipublic static final int BIND_ALLOW_FOREGROUND_SERVICE_STARTS_FROM_BACKGROUND = 0x00040000;/** * Flag for {@link #bindService}: This flag is intended to be used only by the system to adjust * the scheduling policy for IMEs (and any other out-of-process user-visible components that * work closely with the top app) so that UI hosted in such services can have the same * scheduling policy (e.g. SCHED_FIFO when it is enabled and TOP_APP_PRIORITY_BOOST otherwise) * as the actual top-app. * @hide */public static final int BIND_SCHEDULE_LIKE_TOP_APP = 0x00080000;/** * Flag for {@link #bindService}: allow background activity starts from the bound service's * process. * This flag is only respected if the caller is holding * {@link android.Manifest.permission#START_ACTIVITIES_FROM_BACKGROUND}. * @hide */@SystemApipublic static final int BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS = 0x00100000;/** * @hide Flag for {@link #bindService}: the service being bound to represents a * protected system component, so must have association restrictions applied to it. * That is, a system config must have one or more allow-association tags limiting * which packages it can interact with. If it does not have any such association * restrictions, a default empty set will be created. */public static final int BIND_RESTRICT_ASSOCIATIONS = 0x00200000;/** * @hide Flag for {@link #bindService}: allows binding to a service provided * by an instant app. Note that the caller may not have access to the instant * app providing the service which is a violation of the instant app sandbox. * This flag is intended ONLY for development/testing and should be used with * great care. Only the system is allowed to use this flag. */public static final int BIND_ALLOW_INSTANT = 0x00400000;/** * @hide Flag for {@link #bindService}: like {@link #BIND_NOT_FOREGROUND}, but puts it * up in to the important background state (instead of transient). */public static final int BIND_IMPORTANT_BACKGROUND = 0x00800000;/** * @hide Flag for {@link #bindService}: allows application hosting service to manage whitelists * such as temporary allowing a {@code PendingIntent} to bypass Power Save mode. */public static final int BIND_ALLOW_WHITELIST_MANAGEMENT = 0x01000000;/** * @hide Flag for {@link #bindService}: Like {@link #BIND_FOREGROUND_SERVICE}, * but only applies while the device is awake. */public static final int BIND_FOREGROUND_SERVICE_WHILE_AWAKE = 0x02000000;/** * @hide Flag for {@link #bindService}: For only the case where the binding * is coming from the system, set the process state to FOREGROUND_SERVICE * instead of the normal maximum of IMPORTANT_FOREGROUND. That is, this is * saying that the process shouldn't participate in the normal power reduction * modes (removing network access etc). */public static final int BIND_FOREGROUND_SERVICE = 0x04000000;/** * @hide Flag for {@link #bindService}: Treat the binding as hosting * an activity, an unbinding as the activity going in the background. * That is, when unbinding, the process when empty will go on the activity * LRU list instead of the regular one, keeping it around more aggressively * than it otherwise would be. This is intended for use with IMEs to try * to keep IME processes around for faster keyboard switching. */public static final int BIND_TREAT_LIKE_ACTIVITY = 0x08000000;/** * @hide An idea that is not yet implemented. * Flag for {@link #bindService}: If binding from an activity, consider * this service to be visible like the binding activity is. That is, * it will be treated as something more important to keep around than * invisible background activities. This will impact the number of * recent activities the user can switch between without having them * restart. There is no guarantee this will be respected, as the system * tries to balance such requests from one app vs. the importance of * keeping other apps around. */public static final int BIND_VISIBLE = 0x10000000;/** * @hide * Flag for {@link #bindService}: Consider this binding to be causing the target * process to be showing UI, so it will be do a UI_HIDDEN memory trim when it goes * away. */public static final int BIND_SHOWING_UI = 0x20000000;/** * Flag for {@link #bindService}: Don't consider the bound service to be * visible, even if the caller is visible. * @hide */public static final int BIND_NOT_VISIBLE = 0x40000000;/** * Flag for {@link #bindService}: The service being bound is an * {@link android.R.attr#isolatedProcess isolated}, * {@link android.R.attr#externalService external} service. This binds the service into the * calling application's package, rather than the package in which the service is declared. * &lt;p&gt; * When using this flag, the code for the service being bound will execute under the calling * application's package name and user ID. Because the service must be an isolated process, * it will not have direct access to the application's data, though. * * The purpose of this flag is to allow applications to provide services that are attributed * to the app using the service, rather than the application providing the service. * &lt;/p&gt; */public static final int BIND_EXTERNAL_SERVICE = 0x80000000;/** * These bind flags reduce the strength of the binding such that we shouldn't * consider it as pulling the process up to the level of the one that is bound to it. * @hide */public static final int BIND_REDUCTION_FLAGS = Context.BIND_ALLOW_OOM_MANAGEMENT | Context.BIND_WAIVE_PRIORITY | Context.BIND_NOT_PERCEPTIBLE | Context.BIND_NOT_VISIBLE; registerReceiver的flags 12345/** * Flag for {@link #registerReceiver}: The receiver can receive broadcasts from Instant Apps. */// 是否可以被Instant Apps接收到（google的小程序吧）public static final int RECEIVER_VISIBLE_TO_INSTANT_APPS = 0x1; getService的serviceName 1 方法部分get方法1234567891011121314151617181920212223public abstract AssetManager getAssets();public abstract Resources getResources();public abstract PackageManager getPackageManager();public abstract ContentResolver getContentResolver();public abstract Looper getMainLooper();public abstract Context getApplicationContext();public Executor getMainExecutor() { // This is pretty inefficient, which is why ContextImpl overrides it return new HandlerExecutor(new Handler(getMainLooper()));}public abstract ClassLoader getClassLoader();public abstract String getPackageName();public abstract String getBasePackageName();@NonNullpublic String getOpPackageName() { throw new RuntimeException(&quot;Not implemented. Must override in a subclass.&quot;);}public abstract ApplicationInfo getApplicationInfo();public abstract String getPackageResourcePath();// 返回应用包的完整路径public abstract String getPackageCodePath(); systemService123456public abstract @Nullable String getSystemServiceName(@NonNull Class&lt;?&gt; serviceClass);public abstract @Nullable Object getSystemService(@ServiceName @NonNull String name);public final @Nullable &lt;T&gt; T getSystemService(@NonNull Class&lt;T&gt; serviceClass) { // 也可以通过Class对象获取 String serviceName = getSystemServiceName(serviceClass); return serviceName != null ? (T)getSystemService(serviceName) : null;} View相关123456789// 返回进程中唯一的View IDpublic int getNextAutofillId() { if (sLastAutofillId == View.LAST_APP_AUTOFILL_ID - 1) { sLastAutofillId = View.NO_ID; } sLastAutofillId++; return sLastAutofillId;}// 会有并发问题吗？？ ComponentCallbacks123456789public void registerComponentCallbacks(ComponentCallbacks callback) { getApplicationContext().registerComponentCallbacks(callback);}public void unregisterComponentCallbacks(ComponentCallbacks callback) { getApplicationContext().unregisterComponentCallbacks(callback);}// Callback包括:// onConfigurationChanged// onLowMemory: 调用时机没有明确定义，一般在内存不足，所有后台进程被kill之后，processes hosting service和前台用户界面被kill之前。 资源相关1234567891011121314151617181920212223242526272829@NonNullpublic final CharSequence getText(@StringRes int resId) { return getResources().getText(resId);}@NonNullpublic final String getString(@StringRes int resId) { return getResources().getString(resId);}@NonNullpublic final String getString(@StringRes int resId, Object... formatArgs) { return getResources().getString(resId, formatArgs);}@ColorIntpublic final int getColor(@ColorRes int id) { return getResources().getColor(id, getTheme());}@Nullablepublic final Drawable getDrawable(@DrawableRes int id) { return getResources().getDrawable(id, getTheme());}@NonNullpublic final ColorStateList getColorStateList(@ColorRes int id) { return getResources().getColorStateList(id, getTheme());} 主题相关123456789101112131415161718192021222324252627282930313233343536public abstract void setTheme(@StyleRes int resid);/** @hide Needed for some internal implementation... not public because * you can't assume this actually means anything. */@UnsupportedAppUsagepublic int getThemeResId() { return 0;}@ViewDebug.ExportedProperty(deepExport = true)public abstract Resources.Theme getTheme();@NonNullpublic final TypedArray obtainStyledAttributes(@NonNull @StyleableRes int[] attrs) { return getTheme().obtainStyledAttributes(attrs);}@NonNullpublic final TypedArray obtainStyledAttributes(@StyleRes int resid, @NonNull @StyleableRes int[] attrs) throws Resources.NotFoundException { return getTheme().obtainStyledAttributes(resid, attrs);}@NonNullpublic final TypedArray obtainStyledAttributes( @Nullable AttributeSet set, @NonNull @StyleableRes int[] attrs) { return getTheme().obtainStyledAttributes(set, attrs, 0, 0);}@NonNullpublic final TypedArray obtainStyledAttributes(@Nullable AttributeSet set, @NonNull @StyleableRes int[] attrs, @AttrRes int defStyleAttr, @StyleRes int defStyleRes) { return getTheme().obtainStyledAttributes( set, attrs, defStyleAttr, defStyleRes);} SP12345public abstract SharedPreferences getSharedPreferences(String name, @PreferencesMode int mode);@SuppressWarnings(&quot;HiddenAbstractMethod&quot;)public abstract SharedPreferences getSharedPreferences(File file, @PreferencesMode int mode);public abstract boolean moveSharedPreferencesFrom(Context sourceContext, String name); // 将一个context中的sp移动到当前context中public abstract boolean deleteSharedPreferences(String name); 文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// 打开私有文件的流public abstract FileInputStream openFileInput(String name) throws FileNotFoundException;// 读写该文件不需要额外的权限public abstract FileOutputStream openFileOutput(String name, @FileMode int mode) throws FileNotFoundException;// 返回，是否成功删除public abstract boolean deleteFile(String name);// 返回文件的绝对路径（通过openFileOutput创建的）public abstract File getFileStreamPath(String name);// 返回sp的路径@SuppressWarnings(&quot;HiddenAbstractMethod&quot;)public abstract File getSharedPreferencesPath(String name);// 返回app私有文件的存储位置public abstract File getDataDir();// 返回openFileOutput创建文件的目录// 卸载后会删除public abstract File getFilesDir();@NonNull@TestApipublic File getCrateDir(@NonNull String crateId) { throw new RuntimeException(&quot;Not implemented. Must override in a subclass.&quot;);}// 返回目录，该目录下的文件不会被备份public abstract File getNoBackupFilesDir();// 返回共享存储目录// 每个用户都有独立的共享存储目录// 应用卸载后也会删除，属于该app// android.os.Environment#getExternalStoragePublicDirectory 提供的目录是所有app共享的，// 其他应用如果有权限WRITE_EXTERNAL_STORAGE，也可以对文件进行读写// MediaScanner// These files are internal to the application, and not typically visible to the user as media.// 参数是目录类型，android.os.Environment#DIRECTORY_XXX// 返回的目录会被自动创建// 不要使用绝对路径，文件所在位置可能会改变@Nullablepublic abstract File getExternalFilesDir(@Nullable String type);// 类似于getExternalFilesDir，返回所有shared/external storage devices的绝对路径public abstract File[] getExternalFilesDirs(String type);// 安卓N之前，需要权限READ_EXTERNAL_STORAGE// 返回OBB文件的位置，如果没有OBB，返回目录可能不存在// OBB: 安卓游戏通用数据包public abstract File getObbDir();public abstract File[] getObbDirs();// 返回缓存目录// 系统会在需要时删除该目录下的文件// 通过StorageManager#getCacheQuotaBytes可以获取cache的配额（可能随时间变化），如果超过配额，可能会被优先删除// 通过StorageManager#setCacheBehaviorGroup StorageManager#setCacheBehaviorTombstone可以设置缓存的删除策略// 读写不需要权限public abstract File getCacheDir();// 返回代码缓存目录// 应用升级，平台升级会删除// 存储编译的或生成的优化的代码public abstract File getCodeCacheDir();/** * If a shared storage device is emulated (as determined by * {@link Environment#isExternalStorageEmulated(File)}), its contents are * backed by a private user data partition, which means there is little * benefit to storing data here instead of the private directory returned by * {@link #getCacheDir()}. */// 卸载后删除// 不会被自动删除，除非系统在JELLY_BEAN_MR1及以后，且Environment#isExternalStorageEmulated(File)返回true@Nullablepublic abstract File getExternalCacheDir();/** * Returns absolute path to application-specific directory in the preloaded cache. * &lt;p&gt;Files stored in the cache directory can be deleted when the device runs low on storage. * There is no guarantee when these files will be deleted. * @hide */@SuppressWarnings(&quot;HiddenAbstractMethod&quot;)@Nullable@SystemApipublic abstract File getPreloadsFileCache();public abstract File[] getExternalCacheDirs();// 存储媒体文件的位置，会自动被扫描，令其他app可见// 弃用：从安卓Q开始，可以直接通过MediaStore插入内容，不需要权限// 卸载后会被删除@Deprecatedpublic abstract File[] getExternalMediaDirs();// 返回app中该Context对应的所有私有文件的名字public abstract String[] fileList();// 寻找/创建一个新的私有文件目录public abstract File getDir(String name, @FileMode int mode);","link":"/home/2024/07/01/Android%E9%AB%98%E7%BA%A7/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E5%9F%BA%E7%A1%8001-Context/"},{"title":"22-Gradle","text":"核心概念 项目 Gradle项目是一个可以构建的软件，例如应用程序或库。 包括一个根项目和任意数量的子项目。 构建脚本 构建脚本向 Gradle 详细介绍了构建项目所需采取的步骤。 每个项目可以包含一个或多个构建脚本。 依赖管理 依赖管理是一种用于声明和解析项目所需的外部资源的自动化技术。 每个项目通常都包含许多外部依赖项，Gradle 将在构建过程中解决这些依赖项。 任务 任务是基本的工作单元，例如编译代码或运行测试。 每个项目都包含在构建脚本或插件中定义的一个或多个任务。 插件 插件用于扩展 Gradle 的功能，并可选择向项目贡献任务。 Gradle 项目结构 文件/目录名称 作用 gradlew/gradlew.bat Gradle 包装脚本 build.gradle(.kts) 项目的 Gradle 构建脚本 settings.gradle(.kts) Gradle 设置文件用于定义根项目名称和子项目 src 项目/子项目的源码、资源 使用gradle/gradlew编译 编译 1./gradlew build 编译单个任务 12./gradlew :taskname./gradlew taskname 编译单个任务以及全部依赖 编译多项目工程中的任务 12./gradlew :subproject:taskName./gradlew subproject:taskName :相当于分隔符，第一个冒号可以省略 清理产物 1./gradlew clean 执行多个任务 1./gradlew clean build settings.gradle 单工程: optional 多工程: mandatory 要声明所有子工程 123456rootProject.name = 'root-project' // 定义工程名include('sub-project-a') include('sub-project-b')include('sub-project-c')// 声明子工程 Settings对象Settings对象的属性 buildCache: 编译缓存配置 plugins: 应用该设置的插件 rootDir: 编译的根目录, 根项目的目录 rootProject: 根项目 settings: 当前Settings对象 Settings对象的方法 include(): 定义自项目 includeBuild(): 看不懂","link":"/home/2024/04/23/Android%E9%AB%98%E7%BA%A7/Android%20%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/22Gradle/"},{"title":"21-RxJava","text":"Singlestatic &lt;T&gt; Single.just(T t) 生成一个Singled对象 return onAssembly(new SingleJust(t)) onAssembly是一个钩子函数，一般情况下不做任何操作，就是调用一个Function&lt;T, R&gt;.apply() Observer 有后续的onNext 有周期的Observer.interval()每隔一段时间onNext一次 Disposable 任务丢弃（只会丢弃未开始的，正在进行的任务不会丢弃） 线程切换 subscribOn(schedualer): 通过schedualer创建一个有上游的observable，在上级通过observer返回观察结果时切换线程 observeOn(schedualer): 通过schedualer创建一个有上游的observable，在subscribe时切换线程，并执行上游的subscribe 设计模式 观察者模式 Rxjava、kotlin的 observer代理 LiveData，TextWatcher 各种listener 工厂模式 ThreadFactory，OkHttp的RequestFactory Builder OkHttp，Retrofit 单例模式 Handler的mainLooper Application Toast LayoutInflator SharedPrefrence ActivityManager 适配器模式 各种Adator： ArrayAdaptor，BaseAdaptor，RecyclerView.Adaptor Okhttp的CallAdapter 代理模式 Android提供的各种Service 动态代理：Retrofit ContentResolver，ContentProvider","link":"/home/2024/03/10/Android%E9%AB%98%E7%BA%A7/Android%20%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/21RxJava/"},{"title":"基础05-Navigation","text":"简介NavController是中央导航 API。它会跟踪用户访问过的目的地，并允许用户在目的地之间移动。 获取NavController fragment 如果是NavHostFragment 1val navController = this.navController 如果是普通Fragment 1val navController = this.findNavController() compose 1val navController = rememberNavController() NavHostFragment实现了NavHost接口，可以直接获取NavController。 view 12val navController = view.findNavController()// 这个view必须在一个NavHost之中 activity 先获取Activity中的NavHostFragment，再获取NavController。 123val navHostFragment = supportFragmentManager.findFragmentById(R.id.nav_host_fragment) as NavHostFragmentval navController = navHostFragment.navController 使用Activity的扩展函数findNavController，可以获取NavController。 12val navController = activity.findNavController(R.id.view_within_navhost)// R.id.view_within_navhost这个view必须在一个NavHost之中 Fragment.findNavController12public fun Fragment.findNavController(): NavController = NavHostFragment.findNavController(this) 12345678910111213141516171819202122232425262728@JvmStaticpublic fun findNavController(fragment: Fragment): NavController { var findFragment: Fragment? = fragment while (findFragment != null) { if (findFragment is NavHostFragment) { return findFragment.navHostController } val primaryNavFragment = findFragment.parentFragmentManager .primaryNavigationFragment if (primaryNavFragment is NavHostFragment) { return primaryNavFragment.navHostController } findFragment = findFragment.parentFragment } // Try looking for one associated with the view instead, if applicable val view = fragment.view if (view != null) { return Navigation.findNavController(view) } // For DialogFragments, look at the dialog's decor view val dialogDecorView = (fragment as? DialogFragment)?.dialog?.window?.decorView if (dialogDecorView != null) { return Navigation.findNavController(dialogDecorView) } throw IllegalStateException(&quot;Fragment $fragment does not have a NavController set&quot;)} 从当前fragment开始寻找 如果有NavHostFragment，就返回他的NavController 如果没有，就找parentFragmentManager的primaryNavigationFragment 如果是NavHostFragment，就返回他的NavController 如果不是，就把当前fragment设置为parentFragment，重复上面过程，直到找到一个NavHostFragment或没有parentFragment为止 如果当前fragment及父fragment中找不到NavHostFragment，就尝试从当前fragment的view中寻找 如果还是找不到，尝试判断当前fragment是否为DialogFragment，如果是，则从DialogFragment的decorView中查找 如果还是找不到，就抛出异常 View.findNavController12public fun View.findNavController(): NavController = Navigation.findNavController(this) Activity.findNavController123public fun Activity.findNavController( @IdRes viewId: Int): NavController = Navigation.findNavController(this, viewId) 12345678@JvmStaticpublic fun findNavController(activity: Activity, @IdRes viewId: Int): NavController { val view = ActivityCompat.requireViewById&lt;View&gt;(activity, viewId) return findViewNavController(view) ?: throw IllegalStateException( &quot;Activity $activity does not have a NavController set on $viewId&quot; )} Activity就是比View多了一步findViewById findViewNavController(view: View)123456private fun findViewNavController(view: View): NavController? = generateSequence(view) { it.parent as? View? }.mapNotNull { getViewNavController(it) }.firstOrNull() 其实就是从当前view开始，一直找到根view，如果过程中有NavController，就返回 其中一个设置nav_controller_view_tag的地方可以看NavHostFragment#onviewcreated 1234567891011@Suppress(&quot;UNCHECKED_CAST&quot;)private fun getViewNavController(view: View): NavController? { val tag = view.getTag(R.id.nav_controller_view_tag) var controller: NavController? = null if (tag is WeakReference&lt;*&gt;) { controller = (tag as WeakReference&lt;NavController&gt;).get() } else if (tag is NavController) { controller = tag } return controller} 123456@kotlin.internal.LowPriorityInOverloadResolutionpublic fun &lt;T : Any&gt; generateSequence(seed: T?, nextFunction: (T) -&gt; T?): Sequence&lt;T&gt; = if (seed == null) EmptySequence else GeneratorSequence({ seed }, nextFunction) 导航图使用kotlin DSL12345public inline fun NavController.createGraph( startDestination: String, route: String? = null, builder: NavGraphBuilder.() -&gt; Unit): NavGraph = navigatorProvider.navigation(startDestination, route, builder) xml首先，创建一个 NavHostFragment。它充当包含实际导航图的导航宿主。 NavHostFragment 的最小实现： 12345678910111213&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;androidx.fragment.app.FragmentContainerView android:id=&quot;@+id/nav_host_fragment&quot; android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:navGraph=&quot;@navigation/nav_graph&quot; /&gt;&lt;/FrameLayout&gt; NavHostFragment 包含 app:navGraph 属性。使用此属性可将导航图连接到导航宿主。以下示例展示了如何实现该图： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;navigation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/nav_graph&quot; app:startDestination=&quot;@id/profile&quot;&gt; &lt;!-- Action back to destination which launched into this profile --&gt; &lt;action android:id=&quot;@+id/action_global_profile&quot; app:popUpTo=&quot;@id/profile&quot; app:popUpToInclusive=&quot;true&quot; /&gt; &lt;fragment android:id=&quot;@+id/profile&quot; android:name=&quot;com.example.ProfileFragment&quot; android:label=&quot;Profile&quot;&gt; &lt;!-- Action to navigate from Profile to Friends List. --&gt; &lt;action android:id=&quot;@+id/action_profile_to_friendslist&quot; app:destination=&quot;@id/friendslist&quot; /&gt; &lt;/fragment&gt; &lt;fragment android:id=&quot;@+id/friendslist&quot; android:name=&quot;com.example.FriendsListFragment&quot; android:label=&quot;Friends List&quot;&gt; &lt;!-- 深层链接 --&gt; &lt;!-- https://developer.android.com/guide/navigation/design/deep-link?hl=zh-cn --&gt; &lt;deepLink app:uri=&quot;www.example.com&quot; app:action=&quot;android.intent.action.MY_ACTION&quot; app:mimeType=&quot;type/subtype&quot;/&gt; &lt;/fragment&gt; &lt;!-- Add other fragment destinations similarly. --&gt; &lt;!-- 对话框目的地 --&gt; &lt;dialog android:id=&quot;@+id/my_dialog_fragment&quot; android:name=&quot;androidx.navigation.myapp.MyDialogFragment&quot;&gt; &lt;argument android:name=&quot;myarg&quot; android:defaultValue=&quot;@null&quot; /&gt; &lt;action android:id=&quot;@+id/myaction&quot; app:destination=&quot;@+id/another_destination&quot;/&gt; &lt;/dialog&gt; &lt;!-- Activity目的地 --&gt; &lt;activity android:id=&quot;@+id/sampleActivityDestination&quot; android:name=&quot;com.example.android.navigation.activity.DestinationActivity&quot; android:label=&quot;@string/sampleActivityTitle&quot; /&gt; &lt;!-- 嵌套图 --&gt; &lt;!-- 应用中的登录流程、向导或其他子流程通常是嵌套导航图的最佳表示形式。通过以这种方式嵌套独立的子导航流程，您可以更轻松地理解和管理应用界面的主流程。 --&gt; &lt;navigation android:id=&quot;@+id/sendMoneyGraph&quot; app:startDestination=&quot;@id/chooseRecipient&quot;&gt; &lt;fragment android:id=&quot;@+id/chooseRecipient&quot; android:name=&quot;com.example.cashdog.cashdog.ChooseRecipient&quot; android:label=&quot;fragment_choose_recipient&quot; tools:layout=&quot;@layout/fragment_choose_recipient&quot;&gt; &lt;action android:id=&quot;@+id/action_chooseRecipient_to_chooseAmountFragment&quot; app:destination=&quot;@id/chooseAmountFragment&quot; /&gt; &lt;/fragment&gt; &lt;fragment android:id=&quot;@+id/chooseAmountFragment&quot; android:name=&quot;com.example.cashdog.cashdog.ChooseAmountFragment&quot; android:label=&quot;fragment_choose_amount&quot; tools:layout=&quot;@layout/fragment_choose_amount&quot; /&gt; &lt;/navigation&gt;&lt;/navigation&gt; NavHostFragment123public open class NavHostFragment : Fragment(), NavHost { // ...} 实现了navHost接口，也就是有了一个navHostController属性 navHostController1234567891011121314151617181920212223242526272829303132333435363738394041final override val navController: NavController get() = navHostControllerinternal val navHostController: NavHostController by lazy { // 1: lazy val context = checkNotNull(context) { // 2: 获取context并判空 &quot;NavController cannot be created before the fragment is attached&quot; } NavHostController(context).apply { // 3: 生成实例 setLifecycleOwner(this@NavHostFragment) // 4: 传递fragment为lifecycleOwner setViewModelStore(viewModelStore) // 5: 传递fragment的viewModelStore onCreateNavHostController(this) // 6: 回调通知fragment savedStateRegistry.consumeRestoredStateForKey(KEY_NAV_CONTROLLER_STATE)?.let { restoreState(it) } savedStateRegistry.registerSavedStateProvider(KEY_NAV_CONTROLLER_STATE) { saveState() ?: Bundle.EMPTY } savedStateRegistry.consumeRestoredStateForKey(KEY_GRAPH_ID)?.let { bundle -&gt; graphId = bundle.getInt(KEY_GRAPH_ID) } savedStateRegistry.registerSavedStateProvider(KEY_GRAPH_ID) { if (graphId != 0) { bundleOf(KEY_GRAPH_ID to graphId) } else { Bundle.EMPTY } } // 7: savedState相关的看不懂，todo: 以后再看 if (graphId != 0) { // // 8: setGraph // Set from onInflate() setGraph(graphId) // 8.1: 导航图id不为0，有效，设置导航图 } else { // See if it was set by NavHostFragment.create() val args = arguments val graphId = args?.getInt(KEY_GRAPH_ID) ?: 0 val startDestinationArgs = args?.getBundle(KEY_START_DESTINATION_ARGS) if (graphId != 0) { // 8.2: 尝试从fragment的`arguments`获取导航图和startDestinationArgs setGraph(graphId, startDestinationArgs) } } }} 就是创建了一个navHostController,详细内容看NavHostController类 1: lazy这个没啥说的，就是懒加载 2: 获取context并判空 fragment的getContext 1234@Nullablepublic Context getContext() { return mHost == null ? null : mHost.getContext();} mHost会在FragmentStateManager调用moveToExpectedState时，如果移动到Fragment.ATTACHED状态，调用attach方法时，进行初始化 // todo: 再挖个坑以后学习 6: 回调通知fragment 这里调用的是NavHostFragment的方法12345@Suppress(&quot;DEPRECATION&quot;)@CallSuperprotected open fun onCreateNavHostController(navHostController: NavHostController) { onCreateNavController(navHostController)} 123456789101112131415161718192021222324/*** Callback for when the [NavController][getNavController] is created. If you* support any custom destination types, their [Navigator] should be added here to* ensure it is available before the navigation graph is inflated / set.** By default, this adds a [DialogFragmentNavigator] and [FragmentNavigator].** This is only called once when the navController is called. This will be called in [onCreate]* if the navController has not yet been called. This should not be called directly by* subclasses.** @param navController The newly created [NavController].*/@Suppress(&quot;DEPRECATION&quot;)@CallSuper@Deprecated( &quot;&quot;&quot;Override {@link #onCreateNavHostController(NavHostController)} to gain access to the full {@link NavHostController} that is created by this NavHostFragment.&quot;&quot;&quot;)protected open fun onCreateNavController(navController: NavController) { navController.navigatorProvider += DialogFragmentNavigator(requireContext(), childFragmentManager) navController.navigatorProvider.addNavigator(createFragmentNavigator())} 创建getNavController时的回调函数。如果您支持任何自定义目标类型，则应将其导航器添加到此处，以确保在导航图inflate/set之前可用。 默认情况下，这会添加一个DialogFragmentNavigator和FragmentNavigator。 它只在navController被调用时被调用一次。如果navController还没有被调用，这个函数会在onCreate中被调用。子类不应该直接调用这个方法。 翻译一下这个函数的注释 第一句是说子类可以重写这个方法，添加自定义的Navigator 第二句是说默认会添加DialogFragmentNavigator和FragmentNavigator 要理解第三句先看下面代码，navHostController时lazy，但是在Fragment#onCreate时会主动出发他的创建过程123456789101112131415161718@CallSuperpublic override fun onCreate(savedInstanceState: Bundle?) { // We are accessing the NavController here to ensure that it is always created by this point navHostController if (savedInstanceState != null) { if (savedInstanceState.getBoolean(KEY_DEFAULT_NAV_HOST, false)) { defaultNavHost = true parentFragmentManager.beginTransaction() .setPrimaryNavigationFragment(this) .commit() } } // We purposefully run this last as this will trigger the onCreate() of // child fragments, which may be relying on having the NavController already // created and having its state restored by that point. super.onCreate(savedInstanceState)} 7: savedState相关的看不懂，todo: 以后再看// todo: 占坑，以后再看 8: setGraph 导航图id不为0，有效，设置导航图 导航图id为0, 尝试从fragment的arguments获取导航图id和startDestinationArgs setArguments是父类Fragment的一个方法，mArguments就是一个Bundle 123456public void setArguments(@Nullable Bundle args) { if (mFragmentManager != null &amp;&amp; isStateSaved()) { throw new IllegalStateException(&quot;Fragment already added and state has been saved&quot;); } mArguments = args;} 创建NavHostFragment1234567891011121314151617181920212223@JvmOverloads@JvmStaticpublic fun create( @NavigationRes graphResId: Int, startDestinationArgs: Bundle? = null): NavHostFragment { var b: Bundle? = null if (graphResId != 0) { b = Bundle() b.putInt(KEY_GRAPH_ID, graphResId) } if (startDestinationArgs != null) { if (b == null) { b = Bundle() } b.putBundle(KEY_START_DESTINATION_ARGS, startDestinationArgs) } val result = NavHostFragment() if (b != null) { result.arguments = b } return result} 可以看到, KEY_GRAPH_ID和KEY_START_DESTINATION_ARGS 几个key的定义123456789101112131415public companion object { /** */ @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public const val KEY_GRAPH_ID: String = &quot;android-support-nav:fragment:graphId&quot; /** */ @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public const val KEY_START_DESTINATION_ARGS: String = &quot;android-support-nav:fragment:startDestinationArgs&quot; private const val KEY_NAV_CONTROLLER_STATE = &quot;android-support-nav:fragment:navControllerState&quot; private const val KEY_DEFAULT_NAV_HOST = &quot;android-support-nav:fragment:defaultHost&quot;} KEY_GRAPH_ID和KEY_START_DESTINATION_ARGS被限制在同组lib中使用，也就是不推荐我们自己手动通过这两个key来设置导航图id和args 1private var graphId = 0 graphId也是private的，也无法通过继承的方式修改他的值 onInflate12345678910111213141516171819202122232425@CallSuperpublic override fun onInflate( context: Context, attrs: AttributeSet, savedInstanceState: Bundle?) { super.onInflate(context, attrs, savedInstanceState) context.obtainStyledAttributes( attrs, androidx.navigation.R.styleable.NavHost ).use { navHost -&gt; val graphId = navHost.getResourceId( androidx.navigation.R.styleable.NavHost_navGraph, 0 ) if (graphId != 0) { this.graphId = graphId } } context.obtainStyledAttributes(attrs, R.styleable.NavHostFragment).use { array -&gt; val defaultHost = array.getBoolean(R.styleable.NavHostFragment_defaultNavHost, false) if (defaultHost) { defaultNavHost = true } }} 导航图和defaultNavHost可以在FragmentContainerView的xml中使用navGraph和defaultNavHost定义 onSaveInstanceState onSaveInstanceState时如果defaultNavHost是true会把这个状态存起来，onCreate时恢复1234567@CallSuperpublic override fun onSaveInstanceState(outState: Bundle) { super.onSaveInstanceState(outState) if (defaultNavHost) { outState.putBoolean(KEY_DEFAULT_NAV_HOST, true) }} onCreate123456789101112131415161718@CallSuperpublic override fun onCreate(savedInstanceState: Bundle?) { // We are accessing the NavController here to ensure that it is always created by this point navHostController if (savedInstanceState != null) { if (savedInstanceState.getBoolean(KEY_DEFAULT_NAV_HOST, false)) { defaultNavHost = true parentFragmentManager.beginTransaction() .setPrimaryNavigationFragment(this) .commit() } } // We purposefully run this last as this will trigger the onCreate() of // child fragments, which may be relying on having the NavController already // created and having its state restored by that point. super.onCreate(savedInstanceState)} onViewCreated 会给view设置navHostController12345678910111213public override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) check(view is ViewGroup) { &quot;created host view $view is not a ViewGroup&quot; } Navigation.setViewNavController(view, navHostController) // When added programmatically, we need to set the NavController on the parent - i.e., // the View that has the ID matching this NavHostFragment. if (view.getParent() != null) { viewParent = view.getParent() as View if (viewParent!!.id == id) { Navigation.setViewNavController(viewParent!!, navHostController) } }} 通过view的setTag设置1234@JvmStaticpublic fun setViewNavController(view: View, controller: NavController?) { view.setTag(R.id.nav_controller_view_tag, controller)} onDestroyView 非常对称的，在onDestroyView时，会把viewParent中的navHostController设置为null123456789public override fun onDestroyView() { super.onDestroyView() viewParent?.let { it -&gt; if (Navigation.findNavController(it) === navHostController) { Navigation.setViewNavController(it, null) } } viewParent = null} defaultNavHost如果在attach时发现是defaultNavHost，会提交一个setPrimaryNavigationFragment的transaction，追踪这个操作，他具体做了以下内容 12345678910111213141516void setPrimaryNavigationFragment(@Nullable Fragment f) { if (f != null &amp;&amp; (!f.equals(findActiveFragment(f.mWho)) || (f.mHost != null &amp;&amp; f.mFragmentManager != this))) { throw new IllegalArgumentException(&quot;Fragment &quot; + f + &quot; is not an active fragment of FragmentManager &quot; + this); } Fragment previousPrimaryNav = mPrimaryNav; mPrimaryNav = f; dispatchParentPrimaryNavigationFragmentChanged(previousPrimaryNav); dispatchParentPrimaryNavigationFragmentChanged(mPrimaryNav);}private void dispatchParentPrimaryNavigationFragmentChanged(@Nullable Fragment f) { if (f != null &amp;&amp; f.equals(findActiveFragment(f.mWho))) { f.performPrimaryNavigationFragmentChanged(); }} 找到前一个primaryNavigationFragment，和将要设置为defaultNav的fragment,调用其performPrimaryNavigationFragmentChanged操作12345678910void performPrimaryNavigationFragmentChanged() { boolean isPrimaryNavigationFragment = mFragmentManager.isPrimaryNavigation(this); // Only send out the callback / dispatch if the state has changed if (mIsPrimaryNavigationFragment == null || mIsPrimaryNavigationFragment != isPrimaryNavigationFragment) { mIsPrimaryNavigationFragment = isPrimaryNavigationFragment; onPrimaryNavigationFragmentChanged(isPrimaryNavigationFragment); mChildFragmentManager.dispatchPrimaryNavigationFragmentChanged(); }} 更新Fragment中的mIsPrimaryNavigationFragment这个flag，并且找到子fragment，也去更新其状态 调用钩子函数onPrimaryNavigationFragmentChanged 12public void onPrimaryNavigationFragmentChanged(boolean isPrimaryNavigationFragment) {} 他是一个空的方法，子类可以重写，NavHostFragment也没有实现它，看来是给程序员自由发挥的。 官方文档中创建 NavHostFragment 提到这个操作会&quot;允许您的 NavHost 截获对系统“返回”按钮的按下操作&quot;。上面的代码好像并没有体现出来。 NavHostController类 NavHostController继承自NavController，其中没有什么代码，其本身是open的，但它把父类的几个方法设置为final，包括： setLifecycleOwner setOnBackPressedDispatcher enableOnBackPressed setViewModelStore NavController3: 生成实例NavHostController构造函数 1234public open class NavHostController(context: Context) : NavController(context) { // ...} 123456789101112public open class NavController( /** @suppress */ @get:RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public val context: Context) { // ... init { _navigatorProvider.addNavigator(NavGraphNavigator(_navigatorProvider)) _navigatorProvider.addNavigator(ActivityNavigator(context)) } // ...} 传递context就是存起来以后会用 通过context创建ActivityNavigator 可以先剧透一下，Navigator就是一个具体实施跳转等操作的类 比如ActivityNavigator就会调用startActivity FragmentNavigator就会构造FragmentTransaction来跳转fragment 4: 传递fragment为lifecycleOwner123public final override fun setLifecycleOwner(owner: LifecycleOwner) { super.setLifecycleOwner(owner)} 123456789@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)public open fun setLifecycleOwner(owner: LifecycleOwner) { if (owner == lifecycleOwner) { return } lifecycleOwner?.lifecycle?.removeObserver(lifecycleObserver) lifecycleOwner = owner owner.lifecycle.addObserver(lifecycleObserver)} 去掉原来的owner，添加新的owner，并添加观察者12345678private val lifecycleObserver: LifecycleObserver = LifecycleEventObserver { _, event -&gt; hostLifecycleState = event.targetState if (_graph != null) { for (entry in backQueue) { entry.handleLifecycleEvent(event) } }} hostLifecycleState就是存对应的生命周期状态 _graph是一个NavGraph, 在setGraph中初始化 backQueue是存放NavBackStackEntry的双端队列 5: 传递fragment的viewModelStore123public final override fun setViewModelStore(viewModelStore: ViewModelStore) { super.setViewModelStore(viewModelStore)} 12345678@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)public open fun setViewModelStore(viewModelStore: ViewModelStore) { if (viewModel == NavControllerViewModel.getInstance(viewModelStore)) { return } check(backQueue.isEmpty()) { &quot;ViewModelStore should be set before setGraph call&quot; } viewModel = NavControllerViewModel.getInstance(viewModelStore)} 就是创建了一个viewModel，以后会用 8: setGraph 如果导航图id不为0，有效，设置导航图 123public open fun setGraph(@NavigationRes graphResId: Int) { setGraph(navInflater.inflate(graphResId), null)} 如果导航图为0，则尝试从fragment的arguments中获取导航图id和startDestinationArgs 12345@MainThread@CallSuperpublic open fun setGraph(@NavigationRes graphResId: Int, startDestinationArgs: Bundle?) { setGraph(navInflater.inflate(graphResId), startDestinationArgs)} 最终都调用了setGraph(graph: NavGraph, startDestinationArgs: Bundle?) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*** Sets the [navigation graph][NavGraph] to the specified graph.* Any current navigation graph data (including back stack) will be replaced.** The graph can be retrieved later via [graph].** @param graph graph to set* @see NavController.setGraph* @see NavController.graph*/@MainThread@CallSuperpublic open fun setGraph(graph: NavGraph, startDestinationArgs: Bundle?) { if (_graph != graph) { _graph?.let { previousGraph -&gt; // Clear all saved back stacks by iterating through a copy of the saved keys, // thus avoiding any concurrent modification exceptions val savedBackStackIds = ArrayList(backStackMap.keys) savedBackStackIds.forEach { id -&gt; clearBackStackInternal(id) } // Pop everything from the old graph off the back stack NavControllerInternal(previousGraph.id, true) } _graph = graph onGraphCreated(startDestinationArgs) } else { // first we update _graph with new instances from graph for (i in 0 until graph.nodes.size()) { val newDestination = graph.nodes.valueAt(i) val key = _graph!!.nodes.keyAt(i) _graph!!.nodes.replace(key, newDestination) } // then we update backstack with the new instances backQueue.forEach { entry -&gt; // we will trace this hierarchy in new graph to get new destination instance val hierarchy = entry.destination.hierarchy.toList().asReversed() val newDestination = hierarchy.fold(_graph!!) { newDest: NavDestination, oldDest: NavDestination -&gt; if (oldDest == _graph &amp;&amp; newDest == graph) { // if root graph, it is already the node that matches with oldDest newDest } else if (newDest is NavGraph) { // otherwise we walk down the hierarchy to the next child newDest.findNode(oldDest.id)!! } else { // final leaf node found newDest } } entry.destination = newDestination } }} 考虑了两种情况，setGraph前后_graph和graph是否相等 注意kt代码有运算符重载，实际上调用的是NavGraph的equals 12345678override fun equals(other: Any?): Boolean { if (this === other) return true if (other == null || other !is NavGraph) return false return super.equals(other) &amp;&amp; nodes.size == other.nodes.size &amp;&amp; startDestinationId == other.startDestinationId &amp;&amp; nodes.valueIterator().asSequence().all { it == other.nodes.get(it.id) }} navigate通过action的资源id跳转的123456789101112131415161718192021// id1: public open fun navigate(@IdRes resId: Int) { navigate(resId, null)}// id2: public open fun navigate(@IdRes resId: Int, args: Bundle?) { navigate(resId, args, null)}// id3: public open fun navigate(@IdRes resId: Int, args: Bundle?, navOptions: NavOptions?) { navigate(resId, args, navOptions, null)}// id4: public open fun navigate( @IdRes resId: Int, args: Bundle?, navOptions: NavOptions?, navigatorExtras: Navigator.Extras?) { // ...} 一个参数的调两个参数的，两个参数的调三个参数的四个参数的巨长但也不是核心的方法，还会调用核心的navigate方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// id4:public open fun navigate( @IdRes resId: Int, args: Bundle?, navOptions: NavOptions?, navigatorExtras: Navigator.Extras?) { var finalNavOptions = navOptions // 1: navOptions val currentNode = ( if (backQueue.isEmpty()) _graph else backQueue.last().destination ) ?: throw IllegalStateException( &quot;No current destination found. Ensure a navigation graph has been set for &quot; + &quot;NavController $this.&quot; ) @IdRes var destId = resId val navAction = currentNode.getAction(resId) var combinedArgs: Bundle? = null if (navAction != null) { if (finalNavOptions == null) { // 1.2: navOptions空的情况 finalNavOptions = navAction.navOptions } destId = navAction.destinationId // 3: destId val navActionArgs = navAction.defaultArguments if (navActionArgs != null) { combinedArgs = Bundle() combinedArgs.putAll(navActionArgs) } } if (args != null) { if (combinedArgs == null) { combinedArgs = Bundle() } combinedArgs.putAll(args) // 2: 合并args } if (destId == 0 &amp;&amp; finalNavOptions != null &amp;&amp; (finalNavOptions.popUpToId != -1 || finalNavOptions.popUpToRoute != null) ) { when { // 5: popUpTo finalNavOptions.popUpToRoute != null -&gt; NavController( finalNavOptions.popUpToRoute!!, finalNavOptions.isPopUpToInclusive() ) finalNavOptions.popUpToId != -1 -&gt; NavController( finalNavOptions.popUpToId, finalNavOptions.isPopUpToInclusive() ) } return } require(destId != 0) { &quot;Destination id == 0 can only be used in conjunction with a valid navOptions.popUpTo&quot; } val node = findDestination(destId) // 4: 找到destination的node if (node == null) { val dest = NavDestination.getDisplayName(context, destId) require(navAction == null) { &quot;Navigation destination $dest referenced from action &quot; + &quot;${NavDestination.getDisplayName(context, resId)} cannot be found from &quot; + &quot;the current destination $currentNode&quot; } throw IllegalArgumentException( &quot;Navigation action/destination $dest cannot be found from the current &quot; + &quot;destination $currentNode&quot; ) } navigate(node, combinedArgs, finalNavOptions, navigatorExtras) // 6:} 大概做了下面几件事 1: 如果调用navigate时 1.1: NavOptions参数不空，则忽略当前node的action中存储的NavOptions 1.2: 如果空，则使用当前node的action中存储的NavOptions 2: 将action的defaultArguments和参数中的args合并，并传递给核心的navigate 3: 从action中获取destinationId 4: 从当前图中找到destinationId对应的node 5: 弹出导航栈，直到遇到对应的route或id 6: 将node和合并的args, NavOptions, 还有navigatorExtras传递给核心的navigate方法 通过NavDirections跳转的123456789101112131415// NavDirections1:@MainThreadpublic open fun navigate(directions: NavDirections) { navigate(directions.actionId, directions.arguments, null)}// NavDirections2:@MainThreadpublic open fun navigate(directions: NavDirections, navOptions: NavOptions?) { navigate(directions.actionId, directions.arguments, navOptions)}// NavDirections3:@MainThreadpublic open fun navigate(directions: NavDirections, navigatorExtras: Navigator.Extras) { navigate(directions.actionId, directions.arguments, null, navigatorExtras)} 先看一下NavDirections是啥 12345public interface NavDirections { @get:IdRes public val actionId: Int public val arguments: Bundle} 其实就是把action-id和arguments包装了一下，最终也会调用id4 通过Uri类型的DeepLink跳转的12345678910111213141516171819// uri1:@MainThreadpublic open fun navigate(deepLink: Uri) { navigate(NavDeepLinkRequest(deepLink, null, null))}// uri2:@MainThreadpublic open fun navigate(deepLink: Uri, navOptions: NavOptions?) { navigate(NavDeepLinkRequest(deepLink, null, null), navOptions, null)}// uri3:@MainThreadpublic open fun navigate( deepLink: Uri, navOptions: NavOptions?, navigatorExtras: Navigator.Extras?) { navigate(NavDeepLinkRequest(deepLink, null, null), navOptions, navigatorExtras)} 他们都会构造NavDeepLinkRequest对象然后调用NavDeepLinkRequest3 通过route跳转的1234567891011121314// route1:public fun navigate(route: String, builder: NavOptionsBuilder.() -&gt; Unit) { navigate(route, navOptions(builder))}public fun navigate( route: String, navOptions: NavOptions? = null, navigatorExtras: Navigator.Extras? = null) { navigate( NavDeepLinkRequest.Builder.fromUri(createRoute(route).toUri()).build(), navOptions, navigatorExtras )} 通过route跳转的，最后也会变成deeplink 通过NavDeepLinkRequest跳转的12345678910111213141516171819// NavDeepLinkRequest1:@MainThreadpublic open fun navigate(request: NavDeepLinkRequest) { navigate(request, null)}// NavDeepLinkRequest2:@MainThreadpublic open fun navigate(request: NavDeepLinkRequest, navOptions: NavOptions?) { navigate(request, navOptions, null)}// NavDeepLinkRequest3:@MainThreadpublic open fun navigate( request: NavDeepLinkRequest, navOptions: NavOptions?, navigatorExtras: Navigator.Extras?) { // ...} 123456789101112131415161718192021222324252627public open fun navigate( request: NavDeepLinkRequest, navOptions: NavOptions?, navigatorExtras: Navigator.Extras?) { requireNotNull(_graph) { &quot;Cannot navigate to $request. Navigation graph has not been set for &quot; + &quot;NavController $this.&quot; } val deepLinkMatch = _graph!!.matchDeepLink(request) if (deepLinkMatch != null) { val destination = deepLinkMatch.destination val args = destination.addInDefaultArgs(deepLinkMatch.matchingArgs) ?: Bundle() val node = deepLinkMatch.destination val intent = Intent().apply { setDataAndType(request.uri, request.mimeType) action = request.action } args.putParcelable(KEY_DEEP_LINK_INTENT, intent) navigate(node, args, navOptions, navigatorExtras) } else { throw IllegalArgumentException( &quot;Navigation destination that matches request $request cannot be found in the &quot; + &quot;navigation graph $_graph&quot; ) }} 通过matchDeepLink方法找到match对象 如果没有match，抛出异常 如果有match，从match对象中取出destination，和id4方法一样，最终都会调用核心的navigate方法，同样需要找到核心navigate方法所需的几个参数 node: 从destination对象中获得 args: 从destination对象中获得 navOptions: 函数参数 navigatorExtras: 函数参数 调用核心的navigate方法 核心的navigate方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private fun navigate( node: NavDestination, args: Bundle?, navOptions: NavOptions?, navigatorExtras: Navigator.Extras?) { navigatorState.values.forEach { state -&gt; state.isNavigating = true } var popped = false var launchSingleTop = false var navigated = false if (navOptions != null) { when { // 1: 根据navOptions的不同情况，pop栈 navOptions.popUpToRoute != null -&gt; popped = NavControllerInternal( navOptions.popUpToRoute!!, navOptions.isPopUpToInclusive(), navOptions.shouldPopUpToSaveState() ) navOptions.popUpToId != -1 -&gt; popped = NavControllerInternal( navOptions.popUpToId, navOptions.isPopUpToInclusive(), navOptions.shouldPopUpToSaveState() ) } } val finalArgs = node.addInDefaultArgs(args) // Now determine what new destinations we need to add to the back stack if (navOptions?.shouldRestoreState() == true &amp;&amp; backStackMap.containsKey(node.id)) { navigated = restoreStateInternal(node.id, finalArgs, navOptions, navigatorExtras) // 2: 需要恢复状态，且backStackMap中存在对应的node的情况 } else { launchSingleTop = navOptions?.shouldLaunchSingleTop() == true &amp;&amp; launchSingleTopInternal(node, args) //3: singleTop的情况 if (!launchSingleTop) { // 不需要singleTop的情况 // Not a single top operation, so we're looking to add the node to the back stack val backStackEntry = NavBackStackEntry.create( context, node, finalArgs, hostLifecycleState, viewModel ) val navigator = _navigatorProvider.getNavigator&lt;Navigator&lt;NavDestination&gt;&gt;( node.navigatorName ) navigator.navigateInternal(listOf(backStackEntry), navOptions, navigatorExtras) { navigated = true addEntryToBackStack(node, finalArgs, it) } } } updateOnBackPressedCallbackEnabled() // 4: 看起来是设置一个flag navigatorState.values.forEach { state -&gt; state.isNavigating = false // 5: 又设置一个flag } if (popped || navigated || launchSingleTop) { dispatchOnDestinationChanged() // 6: 调用回调 } else { updateBackStackLifecycle() // 7: 更新导航栈的生命周期 }} 根据上面的注释，一共做了7件事 2: 需要恢复状态，且backStackMap中存在对应的node的情况12345678910111213141516171819public class NavOptions internal constructor( private val singleTop: Boolean, private val restoreState: Boolean, // ...) { public fun shouldRestoreState(): Boolean { return restoreState } // ... public class Builder { private var singleTop = false private var restoreState = false // ... public fun setRestoreState(restoreState: Boolean): Builder { this.restoreState = restoreState return this } }} shouldRestoreState返回的是restoreState，是在构造时确定的 1234567891011121314151617private fun restoreStateInternal( id: Int, args: Bundle?, navOptions: NavOptions?, navigatorExtras: Navigator.Extras?): Boolean { if (!backStackMap.containsKey(id)) { return false // 1: 首先是防止backStackMap中没有对应的node } val backStackId = backStackMap[id] // Clear out the state we're going to restore so that it isn't restored a second time backStackMap.values.removeAll { it == backStackId } // 2: 删除map中所有和backStackId相等的entry val backStackState = backStackStates.remove(backStackId) // 3: 删除backStackStates中对应的entry // Now restore the back stack from its saved state val entries = instantiateBackStack(backStackState) // 4: 更新backStackState中的NavBackStackEntryState return executeRestoreState(entries, args, navOptions, navigatorExtras) // 5: 找到Navigator，导航到对应位置} 3: 删除backStackStates中对应的entry看一下backStackStates的数据结构 1private val backStackStates = mutableMapOf&lt;String, ArrayDeque&lt;NavBackStackEntryState&gt;&gt;() 4: 更新backStackState中的12345678910111213141516171819private fun instantiateBackStack( backStackState: ArrayDeque&lt;NavBackStackEntryState&gt;?): List&lt;NavBackStackEntry&gt; { val backStack = mutableListOf&lt;NavBackStackEntry&gt;() var currentDestination = backQueue.lastOrNull()?.destination ?: graph backStackState?.forEach { state -&gt; val node = currentDestination.findDestination(state.destinationId) checkNotNull(node) { val dest = NavDestination.getDisplayName( context, state.destinationId ) &quot;Restore State failed: destination $dest cannot be found from the current &quot; + &quot;destination $currentDestination&quot; } backStack += state.instantiate(context, node, hostLifecycleState, viewModel) currentDestination = node } return backStack} 创建一个空的backStack，然后遍历backStackState 找到当前栈最后一个entry的destination 从currentDestination中找到state.destinationId对应的node 根据node重新创建state对象，添加到backStack中，返回该backStack 5: 找到Navigator，导航到对应位置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private fun executeRestoreState( entries: List&lt;NavBackStackEntry&gt;, args: Bundle?, navOptions: NavOptions?, navigatorExtras: Navigator.Extras?): Boolean { // Split up the entries by Navigator so we can restore them as an atomic operation val entriesGroupedByNavigator = mutableListOf&lt;MutableList&lt;NavBackStackEntry&gt;&gt;() entries.filterNot { entry -&gt; // Skip navigation graphs - they'll be added by addEntryToBackStack() entry.destination is NavGraph }.forEach { entry -&gt; val previousEntryList = entriesGroupedByNavigator.lastOrNull() val previousNavigatorName = previousEntryList?.last()?.destination?.navigatorName if (previousNavigatorName == entry.destination.navigatorName) { // Group back to back entries associated with the same Navigator together previousEntryList += entry } else { // Create a new group for the new Navigator entriesGroupedByNavigator += mutableListOf(entry) } // 1: 如果 navigatorName和前一个的相等，则添加到前一个的list中，否则添加到新建一个list中，最后会得到一个二维数组，每个数组中的元素都是具有相同NavigatorName的 } var navigated = false // Now actually navigate to each set of entries for (entryList in entriesGroupedByNavigator) { val navigator = _navigatorProvider.getNavigator&lt;Navigator&lt;NavDestination&gt;&gt;( entryList.first().destination.navigatorName ) // 2: 每个entryList都具有相同的navigatorName，找到对应的Navigator var lastNavigatedIndex = 0 navigator.navigateInternal(entryList, navOptions, navigatorExtras) { entry -&gt; navigated = true // If this destination is part of the restored back stack, // pass all destinations between the last navigated entry and this one // to ensure that any navigation graphs are properly restored as well val entryIndex = entries.indexOf(entry) val restoredEntries = if (entryIndex != -1) { entries.subList(lastNavigatedIndex, entryIndex + 1).also { lastNavigatedIndex = entryIndex + 1 } } else { emptyList() } addEntryToBackStack(entry.destination, args, entry, restoredEntries) } // 执行导航操作 } return navigated} 12345678910 private fun Navigator&lt;out NavDestination&gt;.navigateInternal( entries: List&lt;NavBackStackEntry&gt;, navOptions: NavOptions?, navigatorExtras: Navigator.Extras?, handler: (backStackEntry: NavBackStackEntry) -&gt; Unit = {}) { addToBackStackHandler = handler // 先把回调放到一边，稍后由NavControllerNavigatorState的push方法调用 navigate(entries, navOptions, navigatorExtras) // 执行导航操作 addToBackStackHandler = null} 123456789101112131415161718192021222324public open fun navigate( entries: List&lt;NavBackStackEntry&gt;, navOptions: NavOptions?, navigatorExtras: Extras?) { entries.asSequence().map { backStackEntry -&gt; // 遍历entries，把他进行变换 val destination = backStackEntry.destination as? D ?: return@map null val navigatedToDestination = navigate( destination, backStackEntry.arguments, navOptions, navigatorExtras ) // 由子类实现，执行真正的导航操作 when (navigatedToDestination) { null -&gt; null // 返回null，当前backStackEntry变成null destination -&gt; backStackEntry // 返回导航结果与destination相同，backStackEntry也不变 else -&gt; { state.createBackStackEntry( navigatedToDestination, navigatedToDestination.addInDefaultArgs(backStackEntry.arguments) ) // 否则创建新的backStackEntry } } }.filterNotNull().forEach { backStackEntry -&gt; state.push(backStackEntry) } // 1: 对于不为null的，重新放入state中,注意这里调用的push方法} 这里面的state定义如下 12345678910protected val state: NavigatorState get() = checkNotNull(_state) { &quot;You cannot access the Navigator's state until the Navigator is attached&quot; }private var _state: NavigatorState? = null@CallSuperpublic open fun onAttach(state: NavigatorState) { // 在onAttach时会初始化 _state = state isAttached = true} 在NavController的onGraphCreated方法中有 12345678910111213141516171819val navigatorBackStack = navigatorState.getOrPut(navigator) { NavControllerNavigatorState(navigator)}navigator.onAttach(navigatorBackStack)// 其中navigatorState是从navigator到NavControllerNavigatorState的mapprivate val navigatorState = mutableMapOf&lt;Navigator&lt;out NavDestination&gt;, NavControllerNavigatorState&gt;()// getOrPut方法就是当没有key时，调用后面的函数插入到map中并返回，有key时则返回查询到的valuepublic inline fun &lt;K, V&gt; MutableMap&lt;K, V&gt;.getOrPut(key: K, defaultValue: () -&gt; V): V { val value = get(key) return if (value == null) { val answer = defaultValue() put(key, answer) answer } else { value }} 所以上面1:出调用的push方法，就是NavControllerNavigatorState的push方法 123456789101112131415161718192021222324override fun push(backStackEntry: NavBackStackEntry) { val destinationNavigator: Navigator&lt;out NavDestination&gt; = _navigatorProvider[backStackEntry.destination.navigatorName] if (destinationNavigator == navigator) { val handler = addToBackStackHandler // 还记得前面存起来的回调吗，就会在这里调用 if (handler != null) { handler(backStackEntry) addInternal(backStackEntry) } else { // TODO handle the Navigator calling add() outside of a call to navigate() Log.i( TAG, &quot;Ignoring add of destination ${backStackEntry.destination} &quot; + &quot;outside of the call to navigate(). &quot; ) } } else { val navigatorBackStack = checkNotNull(navigatorState[destinationNavigator]) { &quot;NavigatorBackStack for ${backStackEntry.destination.navigatorName} should &quot; + &quot;already be created&quot; } navigatorBackStack.push(backStackEntry) }} 疑问，他跳转那么多干什么？ 3: singleTop的情况123456789public class NavOptions internal constructor( private val singleTop: Boolean, // ...) { public fun shouldLaunchSingleTop(): Boolean { return singleTop } // ...} shouldLaunchSingleTop返回的值是其构造时的一个标志位 在分析launchSingleTopInternal方法前，先看一下NavController中维护的一个父子关系 12private val childToParentEntries = mutableMapOf&lt;NavBackStackEntry, NavBackStackEntry&gt;()private val parentToChildCount = mutableMapOf&lt;NavBackStackEntry, AtomicInteger&gt;() 看起来NavBackStackEntry之间存在一个父子关系，可能是一张图的形式，一个map存储这种父子关系，一个map存储子节点的个数 后面看了NavDestination和NavBackStackEntry后就知道，这里维护的就是NavDestination之间的父子关系。 12345678910111213141516171819private fun linkChildToParent(child: NavBackStackEntry, parent: NavBackStackEntry) { childToParentEntries[child] = parent if (parentToChildCount[parent] == null) { parentToChildCount[parent] = AtomicInteger(0) } parentToChildCount[parent]!!.incrementAndGet()}internal fun unlinkChildFromParent(child: NavBackStackEntry): NavBackStackEntry? { val parent = childToParentEntries.remove(child) ?: return null val count = parentToChildCount[parent]?.decrementAndGet() if (count == 0) { val navGraphNavigator: Navigator&lt;out NavGraph&gt; = _navigatorProvider[parent.destination.navigatorName] navigatorState[navGraphNavigator]?.markTransitionComplete(parent) parentToChildCount.remove(parent) } return parent} 这两个函数用于维护NavBackStackEntry之间的父子关系当一个NavBackStackEntry的child个数为0时，会调用markTransitionComplete，具体干啥的继续挖坑吧！// todo : markTransitionComplete 123456789101112131415161718192021222324252627282930313233343536373839404142private fun launchSingleTopInternal( node: NavDestination, args: Bundle?): Boolean { val currentBackStackEntry = currentBackStackEntry val nodeId = if (node is NavGraph) node.findStartDestination().id else node.id if (nodeId != currentBackStackEntry?.destination?.id) return false val tempBackQueue: ArrayDeque&lt;NavBackStackEntry&gt; = ArrayDeque() // pop from startDestination back to original node and create a new entry for each backQueue.indexOfLast { it.destination === node }.let { nodeIndex -&gt; // 找到queue中最后一个destination和node相等的index while (backQueue.lastIndex &gt;= nodeIndex) { // 如果queue中最后一个index大于nodeIndex，就删掉他，并创建一个新的entry，放到tempBackQueue中，直到lastIndex小于nodeIndex为止 val oldEntry = backQueue.removeLast() unlinkChildFromParent(oldEntry) // 删除父子关系 val newEntry = NavBackStackEntry( oldEntry, oldEntry.destination.addInDefaultArgs(args) ) // 创建新的entry tempBackQueue.addFirst(newEntry) // 添加到tempBackQueue中 } } // add each new entry to backQueue starting from original node to startDestination tempBackQueue.forEach { newEntry -&gt; val parent = newEntry.destination.parent if (parent != null) { val newParent = getBackStackEntry(parent.id) linkChildToParent(newEntry, newParent) // 更新entry之间的父子关系 } backQueue.add(newEntry) } // we replace NavState entries here only after backQueue has been finalized tempBackQueue.forEach { newEntry -&gt; val navigator = _navigatorProvider.getNavigator&lt;Navigator&lt;*&gt;&gt;( newEntry.destination.navigatorName ) navigator.onLaunchSingleTop(newEntry) // 拿到对应的Navigator，执行onLaunchSingleTop } return true} 123456@Suppress(&quot;UNCHECKED_CAST&quot;)public open fun onLaunchSingleTop(backStackEntry: NavBackStackEntry) { val destination = backStackEntry.destination as? D ?: return navigate(destination, null, navOptions { launchSingleTop = true }, null) // 这个navigate执行真正的导航操作，老演员了，上面见过就不说了 state.onLaunchSingleTop(backStackEntry) // 这个state在前面也介绍过，下面看看他的onLaunchSingleTop方法干了什么} 1234567891011public open fun onLaunchSingleTop(backStackEntry: NavBackStackEntry) { // We update the back stack here because we don't want to leave it to the navigator since // it might be using transitions. backStackLock.withLock { val tempStack = backStack.value.toMutableList() tempStack.indexOfLast { it.id == backStackEntry.id }.let { idx -&gt; tempStack[idx] = backStackEntry } _backStack.value = tempStack }} 其实就是更新当前的返回栈找到最后一个id与backStackEntry的id相等的index，将这个位置的entry替换为backStackEntry 其他情况在没有开启LaunchSingleTop的情况，或launchSingleTopInternal没有成功的情况那，就会走到这个代码分支 12345678910111213if (!launchSingleTop) { // Not a single top operation, so we're looking to add the node to the back stack val backStackEntry = NavBackStackEntry.create( context, node, finalArgs, hostLifecycleState, viewModel ) val navigator = _navigatorProvider.getNavigator&lt;Navigator&lt;NavDestination&gt;&gt;( node.navigatorName ) navigator.navigateInternal(listOf(backStackEntry), navOptions, navigatorExtras) { navigated = true addEntryToBackStack(node, finalArgs, it) }} 创建新的backStackEntry条目，找到对应的Navigator，执行导航操作，如果成功了，就将其加入到返回栈中 NavigatorProvider数据结构1234private val _navigators: MutableMap&lt;String, Navigator&lt;out NavDestination&gt;&gt; = mutableMapOf()@get:RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)public val navigators: Map&lt;String, Navigator&lt;out NavDestination&gt;&gt; get() = _navigators.toMap() 以上就是NavigatorProvider的全部数据结构了，就是一个String to Navigator的Map 回想核心的navigate方法中多次使用NavDestination#navigatorName从NavigatorProvider中获取Navigator，所以NavigatorProvider的就是一个用来保存navigatorName到Navigator实例的Map 获取Navigator1234567891011121314151617181920212223242526public fun &lt;T : Navigator&lt;*&gt;&gt; getNavigator(navigatorClass: Class&lt;T&gt;): T { val name = getNameForNavigator(navigatorClass) return getNavigator(name)}/*** Retrieves a registered [Navigator] by name.** @param name name of the navigator to return* @return the registered navigator with the given name** @throws IllegalStateException if the Navigator has not been added** @see NavigatorProvider.addNavigator*/@Suppress(&quot;UNCHECKED_CAST&quot;)@CallSuperpublic open fun &lt;T : Navigator&lt;*&gt;&gt; getNavigator(name: String): T { require(validateName(name)) { &quot;navigator name cannot be an empty string&quot; } val navigator = _navigators[name] ?: throw IllegalStateException( &quot;Could not find Navigator with name \\&quot;$name\\&quot;. You must call &quot; + &quot;NavController.addNavigator() for each navigation type.&quot; ) return navigator as T} getNameForNavigator12345678910111213141516171819202122internal companion object { private val annotationNames = mutableMapOf&lt;Class&lt;*&gt;, String?&gt;() internal fun validateName(name: String?): Boolean { return name != null &amp;&amp; name.isNotEmpty() } @JvmStatic internal fun getNameForNavigator(navigatorClass: Class&lt;out Navigator&lt;*&gt;&gt;): String { var name = annotationNames[navigatorClass] if (name == null) { val annotation = navigatorClass.getAnnotation( Navigator.Name::class.java ) name = annotation?.value require(validateName(name)) { &quot;No @Navigator.Name annotation found for ${navigatorClass.simpleName}&quot; } annotationNames[navigatorClass] = name } return name!! }} 发现获取的name是一个运行时注解，所以需要先看看Navigator.Name这个注解 Navigator.Name是Navigator中的一个运行时注解123@kotlin.annotation.Retention(AnnotationRetention.RUNTIME)@Target(AnnotationTarget.ANNOTATION_CLASS, AnnotationTarget.CLASS)public annotation class Name(val value: String) 我们观察几个Navigator，发现他们都有@Navigator.Name注解，并传入了对应的参数123456789101112131415161718192021222324252627// 1. FragmentNavigator@Navigator.Name(&quot;fragment&quot;)public open class FragmentNavigator( private val context: Context, private val fragmentManager: FragmentManager, private val containerId: Int) : Navigator&lt;Destination&gt;() { // ...}// 2. ActivityNavigator@Navigator.Name(&quot;activity&quot;)public open class ActivityNavigator( /** @suppress */ @get:RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public val context: Context) : Navigator&lt;ActivityNavigator.Destination&gt;() { // ...}// 3. NavGraphNavigator@Navigator.Name(&quot;navigation&quot;)public open class NavGraphNavigator( private val navigatorProvider: NavigatorProvider) : Navigator&lt;NavGraph&gt;() { // ...} 这样就可以明确了，Navigator的name就是注解时的value FragmentNavigator的name是&quot;fragment&quot; ActivityNavigator的name是&quot;activity&quot; … addNavigator123456789101112131415161718192021222324252627282930313233public fun addNavigator( navigator: Navigator&lt;out NavDestination&gt;): Navigator&lt;out NavDestination&gt;? { return addNavigator(getNameForNavigator(navigator.javaClass), navigator)}/*** Register a navigator by name. [destinations][NavDestination] may refer to any* registered navigator by name for inflation. If a navigator by this name is already* registered, this new navigator will replace it.** @param name name for this navigator* @param navigator navigator to add* @return the previously added Navigator for the given name, if any*/@CallSuperpublic open fun addNavigator( name: String, navigator: Navigator&lt;out NavDestination&gt;): Navigator&lt;out NavDestination&gt;? { require(validateName(name)) { &quot;navigator name cannot be an empty string&quot; } val previousNavigator = _navigators[name] if (previousNavigator == navigator) { return navigator } check(previousNavigator?.isAttached != true) { &quot;Navigator $navigator is replacing an already attached $previousNavigator&quot; } check(!navigator.isAttached) { &quot;Navigator $navigator is already attached to another NavController&quot; } return _navigators.put(name, navigator)} addNavigator时，首先取出对应name的Navigator 如果Navigator和要放入的Navigator相同，则直接返回 如果前一个Navigator不空且没有被attach，则抛出异常 这里判断方法为previousNavigator?.isAttached != true, null或者bool和true比较，十分简洁，值得学习！ 检查确认要放入的Navigator没有被attach，否则抛出异常 最后将Navigator放入_navigators中，并返回前一个Navigator 被替换的Navigator如果不空的话，不能是已经Attach的 想要放入的Navigator也不能被attach 扩展get和set方法123456789101112131415@Suppress(&quot;NOTHING_TO_INLINE&quot;)public inline operator fun &lt;T : Navigator&lt;out NavDestination&gt;&gt; NavigatorProvider.get( name: String): T = getNavigator(name)@Suppress(&quot;NOTHING_TO_INLINE&quot;)public inline operator fun &lt;T : Navigator&lt;out NavDestination&gt;&gt; NavigatorProvider.get( clazz: KClass&lt;T&gt;): T = getNavigator(clazz.java)@Suppress(&quot;NOTHING_TO_INLINE&quot;)public inline operator fun NavigatorProvider.set( name: String, navigator: Navigator&lt;out NavDestination&gt;): Navigator&lt;out NavDestination&gt;? = addNavigator(name, navigator) 很简单 扩展的+=运算符1234@Suppress(&quot;NOTHING_TO_INLINE&quot;)public inline operator fun NavigatorProvider.plusAssign(navigator: Navigator&lt;out NavDestination&gt;) { addNavigator(navigator)} 也很简单 NavBackStackEntry先看注释12Representation of an entry in the back stack of a androidx.navigation.NavController.The Lifecycle, ViewModelStore, and SavedStateRegistry provided via this object are valid for the lifetime of this destination on the back stack: when this destination is popped off the back stack, the lifecycle will be destroyed, state will no longer be saved, and ViewModels will be cleared. 介绍了两件事情 这个类代表的是NavController中返回栈的一个entry 他能提供Lifecycle, ViewModelStore, and SavedStateRegistry 当这个NavBackStackEntry存在于返回栈时，他们的生命周期时有效的，当这个NavBackStackEntry被pop掉时，他们的生命周期会被销毁，状态会被清除，ViewModel会被清除 类定义和数据结构lifeCycle部分123456789101112131415161718192021222324252627282930313233343536public class NavBackStackEntry private constructor( private val context: Context?, /** * The destination associated with this entry * @return The destination that is currently visible to users */ @set:RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public var destination: NavDestination, private val immutableArgs: Bundle? = null, private var hostLifecycleState: Lifecycle.State = Lifecycle.State.CREATED, private val viewModelStoreProvider: NavViewModelStoreProvider? = null, /** * The unique ID that serves as the identity of this entry * @return the unique ID of this entry */ public val id: String = UUID.randomUUID().toString(), private val savedState: Bundle? = null) : LifecycleOwner, ViewModelStoreOwner, HasDefaultViewModelProviderFactory, SavedStateRegistryOwner { private var _lifecycle = LifecycleRegistry(this) override val lifecycle: Lifecycle get() = _lifecycle @get:RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) @set:RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public var maxLifecycle: Lifecycle.State = Lifecycle.State.INITIALIZED set(maxState) { field = maxState updateState() } // ...} 很简单实现了lifeCycle maxLifecycle是Lifecycle.State，保存当前的状态，默认是Lifecycle.State.INITIALIZED 调用maxLifecycle的set属性时，会调用updateState方法123456789101112131415161718@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)public fun updateState() { if (!savedStateRegistryAttached) { savedStateRegistryController.performAttach() savedStateRegistryAttached = true if (viewModelStoreProvider != null) { enableSavedStateHandles() } // Perform the restore just once, the first time updateState() is called // and specifically *before* we move up the Lifecycle savedStateRegistryController.performRestore(savedState) } if (hostLifecycleState.ordinal &lt; maxLifecycle.ordinal) { _lifecycle.currentState = hostLifecycleState } else { _lifecycle.currentState = maxLifecycle }} 首先判断savedStateRegistry是否被attach, 如果没有，就执行attach,并回复状态 然后就是更新lifeCycle的状态，取hostLifecycleState和maxLifecycle之中较小的那一个 这里看到一个ordinal不太熟悉，这个属于java基础 继续挖坑// todo: enum, ordinal ViewModel部分12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class NavBackStackEntry private constructor( private val context: Context?, /** * The destination associated with this entry * @return The destination that is currently visible to users */ @set:RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public var destination: NavDestination, private val immutableArgs: Bundle? = null, private var hostLifecycleState: Lifecycle.State = Lifecycle.State.CREATED, private val viewModelStoreProvider: NavViewModelStoreProvider? = null, /** * The unique ID that serves as the identity of this entry * @return the unique ID of this entry */ public val id: String = UUID.randomUUID().toString(), private val savedState: Bundle? = null) : LifecycleOwner, ViewModelStoreOwner, HasDefaultViewModelProviderFactory, SavedStateRegistryOwner { private val defaultFactory by lazy { SavedStateViewModelFactory((context?.applicationContext as? Application), this, arguments) } /** * The [SavedStateHandle] for this entry. */ public val savedStateHandle: SavedStateHandle by lazy { check(savedStateRegistryAttached) { &quot;You cannot access the NavBackStackEntry's SavedStateHandle until it is added to &quot; + &quot;the NavController's back stack (i.e., the Lifecycle of the NavBackStackEntry &quot; + &quot;reaches the CREATED state).&quot; } check(lifecycle.currentState != Lifecycle.State.DESTROYED) { &quot;You cannot access the NavBackStackEntry's SavedStateHandle after the &quot; + &quot;NavBackStackEntry is destroyed.&quot; } ViewModelProvider( this, NavResultSavedStateFactory(this) ).get(SavedStateViewModel::class.java).handle } override val defaultViewModelProviderFactory: ViewModelProvider.Factory = defaultFactory override val defaultViewModelCreationExtras: CreationExtras get() { val extras = MutableCreationExtras() (context?.applicationContext as? Application)?.let { application -&gt; extras[ViewModelProvider.AndroidViewModelFactory.APPLICATION_KEY] = application } extras[SAVED_STATE_REGISTRY_OWNER_KEY] = this extras[VIEW_MODEL_STORE_OWNER_KEY] = this arguments?.let { args -&gt; extras[DEFAULT_ARGS_KEY] = args } return extras } override val savedStateRegistry: SavedStateRegistry get() = savedStateRegistryController.savedStateRegistry private class NavResultSavedStateFactory( owner: SavedStateRegistryOwner ) : AbstractSavedStateViewModelFactory(owner, null) { @Suppress(&quot;UNCHECKED_CAST&quot;) override fun &lt;T : ViewModel&gt; create( key: String, modelClass: Class&lt;T&gt;, handle: SavedStateHandle ): T { return SavedStateViewModel(handle) as T } } private class SavedStateViewModel(val handle: SavedStateHandle) : ViewModel() // ...} 这里保留了savedStateHandle，和viewModel有一定的耦合 我们使用的viewModel就存了一个SavedStateHandle 提供了默认的ViewModelProvider.Factory和Extras 基本都是和savedState相关的，所以先不看了 viewModel的作用 提供handle 提供viewModelStore(就是viewModelName到viewModel的map) // todo: 学习saveState后再看 // 疑问，为啥非要通过viewModel来获取handle呢？ savedState部分12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class NavBackStackEntry private constructor( private val context: Context?, /** * The destination associated with this entry * @return The destination that is currently visible to users */ @set:RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public var destination: NavDestination, private val immutableArgs: Bundle? = null, private var hostLifecycleState: Lifecycle.State = Lifecycle.State.CREATED, private val viewModelStoreProvider: NavViewModelStoreProvider? = null, /** * The unique ID that serves as the identity of this entry * @return the unique ID of this entry */ public val id: String = UUID.randomUUID().toString(), private val savedState: Bundle? = null) : LifecycleOwner, ViewModelStoreOwner, HasDefaultViewModelProviderFactory, SavedStateRegistryOwner { private val savedStateRegistryController = SavedStateRegistryController.create(this) private var savedStateRegistryAttached = false /** * The [SavedStateHandle] for this entry. */ public val savedStateHandle: SavedStateHandle by lazy { check(savedStateRegistryAttached) { &quot;You cannot access the NavBackStackEntry's SavedStateHandle until it is added to &quot; + &quot;the NavController's back stack (i.e., the Lifecycle of the NavBackStackEntry &quot; + &quot;reaches the CREATED state).&quot; } check(lifecycle.currentState != Lifecycle.State.DESTROYED) { &quot;You cannot access the NavBackStackEntry's SavedStateHandle after the &quot; + &quot;NavBackStackEntry is destroyed.&quot; } ViewModelProvider( this, NavResultSavedStateFactory(this) ).get(SavedStateViewModel::class.java).handle } override val savedStateRegistry: SavedStateRegistry get() = savedStateRegistryController.savedStateRegistry // ...} // todo: 学习saveState后再看 其他部分12345678910111213141516171819202122232425262728public class NavBackStackEntry private constructor( private val context: Context?, /** * The destination associated with this entry * @return The destination that is currently visible to users */ @set:RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public var destination: NavDestination, private val immutableArgs: Bundle? = null, private var hostLifecycleState: Lifecycle.State = Lifecycle.State.CREATED, private val viewModelStoreProvider: NavViewModelStoreProvider? = null, /** * The unique ID that serves as the identity of this entry * @return the unique ID of this entry */ public val id: String = UUID.randomUUID().toString(), private val savedState: Bundle? = null) : LifecycleOwner, ViewModelStoreOwner, HasDefaultViewModelProviderFactory, SavedStateRegistryOwner { public val arguments: Bundle? get() = if (immutableArgs == null) { null } else { Bundle(immutableArgs) }} id: public的一个随机unique的id，应该是用于标识一个NavBackStackEntry arguments: 在前面的defaultViewModelCreationExtras和defaultFactory中有使用，将args提供给extras和factory 构造函数12345678910111213@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)constructor(entry: NavBackStackEntry, arguments: Bundle? = entry.arguments) : this( entry.context, entry.destination, arguments, entry.hostLifecycleState, entry.viewModelStoreProvider, entry.id, entry.savedState) { hostLifecycleState = entry.hostLifecycleState maxLifecycle = entry.maxLifecycle} 对外暴露的构造函数仅这一个，除了arguments其他都是从另一个NavBackStackEntry中获取的 123456789101112131415public companion object { @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public fun create( context: Context?, destination: NavDestination, arguments: Bundle? = null, hostLifecycleState: Lifecycle.State = Lifecycle.State.CREATED, viewModelStoreProvider: NavViewModelStoreProvider? = null, id: String = UUID.randomUUID().toString(), savedState: Bundle? = null ): NavBackStackEntry = NavBackStackEntry( context, destination, arguments, hostLifecycleState, viewModelStoreProvider, id, savedState )} 通过create方法暴露了另外一个私有的构造函数，猜测这么做的目的是为了限制该构造函数仅在navigation库的范围内使用吧？ 总结 总的来说，这个类作为NavController返回栈的一个entry，同时提供了一些变量 destination id arguments savedStateHandle maxLifecycle viewModelStore NavDestination先看注释12345NavDestination represents one node within an overall navigation graph.Each destination is associated with a Navigator which knows how to navigate to this particular destination.Destinations declare a set of actions that they support. These actions form a navigation API for the destination; the same actions declared on different destinations that fill similar roles allow application code to navigate based on semantic intent.Each destination has a set of arguments that will be applied when navigating to that destination. Any default values for those arguments can be overridden at the time of navigation.NavDestinations should be created via Navigator.createDestination. NavDestination代表一个导航图中的一个节点 每个NavDestination都关联一个Navigator，Navigator知道如何导航到这个NavDestination 保存一组action 后半句有点难懂，不同destinations中相同的action发挥相同的作用，可以允许应用代码基于语义intent导航 每个destination都有一组args，在导航到这个destination时可能会被覆盖 NavDestinations应该通过Navigator.createDestination创建 类定义和数据结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public open class NavDestination( /** * The name associated with this destination's [Navigator]. */ public val navigatorName: String) { @kotlin.annotation.Retention(AnnotationRetention.BINARY) @Target(AnnotationTarget.ANNOTATION_CLASS, AnnotationTarget.CLASS) public annotation class ClassType(val value: KClass&lt;*&gt;) // 1. 注解 public var parent: NavGraph? = null // 2. partent /** @suppress */ @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public set private var idName: String? = null public var label: CharSequence? = null private val deepLinks = mutableListOf&lt;NavDeepLink&gt;() // 3. deepLinks private val actions: SparseArrayCompat&lt;NavAction&gt; = SparseArrayCompat() // 4. actions private var _arguments: MutableMap&lt;String, NavArgument&gt; = mutableMapOf() // 5. args public val arguments: Map&lt;String, NavArgument&gt; get() = _arguments.toMap() @get:IdRes public var id: Int = 0 // 6. id set(@IdRes id) { field = id idName = null } public var route: String? = null // 7. route set(route) { if (route == null) { id = 0 } else { require(route.isNotBlank()) { &quot;Cannot have an empty route&quot; } val internalRoute = createRoute(route) id = internalRoute.hashCode() addDeepLink(internalRoute) } deepLinks.remove(deepLinks.firstOrNull { it.uriPattern == createRoute(field) }) field = route } public open val displayName: String @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) get() = idName ?: id.toString() public companion object { @JvmStatic public val NavDestination.hierarchy: Sequence&lt;NavDestination&gt; // 8. hierarchy get() = generateSequence(this) { it.parent } // ... } // ... 1. 注解在子类中使用，在XXXNavigator中会有内部类Destination继承NavDestination，并使用该注解标注其导航的class 如，在FragmentNavigator中 123456@NavDestination.ClassType(Fragment::class)public open class Destinationpublic constructor(fragmentNavigator: Navigator&lt;out Destination&gt;) : NavDestination(fragmentNavigator) { // ...} 暂时没有找到获取并使用这个注解的代码 1This optional annotation allows tooling to offer auto-complete for the android:name attribute. This should match the class type passed to parseClassFromName when parsing the android:name attribute. 看起来是xml自动补全的时候会用到 2. parentparent是NavGraph，表示当前NavDestination的父节点，同时剧透一下, NavGraph是NavDestination的子类 8. hierarchyhierarchy是一个扩展属性，从当前NavDestination开始，生成一个父节点的sequence 3. deepLinksdeepLinks是一个list, 在matchDeepLink时会遍历该list，寻找到最佳match的NavDeepLink 4. actionsaction是一个SparseArrayCompat，也就是一个Int到Object的Map 7. route代表当前Destination的route字符串，可以看到他也调用了addDeepLink addDeepLink123456789101112131415public fun addDeepLink(uriPattern: String) { addDeepLink(NavDeepLink.Builder().setUriPattern(uriPattern).build())}public fun addDeepLink(navDeepLink: NavDeepLink) { val missingRequiredArguments = _arguments.missingRequiredArguments { key -&gt; key !in navDeepLink.argumentsNames } require(missingRequiredArguments.isEmpty()) { &quot;Deep link ${navDeepLink.uriPattern} can't be used to open destination $this.\\n&quot; + &quot;Following required arguments are missing: $missingRequiredArguments&quot; } deepLinks.add(navDeepLink)} 第一个函数是给route使用的，将route字符串变成一个NavDeepLink第二个函数很简单，就是将NavDeepLink添加到deepLinks中，在放入之前会检查一下，保证_arguments中的key全部存在于deepLink的argumentsNames中 route转换成NavDeepLinkRequest12345678@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)public fun createRoute(route: String?): String = if (route != null) &quot;android-app://androidx.navigation/$route&quot; else &quot;&quot;// NavDeepLinkRequest.Builder#buildpublic fun build(): NavDeepLinkRequest { return NavDeepLinkRequest(uri, action, mimeType)} 就是把route根据特定格式转换成一个uri，存到NavDeepLinkRequest这个类中，这个类也很简单 123456public open class NavDeepLinkRequest { public open val uri: Uri? public open val action: String? public open val mimeType: String? // ...} 就是用来存这三个东西的 matchDeepLink12345678910@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)public fun matchDeepLink(route: String): DeepLinkMatch? { val request = NavDeepLinkRequest.Builder.fromUri(createRoute(route).toUri()).build() val matchingDeepLink = if (this is NavGraph) { matchDeepLinkExcludingChildren(request) } else { matchDeepLink(request) } return matchingDeepLink} 这个函数是用来通过route来匹配DeepLink的，如果当前NavDestination是子类NavGraph，则会调用子类的函数matchDeepLinkExcludingChildren，否则调用matchDeepLink。matchDeepLinkExcludingChildren在后面介绍 123456789101112131415161718192021222324252627282930313233@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)public open fun matchDeepLink(navDeepLinkRequest: NavDeepLinkRequest): DeepLinkMatch? { if (deepLinks.isEmpty()) { return null } var bestMatch: DeepLinkMatch? = null for (deepLink in deepLinks) { val uri = navDeepLinkRequest.uri // includes matching args for path, query, and fragment val matchingArguments = if (uri != null) deepLink.getMatchingArguments(uri, _arguments) else null val matchingPathSegments = deepLink.calculateMatchingPathSegments(uri) val requestAction = navDeepLinkRequest.action val matchingAction = requestAction != null &amp;&amp; requestAction == deepLink.action val mimeType = navDeepLinkRequest.mimeType val mimeTypeMatchLevel = if (mimeType != null) deepLink.getMimeTypeMatchRating(mimeType) else -1 if (matchingArguments != null || ((matchingAction || mimeTypeMatchLevel &gt; -1) &amp;&amp; hasRequiredArguments(deepLink, uri, _arguments)) ) { // 2. match的条件 val newMatch = DeepLinkMatch( this, matchingArguments, deepLink.isExactDeepLink, matchingPathSegments, matchingAction, mimeTypeMatchLevel ) if (bestMatch == null || newMatch &gt; bestMatch) { // 1. 比较match, 选择最好的一个match bestMatch = newMatch } } } return bestMatch} 就是遍历所有deepLinks数组，找到最match的一个 // todo: 2. match的条件 id1234567// 每个destination的唯一id，必须是资源id@get:IdRespublic var id: Int = 0 set(@IdRes id) { field = id idName = null } 这里就有疑问了，这里的id应该是导航图xml的id，如下所示，id在onInflate的时候被赋值。 123456789101112@CallSuperpublic open fun onInflate(context: Context, attrs: AttributeSet) { context.resources.obtainAttributes(attrs, R.styleable.Navigator).use { array -&gt; route = array.getString(R.styleable.Navigator_route) if (array.hasValue(R.styleable.Navigator_android_id)) { id = array.getResourceId(R.styleable.Navigator_android_id, 0) idName = getDisplayName(context, id) } label = array.getText(R.styleable.Navigator_android_label) }} 但在Compose中，并不使用xml的导航图，如何初始化这个id呢？ 12345678910111213public var route: String? = null set(route) { if (route == null) { id = 0 } else { require(route.isNotBlank()) { &quot;Cannot have an empty route&quot; } val internalRoute = createRoute(route) id = internalRoute.hashCode() addDeepLink(internalRoute) } deepLinks.remove(deepLinks.firstOrNull { it.uriPattern == createRoute(field) }) field = route } 可以看到这里，如果是compose的route字符串，createRoute后，会使用hashCode为id赋值 addInDefaultArgs总结大概作用就是 保存action对象，维护了一个map，保存action的resId到action对象 提供navigatorName，方便NavController根据name找到对应的Navigator 维护deeplink列表，提供deeplink匹配的方法 提供parent和hierarchy，提供嵌套图的支持 提供route到deeplinkRequest的转换 NavGraph先看注释12345NavGraph is a collection of NavDestination nodes fetchable by ID.A NavGraph serves as a 'virtual' destination: while the NavGraph itself will not appear on the back stack, navigating to the NavGraph will cause the starting destination to be added to the back stack.Construct a new NavGraph. This NavGraph is not valid until you add a destination and set the starting destination.Params:navGraphNavigator - The NavGraphNavigator which this destination will be associated with. Generally retrieved via a NavController'sNavigatorProvider.getNavigator method. 存储了图中所有的节点，可以通过id获取各个节点 这里的节点就是上面介绍的NavDestination 导航图本身是一个虚拟的destination，但是他不会出现在栈中，如果试图导航到NavGraph，将会导航到这个导航图的startDest中 数据结构12345678910111213141516171819202122232425262728293031323334353637public open class NavGraph(navGraphNavigator: Navigator&lt;out NavGraph&gt;) : NavDestination(navGraphNavigator), Iterable&lt;NavDestination&gt; { public val nodes: SparseArrayCompat&lt;NavDestination&gt; = SparseArrayCompat&lt;NavDestination&gt;() /** @suppress */ @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) get private var startDestId = 0 @get:IdRes public var startDestinationId: Int get() = startDestId private set(startDestId) { require(startDestId != id) { &quot;Start destination $startDestId cannot use the same id as the graph $this&quot; } if (startDestinationRoute != null) { startDestinationRoute = null } this.startDestId = startDestId startDestIdName = null } public var startDestinationRoute: String? = null private set(startDestRoute) { startDestId = if (startDestRoute == null) { 0 } else { require(startDestRoute != route) { &quot;Start destination $startDestRoute cannot use the same route as the graph $this&quot; } require(startDestRoute.isNotBlank()) { &quot;Cannot have an empty start destination route&quot; } val internalRoute = createRoute(startDestRoute) internalRoute.hashCode() } field = startDestRoute }} nodes，存储所有destination的map，key时destination的id startDestId，startDestinationRoute起始destination的id、route 如果startDestinationRoute不空，和id的情况相同，createRoute后，使用hashCode作为startDestId onInflate12345678910override fun onInflate(context: Context, attrs: AttributeSet) { super.onInflate(context, attrs) context.resources.obtainAttributes( attrs, R.styleable.NavGraphNavigator ).use { startDestinationId = it.getResourceId(R.styleable.NavGraphNavigator_startDestination, 0) startDestIdName = getDisplayName(context, startDestId) }} 解析xml时，从xml中获取startDestination的id matchDeepLink12345678910111213141516@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)public override fun matchDeepLink(navDeepLinkRequest: NavDeepLinkRequest): DeepLinkMatch? { // First search through any deep links directly added to this NavGraph val bestMatch = super.matchDeepLink(navDeepLinkRequest) // Then search through all child destinations for a matching deep link val bestChildMatch = mapNotNull { child -&gt; child.matchDeepLink(navDeepLinkRequest) }.maxOrNull() return listOfNotNull(bestMatch, bestChildMatch).maxOrNull()}@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)public fun matchDeepLinkExcludingChildren(request: NavDeepLinkRequest): DeepLinkMatch? = super.matchDeepLink(request) navGraph本身也可以作为一个destination，拥有deeplink，所以先搜索他自身的match，然后搜索所有子节点的match，最后返回最match的一个 这个函数只有在使用route字符串匹配时会使用，通过route匹配时就不考虑子节点，为什么呢？ 总结 其实本质上也是一个保存子节点的map 提供matchDeepLink方法，用于匹配子子节点和自己本身deeplink NavigatorStateNavControllerNavigatorStateNavControllerViewModelFragmentNavigatorActivityNavigator总结中的总结需要一个NavHostFragment想要使用navigation库，需要有一个NavHostFragment。navigation库为Fragment, View, Acivity都添加了扩展函数findNavController，用来找到navController，查找时都需要一个NavHostFragment的存在。 对于Fragment来说，需要它本身，或者所有上级Fragment中存在一个NavHostFragment 对于View来说，需要他本身，或者所有上级view的tag中，存在R.id.nav_controller_view_tag,这个tag下可以获得NavController。NavHostFragment的onViewCreated方法中,会对Fragment的rootView设置这个tag 对于activity来说，需要指定一个viewId，通过findView找到这个view后，寻找过程和View相同 这个NavHostFragment的graphId不能通过用户传入，因为这个变量是private的。NavHostFragment通过xml获取这个导航图的id，或者使用KEY_GRAPH_ID从savedState或Fragment的mArguments中获取，而这个KEY_GRAPH_ID也是仅在navigation库中可用的。 NavHostFragment实现了NavHost，拥有了一个NavController，通过它的navigate方法可以进行跳转。NavHostFragment实现NavController的实现类是NavHostController,这个类中没有任何函数实现，只是将父类的几个函数变成final的 导航图 导航图可以通过xml和kotlin DSL描述。 导航图可以包含多个子节点，每个子节点都是一个destination。 每个destination可以是fragment，activity，dialog，或者一个NavGraph作为子图。每个destination可以包含多个action 每个action包含它本身的id和导航目的地的destinationId，用于确定导航的目的地。 每个destination也可以包含多个deeplink NavController通过deeplink进行导航时，会搜索导航图，以及导航图中的destination的deeplink，找到匹配度最高的一个，进行导航。 在Compose中使用route字符串进行导航时，实际上会将其包装为一个uri类型的deeplink，然后进行匹配。 每个deeplink包含其uri，action字符串，mimeType字符串，用于匹配。 导航图本身也是一个destination，导航到一个NavGraph是，会导航到startDestination。 在xml中，给根节点&lt;navigation&gt;添加startDestination参数，填写一个destinationId，作为startDestination。 在kotlin DSL中，通过startDestination指定一个route字符串，作为startDestination NavController 这个类是整个navigation库的核心 提供多种navigate方法，可以通过destination的resId，route字符串和deepLink进行导航 这个类维护了导航图NavGraph，返回栈_currentBackStack等数据结构 这个类并承担具体的跳转任务，具体的跳转任务由Navigator的各个子类完成 上面说到导航目的地有很多种类，NavController会根据导航目的地的类型，选择不同的Navigator来完成跳转任务，比如FragmentNavigator，ActivityNavigator，DialogNavigator 每个Navigator都有name，是通过一个注解Navigator.Name指定的。 NavController中因此也维护了_navigatorProvider，他的作用类似于一个map,存储Navigator的name和Navigator的映射关系。","link":"/home/2024/08/07/Android%E9%AB%98%E7%BA%A7/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E5%9F%BA%E7%A1%8005-Navigation/"},{"title":"基础03-Lifecycle","text":"lifeCycle的Observer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public interface LifecycleObserverpublic interface DefaultLifecycleObserver : LifecycleObserver { /** * Notifies that `ON_CREATE` event occurred. * * * This method will be called after the [LifecycleOwner]'s `onCreate` * method returns. * * @param owner the component, whose state was changed */ public fun onCreate(owner: LifecycleOwner) {} /** * Notifies that `ON_START` event occurred. * * * This method will be called after the [LifecycleOwner]'s `onStart` method returns. * * @param owner the component, whose state was changed */ public fun onStart(owner: LifecycleOwner) {} /** * Notifies that `ON_RESUME` event occurred. * * * This method will be called after the [LifecycleOwner]'s `onResume` * method returns. * * @param owner the component, whose state was changed */ public fun onResume(owner: LifecycleOwner) {} /** * Notifies that `ON_PAUSE` event occurred. * * * This method will be called before the [LifecycleOwner]'s `onPause` method * is called. * * @param owner the component, whose state was changed */ public fun onPause(owner: LifecycleOwner) {} /** * Notifies that `ON_STOP` event occurred. * * * This method will be called before the [LifecycleOwner]'s `onStop` method * is called. * * @param owner the component, whose state was changed */ public fun onStop(owner: LifecycleOwner) {} /** * Notifies that `ON_DESTROY` event occurred. * * * This method will be called before the [LifecycleOwner]'s `onDestroy` method * is called. * * @param owner the component, whose state was changed */ public fun onDestroy(owner: LifecycleOwner) {}}public fun interface LifecycleEventObserver : LifecycleObserver { /** * Called when a state transition event happens. * * @param source The source of the event * @param event The event */ public fun onStateChanged(source: LifecycleOwner, event: Lifecycle.Event)} 可以看到，我们在使用lifecycle.addObserver()时，可以传入LifecycleEventObserver或DefaultLifecycleObserver，一个通过event获取当前状态，一个通过不同的回调函数获取当前状态 Activity树1234567891011Activity -- AccountAuthenticatorActivity |- ActivityGroup -- TabActivity |- ExpandableListActivity |- LauncherActivity |- ListActivity -- PreferenceActivity |- NativeActivity |- androidx.core.app.ComponentActivity -- androidx.activity.ComponentActivity -- FragmentActivity -- AppCompatActivity |- PreviewActivity |- BootstrapActivity |- EmptyActivity |- EmptyFloatingActivity LifecycleOwner12345678public interface LifecycleOwner { /** * Returns the Lifecycle of the provider. * * @return The lifecycle of the provider. */ public val lifecycle: Lifecycle} androidx.core.app.ComponentActivity和androidx.activity.ComponentActivity都声明了对LifecycleOwner的实现 可以拿到lifecycle的Activity有 androidx.core.app.ComponentActivity androidx.activity.ComponentActivity FragmentActivity AppCompatActivity PreviewActivity androidx.core.app.ComponentActivity中的lifecycle123456789@Suppress(&quot;LeakingThis&quot;)private val lifecycleRegistry = LifecycleRegistry(this)override val lifecycle: Lifecycle get() = lifecycleRegistry@CallSuperoverride fun onSaveInstanceState(outState: Bundle) { lifecycleRegistry.currentState = Lifecycle.State.CREATED super.onSaveInstanceState(outState)} 很意外的是ComponentActivity并不是在每个生命周期回调函数中调用lifecycleRegistry的setCurrentState，从而分发生命周期 LifecycleRegistryaddObserver123456789101112131415161718192021222324252627282930override fun addObserver(observer: LifecycleObserver) { enforceMainThreadIfNeeded(&quot;addObserver&quot;) val initialState = if (state == State.DESTROYED) State.DESTROYED else State.INITIALIZED val statefulObserver = ObserverWithState(observer, initialState) val previous = observerMap.putIfAbsent(observer, statefulObserver) if (previous != null) { return } val lifecycleOwner = lifecycleOwner.get() ?: // it is null we should be destroyed. Fallback quickly return val isReentrance = addingObserverCounter != 0 || handlingEvent var targetState = calculateTargetState(observer) addingObserverCounter++ while (statefulObserver.state &lt; targetState &amp;&amp; observerMap.contains(observer) ) { pushParentState(statefulObserver.state) val event = Event.upFrom(statefulObserver.state) ?: throw IllegalStateException(&quot;no event up from ${statefulObserver.state}&quot;) statefulObserver.dispatchEvent(lifecycleOwner, event) popParentState() // mState / subling may have been changed recalculate targetState = calculateTargetState(observer) } if (!isReentrance) { // we do sync only on the top level. sync() } addingObserverCounter--} 这里看到addObserver首先将observer包装成ObserverWithState，并将其加入到observerMap 加入后立刻调用dispatchEvent将最新的状态传递出去 123456789101112131415161718private fun sync() { val lifecycleOwner = lifecycleOwner.get() ?: throw IllegalStateException( &quot;LifecycleOwner of this LifecycleRegistry is already &quot; + &quot;garbage collected. It is too late to change lifecycle state.&quot; ) while (!isSynced) { newEventOccurred = false if (state &lt; observerMap.eldest()!!.value.state) { backwardPass(lifecycleOwner) } val newest = observerMap.newest() if (!newEventOccurred &amp;&amp; newest != null &amp;&amp; state &gt; newest.value.state) { forwardPass(lifecycleOwner) } } newEventOccurred = false} 这里看到sync会调用backwardPass和forwardPass 12345678910111213141516171819202122232425262728293031private fun forwardPass(lifecycleOwner: LifecycleOwner) { @Suppress() val ascendingIterator: Iterator&lt;Map.Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; = observerMap.iteratorWithAdditions() while (ascendingIterator.hasNext() &amp;&amp; !newEventOccurred) { val (key, observer) = ascendingIterator.next() while (observer.state &lt; state &amp;&amp; !newEventOccurred &amp;&amp; observerMap.contains(key) ) { pushParentState(observer.state) val event = Event.upFrom(observer.state) ?: throw IllegalStateException(&quot;no event up from ${observer.state}&quot;) observer.dispatchEvent(lifecycleOwner, event) popParentState() } }}private fun backwardPass(lifecycleOwner: LifecycleOwner) { val descendingIterator = observerMap.descendingIterator() while (descendingIterator.hasNext() &amp;&amp; !newEventOccurred) { val (key, observer) = descendingIterator.next() while (observer.state &gt; state &amp;&amp; !newEventOccurred &amp;&amp; observerMap.contains(key) ) { val event = Event.downFrom(observer.state) ?: throw IllegalStateException(&quot;no event down from ${observer.state}&quot;) pushParentState(event.targetState) observer.dispatchEvent(lifecycleOwner, event) popParentState() } }} 这里看到sync被调用后，就会根据observer的情况和state的不同，按照需要将state的变化传递给observer ObserverWithState12345678910111213141516internal class ObserverWithState(observer: LifecycleObserver?, initialState: State) { var state: State var lifecycleObserver: LifecycleEventObserver init { lifecycleObserver = Lifecycling.lifecycleEventObserver(observer!!) state = initialState } fun dispatchEvent(owner: LifecycleOwner?, event: Event) { val newState = event.targetState state = min(state, newState) lifecycleObserver.onStateChanged(owner!!, event) state = newState }} 首先这里看到一个关键的函数调用onStateChanged，也就是当dispatchEvent被调用时，state的改变就会传递给observer setCurrentState作用1234567891011override var currentState: State get() = state /** * Moves the Lifecycle to the given state and dispatches necessary events to the observers. * * @param state new state */ set(state) { enforceMainThreadIfNeeded(&quot;setCurrentState&quot;) moveToState(state) } 1234567891011121314151617181920private fun moveToState(next: State) { if (state == next) { return } check(!(state == State.INITIALIZED &amp;&amp; next == State.DESTROYED)) { &quot;no event down from $state in component ${lifecycleOwner.get()}&quot; } state = next if (handlingEvent || addingObserverCounter != 0) { newEventOccurred = true // we will figure out what to do on upper level. return } handlingEvent = true sync() handlingEvent = false if (state == State.DESTROYED) { observerMap = FastSafeIterableMap() }} 可以看到这里对state进行一定逻辑判断后，调用了sync，也就是当前state的改变会传递给observer activity传递state的方式看起来还是通过setCurrentState，但是并没有在CompinentActivity中的各个生命周期函数中调用 ObserverWithState如何处理两种LifecycleObserver1234init { lifecycleObserver = Lifecycling.lifecycleEventObserver(observer!!) state = initialState} 可以看到构造函数中将observer通过Lifecycling.lifecycleEventObserver对observer进行了包装 1234567891011121314151617181920212223242526272829303132public fun lifecycleEventObserver(`object`: Any): LifecycleEventObserver { val isLifecycleEventObserver = `object` is LifecycleEventObserver val isDefaultLifecycleObserver = `object` is DefaultLifecycleObserver if (isLifecycleEventObserver &amp;&amp; isDefaultLifecycleObserver) { return DefaultLifecycleObserverAdapter( `object` as DefaultLifecycleObserver, `object` as LifecycleEventObserver ) } if (isDefaultLifecycleObserver) { return DefaultLifecycleObserverAdapter(`object` as DefaultLifecycleObserver, null) } if (isLifecycleEventObserver) { return `object` as LifecycleEventObserver } val klass: Class&lt;*&gt; = `object`.javaClass val type = getObserverConstructorType(klass) if (type == GENERATED_CALLBACK) { val constructors = classToAdapters[klass]!! if (constructors.size == 1) { val generatedAdapter = createGeneratedAdapter( constructors[0], `object` ) return SingleGeneratedAdapterObserver(generatedAdapter) } val adapters: Array&lt;GeneratedAdapter&gt; = Array(constructors.size) { i -&gt; createGeneratedAdapter(constructors[i], `object`) } return CompositeGeneratedAdaptersObserver(adapters) } return ReflectiveGenericLifecycleObserver(`object`)} 可以看到这里会判断observer的类型，如果是DefaultLifecycleObserver，则会使用DefaultLifecycleObserverAdapter对observer进行适配 这里可以看到，适配器考虑到了Observer即是LifecycleEventObserver又是DefaultLifecycleObserver的情况 DefaultLifecycleObserverAdapter123456789101112131415161718internal class DefaultLifecycleObserverAdapter( private val defaultLifecycleObserver: DefaultLifecycleObserver, private val lifecycleEventObserver: LifecycleEventObserver?) : LifecycleEventObserver { override fun onStateChanged(source: LifecycleOwner, event: Lifecycle.Event) { when (event) { Lifecycle.Event.ON_CREATE -&gt; defaultLifecycleObserver.onCreate(source) Lifecycle.Event.ON_START -&gt; defaultLifecycleObserver.onStart(source) Lifecycle.Event.ON_RESUME -&gt; defaultLifecycleObserver.onResume(source) Lifecycle.Event.ON_PAUSE -&gt; defaultLifecycleObserver.onPause(source) Lifecycle.Event.ON_STOP -&gt; defaultLifecycleObserver.onStop(source) Lifecycle.Event.ON_DESTROY -&gt; defaultLifecycleObserver.onDestroy(source) Lifecycle.Event.ON_ANY -&gt; throw IllegalArgumentException(&quot;ON_ANY must not been send by anybody&quot;) } lifecycleEventObserver?.onStateChanged(source, event) }} 这里就很清晰了，DefaultLifecycleObserverAdapter根据当前的state调用DefaultLifecycleObserver的各个回调 handleLifecycleEvent123456789101112/** * Sets the current state and notifies the observers. * * Note that if the `currentState` is the same state as the last call to this method, * calling this method has no effect. * * @param event The event that was received */open fun handleLifecycleEvent(event: Event) { enforceMainThreadIfNeeded(&quot;handleLifecycleEvent&quot;) moveToState(event.targetState)} 这里看到handleLifecycleEvent也有设置state的作用 Activity生命周期相关函数回调结构定义12private final ArrayList&lt;Application.ActivityLifecycleCallbacks&gt; mActivityLifecycleCallbacks = new ArrayList&lt;Application.ActivityLifecycleCallbacks&gt;(); 此处定义了一个回调的接口List 注册与删除12345678910111213public void registerActivityLifecycleCallbacks( @NonNull Application.ActivityLifecycleCallbacks callback) { synchronized (mActivityLifecycleCallbacks) { mActivityLifecycleCallbacks.add(callback); }}public void unregisterActivityLifecycleCallbacks( @NonNull Application.ActivityLifecycleCallbacks callback) { synchronized (mActivityLifecycleCallbacks) { mActivityLifecycleCallbacks.remove(callback); }} 回调list转数组123456789private Object[] collectActivityLifecycleCallbacks() { Object[] callbacks = null; synchronized (mActivityLifecycleCallbacks) { if (mActivityLifecycleCallbacks.size() &gt; 0) { callbacks = mActivityLifecycleCallbacks.toArray(); } } return callbacks;} 下面介绍的dispatchActivityXXX函数将调用collectActivityLifecycleCallbacks获取所有callbacks，然后调用callbacks的onActivityXXX函数 dispatchActivityPreCreated12345678910private void dispatchActivityPreCreated(@Nullable Bundle savedInstanceState) { getApplication().dispatchActivityPreCreated(this, savedInstanceState); Object[] callbacks = collectActivityLifecycleCallbacks(); if (callbacks != null) { for (int i = 0; i &lt; callbacks.length; i++) { ((Application.ActivityLifecycleCallbacks) callbacks[i]).onActivityPreCreated(this, savedInstanceState); } }} dispatchActivityCreated12345678910private void dispatchActivityCreated(@Nullable Bundle savedInstanceState) { getApplication().dispatchActivityCreated(this, savedInstanceState); Object[] callbacks = collectActivityLifecycleCallbacks(); if (callbacks != null) { for (int i = 0; i &lt; callbacks.length; i++) { ((Application.ActivityLifecycleCallbacks) callbacks[i]).onActivityCreated(this, savedInstanceState); } }} dispatchActivityPostCreated12345678910private void dispatchActivityPostCreated(@Nullable Bundle savedInstanceState) { Object[] callbacks = collectActivityLifecycleCallbacks(); if (callbacks != null) { for (int i = 0; i &lt; callbacks.length; i++) { ((Application.ActivityLifecycleCallbacks) callbacks[i]).onActivityPostCreated(this, savedInstanceState); } } getApplication().dispatchActivityPostCreated(this, savedInstanceState);} 每段代码几乎是一样的，就不全贴上来了 没贴上来的还有 dispatchActivityPreStarted, dispatchActivityStarted, dispatchActivityPostStarted dispatchActivityPreResumed, dispatchActivityResumed, dispatchActivityPostResumed dispatchActivityPrePaused, dispatchActivityPaused, dispatchActivityPostPaused dispatchActivitySaveInstanceState, dispatchActivitySaveInstanceState, dispatchActivityPostSaveInstanceState dispatchActivityPreDestroyed, dispatchActivityDestroyed, dispatchActivityPostDestroyed dispatchActivityConfigurationChanged ReportFragment reportFragment负责传递Activity的生命周期 ReportFragment的初始化1234override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) ReportFragment.injectIfNeededIn(this)} 12345678910111213141516fun injectIfNeededIn(activity: Activity) { if (Build.VERSION.SDK_INT &gt;= 29) { // On API 29+, we can register for the correct Lifecycle callbacks directly LifecycleCallbacks.registerIn(activity) } // Prior to API 29 and to maintain compatibility with older versions of // ProcessLifecycleOwner (which may not be updated when lifecycle-runtime is updated and // need to support activities that don't extend from FragmentActivity from support lib), // use a framework fragment to get the correct timing of Lifecycle events val manager = activity.fragmentManager if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) { manager.beginTransaction().add(ReportFragment(), REPORT_FRAGMENT_TAG).commit() // Hopefully, we are the first to make a transaction. manager.executePendingTransactions() }} api29之后，会使用LifecycleCallbacks.registerIn 另外还会使用ReportFragment来报告activity的生命周期 ReportFragment分发生命周期(API 29之前)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private var processListener: ActivityInitializationListener? = nullprivate fun dispatchCreate(listener: ActivityInitializationListener?) { listener?.onCreate()}private fun dispatchStart(listener: ActivityInitializationListener?) { listener?.onStart()}private fun dispatchResume(listener: ActivityInitializationListener?) { listener?.onResume()}override fun onActivityCreated(savedInstanceState: Bundle?) { super.onActivityCreated(savedInstanceState) dispatchCreate(processListener) dispatch(Lifecycle.Event.ON_CREATE)}override fun onStart() { super.onStart() dispatchStart(processListener) dispatch(Lifecycle.Event.ON_START)}override fun onResume() { super.onResume() dispatchResume(processListener) dispatch(Lifecycle.Event.ON_RESUME)}override fun onPause() { super.onPause() dispatch(Lifecycle.Event.ON_PAUSE)}override fun onStop() { super.onStop() dispatch(Lifecycle.Event.ON_STOP)}override fun onDestroy() { super.onDestroy() dispatch(Lifecycle.Event.ON_DESTROY) // just want to be sure that we won't leak reference to an activity processListener = null} 可以看到，当Fragment的声明周期函数被调用时，会调用dispatch，将activity的生命周期进行传递 dispatch123456789101112131415161718192021private fun dispatch(event: Lifecycle.Event) { if (Build.VERSION.SDK_INT &lt; 29) { // Only dispatch events from ReportFragment on API levels prior // to API 29. On API 29+, this is handled by the ActivityLifecycleCallbacks // added in ReportFragment.injectIfNeededIn dispatch(activity, event) }}internal fun dispatch(activity: Activity, event: Lifecycle.Event) { if (activity is LifecycleRegistryOwner) { activity.lifecycle.handleLifecycleEvent(event) return } if (activity is LifecycleOwner) { val lifecycle = (activity as LifecycleOwner).lifecycle if (lifecycle is LifecycleRegistry) { lifecycle.handleLifecycleEvent(event) } }} 仅在api 29之前通过ReportFragment来进行activity的生命周期传递 这里就可以看到上面分析的LifecycleRegistry类了，获取activity中的lifecycle再调用handleLifecycleEvent来更新activity的生命周期，进而将生命周期改变传递给listener API 29及以后Activity分发生命周期回到ReportFragment1234567fun injectIfNeededIn(activity: Activity) { if (Build.VERSION.SDK_INT &gt;= 29) { // On API 29+, we can register for the correct Lifecycle callbacks directly LifecycleCallbacks.registerIn(activity) } // ...} 大于等于Api 29时，会调用registerIn registerIn1234@JvmStaticfun registerIn(activity: Activity) { activity.registerActivityLifecycleCallbacks(LifecycleCallbacks())} 这里看到，调用了activity的registerActivityLifecycleCallbacks，activity会在发生生命周期改变时调用回调LifecycleCallbacks LifecycleCallbacks12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455internal class LifecycleCallbacks : Application.ActivityLifecycleCallbacks { override fun onActivityCreated( activity: Activity, bundle: Bundle? ) {} override fun onActivityPostCreated( activity: Activity, savedInstanceState: Bundle? ) { dispatch(activity, Lifecycle.Event.ON_CREATE) } override fun onActivityStarted(activity: Activity) {} override fun onActivityPostStarted(activity: Activity) { dispatch(activity, Lifecycle.Event.ON_START) } override fun onActivityResumed(activity: Activity) {} override fun onActivityPostResumed(activity: Activity) { dispatch(activity, Lifecycle.Event.ON_RESUME) } override fun onActivityPrePaused(activity: Activity) { dispatch(activity, Lifecycle.Event.ON_PAUSE) } override fun onActivityPaused(activity: Activity) {} override fun onActivityPreStopped(activity: Activity) { dispatch(activity, Lifecycle.Event.ON_STOP) } override fun onActivityStopped(activity: Activity) {} override fun onActivitySaveInstanceState( activity: Activity, bundle: Bundle ) {} override fun onActivityPreDestroyed(activity: Activity) { dispatch(activity, Lifecycle.Event.ON_DESTROY) } override fun onActivityDestroyed(activity: Activity) {} companion object { @JvmStatic fun registerIn(activity: Activity) { activity.registerActivityLifecycleCallbacks(LifecycleCallbacks()) } }} 这里看到LifecycleCallbacks调用了dispatch()函数，将activity的生命周期进行了分发 Fragment的lifecycle实现LifecycleOwner12345678public class Fragment implements ComponentCallbacks, OnCreateContextMenuListener, LifecycleOwner, ViewModelStoreOwner, HasDefaultViewModelProviderFactory, SavedStateRegistryOwner, ActivityResultCaller { @Override @NonNull public Lifecycle getLifecycle() { return mLifecycleRegistry; } 初始化Lifecycle12345678910111213public Fragment() { initLifecycle();}private void initLifecycle() { mLifecycleRegistry = new LifecycleRegistry(this); mSavedStateRegistryController = SavedStateRegistryController.create(this); // The default factory depends on the SavedStateRegistry so it // needs to be reset when the SavedStateRegistry is reset mDefaultFactory = null; if (!mOnPreAttachedListeners.contains(mSavedStateAttachListener)) { registerOnPreAttachListener(mSavedStateAttachListener); }} 传递事件fragment的生命周期传递比较简单，就是在fragment各个生命周期时调用handleLifecycleEvent 1234567891011121314151617181920212223void performCreate(Bundle savedInstanceState) { mChildFragmentManager.noteStateNotSaved(); mState = CREATED; mCalled = false; mLifecycleRegistry.addObserver(new LifecycleEventObserver() { @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) { if (event == Lifecycle.Event.ON_STOP) { if (mView != null) { mView.cancelPendingInputEvents(); } } } }); onCreate(savedInstanceState); mIsCreated = true; if (!mCalled) { throw new SuperNotCalledException(&quot;Fragment &quot; + this + &quot; did not call through to super.onCreate()&quot;); } mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);} 12345678910111213141516void performStart() { mChildFragmentManager.noteStateNotSaved(); mChildFragmentManager.execPendingActions(true); mState = STARTED; mCalled = false; onStart(); if (!mCalled) { throw new SuperNotCalledException(&quot;Fragment &quot; + this + &quot; did not call through to super.onStart()&quot;); } mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START); if (mView != null) { mViewLifecycleOwner.handleLifecycleEvent(Lifecycle.Event.ON_START); } mChildFragmentManager.dispatchStart();} 12345678910111213141516void performResume() { mChildFragmentManager.noteStateNotSaved(); mChildFragmentManager.execPendingActions(true); mState = RESUMED; mCalled = false; onResume(); if (!mCalled) { throw new SuperNotCalledException(&quot;Fragment &quot; + this + &quot; did not call through to super.onResume()&quot;); } mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME); if (mView != null) { mViewLifecycleOwner.handleLifecycleEvent(Lifecycle.Event.ON_RESUME); } mChildFragmentManager.dispatchResume();} 1234567891011121314void performPause() { mChildFragmentManager.dispatchPause(); if (mView != null) { mViewLifecycleOwner.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE); } mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE); mState = AWAITING_ENTER_EFFECTS; mCalled = false; onPause(); if (!mCalled) { throw new SuperNotCalledException(&quot;Fragment &quot; + this + &quot; did not call through to super.onPause()&quot;); }} 1234567891011121314void performStop() { mChildFragmentManager.dispatchStop(); if (mView != null) { mViewLifecycleOwner.handleLifecycleEvent(Lifecycle.Event.ON_STOP); } mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP); mState = ACTIVITY_CREATED; mCalled = false; onStop(); if (!mCalled) { throw new SuperNotCalledException(&quot;Fragment &quot; + this + &quot; did not call through to super.onStop()&quot;); }} 123456789101112void performDestroy() { mChildFragmentManager.dispatchDestroy(); mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY); mState = ATTACHED; mCalled = false; mIsCreated = false; onDestroy(); if (!mCalled) { throw new SuperNotCalledException(&quot;Fragment &quot; + this + &quot; did not call through to super.onDestroy()&quot;); }}","link":"/home/2024/07/31/Android%E9%AB%98%E7%BA%A7/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E5%9F%BA%E7%A1%8003-Lifecycle/"},{"title":"基础04-LiveData","text":"LiveDataLiveData的观察者1234567fun interface Observer&lt;T&gt; { /** * Called when the data is changed to [value]. */ fun onChanged(value: T)} 通过onChanged函数分派数据变化 成员123456789101112131415161718192021222324252627282930313233343536@SuppressWarnings(&quot;WeakerAccess&quot;) /* synthetic access */final Object mDataLock = new Object();static final int START_VERSION = -1;@SuppressWarnings(&quot;WeakerAccess&quot;) /* synthetic access */static final Object NOT_SET = new Object();private SafeIterableMap&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt; mObservers = new SafeIterableMap&lt;&gt;();// how many observers are in active state@SuppressWarnings(&quot;WeakerAccess&quot;) /* synthetic access */int mActiveCount = 0;// to handle active/inactive reentry, we guard with this booleanprivate boolean mChangingActiveState;private volatile Object mData; // 1️⃣：当前的data// when setData is called, we set the pending data and actual data swap happens on the main// thread@SuppressWarnings(&quot;WeakerAccess&quot;) /* synthetic access */volatile Object mPendingData = NOT_SET; // 2️⃣：给多线程使用的，在4️⃣mPostValueRunnable中使用private int mVersion; // 3️⃣：mVersion是数据版本private boolean mDispatchingValue;@SuppressWarnings(&quot;FieldCanBeLocal&quot;)private boolean mDispatchInvalidated;private final Runnable mPostValueRunnable = new Runnable() {// 4️⃣mPostValueRunnable，在主线程中将mPendingData设置为当前值 @SuppressWarnings(&quot;unchecked&quot;) @Override public void run() { Object newValue; synchronized (mDataLock) { newValue = mPendingData; mPendingData = NOT_SET; } setValue((T) newValue); }}; 数据存在mData中 mPendingData给多线程使用的，在mPostValueRunnable时设置为当前值 mVersion是数据版本 mPostValueRunnable，在主线程中将mPendingData设置为当前值 构造123456789public LiveData(T value) { mData = value; mVersion = START_VERSION + 1;}public LiveData() { mData = NOT_SET; mVersion = START_VERSION;} get 和 set1234567891011121314151617181920212223242526272829@MainThreadprotected void setValue(T value) { assertMainThread(&quot;setValue&quot;); mVersion++; mData = value; dispatchingValue(null);}@SuppressWarnings(&quot;unchecked&quot;)@Nullablepublic T getValue() { Object data = mData; if (data != NOT_SET) { return (T) data; } return null;}protected void postValue(T value) { boolean postTask; synchronized (mDataLock) { postTask = mPendingData == NOT_SET; mPendingData = value; } if (!postTask) { return; } ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);} 每次set,mVersion都会自增1，并调用dispatchingValue 非主线程中调用postValue在主线程中更新值, mPendingData是被异步更新的，但最终mData都在主线程中被set postValue和mPostValueRunnable更新mPendingData时先获取mDataLock对象的锁，runnable执行后会将mPendingData设置为NOT_SET。如果postValue时mPendingData不是NOT_SET，就不会重复post runnable 分派事件dispatchingValue123456789101112131415161718192021222324@SuppressWarnings(&quot;WeakerAccess&quot;) /* synthetic access */void dispatchingValue(@Nullable ObserverWrapper initiator) { if (mDispatchingValue) { mDispatchInvalidated = true; return; } mDispatchingValue = true; do { mDispatchInvalidated = false; if (initiator != null) { considerNotify(initiator); initiator = null; } else { for (Iterator&lt;Map.Entry&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt;&gt; iterator = mObservers.iteratorWithAdditions(); iterator.hasNext(); ) { considerNotify(iterator.next().getValue()); if (mDispatchInvalidated) { break; } } } } while (mDispatchInvalidated); mDispatchingValue = false;} 如果当前正在分派，则退出，并通过mDispatchInvalidated打断后续分派 如果参数不空，则只分派给参数，否则分派给所有observer considerNotify12345678910111213141516171819private void considerNotify(ObserverWrapper observer) { if (!observer.mActive) { return; } // Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet. // // we still first check observer.active to keep it as the entrance for events. So even if // the observer moved to an active state, if we've not received that event, we better not // notify for a more predictable notification order. if (!observer.shouldBeActive()) { observer.activeStateChanged(false); return; } if (observer.mLastVersion &gt;= mVersion) { return; } observer.mLastVersion = mVersion; observer.mObserver.onChanged((T) mData);} 如果observer非active状态，不分派 如果observer上次的数据版本大于当前版本，不分派 更新observer的数据版本 调用observer的onChanged分派数据变化 ObserverWrapper12345678910111213141516171819202122232425262728293031private abstract class ObserverWrapper { final Observer&lt;? super T&gt; mObserver; boolean mActive; int mLastVersion = START_VERSION; ObserverWrapper(Observer&lt;? super T&gt; observer) { mObserver = observer; } abstract boolean shouldBeActive(); boolean isAttachedTo(LifecycleOwner owner) { return false; } void detachObserver() { } void activeStateChanged(boolean newActive) { if (newActive == mActive) { return; } // immediately set active state, so we'd never dispatch anything to inactive // owner mActive = newActive; changeActiveCounter(mActive ? 1 : -1); if (mActive) { dispatchingValue(this); } }} 对Observer进行包装，记录了当前的数据version和active状态 当activeStateChanged被调用时，首先判断与原来的active状态是否一致，如果一致，则直接返回 如果不一致，则更新active状态，并调用外部类(LiveData)的changeActiveCounter 如果当前active状态从false变为true，则调用dispatchingValue，立刻向观察者传递最新的数据状态 changeActiveCounter1234567891011121314151617181920212223@MainThreadvoid changeActiveCounter(int change) { int previousActiveCount = mActiveCount; mActiveCount += change; if (mChangingActiveState) { return; } mChangingActiveState = true; try { while (previousActiveCount != mActiveCount) { boolean needToCallActive = previousActiveCount == 0 &amp;&amp; mActiveCount &gt; 0; boolean needToCallInactive = previousActiveCount &gt; 0 &amp;&amp; mActiveCount == 0; previousActiveCount = mActiveCount; if (needToCallActive) { onActive(); } else if (needToCallInactive) { onInactive(); } } } finally { mChangingActiveState = false; }} 会保存当前状态为active的observer的数量 这个函数会更新其值 如果原来active的个数为0，现在大于0，那么调用onActive 如果原来active的个数大于0，现在为0，那么调用onInactive onActive和onInactive123456protected void onInactive() {}protected void onActive() {} 给子类用的钩子方法，用于通知当前是否有active的observer AlwaysActiveObserver1234567891011private class AlwaysActiveObserver extends ObserverWrapper { AlwaysActiveObserver(Observer&lt;? super T&gt; observer) { super(observer); } @Override boolean shouldBeActive() { return true; }} 这类Observer会一直处于active状态 observeForever会创建AlwaysActiveObserver，创建后立刻调用activeStateChanged(true)更新active状态，active总数 添加AlwaysActiveObserver12345678910111213public void observeForever(@NonNull Observer&lt;? super T&gt; observer) { assertMainThread(&quot;observeForever&quot;); AlwaysActiveObserver wrapper = new AlwaysActiveObserver(observer); ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); if (existing instanceof LiveData.LifecycleBoundObserver) { throw new IllegalArgumentException(&quot;Cannot add the same observer&quot; + &quot; with different lifecycles&quot;); } if (existing != null) { return; } wrapper.activeStateChanged(true);} LifecycleBoundObserver12345678910111213141516171819202122232425262728293031323334353637383940class LifecycleBoundObserver extends ObserverWrapper implements LifecycleEventObserver { @NonNull final LifecycleOwner mOwner; LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer&lt;? super T&gt; observer) { super(observer); mOwner = owner; } @Override boolean shouldBeActive() { return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED); } @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) { Lifecycle.State currentState = mOwner.getLifecycle().getCurrentState(); if (currentState == DESTROYED) { removeObserver(mObserver); return; } Lifecycle.State prevState = null; while (prevState != currentState) { prevState = currentState; activeStateChanged(shouldBeActive()); currentState = mOwner.getLifecycle().getCurrentState(); } } @Override boolean isAttachedTo(LifecycleOwner owner) { return mOwner == owner; } @Override void detachObserver() { mOwner.getLifecycle().removeObserver(this); }} 同时实现了LifecycleEventObserver，可以观察lifecycle 保存对应的lifecycleOwner 根据shouldBeActive，当关联的Lifecycle到达了started及以后的状态，就是active的了 当lifecycle状态变化时 如果到了destroyed,则调用外部类的removeObserver移除当前observer 然后进一个循环，调用activeStateChanged更新当前的active状态，直到两次获取lifecycle的当前状态都相同时，退出循环 添加一个LifecycleBoundObserver123456789101112131415161718@MainThreadpublic void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) { assertMainThread(&quot;observe&quot;); if (owner.getLifecycle().getCurrentState() == DESTROYED) { // ignore return; } LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer); ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); if (existing != null &amp;&amp; !existing.isAttachedTo(owner)) { throw new IllegalArgumentException(&quot;Cannot add the same observer&quot; + &quot; with different lifecycles&quot;); } if (existing != null) { return; } owner.getLifecycle().addObserver(wrapper);} 创建LifecycleBoundObserver，并立刻将其注册到lifecycle的observer中 lifecycle添加observer后，会立刻传递状态，这里也可以立刻根据lifecycle的状态更新active状态，进而向观察者分派当前值 移除observer1234567891011121314151617181920212223242526@MainThreadpublic void removeObserver(@NonNull final Observer&lt;? super T&gt; observer) { assertMainThread(&quot;removeObserver&quot;); ObserverWrapper removed = mObservers.remove(observer); if (removed == null) { return; } removed.detachObserver(); removed.activeStateChanged(false);}/** * Removes all observers that are tied to the given {@link LifecycleOwner}. * * @param owner The {@code LifecycleOwner} scope for the observers to be removed. */@SuppressWarnings(&quot;WeakerAccess&quot;)@MainThreadpublic void removeObservers(@NonNull final LifecycleOwner owner) { assertMainThread(&quot;removeObservers&quot;); for (Map.Entry&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt; entry : mObservers) { if (entry.getValue().isAttachedTo(owner)) { removeObserver(entry.getKey()); } }} 从map中删除observer 调用activeStateChanged(false), 将其active状态变成false，减少活跃状态的数量，按需调用onInactive(), 调用detachObserver，如果是LifecycleBoundObserver，就停止从lifecycle中观察状态。 MutableLiveData1234567891011121314151617181920212223242526272829@SuppressWarnings(&quot;WeakerAccess&quot;)public class MutableLiveData&lt;T&gt; extends LiveData&lt;T&gt; { /** * Creates a MutableLiveData initialized with the given {@code value}. * * @param value initial value */ public MutableLiveData(T value) { super(value); } /** * Creates a MutableLiveData with no value assigned to it. */ public MutableLiveData() { super(); } @Override public void postValue(T value) { super.postValue(value); } @Override public void setValue(T value) { super.setValue(value); }} 好猫猫简洁 postValue和setValue升级成public了 MediatorLiveData 配置多个更新源LiveData，当观察到一个LiveData发生改变，则执行相应的动作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107public class MediatorLiveData&lt;T&gt; extends MutableLiveData&lt;T&gt; { private SafeIterableMap&lt;LiveData&lt;?&gt;, Source&lt;?&gt;&gt; mSources = new SafeIterableMap&lt;&gt;(); /** * Creates a MediatorLiveData with no value assigned to it. */ public MediatorLiveData() { super(); } /** * Creates a MediatorLiveData initialized with the given {@code value}. * * @param value initial value */ public MediatorLiveData(T value) { super(value); } /** * Starts to listen to the given {@code source} LiveData, {@code onChanged} observer will be * called when {@code source} value was changed. * &lt;p&gt; * {@code onChanged} callback will be called only when this {@code MediatorLiveData} is active. * &lt;p&gt; If the given LiveData is already added as a source but with a different Observer, * {@link IllegalArgumentException} will be thrown. * * @param source the {@code LiveData} to listen to * @param onChanged The observer that will receive the events * @param &lt;S&gt; The type of data hold by {@code source} LiveData */ @MainThread public &lt;S&gt; void addSource(@NonNull LiveData&lt;S&gt; source, @NonNull Observer&lt;? super S&gt; onChanged) { if (source == null) { throw new NullPointerException(&quot;source cannot be null&quot;); } Source&lt;S&gt; e = new Source&lt;&gt;(source, onChanged); Source&lt;?&gt; existing = mSources.putIfAbsent(source, e); if (existing != null &amp;&amp; existing.mObserver != onChanged) { throw new IllegalArgumentException( &quot;This source was already added with the different observer&quot;); } if (existing != null) { return; } if (hasActiveObservers()) { e.plug(); } } /** * Stops to listen the given {@code LiveData}. * * @param toRemote {@code LiveData} to stop to listen * @param &lt;S&gt; the type of data hold by {@code source} LiveData */ @MainThread public &lt;S&gt; void removeSource(@NonNull LiveData&lt;S&gt; toRemote) { Source&lt;?&gt; source = mSources.remove(toRemote); if (source != null) { source.unplug(); } } @CallSuper @Override protected void onActive() { for (Map.Entry&lt;LiveData&lt;?&gt;, Source&lt;?&gt;&gt; source : mSources) { source.getValue().plug(); } } @CallSuper @Override protected void onInactive() { for (Map.Entry&lt;LiveData&lt;?&gt;, Source&lt;?&gt;&gt; source : mSources) { source.getValue().unplug(); } } private static class Source&lt;V&gt; implements Observer&lt;V&gt; { final LiveData&lt;V&gt; mLiveData; final Observer&lt;? super V&gt; mObserver; int mVersion = START_VERSION; Source(LiveData&lt;V&gt; liveData, final Observer&lt;? super V&gt; observer) { mLiveData = liveData; mObserver = observer; } void plug() { mLiveData.observeForever(this); } void unplug() { mLiveData.removeObserver(this); } @Override public void onChanged(@Nullable V v) { if (mVersion != mLiveData.getVersion()) { mVersion = mLiveData.getVersion(); mObserver.onChanged(v); } } }} 感觉就是帮我们observeForever，没什么特殊的 CoroutineLiveData 这种livedata提供给一个执行异步的协程，在携程中进行耗时操作，通过emit, emitSource发送数据，给观察者进行观察 其他的使用方法和LiveData一样，对其进行观察，当数据变化时，接收到数据变化 使用方法 emit: 1234567891011121314// a LiveData that tries to load the `User` from local cache first and then tries to fetch// from the server and also yields the updated valueval user = liveData { // check local storage val cached = cache.loadUser(id) if (cached != null) { emit(cached) } if (cached == null || cached.isStale()) { val fresh = api.fetch(id) // errors are ignored for brevity cache.save(fresh) emit(fresh) }} 这里liveData函数产生了一个LiveData，并提供了一个代码块，这个代码块回进行耗时操作，通过emit函数更新LiveData的数据 几个问题 代码块何时执行？ emit如何更新数据？ 12345678// a LiveData that immediately receives a LiveData&lt;User&gt; from the database and yields it as a// source but also tries to back-fill the database from the serverval user = liveData { val fromDb: LiveData&lt;User&gt; = roomDatabase.loadUser(id) emitSource(fromDb) val updated = api.fetch(id) // errors are ignored for brevity roomDatabase.insert(updated)} 从数据库读取User类型的数据，返回fromDb，然后通过emitSource观察该fromDb，当fromDb更新时，更新user 同时执行其他相关的，数据库更新操作 123456789101112131415161718192021public fun &lt;T&gt; liveData( context: CoroutineContext = EmptyCoroutineContext, timeoutInMs: Long = DEFAULT_TIMEOUT, block: suspend LiveDataScope&lt;T&gt;.() -&gt; Unit): LiveData&lt;T&gt; = CoroutineLiveData(context, timeoutInMs, block)// 支持Duration的Api@RequiresApi(Build.VERSION_CODES.O)@JvmOverloadspublic fun &lt;T&gt; liveData( timeout: Duration, context: CoroutineContext = EmptyCoroutineContext, block: suspend LiveDataScope&lt;T&gt;.() -&gt; Unit): LiveData&lt;T&gt; = CoroutineLiveData(context, Api26Impl.toMillis(timeout), block)@RequiresApi(26)internal object Api26Impl { fun toMillis(timeout: Duration): Long { return timeout.toMillis() }} 可以传入一个CoroutineContext，用于指定协程的执行环境，默认是EmptyCoroutineContext 可以传入一个timeoutInMs，具体作用下面再说 CoroutineLiveData1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950internal class CoroutineLiveData&lt;T&gt;( context: CoroutineContext = EmptyCoroutineContext, timeoutInMs: Long = DEFAULT_TIMEOUT, block: Block&lt;T&gt;) : MediatorLiveData&lt;T&gt;() { private var blockRunner: BlockRunner&lt;T&gt;? private var emittedSource: EmittedSource? = null init { // use an intermediate supervisor job so that if we cancel individual block runs due to losing // observers, it won't cancel the given context as we only cancel w/ the intention of possibly // relaunching using the same parent context. val supervisorJob = SupervisorJob(context[Job]) // The scope for this LiveData where we launch every block Job. // We default to Main dispatcher but developer can override it. // The supervisor job is added last to isolate block runs. val scope = CoroutineScope(Dispatchers.Main.immediate + context + supervisorJob) blockRunner = BlockRunner( liveData = this, block = block, timeoutInMs = timeoutInMs, scope = scope ) { blockRunner = null } } internal suspend fun emitSource(source: LiveData&lt;T&gt;): DisposableHandle { clearSource() val newSource = addDisposableSource(source) emittedSource = newSource return newSource } internal suspend fun clearSource() { emittedSource?.disposeNow() emittedSource = null } override fun onActive() { super.onActive() blockRunner?.maybeRun() } override fun onInactive() { super.onInactive() blockRunner?.cancel() }} onActive和onInactive两个函数的内容标明，代码块会在活跃观察者数量大于1时开始执行，没有活跃观察者时被cancel 注意到CoroutineLiveData是一个MediatorLiveData，下面要考 Block的运行和取消12345678910111213141516171819202122232425262728293031323334353637383940414243internal class BlockRunner&lt;T&gt;( private val liveData: CoroutineLiveData&lt;T&gt;, private val block: Block&lt;T&gt;, private val timeoutInMs: Long, private val scope: CoroutineScope, private val onDone: () -&gt; Unit) { // currently running block job. private var runningJob: Job? = null // cancelation job created in cancel. private var cancellationJob: Job? = null @MainThread fun maybeRun() { cancellationJob?.cancel() cancellationJob = null if (runningJob != null) { return } runningJob = scope.launch { val liveDataScope = LiveDataScopeImpl(liveData, coroutineContext) block(liveDataScope) onDone() } } @MainThread fun cancel() { if (cancellationJob != null) { error(&quot;Cancel call cannot happen without a maybeRun&quot;) } cancellationJob = scope.launch(Dispatchers.Main.immediate) { delay(timeoutInMs) if (!liveData.hasActiveObservers()) { // one last check on active observers to avoid any race condition between starting // a running coroutine and cancelation runningJob?.cancel() runningJob = null } } }} maybeRun很简单，就是在指定的scope中启动一个协程，执行block cancel也很简单，就是在协程中先等待一段时间，然后判断是否有活跃的观察者，如果没有，则取消runningJob 我们观察到block是LiveDataScope的扩展函数，对应的具体实现类是LiveDataScopeImpl LiveDataScope12345678910111213141516171819202122232425262728293031323334353637public interface LiveDataScope&lt;T&gt; { /** * Set's the [LiveData]'s value to the given [value]. If you've called [emitSource] previously, * calling [emit] will remove that source. * * Note that this function suspends until the value is set on the [LiveData]. * * @param value The new value for the [LiveData] * * @see emitSource */ public suspend fun emit(value: T) /** * Add the given [LiveData] as a source, similar to [MediatorLiveData.addSource]. Calling this * method will remove any source that was yielded before via [emitSource]. * * @param source The [LiveData] instance whose values will be dispatched from the current * [LiveData]. * * @see emit * @see MediatorLiveData.addSource * @see MediatorLiveData.removeSource */ public suspend fun emitSource(source: LiveData&lt;T&gt;): DisposableHandle /** * References the current value of the [LiveData]. * * If the block never `emit`ed a value, [latestValue] will be `null`. You can use this * value to check what was then latest value `emit`ed by your `block` before it got cancelled. * * Note that if the block called [emitSource], then `latestValue` will be last value * dispatched by the `source` [LiveData]. */ public val latestValue: T?} 定义了emit函数和emitSource函数 LiveDataScopeImpl1234567891011121314151617181920212223internal class LiveDataScopeImpl&lt;T&gt;( internal var target: CoroutineLiveData&lt;T&gt;, context: CoroutineContext) : LiveDataScope&lt;T&gt; { override val latestValue: T? get() = target.value // use `liveData` provided context + main dispatcher to communicate with the target // LiveData. This gives us main thread safety as well as cancellation cooperation private val coroutineContext = context + Dispatchers.Main.immediate override suspend fun emitSource(source: LiveData&lt;T&gt;): DisposableHandle = withContext(coroutineContext) { return@withContext target.emitSource(source) } @SuppressLint(&quot;NullSafeMutableLiveData&quot;) override suspend fun emit(value: T) = withContext(coroutineContext) { target.clearSource() target.value = value }} emit函数的实现是调用CoroutineLiveData的clearSource,并更新LiveData值 emitSource的实现是在协程上下文中执行CoroutineLiveData的emitSource CoroutineLiveData的emitSource12345678910internal suspend fun clearSource() { emittedSource?.disposeNow() emittedSource = null}internal suspend fun emitSource(source: LiveData&lt;T&gt;): DisposableHandle { clearSource() val newSource = addDisposableSource(source) emittedSource = newSource return newSource} emitSource首先调用clearSource 将已发射的source进行dispose 创建新的emittedSource addDisposableSource1234567891011internal suspend fun &lt;T&gt; MediatorLiveData&lt;T&gt;.addDisposableSource( source: LiveData&lt;T&gt;): EmittedSource = withContext(Dispatchers.Main.immediate) { addSource(source) { value = it } EmittedSource( source = source, mediator = this@addDisposableSource )} CoroutineLiveData本身就是一个MediatorLiveData addDisposableSource时首先通过addSource为自身添加一个source 在该source变化时，更新自身的值 创建一个EmittedSource，并返回 CoroutineLiveData的clearSource1234internal suspend fun clearSource() { emittedSource?.disposeNow() emittedSource = null} EmittedSource12345678910111213141516171819202122232425262728internal class EmittedSource( private val source: LiveData&lt;*&gt;, private val mediator: MediatorLiveData&lt;*&gt;) : DisposableHandle { // @MainThread private var disposed = false /** * Unlike [dispose] which cannot be sync because it not a coroutine (and we do not want to * lock), this version is a suspend function and does not return until source is removed. */ suspend fun disposeNow() = withContext(Dispatchers.Main.immediate) { removeSource() } override fun dispose() { CoroutineScope(Dispatchers.Main.immediate).launch { removeSource() } } @MainThread private fun removeSource() { if (!disposed) { mediator.removeSource(source) disposed = true } }} emittedSource就是为了方便dispose而创建的，dispose就是把source移除 在block中，如果我们emitSource了，如果在未来某时刻，我们不再需要这个source了，可以调用emitSource返回的EmittedSource对象的dispose方法来移除 emit和emitSource存在互斥性，使用emit后，之前的source就会失效 PublisherLiveData rxjava兼容的livedata，使用rxjava的Publisher作为数据源","link":"/home/2024/08/06/Android%E9%AB%98%E7%BA%A7/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E5%9F%BA%E7%A1%8004-LiveData/"},{"title":"基础02-viewModel","text":"ViewModel简介在了解ViewModel之前，我们先来了解一下MVC, MVP, MVVM的发展Difference Between MVC, MVP and MVVM Architecture Pattern in Android ViewModelStoreOwner1234567interface ViewModelStoreOwner { /** * The owned [ViewModelStore] */ val viewModelStore: ViewModelStore} 实现了ViewModelStoreOwner的类会有一个viewModelStore属性 在创建ViewModel时会传递这个变量，具体传递方式在见by viewModels() 实现了ViewModelStoreOwner的直接子类有： ComponentActivity, Fragment 和 NavBackStackEntry ViewModelStore实际上就是维护了一个MutableMap&lt;String, ViewModel&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142open class ViewModelStore { private val map = mutableMapOf&lt;String, ViewModel&gt;() /** * @hide */ @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) fun put(key: String, viewModel: ViewModel) { val oldViewModel = map.put(key, viewModel) oldViewModel?.onCleared() } /** * Returns the `ViewModel` mapped to the given `key` or null if none exists. */ /** * @hide */ @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) operator fun get(key: String): ViewModel? { return map[key] } /** * @hide */ @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) fun keys(): Set&lt;String&gt; { return HashSet(map.keys) } /** * Clears internal storage and notifies `ViewModel`s that they are no longer used. */ fun clear() { for (vm in map.values) { vm.clear() } map.clear() }} 发现就是在对map读写，注意到put方法会调用同key值的旧ViewModel的onCleared onCleared并不执行任何操作，是提供给子类进行回收资源的回调。ViewModel真正进行资源回收（调用Closeable的close方法）的函数是clear，put中并没有调用，这是一个很奇怪的问题，具体的原因在下面会解释 那么这个key是什么呢，下面再看吧 by viewModels()ComponentActivity的viewModels()12345678910111213141516@MainThreadpublic inline fun &lt;reified VM : ViewModel&gt; ComponentActivity.viewModels( noinline extrasProducer: (() -&gt; CreationExtras)? = null, noinline factoryProducer: (() -&gt; Factory)? = null): Lazy&lt;VM&gt; { val factoryPromise = factoryProducer ?: { defaultViewModelProviderFactory } return ViewModelLazy( VM::class, { viewModelStore }, // 1️⃣ viewModelStore的传递在这里 factoryPromise, { extrasProducer?.invoke() ?: this.defaultViewModelCreationExtras } )} 可以看到viewModels()实际上是ComponentActivity的一个扩展方法，返回了ViewModelLazy对ViewModel的属性进行代理 ViewModelLazy12345678910111213141516171819202122232425262728public class ViewModelLazy&lt;VM : ViewModel&gt; @JvmOverloads constructor( private val viewModelClass: KClass&lt;VM&gt;, private val storeProducer: () -&gt; ViewModelStore, private val factoryProducer: () -&gt; ViewModelProvider.Factory, private val extrasProducer: () -&gt; CreationExtras = { CreationExtras.Empty }) : Lazy&lt;VM&gt; { private var cached: VM? = null override val value: VM get() { val viewModel = cached return if (viewModel == null) { val factory = factoryProducer() val store = storeProducer() ViewModelProvider( store, factory, extrasProducer() ).get(viewModelClass.java).also { cached = it } } else { viewModel } } override fun isInitialized(): Boolean = cached != null} 可以看到当属性首次get时会构造ViewModelProvider并调用get方法获取viewModel对象 ViewModelProviderViewModelProvider的get方法12345678910111213141516171819202122232425262728@MainThreadpublic open operator fun &lt;T : ViewModel&gt; get(modelClass: Class&lt;T&gt;): T { val canonicalName = modelClass.canonicalName ?: throw IllegalArgumentException(&quot;Local and anonymous classes can not be ViewModels&quot;) return get(&quot;$DEFAULT_KEY:$canonicalName&quot;, modelClass)}public open operator fun &lt;T : ViewModel&gt; get(key: String, modelClass: Class&lt;T&gt;): T { val viewModel = store[key] // 1️⃣ 从store中取viewModel if (modelClass.isInstance(viewModel)) { // 2️⃣ 判断合法性 (factory as? OnRequeryFactory)?.onRequery(viewModel!!) return viewModel as T } else { @Suppress(&quot;ControlFlowWithEmptyBody&quot;) if (viewModel != null) { // TODO: log a warning. } } val extras = MutableCreationExtras(defaultCreationExtras) extras[VIEW_MODEL_KEY] = key // AGP has some desugaring issues associated with compileOnly dependencies so we need to // fall back to the other create method to keep from crashing. return try { factory.create(modelClass, extras) // 3️⃣ 通过factory创建ViewModel } catch (e: AbstractMethodError) { // 3️⃣ 通过factory创建ViewModel factory.create(modelClass) }.also { store.put(key, it) } // 4️⃣ 存入store} 1️⃣ 从store中取viewModel，这个store就是上面提到的ViewModelStore, 这里可以看到其key就是类名 2️⃣ 判断合法性，isInstance函数首先判空，其次判断是否为对应的类型，这一步的判空是为了判断是否需要构造ViewModel实例，避免返回空；这一步的判断类型则是为了提高安全性，返回时强转不会强转失败 3️⃣ 通过factory创建，这一步显而易见，创建新的实例。这里的factory默认值是通过ComponentActivity构造的SavedStateViewModelFactory 4️⃣ 存入store，在创建后存入store中 A: ViewModelStore.put()问题 这里可以推测，如果同一个ViewModelStoreOwner中声明了多个同类型的ViewModel，根据2️⃣的判断，他们会是同一个实例。ViewModelStore.put时一般不会存在同key值的ViewModel对象，所以那里是否调用clear进行资源回收也就不是很重要了。 ViewModelViewModel类实际上不是实际实现，持有ViewModelImpl的实例，对其方法进行代理 类定义1public actual abstract class ViewModel 几个注意的点： actual: 介绍看这里, 大概是和跨端相关的。 abstract clear方法1234567protected actual open fun onCleared() {}@MainThreadinternal actual fun clear() { impl?.clear() onCleared()} 这里可以看到稍有不同的是，除了代理调用ViewModelImpl的clear方法，还调用了钩子方法onCleared 另外很有趣的是ViewModelImpl和ViewModel并没有继承关系，也没有继承相同的接口 ViewModelImpl关键的属性123456private val keyToCloseables = mutableMapOf&lt;String, AutoCloseable&gt;()/** * @see [keyToCloseables] */private val closeables = mutableSetOf&lt;AutoCloseable&gt;() 可以看到维护了一个map和一个set，保存AutoCloseable addCloseable12345678910111213141516171819202122232425fun addCloseable(key: String, closeable: AutoCloseable) { // Although no logic should be done after user calls onCleared(), we will // ensure that if it has already been called, the closeable attempting to // be added will be closed immediately to ensure there will be no leaks. if (isCleared) { closeWithRuntimeException(closeable) return } val oldCloseable = synchronized(lock) { keyToCloseables.put(key, closeable) } closeWithRuntimeException(oldCloseable)}/** @see [ViewModel.addCloseable] */fun addCloseable(closeable: AutoCloseable) { // Although no logic should be done after user calls onCleared(), we will // ensure that if it has already been called, the closeable attempting to // be added will be closed immediately to ensure there will be no leaks. if (isCleared) { closeWithRuntimeException(closeable) return } synchronized(lock) { closeables += closeable }} 可以看到两个函数，一个是添加到map中，一个是添加到set中 如果当前ViewModel已经被clear了，那么会调用closeWithRuntimeException，这个方法会调用其close方法，并将close时出现的异常转换为RuntimeException抛出 如果map中有同key值的closeable，那么也会调用closeWithRuntimeException将其关闭 这两个函数也可以提供给用户使用 构造方法1234567891011121314constructor()constructor(viewModelScope: CoroutineScope) { addCloseable(VIEW_MODEL_SCOPE_KEY, viewModelScope.asCloseable())}constructor(vararg closeables: AutoCloseable) { this.closeables += closeables}constructor(viewModelScope: CoroutineScope, vararg closeables: AutoCloseable) { addCloseable(VIEW_MODEL_SCOPE_KEY, viewModelScope.asCloseable()) this.closeables += closeables} 可以看到，只允许传递一个CoroutineScope，会将其转化为closeable，存到map中 看上去只允许传递一个CoroutineScope，但是还是可以通过相同的方法传递多个用CloseableCoroutineScope包装过的Scope对象 这个构造允许传递一个CoroutineScope完全是为了将其转化为Closeable对象，没有别的意义，感觉很多余。 clear1234567891011121314151617@MainThreadfun clear() { if (isCleared) return // 1️⃣ isCleared = true // 2️⃣ synchronized(lock) { for (closeable in keyToCloseables.values) { closeWithRuntimeException(closeable) } for (closeable in closeables) { closeWithRuntimeException(closeable) } // Clear only resources without keys to prevent accidental recreation of resources. // For example, `viewModelScope` would be recreated leading to unexpected behaviour. closeables.clear() }} @MainThread标明该方法应该被在主线程调用 方法其实就是把所有closeable关掉，再把set清空，但是map却没有清空？ 可以看到1️⃣和2️⃣并不是原子的，如果clear被多个线程同时调用，有可能存在map里的closeable被close两次的情况。 SavedStateViewModelFactorycreate方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;, extras: CreationExtras): T { // 1️⃣ val key = extras[ViewModelProvider.NewInstanceFactory.VIEW_MODEL_KEY] ?: throw IllegalStateException( &quot;VIEW_MODEL_KEY must always be provided by ViewModelProvider&quot; ) return if (extras[SAVED_STATE_REGISTRY_OWNER_KEY] != null &amp;&amp; extras[VIEW_MODEL_STORE_OWNER_KEY] != null) { val application = extras[ViewModelProvider.AndroidViewModelFactory.APPLICATION_KEY] val isAndroidViewModel = AndroidViewModel::class.java.isAssignableFrom(modelClass) val constructor: Constructor&lt;T&gt;? = if (isAndroidViewModel &amp;&amp; application != null) { findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE) } else { findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE) } // doesn't need SavedStateHandle if (constructor == null) { return factory.create(modelClass, extras) } val viewModel = if (isAndroidViewModel &amp;&amp; application != null) { newInstance(modelClass, constructor, application, extras.createSavedStateHandle()) } else { newInstance(modelClass, constructor, extras.createSavedStateHandle()) } viewModel } else { val viewModel = if (lifecycle != null) { create(key, modelClass) } else { throw IllegalStateException(&quot;SAVED_STATE_REGISTRY_OWNER_KEY and&quot; + &quot;VIEW_MODEL_STORE_OWNER_KEY must be provided in the creation extras to&quot; + &quot;successfully create a ViewModel.&quot;) } viewModel }}/** * Creates a new instance of the given `Class`. * * @param key a key associated with the requested ViewModel * @param modelClass a `Class` whose instance is requested * @return a newly created ViewModel * * @throws UnsupportedOperationException if the there is no lifecycle */fun &lt;T : ViewModel&gt; create(key: String, modelClass: Class&lt;T&gt;): T { // 2️⃣ // empty constructor was called. val lifecycle = lifecycle ?: throw UnsupportedOperationException( &quot;SavedStateViewModelFactory constructed with empty constructor supports only &quot; + &quot;calls to create(modelClass: Class&lt;T&gt;, extras: CreationExtras).&quot; ) val isAndroidViewModel = AndroidViewModel::class.java.isAssignableFrom(modelClass) val constructor: Constructor&lt;T&gt;? = if (isAndroidViewModel &amp;&amp; application != null) { findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE) } else { findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE) } // doesn't need SavedStateHandle constructor ?: // If you are using a stateful constructor and no application is available, we // use an instance factory instead. return if (application != null) factory.create(modelClass) else instance.create(modelClass) val controller = LegacySavedStateHandleController.create( savedStateRegistry!!, lifecycle, key, defaultArgs ) val viewModel: T = if (isAndroidViewModel &amp;&amp; application != null) { newInstance(modelClass, constructor, application!!, controller.handle) } else { newInstance(modelClass, constructor, controller.handle) } viewModel.setTagIfAbsent( AbstractSavedStateViewModelFactory.TAG_SAVED_STATE_HANDLE_CONTROLLER, controller ) return viewModel} 1️⃣和2️⃣大体流程上都是获取构造函数，创建实例对象 区别在于newInstance的第四个参数不同，一个通过extras获取，一个通过LegacySavedStateHandleController获得，看起来很复杂，但是看一下这个newInstance的实现就会发现，第四个参数实际上就是构造函数的参数 1234567891011121314151617internal fun &lt;T : ViewModel?&gt; newInstance( modelClass: Class&lt;T&gt;, constructor: Constructor&lt;T&gt;, vararg params: Any): T { return try { constructor.newInstance(*params) } catch (e: IllegalAccessException) { throw RuntimeException(&quot;Failed to access $modelClass&quot;, e) } catch (e: InstantiationException) { throw RuntimeException(&quot;A $modelClass cannot be instantiated.&quot;, e) } catch (e: InvocationTargetException) { throw RuntimeException( &quot;An exception happened in constructor of $modelClass&quot;, e.cause ) }} viewModelStore何时被clear在ComponentActivty的初始化时，会看到下面这段代码 1234567891011lifecycle.addObserver(LifecycleEventObserver { _, event -&gt; if (event == Lifecycle.Event.ON_DESTROY) { // Clear out the available context contextAwareHelper.clearAvailableContext() // And clear the ViewModelStore if (!isChangingConfigurations) { viewModelStore.clear() } reportFullyDrawnExecutor.activityDestroyed() }}) 如果Activity生命周期到了ON_DESTROY，且不是夜间模式改变等情况，就会将viewModel清空，做到了界面和数据分离。 CoroutineScope是如何变成Closeable的1234567891011121314internal fun CoroutineScope.asCloseable() = CloseableCoroutineScope(coroutineScope = this)/** * [CoroutineScope] that provides a method to [close] it, causing the rejection of any new tasks and * cleanup of all underlying resources associated with the scope. */internal class CloseableCoroutineScope( override val coroutineContext: CoroutineContext,) : AutoCloseable, CoroutineScope { constructor(coroutineScope: CoroutineScope) : this(coroutineScope.coroutineContext) override fun close() = coroutineContext.cancel()} CloseableCoroutineScope实现了AutoCloseable, 在close方法中将协程cancel掉 CreationExtras在SavedStateViewModelFactory的create方法中，可以看到factory会拿到一个CreationExtras在by viewModels()时，会传递一个构造CreationExtras的函数，如果没提供，就使用默认ComponentActivity提供的defaultViewModelCreationExtras 默认的CreationExtras123456789101112131415161718192021override val defaultViewModelCreationExtras: CreationExtras /** * {@inheritDoc} * * The extras of [getIntent] when this is first called will be used as * the defaults to any [androidx.lifecycle.SavedStateHandle] passed to a view model * created using this extra. */ get() { val extras = MutableCreationExtras() if (application != null) { extras[APPLICATION_KEY] = application } extras[SAVED_STATE_REGISTRY_OWNER_KEY] = this extras[VIEW_MODEL_STORE_OWNER_KEY] = this val intentExtras = intent?.extras if (intentExtras != null) { extras[DEFAULT_ARGS_KEY] = intentExtras } return extras } 可以看到里面存了当前的Application对象，还有两个this，还会将intent.extra放进去 MutableCreationExtras其实也是维护了一个map 给ViewModel传参 前面提到我们可以指定Factory和CreationExtras 可以自己编写Factory，从CreationExtras中获取参数，下面是示例代码12345678910111213141516class MainViewModel( private val coroutineScope: CoroutineScope = CloseableCoroutineScope(), param1: String, param2: Int) : ViewModel(coroutineScope) { companion object { override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;, extras: CreationExtras): T { val param1 = extras[MY_PARAM_KEY1]!! val param2 = extras[MY_PARAM_KEY2]!! return MainViewModel(param1 = param1, param2 = param2) as T } val MY_PARAM_KEY1 = object : CreationExtras.Key&lt;String&gt; {} val MY_PARAM_KEY2 = object : CreationExtras.Key&lt;Int&gt; {} }} 12345678910class MyActivity : AppCompatActivity() { private val viewModel : MainViewModel by viewModels({ return@viewModels MutableCreationExtras().apply { set(MainViewModel.MY_PARAM_KEY1, &quot;1&quot;) set(MainViewModel.MY_PARAM_KEY2, 2) } }){ return@viewModels MainViewModel.Factory }} Fragment.viewModels1234567891011121314151617181920@MainThreadpublic inline fun &lt;reified VM : ViewModel&gt; Fragment.viewModels( noinline ownerProducer: () -&gt; ViewModelStoreOwner = { this }, noinline extrasProducer: (() -&gt; CreationExtras)? = null, noinline factoryProducer: (() -&gt; Factory)? = null): Lazy&lt;VM&gt; { val owner by lazy(LazyThreadSafetyMode.NONE) { ownerProducer() } return createViewModelLazy( VM::class, { owner.viewModelStore }, { extrasProducer?.invoke() ?: (owner as? HasDefaultViewModelProviderFactory)?.defaultViewModelCreationExtras ?: CreationExtras.Empty }, factoryProducer ?: { (owner as? HasDefaultViewModelProviderFactory)?.defaultViewModelProviderFactory ?: defaultViewModelProviderFactory })} 支持创建/获取其他owner的ViewModel 和ComponentActivity一样，createViewModelLazy的返回的也是ViewModelLazy类 Fragment.activityViewModels12345678910@MainThreadpublic inline fun &lt;reified VM : ViewModel&gt; Fragment.activityViewModels( noinline extrasProducer: (() -&gt; CreationExtras)? = null, noinline factoryProducer: (() -&gt; Factory)? = null): Lazy&lt;VM&gt; = createViewModelLazy( VM::class, { requireActivity().viewModelStore }, { extrasProducer?.invoke() ?: requireActivity().defaultViewModelCreationExtras }, factoryProducer ?: { requireActivity().defaultViewModelProviderFactory }) 获取activity的viewModelStore 获取父fragment的viewModel1val parentFragmentViewModel:XXXViewModel by viewModels(ownerProducer = { requireParentFragment() }) navigation图的viewModel12val naviViewModel : MainViewModel by navGraphViewModels(R.id.xxx)val naviViewModel1 : MainViewModel by viewModels(ownerProducer = { findNavController().getBackStackEntry(R.id.xxx) }) 123456789101112131415161718@MainThreadpublic inline fun &lt;reified VM : ViewModel&gt; Fragment.navGraphViewModels( @IdRes navGraphId: Int, noinline extrasProducer: (() -&gt; CreationExtras)? = null, noinline factoryProducer: (() -&gt; ViewModelProvider.Factory)? = null): Lazy&lt;VM&gt; { val backStackEntry by lazy { findNavController().getBackStackEntry(navGraphId) } val storeProducer: () -&gt; ViewModelStore = { backStackEntry.viewModelStore } return createViewModelLazy( VM::class, storeProducer, { extrasProducer?.invoke() ?: backStackEntry.defaultViewModelCreationExtras }, factoryProducer ?: { backStackEntry.defaultViewModelProviderFactory } )} navGraphViewModels其实就是调用了findNavController().getBackStackEntry(navGraphId)，然后获取其viewModelStore 非lazy获取的viewModel12345val viewModel = ViewModelProvider(this.viewModelStore, ViewModelProvider.NewInstanceFactory.instance)[MainViewModel::class.java]val viewModel = ViewModelProvider(this.viewModelStore, MainViewModel.Factory, MutableCreationExtras().apply { set(MainViewModel.MY_PARAM_KEY1, &quot;1&quot;) set(MainViewModel.MY_PARAM_KEY2, 2)})[MainViewModel::class.java] Compose获取viewModel1234567@Composablefun Greeting(string: String, modifier: Modifier = Modifier, vm : MainViewModel = viewModel()) { Text( text = string, modifier = modifier )} 12345678910111213@Composablepublic inline fun &lt;reified VM : ViewModel&gt; viewModel( viewModelStoreOwner: ViewModelStoreOwner = checkNotNull(LocalViewModelStoreOwner.current) { &quot;No ViewModelStoreOwner was provided via LocalViewModelStoreOwner&quot; }, key: String? = null, factory: ViewModelProvider.Factory? = null, extras: CreationExtras = if (viewModelStoreOwner is HasDefaultViewModelProviderFactory) { viewModelStoreOwner.defaultViewModelCreationExtras } else { CreationExtras.Empty }): VM = viewModel(VM::class, viewModelStoreOwner, key, factory, extras) 123456789101112131415@Suppress(&quot;MissingJvmstatic&quot;)@Composablepublic fun &lt;VM : ViewModel&gt; viewModel( modelClass: KClass&lt;VM&gt;, viewModelStoreOwner: ViewModelStoreOwner = checkNotNull(LocalViewModelStoreOwner.current) { &quot;No ViewModelStoreOwner was provided via LocalViewModelStoreOwner&quot; }, key: String? = null, factory: ViewModelProvider.Factory? = null, extras: CreationExtras = if (viewModelStoreOwner is HasDefaultViewModelProviderFactory) { viewModelStoreOwner.defaultViewModelCreationExtras } else { CreationExtras.Empty }): VM = viewModelStoreOwner.get(modelClass, key, factory, extras) 1234567891011121314151617181920212223internal fun &lt;VM : ViewModel&gt; ViewModelStoreOwner.get( modelClass: KClass&lt;VM&gt;, key: String? = null, factory: ViewModelProvider.Factory? = null, extras: CreationExtras = if (this is HasDefaultViewModelProviderFactory) { this.defaultViewModelCreationExtras } else { CreationExtras.Empty }): VM { val provider = if (factory != null) { ViewModelProvider.create(this.viewModelStore, factory, extras) } else if (this is HasDefaultViewModelProviderFactory) { ViewModelProvider.create(this.viewModelStore, this.defaultViewModelProviderFactory, extras) } else { ViewModelProvider.create(this) } return if (key != null) { provider[key, modelClass] } else { provider[modelClass] }} 12345678910111213141516interface HasDefaultViewModelProviderFactory { /** * Returns the default [ViewModelProvider.Factory] that should be * used when no custom `Factory` is provided to the * [ViewModelProvider] constructors. */ val defaultViewModelProviderFactory: ViewModelProvider.Factory /** * Returns the default [CreationExtras] that should be passed into * [ViewModelProvider.Factory.create] when no overriding * [CreationExtras] were passed to the [ViewModelProvider] constructors. */ val defaultViewModelCreationExtras: CreationExtras get() = CreationExtras.Empty} store来自LocalViewModelStoreOwner.current factory和extras来自HasDefaultViewModelProviderFactory 备忘单","link":"/home/2024/07/31/Android%E9%AB%98%E7%BA%A7/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E5%9F%BA%E7%A1%8002-viewModel/"},{"title":"fabric-1.fabric环境配置与搭建","text":"参考文档-getting start 准备工作 需要安装git，curl，docker，docker compose1sudo apt install docker-compose 给当前用户运行docker的权限12345678## 创建docker组sudo groupadd docker## 将当前用户加入docker组sudo usermod -aG docker tt## 重启服务sudo service docker restart## 刷新docker成员newgrp docker go环境的安装12345678910wget https://golang.google.cn/dl/go1.19.linux-amd64.tar.gztar -zxvf go1.19.linux-amd64.tar.gzsudo mv go /usr/local/sudo tee -a ~/.bachrc &lt;&lt;-'EOF'export GOROOT=/usr/local/go## export GOPATH=/home/go/goProjectexport GOPROXY=https://goproxy.cnexport PATH=$PATH:$GOROOT/binEOFsource /etc/profile fabric的安装 fabric提供了一个脚本，用于安装二进制文件和镜像12345## 安装最新版本curl -sSL https://bit.ly/2ysbOFE | bash -s## 安装指定版本curl -sSL https://bit.ly/2ysbOFE | bash -s -- &lt;fabric_version&gt; &lt;fabric-ca_version&gt;curl -sSL https://bit.ly/2ysbOFE | bash -s -- 2.2.8 1.5.3 问题1–docker权限 我的环境中docker pull必须使用sudo，而curl并不推荐使用sudo 解决方案：先下载script，并修改，将第14行CONTAINER_CLI修改为sudo docker123curl -sSL https://bit.ly/2ysbOFE -o script.shchmod +x script.shvim script.sh 1: ${CONTAINER_CLI:=&quot;docker&quot;} ## 改为sudo docker 解决方案2：重新安装docker，发现脚本结束后，有免root运行的脚本 问题2–pull缓慢 更换镜像123456789101112131415sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'{ &quot;registry-mirrors&quot; : [ &quot;https://registry.docker-cn.com&quot;, &quot;http://hub-mirror.c.163.com&quot;, &quot;https://docker.mirrors.ustc.edu.cn&quot;, &quot;https://cr.console.aliyun.com&quot;, &quot;https://mirror.ccs.tencentyun.com&quot; ]}EOFsudo systemctl daemon-reloadsudo systemctl restart dockersudo docker info 部署一个测试网络 参考文档-Using the Fabric test network test-network在fabric-samples/test-network下 查看帮助文本1./network.sh -h 12345678910111213141516171819202122232425262728293031323334353637383940414243Using docker and docker-composeUsage: network.sh &lt;Mode&gt; [Flags] Modes: up - Bring up Fabric orderer and peer nodes. No channel is created up createChannel - Bring up fabric network with one channel createChannel - Create and join a channel after the network is created deployCC - Deploy a chaincode to a channel (defaults to asset-transfer-basic) down - Bring down the network Flags: Used with network.sh up, network.sh createChannel: -ca &lt;use CAs&gt; - Use Certificate Authorities to generate network crypto material -c &lt;channel name&gt; - Name of channel to create (defaults to &quot;mychannel&quot;) -s &lt;dbtype&gt; - Peer state database to deploy: goleveldb (default) or couchdb -r &lt;max retry&gt; - CLI times out after certain number of attempts (defaults to 5) -d &lt;delay&gt; - CLI delays for a certain number of seconds (defaults to 3) -verbose - Verbose mode Used with network.sh deployCC -c &lt;channel name&gt; - Name of channel to deploy chaincode to -ccn &lt;name&gt; - Chaincode name. -ccl &lt;language&gt; - Programming language of the chaincode to deploy: go, java, javascript, typescript -ccv &lt;version&gt; - Chaincode version. 1.0 (default), v2, version3.x, etc -ccs &lt;sequence&gt; - Chaincode definition sequence. Must be an integer, 1 (default), 2, 3, etc -ccp &lt;path&gt; - File path to the chaincode. -ccep &lt;policy&gt; - (Optional) Chaincode endorsement policy using signature policy syntax. The default policy requires an endorsement from Org1 and Org2 -cccg &lt;collection-config&gt; - (Optional) File path to private data collections configuration file -cci &lt;fcn name&gt; - (Optional) Name of chaincode initialization function. When a function is provided, the execution of init will be requested and the function will be invoked. -h - Print this message Possible Mode and flag combinations up -ca -r -d -s -verbose up createChannel -ca -c -r -d -s -verbose createChannel -c -r -d -verbose deployCC -ccn -ccl -ccv -ccs -ccp -cci -r -d -verbose Examples: network.sh up createChannel -ca -c mychannel -s couchdb network.sh createChannel -c channelName network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-javascript/ -ccl javascript network.sh deployCC -ccn mychaincode -ccp ./user/mychaincode -ccv 1 -ccl javascript 启动测试网络1./network.sh up 创建Channel channel是特定网络成员之间私有通信层，channel只能由邀请加入该channel的组织使用，并且对网络中的其他成员是不可见的。 每个channel都有一个独立的区块链账本。被邀请“加入”其同行的组织到channel来存储channel账本并验证channel上的交易。1./network.sh createChannel -c channel1 运行智能合约 在fabric中，智能合约是chainCode Chaincode安装在组织的对等端，然后部署到一个通道，然后可以使用它来批准交易，并与区块链账本交互。 1./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-go -ccl go 这里使用了go语言的环境 -ccl指定了安装链码的语言，go/typescript/javascript -ccp指定了chainCode 销毁网络1./network.sh down 总结 测试时还有一部分是与网络交互，使用peer命令修改资产所有者等命令，测试网络有些内容还是不太清楚，运行暂时没有出错 Fabric概要 参考视频 参考博客 参考笔记 可以参考笔记中的一个思维导图进行学习 Overview Server/Backend/API Network Chain Code Ca Ledger Development process Client/Frontend/App SDK Development process Samples ServerNetwork是一个p2p网络，由两部分组成 Peer Container，对等节点 Endorser，背书节点，根据背书策略对交易进行验证 Committer，提交节点，chainCode不会部署在Endorser之上，而是Committer上 集群管理 Kubernates Orderer Container，排序节点 Ca客户端服务端配合实现动态授予证书，支持实时添加对等节点数量 Ledger BlockChain：TX记录，存储交易 channel，同一通道具有（可见）同一个公共账本 Hash pointer，支持哈希指针 Hashed linkList，支持哈希链表 State DB：World/Current State，状态数据库 A peer，A DB 存储交易的Index Single/No-SQL – key value存储，HTTP Api，通过http请求获得数据，段康康5984 level DB，默认引擎，k-v存储 Couch DB，数据库引擎，k-v存储，json存储 顺序读写能力强，随机读取能力若 Chain Code System Chain Code 包括CSCC等，可以自定义 创建时随peer一起启动，用于peer节点（而不是channel）上，只支持go User Chain Code 用于操纵资产，提供操纵资产的接口 具有生命周期，初始化-部署-实例化-调用 运行于peer上的容器中 支持语言 Golang语言层面支持并发，适合服务端应用开发 Node Java Client/Frontend/App 操作区块链网络，部署、执行 Chain code 提供的接口函数，监听网络事件，接收区块信息，写入交易等等 SDK Node(推荐使用) TypeScript Golang Python Java Architecture 知识补充–Node.js 简单的说 Node.js 就是运行在服务端的 JavaScript。 创建Node.js应用123456789101112131415var http = require('http');http.createServer(function (request, response) { // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, {'Content-Type': 'text/plain'}); // 发送响应数据 &quot;Hello World&quot; response.end('Hello World\\n');}).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); require函数载入http模块 createServer创建服务器 listen指定监听端口 使用node命令运行，访问8888端口 使用node命令运行1node server.js npm命令 npm安装模块1npm install xxxx 安装好之后，express 包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过 require(‘express’) 的方式就好，无需指定第三方包路径。 -g参数指定全局安装，即将安装包放在 /usr/local 下或者你 node 的安装目录。 pacjage.json 用于定义包的属性 name - 包名。 version - 包的版本号。 description - 包的描述。 homepage - 包的官网 url 。 author - 包的作者姓名。 contributors - 包的其他贡献者姓名。 dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。 repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。 main - main 字段指定了程序的主入口文件，require(‘moduleName’) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。 keywords - 关键字 还可以使用npm init npm adduser npm publish发布自己的模块，使用npm unpublish取消发布模块 REPL Read Eval Print Loop，交互式解释器，类似python的IDLE，可以输入代码并获得执行结果 通过node命令进入，快捷键ctrl c退出。 Hellow World 参考教程编写你的第一个应用 具体内容 启动网络 使用Node登记管理员用户，注册和登记应用程序用户，查询账本，更新账本 清除数据 startFabric.sh12345pushd ../test-network./network.sh down./network.sh up createChannel -ca -s couchdb./network.sh deployCC -ccn fabcar -ccv 1 -cci initLedger -ccl ${CC_SRC_LANGUAGE} -ccp ${CC_SRC_PATH}popd 事实上就是启动test-network，创建两个peer节点和channel，再部署链码 chaincode api sdk有go，java和未正式发布的python 开发一个ChainCode（go）创建struct123456789101112package mainimport ( &quot;fmt&quot; &quot;github.com/hyperledger/fabric-chaincode-go/shim&quot; &quot;github.com/hyperledger/fabric-protos-go/peer&quot;)// SimpleAsset implements a simple chaincode to manage an assettype SimpleAsset struct {} 实现init方法1234567891011121314151617181920// Init is called during chaincode instantiation to initialize any// data. Note that chaincode upgrade also calls this function to reset// or to migrate data, so be careful to avoid a scenario where you// inadvertently clobber your ledger's data!func (t *SimpleAsset) Init(stub shim.ChaincodeStubInterface) peer.Response { // Get the args from the transaction proposal args := stub.GetStringArgs() if len(args) != 2 { return shim.Error(&quot;Incorrect arguments. Expecting a key and a value&quot;) } // Set up any variables or assets here by calling stub.PutState() // We store the key and the value on the ledger err := stub.PutState(args[0], []byte(args[1])) if err != nil { return shim.Error(fmt.Sprintf(&quot;Failed to create asset: %s&quot;, args[0])) } return shim.Success(nil)} 验证 init方法可以是空 实现invoke函数123456789101112131415161718192021// Invoke is called per transaction on the chaincode. Each transaction is// either a 'get' or a 'set' on the asset created by Init function. The Set// method may create a new asset by specifying a new key-value pair.func (t *SimpleAsset) Invoke(stub shim.ChaincodeStubInterface) peer.Response { // Extract the function and args from the transaction proposal fn, args := stub.GetFunctionAndParameters() var result string var err error if fn == &quot;set&quot; { result, err = set(stub, args) } else { result, err = get(stub, args) } if err != nil { return shim.Error(err.Error()) } // Return the result as success payload return shim.Success([]byte(result))} 根据stub中的参数，调用get或set方法，并返回结果 实现get和set1234567891011121314151617181920212223242526272829// Set stores the asset (both key and value) on the ledger. If the key exists,// it will override the value with the new onefunc set(stub shim.ChaincodeStubInterface, args []string) (string, error) { if len(args) != 2 { return &quot;&quot;, fmt.Errorf(&quot;Incorrect arguments. Expecting a key and a value&quot;) } err := stub.PutState(args[0], []byte(args[1])) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;Failed to set asset: %s&quot;, args[0]) } return args[1], nil}// Get returns the value of the specified asset keyfunc get(stub shim.ChaincodeStubInterface, args []string) (string, error) { if len(args) != 1 { return &quot;&quot;, fmt.Errorf(&quot;Incorrect arguments. Expecting a key&quot;) } value, err := stub.GetState(args[0]) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;Failed to get asset: %s with error: %s&quot;, args[0], err) } if value == nil { return &quot;&quot;, fmt.Errorf(&quot;Asset not found: %s&quot;, args[0]) } return string(value), nil} 从ledger账本中读写数据 实现main方法12345func main() { if err := shim.Start(new(SimpleAsset)); err != nil { fmt.Printf(&quot;Error starting SimpleAsset chaincode: %s&quot;, err) }} 在以上步骤的基础上，结合shim api应该可以开发出其他功能","link":"/home/2022/10/22/fedfab/fabric/1.fabric%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%90%AD%E5%BB%BA/"},{"title":"基础06-ViewGroup","text":"testgraph TD A[开始] --> B{条件判断} B -->|是| C[执行操作] B -->|否| D[结束]","link":"/home/2025/05/09/Android%E9%AB%98%E7%BA%A7/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E5%9F%BA%E7%A1%8006-ViewGroup/"},{"title":"01-layout","text":"ID创建 RelativeLayout 时，请务必为视图对象定义 ID。在相对布局中，同级视图可以定义其相对于通过唯一 ID 引用的另一个同级视图的布局。 findViewByIdID 不必在整个树状结构中具有唯一性，但在您搜索的树状结构部分中必须是唯一的。它通常可能是整个树，因此最好尽可能使其具有唯一性。 findViewById是View的方法 123456789101112131415161718192021/** * Finds the first descendant view with the given ID, the view itself if * the ID matches {@link #getId()}, or {@code null} if the ID is invalid * (&lt; 0) or there is no matching view in the hierarchy. * &lt;p&gt; * &lt;strong&gt;Note:&lt;/strong&gt; In most cases -- depending on compiler support -- * the resulting view is automatically cast to the target class type. If * the target class type is unconstrained, an explicit cast may be * necessary. * * @param id the ID to search for * @return a view with given ID if found, or {@code null} otherwise * @see View#requireViewById(int) */@Nullablepublic final &lt;T extends View&gt; T findViewById(@IdRes int id) { if (id == NO_ID) { return null; } return findViewTraversal(id);} 在Activity中，findViewById是调用window的findViewById 123456789101112131415161718/** * Finds a view that was identified by the {@code android:id} XML attribute * that was processed in {@link #onCreate}. * &lt;p&gt; * &lt;strong&gt;Note:&lt;/strong&gt; In most cases -- depending on compiler support -- * the resulting view is automatically cast to the target class type. If * the target class type is unconstrained, an explicit cast may be * necessary. * * @param id the ID to search for * @return a view with given ID if found, or {@code null} otherwise * @see View#findViewById(int) * @see Activity#requireViewById(int) */@Nullablepublic &lt;T extends View&gt; T findViewById(@IdRes int id) { return getWindow().findViewById(id);} Window调用DecorView 1234567891011121314151617181920/** * Finds a view that was identified by the {@code android:id} XML attribute * that was processed in {@link android.app.Activity#onCreate}. * &lt;p&gt; * This will implicitly call {@link #getDecorView} with all of the associated side-effects. * &lt;p&gt; * &lt;strong&gt;Note:&lt;/strong&gt; In most cases -- depending on compiler support -- * the resulting view is automatically cast to the target class type. If * the target class type is unconstrained, an explicit cast may be * necessary. * * @param id the ID to search for * @return a view with given ID if found, or {@code null} otherwise * @see View#findViewById(int) * @see Window#requireViewById(int) */@Nullablepublic &lt;T extends View&gt; T findViewById(@IdRes int id) { return getDecorView().findViewById(id);} 布局参数每个 ViewGroup 类都会实现一个扩展 ViewGroup.LayoutParams 的嵌套类。此子类包含的属性类型会根据需要为视图组定义每个子视图的尺寸和位置。如图 2 所示，父视图组会为每个子视图（包括子视图组）定义布局参数。 所有视图组都使用 layout_width 和 layout_height 包含宽度和高度，并且每个视图都必须定义它们。许多 LayoutParams 包含可选的外边距和边框。 您可以指定具有确切尺寸的宽度和高度，但您可能不希望经常这样做。更常见的情况是，您会使用以下某个常量来设置宽度或高度： wrap_content：告知视图将其大小调整为内容所需的尺寸。 match_parent：告知视图尽可能采用其父视图组允许的最大尺寸。 最好使用dp，密度无关像素 布局位置getLeft(), getTop(), getRight(), getBottom()表示获取相对于其父view的位置坐标 getRight() - getLeft() == getWidth()getBottom() - getTop() == getHeight() 尺寸, 内外边距margin(外边距)和padding(内边距)的区别 margin指的是在view的边界之外的额外空间，用于分隔父布局，或父布局中其他相邻view margin的颜色不受view的影响 padding是在view边界内部的额外空间 padding的颜色受view的背景的影响 自适应布局 使用ConstraintLayout 对列表-详情界面使用 SlidingPaneLayout 根据设备尺寸自动决定菜单和content是并排显示还是层叠显示 备用资源对资源目录/布局文件的文件名后添加限定符，可规定自愿限制应用的屏幕尺寸，语言，屏幕方向，如有多种限制，需要按照表格中的顺序给出。 在表格中越靠前的优先级越高 系统选择合适的资源时，首先排除与设备配置相冲突的资源文件（如语言、像素密度），然后按照表格的顺序依次寻找是否有目录包含该限定符，如果有，则把不含有限定符的目录排除 fragment使用 fragment 将界面组件模块化 对于折叠屏、大尺寸设备，可以用fragment将ui模块化，避免重复的ui加载 activity 嵌入使用Activity嵌入，可在大尺寸设备上在屏幕上并排显示Activity，在小尺寸屏幕上层叠显示 线性布局均等分布若要创建线性布局，让每个子项在屏幕上占据相同大小的空间 android:layout_height=&quot;0dp&quot; or android:layout_width=&quot;0dp&quot; android:layout_weight=&quot;1&quot; 不等分布 weight为0,则只占据所需的大小 不为0，每个占据剩余空间的 $ weight_i / \\sum_{j=1}^{N}{weight_j} $ 优化布局 减少布局层次 合并 使用ConstraintLayout 通过include标签重复使用布局 子布局的根布局可以使用merge标签，与父布局合并 使用ViewStub 动态将ViewStub替换为对应的view 通过ViewStub.inflate替换view 自定义组件自定义属性 创建res/values/attrs.xml 描述属性以及属性的取值 获取属性值1234567891011121314init { context.theme.obtainStyledAttributes( attrs, R.styleable.PieChart, 0, 0).apply { try { mShowText = getBoolean(R.styleable.PieChart_showText, false) textPos = getInteger(R.styleable.PieChart_labelPosition, 0) } finally { recycle() } }} onMeasure 获取parent限制的大小 1234int widthMode = MeasureSpec.getMode(widthMeasureSpec);int widthSize = MeasureSpec.getSize(widthMeasureSpec);int heightMode = MeasureSpec.getMode(heightMeasureSpec);int heightSize = MeasureSpec.getSize(heightMeasureSpec); Mode是MeasureSpec 调用child的measure, 参数表示对child大小的限制 123456789101112131415161718192021/** * &lt;p&gt; * This is called to find out how big a view should be. The parent * supplies constraint information in the width and height parameters. * &lt;/p&gt; * * &lt;p&gt; * The actual measurement work of a view is performed in * {@link #onMeasure(int, int)}, called by this method. Therefore, only * {@link #onMeasure(int, int)} can and must be overridden by subclasses. * &lt;/p&gt; * * * @param widthMeasureSpec Horizontal space requirements as imposed by the * parent * @param heightMeasureSpec Vertical space requirements as imposed by the * parent * * @see #onMeasure(int, int) */public final void measure(int widthMeasureSpec, int heightMeasureSpec) { onLayout遍历child，调用child的layout方法，参数表示其布局相对于父布局的位置 12345678910111213141516171819202122/** * Assign a size and position to a view and all of its * descendants * * &lt;p&gt;This is the second phase of the layout mechanism. * (The first is measuring). In this phase, each parent calls * layout on all of its children to position them. * This is typically done using the child measurements * that were stored in the measure pass().&lt;/p&gt; * * &lt;p&gt;Derived classes should not override this method. * Derived classes with children should override * onLayout. In that method, they should * call layout on each of their children.&lt;/p&gt; * * @param l Left position, relative to parent * @param t Top position, relative to parent * @param r Right position, relative to parent * @param b Bottom position, relative to parent */@SuppressWarnings({&quot;unchecked&quot;})public void layout(int l, int t, int r, int b) { onDraw给你Canvas去绘图 沉浸模式系统边衬区 系统栏边衬区：状态栏+导航条/按钮 系统手势边衬区：手势导航区 圆角 获取设备圆角的圆心和半径12345// 在一个view中val insets = rootWindowInsetsval topRight = insets.getRoundedCorner(RoundedCorner.POSITION_TOP_RIGHT) ?: return// 在activity中val rootWindowInsets = rootView.rootWindowInsets","link":"/home/2024/05/20/Android%E9%AB%98%E7%BA%A7/%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB/01-layout/"},{"title":"fabric-3.链码运行与Api调用","text":"中国社区文档 链码的打包 之前已经完成了链码mod的初始化和编译，直接进行打包1234peer lifecycle chaincode package fedfab.tar.gz \\ --path ../../fabric-cluster/chaincode/go/fedfab \\ --label fedfab_1 \\ --lang golang 在当前目录生成了fedfab.tar.gz文件 将打包好的文件复制到其他cli中1234docker cp cli0:/opt/gopath/src/github.com/hyperledger/fabric/peer/fedfab.tar.gz ./docker cp ./fedfab.tar.gz cli1:/opt/gopath/src/github.com/hyperledger/fabric/peer/docker cp ./fedfab.tar.gz cli2:/opt/gopath/src/github.com/hyperledger/fabric/peer/docker cp ./fedfab.tar.gz cli3:/opt/gopath/src/github.com/hyperledger/fabric/peer/ 链码安装 在每个cli上对链码进行安装1peer lifecycle chaincode install fedfab.tar.gz 122022-09-28 11:00:07.102 UTC 0001 INFO [cli.lifecycle.chaincode] submitInstallProposal -&gt; Installed remotely: response:&lt;status:200 payload:&quot;\\nIfedfab_1:705f9bef5195eff92ab7dd43ad1bcc2a7cb35defbb5c984b5197081f5b768d2e\\022\\010fedfab_1&quot; &gt; 2022-09-28 11:00:07.102 UTC 0002 INFO [cli.lifecycle.chaincode] submitInstallProposal -&gt; Chaincode code package identifier: fedfab_1:705f9bef5195eff92ab7dd43ad1bcc2a7cb35defbb5c984b5197081f5b768d2e 组织org批准链码1peer lifecycle chaincode approveformyorg --channelID channel2 --name fedfab --version 1.0 --package-id fedfab_1:705f9bef5195eff92ab7dd43ad1bcc2a7cb35defbb5c984b5197081f5b768d2e --sequence 1 --init-required --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem org1输出122022-09-03 11:12:26.988 UTC 0001 INFO [cli.lifecycle.chaincode] setOrdererClient -&gt; Retrieved channel (channel2) orderer endpoint: orderer.fedfab.com:70512022-09-03 11:12:29.067 UTC 0002 INFO [chaincodeCmd] ClientWait -&gt; txid [fcf3b9e351cae89503b256ce5dde76080432eac3b065ad8108be9ce8fbe2443a] committed with status (VALID) at peer0.org1.fedfab.com:8051 org2输出122022-09-03 11:12:29.057 UTC 0001 INFO [cli.lifecycle.chaincode] setOrdererClient -&gt; Retrieved channel (channel2) orderer endpoint: orderer.fedfab.com:70512022-09-03 11:12:31.110 UTC 0002 INFO [chaincodeCmd] ClientWait -&gt; txid [24e460abf242c2fd86b0a56e6ee045c76c08cd9b77d2bccb66bcd4e315806deb] committed with status (VALID) at peer0.org2.fedfab.com:9051 每个org提交一次即可 验证是否批准成功1peer lifecycle chaincode queryapproved --channelID channel2 --name fedfab --sequence 1 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --output json 12345678910111213141516{ &quot;sequence&quot;: 1, &quot;version&quot;: &quot;1.0&quot;, &quot;endorsement_plugin&quot;: &quot;escc&quot;, &quot;validation_plugin&quot;: &quot;vscc&quot;, &quot;validation_parameter&quot;: &quot;EiAvQ2hhbm5lbC9BcHBsaWNhdGlvbi9FbmRvcnNlbWVudA==&quot;, &quot;collections&quot;: {}, &quot;init_required&quot;: true, &quot;source&quot;: { &quot;Type&quot;: { &quot;LocalPackage&quot;: { &quot;package_id&quot;: &quot;09dc77ee99925c9ffd623cdcf6009c125c25bfec709a0986a62a883ef28d1ae4&quot; } } }} 1peer lifecycle chaincode checkcommitreadiness --channelID channel2 --name fedfab --version 1.0 --init-required --sequence 1 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --output json 123456{ &quot;approvals&quot;: { &quot;Org1MSP&quot;: true, &quot;Org2MSP&quot;: true }} 提交123456peer lifecycle chaincode commit -o orderer.fedfab.com:7050 --channelID channel2 --name fedfab --version 1.0 --sequence 1 --tls true --init-required --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt 12342022-09-03 22:04:17.335 UTC 0001 INFO [chaincodeCmd] ClientWait -&gt; txid [2468ffb8850ef91b0e3643cdc347fead1e9c39e8c0de8e5528b687b06d4e8ddb] committed with status (VALID) at peer1.org1.fedfab.com:80532022-09-03 22:04:17.338 UTC 0002 INFO [chaincodeCmd] ClientWait -&gt; txid [2468ffb8850ef91b0e3643cdc347fead1e9c39e8c0de8e5528b687b06d4e8ddb] committed with status (VALID) at peer2.org1.fedfab.com:80552022-09-03 22:04:17.338 UTC 0003 INFO [chaincodeCmd] ClientWait -&gt; txid [2468ffb8850ef91b0e3643cdc347fead1e9c39e8c0de8e5528b687b06d4e8ddb] committed with status (VALID) at peer0.org1.fedfab.com:80512022-09-03 22:04:17.338 UTC 0004 INFO [chaincodeCmd] ClientWait -&gt; txid [2468ffb8850ef91b0e3643cdc347fead1e9c39e8c0de8e5528b687b06d4e8ddb] committed with status (VALID) at peer0.org2.fedfab.com:9051 链码的调用输入一个键值对a:bb1234567peer chaincode invoke -o orderer.fedfab.com:7050 --isInit --ordererTLSHostnameOverride orderer.fedfab.com --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;a&quot;, &quot;bb&quot;]}' 12022-09-03 22:32:26.926 UTC 0001 INFO [chaincodeCmd] chaincodeInvokeOrQuery -&gt; Chaincode invoke successful. result: status:200 这个地方出错失败了很多次，原因是之前approve chaincode时，指定的package-id不正确，在approve的前一步install的输出中，输出的package-id是： Chaincode code package identifier: fedfab_2:cf7c1115e177f200ee6383d455b563e1df20721e0dccb6bb9cbf43e95d008739 chaincode的package-id是lable:一串数字，在approve时指定pkgid时必须完整，不能只指定后面的一串数字，重新在org中进行approve操作，则可以正确执行链码 这个回答的reference是官网的文档deploy_chaincode中的内容 查询a的值1peer chaincode query -C channel2 -n fedfab -c '{&quot;Args&quot;:[&quot;query&quot;, &quot;a&quot;]}' 1bb 修改a的值为cc，并查询验证1234567peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;set&quot;, &quot;a&quot;, &quot;cc&quot;]}'peer chaincode query -C channel2 -n fedfab -c '{&quot;Args&quot;:[&quot;query&quot;, &quot;a&quot;]}' 122022-09-04 07:48:30.012 UTC 0001 INFO [chaincodeCmd] chaincodeInvokeOrQuery -&gt; Chaincode invoke successful. result: status:200 payload:&quot;cc&quot; cc 之前失败了几次，试图重新搭建网络，但是即使所有容器都删除后，网络似乎还有一定的“记忆”。并且不能使用新生成的证书文件（否则会报错），只能使用第一次生成的证书文件。(已解决) docker network 在编写docker compose文件时，会配置一个network，起初认为这是定义fabric网络特有的，后来发现是docker的功能。 参考资料 容器网络模型（Container Network Model，简称CNM），只要符合这个模型的网络接口就能被用于容器之间通信，而通信的过程和细节可以完全由网络接口来实现。 参考中详细讲解了docker compose 中使用networks定义网络 fedml与fabric交互 编写application，为了让fabric与fedml结合，需要有调用fabric的api，在fabric训练的不同阶段调用fabric的api达到交互的目的。但是fedml是python代码，api提供了js和java，调用起来相对麻烦一些 使用与hyperledger fabric同名的一个python库fabric，远程连接cli的docker执行命令，感觉这样安全性较差 直接使用python sdk fabric的jira python sdk sdk文档 sdk的pypi链接 通过pypi查询，它最后一次更新在2020年8月，主要支持fabric 1.4.x版本 使用node 使用node编写js代码，如实现invoke等功能，再为每个功能指定一个端口，使用node为每个功能建立http服务。在fedml训练过程中，按照需要调用这些接口，即可以实现上述功能 node实现get、post请求的教程 node sdk 简介 参考 此 API 目前不提供管理功能，例如安装和启动智能合约。对于特定的高级用法，可以使用较低级别的fabric-common API。 用于与 Hyperledger Fabric 区块链网络交互的入口点是 Gateway类。一旦实例化，这个长期存在的对象提供了与区块链网络中的对等点的可重用连接，并允许访问该对等点所属的任何区块链 网络（通道）。提供了对该区块链网络中运行的智能合约（链码）的访问，并且可以向其 提交交易或 评估查询。 fabric-gateway简介参考- fabric gateway是fabric v2.4 引入的一项服务，它提供用于将事务提交到fabric网络的最简化的API示例代码1234567891011121314151617181920212223242526272829303132333435import * as grpc from '@grpc/grpc-js';import * as crypto from 'crypto';import { connect, Identity, signers } from '@hyperledger/fabric-gateway';import { promises as fs } from 'fs';import { TextDecoder } from 'util';const utf8Decoder = new TextDecoder();async function main(): Promise&lt;void&gt; { const credentials = await fs.readFile('path/to/certificate.pem'); const identity: Identity = { mspId: 'myorg', credentials }; const privateKeyPem = await fs.readFile('path/to/privateKey.pem'); const privateKey = crypto.createPrivateKey(privateKeyPem); const signer = signers.newPrivateKeySigner(privateKey); const client = new grpc.Client('gateway.example.org:1337', grpc.credentials.createInsecure()); const gateway = connect({ identity, signer, client }); try { const network = gateway.getNetwork('channelName'); const contract = network.getContract('chaincodeName'); const putResult = await contract.submitTransaction('put', 'time', new Date().toISOString()); console.log('Put result:', utf8Decoder.decode(putResult)); const getResult = await contract.evaluateTransaction('get', 'time'); console.log('Get result:', utf8Decoder.decode(getResult)); } finally { gateway.close(); client.close() }}main().catch(console.error); 运行ts文件 参考 参考代码 安装依赖12npm install @hyperledger/fabric-gatewaynpm install @grpc/grpc-js 安装ts 12345678910tar -zxvf node-v16.17.0-linux-x64.tar.xzsudo mv node-v16.17.0-linux-x64 /usr/local/nodevim tee -a /etc/profile &lt;&lt;-'EOF'export NODE_HONE=/usr/local/nodeexport PATH=$PATH:$NODE_HONE/binEOFsource /etc/profilenpm install -g typescriptnpm install ts-node -Dtsc -v 运行ts文件 1npx ts-node src/app.ts 对a的get，set，get，再对b（原来没有的key） set，get12345678910111213141516171819202122232425/home/tt/Desktop/fabric/my-network/nodes/crypto-config/peerOrganizations/org1.fedfab.comchannelName: channel2chaincodeName: fedfabmspId: Org1MSPcryptoPath: /home/tt/Desktop/fabric/my-network/nodes/crypto-config/peerOrganizations/org1.fedfab.comkeyDirectoryPath: /home/tt/Desktop/fabric/my-network/nodes/crypto-config/peerOrganizations/org1.fedfab.com/users/User1@org1.fedfab.com/msp/keystorecertPath: /home/tt/Desktop/fabric/my-network/nodes/crypto-config/peerOrganizations/org1.fedfab.com/users/User1@org1.fedfab.com/msp/signcerts/User1@org1.fedfab.com-cert.pemtlsCertPath: /home/tt/Desktop/fabric/my-network/nodes/crypto-config/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crtpeerEndpoint: localhost:8051peerHostAlias: peer0.org1.fedfab.com--&gt; Evaluate Transaction: Invoke, function returns all the current assets on the ledger*** Result: bb--&gt; Evaluate Transaction: Invoke, function returns all the current assets on the ledger*** Result: dd--&gt; Evaluate Transaction: Invoke, function returns all the current assets on the ledger*** Result: dd--&gt; Evaluate Transaction: Invoke, function returns all the current assets on the ledger*** Result: cc--&gt; Evaluate Transaction: Invoke, function returns all the current assets on the ledger*** Result: cc 创建http服务使用node-http等库，建立http服务，就可以通过网络请求的方式访问区块链 123456789http://10.128.196.184:3000/invokeChaincodebody:json{ &quot;peer&quot;: 0, &quot;org&quot;: 2, &quot;function&quot;: &quot;set&quot;, &quot;key&quot;: &quot;a&quot;, &quot;val&quot;: &quot;bb&quot;} 12345678http://10.128.196.184:3000/invokeChaincodebody:json{ &quot;peer&quot;: 0, &quot;org&quot;: 2, &quot;function&quot;: &quot;get&quot;, &quot;key&quot;: &quot;a&quot;} 代码","link":"/home/2022/10/22/fedfab/fabric/3.%E9%93%BE%E7%A0%81%E8%BF%90%E8%A1%8C%E4%B8%8EApi%E8%B0%83%E7%94%A8/"},{"title":"fabric-5.论文","text":"需要实现 论文中的新的归一化算法 防止恶意模型更新 客户使用私钥签名模型 fedml的节点作为mec服务器起训练作用，再对原始数据进行处理，模拟移动设备对数据添加噪声 智能合约中记录用户的有效交易，用于用户获取奖励 如何控制fabric的出块？ 实现IPFS peer节点和fedml训练节点之间如何获取对方的公钥，如何避免中间人攻击 笔记IPFS is a peer-to-peer distributed file system that enables distributed computing devices to connect with the same file system. 在IPFS上进行存储，区块链上存储Hash指针，用于找到文件（块大小限制） 在神经网络的中间层添加噪声(ε, δ)-differential，cnn全连接层作为噪声提取器 共识方案是基于股份证明（POS）和拜占庭式容错（BFT） leader是币占比最高的节点，出块需求committee节点超过2/3验证同意，committee节点广播块。 上传新模型的过程 矿工验证上载模型的有效性：矿工验证上传模型的签名，有效则将交易放入交易池。矿工组成的Committee 使用Multi-Krum验证池中的所有交易，并接受合法的更新。领导者生成包含新模型（模型hash/ifps地址）的新块。 leader更新模型 激励机制归一化方法","link":"/home/2022/10/22/fedfab/fabric/5.%E8%AE%BA%E6%96%87/"},{"title":"fabric-4.创建ca","text":"官方教程创建ca节点 参考教程 第一次启动CA时，它查找fabric-ca-server-config.yaml文件，其中包含CA配置参数。 编写创建ca的docker-compose文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586version: '3.7'networks: fed_fab: name: fabric_fedmlservices: ca_org1: image: hyperledger/fabric-ca:latest labels: service: hyperledger-fabric environment: - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server - FABRIC_CA_SERVER_CA_NAME=ca-org1 - FABRIC_CA_SERVER_TLS_ENABLED=true - FABRIC_CA_SERVER_PORT=8050 - FABRIC_CA_SERVER_OPERATIONS_LISTENADDRESS=0.0.0.0:18050 ports: - &quot;8050:8050&quot; - &quot;18050:18050&quot; command: sh -c 'fabric-ca-server start -b admin:adminpw -d' volumes: - ../crypto-config/fabric-ca/org1:/etc/hyperledger/fabric-ca-server container_name: ca_org1 networks: - fed_fab ca_org2: image: hyperledger/fabric-ca:latest labels: service: hyperledger-fabric environment: - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server - FABRIC_CA_SERVER_CA_NAME=ca-org2 - FABRIC_CA_SERVER_TLS_ENABLED=true - FABRIC_CA_SERVER_PORT=9050 - FABRIC_CA_SERVER_OPERATIONS_LISTENADDRESS=0.0.0.0:19050 ports: - &quot;9050:9050&quot; - &quot;19050:19050&quot; command: sh -c 'fabric-ca-server start -b admin:adminpw -d' volumes: - ../crypto-config/fabric-ca/org2:/etc/hyperledger/fabric-ca-server container_name: ca_org2 networks: - fed_fab ca_orderer: image: hyperledger/fabric-ca:latest labels: service: hyperledger-fabric environment: - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server - FABRIC_CA_SERVER_CA_NAME=ca-orderer - FABRIC_CA_SERVER_TLS_ENABLED=true - FABRIC_CA_SERVER_PORT=7051 - FABRIC_CA_SERVER_OPERATIONS_LISTENADDRESS=0.0.0.0:17051 ports: - &quot;7051:7051&quot; - &quot;17051:17051&quot; command: sh -c 'fabric-ca-server start -b admin:adminpw -d' volumes: - ../crypto-config/fabric-ca/ordererOrg:/etc/hyperledger/fabric-ca-server container_name: ca_orderer networks: - fed_fab ca_tls: image: hyperledger/fabric-ca:latest labels: service: hyperledger-fabric environment: - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server - FABRIC_CA_SERVER_CA_NAME=ca-orderer - FABRIC_CA_SERVER_TLS_ENABLED=true - FABRIC_CA_SERVER_PORT=7054 - FABRIC_CA_SERVER_OPERATIONS_LISTENADDRESS=0.0.0.0:17054 ports: - &quot;7054:7054&quot; - &quot;17054:17054&quot; command: sh -c 'fabric-ca-server start -b admin:adminpw -d' volumes: - ../crypto-config/fabric-ca/tls-ca:/etc/hyperledger/fabric-ca-server container_name: ca_tls networks: - fed_fab 启动ca节点1docker-compose -f compose/compose-ca.yaml up -d 可以看到它生成了容器，并在../crypto-config文件夹下生成了各个节点的证书等文件 修改test-network中的registerEnroll.sh并执行1234. ./crypto-config/fabric-ca/registerEnroll.shcreateOrg1createOrg2createOrderer 其他步骤创建好ca后，就可以部署网络节点，chaincode，并使用api调用链码，参考test-network中的操作，将network删除干净，将生成网络和销毁网络整理成脚本/scripts/networkup.sh和/scripts/networkdown.sh","link":"/home/2022/10/22/fedfab/fabric/4.%E5%88%9B%E5%BB%BAca/"},{"title":"fabric-8.yaml-requests","text":"Yaml-Requests 地址","link":"/home/2022/10/22/fedfab/fabric/8.yaml-requests/"},{"title":"fabric-9.服务器配置","text":"centos yum错误1错误：为 repo 'appstream' 下载元数据失败 : Cannot prepare internal mirrorlist: No URLs in mirrorlist 参考12sudo sed -i -e &quot;s|mirrorlist=|#mirrorlist=|g&quot; /etc/yum.repos.d/CentOS-*sudo sed -i -e &quot;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&quot; /etc/yum.repos.d/CentOS-* 查看显卡1lspci | grep -i vga 没有找到合适的显卡驱动 使用命令登录校园网1curl --data ./pwd http://10.3.8.211/login pwd用url-encoding编写以下内容12user: '学号'pass: '密码' hosts文件配置123456789101112131410.112.242.228 lab.server210.112.144.78 lab.server110.128.196.184 tt-HP10.128.196.184 orderer.fedfab.com10.128.196.184 peer0.org2.fedfab.com10.112.144.78 peer0.org1.fedfab.com10.112.144.78 peer1.org1.fedfab.com10.112.144.78 peer2.org1.fedfab.com10.128.196.184 fedml.server10.112.144.78 fedml.worker110.112.144.78 fedml.worker210.112.144.78 fedml.worker3 在所有主机，fabric的docker中都配置一遍 fabric多机搭建参考 docker compose文件中去掉其他机器的的volumes，peer，cli，orderer 使用scp传送证书，*.block，打包好的链码等文件 1scp fedfab.tar.gz tt@tt-HP:/home/tt/Desktop/fabric/my-network/nodes/mtemp 需要使用CouchDB org1的service节点下增加 123456789services: couchdb0.org1.fedfab.com: container_name: couchdb0.org1.fedfab.com image: couchdb:3.1 environment: - COUCHDB_USER=admin - COUCHDB_PASSWORD=adminpw ports: - 5984:5984 org2的service节点下增加 123456789services: couchdb0.org2.fedfab.com: container_name: couchdb0.org2.fedfab.com image: couchdb:3.1 environment: - COUCHDB_USER=admin - COUCHDB_PASSWORD=adminpw ports: - 5984:5984 peer的environments下增加 12345- CORE_LEDGER_STATE_STATEDATABASE=CouchDB- CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=couchdb0.org1.fedfab.com:5984 ## org1 peer- CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=couchdb0.org2.fedfab.com:5984 ## org2 peer- CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME=admin- CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD=adminpw peer的depends_on下增加 12- couchdb0.org1.fedfab.com ## org1 peer- couchdb0.org2.fedfab.com ## org2 peer 不使用networks，使用extra-hosts123456extra_hosts: - &quot;orderer.fedfab.com:10.128.196.184&quot; - &quot;peer0.org1.fedfab.com:10.112.144.78&quot; - &quot;peer1.org1.fedfab.com:10.112.144.78&quot; - &quot;peer2.org1.fedfab.com:10.112.144.78&quot; - &quot;peer0.org2.fedfab.com:10.128.196.184&quot; fedml是否需要？ debug记录调用chaincode失败 chaincode 的container启动时，与对应peer建立tcp连接失败 docker-compose的peer节点上，建立tcp的端口与实际端口的映射","link":"/home/2022/10/22/fedfab/fabric/9.%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"title":"fabric-6.IPFS的安装与使用","text":"IPFS 安装下载地址安装教程ipfs搭建私有网络 Kubo CLIKubo RPC API","link":"/home/2022/10/22/fedfab/fabric/6.IPFS%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"title":"fabric-7.使用nest后端框架","text":"教程","link":"/home/2022/10/22/fedfab/fabric/7.%E4%BD%BF%E7%94%A8nest%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"title":"fedml-1.配置＆运行&amp;自定义","text":"官方文档 repo 克隆fedml库1git clone https://github.com/FedML-AI/FedML.git 参阅源码 参考样例，测试环境 FedML/iot/anomaly_detection_for_cybersecurity FedML/python/setup.py wsl - cuda 参考 安装支持wsl的Nvidia驱动 下载地址 下载安装cuda 不要下载最新版11.7，pytorch目前不支持1234sudo apt updatesudo apt install build-essential #安装c++ make等环境wget https://developer.download.nvidia.com/compute/cuda/11.6.2/local_installers/cuda_11.6.2_510.47.03_linux.runsudo bash cuda_11.6.2_510.47.03_linux.run 环境变量 在目录~/.bashrc下 追加123export CUDA_HOME=/usr/local/cudaexport PATH=$PATH:$CUDA_HOME/binexport LD_LIBRARY_PATH=/usr/local/cuda-11.7/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}} 生效，并安装需要的库12source ~/.bashrcsudo apt-get install freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev libgl1-mesa-glx libglu1-mesa libglu1-mesa-dev 检查是否成功1nvcc -V 12345nvcc: NVIDIA (R) Cuda compiler driverCopyright (c) 2005-2022 NVIDIA CorporationBuilt on Tue_May__3_18:49:52_PDT_2022Cuda compilation tools, release 11.7, V11.7.64Build cuda_11.7.r11.7/compiler.31294372_0 安装 cudnn下载安装 参考 123456sudo apt-get install zlib1ghttps://developer.nvidia.com/rdp/cudnn-downloadtar -xvf cudnn-linux-x86_64-8.4.1.50_cuda11.6-archive.tar.xzsudo cp cudnn-*-archive/include/cudnn*.h /usr/local/cuda/includesudo cp -P cudnn-*-archive/lib/libcudnn* /usr/local/cuda/lib64sudo chmod a+r /usr/local/cuda/include/cudnn*.h /usr/local/cuda/lib64/libcudnn* 后来发现这种方式使用cnn时会报错，找不到cudnn cnn的动态链接库，改用以下方法 1conda install -c nvidia cudnn Table 1. Supported NVIDIA Hardware and CUDA Version cuDNN Package Supported NVIDIA Hardware CUDA Toolkit Version CUDA Compute Capability Supports static linking?1 cuDNN 8.4.1 for CUDA 11.x2 NVIDIA Ampere Architecture NVIDIA Turing™ NVIDIA Volta™ NVIDIA Pascal™ NVIDIA Maxwell® NVIDIA Kepler™ 11.7 SM 3.5 and later Yes 11.6 11.5 11.4 11.3 11.2 No 11.1 11.0 cuDNN 8.4.1 for CUDA 10.2 NVIDIA Turing NVIDIA Volta Xavier™ NVIDIA Pascal NVIDIA Maxwell NVIDIA Kepler 10.2 SM 3.0 and later Yes 安装配置fedml 参考-（bilibili视频的方法已经过时） 安装Miniconda12345wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh./Miniconda3-latest-Linux-x86_64.sh## 最后一步选yes，让脚本自动配置环境变量## 根据输出的内容决定下面source的文件source /root/.bashrc 添加Miniconda源123456conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forgeconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/conda config --set show_channel_urls yes #设置搜索时显示通道地址 安装fedml1234conda create --name fedml python=3.7conda activate fedmlconda install --name fedml pippip install fedml -i https://pypi.douban.com/simple 备忘123456常用pip源：豆瓣：https://pypi.douban.com/simple阿里：https://mirrors.aliyun.com/pypi/simple中国科技大学 ：https://pypi.mirrors.ustc.edu.cn/simple/清华大学： https://pypi.tuna.tsinghua.edu.cn/simple/中国科学技术大学 ：https://pypi.mirrors.ustc.edu.cn/simple/ python包：wasabi-控制台打印和格式化工具包 安装fedml环境 进入FEDML仓库，FedML/python，运行setup.py pytorch安装地址，根据cuda版本选择命令，去掉 -c forge（不从官网下载）1python3 setup.py install 卸载pytorch，重新按照cuda版本进行安装 12conda uninstall *torch* cudatoolkitconda install pytorch torchvision torchaudio cudatoolkit=11.6 运行demoiot 运行iot物联网demo server12conda activate fedmlbash run_server.sh client-112conda activate fedmlbash run_client.sh 1 client-212conda activate fedmlbash run_client.sh 2 后来发现这个demo适用于树莓派、Jeston Nano设备，需要进行一定的配置 这个样例中有自定义data loader和trainer，比较有参考价值 mpi_torch_fedopt_mnist_lr_example 配置文件中，以simulation模式运行的 位置，以simulation模式运行，单进程 1bash run_step_by_step_example.sh 2 参数为2时可以完成训练，参数（即worker）过大，会出现以下提示，怀疑是内存不够12345678910==================================================================================== BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES= PID 5218 RUNNING AT tt= EXIT CODE: 9= CLEANING UP REMAINING PROCESSES= YOU CAN IGNORE THE BELOW CLEANUP MESSAGES===================================================================================YOUR APPLICATION TERMINATED WITH THE EXIT STRING: Killed (signal 9)This typically refers to a problem with your application.Please see the FAQ page for debugging suggestions 训练完成后会在目录./tmp/下生成一个模型文件fedml，执行cat1cat fedml 输出为12training is finished!&lt;fedml.arguments.Arguments object at 0x7ff03c13b210&gt; 使用GPU进行训练修改配置文件 修改config/fedml_config.yaml文件device_args标签下的内容12345device_args: worker_num: 3 using_gpu: true gpu_mapping_file: config/gpu_mapping.yaml #mapping文件位置 gpu_mapping_key: mapping_tt #使用的mapping 修改mapping文件 在文件config/gpu_mapping.yaml下增加节点mapping_tt 12mapping_tt: tt: [4] #只有一个节点tt，一个gpu 增加节点的格式如下，为每个hostname指定在每个gpu下有多少进程 12345## config_cluster0:## host_name_node0: [num_of_processes_on_GPU0, num_of_processes_on_GPU1, num_of_processes_on_GPU2, num_of_processes_on_GPU3, ..., num_of_processes_on_GPU_n]## host_name_node1: [num_of_processes_on_GPU0, num_of_processes_on_GPU1, num_of_processes_on_GPU2, num_of_processes_on_GPU3, ..., num_of_processes_on_GPU_n]## ......## host_name_node_m: [num_of_processes_on_GPU0, num_of_processes_on_GPU1, num_of_processes_on_GPU2, num_of_processes_on_GPU3, ..., num_of_processes_on_GPU_n] 运行，前面配置了4个进程，worker_num配置为3，这里参数就写3， 3个worker + 1个server 1bash run_step_by_step_example.sh 3 过程中在bash中看到输出 12[FedML-Server(0) @device-id-0] [Thu, 28 Jul 2022 20:54:06] [INFO] [gpu_mapping_mpi.py:51:mapping_processes_to_gpu_device_from_yaml_file_mpi] process_id = 2, GPU device = cuda:0[FedML-Server(0) @device-id-0] [Thu, 28 Jul 2022 20:54:06] [INFO] [device.py:78:get_device] device = cuda:0 taskmgr中查看独显占用情况 说明确实使用了gpu cross_silo 运行 非单进程模拟，多个设备运行 config/fedml_config.yaml 配置节点comm_args123comm_args: backend: &quot;GRPC&quot; grpc_ipconfig_path: config/grpc_ipconfig.csv grpc_ipconfig.csv 安装pip install grpcio，使用grpc协议进行通信 在/config下创建该文件，写入编号-ip，0为server，1...n为worker receiver_id ip 0 127.0.0.1 1 127.0.0.1 2 127.0.0.1 结果 没有找到输出的模型文件，只在最后一轮结束后找到了以下输出123[FedML-Server(0) @device-id-0] [Fri, 29 Jul 2022 22:54:08] [INFO] [fedml_aggregator.py:195:test_on_server_for_all_clients] ################test_on_server_for_all_clients : 49[FedML-Server(0) @device-id-0] [Fri, 29 Jul 2022 22:54:12] [INFO] [fedml_aggregator.py:225:test_on_server_for_all_clients] {'training_acc': 0.796526336274001, 'training_loss': 1.8660167525693983}[FedML-Server(0) @device-id-0] [Fri, 29 Jul 2022 22:54:13] [INFO] [fedml_aggregator.py:257:test_on_server_for_all_clients] {'test_acc': 0.8005698005698005, 'test_loss': 1.8635211240936371} fedml自定义fedml运行参数 fedml运行时需要几个参数 参数 含义 可选值 –cf 配置文件 / –rank 序号，server为0 0,1,2,3 –role server 或 client server, client fedml运行流程1234567891011121314args = fedml.init()## init devicedevice = fedml.device.get_device(args)## load datadataset, output_dim = fedml.data.load(args)## load modelmodel = fedml.model.create(args, output_dim)## start trainingfedml_runner = FedMLRunner(args, device, dataset, model)fedml_runner.run() DataLoader, Model, Trainer都是可以自定义的 参考 DataLoader的自定义 支持MNN，pytorch的DataLoader 输出数据集和输出的维数 模型的自定义 支持pytorch的神经网络模型，torch.nn Trainer的自定义1234567891011121314151617181920from fedml.core import ClientTrainerclass MyModelTrainer(ClientTrainer): #继承ClientTrainer def get_model_params(self): return self.model.cpu().state_dict() def set_model_params(self, model_parameters): self.model.load_state_dict(model_parameters) def train(self, train_data, device, args): #实现模型的训练 pass def test(self, test_data, device, args): pass def test_on_the_server( self, train_data_local_dict, test_data_local_dict, device, args=None ) -&gt; bool: #实现对模型的评估 return True 用qemu虚拟机模拟多台机器（未完成）安装 参考连接 Ninja的安装1sudo apt install ninja-build pkg-config1 12345wget https://download.qemu.org/qemu-7.1.0-rc0.tar.xztar xvJf qemu-7.1.0-rc0.tar.xzcd qemu-7.1.0-rc0./configuremake 使用虚拟机环境，需要对qemu配置显卡直通","link":"/home/2022/10/22/fedfab/fedml/1.%E9%85%8D%E7%BD%AE%EF%BC%86%E8%BF%90%E8%A1%8C&%E8%87%AA%E5%AE%9A%E4%B9%89/"},{"title":"fedml-2.Docker多容器配置","text":"Docker安装1curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 中间遇到输出，提示建议使用for windows12WSL DETECTED: We recommend using Docker Desktop for Windows.Please get Docker Desktop from https://www.docker.com/products/docker-desktop 创建容器并配置环境验证是否可以使用gpu 官方参考1docker run --gpus all nvcr.io/nvidia/k8s/cuda-sample:nbody nbody -gpu -benchmark pull fedml镜像1docker pull fedml/fedml:cuda-11.4.0-devel-ubuntu20.04 编写运行脚本并运行1234567891011121314151617181920212223FEDML_DOCKER_IMAGE=fedml/fedml:cuda-11.4.0-devel-ubuntu20.04WORKSPACE=~/Desktop/docker_workspaceFEDML_REPO=~/Desktop/FedMLDATA=~/fedml_dataID=$1IP=$2NUM=$3HOSTNAME=$4sudo docker run -itd -v $WORKSPACE:/home/workspace -v $FEDML_REPO:/home/fedml_repo -v $DATA:/root/fedml_data \\--shm-size=64g --ulimit nofile=65535 --ulimit memlock=-1 --privileged \\--env FEDML_NODE_INDEX=$ID \\--env WORKSPACE=$WORKSPACE \\--env FEDML_NUM_NODES=$NUM \\--env FEDML_MAIN_NODE_INDEX=0 \\--env FEDML_RUN_ID=$ID \\--env FEDML_MAIN_NODE_PRIVATE_IPV4_ADDRESS=$IP \\--gpus all \\--hostname $HOSTNAME \\-u fedml --net=host \\$FEDML_DOCKER_IMAGE \\/bin/bash 创建两个容器12bash run_fedml_docker.sh 1 2 127.0.0.1 worker1bash run_fedml_docker.sh 2 2 127.0.0.1 worker2 修改GPU MAPPING1234mapping_default: tt: [1] worker1: [1] worker2: [1] 初始化fedml 分别在两个docker内运行1sudo /home/code/setup_docker.sh 更新fedml 自带的pytorch支持的gpu算力等级太低，需要更新 在主节点下启动server1bash run_server.sh 在容器中启动client12bash run_client.sh 1bash run_client.sh 2 可以正常运行，也可以正常调用gpu 使用Dockerfile避免setup_docker.sh 节省空间 避免重复下载环境 新建一个空目录，在其中创建文件Dockerfile1234FROM fedml/fedml:cuda-11.4.0-devel-ubuntu20.04RUN python -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade pipRUN pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simpleRUN pip3 install --upgrade fedml 对于算力较高的gpu，更新pytorch 12345678FROM fedml/fedml:cuda-11.4.0-devel-ubuntu20.04RUN python -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade pipRUN pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simpleRUN pip3 install --upgrade fedmlRUN pip3 uninstall -y torchRUN pip3 uninstall -y torchaudioRUN pip3 uninstall -y torchvisionRUN pip3 install torch torchvision torchaudio --extra-index-url https://download.pytorch.org/whl/cu116 #3050TI 在该目录下执行1sudo docker build -t fedml:tt . 使用fedml:tt创建container1234567891011121314151617181920212223FEDML_DOCKER_IMAGE=fedml:tt ### 这里WORKSPACE=~/Desktop/docker_workspaceFEDML_REPO=~/Desktop/FedMLDATA=~/fedml_dataID=$1IP=$2NUM=$3HOSTNAME=$4sudo docker run -itd -v $WORKSPACE:/home/workspace -v $FEDML_REPO:/home/fedml_repo -v $DATA:/root/fedml_data \\--shm-size=64g --ulimit nofile=65535 --ulimit memlock=-1 --privileged \\--env FEDML_NODE_INDEX=$ID \\--env WORKSPACE=$WORKSPACE \\--env FEDML_NUM_NODES=$NUM \\--env FEDML_MAIN_NODE_INDEX=0 \\--env FEDML_RUN_ID=$ID \\--env FEDML_MAIN_NODE_PRIVATE_IPV4_ADDRESS=$IP \\--gpus all \\--hostname $HOSTNAME \\-u fedml --net=host \\$FEDML_DOCKER_IMAGE \\/bin/bash 容器创建脚本 创建容器并开始观测gpu使用率123456789sudo docker stop $(sudo docker ps -a | awk '{ print $1}' | tail -n +2)sudo docker container pruneread -n1 -p &quot;Press any key to create containers...&quot;./run_fedml_docker.sh 0 127.0.0.1 3 server./run_fedml_docker.sh 1 127.0.0.1 3 worker1./run_fedml_docker.sh 2 127.0.0.1 3 worker2docker ps -aread -n1 -p &quot;Press any key to continue...&quot;watch -n 1 nvidia-smi","link":"/home/2022/10/22/fedfab/fedml/2.Docker%E5%A4%9A%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"title":"fedml-3.Runner源码阅读","text":"wandb 的使用 在wandb官网project页面创建工程 获取wandb_key 配置config.yaml enable - true wandb key priject name123456tracking_args: log_file_dir: ./log enable_wandb: true #enable wandb_key: e3be1b9a8ab45f14a6ff454009bc7ca07b8792ba #key wandb_project: fedml_mnist_test #project name wandb_name: fedml_torch_fedavg_mnist_lr 运行 运行时选择2，将key再输入一次1234567wandb: (1) Create a W&amp;B accountwandb: (2) Use an existing W&amp;B accountwandb: (3) Dont visualize my resultswandb: Enter your choice: 2wandb: You chose 'Use an existing W&amp;B account'wandb: You can find your API key in your browser here: https://wandb.ai/authorizewandb: Paste an API key from your profile and hit enter, or press ctrl+c to quit: wandb结果 在终端输出了1234567891011121314151617181920212223242526272829303132333435363738394041424344wandb: Waiting for W&amp;B process to finish... (success).wandb: wandb: wandb: Run history:wandb: AggregationTime ▂▃▃▂▂▃▃▃▃▂▃▃▁▃▃▂▃▇▃▃▃▇▂▃▃▂▃▃█▃▂▂▂▃▃▃▃▁▂▂wandb: BenchmarkStart ▁wandb: BusyTime ▁▄▄▄▄▃▅▃▂▄▆▃▃▇▄▃▅█▃▆▄▅▅▅▃▂▄▅▄▃▄▃▄▄▃▂▄▃▃█wandb: Comm/recieve_delay_s3 ▃▁▂▁▂▂▁▂▂▂▁▂▂▁▃▄▂▄▂▂▁█▂▂▂▂▄▂▁▂▂▂▃▂▃▁▁▂▂▃wandb: Comm/send_delay █▃▂▁▁▁▃▂▂▁▂▆▁▄▂▃▅▂▂▂▂▁▁▁▂▁▁▁▁▁▁▃▁▁▂▂▁▁▂▁wandb: Comm/send_delay_mqtt ▃▆▆▇▆▆▇▆▆▆▆▆▆▆▂▆▆▆▆▆▆▆▆▁█▆▆▆▆▆▁▆▆▁▁▆▆▆█▁wandb: Communiaction/Send_Total █▃▂▁▁▁▃▂▂▁▂▆▁▄▂▃▅▂▂▂▂▁▁▁▂▁▁▁▁▁▁▃▁▁▂▂▁▁▂▁wandb: ListenStart ▁wandb: MessageReceiveTime ▁▁▂▂▂▂▂▂▂▂▂▂▄▄▄▄▄▄▄▄▅▅▅▅▅▅▅▅▇▇▇▇▇▇▇▇▇▇██wandb: PickleDumpsTime █▁▅▁▁▁▂▆▃▅▂▃▅▁▁▁▅▁▆▅▁▁▅▅▁▄▅▅▁▅▅▅▁▁▅▅▅▂▅▁wandb: Test/Acc ▁▄▄▅▆▆▆████wandb: Test/Loss █▆▅▃▃▂▂▁▁▁▁wandb: TotalTime ▁wandb: Train/Acc ▁▄▄▅▆▆▆████wandb: Train/Loss █▆▅▄▃▂▂▁▁▁▁wandb: UnpickleTime █▄▄▃█▄▄▄▄▄▇▇▄▇▄▁▄▇▄▁▄▇▇▄▇▂▄▇▄▄▄▄▄▄▇▄▄▂▁▄wandb: round ▁▁▁▁▂▂▂▂▂▂▃▃▃▃▃▄▄▄▄▅▅▅▅▅▅▅▆▆▆▆▇▇▇▇▇▇▇███wandb: wandb: Run summary:wandb: AggregationTime 0.00103wandb: BenchmarkStart 1660014268.494wandb: BusyTime 8.49421wandb: Comm/recieve_delay_s3 3.13148wandb: Comm/send_delay 0.40766wandb: Comm/send_delay_mqtt 4e-05wandb: Communiaction/Send_Total 0.40971wandb: ListenStart 1660014198.82541wandb: MessageReceiveTime 1660014798.21999wandb: PickleDumpsTime 0.00032wandb: Test/Acc 0.80057wandb: Test/Loss 1.86352wandb: TotalTime 607.89401wandb: Train/Acc 0.79653wandb: Train/Loss 1.86602wandb: UnpickleTime 0.00087wandb: round 49wandb: wandb: Synced exalted-eon-1: https://wandb.ai/tt_blockchain/fedml_mnist_test/runs/3850zs40wandb: Synced 5 W&amp;B file(s), 0 media file(s), 0 artifact file(s) and 0 other file(s)wandb: Find logs at: ./wandb/run-20220809_030244-3850zs40/logs 在网页中输出情况report.pdf FedMLRunner 该Runner是通用的runner 根据args.training_type进行初始化 simulation cross silo cross device _init_simulation_runner 根据args中的backend构造runner SP -&gt; SimulatorSingleProcess MPI -&gt; SimulatorMPI NCCL -&gt; SimulatorNCCL _init_cross_silo_runner 根据args.role为 clientorserver构造runner client -&gt; Client server -&gt; Sever _init_cross_device_runner args.role 为 sever，构造ServerMNN，否则raise Exception Sever FedMLCrossSiloServer 若federated_optimizer为FedAvg，trainer = server_initializer.init_server 若federated_optimizer为LSA，trainer=FedML_LSA_Horizontal server_initializer.init_server 创建Aggregator - 聚集器，处理训练相关的任务，将Client的模型聚集并更新全局模型 创建FedMLServerManager - 收发网络请求 FedML_LSA_Horizontal 根据client rank init server或client init server会创建Aggregator和ServerManager init client会创建Trainer和ClientManager，一般role为server，rank也是0，这一步应该不会走到 Client FedMLCrossSiloClient 若federated_optimizer为FedAvg，trainer = client_initializer.init_client 若federated_optimizer为LSA，trainer=FedML_LSA_Horizontal Aggregator FedMLAggregator 通过cross silo找到的 还有FedSegAggregator、BaseLocalAggregator、RobustAggregator等 函数 add_local_trained_result和check_whether_all_receive add_local_trained_result负责记录local的训练结果 check_whether_all_receive负责检查是否全部上传本地模型，若是，则将全部flag置为False aggregate 计算出总的训练样本数目（所有client训练的样本数之和） 根据本地样本数/总训练数计算权值w 根据权值算出模型参数的加权平均 更新全局模型 data_silo_selection 若每轮训练数和总client数相同，则返回0...n-1，否则随机从中随机寻找一部分 client_selection 也是一个随机选择，和上一个差不多 client_sampling 看起来和data_silo_selection一模一样 test_on_server_for_all_clients if self.trainer.test_on_the_server : return 每隔n轮一次test 或 最后一轮时进行test(对训练集) 对于每一个client，计算TP+TN，训练个数，loss，并保存 计算总的acc和loss，打log，若启用了wandb，则使用wandb api记录 对测试集进行测试，log，wandb记录 FedMLServerManager父类 ServerManager函数 __init__ 根据backend具体指定的协议名称构造对应的CommunicationManager run 执行register_message_receive_handlers（子类实现），用于注册子类定义的几种消息和消息对应的callback函数，当收到对应消息类型时调用相应函数 执行具体协议对应的CommunicationManager的handle_receive_message receive_message 参数，msg_type，msg_params 从一个字典中根据msgType获取callback，并调用，传递msg_params send_message 通过CommunicationManager发送 register_message_receive_handler 维护message_handler_dict，即前面提到的callback字典 注册新的msg_type和他的callback finish 将CommunicationManager stop掉 FedMLServerManager的函数 run super().run() send_init_msg 发送初始化信息 对于本轮中的每一个参与的client，发送初始模型参数，通过函数send_message_init_config send_message_init_config通过父类的send_message实现 register_message_receive_handlers 注册三类信息的处理函数，通过父类的register_message_receive_handler实现 client的connection ready client的status change 当所有的client都online，调用send_init_msg client的model发送 通过Aggregator的add_local_trained_result将参数中的模型参数，训练样本数等信息聚集起来 如果全部发送了模型信息 调用Aggregator的aggregate函数更新全局模型，test_on_server_for_all_clients函数进行模型的测试。 进行下一轮训练，全局模型发送至下一轮的机器中，通过send_message_sync_model_to_client函数 轮数+=1，若轮数达到预定的总轮数，调用cleanup函数 cleanup- 向所有client发送finis信息- 延迟3s，调用finish结束自己（父类的finish） 三个handle_* register_message_receive_handlers中注册的三个函数，用于处理客户端的消息 几个send_* 在前面都有提到，向客户端发送信息 FedMLCrossSiloClient 如果args.scenario HIERARCHICAL，则根据rank，若rank为0，构造ClientMasterManager，否则构造ClientSlaveManager HORIZONTAL，构造ClientMasterManager Master客户端的父类–ClientManager 与ServerManager类似，根据协议构造CommunicationManager，提供消息类型与回调的注册函数，提供send_message函数 不同点在于Server的Host和Port固定，Client从配置中读取 ClientMasterManager 和ServerManager类似，处理网络消息，给server发送信息（如本地模型信息等） 训练本地模型 ClientSlaveManager 处理本地训练 Observer 定义抽象函数receive_message，communicationManager会调用observer的这个函数，将受到的消息类型，参数传递给子类，上面的例子中都是使用消息类型-handle函数的dict实现对不同类型的消息进行处理 结论 根据FedML+BlockChain的定义双方之间的通信流程，根据通信流程分别置顶S-C的通信消息，直接基于ClientManager和ServerManager，自定义一个FedMLBlockChainServer和FedMLBlockChainServer，实现这个通信过程。","link":"/home/2022/10/22/fedfab/fedml/3.Runner%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"title":"fabric-2.fabric自定义与实践","text":"手动搭建hyperledger fabric v2.x，其中第二个视频中，创建组织的锚节点文件已经被弃用 命令参考 计划配置一个4个节点的网络，三个节点模拟IOT设备，一个代表公司节点 主要工作 创建了一个拥有两个org的通道 自定义了一个网络，org1拥有三个节点，org2拥有1个节点 用go语言自定义了chaincode并编译 在网络上安装通道，执行链码 fabric环境变量 为了使用cryptogen等工具123cd fabric-samples/binsudo echo export PATH=\\$PATH:$(pwd) &gt;&gt; ~/.bashrcsource ~/.bashrc 创建节点目录，使用cryptogen命令cryptogen 有如下五个子命令: help generate showtemplate extend version 创建模板文件1cryptogen showtemplate &gt; crypto-config.yaml 修改模板排序节点12345678910111213141516## ---------------------------------------------------------------------------## &quot;OrdererOrgs&quot; - Definition of organizations managing orderer nodes## ---------------------------------------------------------------------------OrdererOrgs: ## --------------------------------------------------------------------------- ## Orderer ## --------------------------------------------------------------------------- - Name: Orderer Domain: fedfab.com EnableNodeOUs: false ## --------------------------------------------------------------------------- ## &quot;Specs&quot; - See PeerOrgs below for complete description ## --------------------------------------------------------------------------- Specs: - Hostname: orderer EnableNodeOUs，即是否启用Organization Unit peer节点（组织1）123456789101112131415PeerOrgs: ## --------------------------------------------------------------------------- ## Org1 ## --------------------------------------------------------------------------- - Name: Org1 Domain: org1.fedfab.com EnableNodeOUs: false #这里改为true Template: Count: 1 ## 这里改为3. ## Start: 5 ## Hostname: {{.Prefix}}{{.Index}} ## default ## SANS: ## - &quot;{{.Hostname}}.alt.{{.Domain}}&quot; Users: Count: 1 #这里也改为3 User指操纵终端的人，在终端操纵的人 peer节点（组织2）12345678910#---------------------------------------------------------------------------## Org2: See &quot;Org1&quot; for full specification## ---------------------------------------------------------------------------- Name: Org2 Domain: org2.fedfab.com EnableNodeOUs: false #改成true Template: Count: 1 Users: Count: 1 生成证书文件1cryptogen generate --config=crypto-config.yaml 输出，并创建了证书文件12org1.fedfab.comorg2.fedfab.com 进入一个组织查看12tt@tt-HP:~/Desktop/fabric/my-network/nodes/crypto-config/peerOrganizations/org1.fedfab.com$ lsca msp peers tlsca users 创建通道 编写configtx.yaml配置文件 使用configtxgen命令创建通道 configtxgen的使用 configtxgen 工具没有子命令，但是支持flag，通过设置flag可以完成不同的任务。12345678910111213141516171819202122232425Usage of configtxgen: -asOrg string 以特定组织（按名称）执行配置生成，仅包括组织（可能）有权设置的写集中的值。 -channelCreateTxBaseProfile string 指定要视为排序系统通道当前状态的轮廓（profile），以允许在通道创建交易生成期间修改非应用程序参数。仅在与 “outputCreateChannelTX” 结合时有效。 -channelID string 配置交易中使用的通道 ID。 -configPath string 包含所用的配置的路径。（如果设置的话） -inspectBlock string 打印指定路径的区块中包含的配置。 -inspectChannelCreateTx string 打印指定路径的交易中包含的配置。 -outputAnchorPeersUpdate string 创建一个更新锚节点的配置更新（仅在默认通道创建时有效，并仅用于第一次更新）。 -outputBlock string 写入创世区块的路径。（如果设置的话） -outputCreateChannelTx string 写入通道创建交易的路径。（如果设置的话） -printOrg string 以 JSON 方式打印组织的定义。（手动向通道中添加组织时很有用） -profile string configtx.yaml 中用于生成的轮廓。 -version 显示版本信息。 configtx.yaml的编写官方文档在创建新通道中详细介绍了configtx.yaml的写法 这里我直接复制test-network中的配置文件并进行相应修改 创建configtx文件夹1mkdir configtx 修改配置文件 修改msp文件地址将配置文件中的MSPDir-msp地址修改为在生成证书文件步骤中生成的文件的目录 修改证书地址将配置文件中的ClientTLSCert和ServerTLSCert修改为在生成证书文件步骤中生成的文件的目录 写入创世块的配置文件 12345678910111213TwoOrgsOrdererGenesis: &lt;&lt;: *ChannelDefaults Orderer: &lt;&lt;: *OrdererDefaults Organizations: - *OrdererOrg Capabilities: &lt;&lt;: *OrdererCapabilities Consortiums: SampleConsortium: Organizations: - *Org1 - *Org2 编写yaml文件时要注意缩进，否则将导致执行失败 写入创建应用通道的配置 12345678910TwoOrgsChannel: Consortium: SampleConsortium &lt;&lt;: *ChannelDefaults Application: &lt;&lt;: *ApplicationDefaults Organizations: - *Org1 - *Org2 Capabilities: &lt;&lt;: ***ApplicationCapabilities** 创建环境变量1export FABRIC_CFG_PATH=${PWD}/configtx 创建创世块1configtxgen -profile TwoOrgsOrdererGenesis -channelID system-channel -outputBlock ./system-genesis-block/genesis.block 得到输出 12345672022-08-27 20:52:53.432 CST 0001 INFO [common.tools.configtxgen] main -&gt; Loading configuration2022-08-27 20:52:53.441 CST 0002 INFO [common.tools.configtxgen.localconfig] completeInitialization -&gt; orderer type: etcdraft2022-08-27 20:52:53.441 CST 0003 INFO [common.tools.configtxgen.localconfig] completeInitialization -&gt; Orderer.EtcdRaft.Options unset, setting to tick_interval:&quot;500ms&quot; election_tick:10 heartbeat_tick:1 max_inflight_blocks:5 snapshot_interval_size:16777216 2022-08-27 20:52:53.441 CST 0004 INFO [common.tools.configtxgen.localconfig] Load -&gt; Loaded configuration: /home/tt/Desktop/fabric/my-network/nodes/configtx/configtx.yaml2022-08-27 20:52:53.443 CST 0005 INFO [common.tools.configtxgen] doOutputBlock -&gt; Generating genesis block2022-08-27 20:52:53.443 CST 0006 INFO [common.tools.configtxgen] doOutputBlock -&gt; Creating system channel genesis block2022-08-27 20:52:53.443 CST 0007 INFO [common.tools.configtxgen] doOutputBlock -&gt; Writing genesis block 创建应用通道123configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel2.tx -channelID channel2configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID channel2 -asOrg Org1MSPconfigtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID channel2 -asOrg Org2MSP 得到输出 12342022-08-27 21:01:01.223 CST 0001 INFO [common.tools.configtxgen] main -&gt; Loading configuration2022-08-27 21:01:01.233 CST 0002 INFO [common.tools.configtxgen.localconfig] Load -&gt; Loaded configuration: /home/tt/Desktop/fabric/my-network/nodes/configtx/configtx.yaml2022-08-27 21:01:01.233 CST 0003 INFO [common.tools.configtxgen] doOutputChannelCreateTx -&gt; Generating new channel configtx2022-08-27 21:01:01.235 CST 0004 INFO [common.tools.configtxgen] doOutputChannelCreateTx -&gt; Writing new channel tx 创建peer节点和order节点 使用docker compose对节点容器进行定义 在test-network的基础上进行修改 修改order节点1234567891011121314151617181920212223242526272829303132333435363738394041424344orderer.fedfab.com: container_name: orderer.fedfab.com image: hyperledger/fabric-orderer:latest labels: service: hyperledger-fabric environment: - FABRIC_LOGGING_SPEC=INFO - ORDERER_GENERAL_LISTENADDRESS=0.0.0.0 - ORDERER_GENERAL_LISTENPORT=7050 - ORDERER_GENERAL_LOCALMSPID=OrdererMSP - ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/msp ## enabled TLS - ORDERER_GENERAL_TLS_ENABLED=true - ORDERER_GENERAL_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key - ORDERER_GENERAL_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt - ORDERER_GENERAL_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt] - ORDERER_GENERAL_CLUSTER_CLIENTCERTIFICATE=/var/hyperledger/orderer/tls/server.crt - ORDERER_GENERAL_CLUSTER_CLIENTPRIVATEKEY=/var/hyperledger/orderer/tls/server.key - ORDERER_GENERAL_CLUSTER_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt] ## - ORDERER_GENERAL_BOOTSTRAPMETHOD=none #去掉 - ORDERER_GENERAL_GENESISMETHOD=file #增加 - ORDERER_GENERAL_GENESISFILE=/var/hyperledger/orderer/system-genesis-block/genesis.block #增加 - ORDERER_CHANNELPARTICIPATION_ENABLED=true - ORDERER_ADMIN_TLS_ENABLED=true - ORDERER_ADMIN_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt - ORDERER_ADMIN_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key - ORDERER_ADMIN_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt] - ORDERER_ADMIN_TLS_CLIENTROOTCAS=[/var/hyperledger/orderer/tls/ca.crt] - ORDERER_ADMIN_LISTENADDRESS=0.0.0.0:7053 - ORDERER_OPERATIONS_LISTENADDRESS=orderer.fedfab.com:9443 - ORDERER_METRICS_PROVIDER=prometheus working_dir: /root command: orderer volumes: - ../crypto-config/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp:/var/hyperledger/orderer/msp - ../crypto-config/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/tls/:/var/hyperledger/orderer/tls - ../system-genesis-block/:/var/hyperledger/orderer/system-genesis-block #增加 - orderer.fedfab.com:/var/hyperledger/production/orderer ports: - 7050:7050 - 7053:7053 - 9443:9443 networks: - test 后续会手动生成创世块，需要在compose中指定生成的创世块 增加节点个数 test-network中只有三个节点（排序和两个peer节点），现在修改为1排序+3org1+1org2 123456volumes: orderer.fedfab.com: peer0.org1.fedfab.com: peer1.org1.fedfab.com: peer2.org1.fedfab.com: peer0.org2.fedfab.com: 增加org1中的节点配置，以下面的配置文件为模板1234567891011121314151617181920212223242526272829303132333435363738peer0.org1.fedfab.com: #修改 container_name: peer0.org1.fedfab.com #修改 image: hyperledger/fabric-peer:latest labels: service: hyperledger-fabric environment: - FABRIC_CFG_PATH=/etc/hyperledger/peercfg - FABRIC_LOGGING_SPEC=INFO #- FABRIC_LOGGING_SPEC=DEBUG - CORE_PEER_TLS_ENABLED=true - CORE_PEER_PROFILE_ENABLED=false - CORE_PEER_TLS_CERT_FILE=/etc/hyperledger/fabric/tls/server.crt - CORE_PEER_TLS_KEY_FILE=/etc/hyperledger/fabric/tls/server.key - CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/tls/ca.crt ## Peer specific variables - CORE_PEER_ID=peer0.org1.fedfab.com #修改 - CORE_PEER_ADDRESS=peer0.org1.fedfab.com:7051 #修改 - CORE_PEER_LISTENADDRESS=0.0.0.0:7051 - CORE_PEER_CHAINCODEADDRESS=peer0.org1.fedfab.com:7052 #修改 - CORE_PEER_CHAINCODELISTENADDRESS=0.0.0.0:7052 - CORE_PEER_GOSSIP_BOOTSTRAP=peer0.org1.fedfab.com:7051 #修改 - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org1.fedfab.com:7051 - CORE_PEER_LOCALMSPID=Org1MSP - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/fabric/msp - CORE_OPERATIONS_LISTENADDRESS=peer0.org1.fedfab.com:9444 #修改 - CORE_METRICS_PROVIDER=prometheus - CHAINCODE_AS_A_SERVICE_BUILDER_CONFIG={&quot;peername&quot;:&quot;peer0org1&quot;} #修改 - CORE_CHAINCODE_EXECUTETIMEOUT=300s volumes: - ../organizations/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com:/etc/hyperledger/fabric #修改 - peer0.org1.fedfab.com:/var/hyperledger/production #修改 working_dir: /root command: peer node start ports: - 7051:7051 #修改 - 9444:9444 #修改 networks: - test 修改容器的文件夹映射 将tls，mse等路径，域名名称修改正确 修改端口号 编号 端口配置 orderer.fedfab.com 7050:7050, 7053:7053, 9443:9443 peer0.org1.fedfab.com 8051:7051, 9444:9444 peer1.org1.fedfab.com 8052:7051, 9445:9444 peer2.org1.fedfab.com 8053:7051, 9446:9444 peer0.org2.fedfab.com 9051:7051, 9447:9444 CLI（命令行接口）配置 为每个节点创建一个cli 参考官方的cli配置教程，cli需要以下环境变量123456export FABRIC_CFG_PATH=$PWD/../config/export CORE_PEER_TLS_ENABLED=trueexport CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crtexport CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.fedfab.com/users/Admin@org1.fedfab.com/mspexport CORE_PEER_ADDRESS=localhost:7051 根据上述环境变量和test-network中的cli配置，编写四个节点的cli123456789101112131415161718192021222324252627282930313233cli1: #修改 container_name: cli1 #修改 image: hyperledger/fabric-tools:latest labels: service: hyperledger-fabric tty: true stdin_open: true environment: - GOPATH=/opt/gopath - FABRIC_LOGGING_SPEC=INFO - FABRIC_CFG_PATH=/etc/hyperledger/peercfg #- FABRIC_LOGGING_SPEC=DEBUG - CORE_PEER_ID=cli1 #修改 - CORE_PEER_TLS_ENABLED=true - CORE_PEER_LOCALMSPID=Org1MSP #修改 - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/server.crt #修改 - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/server.key #修改 - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt #修改 - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/users/Admin@org1.fedfab.com/msp #修改 - CORE_PEER_ADDRESS=peer0.org1.fedfab.com:8051 #修改 working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer command: /bin/bash volumes: - ../crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto - ../scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/ - /var/run/:/host/var/run/ - ../chaincode/go/:/opt/gopath/src/github.com/hyperledger/fabric-cluster/chaincode/go - ../channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts - ./docker/peercfg:/etc/hyperledger/peercfg depends_on: - peer0.org1.fedfab.com #修改 networks: - test 运行1docker-compose up -d 得到输出 123456789101112131415Creating network &quot;fabric_test&quot; with the default driverCreating volume &quot;compose_orderer.fedfab.com&quot; with default driverCreating volume &quot;compose_peer0.org1.fedfab.com&quot; with default driverCreating volume &quot;compose_peer1.org1.fedfab.com&quot; with default driverCreating volume &quot;compose_peer2.org1.fedfab.com&quot; with default driverCreating volume &quot;compose_peer0.org2.fedfab.com&quot; with default driverCreating peer0.org1.fedfab.com ... doneCreating peer0.org2.fedfab.com ... doneCreating peer1.org1.fedfab.com ... doneCreating peer2.org1.fedfab.com ... doneCreating orderer.fedfab.com ... doneCreating cli0 ... doneCreating cli3 ... doneCreating cli1 ... doneCreating cli2 ... done 验证容器是否启动1docker ps -a 12345678910CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd6a76f883fff hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 3 seconds ago Up 2 seconds cli377b3a4f45dd7 hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 3 seconds ago Up 2 seconds cli1cc967bbbffbc hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 3 seconds ago Up 2 seconds cli24cac839a509e hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 4 seconds ago Up 2 seconds cli0dd8fb44841ed hyperledger/fabric-peer:latest &quot;peer node start&quot; 4 seconds ago Exited (1) 2 seconds ago peer1.org1.fedfab.com37d044dc815b hyperledger/fabric-peer:latest &quot;peer node start&quot; 4 seconds ago Exited (1) 3 seconds ago peer2.org1.fedfab.comc5d9572fd1b0 hyperledger/fabric-peer:latest &quot;peer node start&quot; 4 seconds ago Exited (1) 2 seconds ago peer0.org2.fedfab.comfa43da3532d7 hyperledger/fabric-orderer:latest &quot;orderer&quot; 4 seconds ago Up 3 seconds 0.0.0.0:7050-&gt;7050/tcp, :::7050-&gt;7050/tcp, 0.0.0.0:7053-&gt;7053/tcp, :::7053-&gt;7053/tcp, 0.0.0.0:9443-&gt;9443/tcp, :::9443-&gt;9443/tcp orderer.fedfab.com45b71846f669 hyperledger/fabric-peer:latest &quot;peer node start&quot; 4 seconds ago Exited (1) 3 seconds ago peer0.org1.fedfab.com 使用logs命令查看日志 12docker logs peer0.org1.fedfab.com2022-08-28 11:18:05.811 UTC 0001 ERRO [main] InitCmd -&gt; Fatal error when initializing core config : FABRIC_CFG_PATH /etc/hyperledger/peercfg does not exist 根据docker hub - fabric-peer的描述，在FABRIC_CFG_PATH下需要有core.yaml文件 复制一份test-network的core.yaml到compose文件夹下 在peer节点中添加映射 1- ./docker/peercfg:/etc/hyperledger/peercfg 再次尝试创建容器，并使用ps命令验证 12345678910CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESeaa7a6ad0dc4 hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 4 seconds ago Up 3 seconds cli36cfcf59846eb hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 5 seconds ago Up 3 seconds cli229fe65400204 hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 5 seconds ago Up 3 seconds cli14ac9037d3c2c hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 5 seconds ago Up 4 seconds cli0a5e90a5b170a hyperledger/fabric-peer:latest &quot;peer node start&quot; 5 seconds ago Up 4 seconds 7051/tcp, 0.0.0.0:9051-&gt;9051/tcp, :::9051-&gt;9051/tcp, 0.0.0.0:9447-&gt;9445/tcp, :::9447-&gt;9445/tcp peer0.org2.fedfab.com9b3b0f6445d2 hyperledger/fabric-peer:latest &quot;peer node start&quot; 5 seconds ago Up 4 seconds 0.0.0.0:9444-&gt;9444/tcp, :::9444-&gt;9444/tcp, 0.0.0.0:8051-&gt;7051/tcp, :::8051-&gt;7051/tcp peer0.org1.fedfab.com5d75a82337c8 hyperledger/fabric-peer:latest &quot;peer node start&quot; 5 seconds ago Up 4 seconds 0.0.0.0:8052-&gt;7051/tcp, :::8052-&gt;7051/tcp, 0.0.0.0:9445-&gt;9444/tcp, :::9445-&gt;9444/tcp peer1.org1.fedfab.com5eb7a92eb4e0 hyperledger/fabric-orderer:latest &quot;orderer&quot; 5 seconds ago Up 4 seconds 0.0.0.0:7050-&gt;7050/tcp, :::7050-&gt;7050/tcp, 0.0.0.0:7053-&gt;7053/tcp, :::7053-&gt;7053/tcp, 0.0.0.0:9443-&gt;9443/tcp, :::9443-&gt;9443/tcp orderer.fedfab.com17c6798b2dc9 hyperledger/fabric-peer:latest &quot;peer node start&quot; 5 seconds ago Up 4 seconds 0.0.0.0:8053-&gt;7051/tcp, :::8053-&gt;7051/tcp, 0.0.0.0:9446-&gt;9444/tcp, :::9446-&gt;9444/tcp peer2.org1.fedfab.com 全部容器都已经启动成功！ 补充 在test-network的network.sh脚本中仔细观察docker-compose的代码发现，test-network中使用了多个yml文件进行配置 123456789101112131415161718192021function networkUp() { checkPrereqs ## generate artifacts if they don't exist if [ ! -d &quot;organizations/peerOrganizations&quot; ]; then createOrgs fi COMPOSE_FILES=&quot;-f compose/${COMPOSE_FILE_BASE} -f compose/${CONTAINER_CLI}/${CONTAINER_CLI}-${COMPOSE_FILE_BASE}&quot; #此处 if [ &quot;${DATABASE}&quot; == &quot;couchdb&quot; ]; then COMPOSE_FILES=&quot;${COMPOSE_FILES} -f compose/${COMPOSE_FILE_COUCH} -f compose/${CONTAINER_CLI}/${CONTAINER_CLI}-${COMPOSE_FILE_COUCH}&quot; fi DOCKER_SOCK=&quot;${DOCKER_SOCK}&quot; ${CONTAINER_CLI_COMPOSE} ${COMPOSE_FILES} up -d 2&gt;&amp;1 $CONTAINER_CLI ps -a if [ $? -ne 0 ]; then fatalln &quot;Unable to start network&quot; fi} 故找到相应文件，将其中的配置添加到节点中（这也就是之前peer节点创建后启动失败的原因） 123456789101112131415161718192021222324252627282930313233version: '3.7'services: peer0.org1.fedfab.com: container_name: peer0.org1.fedfab.com image: hyperledger/fabric-peer:latest labels: service: hyperledger-fabric environment: #Generic peer variables - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=fabric_test volumes: - ./docker/peercfg:/etc/hyperledger/peercfg - ${DOCKER_SOCK}:/host/var/run/docker.sock peer0.org2.fedfab.com: container_name: peer0.org2.fedfab.com image: hyperledger/fabric-peer:latest labels: service: hyperledger-fabric environment: #Generic peer variables - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=fabric_test volumes: - ./docker/peercfg:/etc/hyperledger/peercfg - ${DOCKER_SOCK}:/host/var/run/docker.sock cli: container_name: cli image: hyperledger/fabric-tools:latest volumes: - ./docker/peercfg:/etc/hyperledger/peercfg 使用docer-compose命令创建容器(添加DOCKER_SOCK)环境变量123SOCK=&quot;${DOCKER_HOST:-/var/run/docker.sock}&quot;export DOCKER_SOCK=&quot;${SOCK##unix://}&quot;docker-compose up -d docker容器建立了，但是docker-compose的配置文件中的很多细节并不清楚 修改host文件12345678sudo tee -a /etc/hosts &lt;&lt;-'EOF'127.0.0.1 orderer.fedfab.com127.0.0.1 peer0.org1.fedfab.com127.0.0.1 peer1.org1.fedfab.com127.0.0.1 peer2.org1.fedfab.com127.0.0.1 peer0.org2.fedfab.comEOFcat /etc/hosts 安装链码 参考 Housekeeping初始化mod，获取fabric模块 12go mod init github.com/hyperledger/fabric-samples/chaincode/mycontractgo get -u github.com/hyperledger/fabric-contract-api-go 编写链码，编译编写好chaincode.go，下载依赖包，编译 12go mod vendorgo build 配置通道 peer命令介绍 进入cli容器1234docker exec -it cli0 shdocker exec -it cli1 shdocker exec -it cli2 shdocker exec -it cli3 sh 安装通道1peer channel create -o orderer.fedfab.com:7050 -c channel2 -f ./channel-artifacts/channel2.tx --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem 12345678910111213142022-08-29 08:31:23.202 UTC 0001 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:31:23.211 UTC 0002 INFO [cli.common] readBlock -&gt; Expect block, but got status: &amp;{NOT_FOUND}2022-08-29 08:31:23.214 UTC 0003 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:31:23.415 UTC 0004 INFO [cli.common] readBlock -&gt; Expect block, but got status: &amp;{SERVICE_UNAVAILABLE}2022-08-29 08:31:23.417 UTC 0005 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:31:23.619 UTC 0006 INFO [cli.common] readBlock -&gt; Expect block, but got status: &amp;{SERVICE_UNAVAILABLE}2022-08-29 08:31:23.621 UTC 0007 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:31:23.822 UTC 0008 INFO [cli.common] readBlock -&gt; Expect block, but got status: &amp;{SERVICE_UNAVAILABLE}2022-08-29 08:31:23.824 UTC 0009 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:31:24.026 UTC 000a INFO [cli.common] readBlock -&gt; Expect block, but got status: &amp;{SERVICE_UNAVAILABLE}2022-08-29 08:31:24.028 UTC 000b INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:31:24.229 UTC 000c INFO [cli.common] readBlock -&gt; Expect block, but got status: &amp;{SERVICE_UNAVAILABLE}2022-08-29 08:31:24.231 UTC 000d INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:31:24.434 UTC 000e INFO [cli.common] readBlock -&gt; Received block: 0 将生成的channel2.block复制到其他cli中1234docker cp cli0:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel2.block ./docker cp ./channel2.block cli1:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel2.blockdocker cp ./channel2.block cli2:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel2.blockdocker cp ./channel2.block cli3:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel2.block 加入channel分别进入四个cli，执行以下命令 1peer channel join -b ./channel2.block 122022-08-29 08:55:24.659 UTC 0001 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:55:24.695 UTC 0002 INFO [channelCmd] executeJoin -&gt; Successfully submitted proposal to join channel 第一次执行时，cli0-cli2出现了connection refuse的情况，对docker compose文件进行修改，重新进行端口映射，则正常。这里出现这个问题的原因不详，容器内的端口号必须和外面匹配才行 编号 端口配置 orderer.fedfab.com 7050:7050, 7053:7053, 9443:9443 peer0.org1.fedfab.com 8051:8051, 9444:9444 peer1.org1.fedfab.com 8053:8053, 9445:9444 peer2.org1.fedfab.com 8055:8055, 9446:9444 peer0.org2.fedfab.com 9051:7051, 9447:9444 验证是否加入通道1peer channel getinfo -c channel2 122022-08-29 09:28:21.265 UTC 0001 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initializedBlockchain info: {&quot;height&quot;:1,&quot;currentBlockHash&quot;:&quot;xHaVldOzr0XQgw20tyMdri5No9dZuSQMez7jUOew/TU=&quot;} 配置锚节点 获取通道配置12peer channel fetch config channel-artifacts/config_block.pb -o orderer.fedfab.com:7050 -c channel2 --tls --cafile ${PWD}/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pemcd channel-artifacts pb文件转为json文件123configtxlator proto_decode --input config_block.pb --type common.Block --output config_block.jsonjq .data.data[0].payload.data.config config_block.json &gt; config.jsoncp config.json config_copy.json 使用jq工具将Org1的Peer锚节点添加到通道配置中 1jq '.channel_group.groups.Application.groups.Org2MSP.values += {&quot;AnchorPeers&quot;:{&quot;mod_policy&quot;: &quot;Admins&quot;,&quot;value&quot;:{&quot;anchor_peers&quot;: [{&quot;host&quot;: &quot;peer0.org2.fedfab.com&quot;,&quot;port&quot;: 9051}]},&quot;version&quot;: &quot;0&quot;}}' config_copy.json &gt; modified_config.json 完成此步骤后，我们在modified_config.json文件中以JSON格式获取了通道配置的更新版本。现在，我们可以将原始和修改的通道配置都转换回protobuf格式，并计算它们之间的差异。 123configtxlator proto_encode --input config.json --type common.Config --output config.pbconfigtxlator proto_encode --input modified_config.json --type common.Config --output modified_config.pbconfigtxlator compute_update --channel_id channel2 --original config.pb --updated modified_config.pb --output config_update.pb 名为channel_update.pb的新的protobuf包含我们需要应用于通道配置的Peer锚节点更新。我们可以将配置更新包装在交易Envelope中，以创建通道配置更新交易。 123configtxlator proto_decode --input config_update.pb --type common.ConfigUpdate --output config_update.jsonecho '{&quot;payload&quot;:{&quot;header&quot;:{&quot;channel_header&quot;:{&quot;channel_id&quot;:&quot;channel2&quot;, &quot;type&quot;:2}},&quot;data&quot;:{&quot;config_update&quot;:'$(cat config_update.json)'}}}' | jq . &gt; config_update_in_envelope.jsonconfigtxlator proto_encode --input config_update_in_envelope.json --type common.Envelope --output config_update_in_envelope.pb 我们可以通过向peer channel update命令提供新的通道配置来添加Peer锚节点。因为我们正在更新仅影响Org1的部分通道配置，所以其他通道成员不需要批准通道更新。 12cd ..peer channel update -f channel-artifacts/config_update_in_envelope.pb -c channel2 -o orderer.fedfab.com:7050 --tls --cafile ${PWD}/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem 122022-08-29 09:47:17.178 UTC 0001 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 09:47:17.185 UTC 0002 INFO [channelCmd] update -&gt; Successfully submitted channel update 进入org2的cli，执行上面的类似操作 验证已经更新 1peer channel getinfo -c channel2 1Blockchain info: {&quot;height&quot;:3,&quot;currentBlockHash&quot;:&quot;ScjYWX32DW8yvtDZ+DnLOljrFnHIjlCT2WbM2s19lF0=&quot;,&quot;previousBlockHash&quot;:&quot;hTNOb9vIRm2sm8XPgrEsz33w/Ivc28MINV4Kn6ICXyU=&quot;} 已经有三个块了","link":"/home/2022/10/22/fedfab/fabric/2.fabric%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9E%E8%B7%B5/"},{"title":"cha13.文件I&#x2F;O缓冲","text":"13.1使用shell内嵌的time命令，测算程序清单4-1(copy.c)在当前环境下的用时。a）使用不同的文件和缓冲区大小进行试验。编译应用程序时使用-DBUF_SIZE=nbytes选项可设置缓冲区大小。b) 对open()的系统调用加入O_SYNC标识，针对不同大小的缓冲区，速度存在多大差异?c) 在一系列文件系统（比如，ext3、XFS、Btrfs和 JFS）中执行这些计时测试。结果相似吗?当缓冲区大小从小变大时，用时趋势相同吗? 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdarg.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#ifndef BUF_SIZE#define BUF_SIZE 1024#endif#define ERR(code, format, ...) do { \\ if(!(code)) { \\ fprintf(stderr, (char*)format, ##__VA_ARGS__); \\ exit(code); \\ } \\} while(0)int main(int argc, char *argv[]) { char buf[BUF_SIZE]; ssize_t readsize = 0; int openflag = O_RDONLY;#ifdef SYNC openflag |= O_SYNC;#endif int inputfd = open(argv[1], openflag); ERR(inputfd != -1, &quot;fail to open %s, err:%s\\n&quot;, argv[1], strerror(errno)); int outputfd = open(argv[2], O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH); ERR(outputfd != -1, &quot;fail to open %s, err:%s\\n&quot;, argv[2], strerror(errno)); while((readsize = read(inputfd, buf, BUF_SIZE)) &gt; 0) { ERR(write(outputfd, buf, readsize) == readsize, &quot;could not write whole buffer, err:%s\\n&quot;, strerror(errno)); } ERR(readsize != -1, &quot;read fail, err:%s&quot;, strerror(errno)); ERR(close(inputfd) != -1, &quot;fail to close input, err:%s\\n&quot;, strerror(errno)); ERR(close(outputfd) != -1, &quot;fail to close output, err:%s\\n&quot;, strerror(errno)); return 0;} 测试时间1234567891011121314151617BUFSIZE=1cat /dev/null &gt; log13.1.logfor i in `seq 15`; do echo round $i, BUFSIZE=$BUFSIZE &gt;&gt; log13.1.log gcc practice13_1.c -DBUF_SIZE=$BUFSIZE -o practice13_1 /usr/bin/time -f &quot;real = %e\\nuser = %U\\nsystem = %S&quot; -o log13.1.log -a ./practice13_1 big big.copy BUFSIZE=`expr $BUFSIZE \\* 2`doneBUFSIZE=1cat /dev/null &gt; log13.1_sync.logfor i in `seq 15`; do echo round $i, BUFSIZE=$BUFSIZE &gt;&gt; log13.1_sync.log gcc practice13_1.c -DBUF_SIZE=$BUFSIZE -DSYNC -o practice13_1 /usr/bin/time -f &quot;real = %e\\nuser = %U\\nsystem = %S&quot; -o log13.1_sync.log -a ./practice13_1 big big.copy BUFSIZE=`expr $BUFSIZE \\* 2`done 生成md1234567891011121314151617181920file=$1tee awk_script.awk 2&gt;&amp;1 &gt; /dev/null &lt;&lt;-'EOF'{ print &quot;|round|bufsize|real|user|system|&quot;; print &quot;|-|-|-|-|-|&quot;;len=split($0, a, &quot;\\n&quot;)-1; for(i = 0; i &lt; len/4; i++) { split(a[i*4+1], line1, &quot;,&quot;); split(line1[1], line11, &quot; &quot;); round=line11[2];split(line1[2], line12, &quot;=&quot;); bufsize=line12[2]; printf(&quot;|%s|%s|&quot;, round, bufsize); for(j = 2; j &lt;= 4; j++) { split(a[i*4+j], linej, &quot; &quot;); printf(&quot;%s|&quot;, linej[3]); } printf(&quot;\\n&quot;); }}EOFcat $file | awk -v RS='EOF' -f awk_script.awk 测试结果 测试于ext4，搭建其他文件系统太耗时了，就不弄了 没有O_SYNC round bufsize real user system 1 1 322.64 86.14 236.38 2 2 160.22 43.23 116.92 3 4 80.88 21.85 58.97 4 8 40.21 10.77 29.41 5 16 19.97 5.23 14.73 6 32 10.13 2.72 7.37 7 64 5.06 1.42 3.63 8 128 2.52 0.57 1.94 9 256 1.27 0.26 1.00 10 512 0.71 0.14 0.56 11 1024 0.37 0.11 0.26 12 2048 0.21 0.03 0.17 13 4096 0.14 0.03 0.10 14 8192 0.10 0.02 0.07 15 16384 0.10 0.00 0.09 有O_SYNC round bufsize real user system 1 1 370.43 99.46 270.89 2 2 202.32 53.13 149.09 3 4 95.62 25.74 69.80 4 8 49.08 12.88 36.17 5 16 23.94 6.48 17.45 6 32 11.96 3.65 8.31 7 64 6.05 1.55 4.49 8 128 3.26 0.82 2.43 9 256 1.61 0.38 1.22 10 512 0.78 0.23 0.55 11 1024 0.45 0.06 0.39 12 2048 0.31 0.08 0.16 13 4096 0.24 0.04 0.14 14 8192 0.19 0.00 0.12 15 16384 0.19 0.02 0.12 13.2懒得搞 13.3如下语句的执行效果是什么? 12fflush(fp);fsync(fileno(fp)); 先将文件指针fp的stdio库的缓存调用write系统调用，再获取fd的文件描述符，将该文件描述符的系统IO缓冲区的数据以及文件元数据强制写入存储设备 13.4试解释取决于将标准输出重定向到终端还是磁盘文件,为什么如下代码的输出结果不同。 12printf(&quot;If I had more time,\\n&quot;);write(STDOUT_FILENO, &quot;I would have written you a shorter letter.\\n&quot;,43); 代码1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;int main() { printf(&quot;If I had more time,\\n&quot;); write(STDOUT_FILENO, &quot;I would have written you a shorter letter.\\n&quot;,43); FILE* file = freopen(&quot;tmp13.4&quot;, &quot;w&quot;, stdout); if(file == NULL) { return 1; } printf(&quot;If I had more time,\\n&quot;); write(STDOUT_FILENO, &quot;I would have written you a shorter letter.\\n&quot;,43); fclose(file); return 0;} 结果 终端 由于终端的缓存mod默认为_IOLBUF，行缓冲io，也就是当遇到一行结束或缓存满时，就写入终端，所以会按照代码的顺序输出 文件 普通磁盘文件的缓存mod为_IOFBUF，全缓冲io，printf会先写入stdio库的缓冲区，write直接写入系统IO缓冲区，一般情况下，write会先于stdio进入系统缓冲区，导致最终写入文件的顺序与代码中的顺序相反 13.5实现tail 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216#define _XOPEN_SOURCE 600#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdarg.h&gt;#define INFO(msg, ...) fprintf(stderr, &quot;INFO: &quot;);\\ fprintf(stderr, msg, ##__VA_ARGS__)#define CHECK(flag, msg, ...) do { \\ if(!(flag)) {\\ fprintf(stderr, &quot;FATAL: &quot;); \\ fprintf(stderr, msg, ##__VA_ARGS__); \\ fprintf(stderr, &quot; ERROR: %s\\n&quot;, strerror(errno)); \\ exit(2); \\ } \\ } while(0)#define streq(str1, str2) (strcmp(str1, str2)==0)#ifndef BUFSIZE//#define BUFSIZE 0x1000//#define BUFSIZE 2#define BUFSIZE 1#endifbool str2int(const char *num, int *ret) { errno = 0; char *end; *ret = strtol(num, &amp;end, 10); CHECK(!(end == num || *end != '\\0' || errno != 0), &quot;%s is not a integer!\\n&quot;, num); return true;}void print(const char *str, ...) { va_list list; va_start(list, str); for(const char *s = str; s != NULL; (s = va_arg(list, const char *))) { size_t slen = va_arg(list, size_t); ssize_t wsize = write(STDOUT_FILENO, s, slen); CHECK(wsize == slen, &quot;fail to print %s\\n&quot;, s); } va_end(list);}char *str_alloc_reverse_cat(char * str1, const char *str2, int *len1, int len2) { char *str = realloc(strdup(str2), (*len1+len2+1) * sizeof(char)); str[len2] = 0; strncat(str, str1, *len1); *len1 += len2; return str;}void tail(int fd, const int line, off_t end) { int num = line; char *buf = (char*)malloc((BUFSIZE+1)*sizeof(char)); char **output = (char **)malloc(num *sizeof(char *)); int *output_len = (int *) malloc(num * sizeof(int)); memset(output, 0, num *sizeof(char *)); memset(output_len, 0, num *sizeof(int)); while(end &gt; 0 &amp;&amp; num) { size_t bufsize = BUFSIZE &gt; end ? end : BUFSIZE; posix_fadvise(fd, end-bufsize, bufsize, POSIX_FADV_WILLNEED); CHECK(end != -1, &quot;end = %ld, fail to lseek fd%d&quot;, end, fd); ssize_t readsize = pread(fd, buf, bufsize, end-bufsize); CHECK(readsize &gt;= 0, &quot;readsize = %ld, fail to read fd%d&quot;, readsize, fd); buf[readsize] = 0; end -= bufsize; CHECK(end != -1, &quot;end = %ld, fail to lseek fd%d&quot;, end, fd); while(readsize &gt;= 0 &amp;&amp; num) { ssize_t move = readsize-1; while(move &gt;=0 &amp;&amp; buf[move] != '\\n') move--; size_t size = readsize - move - 1; if(move &gt;= 0 || end == 0) { num--; output[num] = str_alloc_reverse_cat(output[num], buf+move+1, &amp;output_len[num], size); } else { output[num-1] = str_alloc_reverse_cat(output[num-1], buf+move+1, &amp;output_len[num-1], size); } readsize = move; } } size_t outbufsize = 1; for(int i = num; i &lt; line; i++) { outbufsize += output_len[i]+1; } char *outbuf = (char *) malloc(outbufsize*sizeof(char)); outbuf[0] = 0; for(int i = num; i &lt; line; i++) { strcat(outbuf, output[i]); strcat(outbuf, &quot;\\n&quot;); free(output[i]); } print(outbuf, outbufsize - 1, NULL); free(outbuf); free(buf); free(output);}char *str_alloc_cat(char * str1, const char *str2, int *len1, int len2) { char *str = NULL; if(str1 == NULL) { str = malloc((*len1+len2+1) * sizeof(char)); *len1 = 0; } else { str = realloc(str1, (*len1 + len2 + 1) * sizeof(char)); } str[*len1] = 0; strncat(str + *len1, str2, len2); *len1 += len2; return str;}void tailsafe(int fd, const int num) { // for file that do not support SEEK_END int line = 0; char *buf = (char*)malloc((BUFSIZE+1)*sizeof(char)); char **output = (char **)malloc(num *sizeof(char *)); int *output_len = (int *) malloc(num * sizeof(int)); memset(output, 0, num *sizeof(char *)); memset(output_len, 0, num *sizeof(int)); size_t readsize = 0, prev_readsize = 0; int i,j; while((readsize = read(fd, buf, BUFSIZE)) != 0) { prev_readsize = readsize; CHECK(readsize &gt;= 0, &quot;readsize = %ld, fail to read fd%d&quot;, readsize, fd); buf[readsize] = 0; for(i = 0; i &lt; readsize; i=j+1) { j = i; while(j &lt; readsize &amp;&amp; buf[j] != '\\n')j++; if(output[line] != NULL &amp;&amp; output[line][output_len[line]] == '\\n') { free(output[line]); output[line]= NULL; } if(j &lt; readsize) { output[line] = str_alloc_cat(output[line], buf+i, &amp;output_len[line], j - i); output[line][output_len[line]] = '\\n'; line = (line+1)%num; } else {// size_t end = lseek(fd, i - j, SEEK_CUR); output[line] = str_alloc_cat(output[line], buf+i, &amp;output_len[line], j - i); break; } } } if(i &lt; prev_readsize) { output[line][output_len[line]] = 0; line = (line+1)%num; } if(output[line] == NULL) { line = 0; } size_t outbufsize = 1; for(int i = 0; i &lt; num; i++) { outbufsize += output_len[i]+1; if(output[i] != NULL) output[i][output_len[i]] = 0; } char *outbuf = (char *) malloc(outbufsize*sizeof(char)); outbuf[0] = 0; for(int i = 0; i &lt; num &amp;&amp; output[(i+line)%num] != NULL; i++) { strcat(outbuf, output[(i+line)%num]); strcat(outbuf, &quot;\\n&quot;); free(output[(i+line)%num]); } print(outbuf, outbufsize - 1, NULL); free(outbuf); free(output_len); free(output); free(buf);}int main(int argc, char ** argv) { char **filename = (char **)malloc(argc * sizeof(char *)); int filecount = 0; int num = 10; bool safe = false; for(int i = 1; i &lt; argc; i++) { if(argv[i][0] == '-') { if(streq(argv[i], &quot;--help&quot;) || streq(argv[i], &quot;-h&quot;)) { INFO(&quot;Usage: %s [-h|--help] [-n num] filename&quot;, argv[0]); } else if(streq(argv[i], &quot;-n&quot;)) { str2int(argv[++i], &amp;num); } else if(streq(argv[i], &quot;--safe&quot;)) { safe = true; } } else { filename[filecount++] = strdup(argv[i]); } } CHECK(num &gt;= 0, &quot;num should be non-negative, num = %d\\n&quot;, num); if(filecount == 0) { INFO(&quot;Usage: %s [-h|--help] [-n num] filename&quot;, argv[0]); } for(int i = 0; i &lt; filecount; i++) { int fd = open(filename[i], O_RDONLY); CHECK(fd != -1, &quot;fail to open %s, fd = %d&quot;, filename[i], fd); if (filecount &gt; 1) print(&quot;==&gt; &quot;, 4, filename[i], strlen(filename[i]), &quot; &lt;==&quot;, 4, &quot;\\n&quot;, 1, NULL); if(!safe) { off_t pos = lseek(fd, 0, SEEK_END); CHECK(pos != -1, &quot;fail to lseek %s, pos = %ld&quot;, filename[i], pos); tail(fd, num, pos); } else { tailsafe(fd, num); } close(fd); free(filename[i]); } free(filename); return 0;} 两种方式，正着读和倒着读有些文件不支持SEEK_END，用--safe选项正着读","link":"/home/2023/04/26/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha13/"},{"title":"fedml-4.与fabric通信","text":"直接采用“偷梁换柱”的模式,把修改后的代码复制到pip安装的位置 pip install的位置通过python -m site命令查找包的安装路径 123456789101112sys.path = [ '/usr/share/python3', '/usr/lib/python310.zip', '/usr/lib/python3.10', '/usr/lib/python3.10/lib-dynload', '/home/tt/.local/lib/python3.10/site-packages', '/usr/local/lib/python3.10/dist-packages', '/usr/lib/python3/dist-packages',]USER_BASE: '/home/tt/.local' (exists)USER_SITE: '/home/tt/.local/lib/python3.10/site-packages' (exists)ENABLE_USER_SITE: True 思考：需要修改哪些代码？ 修改Aggregator。Aggregator的作用是（1）保存各个节点上传的本地模型；（2）对本地模型进行aggregate操作。 分离aggregator的功能,分为本地Aggregator和链上Aggregator,本地Aggregator不保存模型,将收到的模型转发给区块链,聚集操作时先向区块链取模型,再进行聚集操作 修改FedMLServerManager 在适当位置调用http接口,适当根据逻辑需要修改其它代码 修改ClientMasterManager 在适当位置调用http接口,适当根据逻辑需要修改其它代码 修改message_define,文件中定义了C/S之间相互通信的名称,参数名称 对其适当增删,达到C/S间协同的目的 修改FedMLAggregator model_dict: 用于保存收到的本地模型,与他相关的sample_num_dict,保存收到的本地模型的样本个数,flag_client_model_uploaded_dict用于保存是否收到模型。区块链端的Aggregator需要维护这三个数组 add_local_trained_result,这个函数通过ml_engine_adapter.model_params_to_device获得本地模型,将这个函数注释掉 check_whether_all_receive,这个函数通过检查flag_client_model_uploaded_dict是否全是true来判断是否全部收到。这里改成从区块链获取 aggregate,这个函数使用了sample_num_dict和model_dict,也全都改成从区块链获取 其他函数未涉及这三个dict,暂不做修改。 修改FedMLServerManager handle_message_receive_model_from_client,这个函数处理节点发送来的模型,从消息中读取模型参数和样本个数。不从消息中获取这两个参数（后续修改Client,也不发送这两个参数）,但是仍然向Server发送这个消息。收到消息后延迟一定时间向区块链查询是否全部收到（调用本地aggregator的check_whether_all_receive） 当查询到全部都收到后,会进行聚集操作,聚集操作后产生更新后的模型,这个模型会发送给client,在发送给client的同时发送一份给区块链存储 修改ClientMasterManager send_model_to_server,对应Server的handle_message_receive_model_from_client。不发送模型和样本数给server,而是发送给区块链 统一发送模型的格式 ml_engine_adapter中的函数model_params_to_device用于处理收到的模型,根据ml_engine的类型对模型进行处理,希望在发送之前在Client端就进行处理 通过测试,输出type(ml_engine_adapter.model_params_to_device(self.args, weights, self.trainer_dist_adapter.device)),得到其类型是collections.OrderedDict它也是一种dict, 存储的是model_params(string) to Tensor对他进行处理,变成python原生的dict,对Tensor处理,变成python原生的list,目的是使其可以变成json串server收到后,对其dumps, 再将list转换成Tensor 1234567from ...ml.engine import ml_engine_adaptermodel_params = ml_engine_adapter.model_params_to_device(self.args, weights, self.trainer_dist_adapter.device)model_params = {k:v.tolist() for k,v in model_params.items()}logging.info(&quot;Jingtian: type of model_params: %s&quot; % type(model_params))import jsonmodel_params_json = json.dumps(model_params)logging.info(&quot;Jingtian: model_params: &quot; + (model_params_json)) 编写ChainCode链上Aggregator实现思路ChainCode要实现存储模型,并检测每轮模型是否上传完毕,参考fabcar示例中队Car的定义以及对Car的增改查的代码,设计Round结构 12345type Round struct { Models map[string]string // ClientID to Model RoundID string ClientNum int64} 只需要检查Round中len(Model)与ClientNum是否相等即可 ChainCode合约定义根据上面的分析,需要一下几个函数 AddModel 接受并存储本地模型 保存： model-key model-weight model-sample-num params: RoundID string ClientID string model string(原始json串) QueryWetherAllReceived 检查是否全部收到,检查是否全部收到,返回True or False params: RoundID string QueryAllReceived 若全部收到,返回模型,模型权重和模型样本数目,否则返回空 params: RoundID string UpdateGlobal 接受Server聚集后的,更新后的模型,对区块链内的内容进行更新 params: ServerID string model-weight string NewRound 新增一个Round,每轮开始时创建 params: RoundID string ClientNum int64 根据以上分析,需要在fedml节点运行时生成一个id,server的id自然成为server-id,client的id自然成为ClientID。在每轮训练开始前,需要生成RoundID,并且调用NewRound通知区块链。RoundID的前n为与ServerID相同,再拼接随机生成的后n位。 通过以下命令进行对ChainCode的测试与Debug123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960## RoundID = &quot;ri&quot;## ServerID = &quot;si&quot;## ClientID = &quot;ci&quot;peer chaincode invoke -o orderer.fedfab.com:7050 --isInit --ordererTLSHostnameOverride orderer.fedfab.com --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;initialize&quot;, &quot;Initializing chaincode&quot;]}'## chaincode 初始化peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;NewRound&quot;, &quot;r1&quot;, &quot;2&quot;]}'peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;AddModel&quot;, &quot;r1&quot;, &quot;c1&quot;, &quot;{\\&quot;a\\&quot;:[1,2,3], \\&quot;b\\&quot;:[2,3,4], \\&quot;c\\&quot;:[3,4,5]}&quot;]}'peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;QueryWetherAllReceived&quot;, &quot;r1&quot;]}'peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;AddModel&quot;, &quot;r1&quot;, &quot;c2&quot;, &quot;{\\&quot;a\\&quot;:[1,2,3], \\&quot;b\\&quot;:[2,3,4], \\&quot;c\\&quot;:[3,4,5]}&quot;]}'peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;QueryWetherAllReceived&quot;, &quot;r1&quot;]}'peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;QueryAllReceived&quot;, &quot;r1&quot;]}'peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;UpdateGlobal&quot;, &quot;s1&quot;, &quot;{\\&quot;a\\&quot;:[1,2,3], \\&quot;b\\&quot;:[2,3,4], \\&quot;c\\&quot;:[3,4,5]}&quot;]}' fedml拿到返回值后可能要进行两次json解析把模型变成json后,当作普通字符串作为请求发送,发送请求时有进行了依次json编码增加了json的转义字符,增加了冗余字符减少了ChainCode编写的复杂度 Server需要知道Client的id？ –不需要,QueryAll后对每个模型求平均就好,不需要发送给Client 更新同名的ChainCode时,label要有变化,命令中的sequence参数要比上一次递增。 编写ts API与HTTP Server 根据上周的ttsacc的api和Http Server,相同的方法实现上面5个功能对应的api和接口 使用postMan进行测试 newRound调用时,client_num使用string 编写并测试Yaml-Requests的yaml配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263url: '10.128.196.184'port: '3000'methods: AddModel: type: 'post' async: false res-type: 'json' path: '/invokeChainCode/AddModel' params: peer: 0 org: 2 body: content-type: 'json' content: cid: 'c1' QueryWetherAllReceived: type: 'post' async: false res-type: 'json' path: '/invokeChainCode/QueryWetherAllReceived' params: peer: 0 org: 2 body: content-type: 'json' QueryAllReceived: type: 'post' async: false res-type: 'json' path: '/invokeChainCode/QueryAllReceived' params: peer: 0 org: 2 body: content-type: 'json' UpdateGlobal: type: 'post' async: false res-type: 'json' path: '/invokeChainCode/UpdateGlobal' params: peer: 0 org: 2 body: content-type: 'json' content: sid: 's1' NewRound: type: 'post' async: false res-type: 'json' path: '/invokeChainCode/NewRound' params: peer: 0 org: 2 body: content-type: 'json' content: client_num: '3' fedml中调用api 根据之前的分析，在对应位置进行调用，并处理返回值 编写dockerfile 创建自定义镜像,修改镜像中的fedml代码 使用镜像创建container,在container中运行修改后的代码进行测试修改过的文件有：123456/home/tt/.local/lib/python3.10/site-packages/fedml/cross_silo/client/fedml_client_master_manager.py/home/tt/.local/lib/python3.10/site-packages/fedml/cross_silo/server/fedml_aggregator.py/home/tt/.local/lib/python3.10/site-packages/fedml/cross_silo/server/fedml_server_manager.py/home/tt/.local/lib/python3.10/site-packages/fedml/cross_silo/server/fedml_server_manager.py/home/tt/.local/lib/python3.10/site-packages/fedml/cross_silo/client/message_define.py/home/tt/.local/lib/python3.10/site-packages/fedml/cross_silo/server/message_define.py docker COPYCOPY 遵循的规则 src路径必须在构建的上下文中 src是目录 则复制目录的全部内容,包括文件系统元数据 不会复制目录本身,只会复制其内容 src是任何其他类型的文件 则将其与其元数据一起单独复制 dest 以斜杠 / 结尾,它将被视为一个目录,并且 src 的内容将写入 dest/base(src) 指定了多个 src 资源,或者由于使用了通配符 则 dest 必须是一个目录,并且必须以斜杠 / 结尾 dest 不以斜杠结尾 它将被视为常规文件,并且 src 的内容将写入 dest dest 不存在 路径中所有缺失的目录都会自动创建 docker 错误记录1Error response from daemon: could not select device driver &quot;&quot; with capabilities: [[gpu]] 解决方法 12345678curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | \\ sudo apt-key add -distribution=$(. /etc/os-release;echo $ID$VERSION_ID)curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | \\ sudo tee /etc/apt/sources.list.d/nvidia-docker.listsudo apt-get updatesudo apt-get install -y nvidia-container-toolkitsudo systemctl restart docker 如果上面出错了,先使用下面的命令 1sudo rm -f $(grep -l &quot;nvidia.github.io&quot; /etc/apt/sources.list.d/* | grep -vE &quot;/nvidia-container-toolkit.list\\$&quot;) dockerfile 文件1234567891011FROM fedml/fedml:cuda-11.4.0-devel-ubuntu20.04## RUN sudo apt upgrade python3RUN python -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade pipRUN pip3 config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simpleRUN pip3 install updateRUN pip3 install --upgrade fedmlCOPY ./fedml_files/fedml_client_master_manager.py /usr/local/lib/python3.8/dist-packages/fedml/cross_silo/client/COPY ./fedml_files/fedml_aggregator.py /usr/local/lib/python3.8/dist-packages/fedml/cross_silo/server/COPY ./fedml_files/fedml_server_manager.py /usr/local/lib/python3.8/dist-packages/fedml/cross_silo/server/COPY ./fedml_files/message_define.py /usr/local/lib/python3.8/dist-packages/fedml/cross_silo/server/COPY ./fedml_files/message_define.py /usr/local/lib/python3.8/dist-packages/fedml/cross_silo/client/ 编译dockerfile的脚本 123456## docker image rm fedml:ttcp ~/.local/lib/python3.10/site-packages/fedml/cross_silo/client/fedml_client_master_manager.py ../fedml_dockerfile_context/fedml_files/cp ~/.local/lib/python3.10/site-packages/fedml/cross_silo/server/fedml_aggregator.py ../fedml_dockerfile_context/fedml_files/cp ~/.local/lib/python3.10/site-packages/fedml/cross_silo/server/fedml_server_manager.py ../fedml_dockerfile_context/fedml_files/cp ~/.local/lib/python3.10/site-packages/fedml/cross_silo/server/message_define.py ../fedml_dockerfile_context/fedml_files/docker build -t fedml:tt ../fedml_dockerfile_context 运行测试问题： 会随机有几个请求被拒绝连接 减少出块时间到50ms 依然没有解决修改configtx.yaml中的一个参数 1BatchTimeout: 50ms 给invoke函数加Mutex互斥锁,让其只能按顺序执行,锁解除后在sleep 65ms 依然没有解决 观察到观察到MVCC_READ_CONFLICT总是在AddModel总是在AddModel, 时出现 在Client发送Model前,sleep(1*client_real_id),排队依次上传,给区块链反应的时间（假设模型训练时间都差不多） 还是没有解决 总结 经过多天的debug与调试,最终基本可以正常训练,存储到区块链上,但是最多只训练了44轮,还是在AddModel环节出现了MVCC_READ_CONFLICT。 很多地方要增加sleep操作,增加了运行时间 需要一个协调方式,避免同时AddModel造成BlockChain崩溃。 可以尝试用Server调用AddModel,Client的本地Model还是通过MQTT协议传送给Server,由Server统一上链 或者可以捕获异常,保证server持续运行,Client发现Add失败则重新Add 寻找方法将请求串行化 最新进展 解决了MVCC_READ_CONFLICT,fedml和fabric可以相互配合完成整个训练过程,并且不发生MVCC_READ_CONFLICT等问题 新定义三个mqtt消息1234## tt defineMSG_TYPE_C2S_ADD_MODEL_READY = 8MSG_TYPE_C2S_ADD_MODEL_SEND = 9MSG_TYPE_S2C_START_ADD_MODEL = 10 解释： MSG_TYPE_C2S_ADD_MODEL_READY, Client to Server,训练完毕,可以向区块链发送AddModel。知会Server,server的Aggregator收集这个信息 MSG_TYPE_S2C_START_ADD_MODEL, Server to Client, 当全部ready时,会向Client开始依次发送这个消息。 MSG_TYPE_C2S_ADD_MODEL_SEND, Client to Server,当一个Client将Model发送到Chain后,发送这个消息到Server,Server收到后向下一个Client发送MSG_TYPE_S2C_START_ADD_MODEL消息,让下一个Client开始上传模型 方法带来的问题与思考： 由于invoke函数的mutex锁和刻意的延迟,以及上面通过三个信号实现的排队向ChainCode发送模型,导致整个系统运行的速度非常慢 有些节点算力强,训练快,有些算力低训练慢。 只有训练速度相似的节点会竞争AddModel的权利,而现在要让所有的Client都训练完成后才开始上传区块链,这样一定程度上降低了系统的效率 解决方法（设想）： 维护一个队列ready,一个变量sending,一个字典send ready表示目前收到ready的Client sending表示当前正在发送但没收到send消息的Client dict中存储ClientID to Bool,表示ClientID是否已经发送,即是否为send状态,将字典初始化全为False 收到Ci的ready消息后 若sending为None,则让Ci开始发送模型,将sending设为Ci 若sending不为None,加入ready队列 收到Ci的send消息后,将sending设为None,send[Ci]变成True,检测send字典是否全为True 若全为True,进行下一轮 若不全为True 若ready队列不为空,则从队列中取出下一个Client Cj让其发送模型,sending设为Cj 若ready队列为空,则继续等待ready消息","link":"/home/2022/10/22/fedfab/fedml/4.%E4%B8%8Efabric%E9%80%9A%E4%BF%A1/"},{"title":"cha14.系统编程概念","text":"14.1编写一程序，试对在单目录下创建和删除大量1字节文件所需的时间进行度量。该程序应以xNNNNNN命名格式来创建文件，其中 NNNNNN为随机的6位数字。文件的创建顺序与生成文件名相同，为随机方式，删除文件则按数字升序操作（删除与创建的顺序不同)。文件的数量(FN)和文件所在目录应由命令行指定。针对不同的NF值（比如，在1000和20000之间取值）和不同的文件系统（比如 ext2、ext3和 XFS)来测量时间。随着NF的递增,每个文件系统下耗时的变化模式如何?不同文件系统之间，情况又是如何呢?如果按数字升序来创建文件（x000001、x000001、x0000002等)，然后以相同顺序加以删除，结果会改变吗?如果会，原因何在?此外，上述结果会随文件系统类型的不同而改变吗? c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include &lt;stdio.h&gt;#include &lt;limits.h&gt;#include &lt;string.h&gt;#include &lt;stdbool.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/times.h&gt;#include &lt;sys/time.h&gt;#define CHECK(flag, msg, ...) do { \\ if(!(flag)) {\\ fprintf(stderr, &quot;FATAL: &quot;); \\ fprintf(stderr, msg, ##__VA_ARGS__); \\ fprintf(stderr, &quot; ERROR: %s\\n&quot;, strerror(errno)); \\ exit(2); \\ } \\ } while(0)bool str2int(const char *num, int *ret) { errno = 0; char *end; *ret = strtol(num, &amp;end, 10); return !(end == num || *end != '\\0' || errno != 0);}int *seqArr(int len) { int *nums = malloc(len * sizeof(int)); for(int i = 0; i &lt; len; i++) { nums[i] = i; } return nums;}int* randArr(int len) { int *visited = malloc(len * sizeof(int)); int *nums = malloc(len * sizeof(int)); memset(visited, 0, len * sizeof(int)); for(int i = 0; i &lt; len; i++) { int uniq; while(visited[(uniq = rand() % len)]); visited[uniq] = 1; nums[i] = uniq; } free(visited); return nums;}char *path = NULL;void creatFiles(int *arr, int fn) { char *filename = (char *) malloc((9 + strlen(path))*sizeof(char)); for(int i = 0; i &lt; fn; i++) { sprintf(filename, &quot;%s/x%06d&quot;, path, arr[i]); int fd = open(filename, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH); CHECK(fd != -1, &quot;fail to open file %s, fd = %d&quot;, filename, fd); CHECK(write(fd, &quot; &quot;, 1) == 1, &quot;fail to write&quot;);// fsync(fd); // Synchronized I/O file integrity completion，能否保证文件创建？ close(fd); } free(filename);}struct RmFilesArgs { int *arr; int fn;};void rmFiles(void *args) { int *arr = ((struct RmFilesArgs*)args)-&gt;arr; int fn = ((struct RmFilesArgs*)args)-&gt;fn; char filename[8] = {0}; for(int i = 0; i &lt; fn; i++) { sprintf(filename, &quot;x%06d&quot;, arr[i]); unlink(filename); }}long clockTic = 0;// clock_t long int// time_t long int#define FIX_MINUS(x, max) ((x) &lt; 0 ? ((x)) : (x))void timeIt(void (*test)(void *args), void *args, double *system, double *user, double *process, double *real) { clock_t processStart, processEnd; struct timeval realStart, realEnd; struct tms start, end; CHECK((processStart = clock()) != (clock_t)-1, &quot;fail to get clock, ERROR: %s&quot;, strerror(errno)); CHECK(gettimeofday(&amp;realStart, NULL) != -1, &quot;fail to get timeofday, ERROR: %s&quot;, strerror(errno)); CHECK(times(&amp;start) != (clock_t)-1, &quot;fail to get times, ERROR: %s&quot;, strerror(errno)); test(args); CHECK(times(&amp;end) != (clock_t)-1, &quot;fail to get times, ERROR: %s&quot;, strerror(errno)); CHECK(gettimeofday(&amp;realEnd, NULL) != -1, &quot;fail to get timeofday, ERROR: %s&quot;, strerror(errno)); CHECK((processEnd = clock()) != (clock_t)-1, &quot;fail to get clock, ERROR: %s&quot;, strerror(errno)); *process = (double)(FIX_MINUS((processEnd - processStart), LONG_MAX)) / CLOCKS_PER_SEC; *real = (double)(FIX_MINUS((realEnd.tv_usec - realStart.tv_usec), LONG_MAX)) / 1000; *user = (double)(FIX_MINUS((end.tms_utime - start.tms_utime), LONG_MAX)) / clockTic; *system = (double)(FIX_MINUS((end.tms_stime - start.tms_stime), LONG_MAX)) / clockTic;#ifdef DEBUG char *format = &quot;system = %lfs, user = %lfs, process = %lfs, real = %lfms\\n&quot;; printf(format, *system, *user, *process, *real);#endif}int NOP(const char * command) { return 0;}int main(int argc, char **argv) { srand(time(NULL)); int fn = 0; char *format = &quot;system = %.4lfms, user = %.4lfms, process = %.4lfms, real = %.4lfms\\n&quot;; int (*bash)(const char *) = system;#ifndef COMMAND bash = NOP;#endif double system, user, process, real; for(int i = 1; i &lt; argc; i++) { if(strcmp(argv[i], &quot;-fn&quot;) == 0) { CHECK(i + 1 &lt; argc, &quot;no enough args\\n&quot;); const char *num = argv[++i]; CHECK(str2int(num, &amp;fn), &quot;%s is not a integer!\\n&quot;, num); } else if(strcmp(argv[i], &quot;-path&quot;) == 0) { CHECK(i + 1 &lt; argc, &quot;no enough args\\n&quot;); path = argv[++i]; } } clockTic = sysconf(_SC_CLK_TCK); CHECK(clockTic != -1, &quot;fail to get sysconf: _SC_CLK_TCK, ERROR:%s&quot;, strerror(errno)); int *randIntArr = randArr(fn); int *seqIntArr = seqArr(fn); creatFiles(randIntArr, fn);bash(&quot;ls -lh&quot;); timeIt(rmFiles, &amp;(struct RmFilesArgs){ .arr=seqIntArr, .fn=fn }, &amp;system, &amp;user, &amp;process, &amp;real);bash(&quot;ls -lh&quot;); printf(format, system * 1000, user * 1000, process * 1000, real); creatFiles(seqIntArr, fn);bash(&quot;ls -lh&quot;); timeIt(rmFiles, &amp;(struct RmFilesArgs){ .arr=seqIntArr, .fn=fn }, &amp;system, &amp;user, &amp;process, &amp;real);bash(&quot;ls -lh&quot;); printf(format, system * 1000, user * 1000, process * 1000, real); free(seqIntArr); free(randIntArr); return 0;} 没有刻意复杂化，被测函数执行相同的函数保证测试的相对准确性 结果1234gcc -O3 practice14.1.c -o practice14.1 ./practice14.1 -fn 1000 -path .system = 20.0000ms, user = 0.0000ms, process = 18.7450ms, real = 18.7320mssystem = 20.0000ms, user = 0.0000ms, process = 37.0100ms, real = 38.6430ms O3优化掉CHECK多余的while(0)循环，计时更精确大部分时候第二次大于第一次reeal偶尔为负数，很奇怪 解释磁盘分区的结构为：引导块 超级块 i节点表 数据块 假设i节点表使用数组管理，删除文件时需要删除i-node。如果按照与创建顺序相同的顺序删除文件，那么数组在这个过程中需要移动 $ \\sum_{i=0}^{n-1}i $ 次。 如果随机删除，则移动次数一定小于$ \\sum_{i=0}^{n-1}i $ 次。","link":"/home/2023/04/28/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha14/"},{"title":"cha19.监控文件事件","text":"19.1监控某个目录及其所有子目录的，创建，删除改名 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222//// Created by root on 5/22/23.//#define _XOPEN_SOURCE 600#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;limits.h&gt;#include &lt;sys/inotify.h&gt;#include &lt;stddef.h&gt;#include &lt;sys/stat.h&gt;#include &lt;ftw.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;alloca.h&gt;#include &lt;stdbool.h&gt;// 对root及其子目录下所有文件的创建、删除改名操作监控，并支持监控新建的子目录struct listNode { int wd; char *name; struct listNode *next;} *head;int len() { int l = 0; struct listNode *next = head-&gt;next; while (next) { l++; next = next-&gt;next; } return l;}struct listNode *newListNode(int wd, const char *name, struct listNode *next) { struct listNode *node = malloc(sizeof(struct listNode)); node-&gt;wd = wd; node-&gt;name = strdup(name); node-&gt;next = next; return node;}struct listNode *searchWD(const char *name) { struct listNode *next = head-&gt;next; while (next) { if(strcmp(next-&gt;name, name) == 0) { return next; } next = next-&gt;next; } return NULL;}struct listNode *search(int wd) { struct listNode *next = head-&gt;next; while (next) { if(next-&gt;wd == wd) { return next; } next = next-&gt;next; } return NULL;}bool delete(int wd) { struct listNode *next = head; while (next-&gt;next) { if(next-&gt;next-&gt;wd == wd) { struct listNode *del = next-&gt;next; next-&gt;next = next-&gt;next-&gt;next; free(del); return true; } next = next-&gt;next; } return false;}const uint32_t watch_mask = IN_CREATE|IN_DELETE|IN_DELETE_SELF|IN_MOVED_TO|IN_MOVED_FROM;int fd = -1;size_t read_event(void *ievent) { size_t numRead = read(fd, ievent, 10 * (sizeof(struct inotify_event) + NAME_MAX + 1)); if(numRead == -1) { fprintf(stderr, &quot;read1: %s\\n&quot;, strerror(errno)); return -1; } printf(&quot;readNum = %lu\\n&quot;, numRead); return numRead;}int addwatch(const char *path) { int wd; if((wd = inotify_add_watch(fd, path, watch_mask)) != -1) { struct listNode *e = NULL; if((e = search(wd)) == NULL) { head-&gt;next = newListNode(wd, path, head-&gt;next); } else { free(e-&gt;name); e-&gt;name = strdup(path); } fprintf(stderr, &quot;watching: %s\\n&quot;, path); return 0; } else { fprintf(stderr, &quot;fail to watch: %s, %s\\n&quot;, path, strerror(errno)); return -1; }}int nftw_read(const char *path, const struct stat *sbuf, int type, struct FTW *ftwb) { switch (sbuf-&gt;st_mode &amp; S_IFMT) { case S_IFDIR: break; default: return 0; } addwatch(path); return 0;}void update_monitor(struct inotify_event *ievent) { struct listNode *node = search(ievent-&gt;wd); char *new_path = malloc(strlen(node-&gt;name) + strlen(ievent-&gt;name) + 1 + 1); sprintf(new_path, &quot;%s/%s&quot;, node-&gt;name, ievent-&gt;name); struct stat stat1; if(stat(new_path, &amp;stat1) != -1) { if((stat1.st_mode &amp; S_IFMT) == S_IFDIR) {// addwatch(new_path); if(nftw(new_path, nftw_read, 10, FTW_PHYS) == -1) { fprintf(stderr, &quot;fail to traverse: %s, %s\\n&quot;, new_path, strerror(errno)); } } } free(new_path);}int nftw_del(const char *path, const struct stat *sbuf, int type, struct FTW *ftwb) { switch (sbuf-&gt;st_mode &amp; S_IFMT) { case S_IFDIR: break; default: return 0; }// addwatch(path); int wd = searchWD(path)-&gt;wd; inotify_rm_watch(fd,wd); delete(wd); return 0;}void rm_monitor(struct inotify_event *ievent, bool recursive) { if(recursive) { struct listNode *node = search(ievent-&gt;wd); char *new_path = malloc(strlen(node-&gt;name) + strlen(ievent-&gt;name) + 1 + 1); sprintf(new_path, &quot;%s/%s&quot;, node-&gt;name, ievent-&gt;name); if (nftw(new_path, nftw_del, 10, FTW_PHYS) == -1) { fprintf(stderr, &quot;fail to traverse: %s, %s\\n&quot;, new_path, strerror(errno)); } free(new_path); } else {// int wd = searchWD(new_path)-&gt;wd; inotify_rm_watch(fd,ievent-&gt;wd); delete(ievent-&gt;wd); }}void process_event(struct inotify_event *ievent) {// IN_CREATE|IN_DELETE|IN_DELETE_SELF|IN_MOVE printf(&quot;mask = %x\\n&quot;, ievent-&gt;mask); if(ievent-&gt;mask &amp; IN_CREATE) { printf(&quot;Monitor: File Creation: %s/%s\\n&quot;, search(ievent-&gt;wd)-&gt;name, ievent-&gt;name); update_monitor(ievent); } if(ievent-&gt;mask &amp; IN_DELETE) { printf(&quot;Monitor: File Deletion: %s, wd = %s\\n&quot;, ievent-&gt;name, search(ievent-&gt;wd)-&gt;name); } if(ievent-&gt;mask &amp; IN_DELETE_SELF) { printf(&quot;Monitor: File Deletion: %s, stop monitoring, wd = %s\\n&quot;, search(ievent-&gt;wd)-&gt;name, search(ievent-&gt;wd)-&gt;name); rm_monitor(ievent, false); } if(ievent-&gt;mask &amp; IN_MOVED_FROM) { printf(&quot;Monitor: File Move in, from: %s/%s\\n&quot;, search(ievent-&gt;wd)-&gt;name, ievent-&gt;name); rm_monitor(ievent, true); } if(ievent-&gt;mask &amp; IN_MOVED_TO) { printf(&quot;Monitor: File Move out, to: %s/%s\\n&quot;, search(ievent-&gt;wd)-&gt;name, ievent-&gt;name); update_monitor(ievent); }}int main(int argc, char *argv[]) { char *monitor_root = (argc &gt; 1) ? argv[1] : &quot;.&quot;; fd = inotify_init(); if(fd == -1) { fprintf(stderr, &quot;fail to init inotify: %s\\n&quot;, strerror(errno)); return 1; } head = newListNode(0, &quot;&quot;, NULL); if(head == NULL) { fprintf(stderr, &quot;fail to malloc head, %s\\n&quot;, strerror(errno)); return 2; } if(nftw(monitor_root, nftw_read, 10, FTW_PHYS) == -1) { fprintf(stderr, &quot;fail to traverse: %s, %s\\n&quot;, monitor_root, strerror(errno)); } void *ievent = malloc(10 * (sizeof(struct inotify_event) + NAME_MAX + 1)); for(;len()&gt;0;) { size_t numread = -1; if((numread = read_event(ievent)) == -1) { fprintf(stderr, &quot;read fail, sleep\\n&quot;); usleep(500000); continue; } for(void *p = ievent; p &lt; ievent + numread;) { struct inotify_event* e = (struct inotify_event *)p; p += e-&gt;len + sizeof(struct inotify_event); process_event(e); } } free(ievent);} todo:如果read了半个event怎么办","link":"/home/2023/05/22/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha19/"},{"title":"cha12.系统和进程信息","text":"12.1编写一个程序，以用户名作为命令行参数，列表显示该用户下所有正在运行的进程ID和命令名。（程序清单8-1中的userldFromName()函数对本题程序的编写可能会有所帮助。）通过分析系统中/proc/PID/status文件的 Name:和 Uid:各行信息，可以实现此功能。遍历系统的所有/proc/PID目录需要使用readdir(3)函数，18.8节对其进行了描述。程序必须能够正确处理如下可能性:在确定目录存在与程序尝试打开相应/proc/PID/status文件之间，/proc/PID目录消失了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;unistd.h&gt;#include &lt;dirent.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;pwd.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt; #include &lt;unistd.h&gt;#include &lt;limits.h&gt;uid_t getUid(const char * user) { errno = 0; struct passwd *ret = getpwnam(user); if(ret == NULL) { fprintf(stderr, &quot;ERROR: fail to get uid of user '%s'\\n&quot;, user); exit(1); } return ret-&gt;pw_uid;}int get_pid_max() { FILE *pid_max = fopen(&quot;/proc/sys/kernel/pid_max&quot;, &quot;r&quot;); int ret = -1; fscanf(pid_max, &quot;%d&quot;, &amp;ret); fclose(pid_max); if(ret == -1) { fprintf(stderr, &quot;Error: fail to read /proc/sys/kernel/pid_max\\n&quot;); exit(3); } return ret;}int main(int argc, char **argv) { if(argc &lt; 2 || strcmp(argv[1], &quot;-help&quot;) == 0) { fprintf(stderr, &quot;Usage: user list [-help]\\n&quot;); exit(0); } pid_t pid_max = get_pid_max(); uid_t *uidlist = (uid_t *)alloca(argc * sizeof(uid_t)); pid_t **uid2pids = (pid_t **)alloca(argc * sizeof(pid_t*)); for(int i = 1; i &lt; argc; i++) { uidlist[i] = getUid(argv[i]); uid2pids[i] = (pid_t *)alloca((pid_max + 1) * sizeof(pid_t)); uid2pids[i][0] = 0; } DIR *proc = opendir(&quot;/proc&quot;); if(proc == NULL) { fprintf(stderr, &quot;ERROR: fail to read /proc: %s\\n&quot;, strerror(errno)); exit(1); } struct dirent *proc_rent = NULL; while((proc_rent = readdir(proc)) != NULL) { const char *spid = proc_rent-&gt;d_name; char *end; errno = 0; pid_t pid = strtol(spid, &amp;end, 10); if(end == spid || *end != '\\0' || errno != 0) { fprintf(stderr, &quot;INFO: %s/%s is not a pid\\n&quot;, &quot;/proc&quot;, spid); continue; } char filename[128] = {0}; sprintf(filename, &quot;/proc/%s/status&quot;, spid); FILE *status = fopen(filename, &quot;r&quot;); if(status == NULL) { fprintf(stderr, &quot;ERROR: fail to open %s\\n&quot;, filename); exit(4); } uid_t realUid = -1; char buffer[1024] = {0}; fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*s %u&quot;, &amp;realUid); //忽略前8行 if(realUid == -1) { fprintf(stderr, &quot;ERROR: fail to read Uid in %s/%s/status\\n&quot;, &quot;/proc&quot;, spid); exit(2); } for(int i = 1; i &lt; argc; i++) { if(realUid == uidlist[i]) { uid2pids[i][++uid2pids[i][0]] = pid; break; } } fclose(status); } for(int i = 1; i &lt; argc; i++) { printf(&quot;---------------Process of User: %s, uid = %u---------------\\n&quot;, argv[i], uidlist[i]); for(int j = 1; j &lt; uid2pids[i][0]; j++) { printf(&quot;\\t├ %d\\n&quot;, uid2pids[i][j]); } if(uid2pids[i][0] == 0) { printf(&quot;\\t(nil)\\n&quot;); } else { printf(&quot;\\t└ %d\\n&quot;, uid2pids[i][uid2pids[i][0]]); } } closedir(proc);} /proc/PID目录消失我觉得不要去读/proc/PID目录就好了，直接读/proc/PID/status，不存在就返回NULL， 然后读取下一个pid 12.2实现一个pstree 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#include &lt;unistd.h&gt;#include &lt;dirent.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt; #include &lt;unistd.h&gt;#include &lt;limits.h&gt;int get_pid_max() { FILE *pid_max = fopen(&quot;/proc/sys/kernel/pid_max&quot;, &quot;r&quot;); int ret = -1; fscanf(pid_max, &quot;%d&quot;, &amp;ret); fclose(pid_max); if(ret == -1) { fprintf(stderr, &quot;Error: fail to read /proc/sys/kernel/pid_max\\n&quot;); exit(1); } return ret;}struct process { char *name; char *cmd; pid_t parent; pid_t pid; struct process *children; struct process *sibling;};char *append(char * str, const char *cat) { int len = strlen(str) + strlen(cat) + 1; char *ret = malloc(len*sizeof(char)); ret[0] = 0; strcat(ret, str); strcat(ret, cat); return ret;}int max(int a, int b) { return a&gt;b?a:b;}void prettyPrint(struct process *root, char *preffix, int last) { const char * tab = last ? &quot;└&quot; : &quot;├&quot;; printf(&quot;%s│•Name=%s\\n&quot;, preffix, root-&gt;name); printf(&quot;%s│ pid=%d\\n&quot;, preffix, root-&gt;pid); printf(&quot;%s│ cmd=%s\\n&quot;, preffix, root-&gt;cmd); printf(&quot;%s│ ppid=%d\\n&quot;, preffix, root-&gt;parent); printf(&quot;%s%s&quot;, preffix, tab); struct process *move = root-&gt;children; if(move != NULL) { printf(&quot;┬&quot;); } else { printf(&quot;─&quot;); } int suff = max(max(strlen(root-&gt;name)+5, strlen(root-&gt;cmd)+4), 10); while(suff) {printf(&quot;─&quot;); suff--;} printf(&quot;\\n&quot;); preffix = append(preffix, (!last ? &quot;│&quot; : &quot; &quot;)); while(move != NULL &amp;&amp; move-&gt;sibling != NULL) { prettyPrint(move, preffix, 0); move = move-&gt;sibling; } if(move != NULL) prettyPrint(move, preffix, 1);}int main(int argc, char **argv) {#ifndef DEBUG freopen(&quot;/dev/null&quot;, &quot;w&quot;, stderr);#endif long lim_filename = pathconf(&quot;/proc&quot;,_PC_NAME_MAX); long lim_argmax = sysconf(_SC_ARG_MAX); int pid_max = get_pid_max(); struct process **pidlist = (struct process **)malloc(pid_max * sizeof(struct process *)); pid_t *pids = (pid_t *)malloc(pid_max * sizeof(pid_t)); int pidscount = 0; pids[pidscount++] = 0; memset(pidlist, 0, pid_max * sizeof(struct process *)); pidlist[0] = malloc(sizeof(struct process)); memcpy(pidlist[0], &amp;(struct process) { .name=NULL, //filename ? .cmd=NULL, .parent=-1, .pid=0, .children=NULL, .sibling=NULL }, sizeof(struct process)); char *filename = malloc((14 + lim_filename+1)*sizeof(char)); DIR *proc = opendir(&quot;/proc&quot;); struct dirent *proc_rent = NULL; while((proc_rent = readdir(proc)) != NULL) { const char *spid = proc_rent-&gt;d_name; char *end; errno = 0; pid_t pid = strtol(spid, &amp;end, 10); if(end == spid || *end != '\\0' || errno != 0) { fprintf(stderr, &quot;INFO: %s/%s is not a pid\\n&quot;, &quot;/proc&quot;, spid); continue; } // if(pid == selfpid || pid == selfppid) continue; fprintf(stderr, &quot;INFO: current pid = %d\\n&quot;, pid); pidlist[pid] = malloc(sizeof(struct process)); memcpy(pidlist[pid], &amp;(struct process) { .name=malloc((lim_filename+1)*sizeof(char)), //filename ? .cmd=malloc((lim_argmax+1)*sizeof(char)), .parent=-1, .pid=pid, .children=NULL, .sibling=NULL }, sizeof(struct process)); pidlist[pid]-&gt;name[0] = 0; pidlist[pid]-&gt;cmd[0] = 0; sprintf(filename, &quot;/proc/%s/status&quot;, spid); FILE *status = fopen(filename, &quot;r&quot;); if(status == NULL) { fprintf(stderr, &quot;ERROR: fail to open %s\\n&quot;, filename); exit(4); } uid_t realUid = -1; char buffer[1024] = {0}; fscanf(status, &quot;%*s %s\\n&quot;, pidlist[pid]-&gt;name); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*s %d\\n&quot;, &amp;pidlist[pid]-&gt;parent); if(strcmp(pidlist[pid]-&gt;name, &quot;&quot;) == 0 || pidlist[pid]-&gt;parent == -1) { fprintf(stderr, &quot;ERROR: fail to read name or ppid in %s/%s/status\\n&quot;, &quot;/proc&quot;, spid); exit(2); } // printf(&quot;read /proc/%s/status, name = %s, ppid = %d\\n&quot;, spid,pidlist[pid]-&gt;name, pidlist[pid]-&gt;parent); sprintf(filename, &quot;/proc/%s/cmdline&quot;, spid); FILE *cmdline = fopen(filename, &quot;r&quot;); if(cmdline == NULL) { fprintf(stderr, &quot;ERROR: fail to open %s\\n&quot;, filename); exit(4); } fscanf(cmdline, &quot;%s&quot;, pidlist[pid]-&gt;cmd); // printf(&quot;read cmdline = %s\\n&quot;, pidlist[pid]-&gt;cmd); fclose(cmdline); fclose(status); pids[pidscount++] = pid; // pid_t ppid = pidlist[pid]-&gt;parent; // pidlist[pid]-&gt;sibling = pidlist[ppid]-&gt;children; // pidlist[ppid]-&gt;children = pidlist[pid]; // 不能在这里找父节点，父节点可能还没读出来。 } for(int i = 1; i &lt; pidscount; i++) { pid_t pid = pids[i]; pid_t ppid = pidlist[pid]-&gt;parent; pidlist[pid]-&gt;sibling = pidlist[ppid]-&gt;children; pidlist[ppid]-&gt;children = pidlist[pid]; } closedir(proc); prettyPrint(pidlist[1], memset(malloc(sizeof(char)), 0, sizeof(char)), 1); for(int i = 0; i &lt; pidscount; i++) { free(pidlist[pids[i]]-&gt;name); free(pidlist[pids[i]]-&gt;cmd); free(pidlist[pids[i]]); } free(filename); free(pids); free(pidlist); return 0;} 12.3编写一个程序，列表展示打开同一特定路径名文件的所有进程。可以通过分析所有/proc/PID/fd/*符号链接的内容来实现此功能。这需要利用readdir(3)函数来嵌套循环，扫描所有/proc/PID目录以及每个/proc/PID目录下所有/proc/PID/fd的条目内容。读取/proc/PID/fd/n符号链接的内容，需要使用readlink(),18.5节对其进行了描述。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;unistd.h&gt;#include &lt;dirent.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt; #include &lt;unistd.h&gt;#include &lt;limits.h&gt;int get_pid_max() { FILE *pid_max = fopen(&quot;/proc/sys/kernel/pid_max&quot;, &quot;r&quot;); int ret = -1; fscanf(pid_max, &quot;%d&quot;, &amp;ret); fclose(pid_max); if(ret == -1) { fprintf(stderr, &quot;Error: fail to read /proc/sys/kernel/pid_max\\n&quot;); exit(1); } return ret;}int main(int argc, char **argv) { if(argc != 2) { fprintf(stderr, &quot;Usage: %s filename\\n&quot;, argv[0]); exit(0); }#ifndef DEBUG freopen(&quot;/dev/null&quot;, &quot;w&quot;, stderr);#endif int pid_max = get_pid_max(); long lim_argmax = sysconf(_SC_ARG_MAX); long lim_pathmax = pathconf(&quot;/proc&quot;,_PC_PATH_MAX); pid_t *pids = malloc(pid_max * sizeof(pid_t)); int pidscount = 0; DIR *proc = opendir(&quot;/proc&quot;); if(proc == NULL) { fprintf(stderr, &quot;ERROR: fail to read /proc: %s\\n&quot;, strerror(errno)); exit(1); } struct dirent *proc_rent = NULL; char *fdname = alloca((lim_pathmax+1) * sizeof(char)); char *fdlink = alloca((lim_pathmax+1) * sizeof(char)); char *fdbuf = alloca((BUFSIZ + 1) * sizeof(char)); while((proc_rent = readdir(proc)) != NULL) { const char *spid = proc_rent-&gt;d_name; char *end; errno = 0; pid_t pid = strtol(spid, &amp;end, 10); if(end == spid || *end != '\\0' || errno != 0) { fprintf(stderr, &quot;INFO: %s/%s is not a pid\\n&quot;, &quot;/proc&quot;, spid); continue; } sprintf(fdname, &quot;/proc/%s/fd&quot;, spid); DIR *fd = opendir(fdname); struct dirent *fd_rent = NULL; while((fd_rent = readdir(fd)) != NULL) { errno = 0; int filedes = strtol(fd_rent-&gt;d_name, &amp;end, 10); if(end == fd_rent-&gt;d_name || *end != '\\0' || errno != 0) { fprintf(stderr, &quot;INFO: %s/%s is not a fd\\n&quot;, fdname, fd_rent-&gt;d_name); continue; } sprintf(fdlink, &quot;%s/%s&quot;, fdname, fd_rent-&gt;d_name); ssize_t readsize = readlink(fdlink, fdbuf, BUFSIZ); if(readsize == -1) { fprintf(stderr, &quot;ERROR: fail to read link: %s, %s\\n&quot;, fdlink, strerror(errno)); } fdbuf[readsize] = 0;#ifdef DEBUG fprintf(stderr, &quot;fdbuf = %s\\n&quot;, fdbuf);#endif if(strcmp(fdbuf, argv[1]) == 0) { pids[pidscount++] = pid;#ifndef DEBUG break;#endif } } closedir(fd); } closedir(proc); char *command = alloca((lim_argmax+1) * sizeof(char)); if(pidscount &gt; 0) { strcpy(command, &quot;ps -f -p&quot;); for(int i = 0; i &lt; pidscount; i++) { sprintf(command, &quot;%s %d&quot;, command, pids[i]); } } else { char *command = alloca((lim_argmax+1) * sizeof(char)); sprintf(command, &quot;ps -f -p %d&quot;, pid_max); } #ifdef DEBUG fprintf(stderr, &quot;command = %s\\n&quot;, command); #endif system(command); return 0;}","link":"/home/2023/04/24/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha12/"},{"title":"cha15.文件属性","text":"15.1 15.4节中描述了针对各种文件系统操作所需的权限。请使用shell命令或编写程序来回答或验证以下说法。a）将文件属主的所有权限“剥夺”后，即使“本组”和“其他”用户仍有访问权,属主也无法访问文件。b）在一个可读但无可执行权限的目录下，可列出其中的文件名，但无论文件本身的权限如何，也不能访问其内容。c）要创建一个新文件，打开一个文件进行读操作，打开及删除一个文件,父目录和文件本身分别需要具备何种权限?对文件执行重命名操作时，源及目标目录分别需要具备何种权限?若重命名操作的目标文件已存在，该文件需要具备何种权限?为目录设置sticky位(chmod +t)，将如何影响重命名和删除操作? a由检查权限的方式可知，先检查有效用户id与属主id是否相同，不相同则检验有效组id与属组gid是否相同，仍不相同则按照其他用户的权限访问。但由于root用户用于所有能力，所以该命题在没有前提条件属主不为root时该命题为假，若有该前提条件，则可知a)为真。 123touch tmpchmod 066 tmpecho aaa &gt; tmp # Permission Denied b文件夹是一个特殊文件，由readdir, opendir系统调用可知，其中的内容就是文件相关的信息。有读权限，则可知目录下存在哪些文件；有写权限，则可以对文件元数据修改；有搜索权限则可对其中文件进行访问。故b在不考虑root用户的情况下，也是正确的 1234567mkdir dirtouch dir/tmpecho aaa &gt; dir/tmpchmod +r,-w,-x dircat dir/tmp # Permission Denied 没有搜索权mv dir/tmp dir/temp # Permission Denied 没有写入权ls dir # Success 有读取权 c至少需要以下权限 操作 父目录权限 文件权限 打开+读 搜索(+x) 读(+r) 打开+删除 搜索(+x) 写(+w) 无需权限 操作 源目录 目标目录 目标文件(若已存在) 重命名 写(+w) 搜索(+x) 写(+w) 搜索(+x) 无需权限 重命名(源 sticky) 写(+w) 搜索(+x) 写(+w) 搜索(+x) 无需权限 重命名(目标 sticky) 重命名(源+目标 sticky) 在拥有sticky标志的目录下删除其他用户的文件，依然能删，只是会在删除时报错rm: remove write-protected regular file 'tmp'? ，输入y即可 15.2你认为系统调用stat()会改变文件3个时间戳中的任意之一吗?请解释原因。 stat只获取的是文件的信息，而不是去访问文件，对于软连接，其内容就是另一个文件的“地址”，对其解引用的过程就是对文件的访问（但经过实验，并非这样） 15.3在运行Linux 2.6的系统上修改程序清单15-1(t_stat.c)，令其可以纳秒级精度来显示文件时间戳。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//// Created by root on 5/17/23.//#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;sys/time.h&gt;void showlstat(const char *file) { struct stat stat1; if(lstat(file, &amp;stat1) == -1) { exit(1); } char accesstime[1024] = {0}; strftime(accesstime, 1024, &quot;%Y-%b-%a %H:%M:%S&quot;, localtime(&amp;stat1.st_atime)); char modifitime[1024] = {0}; strftime(modifitime, 1024, &quot;%Y-%b-%a %H:%M:%S&quot;, localtime(&amp;stat1.st_mtime)); char statustime[1024] = {0}; strftime(statustime, 1024, &quot;%Y-%b-%a %H:%M:%S&quot;, localtime(&amp;stat1.st_ctime)); printf(&quot;device-id\\t : %lu\\n&quot;, stat1.st_dev); printf(&quot;inode \\t : %lu\\n&quot;, stat1.st_ino); printf(&quot;file-type\\t : %o\\n&quot;, stat1.st_mode); printf(&quot;hard-link\\t : %lu\\n&quot;, stat1.st_nlink); printf(&quot;owner-uid\\t : %u\\n&quot;, stat1.st_uid); printf(&quot;owner-gid\\t : %u\\n&quot;, stat1.st_gid); printf(&quot;st_rdev \\t : %lu\\n&quot;, stat1.st_rdev); printf(&quot;file-size\\t : %ld\\n&quot;, stat1.st_size); printf(&quot;block-size\\t : %ld\\n&quot;, stat1.st_blksize); printf(&quot;block-number\\t : %ld\\n&quot;, stat1.st_blocks); printf(&quot;last-access\\t : %s.%ld\\n&quot;, accesstime, stat1.st_atim.tv_nsec); printf(&quot;last-modify\\t : %s.%ld\\n&quot;, modifitime, stat1.st_mtim.tv_nsec); printf(&quot;last-stat\\t : %s.%ld\\n&quot;, statustime, stat1.st_ctim.tv_nsec);}void showstat(const char *file) { struct stat stat1; if(stat(file, &amp;stat1) == -1) { exit(1); } char accesstime[1024] = {0}; strftime(accesstime, 1024, &quot;%Y-%b-%a %H:%M:%S&quot;, localtime(&amp;stat1.st_atim)); char modifitime[1024] = {0}; strftime(modifitime, 1024, &quot;%Y-%b-%a %H:%M:%S&quot;, localtime(&amp;stat1.st_mtim)); char statustime[1024] = {0}; strftime(statustime, 1024, &quot;%Y-%b-%a %H:%M:%S&quot;, localtime(&amp;stat1.st_ctim)); printf(&quot;device-id\\t : %lu\\n&quot;, stat1.st_dev); printf(&quot;inode \\t : %lu\\n&quot;, stat1.st_ino); printf(&quot;file-type\\t : %o\\n&quot;, stat1.st_mode); printf(&quot;hard-link\\t : %lu\\n&quot;, stat1.st_nlink); printf(&quot;owner-uid\\t : %u\\n&quot;, stat1.st_uid); printf(&quot;owner-gid\\t : %u\\n&quot;, stat1.st_gid); printf(&quot;st_rdev \\t : %lu\\n&quot;, stat1.st_rdev); printf(&quot;file-size\\t : %ld\\n&quot;, stat1.st_size); printf(&quot;block-size\\t : %ld\\n&quot;, stat1.st_blksize); printf(&quot;block-number\\t : %ld\\n&quot;, stat1.st_blocks); printf(&quot;last-access\\t : %s\\n&quot;, accesstime); printf(&quot;last-modify\\t : %s\\n&quot;, modifitime); printf(&quot;last-stat\\t : %s\\n&quot;, statustime);}int main(int argc, char **argv) { for(int i = 1; i &lt; argc; i++) { showstat(argv[i]); showlstat(argv[i]); } return 0;} 15.412345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//// Created by root on 5/17/23.//#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int check_mode(int mask1, int mask2, int mask3, uid_t euid, gid_t egid, struct stat *stat1) { int granted = 0; if(stat1-&gt;st_uid == euid) { if(stat1-&gt;st_mode&amp;mask1) { granted++; } } else if (stat1-&gt;st_gid == egid) { if(stat1-&gt;st_mode&amp;mask2) { granted++; } } else { if(stat1-&gt;st_mode&amp;mask3) { granted++; } } return granted &gt; 0;}int eaccess(const char *pathname, int mode) {// if(mode&amp;F_OK) {// if(access(pathname, F_OK) == -1) {// return -1;// }// }// F_OK为0 struct stat stat1; if(stat(pathname, &amp;stat1) == -1) { return -1; } uid_t euid = geteuid(); gid_t egid = getegid(); if(mode&amp;R_OK) { if(!check_mode(0400, 040, 04, euid, egid, &amp;stat1)) { return -1; } } if(mode&amp;W_OK) { if(!check_mode(0200, 020, 02, euid, egid, &amp;stat1)) { return -1; } } if(mode&amp;X_OK) { if(!check_mode(0100, 010, 01, euid, egid, &amp;stat1)) { return -1; } } return 0;}int main(int argc, char **argv) { if(argc != 3) return -1; int mode = *argv[2] - '0'; char *ok = &quot;ok&quot;; char smode[1024] = {0}; if(eaccess(argv[1], mode) == -1) { ok = &quot;fail&quot;; } if(mode&amp;R_OK) { strcat(smode, &quot;r&quot;); } if(mode&amp;W_OK) { strcat(smode, &quot;w&quot;); } if(mode&amp;X_OK) { strcat(smode, &quot;x&quot;); } printf(&quot;access for %s : %s\\n&quot;, smode ,ok); return 0;} 15.5linux内核提供了current_umask()函数，在头文件#include &lt;linux/fs.h&gt;中 15.6实现chmod的X功能 chmodchmod的大写X表示: execute/search only if the file is a directory or already has execute permission for some user (X) 也就是若某些用户已经有了执行权限时，为其赋予执行/搜索权限 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;string.h&gt;#include &lt;stdbool.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;mode_t MODE = 0;mode_t UMASK = 0;int operation = 0; // bits from high to low represents, -/+/= ugobool flag_X = false;void step41(char *arg) { if(arg == NULL || *arg == 0) return; if(*arg == 'r') { if(operation&amp;01) { MODE |= 04; } if(operation&amp;02) { MODE |= 040; } if(operation&amp;04) { MODE |= 0400; } step41(arg+1); } else if(*arg == 'w') { if(operation&amp;01) { MODE |= 02; } if(operation&amp;02) { MODE |= 020; } if(operation&amp;04) { MODE |= 0200; } step41(arg+1); } else if(*arg == 'x') { if(operation&amp;01) { MODE |= 01; } if(operation&amp;02) { MODE |= 010; } if(operation&amp;04) { MODE |= 0100; } step41(arg+1); } else if(*arg == 'X') { flag_X = true; step41(arg+1); } else if(*arg == 's') { // u+s, g+s if(operation&amp;02) { MODE |= 02000; } if(operation&amp;04) { MODE |= 04000; } step41(arg+1); } else if(*arg == 't') { MODE |= 01000; step41(arg+1); } else { // undefined behavior }}void step42(char *arg) { if(arg == NULL || *arg == 0) return; int flag = *arg - '0'; if(operation&amp;01) { MODE |= flag; } if(operation&amp;02) { MODE |= flag&lt;&lt;3; } if(operation&amp;04) { MODE |= flag&lt;&lt;6; } step42(arg+1);}// parse: [rwxXst]+|[0-7]+void step3(char * arg) { if(arg == NULL || *arg == 0) return; if(*arg == 'r' || *arg == 'w' || *arg == 'x' || *arg == 'X' || *arg == 's' || *arg == 't') { step41(arg); } else if(*arg &gt;= '0' &amp;&amp; *arg &lt;= '7') { step42(arg); } else { // undefined behavior }}// parse: [-+=]([rwxXst]+|[0-7]+)void step2(char * arg) { if(arg == NULL || *arg == 0) return; if(*arg == '-') { operation |= 010; step3(arg+1); } else if(*arg == '+') { operation |= 020; step3(arg+1); } else if(*arg == '=') { operation |= 030; step3(arg+1); } else { // undefined behavior }}// 原本的表达式是: [ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+，简化为// parse: [ugoa]*[-+=]([rwxXst]+|[0-7]+)void step1(char * arg) { if(arg == NULL || *arg == 0) return; if(*arg == 'u') { operation = 4; step1(arg+1); } else if(*arg == 'g') { operation = 2; step1(arg+1); } else if(*arg == 'o') { operation = 1; step1(arg+1); } else if(*arg == 'a') { operation = 7; step1(arg+1); } else { if(operation == 0) { operation = 7; } step2(arg); }}mode_t apply_mod(mode_t mode) { fprintf(stderr, &quot;MODE = %o\\n&quot;, MODE); mode_t mask = ((operation&amp;07) == 0) ? UMASK : 0; fprintf(stderr, &quot;op = %o\\n&quot;, operation); MODE = MODE &amp; (~mask); //00 0 //01 0 //10 1 //11 0 // //( a &amp; ~b ) 逻辑减法 if((operation&amp;00070) == 010) { // - mode = mode &amp; (~MODE); if(flag_X &amp;&amp; (mode&amp;0111)) { mode = (~(0111) &amp; mode); // 三个xxx全都变成0，其余不变 } } else if ((operation&amp;00070) == 020) { // + mode = mode | MODE; if(flag_X &amp;&amp; (mode&amp;0111)) { if(operation&amp;01) { mode |= 01; } if(operation&amp;02) { mode |= 010; } if(operation&amp;04) { mode |= 0100; } } } else if ((operation&amp;00070) == 030) { // = fprintf(stderr, &quot;flagX = %d, mode = %o\\n&quot;, flag_X, mode); if(flag_X &amp;&amp; (mode&amp;0111)) { if(operation&amp;01) { MODE |= 01; } if(operation&amp;02) { MODE |= 010; } if(operation&amp;04) { MODE |= 0100; //这里的大MODE，防止一会mode被MODE覆盖 } } // incase: chmod =X if(operation&amp;01) { mode = (07&amp;MODE) | ((~07)&amp;mode); } if(operation&amp;02) { mode = (070&amp;MODE) | ((~070)&amp;mode); } if(operation&amp;04) { mode = (0700&amp;MODE) | ((~0700)&amp;mode); } mode = (07000&amp;MODE) | ((~07000)&amp;mode); //000 0 //010 0 //100 1 //110 0 //001 0 //011 1 //101 1 //111 1 // //( b &amp; c )|( ~b &amp; a ) // 根据掩码b置位 if(flag_X &amp;&amp; (mode&amp;0111)) { if(operation&amp;01) { mode |= 01; } if(operation&amp;02) { mode |= 010; } if(operation&amp;04) { mode |= 0100; } } } else { } operation = 0; MODE = 0; flag_X = false; return mode;}// parse_mod: split by ','mode_t parse_mod(char * arg, mode_t mode) { fprintf(stderr, &quot;old Mode = %o\\n&quot;, mode); char *end = NULL; while((end = strchr(arg, ',')) != NULL) { *end = 0; step1(arg); mode = apply_mod(mode); fprintf(stderr, &quot;new Mode = %o\\n&quot;, mode); arg = end+1; } step1(arg); mode = apply_mod(mode); fprintf(stderr, &quot;new Mode = %o\\n&quot;, mode); return mode;}mode_t current_umask() { mode_t old = umask(0); umask(old); return old;}int main(int argc, char **argv) {#ifndef DEBUG freopen(&quot;/dev/null&quot;, &quot;w&quot;, stderr);#endif int i = 1; UMASK = current_umask(); char *mode = NULL; for(; i &lt; argc-1; i++) { if(argv[i][0] == '-' &amp;&amp; argv[i][1] == '-') { // argument or --reference fprintf(stderr, &quot;unsupported argument: %s\\n&quot;, argv[i]); } else if(argv[i][0] &gt;= '0' &amp;&amp; argv[i][0] &lt;= '9') { // octal-mode while (*argv[i] != NULL) { MODE *= 8; MODE += *argv[i] - '0'; argv[i]++; } i++; break; } else { // mod mode = argv[i];// parse_mod(argv[i]); i++; break; } } fprintf(stderr, &quot;argv[i] = %s\\n&quot;, argv[i]); fprintf(stderr, &quot;mode = %s\\n&quot;, mode); // chmod if(mode == NULL) { for(; i &lt; argc; i++) { chmod(argv[i], MODE); } } else { for(; i &lt; argc; i++) { struct stat filestat; if (stat(argv[i], &amp;filestat) == -1) { fprintf(stderr, &quot;stat, error: %s\\n&quot;, strerror(errno)); } mode_t newMode = parse_mod(mode, filestat.st_mode); if (chmod(argv[i], newMode) == -1) { fprintf(stderr, &quot;chmod, error: %s\\n&quot;, strerror(errno)); } } } return 0;}// chmod u=s,g=s tmp.c的行为与chmod不同(仅为=s时不同，其他含有多个等号时相同) 15.7实现chattr简化版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//// Created by root on 5/18/23.//// chattr [-+=aAcCdDeijPsStTuFx] [-v version] files...//A：即Atime，告诉系统不要修改对这个文件的最后访问时间。//S：即Sync，一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘。//a：即Append Only，系统只允许在这个文件之后追加数据，不允许任何进程覆盖或截断这个文件。如果目录具有这个属性，系统将只允许在这个目录下建立和修改文件，而不允许删除任何文件。//b：不更新文件或目录的最后存取时间。//c：将文件或目录压缩后存放。//d：当dump程序执行时，该文件或目录不会被dump备份。//D:检查压缩文件中的错误。//i：即Immutable，系统不允许对这个文件进行任何的修改。如果目录具有这个属性，那么任何的进程只能修改目录之下的文件，不允许建立和删除文件。//s：彻底删除文件，不可恢复，因为是从磁盘上删除，然后用0填充文件所在区域。//u：当一个应用程序请求删除这个文件，系统会保留其数据块以便以后能够恢复删除这个文件，用来防止意外删除文件或目录。//t:文件系统支持尾部合并（tail-merging）。//X：可以直接访问压缩文件的内容。#include &lt;unistd.h&gt;#include &lt;linux/fs.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#define SUB 0#define ADD 1#define SET 2int main(int argc, char **argv) { int OP = -1; if(argv[1][0] == '-') { OP = 0; } else if (argv[1][0] == '+') { OP = 1; } else if(argv[1][0] == '=') { OP = 2; } int new_attr = 0; while (*argv[1]) { switch (*argv[1]) { case 'a': new_attr |= FS_APPEND_FL; break; case 'c': new_attr |= FS_COMPR_FL; break; case 'D': new_attr |= FS_DIRSYNC_FL; break; case 'i': new_attr |= FS_IMMUTABLE_FL; break; case 'j': new_attr |= FS_JOURNAL_DATA_FL; break; case 'A': new_attr |= FS_NOATIME_FL; break; case 'd': new_attr |= FS_NODUMP_FL; break; case 't': new_attr |= FS_NOTAIL_FL; break; case 's': new_attr |= FS_SECRM_FL; break; case 'S': new_attr |= FS_SYNC_FL; break; case 'T': new_attr |= FS_TOPDIR_FL; break; case 'u': new_attr |= FS_UNRM_FL; break; case 'C': break; case 'e': break; case 'E': break; case 'F': break; case 'I': break; } argv[1]++; } for(int i = 2; i &lt; argc; i++) { int fd = open(argv[i], O_RDONLY); if (fd == -1) continue; int attr; if (ioctl(fd, FS_IOC_GETFLAGS, &amp;attr) == -1) { continue; } if(OP==SUB) { attr = attr &amp; (~new_attr); }else if(OP == ADD) { attr = attr | new_attr; } else if(OP == SET) { attr = new_attr; } if (ioctl(fd, FS_IOC_SETFLAGS, &amp;attr) == -1) { continue; } close(fd); } return 0;}","link":"/home/2023/05/16/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha15/"},{"title":"cha18.目录与链接","text":"18.14.3.2节曾指出，如果一个文件正处于执行状态，那么要将其打开以执行写操作是不可能的(open)调用返回-1，且将errno置为ETXTBSY。然而，在 shell 中执行如下操作却是可能的: 12345gcc -o longrunner longrunner.c$ ./longrunner &amp;# Leave running in backgroundvi longrunner.c# Make some changes to the source codegcc -o longrunner longrunner.c 最后一条命令覆盖了现有的同名可执行文件。原因何在?(提示:在每次编译后调用ls -li命令来查看可执行文件的i-node编号。) 解释变异前后使用ls -li，inode确实变了。猜测-o参数会令编译程序将临时文件rename为对应名称，rename若newpath存在，则会覆盖。 18.2测试1234567891011121314151617181920//// Created by root on 5/20/23.//#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;int main() { mkdir(&quot;test&quot;, 0700); chdir(&quot;test&quot;); int fd = open(&quot;file&quot;, O_CREAT | O_RDWR, 0744); symlink(&quot;file&quot;, &quot;../file&quot;); chmod(&quot;../file&quot;, 0111); printf(&quot;errno = %s\\n&quot;, strerror(errno)); return 0;} 分析打印出errno， 结果为： Too many levels of symbolic links。通过readlink读取该链接，其内容为file。 通过ll打印，该链接变成了指向自己的链接。chmod对其解引用，得到自身，导致解引用次数达到最大。 1lrwxrwxrwx 1 root root 4 May 20 21:24 file -&gt; file 18.3实现realpath 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//// Created by root on 5/20/23.//#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;limits.h&gt;void parse(char *path, char *realpath) { char *end = NULL; while (path != NULL) { end = strchr(path, '/'); if(end) *end = 0; if(path == end) {} else if (strcmp(path, &quot;.&quot;) == 0) { } else if (strcmp(path, &quot;..&quot;) == 0) { char *tmp = strrchr(realpath, '/'); if (tmp) { *tmp = 0; } } else { strcat(realpath, &quot;/&quot;); strcat(realpath, path); } if(end) path = end + 1; else path = NULL; }}int main(int argc, char **argv) { char *realpath = (char *) malloc(PATH_MAX + 1); char *buff = (char *) malloc(PATH_MAX + 1); realpath[0] = 0; buff[0] = 0; char *path = strdup(argv[1]); if(path[0] != '/') getcwd(realpath, NAME_MAX); parse(path, realpath); struct stat stat1; if(lstat(realpath, &amp;stat1) == -1) { fprintf(stderr, &quot;%s\\n&quot;, strerror(errno)); } if(S_ISLNK(stat1.st_mode)) { int readsize = readlink(realpath, buff, NAME_MAX); buff[readsize] = 0; struct stat stat2; if(stat(buff, &amp;stat2) != -1) { char *tmp = strrchr(realpath, '/'); if (tmp) { *tmp = 0; } parse(buff, realpath); } } printf(&quot;%s\\n&quot;, realpath); return 0;} 2023年6月3日更新之前没有考虑到目录也可以有软链接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//// Created by root on 5/20/23.//#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;limits.h&gt;void parse(char *path, char *realpath, char *buff) { char *end = NULL; while (path != NULL &amp;&amp; *path) { end = strchr(path, '/'); if(end) *end = 0; if(end == path) { } else if (strcmp(path, &quot;.&quot;) == 0) { } else if (strcmp(path, &quot;..&quot;) == 0) { char *tmp = strrchr(realpath, '/'); if (tmp) { *tmp = 0; } } else { strcat(realpath, &quot;/&quot;); strcat(realpath, path); struct stat stat1; if(lstat(realpath, &amp;stat1) == -1) { fprintf(stderr, &quot;%s:%s\\n&quot;, strerror(errno), realpath); exit(1); } if(S_ISLNK(stat1.st_mode)) { ssize_t readsize = readlink(realpath, buff, NAME_MAX); buff[readsize] = 0;// printf(&quot;%s is link to: %s\\n&quot;, realpath, buff); if(buff[0] == '/') { realpath[0] = 0; } else { char *tmp = strrchr(realpath, '/'); if (tmp) { *tmp = 0; } else { realpath[0] = 0; //不需要，相对路径已经变成绝对路径了 } } parse(buff, realpath, buff); } } if(end) path = end + 1; else path = NULL; }}int main(int argc, char **argv) { char *realpath = (char *) malloc(PATH_MAX + 1); char *buff = (char *) malloc(PATH_MAX + 1); char *cwd = (char *) malloc(PATH_MAX + 1); cwd[0] = 0; realpath[0] = 0; buff[0] = 0; char *argpath = strdup(argv[1]); if(argpath[0] != '/') getcwd(cwd, NAME_MAX); parse(cwd, realpath, buff); parse(argpath, realpath, buff); printf(&quot;%s\\n&quot;, realpath); return 0;} 18.4把18.4换成readdir_r 代码懒得写，无聊 18.5实现getcwd 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//// Created by root on 5/21/23.//#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;dirent.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#include &lt;string.h&gt;struct list { char name[NAME_MAX+1]; struct list *next;} * head;struct list *new_list(const char *name, struct list *next) { struct list *ret = malloc(sizeof(struct list)); strcpy(ret-&gt;name, name); ret-&gt;next = next; return ret;}bool samestat(struct stat* stat1, struct stat* stat2) { return stat1-&gt;st_ino == stat2-&gt;st_ino &amp;&amp; stat1-&gt;st_dev == stat2-&gt;st_dev;}int main() { head = new_list(&quot;&quot;, NULL); long namemax = pathconf(&quot;.&quot;, _PC_NAME_MAX); char *buff = alloca(namemax + 1); buff[0] = 0; strcat(buff, &quot;../&quot;); while (true) { struct stat pwdstat, parentstat; stat(&quot;.&quot;, &amp;pwdstat); stat(&quot;..&quot;, &amp;parentstat); if (samestat(&amp;pwdstat, &amp;parentstat)) { break; } DIR *parent = opendir(&quot;..&quot;); struct dirent *parent_rent = NULL; while ((parent_rent = readdir(parent)) != NULL) { buff[3] = 0; strcat(buff + 3, parent_rent-&gt;d_name); struct stat readstat; stat(buff, &amp;readstat); if (samestat(&amp;readstat, &amp;pwdstat)) { printf(&quot;match! :%s\\n&quot;, parent_rent-&gt;d_name); head-&gt;next = new_list(parent_rent-&gt;d_name, head-&gt;next); break; } } fchdir(dirfd(parent)); closedir(parent); } struct list *p = head; while (p) { printf(&quot;%s/&quot;, p-&gt;name); p = p-&gt;next; } printf(&quot;\\n&quot;); return 0;} 18.6 18.7 18.8实现nftw 懒得写 18.9如果程序不知道当前工作目录，且在当前目录和目标目录下都打开了文件，其文件fd为fd1和fd2那么，fchdir效率更高。 chdir: $ pwd=getcwd(), chdir(dir1), chdir(pwd), chdir(dir1), chdir(pwd), … $ fchdir $ fchdir(fd2), fchdir(fd1), fchdir(fd2), fchdir(fd1), … $ 跟据Flawfinder的输出，chdir, chown等函数依靠路径名，攻击者在调用前将文件移走，会导致chown，chdir失败，使用fchown，fchdir会更安全。 即，少调用一次getpwd 若在当前目录下打开了文件，而没有目标目录下的文件 $ chdir(dir1), fchdir(fd), chdir(dir1), fchdir(fd), … $","link":"/home/2023/05/20/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha18/"},{"title":"cha20.信号:基本概念","text":"20.2展示SIG_IGN一定不会收到信号 123456789101112131415161718192021222324//// Created by root on 5/23/23.//#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;int main() { signal(SIGINT, SIG_IGN); printf(&quot;set SIGINT(%s) as SIG_IGN. always ignore ctrl-c\\n&quot;, strsignal(SIGINT)); for(int i = 16; i &gt;= 0; i--) { sleep(1); printf(&quot;sleep %ds, try press ctrl-c\\n&quot;, i); } signal(SIGINT, SIG_DFL); printf(&quot;set SIGINT(%s) as SIG_DFL. always take default action for ctrl-c\\n&quot;, strsignal(SIGINT)); for(;;) { usleep(500000); printf(&quot;try press ctrl-c\\n&quot;); } return 0;} 20.3展示sigaction时，sa_nodefer和sa_resethand的作用 123456789101112131415161718192021222324252627282930313233343536373839404142//// Created by root on 5/23/23.//#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;void sigint_handler(int sig) { if(sig != SIGINT) { return; } printf(&quot;喵！\\n&quot;); sleep(1); // sa_nodefer处理过程中，不阻塞sigint // 此时连续按ctrl-c，可以喵很多次 printf(&quot;汪！\\n&quot;);}int main() { sigaction(SIGINT, &amp;(struct sigaction){ .sa_handler = sigint_handler, .sa_flags = SA_NODEFER, }, NULL); printf(&quot;set SIGINT(%s) as SA_NODEFER\\n&quot;, strsignal(SIGINT)); for(int i = 16; i &gt;= 0; i--) { sleep(1); printf(&quot;sleep %ds, try press ctrl-c\\n&quot;, i); } sigaction(SIGINT, &amp;(struct sigaction){ .sa_handler = sigint_handler, .sa_flags = SA_RESETHAND, }, NULL); printf(&quot;set SIGINT(%s) as SA_RESETHAND\\n&quot;, strsignal(SIGINT)); for(;;) { usleep(500000); printf(&quot;try press ctrl-c\\n&quot;); } return 0;} sa_nodefersa_nodefer处理过程中，不阻塞sigint，此时连续按ctrl-c，可以喵很多次 sleep的信号好像也被sigint干扰了 sa_resethand等于sa_oneshot，执行一次，恢复默认 20.4sigaction实现siginterrupt siginterrupt来源 123456789101112131415161718NAME siginterrupt - 允许信号中断系统调用 SYNOPSIS #include &lt;signal.h&gt; int siginterrupt(int sig, int flag);DESCRIPTION 当系统调用被信号sig中断时，siginterrupt（）函数将更改重新启动行为。 如果flag参数为false（0）， 则如果被指定的信号sig中断，则将重新启动系统调用。 这是Linux中的默认行为。 如果flag参数为true（1）并且未传输任何数据，则被信号sig中断的系统调用将返回-1，并且errno将设置为EINTR。 如果flag参数为true（1）并且数据传输已开始，则系统调用将被中断，并将返回实际传输的数据量。 RETURN VALUE siginterrupt（）函数成功返回0。 如果信号编号sig无效，则返回-1，并将errno设置为指示错误原因。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//// Created by root on 5/23/23.//#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#define true 1#define false 0#define isTrue(x) ((x) != 0)#define isFalse(x) ((x) == 0)void sigint_handler(int sig) { if(sig != SIGINT) { return; } printf(&quot;喵！\\n&quot;); printf(&quot;汪！\\n&quot;);}int __siginterrupt(int __sig, int __interrupt) { struct sigaction sigact, sigact1; sigaction(__sig, &amp;sigact1, &amp;sigact); if(isTrue(__interrupt)) { // add SA_RESTART sigact.sa_flags |= SA_RESTART; } else { // sub SA_RESTART sigact.sa_flags &amp;= ~SA_RESTART; } return sigaction(__sig, &amp;sigact, NULL);}int main() { void *buf[BUFSIZ]; sigaction(SIGINT, &amp;(struct sigaction) { .sa_handler = sigint_handler, .sa_flags = SA_NODEFER, }, NULL); __siginterrupt(SIGINT, false); pid_t pid = fork(); if(pid == 0) { kill(getppid(), SIGINT); } else { int fd = open(&quot;/proc/self/status&quot;, O_RDONLY); size_t read_num = 0, write_num; if ((read_num = read(fd, buf, BUFSIZ)) == -1) { printf(&quot;read_num = %lu\\n&quot;, read_num); printf(&quot;fail to read /proc/self/status, %s\\n&quot;, strerror(errno)); return errno; } if ((write_num = write(STDOUT_FILENO, buf, read_num)) != read_num) { printf(&quot;write_num = %lu\\n&quot;, write_num); printf(&quot;fail to write STDOUT_FILENO, %s\\n&quot;, strerror(errno)); return errno; } } return 0;} 验证不太成功，可以参考这篇文章，创建并等待消息队列","link":"/home/2023/05/23/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha20/"},{"title":"cha21.信号:信号处理器函数","text":"21.1实现abort 123456789101112131415161718192021void __abort(void) { fflush(NULL); // 随便输出点什么吧 void *buff = malloc(BUFSIZ); int cd = open(&quot;coredump&quot;, O_RDWR | O_CREAT, 0644); int mem = open(&quot;/proc/self/stack&quot;, O_RDONLY); size_t readsize; while((readsize = read(mem, buff, BUFSIZ)) &gt; 0) { write(cd, buff, readsize); } close(cd); close(mem); // 后面这三行+fflush就够了吧 printf(&quot;raise SIGABRT\\n&quot;); raise(SIGABRT); printf(&quot;signal SIG_DFL\\n&quot;); signal(SIGABRT, SIG_DFL); printf(&quot;raise SIGABRT\\n&quot;); raise(SIGABRT); printf(&quot;__abort return\\n&quot;);} 读后感可重入问题这一章首先讲了信号处理器函数的可重入问题。这是由于执行信号处理器函数时，有可能再次触发信号，调用该函数。 对于C库函数，大量存在对静态数据的修改，如printf，scanf 对部分系统调用，也存在对静态数据的修改，如crypt，getpwnam等 对全局变量，errno，对他们的修改都是不安全的。故而信号处理器函数中使用的全局变量必须定义为1volatile sig_atomic __variable_name; 他们都是不可重入的，在信号处理器函数中使用都是不安全的。由此定义了异步信号安全函数，即 $$ 函数是可重入的或是信号处理器函数无法将其中断的 $$POSIX，SUS指出了哪些函数是异步信号安全的函数，除此之外都是不安全的 值得注意的是: abort会对stdio流刷新，但依然是异步信号安全的。 exit函数会对stdio流刷新，但不是异步信号安全的。（_exit安全） 终止信号处理函数 _exit kill 非本地跳转（需要使用sigsetjmp siglognjmp，来保存sa_mask） abort 栈溢出信号处理时，信号处理器函数的栈爆了，会产生SIGSEGV信号，为了保证这个信号的正常处理，分配一块”备选信号栈”。使用sigaktstack SA_SIGINFO在使用sigaction时，如果使用SA_SIGINFO标志，会使其返回多余信息。struct sigaction中，函数指针位置是一个union，为两种函数签名之一（不带多余信息的和带多余信息的）。 系统调用的中断 使用while循环或宏 12345while((cnt = read(xxx,xxx,xxx)) == -1 &amp;&amp; errno == EINTR);// or#include &lt;unistd.h&gt;NO_EINTR(cnt = read(xxx,xxx,xxx)); SA_RESTART，使用该flag，部分系统调用，以及建立在其上的库函数，是可重启的；但某些系统调用，以及建立在其上的库函数，是绝对不会重启的。 某些Linux系统调用，未处理的停止信号会产生EINTR错误。当发生SIGSTOP SIGTSTP SIGTTIN SIGTTOU而进程停止，后有收到SIGCONT恢复进程后，就是产生这种错误。 对于sleep，也会被中断，但他不会产生错误，只是返回剩余秒数","link":"/home/2023/05/24/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha21/"},{"title":"cha24.进程的创建","text":"1执行下面代码后会产生多少新进程 123fork();fork();fork(); $ 2^3 -1 = 7 $ 123fork(); // A，产生B， A+Bfork(); // A产生C，B产生D， A+B+C+Dfork(); // ABCD产生EFGH，A+B+C+D+E+F+G+H 2编写一个程序以便验证调用vfork()之后，子进程可以关闭一文件描述符（例如描述符0）而不影响对应父进程中的文件描述符。 无聊不写 3假设可以修改程序源代码，如何在某一特定时刻生成一核心转储（core dump）文件，而同时进程得以继续执行? fork()，然后子进程立刻调用abort() 4在其他UNIX实现上实验程序清单24-5 ( fork_whos_on_first.c）中的程序，并判断在执行fork()后这些系统是如何调度父子进程的。 不弄好麻烦 5假定在程序清单24-6的程序中，子进程也需要等待父进程完成某些操作。为确保达成这一目的,应如何修改程序? fork后子进程sigsuspend，父进程执行完成后kill子进程（向子进程发送信号）","link":"/home/2023/06/19/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha24/"},{"title":"cha22.信号:高级特性","text":"读书笔记核心转储文件 特定信号会引发进程创建核心转储文件（工作目录）并终止。 核心转储文件(core)是内存映像的一个文件，利用调试器可以查看到退出时的代码、数据状态。 P371展示了不会产生核心转储文件的情况，大致为 没有写权限 存在硬链接大于1的同名文件 目录不存在 ulimit等限制为0 二进制程序没有读权限 工作目录的挂载方式为只读 set-user/group-ID程序运行者为非文件属主（组） /proc/sys/kenel/core_pattern中存储了核心转储文件的命名格式化字符串 信号处理、传递特殊情况 SIGKILL和SIGSTOP的默认行为无法改变，无法阻塞。总是可以使用该信号处理失控进程。 前面读书不认真 信号阻塞即对该信号的传递延后，直到该信号从掩码中移除。 除非是实时信号，否则不对阻塞信号排队，恢复信号后只传递该信号一次 SIGCONT恢复停止的进程 SIGCONT总会恢复运行，不论该信号是否被阻塞或忽略 在停止的进程恢复之前，若有其他进程传递其他信号，则该信号并未被真实传递。（除了sigkill） 收到SIGCONT时，处于等待状态的停止信号将会被丢弃。反过来，收到停止信号后，等待状态的SIGCONT也会被丢弃 若由终端产生的信号（SIGHUP SIGINT SIGQUIT SIGTTIN SIGTTOU SIGTSTP）被忽略，则不应该改变其信号处置（处理函数） 这个很难懂，后面34章会讲 sigkill的力所不能及进程休眠时，有两种休眠状态 可打断(TASK_INTERRUPTIBLE)，ps命令中标记为S。如等待终端输入 不可打断(TASK_UNINTERRUPTIBLE)，ps命令中标记为D。如等待磁盘IO完成 在不可打断休眠时，直到脱离这种状态，任何信号（包括sigkill）都不会被传递 如果由于各种BUG导致进程持续不可打断的方式kill，该进程只能通过重启的方式消灭 linux2.6加入了TASK_KILLABLE，类似于不可打断状态，但是可以由致命信号唤醒 硬件产生的信号硬件异常产生的信号一般不设置能正常返回的信号处理器函数，也不将其忽略、阻塞。 若返回，将会重复触发异常若忽略或阻塞，以除0错误为例，此时该如何继续运行呢 一般接受默认行为，或信号处理函数中longjmp或退出（不要正常返回） 信号的同步生成和异步生成信号产生一般是异步的，也就是不确定是否会立刻传递信号对于： 硬件产生信号 raise, kill, killpg向自身发送的信号 是同步产生的，会立刻传递 信号传递的时机与顺序传递 同步信号 硬件产生的信号会立即传递，raise在调用返回之前就会发出信号 异步信号 进程再次获得调度，时间片开始时 内核态到用户态的下一次切换时（系统调用的完成时） 书上此处标注了信号的传递可能引起正在阻塞的系统调用过早地完成。不知道为啥要提到他 解除多个信号的阻塞时解除时，会立刻传递等待中的信号，并且按照信号升序传递 当一个处理器发生用户态和内核态的切换时，会转去调用第二个信号的函数 signal的实现早期的signal实现 进入处理器函数，会自动恢复默认行为。可以手动再次调用signal，但会导致再次设置之前的信号依旧执行默认行为 信号处理器执行过程中不阻塞新信号。过多信号可能导致导致栈溢出 早期的实现不支持自动重启功能(SA_RESTART) 当前提供的都是可靠信号，使用OLD_SIGNAL条件测试宏编译可展示早期的不可靠语义 最好使用sigaction（考虑到可移植性问题） 实时信号实时信号在POSIX的信号基础上进行了扩展 信号范围更大 使用队列管理（长度有上限sysconf(_SC_SIGQUEUE_MAX)） 保证了信号到达的顺序，数量 可以在传递实时信号时同时传递一个整型值或一个指针 为一个包含int和指针的union，对该union的解释交由程序处理 必须使用SA_SIGINFO从中获取上面的union 题目22.1验证：对SIGCONT设置信号处理器并屏蔽，暂停该进程，发送SIGCONT恢复进程，当且仅当取取消对SIGCONT的屏蔽，才会调用其处理器 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;void handler(int sig) { printf(&quot;handler, received sig:%d, %s\\n&quot;, sig, strsignal(sig));}int main() { sigset_t sigset, osigset; signal(SIGCONT, handler); sigemptyset(&amp;sigset); sigaddset(&amp;sigset, SIGCONT); sigprocmask(SIG_BLOCK, &amp;sigset, &amp;osigset); printf(&quot;block SIGCONT\\npid = %u\\n&quot;, getpid()); for(time_t t = time(NULL); time(NULL) &lt; t + 10;) { } printf(&quot;received SIGCONT\\n&quot;); printf(&quot;unblock SIGCONT\\n&quot;); sigprocmask(SIG_SETMASK, &amp;osigset, NULL); return 0;} 22.2假设一个信号和一个实时信号都被阻塞了，当恢复阻塞后，传递顺序是怎样的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;#include &lt;sys/wait.h&gt;void handler(int sig, siginfo_t *siginfo, void *ucontext) { printf(&quot;handler, received sig:%d, %s, &quot;, sig, strsignal(sig)); printf(&quot;sig type = %s\\n&quot;, (siginfo-&gt;si_code == SI_USER) ? &quot;sig&quot; : \\ (siginfo-&gt;si_code == SI_QUEUE) ? &quot;rt-sig&quot; : &quot;other&quot; );}int main() { sigset_t sigset, osigset; sigemptyset(&amp;sigset); for(int i = 1; i &lt; 64; i++) { sigaction(i, &amp;(struct sigaction) { .sa_flags=SA_SIGINFO, .sa_sigaction=handler }, NULL); sigaddset(&amp;sigset, i); } sigprocmask(SIG_BLOCK, &amp;sigset, &amp;osigset); printf(&quot;block\\npid = %u\\n&quot;, getpid()); pid_t pid = fork(); if(!pid) { pid_t ppid = getppid(); int rtsig = SIGRTMIN+1; sigqueue(ppid, rtsig, (union sigval) { .sival_int=1 }); kill(ppid, SIGUSR1); printf(&quot;send rt_sig=%d, sig=%d to parent, ppid = %u\\n&quot;, rtsig, SIGUSR1, ppid); rtsig = SIGRTMIN+2; kill(ppid, SIGUSR2); sigqueue(ppid, rtsig, (union sigval) { .sival_int=1 }); printf(&quot;send rt_sig=%d, sig=%d to parent, ppid = %u\\n&quot;, rtsig, SIGUSR1, ppid); return 0; } for(time_t t = time(NULL); time(NULL) &lt; t + 10;) { } printf(&quot;unblock\\n&quot;); sigprocmask(SIG_SETMASK, &amp;osigset, NULL); wait(NULL); return 0;} 结论先RT，再普通 12345678910blockpid = 31633send rt_sig=35, sig=10 to parent, ppid = 31633send rt_sig=36, sig=10 to parent, ppid = 31633unblockhandler, received sig:36, Real-time signal 2, sig type = rt-sighandler, received sig:35, Real-time signal 1, sig type = rt-sighandler, received sig:17, Child exited, sig type = otherhandler, received sig:12, User defined signal 2, sig type = sighandler, received sig:10, User defined signal 1, sig type = sig 22.322.10节指出，接收信号时，利用sigwaitinfo()调用要比信号处理器外加sigsuspend()调用的方法来得快。随本书发布的源码中提供的signals/sig_speed_ sigsuspend.c程序使用sigsuspend()在父、子进程之间交替发送信号。请对两进程间交换一百万次信号所花费的时间进行计时。(信号交换次数可通过程序命令行参数来提供。）使用sigwaitinfo()作为替代技术来对程序进行修改,并度量该版本的耗时。两个程序间的速度差异在哪里? 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdbool.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#ifndef SIGNUM#define SIGNUM 100#endifvoid handler(int sig, siginfo_t *siginfo, void *ucontext) { printf(&quot;\\&quot;%s\\&quot;, handler received sig:%d, from:%u, info:%d\\n&quot;, strsignal(sig), sig, siginfo-&gt;si_pid, siginfo-&gt;si_value.sival_int);}int fork_main(pid_t pid, int sig, sigset_t *oset, sigset_t *sigset) {#ifdef SIGWAITINFO siginfo_t *siginfo = malloc(sizeof(siginfo_t));#endif sigqueue(pid, sig, (union sigval) { .sival_int = 0 }); printf(&quot;pid: %u, send to: %u\\n&quot;, getpid(), pid); for(int i = 1; i &lt; SIGNUM; i++) {#ifdef SIGWAITINFO sigwaitinfo(sigset, siginfo); printf(&quot;\\&quot;%s\\&quot;, sigwaitinfo received sig:%d, from:%u, info:%d\\n&quot;, strsignal(sig), sig, siginfo-&gt;si_pid, siginfo-&gt;si_value.sival_int);#endif#ifdef SIGSUSPEND sigsuspend(oset);#endif sigqueue(pid, sig, (union sigval) { .sival_int = i }); printf(&quot;pid: %u, send to: %u\\n&quot;, getpid(), pid); }#ifdef SIGWAITINFO free(siginfo);#endif}int main() { sigset_t sigset, oset; sigemptyset(&amp;sigset); sigaddset(&amp;sigset, SIGUSR1); sigaddset(&amp;sigset, SIGUSR2); sigprocmask(SIG_BLOCK, &amp;sigset, &amp;oset); sigaction(SIGUSR1, &amp;(struct sigaction) { .sa_flags = SA_SIGINFO, .sa_sigaction = handler }, NULL); sigaction(SIGUSR2, &amp;(struct sigaction) { .sa_flags = SA_SIGINFO, .sa_sigaction = handler }, NULL); pid_t pid = fork(); printf(&quot;pid = %u\\n&quot;, pid); if(!pid) { fork_main(getppid(), SIGUSR2, &amp;oset, &amp;sigset); } else { fork_main(pid, SIGUSR1, &amp;oset, &amp;sigset); wait(NULL); } return 0;} 分析 测试脚本1234gcc -DSIGNUM=1000 -DSIGWAITINFO practice22.3.c -o practice22.3time ./practice22.3 &gt; SIGSUSPENDgcc -DSIGNUM=1000 -DSIGSUSPEND practice22.3.c -o practice22.3time ./practice22.3 &gt; SIGSUSPEND 测试很多次，sigwaitinfo确实会快一点。偶尔系统时间很少，总体三个时间都小于sigsuspend 12345678910111213141516171819root@tt-surfacepro6:~/linux/cha22# ./practice22.3.sh real 0m0.076suser 0m0.008ssys 0m0.057sreal 0m0.084suser 0m0.000ssys 0m0.069sroot@tt-surfacepro6:~/linux/cha22# ./practice22.3.sh real 0m0.115suser 0m0.000ssys 0m0.076sreal 0m0.126suser 0m0.018ssys 0m0.067s","link":"/home/2023/05/30/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha22/"},{"title":"cha29.线程：介绍","text":"29.1若一线程执行了如下代码,可能会产生什么结果?pthread_join(pthread_self()，NULL);在 Linux上编写一个程序，观察一下实际会发生什么情况。假设代码中有一变量 tid,其中包含了某个线程ID，在自身发起pthread_join(tid, NULL)调用时，要避免造成与上述语句相同的后果，该线程应采取何种措施? 123456789101112131415161718192021222324252627#define CHECK(x) do { \\ if(!(x)) { \\ fwritef(STDERR_FILENO, &quot;error: %s\\n&quot;, strerror(errno)); \\ pthread_exit(NULL); \\ } \\ } while(0)void *thread1_fun(void * args) { sleep(1); return NULL;}void *thread_fun(void * args) { void *ret; printf(&quot;thread: before,join-pthread_self()\\n&quot;); CHECK(pthread_join(pthread_self(), &amp;ret) == 0); printf(&quot;thread: after,join-pthread_self()\\n&quot;); return NULL;}int main() { pthread_t thread; CHECK(pthread_create(&amp;thread, NULL, thread_fun, NULL) == 0); CHECK(pthread_detach(thread) == 0); printf(&quot;main: pthread_created.\\n&quot;); sleep(10); return 0;} 结果pthread_join返回值非0，出现错误，errno表示SUCCESS 为啥是success呢，errno不是一个线程一份吗，还是这个函数不算系统调用？？可能是他调用了waitpid，但是出错位置不在waitpid 措施检查一下tid与pthread_self()呗，使用pthread_equal 29.2除了缺少错误检查，以及对各种变量和结构的声明外，下列程序还有什么问题? 12345678910static void*threadFunc(void *arg){ struct someStruct *pbuf = (struct someStruct *) arg;/* Do some work with structure pointed to by 'pbuf'*/}intmain(int argc,char *argv[]){ struct someStruct buf; pthread_create(&amp;thr，NULL,threadFunc，(void *) &amp;buf); pthread_exit(NULL);} 回答thread函数里面最后没有return（这里感谢Clion的提示 这里居然不会因为main的退出而导致线程的退出，因为在主线程调用这个函数，其他线程会继续运行","link":"/home/2023/06/27/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha29/"},{"title":"cha27.进程执行","text":"exec() 带e的可以指定环境变量，否则继承 带p的允许只提供文件名，允许提供不带&quot;/&quot;的路径，在path中寻找 若无env PATH默认为.:/usr/bin/:/bin 从左往右搜索，直到找到为止 带l的用不定长参数（参数列表），以NULL结尾 execle在NULL后面接envp数组 exec执行脚本当exec第一个参数文件以&quot;#!&quot;开始，则会读取该行进行解析 1#!&lt;interpreter-path&gt; [arg] &lt;script&gt; &lt;script-args...&gt; 如 1#!/bin/bash --debug 若 1execl(&quot;xxx.sh&quot;, &quot;argv1&quot;, &quot;argv2&quot;, ..., NULL); 则实际调用为 1execl(&quot;/bin/bash&quot;, &quot;--debug&quot;, &quot;xxx.sh&quot;, &quot;argv1&quot;, &quot;argv2&quot;, ..., NULL); 1#!/bin/awk -f 信号与execexec时，会将设置了信号处理器函数的信号置为SIG_DFL，将SA_ONSTACK位清除 但是对于置为SIG_IGN的SIGCHLD是否会置为SIG_DFL，susv3并未规定 信号掩码（就是SA_INFO， SA_NODEFER那些东西）与挂起信号的设置会被保存 27.1123456export PATH=/usr/local/bin:/usr/bin:/bin/:./dir1:./dir2ls -l dir1-rw-r--r-- 1 mtk users 7860 Jun 13 11:55 xyzls -l dir2-rwxr-xr-x 1 mtk users 27860 Jun 13 11:55 xyzxyz # 执行这里，结果如何？ 执行失败？搜索到dir1下，但是没有执行权限？ 结果执行成功，访问到dir2下的xyz 27.2用execve实现execlp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdarg.h&gt;#include &lt;errno.h&gt;#include &lt;stdarg.h&gt;#include &lt;stdlib.h&gt; extern char **environ;#define CHECK(x) do { \\ if(!(x)) { \\ fprintf(stderr, &quot;CHECK: %s\\n&quot;, strerror(errno)); \\ exit(1); \\ } \\ } while(0);int _execlp(const char *file, const char *args, ...) { const int malloc_step = 128; unsigned int args_size = malloc_step; const char **arglist = malloc(sizeof(const char *) * args_size); CHECK(arglist != NULL); const char **arglist_ptr = arglist; const char **arglist_endptr = arglist + args_size; va_list va_args; *(arglist_ptr++) = args; va_start(va_args, args); while((*(arglist_ptr++) = va_arg(va_args, const char *)) != NULL) { if(arglist_ptr == arglist_endptr) { args_size += malloc_step; unsigned offset = arglist_ptr - arglist; arglist = realloc(arglist, args_size); CHECK(arglist != NULL); arglist_ptr = arglist + offset; } } va_end(va_args); char *end; if(strchr(file, '/') != NULL) { execve(file, arglist, environ); free(arglist); CHECK(0); return -1; } char *path = getenv(&quot;PATH&quot;); if(path) { path = strdup(path); } else { path = strdup(&quot;.:/usr/bin:/bin&quot;); } char *path_ptr = path; while((end = strchr(path, ':')) != NULL || (end = strchr(path, '\\0')) != NULL) { if(end == path) { break; } *end = '\\0'; int len = snprintf(NULL, 0, &quot;%s/%s&quot;, path, file); CHECK(len &gt;= 0); char *target = malloc(len+1); snprintf(target, len+1, &quot;%s/%s&quot;, path, file); printf(&quot;try exec: %s\\n&quot;, target); execve(target, arglist, environ); CHECK(errno == ENOENT); // ENOENT调用失败只能是由于文件不存在 path = end+1; free(target); } free(path_ptr); free(arglist); return -1;}int main(int argc, char **argv) { switch(argc) { case 2: _execlp(argv[1], argv[1], NULL); break; case 3: _execlp(argv[1], argv[1], argv[1], argv[2], NULL); break; case 4: _execlp(argv[1], argv[1], argv[1], argv[2], argv[3], NULL); break; case 5: _execlp(argv[1], argv[1], argv[1], argv[2], argv[3], argv[4], NULL); break; case 6: _execlp(argv[1], argv[1], argv[2], argv[3], argv[4], argv[5], NULL); break; default: printf(&quot;not support arg num: %d\\n&quot;, argc); break; } return 0;} 27.327-3.如果赋予如下脚本可执行权限并以exec()运行，输出结果如何? 12#!/bin/cat -nHello world 打印文件内容并显示行号 27.4下列代码会有什么效果?在何种情况下会起作用? 12345678910111213141516171819childPid = fork();if (childPid == -1) errExit( &quot;fork1&quot;);if (childPid == 0){/* Child*/ switch (fork()){ case -1: errExit(&quot;fork2&quot;); /* Grandchild*/ case 0: /*----- Do real work here ----- */ exit(EXIT_SUCCESS); /* After doing real work*/ default: exit(EXIT_SUCCESS); /*Make grandchild an orphan*/ }}/* Parent falls through to here*/if (waitpid(childPid，&amp;status, 0) == -1) errExit(&quot;waitpid&quot;);/* Parent carries on to do other things*/ 创建一个孤儿进程，执行真正的任务 作用：比如创建服务器的守护进程 27.527-5.运行如下程序时无输出。试问原因何在? 12345int main(int argc,char *argv[]){ printf(&quot;Hello world&quot;); execlp(&quot;sleep&quot; , &quot;sleep&quot; ,&quot;o&quot;,(char *) NULL);} 还没有fflush，stdio的缓存还未写入系统的缓冲（因为printf没加'\\n'），进程就被替换了。 27.6假设父进程为信号SIGCHLD创建了一处理器程序,同时阻塞该信号。随后，其某一子进程退出，父进程接着执行 wait)以获取该子进程的状态。当父进程解除对SIGCHLD的阻塞时，会发生什么?编写一个程序来验证答案。这一结果与调用system()函数的程序之间有什么关联? 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;signal.h&gt;#include &lt;stdarg.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;int fwritef(int fd, const char *fmt, ...) { va_list vl; va_start(vl, fmt); int n = vsnprintf(NULL, 0, fmt, vl); va_end(vl); if(n &lt; 0) return -1; char *out = malloc(n+1); if(!out) return -1; va_start(vl, fmt); vsnprintf(out, n+1, fmt, vl); va_end(vl); int ret = 0; if(write(fd, out, n) != n) { ret = -1; } free(out); return ret;}#define CHECK(x) do { \\ if(!(x)) { \\ fwritef(STDERR_FILENO, &quot;error: %s\\n&quot;, strerror(errno)); \\ _exit(1); \\ } \\ } while(0)void sigchld_handler(int sig) { fwritef(STDOUT_FILENO, &quot;sigchld_handler: child exit, sig = %d, %s\\n&quot;, sig, strsignal(sig));}void sigusr1_hander(int sig) { pid_t pid = wait(NULL); fwritef(STDOUT_FILENO, &quot;wait child, %d\\n&quot;, pid); sigset_t sigset; CHECK(sigemptyset(&amp;sigset) == 0); CHECK(sigaddset(&amp;sigset, SIGCHLD) == 0); CHECK(sigprocmask(SIG_UNBLOCK, &amp;sigset, NULL) == 0);}int main() { if(sigaction(SIGCHLD, &amp;(struct sigaction) { .sa_handler=sigchld_handler }, NULL) == -1) return 1; if(sigaction(SIGUSR1, &amp;(struct sigaction) { .sa_handler=sigusr1_hander }, NULL) == -1) return 1; sigset_t sigset; CHECK(sigemptyset(&amp;sigset) == 0); CHECK(sigaddset(&amp;sigset, SIGCHLD) == 0); CHECK(sigprocmask(SIG_BLOCK, &amp;sigset, NULL) == 0); pid_t pid = fork(); if(!pid) { kill(getppid(), SIGUSR1); fwritef(STDOUT_FILENO, &quot;child: exit\\n&quot;); exit(0); } else { sleep(100); } return 0;} 收到一个非常正常的信号和system的关联是，，system也是这么实现的？？","link":"/home/2023/06/20/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha27/"},{"title":"cha30.线程：线程同步","text":"读书笔记条件变量一般搭配一个条件和一个互斥量使用 经典的使用方式如下 对于需要在某某条件下运行的线程，先对mutex加锁，以读取condition 若满足，则在预期状态下执行后续操作，结束后对mutex解锁 若不满足，则pthread_cond_wait 此时该函数会先解锁mutex（允许其他进程获取mutex以修改状态） 陷入阻塞，直到其他线程调用pthread_cond_signal或pthread_cond_broadcast唤醒 唤醒后，获取mutex锁，以检查条件是否满足，满足则执行后续，不满足继续调用wait阻塞（故此处需要用while） 对于可以改变某某条件的线程 获取mutex 改变condition signal/broadcast unlock(unlock与上一步顺序可调换) 123456789101112// one threadpthread_mutex_lock(&amp;mutex);while(!condition) pthread_cond_wait(&amp;cond, &amp;mutex);/* condition matched, execute task */pthread_mutex_unlock(&amp;mutex);// other threadpthread_mutex_lock(&amp;mutex);condition = xxxx; // change conditionpthread_cond_signal(&amp;cond); // or pthread_cond_broadcast(&amp;cond);pthread_mutex_unlock(&amp;mutex); // 以上两行顺序任意， broadcast与signal的选择 如果所有线程都需要在同一条件下互斥的执行，那么选择signal，broadcast会唤醒所有线程且大家条件都相同，所有只会有一个线程获得mutex 如果条件不同，如一个线程为condition == STAT1，另一个为condition == STAT2，那么适合broadcast 条件变量的作用是通知某某条件的改变 30.130-1.修改程序清单30-1 ( thread_incr.c）中的程序，以便线程起始函数在每次循环中都能输出 glob 的当前值以及能对线程做唯一标识的标识符。可将线程的这一唯一标识指定为创建线程的函数pthread_create()的调用参数。对于这一程序，需要将线程起始函数的参数改为指针，指向包含线程唯一标识和循环次数限制的数据结构。运行该程序，将输出重定向至一文件，查看内核在调度两线程交替执行时glob 的变化情况。 ok，无聊捏 30.2实现一组线程安全的函数，以更新和搜索一个不平衡二叉树。此函数库应该包含如下形式的函数（目的明显): 1234initialize(tree);add(tree,char *key,void *value);delete(tree,char *key)Boolean lookup(char *key,void**value) 上述函数原型中，tree是一个指向根节点的结构（为此需要足义一个合P的绐构)。例的每个节点保存有一个键-值对。还需为树中每个节点定义一数据结构，其中应包含互斥量，以确保同时仅有一个线程可以访问该节点。initialize()、add()和 lookup()函数的实现相对简单。delete()的实现需要较为深入的考虑。 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324//// Created by root on 6/28/23.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#include &lt;pthread.h&gt;#include &lt;stdarg.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#define CHECK(x, exitline, ...) do { if(!(x)) { \\ fprintf(stderr, &quot;CHECK: &quot;); \\ fprintf(stderr, __VA_ARGS__); \\ fprintf(stderr, &quot;\\n&quot;); \\ exitline; \\ } \\ } while(0)#define CHECKERR(x, exitline) CHECK(x, exitline, &quot;Error: %s\\n&quot;, strerror(errno))typedef int K;typedef int V;typedef struct ConcurrentTreeStruct{ pthread_mutex_t mutex; K *key; V *value; struct ConcurrentTreeStruct *left; struct ConcurrentTreeStruct *right;} *ConcurrentTreeNode;typedef struct ConcurrentTree{ ConcurrentTreeNode dummy; int (*compare)(K *key1, K *key2); void (*destroyKey)(K *key); void (*destroyValue)(V *value);} *ConcurrentTree;ConcurrentTreeNode initCTreeNode(K *key, V *value, ConcurrentTreeNode left, ConcurrentTreeNode right) { ConcurrentTreeNode tree = (ConcurrentTreeNode)malloc(sizeof(struct ConcurrentTreeStruct)); CHECKERR(tree, return NULL); tree-&gt;left = left; tree-&gt;right = right; tree-&gt;key = key; tree-&gt;value = value; CHECKERR(pthread_mutex_init(&amp;tree-&gt;mutex, NULL) == 0, do {free(tree); return NULL; } while(0)); return tree;}ConcurrentTree initCTree( int (*compare)(K *key1, K *key2), void (*destroyKey)(K *key), void (*destroyValue)(V *value)) { ConcurrentTree tree = (ConcurrentTree)malloc(sizeof(struct ConcurrentTree)); CHECKERR(tree, return NULL); tree-&gt;dummy = initCTreeNode(NULL, NULL, NULL, NULL); CHECK(tree-&gt;dummy, do { free(tree); return NULL; } while(0), &quot;&quot;); tree-&gt;compare = compare; tree-&gt;destroyKey = destroyKey; tree-&gt;destroyValue = destroyValue; return tree;}int add(ConcurrentTree tree, K *key, V *value) { CHECK(tree, return -1, &quot;&quot;); CHECKERR(pthread_mutex_lock(&amp;tree-&gt;dummy-&gt;mutex) == 0, return -1); pthread_mutex_t *old = &amp;tree-&gt;dummy-&gt;mutex; ConcurrentTreeNode *treeNode = &amp;tree-&gt;dummy-&gt;left; while(*treeNode){ pthread_mutex_t *lock = &amp;(*treeNode)-&gt;mutex; CHECKERR(pthread_mutex_lock(&amp;(*treeNode)-&gt;mutex) == 0, exit(5)); int cmp = tree-&gt;compare(key, (*treeNode)-&gt;key); if (cmp &lt; 0) { // key小于根 treeNode = &amp;(*treeNode)-&gt;left; } else { treeNode = &amp;(*treeNode)-&gt;right; } CHECKERR(pthread_mutex_unlock(old) == 0, exit(5)); old = lock; } *treeNode = initCTreeNode(key, value, NULL, NULL); CHECKERR(pthread_mutex_unlock(old) == 0, exit(5)); return 0;}void delCTreeNode(ConcurrentTreeNode tree, void (*destroyKey)(K *key), void (*destroyValue)(V *value)) { if(!tree) return; destroyKey(tree-&gt;key); destroyValue(tree-&gt;value); pthread_mutex_destroy(&amp;tree-&gt;mutex); tree-&gt;key = NULL; tree-&gt;value = NULL;}int del(ConcurrentTree tree, K *key) { CHECK(tree, return -1, &quot;&quot;); if(!tree-&gt;dummy-&gt;left) return -1; CHECKERR(pthread_mutex_lock(&amp;tree-&gt;dummy-&gt;mutex) == 0, return -1); CHECKERR(pthread_mutex_lock(&amp;tree-&gt;dummy-&gt;left-&gt;mutex) == 0, do { pthread_mutex_unlock(&amp;tree-&gt;dummy-&gt;mutex); return -1;} while(0)); pthread_mutex_t *parent_lock = &amp;tree-&gt;dummy-&gt;mutex; pthread_mutex_t *child_lock =&amp;tree-&gt;dummy-&gt;left-&gt;mutex; ConcurrentTreeNode *parentNode = &amp;tree-&gt;dummy-&gt;left; ConcurrentTreeNode treeNode = tree-&gt;dummy-&gt;left; while(treeNode) {// printf(&quot;cmp %d, %d\\n&quot;, *key, *treeNode-&gt;key); int cmp = tree-&gt;compare(key, treeNode-&gt;key); if(cmp == 0) { if(treeNode-&gt;left) CHECKERR(pthread_mutex_lock(&amp;treeNode-&gt;left-&gt;mutex) == 0, exit(5)); if(treeNode-&gt;right) CHECKERR(pthread_mutex_lock(&amp;treeNode-&gt;right-&gt;mutex) == 0, exit(5)); ConcurrentTreeNode left = treeNode-&gt;left; ConcurrentTreeNode right = treeNode-&gt;right; if(!left &amp;&amp; !right) { *parentNode = NULL; } else if(!left) { *parentNode = right; } else if(!right) { *parentNode = left; } else { *parentNode = left; } CHECKERR(pthread_mutex_unlock(parent_lock) == 0, exit(5)); if(left &amp;&amp; right) { while (left-&gt;right) { ConcurrentTreeNode old = left; left = left-&gt;right; if(left) CHECKERR(pthread_mutex_lock(&amp;left-&gt;mutex) == 0, exit(5)); CHECKERR(pthread_mutex_unlock(&amp;old-&gt;mutex) == 0, exit(5)); } left-&gt;right = right; } if(left)CHECKERR(pthread_mutex_unlock(&amp;left-&gt;mutex) == 0, exit(5)); if(right)CHECKERR(pthread_mutex_unlock(&amp;right-&gt;mutex) == 0, exit(5)); CHECKERR(pthread_mutex_unlock(child_lock) == 0, exit(5)); delCTreeNode(treeNode, tree-&gt;destroyKey, tree-&gt;destroyValue); free(treeNode); return 0; } else if(cmp &lt; 0) { CHECKERR(pthread_mutex_unlock(parent_lock) == 0, exit(5)); if(treeNode-&gt;left) CHECKERR(pthread_mutex_lock(&amp;treeNode-&gt;left-&gt;mutex) == 0, exit(5)); parent_lock = &amp;treeNode-&gt;mutex; parentNode = &amp;treeNode-&gt;left; treeNode = treeNode-&gt;left; child_lock = treeNode ? &amp;treeNode-&gt;mutex : NULL; } else { CHECKERR(pthread_mutex_unlock(parent_lock) == 0, exit(5)); if(treeNode-&gt;right) CHECKERR(pthread_mutex_lock(&amp;treeNode-&gt;right-&gt;mutex) == 0, exit(5)); parent_lock = &amp;treeNode-&gt;mutex; parentNode = &amp;treeNode-&gt;right; treeNode = treeNode-&gt;right; child_lock = treeNode ? &amp;treeNode-&gt;mutex : NULL; } } CHECKERR(pthread_mutex_unlock(parent_lock) == 0, exit(5)); if(child_lock) CHECKERR(pthread_mutex_unlock(child_lock) == 0, exit(5)); return -1;}int lookup(ConcurrentTree tree, K *key, V **value) { CHECK(tree, return -1, &quot;tree cannot be null&quot;); CHECK(key, return -1, &quot;key cannot be null&quot;); CHECK(value, return -1, &quot;value cannot be null&quot;); CHECKERR(pthread_mutex_lock(&amp;tree-&gt;dummy-&gt;mutex) == 0, return -1); if(tree-&gt;dummy-&gt;left)CHECKERR(pthread_mutex_lock(&amp;tree-&gt;dummy-&gt;left-&gt;mutex) == 0, do { pthread_mutex_unlock(&amp;tree-&gt;dummy-&gt;mutex); return -1;} while(0)); ConcurrentTreeNode treeNode = tree-&gt;dummy-&gt;left; CHECKERR(pthread_mutex_unlock(&amp;tree-&gt;dummy-&gt;mutex) == 0, exit(5)); while(treeNode) { int cmp = tree-&gt;compare(key, treeNode-&gt;key); if(cmp == 0) { *value = treeNode-&gt;value; CHECKERR(pthread_mutex_unlock(&amp;treeNode-&gt;mutex) == 0, exit(5)); return 0; } else if(cmp &lt; 0) { ConcurrentTreeNode old = treeNode; treeNode = treeNode-&gt;left; if(treeNode) CHECKERR(pthread_mutex_lock(&amp;treeNode-&gt;mutex) == 0, do { pthread_mutex_unlock(&amp;old-&gt;mutex); return -1;} while(0)); //先获取新锁，再放弃旧锁 CHECKERR(pthread_mutex_unlock(&amp;old-&gt;mutex) == 0, exit(5)); } else { ConcurrentTreeNode old = treeNode; treeNode = treeNode-&gt;right; if(treeNode) CHECKERR(pthread_mutex_lock(&amp;treeNode-&gt;mutex) == 0, do { pthread_mutex_unlock(&amp;old-&gt;mutex); return -1;} while(0)); CHECKERR(pthread_mutex_unlock(&amp;old-&gt;mutex) == 0, exit(5)); } } return -1;}void destroyCTreeNode(ConcurrentTreeNode tree, void (*destroyKey)(K *key), void (*destroyValue)(V *value)) { if(!tree) return; destroyCTreeNode(tree-&gt;left, destroyKey, destroyValue); destroyCTreeNode(tree-&gt;right, destroyKey, destroyValue); delCTreeNode(tree, destroyKey, destroyValue); free(tree);}void destroyCTree(ConcurrentTree tree) { CHECK(tree, return, &quot;tree cannot be null\\n&quot;); destroyCTreeNode(tree-&gt;dummy-&gt;left, tree-&gt;destroyKey, tree-&gt;destroyValue); free(tree-&gt;dummy); tree-&gt;dummy = NULL;}struct ThreadRet { int read; int add; int del;};struct ThreadArg { ConcurrentTree tree; int threadID;};int cmpInt(int *a, int *b) { if(*a == *b) { return 0; } else if(*a &gt; *b) { return 1; } else { return -1; }}void destroyInt(int *a) { if(a) { free(a); }}int maxKey = 0;pthread_mutex_t mutex_mk;void *threadfn(void *args) { ConcurrentTree tree = ((struct ThreadArg *)args)-&gt;tree; int tid = ((struct ThreadArg *)args)-&gt;threadID; CHECKERR(tree, return NULL); struct ThreadRet *ret = malloc(sizeof(struct ThreadRet)); CHECKERR(ret, return NULL); ret-&gt;read = ret-&gt;add = ret-&gt;del = 0; int opNum = 1000 + rand() % 1001; int *key = (int *)malloc(sizeof(int)); while (opNum--) { int *val; CHECKERR(key, return ret); switch (rand()%3) { case 0: printf(&quot;Thread-%d, try add\\n&quot;, tid); val = (int *)malloc(sizeof(int)); CHECKERR(val, return ret); *val = rand()%200000; CHECKERR(pthread_mutex_lock(&amp;mutex_mk) == 0,return ret); maxKey++; *key = maxKey; CHECKERR(pthread_mutex_unlock(&amp;mutex_mk) == 0,return ret); add(tree, key, val); ret-&gt;add++; printf(&quot;Thread-%d, add (%d, %d)\\n&quot;, tid, *key, *val); key = (int *)malloc(sizeof(int)); break; case 1: printf(&quot;Thread-%d, try read\\n&quot;, tid); CHECKERR(pthread_mutex_lock(&amp;mutex_mk) == 0,return ret); if(maxKey &gt; 0)*key = rand()%maxKey + 1; else *key = -1; CHECKERR(pthread_mutex_unlock(&amp;mutex_mk) == 0,return ret);// printf(&quot;Thread-%d, try read %d\\n&quot;, tid, *key); if(lookup(tree, key, &amp;val) == 0) printf(&quot;Thread-%d, read (%d, %d)\\n&quot;, tid, *key, *val); else printf(&quot;Thread-%d, fail to read (%d)\\n&quot;, tid, *key); ret-&gt;read++; break; case 2: printf(&quot;Thread-%d, try del\\n&quot;, tid); CHECKERR(pthread_mutex_lock(&amp;mutex_mk) == 0,return ret); if(maxKey &gt; 0) { *key = maxKey; } else *key = -1; CHECKERR(pthread_mutex_unlock(&amp;mutex_mk) == 0,return ret);// printf(&quot;Thread-%d, try del %d\\n&quot;, tid, *key); if(del(tree, key) == 0) { printf(&quot;Thread-%d, del (%d)\\n&quot;, tid, *key); CHECKERR(pthread_mutex_lock(&amp;mutex_mk) == 0,return ret); maxKey--; CHECKERR(pthread_mutex_unlock(&amp;mutex_mk) == 0, return ret); } else printf(&quot;Thread-%d, fail to del (%d)\\n&quot;, tid, *key); ret-&gt;del++; break; } } free(key); free(args); return ret;}int main(int argc, char *argv[]) { CHECK(argc &gt; 1, return 1, &quot;Usage: %s threadCnt&quot;, argv[0]); int threadCnt = atoi(argv[1]); pthread_t *thread = malloc(threadCnt * sizeof(pthread_t)); CHECKERR(thread, return 2); CHECKERR(pthread_mutex_init(&amp;mutex_mk, NULL) == 0,return 3); ConcurrentTree tree = initCTree(cmpInt, destroyInt, destroyInt); for(int i = 0; i &lt; threadCnt; i++) { struct ThreadArg *args = malloc(sizeof(struct ThreadArg)); args-&gt;threadID = i+1; args-&gt;tree = tree; CHECKERR(pthread_create(&amp;thread[i], NULL, threadfn, args) == 0,return 1); } for(int i = 0; i &lt; threadCnt; i++) { struct ThreadRet *ret; CHECKERR(pthread_join(thread[i], (void **)&amp;ret) == 0,return 1); if(!ret) { printf(&quot;Summary: Thread-%d occured error, returned NULL\\n&quot;, i+1); } else { printf(&quot;Summary: Thread-%d add=%d, read=%d, del=%d\\n&quot;, i+1, ret-&gt;add, ret-&gt;read, ret-&gt;del); free(ret); } } CHECKERR(pthread_mutex_destroy(&amp;mutex_mk) == 0,return 3); destroyCTree(tree); free(tree); free(thread); return 0;} 用四个线程跑了几次，反正都没有死锁过。还没有仔细看过正确性 valgrindvalgrind跑了很多次，正常情况下全部内存都被free了，没有泄漏 asanasan跑了几次，每次都有错误。用gdb也看不到调用栈，后来clion很给力，打印出了调用栈 不是实现有问题，是在输出log的时候出错了，原理如下 A线程给树里加入一个节点，然后A打印他的值。但在这之前B又把他删除，他的key，value都被free了，这个时候就不对了。","link":"/home/2023/06/29/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha30/"},{"title":"cha31.线程安全和每线程存储","text":"读书笔记 pthread提供了一种所有线程只执行一次（用于所有线程只初始化一次）的方法pthread_once(pthread_once_t*, void (*)(void)); pthread提供了每线程存储，即每个线程有独立与其他线程的存储，使用k-v存储 int pthread_key_create(pthread_key_t *, void (*)(void *));每个线程都存储一份，第一个参数为一个全局变量的指针，第二个参数为线程终止时自动调用的析构函数 int pthread_setspecific(pthread_key_t, const void *)指定key所对应的内存区域，进程终止时会将第二个参数送入析构函数 void * pthread_getspecific(pthread_key_t)获取key所对应的内存区域 31.1实现pthread_once 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//// Created by root on 6/29/23.//#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void init() { printf(&quot;init\\n&quot;);}typedef struct { pthread_mutex_t mutex; bool call;} _pthread_once_t;_pthread_once_t once = { .mutex=PTHREAD_MUTEX_DEFAULT, .call=false};int _pthread_once(_pthread_once_t *once_ctrl, void (*init)(void)) { bool ok; if(pthread_mutex_lock(&amp;once_ctrl-&gt;mutex) == 0) { ok = !once_ctrl-&gt;call; once_ctrl-&gt;call = true; pthread_mutex_unlock(&amp;once_ctrl-&gt;mutex); } else { return -1; } if(ok) { init(); } return 0;}void *fun(void *arg) { printf(&quot;Thread-%d start\\n&quot;, *(int*)arg); if(_pthread_once(&amp;once, init) == 0){ printf(&quot;Thread-%d _pthread_once Success\\n&quot;, *(int*)arg); } free(arg); return NULL;}int main() { pthread_t t; for(int i = 1; i &lt;= 100; i++) pthread_create(&amp;t, NULL, fun, memcpy(malloc(sizeof(int)), &amp;i, sizeof(int))); pthread_exit(NULL);} 31.2实现线程安全版本的dirname,basename 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//// Created by root on 6/29/23.//#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;limits.h&gt;#include &lt;libgen.h&gt;static __thread char dirname_buf[PATH_MAX];static pthread_key_t basename_key;static pthread_once_t basename_once = PTHREAD_ONCE_INIT;char *dirname_r(const char *path) { const char *lastSlash = strrchr(path, '/'); if(!lastSlash) { strncpy(dirname_buf, &quot;.&quot;, 1); } else { strncpy(dirname_buf, path, lastSlash - path); } dirname_buf[PATH_MAX-1] = 0; return dirname_buf;}void destroy_basename(void * buf) { free(buf);}void init_basename() { pthread_key_create(&amp;basename_key, destroy_basename);}char *basename_r(const char *path) { pthread_once(&amp;basename_once, init_basename); char *_basename_buf = (char *)pthread_getspecific(basename_key); if(_basename_buf == NULL) { _basename_buf = malloc(sizeof(char) * PATH_MAX); pthread_setspecific(basename_key, _basename_buf); } const char *lastSlash = strrchr(path, '/'); if(!lastSlash) { lastSlash = path; } else { lastSlash++; } strncpy(_basename_buf, lastSlash, PATH_MAX-1); _basename_buf[PATH_MAX-1] = 0; return _basename_buf;}void *threadfn(void *arg) { if(!arg) return NULL; char *dir = (char *)arg; printf(&quot;dir = %s\\nSAFE :basename = %s, dirname = %s\\n&quot;, dir, basename_r(dir), dirname_r(dir)); printf(&quot;UNSAFE:basename = %s, dirname = %s\\n&quot;, basename(dir), dirname(dir)); return NULL;}int main(int argc, char *argv[]) { for(int i = 1; i &lt; argc; i++) { pthread_t t; pthread_create(&amp;t, NULL, threadfn, argv[i]); } pthread_exit(NULL);}","link":"/home/2023/06/29/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha31/"},{"title":"cha32.线程取消","text":"读书笔记带参宏从作用域的角度上看，带参宏和函数的区别： 函数有新的函数栈，而带参宏没有，因而带参宏在不同作用域调用时，会受到作用域的影响。如在宏A中的定义的变量，也会影响后续。 如果一对作用相反的带参宏，如本节的pthread_cleanup_push和pthread_cleanup_pop，很多实现都是使用带参宏，那么这两个宏调用时必须属于同一个代码块 ?，保证push的作用域包含pop不就好了吗 线程取消线程取消状态可设置为启用和禁用。 若启用，则可以取消，但何时响应未知，依赖于取消类型 若禁用，将取消请求挂起，直到允许取消 线程取消类型 延迟取消，直到取消点（某些特定的系统调用或库函数，如cond_wait等 异步取消，随时都可以取消 包括malloc，free执行过程中，若在这些函数中取消，则很有可能会导致后续内存分配的过程出现错误。 异步取消线程不应该分配资源，（那么是否可以在分配，释放内存时暂时禁止取消，或在计算密集任务开始时设置为异步，结束后恢复？） 适用于计算密集型，长时间没有取消点的情况。 可以手动产生取消点pthread_testcancel()，若调用前已经有了取消请求，则线程会终止","link":"/home/2023/06/29/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha32/"},{"title":"cha36.进程资源","text":"36.1编写一个程序使用getrusage0 RUSAGE CHILDREN标记获取wait调用所等待的子进程相关的信息。(让程序创建一个子进程并使子进程消耗一些 CPU 时间，接着让父进程在调用wait0前后都调用getrusage0。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//// Created by root on 7/18/23.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/times.h&gt;#include &lt;unistd.h&gt;#include &lt;limits.h&gt;#include &lt;sys/resource.h&gt;#define CHECK(x) \\ do { \\ if(!(x)) { \\ fprintf(stderr, &quot;%s:%d\\nerror: %s\\n&quot;, __FILE__, __LINE__,strerror(errno)); \\ exit(0); \\ } \\ } while(0)#define rcputime(rusage, xtime) rusage.xtime.tv_sec + rusage.xtime.tv_usec/1000000.0int main(int argc, char **argv) { long tic = sysconf(_SC_CLK_TCK); long tottm = 0; for(int i = 1; i &lt; argc; i++) { char *end = NULL; long sec = strtol(argv[i], &amp;end, 10); tottm += sec; CHECK(end != argv[i] &amp;&amp; errno == 0); if(!fork()) { struct tms tms, start; CHECK(times(&amp;start) != (clock_t) -1); CHECK(times(&amp;tms) != (clock_t) -1); for(; (tms.tms_utime + tms.tms_stime)/tic - (start.tms_utime + start.tms_stime)/tic &lt;= sec;) { CHECK(times(&amp;tms) != (clock_t) -1); } exit(0); } } printf(&quot;total time:%ld\\n&quot;, tottm); struct rusage rusage; CHECK(getrusage(RUSAGE_CHILDREN, &amp;rusage) != -1); printf(&quot;child use:\\n\\tcpu time:%.2lfs (user)\\n\\tcpu time:%.2lfs (system)\\ntotal:%.2lfs\\n&quot;, rcputime(rusage, ru_utime), rcputime(rusage, ru_stime), rcputime(rusage, ru_utime) + rcputime(rusage, ru_stime)); for(;;) if(waitpid(-1, NULL, 0) == -1 &amp;&amp; errno == 10) break; CHECK(getrusage(RUSAGE_CHILDREN, &amp;rusage) != -1); printf(&quot;&quot; &quot;child use:\\n&quot; &quot;\\tcpu time:\\n&quot; &quot;\\t\\tcpu time:%.2lfs (user)\\n&quot; &quot;\\t\\tcpu time:%.2lfs (system)\\n&quot; &quot;\\ttotal:%.2lfs\\n&quot; &quot;\\tMax resident set:%ldKB\\n&quot; &quot;\\tIntegral shared text mem:%ldkB/s\\n&quot; &quot;\\tIntegral shared data mem:%ldkB/s\\n&quot; &quot;\\tIntegral shared stack mem:%ldkB/s\\n&quot; &quot;\\tsoft page fault:%ld\\n&quot; &quot;\\thard page fault:%ld\\n&quot; &quot;\\tswaps out of physical mem:%ld\\n&quot; &quot;\\tfile input block:%ld\\n&quot; &quot;\\tfile output block:%ld\\n&quot; &quot;\\tIPC msg send:%ld\\n&quot; &quot;\\tIPC msg recv:%ld\\n&quot; &quot;\\tsignal recv:%ld\\n&quot; &quot;\\tvoluntary context switch:%ld\\n&quot; &quot;\\tinvoluntary context switch:%ld\\n&quot;, rcputime(rusage, ru_utime), rcputime(rusage, ru_stime), rcputime(rusage, ru_utime) + rcputime(rusage, ru_stime), rusage.ru_maxrss, rusage.ru_ixrss, rusage.ru_idrss, rusage.ru_isrss, rusage.ru_minflt, rusage.ru_majflt, rusage.ru_nswap, rusage.ru_inblock, rusage.ru_oublock, rusage.ru_msgsnd, rusage.ru_msgrcv, rusage.ru_nsignals, rusage.ru_nvcsw, rusage.ru_nivcsw);} 36.2编写一个程序来执行一个命令，接着显示其当前的资源使用。这个程序与 time(1)命令的功能类似，因此可以像下面这样使用这个程序: 1$ ./rusage command arg... 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//// Created by root on 7/18/23.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/times.h&gt;#include &lt;unistd.h&gt;#include &lt;limits.h&gt;#include &lt;sys/resource.h&gt;#define CHECK(x) \\ do { \\ if(!(x)) { \\ fprintf(stderr, &quot;%s:%d\\nerror: %s\\n&quot;, __FILE__, __LINE__,strerror(errno)); \\ exit(0); \\ } \\ } while(0)#define rcputime(rusage, xtime) rusage.xtime.tv_sec + rusage.xtime.tv_usec/1000000.0int main(int argc, char **argv) { struct rusage rusage; pid_t pid; if((pid = fork()) == 0) { CHECK(execvp(argv[1], &amp;argv[1]) != 0); } CHECK(waitpid(pid, NULL, 0) != -1); CHECK(getrusage(RUSAGE_CHILDREN, &amp;rusage) != -1); printf(&quot;&quot; &quot;child use:\\n&quot; &quot;\\tcpu time:\\n&quot; &quot;\\t\\tcpu time:%.2lfs (user)\\n&quot; &quot;\\t\\tcpu time:%.2lfs (system)\\n&quot; &quot;\\ttotal:%.2lfs\\n&quot; &quot;\\tMax resident set:%ldKB\\n&quot; &quot;\\tIntegral shared mem:(kB/s)\\n&quot; &quot;\\t\\ttext\\tmem:%ldkB/s\\n&quot; &quot;\\t\\tdata\\tmem:%ldkB/s\\n&quot; &quot;\\t\\tstack\\tmem:%ldkB/s\\n&quot; &quot;\\tpage fault:\\n&quot; &quot;\\t\\tsoft:%ld\\n&quot; &quot;\\t\\thard:%ld\\n&quot; &quot;\\tswaps out of physical mem:%ld\\n&quot; &quot;\\tfile input block:%ld\\n&quot; &quot;\\tfile output block:%ld\\n&quot; &quot;\\tIPC msg:\\n&quot; &quot;\\t\\tsend:%ld\\n&quot; &quot;\\t\\trecv:%ld\\n&quot; &quot;\\tsignal recv:%ld\\n&quot; &quot;\\tvoluntary context switch:%ld\\n&quot; &quot;\\tinvoluntary context switch:%ld\\n&quot;, rcputime(rusage, ru_utime), rcputime(rusage, ru_stime), rcputime(rusage, ru_utime) + rcputime(rusage, ru_stime), rusage.ru_maxrss, rusage.ru_ixrss, rusage.ru_idrss, rusage.ru_isrss, rusage.ru_minflt, rusage.ru_majflt, rusage.ru_nswap, rusage.ru_inblock, rusage.ru_oublock, rusage.ru_msgsnd, rusage.ru_msgrcv, rusage.ru_nsignals, rusage.ru_nvcsw, rusage.ru_nivcsw);} 36.3编写一个程序来确定当进程所消耗的各种资源超出通过 setrlimit0调用设置的软限制时会发生什么事情。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250//// Created by root on 7/18/23.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;signal.h&gt;#include &lt;errno.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sched.h&gt;#include &lt;sys/times.h&gt;#include &lt;unistd.h&gt;#include &lt;limits.h&gt;#include &lt;sys/resource.h&gt;#include &lt;fcntl.h&gt;#define CONDITION(x) \\ do { \\ if(!(x)) { \\ fprintf(stderr, &quot;%s:%d\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__, #x); \\ exit(2); \\ } \\ } while(0)#define CHECK(x) \\ do { \\ if(!(x)) { \\ fprintf(stderr, &quot;%s:%d\\nerror: %s\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__,strerror(errno), #x); \\ exit(1); \\ } \\ } while(0)#define USER 10087void test(__rlimit_resource_t res, const char *name,void (*task)(__rlimit_resource_t res, struct rlimit *)) { printf(&quot;test: %d(%s)\\n&quot;, res, name); pid_t pid; CHECK((pid = fork()) != -1); if(!pid) { struct rlimit lim; CHECK(getrlimit(res, &amp;lim) != -1); printf(&quot;soft=%lu, hard=%lu\\n&quot;, lim.rlim_cur, lim.rlim_max); task(res, &amp;lim); printf(&quot;soft=%lu, hard=%lu\\n&quot;, lim.rlim_cur, lim.rlim_max); exit(0); } int status; CHECK(waitpid(pid, &amp;status, 0) != -1); CONDITION(WEXITSTATUS(status) != 0 || WCOREDUMP(status));}#define invoke_test(res) test(res, #res, f##res)#define fun(name) void f##name(__rlimit_resource_t res, struct rlimit *lim)fun(RLIMIT_AS) { lim-&gt;rlim_cur = 1024; CHECK(setrlimit(res, lim) != -1); CHECK(sbrk(1024 + 1) != (void *) -1);}fun(RLIMIT_CORE) { pid_t pid; CHECK((pid = fork()) != -1); if(!pid) { CONDITION(lim-&gt;rlim_cur != 0); lim-&gt;rlim_cur = 1; CHECK(setrlimit(res, lim) != -1); CHECK(sbrk(lim-&gt;rlim_cur + 1) != (void *) -1); abort(); } int status; CHECK(waitpid(pid, &amp;status, 0) != -1); CONDITION(WCOREDUMP(status)); // 超过limit，则不产生core dump文件}void signal_RLIMIT_CPU(int sig) { printf(&quot;pid=%ld, received signal:%d(%s)\\n&quot;, (long)getpid(), sig, strsignal(sig)); exit(1);}fun(RLIMIT_CPU) { CHECK(signal(SIGXCPU, signal_RLIMIT_CPU) != SIG_ERR); lim-&gt;rlim_cur = 1; CHECK(setrlimit(res, lim) != -1); for(;;);}fun(RLIMIT_DATA) { lim-&gt;rlim_cur = 1; CHECK(setrlimit(res, lim) != -1); CHECK(sbrk(lim-&gt;rlim_cur + 1) != (void *)-1);}fun(RLIMIT_FSIZE) { lim-&gt;rlim_cur = 1; char buf[1024]; CHECK(setrlimit(res, lim) != -1); char *file = tmpnam(NULL); CHECK(file != NULL); printf(&quot;create tmp file:%s\\n&quot;, file); int fd = open(file, O_CREAT|O_RDWR, 0611); CHECK(fd != -1); ssize_t writesize; if((writesize = write(fd, buf, 1024)) != 1024) { CHECK(writesize != -1); printf(&quot;incomplete write, write %lu byte\\n&quot;, writesize); } else { printf(&quot;write, write %lu byte\\n&quot;, writesize); } CHECK(close(fd) != -1); CHECK(unlink(file) != -1); CONDITION(writesize == 1024);}fun(RLIMIT_MEMLOCK);fun(RLIMIT_MSGQUEUE);fun(RLIMIT_NICE) {// CHECK(setpriority(PRIO_PROCESS, 0, 0) != -1); CHECK(setuid(10087) != -1); //切换到非root用户 lim-&gt;rlim_cur = 5; lim-&gt;rlim_max = 5; CHECK(setrlimit(res, lim) != -1); errno = 0; int prio = getpriority(PRIO_PROCESS, 0); CHECK(!(prio == -1 &amp;&amp; errno != 0)); printf(&quot;current prio = %d\\n&quot;, prio); CHECK(setpriority(PRIO_PROCESS, 0, 14) != -1); CHECK(setpriority(PRIO_PROCESS, 0, 16) != -1);}fun(RLIMIT_NOFILE) { lim-&gt;rlim_cur = 0; lim-&gt;rlim_max = 0; CHECK(setrlimit(res, lim) != -1); char *file = tmpnam(NULL); CHECK(file != NULL); printf(&quot;create tmp file:%s\\n&quot;, file); int fd = open(file, O_CREAT|O_RDWR, 0611); CHECK(fd != -1); CHECK(close(fd) != -1);}fun(RLIMIT_NPROC) { CHECK(setuid(10087) != -1); //切换到非root用户 lim-&gt;rlim_cur = 0; lim-&gt;rlim_max = 0; CHECK(setrlimit(res, lim) != -1); CHECK(fork() != -1);}fun(RLIMIT_RSS);fun(RLIMIT_RTPRIO) { CHECK(setuid(0) != -1); lim-&gt;rlim_cur = 50; lim-&gt;rlim_max = 50; CHECK(setrlimit(res, lim) != -1); CHECK(setuid(10087) != -1); CHECK(sched_setscheduler(0, SCHED_FIFO, &amp;(struct sched_param) { .sched_priority=50 }) != -1); CHECK(sched_setscheduler(0, SCHED_FIFO, &amp;(struct sched_param) { .sched_priority=51 }) != -1);}fun(RLIMIT_RTTIME) { CHECK(sched_setscheduler(0, SCHED_FIFO, &amp;(struct sched_param) { .sched_priority=sched_get_priority_max(SCHED_FIFO) }) != -1); CHECK(signal(SIGXCPU, signal_RLIMIT_CPU) != SIG_ERR); lim-&gt;rlim_cur = 1; CHECK(setrlimit(res, lim) != -1); for(;;);}fun(RLIMIT_SIGPENDING) { lim-&gt;rlim_cur = 1; char buf[1024] = {0}; sprintf(buf, &quot;/proc/%d/status&quot;, getpid()); if(!fork()) { execlp(&quot;cat&quot;, &quot;cat&quot;, buf, NULL); } wait(NULL); CHECK(setrlimit(res, lim) != -1); sigset_t set; CHECK(sigemptyset(&amp;set) != -1); CHECK(sigaddset(&amp;set, SIGRTMAX-2) != -1); CHECK(sigaddset(&amp;set, SIGRTMAX-1) != -1); CHECK(sigprocmask(SIG_BLOCK, &amp;set, NULL) != -1);// CHECK(sigqueue(getpid(), SIGUSR1, (union sigval){.sival_int=0}) != -1);// CHECK(sigqueue(getpid(), SIGUSR2, (union sigval){.sival_int=0}) != -1); // 不是说标准信号和实时信号都行吗？ CHECK(sigqueue(getpid(), SIGRTMAX - 1, (union sigval){.sival_int=0}) != -1); CHECK(sigqueue(getpid(), SIGRTMAX - 2, (union sigval){.sival_int=0}) != -1);// CHECK(sigqueue(getpid(), SIGUSR2, (union sigval){.sival_int=0}) != -1); // 不是说标准信号和实时信号都行吗？ if(!fork()) { execlp(&quot;cat&quot;, &quot;cat&quot;, buf, NULL); } wait(NULL);}void handlerRLIMIT_STACK(int sig) { printf(&quot;pid:%ld received a signal:%d(%s)\\n&quot;, (long) getpid(), sig, strsignal(sig)); exit(1);}void stackoverflow() { char buf[MINSIGSTKSZ*MINSIGSTKSZ] = {0}; // 反正这里要足够大 // 参考这里: https://stackoverflow.com/questions/4118016/set-stack-size-with-setrlimit-and-provoke-a-stack-overflow-segfault buf[MINSIGSTKSZ+1] = 0;}fun(RLIMIT_STACK) {// CHECK(signal(SIGSEGV, handlerRLIMIT_STACK) != SIG_ERR); CHECK(sigaltstack(&amp;(stack_t) { .ss_flags=0, .ss_size=SIGSTKSZ, .ss_sp=malloc(SIGSTKSZ) }, NULL) != -1); sigset_t sigset; CHECK(sigemptyset(&amp;sigset) != -1); CHECK(sigaction(SIGSEGV, &amp;(struct sigaction) { .sa_flags = SA_ONSTACK, // sigaltstack要搭配这个flag .sa_mask = sigset, .sa_handler=handlerRLIMIT_STACK },NULL) != -1); lim-&gt;rlim_cur = MINSIGSTKSZ;// lim-&gt;rlim_max = 0; CHECK(setrlimit(res, lim) != -1); stackoverflow();}int main(int argc, char ** argv) { invoke_test(RLIMIT_AS); invoke_test(RLIMIT_CORE); invoke_test(RLIMIT_CPU); invoke_test(RLIMIT_DATA); invoke_test(RLIMIT_FSIZE);// invoke_test(RLIMIT_MEMLOCK); //还没学// invoke_test(RLIMIT_MSGQUEUE); //还没学// invoke_test(RLIMIT_NICE); invoke_test(RLIMIT_NOFILE); invoke_test(RLIMIT_NPROC);// invoke_test(RLIMIT_RSS); //linux没作用 invoke_test(RLIMIT_RTPRIO); invoke_test(RLIMIT_RTTIME); invoke_test(RLIMIT_SIGPENDING); invoke_test(RLIMIT_STACK);}","link":"/home/2023/07/18/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha36/"},{"title":"cha33.线程：更多细节","text":"33.1编写程序以便证明:作为函数sigpending()的返回值，同一个进程中的的不同线程可以拥有不同的 pending信号。可以使用函数pthread_kill(分别发送不同的信号给阻塞这些信号的两个不同的线程,接着调用sigpending()方法并显示这些pending信号的信息。(可能会发现程序清单20-4中函数的作用。) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//// Created by root on 7/2/23.//#define _GNU_SOURCE#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#define CHECK(x) do { if(!(x)) { fprintf(stderr, &quot;ERROR: %s\\nfile=%s, line=%d\\n&quot;, strerror(errno), __FILE__, __LINE__); exit(1); } } while(0)#define THREAD_CNT 5pthread_mutex_t sig_mutex;pthread_cond_t sig_cond;int thread_ready_count;void handler(int sig, siginfo_t *info, void *context) { printf(&quot;recv sig = %d: %s, from = %d\\n&quot;, sig, strsignal(sig), info-&gt;si_value.sival_int);}pthread_t tid2pthread[THREAD_CNT];int tid2sig(int tid) { return SIGRTMAX - 1 - tid;}void *fun_thread(void *arg) { int tid = *(int *)arg; free(arg); sigset_t set; CHECK(sigemptyset(&amp;set) == 0); CHECK(sigaddset(&amp;set, tid2sig(tid)) == 0); CHECK(pthread_sigmask(SIG_SETMASK, &amp;set, NULL) == 0); CHECK(sigaction(tid2sig(tid), &amp;(struct sigaction) { .sa_sigaction =handler, .sa_flags = SA_SIGINFO, .sa_mask = 0 }, NULL) == 0); printf(&quot;Thread-%d, sigaction %d\\n&quot;, tid, tid2sig(tid)); CHECK(pthread_mutex_lock(&amp;sig_mutex) == 0); thread_ready_count++; tid2pthread[tid] = pthread_self(); CHECK(pthread_mutex_unlock(&amp;sig_mutex) == 0); CHECK(pthread_cond_broadcast(&amp;sig_cond) == 0); CHECK(pthread_mutex_lock(&amp;sig_mutex) == 0); while(thread_ready_count &lt; THREAD_CNT){ CHECK(pthread_cond_wait(&amp;sig_cond, &amp;sig_mutex) == 0); } CHECK(pthread_mutex_unlock(&amp;sig_mutex) == 0); int sig = tid2sig((tid + 1) % THREAD_CNT); printf(&quot;Thread-%d send %d(%s) to %d\\n&quot;, tid, sig, strsignal(sig), (tid + 1) % THREAD_CNT); CHECK(pthread_sigqueue(tid2pthread[(tid + 1) % THREAD_CNT], sig, (union sigval) { .sival_int=tid }) == 0); do { printf(&quot;Thread-%d sig not pending %d\\n&quot;, tid, tid2sig(tid)); sleep(1); CHECK(sigemptyset(&amp;set) == 0); CHECK(sigpending(&amp;set) == 0); } while(sigismember(&amp;set, tid2sig(tid)) == 0); printf(&quot;Thread-%d sig pending %d\\n&quot;, tid, tid2sig(tid)); CHECK(sigemptyset(&amp;set) == 0); CHECK(pthread_sigmask(SIG_SETMASK, &amp;set, NULL) == 0); CHECK(sigpending(&amp;set) == 0); sig = -1; while(sig != tid2sig(tid)) CHECK(sigwait(&amp;set, &amp;sig) == 0); printf(&quot;Thread-%d exit\\n&quot;, tid); return NULL;}int main(int argc, char *argv[]) { CHECK(pthread_mutex_init(&amp;sig_mutex, NULL) == 0); CHECK(pthread_cond_init(&amp;sig_cond, NULL) == 0); thread_ready_count = 0; for(int i = 0; i &lt; THREAD_CNT; i++) { pthread_t thread; int *data = malloc(sizeof(int)); *data = i; CHECK(pthread_create(&amp;thread, NULL, fun_thread, data) == 0); } pthread_exit(NULL);} 33.2假设一个线程使用fork()创建了一个子进程。当子进程终止时，可以保证由此产生的SIGCHLD信号一定会发送给调用fork()的线程吗(可以用进程中的其他线程做对比)? 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//// Created by root on 7/2/23.//#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#define CHECK(x) do { if(!(x)) { fprintf(stderr, &quot;ERROR: %s\\nfile=%s, line=%d\\n&quot;, strerror(errno), __FILE__, __LINE__); exit(1); } } while(0)sigset_t set;void handler(int sig, siginfo_t *info, void *context) { printf(&quot;recv sig = %d: %s, my tid is %ld\\n&quot;, sig, strsignal(sig), pthread_self());}void *fn(void *arg) { CHECK(sigaction(SIGCHLD, &amp;(struct sigaction) { .sa_mask = 0, .sa_flags = SA_SIGINFO, .sa_sigaction=handler }, NULL) == 0); if(*(int *)arg) { printf(&quot;I am %ld, I fork\\n&quot;, pthread_self()); if(!fork()) { exit(0); }// wait(NULL); } else { printf(&quot;I am %ld, I sleep\\n&quot;, pthread_self()); sleep(10); } free(arg); return NULL;}int main() { CHECK(sigemptyset(&amp;set) == 0); CHECK(sigaddset(&amp;set, SIGCHLD) == 0); CHECK(sigaction(SIGCHLD, &amp;(struct sigaction) { .sa_mask = 0, .sa_flags = SA_SIGINFO, .sa_sigaction=handler }, NULL) == 0); pthread_t tid; int ok = 0; CHECK(pthread_create(&amp;tid, NULL, fn, memcpy(malloc(sizeof(int)), &amp;ok, sizeof(int))) == 0); ok = 1; CHECK(pthread_create(&amp;tid, NULL, fn, memcpy(malloc(sizeof(int)), &amp;ok, sizeof(int))) == 0); pthread_exit(NULL);} 不一定相同，前面书中正文也说过了","link":"/home/2023/07/01/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha33/"},{"title":"cha26.监控子进程","text":"孤儿与僵尸 孤儿： 子进程结束前父进程未wait结束的进程。其父进程会变成1由init接管进行wait 僵尸： 父进程未结束，子进程已经结束，且父进程未执行wait。系统保留僵尸的进程表记录，以备未来父进程需要wait获取其结束状态 无法被kill，只能kill其父进程 1编写一程序以验证当一子进程的父进程终止时，调用getppid()将返回1（进程 init的进程ID)。 无聊，不弄 2假设存在3个相互关联的进程（祖父、父及子进程)，祖父进程没有在父进程退出之后立即执行wait()，所以父进程变成僵尸进程。那么请指出孙进程何时被init进程收养（即孙进程调用getppid)将返回1)，是在父进程终止后，还是祖父进程调用wait()后?请编写程序验证结果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;sys/wait.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#define CHECK(x) do {if(!(x)) {fprintf(stderr, &quot;CHECK: %s\\n&quot;, strerror(errno));} } while(0)void son(pid_t child) { printf(&quot;son: pid = %d, ppid = %d\\n&quot;, getpid(), getppid()); kill(getppid(), SIGUSR2); sleep(1); for(int i = 0; i &lt; 10; i++) { printf(&quot;son: pid = %d, ppid = %d\\n&quot;, getpid(), getppid()); sleep(1); }}void father(pid_t child) { printf(&quot;father: pid = %d, ppid = %d\\n&quot;, getpid(), getppid()); sleep(100);}void grandpa(pid_t child) { printf(&quot;grandpa: pid = %d, ppid = %d\\n&quot;, getpid(), getppid()); sleep(100);}void son_exit(int sig) { if(sig == SIGCHLD) { printf(&quot;gandpa: SIGCHLD\\n&quot;); sleep(5); CHECK(wait(NULL) &gt; 0); printf(&quot;gandpa: wait father\\n&quot;); sleep(100); }}void killme(int sig) { if(sig == SIGUSR2) { printf(&quot;father: SIGUSR2, exit\\n&quot;); _exit(0); }}int main() { sigaction(SIGCHLD, &amp;(struct sigaction){ .sa_handler=son_exit }, NULL); sigaction(SIGUSR2, &amp;(struct sigaction) { .sa_handler=killme }, NULL); pid_t pid = fork(); CHECK(pid &gt;= 0); if(!pid) { pid_t pid1 = fork(); CHECK(pid1 &gt;= 0); if(!pid1) { son(pid1); } else { father(pid1); } } else { grandpa(pid); } return 0;} 输出分析12345678910111213141516grandpa: pid = 15308, ppid = 14448father: pid = 15309, ppid = 15308son: pid = 15310, ppid = 15309father: SIGUSR2, exitgandpa: SIGCHLDson: pid = 15310, ppid = 38son: pid = 15310, ppid = 38son: pid = 15310, ppid = 38son: pid = 15310, ppid = 38gandpa: wait fatherson: pid = 15310, ppid = 38son: pid = 15310, ppid = 38son: pid = 15310, ppid = 38son: pid = 15310, ppid = 38son: pid = 15310, ppid = 38son: pid = 15310, ppid = 38 father退出后缺少被接管了，但是不是init 查了资料后发现是使用伪终端的原因 26.3使用waitid()替换程序清单26-3 (child_status.c）中的 waitpid()。需要将对函数printWaitStatus()的调用替换为打印 waitid()所返回siginfo_t结构中相关字段的代码。 无聊，不搞 26.4程序清单26-4(make_zombie.c）调用了sleep()，以便允许子进程在父进程执行函数system()前得到机会去运行并终止。这一方法理论上存在产生竞争条件的可能。修改此程序，使用信号来同步父子进程以消除该竞争条件。 fork前设置处理器函数，该函数longjmp到子进程执行位置fork后父进程还原处理器函数，发送信号 就酱","link":"/home/2023/06/19/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha26/"},{"title":"cha34.进程组、会话和作业控制","text":"读书笔记34.1假设一个父进程执行了下面的步骤。这个应用程序设计可能会碰到什么问题?考虑 shell 管道。如何避免此类问题的发生? 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/wait.h&gt;void handler(int sig){ printf(&quot;%d, received %d(%s)\\n&quot;, getpid(), sig, strsignal(sig));}int main() { sigset_t set; sigemptyset(&amp;set); sigaddset(&amp;set, SIGUSR1); signal(SIGUSR1, handler); for(int i = 0; i &lt; 10; i++) { pid_t pid; if((pid = fork()) == 0) { pause(); return 0; } else { printf(&quot;child-%d: %d\\n&quot;, i, pid); } } signal(SIGUSR1, SIG_IGN); killpg(getpgrp(), SIGUSR1); waitpid(-1, NULL, 0);} 假设不发送SIGUSER时 当不使管道时，可以看到有小于等于10个子进程显示收到SIGUSER1 如果使用管道，会发现child-%d: %d被重复输出了多次，这是由于stdout被重定向后变成了全缓冲，fork的子进程退出后fflush()时会将fork前未flush的数据打印出来。 假设执行该命令./practice34.1 | cat，输出会是User defined signal 1，即cat与程序同属一个进程组，cat也会收到该信号，导致无法正常执行（非预期内） 避免记录每个子进程的pid，依次给每个pid发送信号，避免使用killpg或kill时使用负值pid 34.2编写一个程序来验证父进程能够在子进程执行exec0之前修改子进程的进程组ID但无法在执行exec0之后修改子进程的进程组ID。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//// Created by root on 7/10/23.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/wait.h&gt;#include &lt;errno.h&gt;pid_t pid;void parent_handler(int sig) { printf(&quot;pid = %d, recv sig-%d(%s), setpgid pid=%d, pgid=%d\\n&quot;, getpid(), sig, strsignal(sig), pid, getpgid(getpid())); if(setpgid(pid, getpgid(getpid())) == -1) { printf(&quot;setpgid fail, %d， err:%s\\n&quot;, __LINE__, strerror(errno)); } printf(&quot;newpgid pid=%d, pgid=%d\\n&quot;, pid, getpgid(pid)); kill(pid, SIGUSR1);}int main(int argc, char **argv) { if(argc == 1) { printf(&quot;before fork, pgid=%d\\n&quot;, getpgid(getpid())); if((pid = fork()) == 0) { printf(&quot;before exec, pid = %d, gid = %d\\n&quot;, getpid(), getpgrp()); fflush(stdout); int len = snprintf(NULL, 0, &quot;%d&quot;, getppid()); char *spid = malloc(len + 1); sprintf(spid, &quot;%d&quot;, getppid()); if(spid) { fflush(stdout); if(execl(argv[0], argv[0], spid) == -1) { printf(&quot;execl error!\\n&quot;); } } else { printf(&quot;error: malloc, len = %d\\n&quot;, len); } } else { // 父进程先执行 signal(SIGUSR1, parent_handler); setpgid(pid, 0);// kill(pid, SIGUSR1); wait(NULL); } } else { printf(&quot;exec pid = %d, gid = %d\\n&quot;, getpid(), getpgrp()); kill(atoi(argv[1]), SIGUSR1); pause(); }} 可以看到，在parent_handler中，对子进程修改pgid后再次查询其pgid，并没有改变报错为Permission denied 34.3编写一个程序来验证在进程组首进程中调用setsid会失败 123456789#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;int main() { if(setsid() == -1) { fprintf(stderr, &quot;error: %s\\n&quot;, strerror(errno)); }} 结果1error: Operation not permitted 34.4修改程序清单34-4 (disc_SIGHUP.c)来验证当控制进程在收到 SIGHUP 信号而不终止时，内核不会向前台进程组中的成员发送SIGHUP信号。 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#define CHECK(x) do { if(!(x)) { fprintf(stderr, &quot;CHECK: %s, %s:%d\\n&quot;, strerror(errno), __FILE__, __LINE__); } } while(0)void handler(int sig) { printf(&quot;PID=%ld received signal: %d(%s)\\n&quot;, (long) getpid(), sig, strsignal(sig));}int main(int argc, char **argv) { setbuf(stdout, NULL); if(argc &lt; 2) { printf(&quot;Usage: exec %s [enable-sighup|disable-sighup] [d|s]...\\n&quot;, argv[0]); } printf(&quot;PID=%ld, PGID=%ld (parent)\\n&quot;, (long)getpid(), (long) getpgrp()); if(argv[1][0] == 'd') { CHECK(signal(SIGHUP, handler) != SIG_ERR); } for(int i = 2; i &lt; argc; i++) { pid_t pid; CHECK((pid = fork()) != -1); if(!pid) { if(argv[i][0] == 'd') { CHECK(setpgid(0, 0) != -1); } CHECK(signal(SIGHUP, handler) != SIG_ERR); break; } } printf(&quot;PID=%ld, PGID=%ld\\n&quot;, (long)getpid(), (long) getpgrp()); alarm(60); for(;;) pause(); getpgid(getpid());} 小结嗯，确实是这样 复习知识 alarm到期发送SIGALARM，默认行为是结束进程 getpgrp是获取当前进程的进程组id，getpgid是获得参数pid指定进程的进程组id signal函数失败时的返回值是SIG_ERR 知识补漏 SIGTSTP和SIGSTOP 两个信号的作用都是让进程暂停，区别是SIGSTOP不可以捕获。 wait和waitpid wait当进程停止时返回 waitpid可通过options参数等待停止的子进程 waitflags.h中的部分宏定义 12345678910111213141516/* Bits in the third argument to `waitpid'. */#define WNOHANG 1 /* Don't block waiting. */#define WUNTRACED 2 /* Report status of stopped children. *//* Bits in the fourth argument to `waitid'. */#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8# define WSTOPPED 2 /* Report stopped child (same as WUNTRACED). */# define WEXITED 4 /* Report dead child. */# define WCONTINUED 8 /* Report continued child. */# define WNOWAIT 0x01000000 /* Don't reap, just poll status. */#endif#define __WNOTHREAD 0x20000000 /* Don't wait on children of other threads in this group */#define __WALL 0x40000000 /* Wait for any child. */#define __WCLONE 0x80000000 /* Wait for cloned process. */ 等待暂停的进程 123456789101112131415161718192021222324#include &lt;wait.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#define CHECK(x) do { if(!(x)) { fprintf(stderr, &quot;CHECK: %s, %s:%d\\n&quot;, strerror(errno), __FILE__, __LINE__); } } while(0)int main() { pid_t pid; CHECK((pid = fork()) != -1); if(!pid) {// raise(SIGABRT); raise(SIGSTOP); } else { int status;// CHECK(wait(&amp;status) != (pid_t) -1); CHECK(waitpid(pid, &amp;status, WUNTRACED) != (pid_t) -1); int term_sig = WTERMSIG(status); printf(&quot;PID=%d terminated, terminate signal=%d(%s)\\n&quot;, pid, term_sig, strsignal(term_sig)); kill(pid, SIGKILL); }} 34.5假设将程序清单34-6中的信号处理器中解除阻塞SIGTSTP信号的代码移动到处理器的开头部分。这样做会导致何种竞争条件? 可能会导致同时执行多个tstphandler？ 34.6编写一个程序来验证当位于孤儿进程组中的一个进程试图从控制终端调用read时会得到EIO的错误. 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#define CHECK(file, x) do { if(!(x)) { fprintf(file, &quot;CHECK: error:%d(%s), %s:%d\\n&quot;, errno, strerror(errno), __FILE__, __LINE__); } } while(0)int main() { int pid = fork(); CHECK(stdout, pid != -1); if(!pid) { CHECK(stdout, setpgid(0, 0) == 0); char arr[4096] = {0}; CHECK(stdout, read(STDIN_FILENO, arr, sizeof(arr)) &gt; 0); fprintf(stdout, &quot;EIO=%d\\n&quot;, EIO); }} 嗯，确实是这样 12CHECK: error:5(Input/output error), /root/linux/cha34/practice34.6.c:20EIO=5 34.7编写一个程序来验证当SIGTTIN、SIGTTOU或SIGTSTP三个信号中的一个信号被发送给孤儿进程组中的一个成员时，如果这个信号会停止该进程(即处理方式为SIG_DFL)，那么这个信号就会被丢弃(即不产生任何效果)，但如果该信号存在处理器，就会发送该信号。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//// Created by root on 7/13/23.//#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;wait.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/shm.h&gt;#define CHECK(x) do { if(!(x)) { fprintf(stderr, &quot;CHECK: error:%d(%s), %s:%d\\n&quot;, errno, strerror(errno), __FILE__, __LINE__); } } while(0)void handler(int sig) { int saveerrno = errno; printf(&quot;pid=%d received signal=%d(%s)\\n&quot;, getpid(), sig, strsignal(sig)); CHECK(signal(sig, SIG_DFL) != SIG_ERR); sigset_t set, old; CHECK(sigemptyset(&amp;set) != -1); CHECK(sigaddset(&amp;set, sig) != -1); CHECK(raise(sig) != -1); CHECK(sigprocmask(SIG_UNBLOCK, &amp;set, &amp;old) != -1); printf(&quot;continue\\n&quot;); CHECK(sigprocmask(SIG_SETMASK, &amp;old, NULL) != -1); CHECK(signal(sig, handler) != SIG_ERR); errno = saveerrno;}#define SHM_KEY (key_t)5341int shmid;void ps(char *argpid){ pid_t pspid; if((pspid = fork()) == 0) { CHECK(execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;-f&quot;, argpid, NULL) != -1); _exit(0); } CHECK(pspid != (pid_t)-1); CHECK(waitpid(pspid, NULL, 0) != (pid_t)-1);}int main(int argc, char **argv) { CHECK(argc == 3); CHECK(argv[1][0] == 'e' || argv[1][0] == 'd'); CHECK(argv[2][0] &gt;= '0' || argv[2][0] &lt;= '2'); int sigs[3] = { SIGTTIN, SIGTTOU, SIGTSTP }; if(argv[1][0] == 'e') { CHECK(signal(sigs[argv[2][0] - '0'], handler) != SIG_ERR); } CHECK((shmid = shmget(SHM_KEY, sizeof(pid_t), 0666|IPC_CREAT|IPC_EXCL)) != -1); int pid = fork(); CHECK(pid != -1); pid_t *grandson = shmat(shmid, (void*) 0, 0); CHECK(grandson != (void *)-1); if(!pid) { int pid1 = fork(); CHECK(pid1 != -1); if(!pid1) { CHECK(setpgid(0, 0) != -1); alarm(60); for(;;) {// printf(&quot;alive\\n&quot;);// sleep(1);// pause(); } } else { setpgid(pid1, 0); *grandson = pid1; CHECK(shmdt(grandson) != -1); _exit(0); } } else { CHECK(signal(sigs[argv[2][0] - '0'], SIG_IGN) != SIG_ERR); CHECK(wait(NULL) != (pid_t)-1); printf(&quot;grandson = %d\\n&quot;, *grandson); char argpid[128] = {0}; sprintf(argpid, &quot;%d&quot;, *grandson); ps(argpid); kill(*grandson, sigs[argv[2][0] - '0']); ps(argpid); kill(*grandson, SIGCONT); ps(argpid); kill(*grandson, SIGKILL); ps(argpid); CHECK(shmdt(grandson) != -1); CHECK(shmctl(shmid, IPC_RMID, 0) != -1); }} 似乎还没成功，输出一直是R（运行中的后台进程组） 1234567891011/root/linux/practice34.7 e 0grandson = 31406UID PID PPID C STIME TTY STAT TIME CMDroot 31406 15886 0 16:54 pts/5 R 0:00 /root/linux/practice34.7 e 0pid=31406 received signal=21(Stopped (tty input))continueUID PID PPID C STIME TTY STAT TIME CMDroot 31406 15886 0 16:54 pts/5 R 0:00 /root/linux/practice34.7 e 0UID PID PPID C STIME TTY STAT TIME CMDroot 31406 15886 0 16:54 pts/5 R 0:00 /root/linux/practice34.7 e 0UID PID PPID C STIME TTY STAT TIME CMD 可能发现能调用handler就可以了吧？","link":"/home/2023/07/10/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha34/"},{"title":"cha37.DAEMON","text":"37.1编写一个使用syslog(3)的程序(与logger(1)类似)来将任意的消息写入到系统日志文件中。程序应该接收包含如记录到日志中的消息的命令行参数，同时应该允许指定消息的level。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//// Created by root on 7/24/23.//#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;limits.h&gt;#include &lt;sys/resource.h&gt;#include &lt;syslog.h&gt;volatile int init = 0;void restart(int sig) { if(init) { closelog(); printf(&quot;restart\\n&quot;); } openlog(&quot;meow&quot;, LOG_CONS|LOG_NDELAY|LOG_PID, LOG_USER); init = 1;}#define min(x, y) ((x) &lt; (y) ? (x) : (y))#define CHECK_WITH_RET(x, ret, format, ...) \\ do { \\ if(!(x)) { \\ fprintf(stderr, format, __VA_ARGS__); \\ ret \\ } \\ } while(0)#define CHECK(x) CHECK_WITH_RET(x, return -1;, &quot;%s:%d\\nerror: %s\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__,strerror(errno), #x)#define CONDITION(x) CHECK_WITH_RET(x, exit(2);, &quot;%s:%d\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__, #x)#define CHECKMAIN(x) CHECK_WITH_RET(x, exit(1);, &quot;%s:%d\\nerror: %s\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__,strerror(errno), #x)int makeDaemon() { pid_t pid; switch ((pid = fork())) { case -1: CHECK(0); case 0: break; default: printf(&quot;pid:%ld\\n&quot;, (long)pid); _exit(0); } CHECK(setsid() != -1); CHECK(umask(0) != -1); CHECK(chroot(&quot;/&quot;) != -1); int nullfd = open(&quot;/dev/null&quot;, O_RDWR); CHECK(nullfd != -1); CHECK(dup2(nullfd, STDIN_FILENO) != -1); CHECK(dup2(nullfd, STDOUT_FILENO) != -1); CHECK(dup2(nullfd, STDERR_FILENO) != -1); CHECK(close(nullfd) != -1); long fdmax = sysconf(_SC_OPEN_MAX); struct rlimit rlimit; CHECK(getrlimit(RLIMIT_NOFILE, &amp;rlimit) != -1); for(int fdi = 0; fdi &lt; min(fdmax, rlimit.rlim_cur); fdi++) { close(fdi); } CHECK(signal(SIGHUP, restart) != SIG_ERR); return 0;}struct logmesg { int level; char *str;};int main(int argc, char **argv) { printf(&quot;pid:%ld\\n&quot;, (long)getpid()); CHECKMAIN(makeDaemon() != -1); printf(&quot;pid:%ld\\n&quot;, (long)getpid()); restart(SIGHUP); CHECKMAIN(signal(SIGHUP, restart) != SIG_ERR); CONDITION(argc &gt;= 3); struct logmesg *data = malloc(sizeof(struct logmesg)); data-&gt;level = atoi(argv[1]); CONDITION(data-&gt;level &gt;= 0 &amp;&amp; data-&gt;level &lt;= 7); int strlen = 0; for(char **argvi = &amp;argv[2]; *argvi; argvi++) { strlen += snprintf(NULL, 0, &quot;%s %s&quot;, (char *)NULL, *argvi); } char *str = malloc(strlen + 1); for(char **argvi = &amp;argv[2]; *argvi; argvi++) { strlen += sprintf(str, &quot;%s %s&quot;,str, *argvi); } data-&gt;str = str+1; syslog(data-&gt;level, &quot;%s&quot;, data-&gt;str); printf(&quot;syslog: %s\\n&quot;, data-&gt;str); closelog();} 不及丢为什么，syslog.conf中配置的东西打印不出来 2023年8月23日更新 wsl下syslog确实不行，换一个环境，安装syslog后，重新允许，可以正常打印log 12Aug 23 16:13:34 localhost syslogd (GNU inetutils 1.9.4): restartAug 23 16:13:39 localhost meow[6279]: a b c","link":"/home/2023/08/01/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha37/"},{"title":"cha35.进程优先级和调度","text":"读书笔记nicenice值形象的说是一个进程的友好（nice）程度，越nice（nice值数值越大的）的进程越礼让，多个任务争用cpu的时候越礼让。（本书中高nice值表示nice值数值更低，更不nice 取值范围为(-20(不友好，高优先级)-19(友好，低优先级)) fork、exec时继承nice值 RLIMIT_NICE资源限制，特权进程最高可以将nice值提升到20-RLIMIT_NICE getpriority, setpriority获取/设置nice值，getpriority可能返回负值，调用前将errno置0，调用后结合errno判断是否失败 实时调度这里的实时调度和本科时的知识有些出入 为外部输入保证最大相应时间 高优先级进程互斥访问cpu 实时应用能精确控制其组件进程的调度顺序 linux内核2.617开始，支持的硬实时 几种调度策略 策略 特性 SCHED_RR 多级队列+时间片 SCHED_FIFO 多级队列+先入先出+没有时间片 SCHED_OTHER 非实时调度（默认） SCHED_BATCH SCHED_IDLE 感觉这本书有点老了，这篇文章看起来和本科的很接近 实时api API 作用 sched_setscheduler 设置pid的调度策略，见上一节 sched_setparam 将pid移动到指定优先级队列的队尾 sched_getscheduler 获取pid的调度策略 sched_getparam 获取pid的优先级 sched_yield 释放CPU sched_rr_get_interval 获取rr时间片 cpu亲和力多cpu系统中，为了减少因进程切换cpu导致的高速缓冲失效的情况，将进程绑定到一个/一组CPU中 API sched_getaffinity sched_setaffinity 35.1实现nice命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//// Created by root on 7/17/23.//#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;sys/resource.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt); exit(1);}#define ERROR(...) error(__FILE__, __LINE__, __VA_ARGS__)int main(int argc, char **argv) { int prio = getpriority(PRIO_PROCESS, 0); if(argc == 1) { printf(&quot;%d\\n&quot;, prio); return 0; } int cmd = 1; int n = 10; for(; cmd &lt; argc; cmd++) { if(argv[cmd][0] == '-') { if(argv[cmd][1] == '-') { if(argv[cmd][2] == 'a') { // adjustment char *end; if((end = strchr(argv[cmd], '=')) != NULL) { n = atoi(end+1); } } else if (argv[cmd][2] == 'h') { // help printf(&quot;Usage: nice [OPTION] [COMMAND [ARG]...]\\n&quot;); } else if (argv[cmd][2] == 'v') { // version printf(&quot;Written by MeowMeow Liu.\\n&quot;); } else { ERROR(&quot;未知的参数:%s&quot;, argv[cmd]); } } else { n = atoi(argv[cmd]+1); } } else { break; } } if(cmd &lt; argc) { if(setpriority(PRIO_PROCESS, 0, prio + n) == -1) ERROR(&quot;setpriority&quot;); if(execvp(argv[cmd], &amp;argv[cmd]) == -1) ERROR(&quot;execv&quot;); } else { ERROR(&quot;%s: a command must be given with an adjustment&quot;, argv[0]); } return 0;} 35.2编写一个与nice(1)命令类似的实时调度程序set-user-ID-root程序。这个程序的命令行界面如下所示: 1# ./rtsched policy priority command arg.. 在上面的命令中，policy 中r表示SCHED RR，f表示SCHED FIFO。基于在9.7.1节和38.3 节中描述的原因，这个程序在执行命令前应该丢弃自己的特权ID。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//// Created by root on 7/17/23.//#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;sys/resource.h&gt;#include &lt;sched.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt); exit(1);}#define ERROR(...) error(__FILE__, __LINE__, __VA_ARGS__)const char *pol2str(int policy) { return policy == SCHED_RR ? &quot;RR&quot; : policy == SCHED_FIFO ? &quot;FIFO\\n&quot; : #ifdef SCHED_BATCH policy == SCHED_BATCH ? &quot;BATCH&quot; : #endif #ifdef SCHED_IDLE policy == SCHED_IDLE ? &quot;IDLE&quot; : #endif policy == SCHED_OTHER ? &quot;OTHER&quot; : &quot;UNKNOWN&quot;;}int main(int argc, char **argv) { int argi = 1; if (argc &lt; 3){ printf(&quot;policy = %s\\n&quot;, pol2str(sched_getscheduler(getpid()))); printf(&quot;Usage: %s policy priority [--help] command...\\npolicy:\\n&quot; &quot;r\\tRR\\n&quot; &quot;f\\tFIFO\\n&quot;#ifdef SCHED_BATCH &quot;b\\tBATCH\\n&quot;#endif#ifdef SCHED_IDLE &quot;i\\tIDLE\\n&quot;#endif &quot;o\\tOTHER\\n&quot;, argv[0] ); return 0;} int policy = 0; switch (argv[argi][0]) { case 'r': policy = SCHED_RR; break; case 'f': policy = SCHED_FIFO; break;#ifdef SCHED_BATCH case 'b': policy = SCHED_BATCH; break;#endif#ifdef SCHED_IDLE case 'i': policy = SCHED_IDLE; break;#endif case 'o': policy = SCHED_OTHER; break; default: ERROR(&quot;unsupported policy:%s\\n&quot;, argv[argi]); break; } argi++; struct sched_param schedParam; schedParam.sched_priority = atoi(argv[argi]); argi++; if(argv[argi][0] == '-') { // --help -h ERROR(&quot;policy=%s, min=%d, max=%d&quot;, pol2str(policy), sched_get_priority_min(policy), sched_get_priority_max(policy)); argi++; } setuid(getuid()); if(sched_setscheduler(0, policy, &amp;schedParam) == -1) { ERROR(&quot;sched_setscheduler&quot;); } if(execvp(argv[argi], &amp;argv[argi]) == -1) { ERROR(&quot;execvp&quot;); } return 0;} 35.3编写一个运行于SCHED FIFO调度策略下的程序，然后创建一个子进程。在两个进程中都执行一个能导致进程最多消耗3秒CPU时间的函数。(这可以通过使用一个循环并在循环中不断使用 times()系统调用来确定累积消耗的CPU时间来完成。每当消耗了 1/4秒的CPU时间之后，函数应该打印出一条显示进程ID和迄今消耗的CPU时间的消息。每当消耗了1秒的CPU 时间之后，函数应该调用sched yield0来将CPU释放给其他进程另一种方法是进程使用sched setparam(提升对方的调度策略。)从程序的输出中应该能够看出两个进程交替消耗了1秒的CPU时间。(注意在35.3.2节中给出的有关防止失控实时进程占住CPU的建议。) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;sched.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;sys/times.h&gt;#include &lt;stdlib.h&gt;#include &lt;limits.h&gt;#include &lt;signal.h&gt;#include &lt;time.h&gt;#include &lt;sys/wait.h&gt;#define CHECK(x) do { if(!(x)) { fprintf(stderr, &quot;%s:%d\\nerror: %s\\n&quot;, __FILE__, __LINE__, strerror(errno)); } } while(0)void handler(int sig) { printf(&quot;PID:%d received signal:%d(%s)\\n&quot;, getpid(), sig, strsignal(sig)); exit(0);}int main() { CHECK(signal(SIGALRM, handler) != SIG_ERR); timer_t timerid; CHECK(sched_setscheduler(0, SCHED_FIFO, &amp;(struct sched_param){.sched_priority=sched_get_priority_max(SCHED_FIFO)}) != -1); long tck = sysconf (_SC_CLK_TCK) &gt;&gt; 2; pid_t pid; CHECK((pid = fork()) != -1); struct tms *cputm, *oldtm; cputm = malloc(sizeof(struct tms)); oldtm = malloc(sizeof(struct tms)); CHECK(times(oldtm) != (clock_t) -1); CHECK(timer_create(CLOCK_PROCESS_CPUTIME_ID, &amp;(struct sigevent) { .sigev_signo=SIGALRM, .sigev_notify=SIGEV_SIGNAL }, &amp;timerid) != -1); CHECK(timer_settime(timerid, 0, &amp;(struct itimerspec) { .it_interval = {.tv_nsec = 0,.tv_sec = 0}, .it_value = {.tv_sec = 13,.tv_nsec = 0} }, NULL) != -1); for(long i = 0; i &lt; 12;) { CHECK(times(cputm) != (clock_t) -1); long inc = ((cputm-&gt;tms_utime + cputm-&gt;tms_stime) - (oldtm-&gt;tms_utime + oldtm-&gt;tms_stime)) / tck; if(inc &gt;= 1) { struct tms *t = cputm; cputm = oldtm; oldtm = t; i += inc; fprintf(stderr, &quot;PID=%d, CPU=%.2lfs\\n&quot;, getpid(), i/4.0); } if(i % 4 == 0) { CHECK(sched_yield() != -1); } } CHECK(timer_settime(timerid, 0, &amp;(struct itimerspec) { .it_interval = {.tv_nsec = 0,.tv_sec = 0}, .it_value = {.tv_sec = 0,.tv_nsec = 0} }, NULL) != -1); CHECK(timer_delete(timerid) != -1); if(!pid) CHECK(wait(NULL) != -1); return 0;} 35.4如果两个进程在一个多处理器系统上使用管道来交换大量数据，那么两个进程运行在同一个CPU上的通信速度应该要快于两个进程运行在不同的CPU上其原因是当两个进程运行在同一个 CPU 上时能够快速地访问管道数据，因为管道数据可以保留在 CPU的高速缓冲器中。相反，当两个进程运行在不同的CPU上时将无法享受CPU高速缓冲器带来的优势。读者如果拥有多处理器系统可以编写一个使用sched setaffinity0强制将两个进程运行在同一个CPU上或运行在两个不同的CPU上的程序来演示这种效果。(第44 章描述了管道的使用。) 12345678910111213141516171819202122232425262728293031//// Created by root on 7/17/23.//#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sched.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#define CHECK(x,...) do { if(!(x)) { fprintf(stderr, &quot;%s:%d\\n&quot;, __FILE__, __LINE__); fprintf(stderr, __VA_ARGS__); exit(2); } } while(0)#define CHECKERR(x) do { if(!(x)) { fprintf(stderr, &quot;%s:%d\\nerror: %s\\n&quot;, __FILE__, __LINE__, strerror(errno)); exit(1); } } while(0)int main(int argc, char **argv) { char buffer[4096]; CHECK(argc == 2, &quot;Usage:%s cpuid\\n&quot;, argv[0]); int cpuid = atoi(argv[1]); cpu_set_t *set = malloc(sizeof(cpu_set_t)); CPU_ZERO(set); CPU_SET(cpuid, set); CHECKERR(sched_setaffinity(0, 1, set) != -1); ssize_t readsize; while((readsize = read(STDIN_FILENO, buffer, 4096)) &gt; 0) { CHECKERR(write(STDOUT_FILENO, buffer, readsize) == readsize); } CHECKERR(readsize == 0); free(set); return 0;} 测试12time `find / | ./practice35.4 1 | ./practice35.4 1`time `find / | ./practice35.4 2 | ./practice35.4 3` 经过几次测试，确实同一个cpu会快一点","link":"/home/2023/07/17/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha35/"},{"title":"cha38.编写安全的特权程序","text":"38.1用一个普通的非特权用户登录系统，创建一个可执行文件(或复制一个既有文件如/bin/sleep)，然后启用该文件的set-user-ID权限位(chmod u+s)。尝试修改这个文件(如cat &gt;&gt;fle)。当使用(ls -l)时文件的权限会发生什么情况呢?为何会发生这种情况? 现象：saved-user-id不见了原因：通过下面的例子，猜测open时会清除set-usr-id标志位 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//// Created by root on 8/1/23.//#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;static int exitcode = 0;#define ERR(str...) do { fprintf(stderr, &quot;%s:%d\\n%s:&quot;, __FILE__, __LINE__, strerror(errno)); fprintf(stderr, str); fprintf(stderr, &quot;\\n&quot;); exit(exitcode++); } while(0)int main(int argc, char **argv) { if(argc &lt; 3) { ERR(&quot;Usage: %s src dst [content..]&quot;, argv[0]); } char *file1 = argv[1]; char *file2 = argv[2]; int fd1 = open(file1, O_RDONLY); if(fd1 == -1) { ERR(&quot;file to open %s&quot;, file1); } struct stat stat1; if(fstat(fd1, &amp;stat1) == -1) { ERR(&quot;fstat(fd1, &amp;stat1)&quot;); } fprintf(stderr, &quot;F_GETFL:%o\\n&quot;, stat1.st_mode); int fd2 = open(file2, O_WRONLY | O_CREAT, stat1.st_mode); if(fd2 == -1) { ERR(&quot;fail to open %s&quot;, file2); } char buffer[4096] = {0}; ssize_t readsize = 0; while ((readsize = read(fd1, buffer, 4096)) &gt; 0) { ssize_t writesize = write(fd2, buffer, readsize); if(writesize != readsize) { ERR(&quot;fail to write %s&quot;, file2); } } if(readsize &lt; 0) { ERR(&quot;fail to read %s&quot;, file1); } for(int i = 3; i &lt; argc; i++) { size_t len = strlen(argv[i]); if(write(fd2, argv[i], len) != len) { ERR(&quot;fail to write %s&quot;, file2); } } return 0;} 38.2编写一个与 sudo(8)程序类似的 set-user-ID-root 程序。这个程序应该像下面这样接收命令行选项和参数: 1$ ./douser[ -u user ] program-file arg1 arg2 douser程序使用给定的参数执行 program-file，就像是被user 运行一样。(如果省略了-u选项，那么user 默认为root。)在执行 program-file之前，douser 应该请求 use的密码并将密码与标准密码文件进行比较(参见程序清单8-2)，接着将进程的用户和组ID设置为与该用户对应的值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//// Created by root on 8/2/23.//#include &lt;unistd.h&gt;#include &lt;pwd.h&gt;#include &lt;crypt.h&gt;#include &lt;shadow.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#define COND_RET(x, ret, msg...) \\ do { \\ errno = 0;\\ if(!(x)) { \\ if(errno == 0)fprintf(stderr, &quot;%s:%d\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__, #x); \\ else fprintf(stderr, &quot;%s:%d\\nerror: %s\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__,strerror(errno), #x); \\ fprintf(stderr, msg); \\ fprintf(stderr, &quot;\\n&quot;);\\ ret \\ } \\ } while(0)#define CHECK(x, msg...) COND_RET(x, return -1;, msg)#define CHECK_EXIT(x, msg...) COND_RET(x, exit(1);, msg)int main(int argc, char *argv[]) { char *filename = strrchr(argv[0], '/'); if(filename == NULL) { filename = argv[0]; } else { filename++; } if(!strcmp(filename, &quot;sudo&quot;)) { CHECK_EXIT(argc &gt;= 2, &quot;Usage: %s [-u user] exec [args...]&quot;, argv[0]); uid_t user = 0; char *username = &quot;root&quot;; char **exec = &amp;argv[1]; char *shadow = NULL; if (argv[1][0] == '-') { username = argv[2]; exec = &amp;argv[3]; } struct passwd *usrpwd; CHECK_EXIT((usrpwd = getpwnam(username)) != NULL, &quot;username:%s not found&quot;, username); user = usrpwd-&gt;pw_uid; shadow = usrpwd-&gt;pw_passwd; printf(&quot;shaowd=%s\\n&quot;, shadow); char *pass = getpass(&quot;password:&quot;); CHECK_EXIT(setuid(0) != -1, &quot;execute 'su; sudo chmod u+s %s' may fix this problem&quot;, argv[0]); if(!strcmp(shadow, &quot;x&quot;)) { struct spwd *shadowpwd; CHECK_EXIT((shadowpwd = getspnam(username)) != NULL, &quot;shadowpwd not found&quot;); shadow = shadowpwd-&gt;sp_pwdp; pass = crypt(pass, shadow); } printf(&quot;shaowd=%s, pass=%s\\n&quot;, shadow, pass); CHECK_EXIT(!strcmp(shadow, pass), &quot;password not match!&quot;); CHECK_EXIT(setuid(user) != -1, &quot;&quot;); CHECK_EXIT(execvp(exec[0], exec) != -1, &quot;&quot;); } else { struct passwd *pwd = NULL; uid_t uid = 0; if(argc &gt; 1) { char *end = NULL; uid = strtoul(argv[1], &amp;end, 10); CHECK_EXIT((end != NULL &amp;&amp; end != argv[1]), &quot;%s is not a number\\n&quot;, argv[1]); } else { uid = getuid(); } CHECK_EXIT((pwd = getpwuid(uid)) != NULL, &quot;uid:%u not found&quot;, uid); printf(&quot;uid:%u, user:%s\\n&quot;, pwd-&gt;pw_uid, pwd-&gt;pw_name); } return 0;} 太笨了，以前学的都忘了","link":"/home/2023/08/01/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha38/"},{"title":"cha4.文件IO:通用的I&#x2F;O模型","text":"实现tee tee命令是从标准输入中读取数据，直至文件结尾，随后将数据写入标准输出和命令行参数所指定的文件。(44.7节讨论FIFO时，会展示使用tee命令的一个例子。)请使用IO系统调用实现tee命令。默认情况下，若已存在与命令行参数指定文件同名的文件，tee命令会将其覆盖。如文件已存在，请实现-a命令行选项tee-a file在文件结尾处追加数据。(请参考附录B中对getopt)函数的描述来解析命令行选项。 预处理与函数声明12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include&lt;errno.h&gt; // 使用变量errno#define bool char#define false 0#define true 1#define strcmp(a,b) strcmp(a,b)==0// exit code#define UNSUPPORTED_ARG 1#define FILE_OPEN_FAIL 2#define STDOUT_WRITE_FAIL 3#define STDERR_WRITE_FAIL 4#define STDIN_READ_FAIL 5#define PARTIAL_WRITE_OCCURED 6#define FILE_CLOSE_FAIL 7#define FILE_WRITE_FAIL 8// 函数声明void printHelp();void printVersion();void writeErr(const char* str);void writeStdout(const char* str);void exitErr(const char * err, int exitcode);void release();// 常量#define MAX_FILE_COUNT 100#define READ_BUFFER_SIZE 100// 全局资源char **files = NULL;int *fds = NULL;int fileCount = 0; 不引用c的库函数，直接使用系统调用对文件进行读写，不引入stdio.h 工具函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void release() { // 关闭文件 for(int i = 0; i &lt; fileCount; i++) { errno = 0; int success = close(fds[i]); if(success == -1) { exitErr(strcat(&quot;can not close file: &quot;, files[i]), FILE_CLOSE_FAIL); } } free(files); free(fds);}void printHelp() { writeStdout(&quot;Usage: tee [-ai][--help][--version][files...]\\n&quot;);}void printVersion() { writeStdout(&quot;Written by Jingtian Meow\\n&quot;);}void exitErr(const char * err, int exitcode) { char *errstr = strerror(errno); writeErr(&quot;Error: &quot;); writeErr(errstr); writeErr(&quot;\\n&quot;); writeErr(err); writeErr(&quot;\\n&quot;); release(); exit(exitcode);}void writeStdout(const char* str) { errno = 0; int writeSize = write(STDOUT_FILENO, str, strlen(str)); if(writeSize == -1) { exitErr(&quot;fail to write to stdout\\n&quot;, STDOUT_WRITE_FAIL); }}void writeErr(const char* str) { errno = 0; int writeSize = write(STDERR_FILENO, str, strlen(str)); if(writeSize == -1) { release(); exit(STDERR_WRITE_FAIL); }} 实现错误打印，正常输出 对于错误，利用系统调用write，写入文件fdSTDERR_FILENO指代的标准错误流中 使用errno宏和strerror获取出错后的错误字符串，并打印其他提示信息 实现资源释放 资源分配1234// 保存文件名，打开文件的fd，文件总数files = (char **)malloc(MAX_FILE_COUNT*sizeof(char *));fds = (int *)malloc(MAX_FILE_COUNT*sizeof(int));fileCount = 0; 参数处理123456789101112131415161718192021222324252627282930313233int main(int argc, char **argv) { // 参数处理结果 bool append = false; bool ignore_int = false; // 处理参数 for(int i = 1; i &lt; argc; i++) { if(argv[i][0] == '-') { if(strcmp(argv[i], &quot;-a&quot;)) { append = true; } else if(strcmp(argv[i], &quot;-i&quot;) || strcmp(argv[i], &quot;--ignore-interrupts&quot;)) { ignore_int = true; } else if(strcmp(argv[i], &quot;-ai&quot;) || strcmp(argv[i], &quot;-ia&quot;) ) { append = true; ignore_int = true; } else if(strcmp(argv[i], &quot;--help&quot;)) { printHelp(); } else if(strcmp(argv[i], &quot;--version&quot;)) { printVersion(); } else { writeErr(&quot;Unsupported arg: &quot;); writeErr(argv[i]); writeErr(&quot;\\n&quot;); free(files); free(fds); exit(UNSUPPORTED_ARG); } } else { if(fileCount &lt; MAX_FILE_COUNT-1) files[fileCount++] = argv[i]; } } // other part of code} 支持参数-a, --help, --version，处理结果保存至append和ignore_int 对于不是以-开头的参数，认为其是文件名，存储到files 打开文件1234567// 打开文件，保存fdfor(int i = 0; i &lt; fileCount; i++) { fds[i] = open(files[i], O_CREAT | O_WRONLY | (append == true ? O_APPEND : O_TRUNC)); if(fds[i] == -1) { exitErr(strcat(&quot;Can not open file: &quot;, argv[i]), FILE_OPEN_FAIL); }} 将files中的文件打开，存储其fd 读取stdin，写入文件123456789101112131415161718192021222324// 读取stdinssize_t readSize = 0;char readBuffer[READ_BUFFER_SIZE+1]; // 需要手动添加'\\0'， 故+1while(1) { errno = 0; readSize = read(STDIN_FILENO, readBuffer, READ_BUFFER_SIZE); if(readSize == -1) { exitErr(&quot;read stdin fail&quot;, STDIN_READ_FAIL); } if(readSize == 0) { //EOF break; } readBuffer[readSize] = '\\0'; //防止写入脏数据，但是write时有readSize限制，所以没必要 for(int i = 0; i &lt; fileCount; i++) { errno = 0; ssize_t writeSize = write(fds[i], readBuffer, readSize); if(writeSize == -1) { //先判断-1 exitErr(strcat(&quot;file write failed on file: &quot;, files[i]), FILE_WRITE_FAIL); } if(writeSize &lt; readSize) { // 部分写 exitErr(strcat(&quot;Partial write occured on file: &quot;, files[i]), PARTIAL_WRITE_OCCURED); } }} 循环读取文件，利用系统调用read，若其返回0，则是遇到eof，跳出循环，若返回-1，则读取错误，异常退出 读取时注意该系统调用不认为读取的文件一定是文本文件，不会将其处理成字符串，即在末尾添加'\\0'，需要手动添加 从stdin读取后，一次写入待写入的文件中，并判断是否成功，是否发生部分写 收尾1release(); 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include&lt;errno.h&gt; // 使用变量errno#define bool char#define false 0#define true 1#define strcmp(a,b) strcmp(a,b)==0// exit code#define UNSUPPORTED_ARG 1#define FILE_OPEN_FAIL 2#define STDOUT_WRITE_FAIL 3#define STDERR_WRITE_FAIL 4#define STDIN_READ_FAIL 5#define PARTIAL_WRITE_OCCURED 6#define FILE_CLOSE_FAIL 7#define FILE_WRITE_FAIL 8// 函数声明void printHelp();void printVersion();void writeErr(const char* str);void writeStdout(const char* str);void exitErr(const char * err, int exitcode);void release();// 常量#define MAX_FILE_COUNT 100#define READ_BUFFER_SIZE 100char **files = NULL;int *fds = NULL;int fileCount = 0;int main(int argc, char **argv) { // 参数处理结果 bool append = false; bool ignore_int = false; // 保存文件名，打开文件的fd，文件总数 files = (char **)malloc(MAX_FILE_COUNT*sizeof(char *)); fds = (int *)malloc(MAX_FILE_COUNT*sizeof(int)); fileCount = 0; // 处理参数 for(int i = 1; i &lt; argc; i++) { if(argv[i][0] == '-') { if(strcmp(argv[i], &quot;-a&quot;)) { append = true; } else if(strcmp(argv[i], &quot;-i&quot;) || strcmp(argv[i], &quot;--ignore-interrupts&quot;)) { ignore_int = true; } else if(strcmp(argv[i], &quot;-ai&quot;) || strcmp(argv[i], &quot;-ia&quot;) ) { append = true; ignore_int = true; } else if(strcmp(argv[i], &quot;--help&quot;)) { printHelp(); } else if(strcmp(argv[i], &quot;--version&quot;)) { printVersion(); } else { writeErr(&quot;Unsupported arg: &quot;); writeErr(argv[i]); writeErr(&quot;\\n&quot;); free(files); free(fds); exit(UNSUPPORTED_ARG); } } else { if(fileCount &lt; MAX_FILE_COUNT-1) files[fileCount++] = argv[i]; } } // 打开文件，保存fd for(int i = 0; i &lt; fileCount; i++) { fds[i] = open(files[i], O_CREAT | O_WRONLY | (append == true ? O_APPEND : O_TRUNC)); if(fds[i] == -1) { exitErr(strcat(&quot;Can not open file: &quot;, argv[i]), FILE_OPEN_FAIL); } } // 读取stdin ssize_t readSize = 0; char readBuffer[READ_BUFFER_SIZE+1]; // 需要手动添加'\\0'， 故+1 while(1) { errno = 0; readSize = read(STDIN_FILENO, readBuffer, READ_BUFFER_SIZE); if(readSize == -1) { exitErr(&quot;read stdin fail&quot;, STDIN_READ_FAIL); } if(readSize == 0) { //EOF break; } readBuffer[readSize] = '\\0'; //防止写入脏数据，但是write时有readSize限制，所以没必要 for(int i = 0; i &lt; fileCount; i++) { errno = 0; ssize_t writeSize = write(fds[i], readBuffer, readSize); if(writeSize == -1) { //先判断-1 exitErr(strcat(&quot;file write failed on file: &quot;, files[i]), FILE_WRITE_FAIL); } if(writeSize &lt; readSize) { // 部分写 exitErr(strcat(&quot;Partial write occured on file: &quot;, files[i]), PARTIAL_WRITE_OCCURED); } } } release(); return 0;}void release() { // 关闭文件 for(int i = 0; i &lt; fileCount; i++) { errno = 0; int success = close(fds[i]); if(success == -1) { exitErr(strcat(&quot;can not close file: &quot;, files[i]), FILE_CLOSE_FAIL); } } free(files); free(fds);}void printHelp() { writeStdout(&quot;Usage: tee [-ai][--help][--version][files...]\\n&quot;);}void printVersion() { writeStdout(&quot;Written by Jingtian Meow\\n&quot;);}void exitErr(const char * err, int exitcode) { char *errstr = strerror(errno); writeErr(&quot;Error: &quot;); writeErr(errstr); writeErr(&quot;\\n&quot;); writeErr(err); writeErr(&quot;\\n&quot;); release(); exit(exitcode);}void writeStdout(const char* str) { errno = 0; int writeSize = write(STDOUT_FILENO, str, strlen(str)); if(writeSize == -1) { exitErr(&quot;fail to write to stdout\\n&quot;, STDOUT_WRITE_FAIL); }}void writeErr(const char* str) { errno = 0; int writeSize = write(STDERR_FILENO, str, strlen(str)); if(writeSize == -1) { release(); exit(STDERR_WRITE_FAIL); }} 实现cp 编写一个类似于cp命令的程序，当使用该程序复制一个包含空洞(连续的空字节)的普通文件时，要求目标文件的空洞与源文件保持一致。 这道题走了一点弯路，一直在探索如何保存文件空洞，不能和上面程序一样 由于空洞是程序在文件结尾处lseek了一段大于磁盘blocksize的距离后继续写入造成的，那么需要与其进行相同的lseek操作 如果读取出的内容全部为0，则记录全为0的长度，直到读取出不全为0的时候，先lseek，再写入 需要保证buffer的大小小于blocksize 创建文件空洞12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#define BLOCKSIZE 4096void writeContent(int fd, const char * content);int main(int argc, char **argv) { int fd = argc &gt;= 2 ? open(argv[1], O_WRONLY | O_CREAT) : STDOUT_FILENO; int fd1 = argc &gt;= 2 ? open(strcat(argv[1],&quot;.normal&quot;), O_WRONLY | O_CREAT) : STDOUT_FILENO; int holeNum = argc == 3 ? atoi(argv[2]) : 1; if(fd == -1) { return 1; } char *content; char blank[BLOCKSIZE*2] = {0}; memset(blank, ' ', sizeof(blank)); blank[BLOCKSIZE*2-1] = 0; for(int i = 0; i &lt; holeNum; i++) { content = &quot;Content before the file hole!!!!!\\n&quot;; writeContent(fd, content); writeContent(fd1, content); // make a hole lseek(fd, BLOCKSIZE*2, SEEK_CUR); writeContent(fd1, blank); content = &quot;Content after the file hole!!!!!\\n&quot;; writeContent(fd, content); writeContent(fd1, content); } if(close(fd) == -1) { exit(4); } if(close(fd1) == -1) { exit(4); } return 0;}void writeContent(int fd, const char * content) { size_t contentLen = strlen(content) + 1; int writeSize = write(fd, content, contentLen); if(writeSize == -1 || writeSize &lt; contentLen) { exit(2); }} 打开两个文件用作对比，fd通过lseek制造空洞，fd1写入相同大小的空格 使用命令stat比较生成的两个文件12root@tt-surfacepro6:~/linux# stat -c %b abc16 abc的块数是16 12root@tt-surfacepro6:~/linux# stat -c %b abc.normal 24 abc.normal的块数的24 预处理1234567891011121314151617181920212223242526272829303132333435363738#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include&lt;errno.h&gt;// #define debug#ifdef debug#include&lt;stdio.h&gt;#endif#define bool char#define false 0#define true 1#define strcmp(a,b) strcmp(a,b)==0// exit code#define UNSUPPORTED_ARG 1#define FILE_OPEN_FAIL 2#define STDOUT_WRITE_FAIL 3#define STDERR_WRITE_FAIL 4#define STDIN_READ_FAIL 5#define PARTIAL_WRITE_OCCURED 6#define FILE_CLOSE_FAIL 7#define FILE_WRITE_FAIL 8#define FILE_READ_FAIL 10#define INVALID_ARG 9// 函数声明void printHelp();void printVersion();void writeErr(const char* str);void writeStdout(const char* str);void fileErrClose(const char * filename, const char *err, int exitCode); #define READ_BUFF_SIZE 1023 工具函数123456789101112131415161718192021222324252627282930313233343536373839void fileErrClose(const char * filename, const char *err, int exitCode) { const char *errstr = strerror(errno); writeErr(&quot;Error: &quot;); writeErr(errstr); writeErr(&quot;\\n&quot;); writeErr(err); writeErr(filename); writeErr(&quot;\\n&quot;); exit(exitCode);}void printHelp() { writeStdout(&quot;Usage: cp [--help][--version][src dest]\\n&quot;);}void printVersion() { writeStdout(&quot;Written by Jingtian Meow\\n&quot;);}void writeStdout(const char* str) { errno = 0; int writeSize = write(STDOUT_FILENO, str, strlen(str)); if(writeSize == -1) { char *errstr = strerror(errno); writeErr(&quot;Error: &quot;); writeErr(errstr); writeErr(&quot;\\n&quot;); writeErr(&quot;fail to write to stdout\\n&quot;); exit(STDOUT_WRITE_FAIL); }}void writeErr(const char* str) { errno = 0; int writeSize = write(STDERR_FILENO, str, strlen(str)); if(writeSize == -1) { exit(STDERR_WRITE_FAIL); }} 参数处理1234567891011121314151617181920212223242526272829303132int main(int argc, char **argv) { // src文件，dest文件 char *filesrc = NULL, *filedest = NULL; // 处理参数 for(int i = 1; i &lt; argc; i++) { if(argv[i][0] == '-') { if(strcmp(argv[i], &quot;--help&quot;) || strcmp(argv[i], &quot;-h&quot;)) { printHelp(); } else if(strcmp(argv[i], &quot;--version&quot;) || strcmp(argv[i], &quot;-v&quot;)) { printHelp(); } else { writeErr(&quot;Unsupported arg: &quot;); writeErr(argv[i]); writeErr(&quot;\\n&quot;); exit(UNSUPPORTED_ARG); } } else { if(filesrc == NULL) { filesrc = argv[i]; } else if(filedest == NULL) { filedest = argv[i]; } else { writeErr(&quot;Invalid arguments: &quot;); writeErr(argv[i]); writeErr(&quot;\\n&quot;); exit(INVALID_ARG); } } } // other part ...} 不允许-r等操作，只允许对文件进行复制 文件打开12345678910errno = 0;int srcFd = open(filesrc, O_RDONLY);if(srcFd == -1) { fileErrClose(filesrc, &quot;Can not open file: &quot;, FILE_OPEN_FAIL);}errno = 0;int descFd = open(filedest, O_WRONLY | O_TRUNC | O_CREAT);if(descFd == -1) { fileErrClose(filedest, &quot;Can not open file: &quot;, FILE_OPEN_FAIL);} 分别打开输入和输出文件 文件读写12345678910111213141516171819202122232425262728293031323334353637char * readBuffer[READ_BUFF_SIZE+1];char allzero[READ_BUFF_SIZE+1] = {0};off_t offdest = 0;while(1) { errno = 0; ssize_t readSize = read(srcFd, readBuffer, READ_BUFF_SIZE); if(readSize == -1) { fileErrClose(filesrc, &quot;Can not read file: &quot;, FILE_READ_FAIL); } #ifdef debug printf(&quot;readsize = %ld\\n&quot;, readSize); #endif if(readSize == 0) { #ifdef debug writeStdout(&quot;Read finish\\n&quot;); #endif break; } readBuffer[readSize] = 0; offdest += readSize; if(memcmp(readBuffer, allzero, readSize) == 0) { #ifdef debug printf(&quot;hole, readsize = %ld, off = %ld\\n&quot;, readSize, offdest); #endif continue; } if(offdest &gt; 0)lseek(descFd, offdest, SEEK_CUR); offdest = 0; errno = 0; int writeSize = write(descFd, readBuffer, readSize); if(writeSize == -1) { fileErrClose(filedest, &quot;Write Fail on file: &quot;, FILE_WRITE_FAIL); } if(writeSize &lt; readSize) { fileErrClose(filedest, &quot;Partial write occured on file: &quot;, PARTIAL_WRITE_OCCURED); }} 当某次读出数据全为0时，则此处是空洞，记录空洞的累计长度 直到某次读取不全为0时，空洞结束，先lseek空洞长度，再写入 善后12345678910errno = 0;if(close(srcFd) == -1) { fileErrClose(filesrc, &quot;Can not close file: &quot;, FILE_CLOSE_FAIL);}errno = 0;if(close(descFd) == -1) { fileErrClose(filedest, &quot;Can not close file: &quot;, FILE_CLOSE_FAIL);}return 0; 复制文件12gcc cp.c -o cp &amp;&amp; ./cp abc abc.cpstat -c %b abc.cp 编译该cp工具，使用它复制带有空洞文件，可发现其成功复制，并输出块数也为16 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include&lt;errno.h&gt;// #define debug#ifdef debug#include&lt;stdio.h&gt;#endif#define bool char#define false 0#define true 1#define strcmp(a,b) strcmp(a,b)==0// exit code#define UNSUPPORTED_ARG 1#define FILE_OPEN_FAIL 2#define STDOUT_WRITE_FAIL 3#define STDERR_WRITE_FAIL 4#define STDIN_READ_FAIL 5#define PARTIAL_WRITE_OCCURED 6#define FILE_CLOSE_FAIL 7#define FILE_WRITE_FAIL 8#define FILE_READ_FAIL 10#define INVALID_ARG 9// 函数声明void printHelp();void printVersion();void writeErr(const char* str);void writeStdout(const char* str);void fileErrClose(const char * filename, const char *err, int exitCode); #define READ_BUFF_SIZE 1023int main(int argc, char **argv) { // src文件，dest文件 char *filesrc = NULL, *filedest = NULL; // 处理参数 for(int i = 1; i &lt; argc; i++) { if(argv[i][0] == '-') { if(strcmp(argv[i], &quot;--help&quot;) || strcmp(argv[i], &quot;-h&quot;)) { printHelp(); } else if(strcmp(argv[i], &quot;--version&quot;) || strcmp(argv[i], &quot;-v&quot;)) { printHelp(); } else { writeErr(&quot;Unsupported arg: &quot;); writeErr(argv[i]); writeErr(&quot;\\n&quot;); exit(UNSUPPORTED_ARG); } } else { if(filesrc == NULL) { filesrc = argv[i]; } else if(filedest == NULL) { filedest = argv[i]; } else { writeErr(&quot;Invalid arguments: &quot;); writeErr(argv[i]); writeErr(&quot;\\n&quot;); exit(INVALID_ARG); } } } errno = 0; int srcFd = open(filesrc, O_RDONLY); if(srcFd == -1) { fileErrClose(filesrc, &quot;Can not open file: &quot;, FILE_OPEN_FAIL); } errno = 0; int descFd = open(filedest, O_WRONLY | O_TRUNC | O_CREAT); if(descFd == -1) { fileErrClose(filedest, &quot;Can not open file: &quot;, FILE_OPEN_FAIL); } char * readBuffer[READ_BUFF_SIZE+1]; char allzero[READ_BUFF_SIZE+1] = {0}; off_t offdest = 0; while(1) { errno = 0; ssize_t readSize = read(srcFd, readBuffer, READ_BUFF_SIZE); if(readSize == -1) { fileErrClose(filesrc, &quot;Can not read file: &quot;, FILE_READ_FAIL); } #ifdef debug printf(&quot;readsize = %ld\\n&quot;, readSize); #endif if(readSize == 0) { #ifdef debug writeStdout(&quot;Read finish\\n&quot;); #endif break; } readBuffer[readSize] = 0; offdest += readSize; if(memcmp(readBuffer, allzero, readSize) == 0) { #ifdef debug printf(&quot;hole, readsize = %ld, off = %ld\\n&quot;, readSize, offdest); #endif continue; } if(offdest &gt; 0)lseek(descFd, offdest, SEEK_CUR); offdest = 0; errno = 0; int writeSize = write(descFd, readBuffer, readSize); if(writeSize == -1) { fileErrClose(filedest, &quot;Write Fail on file: &quot;, FILE_WRITE_FAIL); } if(writeSize &lt; readSize) { fileErrClose(filedest, &quot;Partial write occured on file: &quot;, PARTIAL_WRITE_OCCURED); } } errno = 0; if(close(srcFd) == -1) { fileErrClose(filesrc, &quot;Can not close file: &quot;, FILE_CLOSE_FAIL); } errno = 0; if(close(descFd) == -1) { fileErrClose(filedest, &quot;Can not close file: &quot;, FILE_CLOSE_FAIL); } return 0;}void fileErrClose(const char * filename, const char *err, int exitCode) { const char *errstr = strerror(errno); writeErr(&quot;Error: &quot;); writeErr(errstr); writeErr(&quot;\\n&quot;); writeErr(err); writeErr(filename); writeErr(&quot;\\n&quot;); exit(exitCode);}void printHelp() { writeStdout(&quot;Usage: cp [--help][--version][src dest]\\n&quot;);}void printVersion() { writeStdout(&quot;Written by Jingtian Meow\\n&quot;);}void writeStdout(const char* str) { errno = 0; int writeSize = write(STDOUT_FILENO, str, strlen(str)); if(writeSize == -1) { char *errstr = strerror(errno); writeErr(&quot;Error: &quot;); writeErr(errstr); writeErr(&quot;\\n&quot;); writeErr(&quot;fail to write to stdout\\n&quot;); exit(STDOUT_WRITE_FAIL); }}void writeErr(const char* str) { errno = 0; int writeSize = write(STDERR_FILENO, str, strlen(str)); if(writeSize == -1) { exit(STDERR_WRITE_FAIL); }}","link":"/home/2023/03/22/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha4/"},{"title":"cha39.能力","text":"读书笔记进程能力分为： 类型 解释 许可集 进程可使用的能力，删除一个能力是不可逆的 有效集 进程当前能使用的能力 可继承集 exec之后，可以继承、进入许可集的能力集（规定被exec的文件可以继承哪些能力） 文件能力分为： 类型 解释 许可集 exec时添加到进程的许可集 有效集 1位，关闭，则exec后进程有效集为空；开启，exec后有效集为许可集 可继承集 文件可继承集与进程可继承集相交后，作为exec后可被继承、进入许可集的能力集合（规定被exec的文件可以继承哪些能力） exec前后计算公式 cap_bset为能力边界集 39.1使用capability修改35-2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;sys/capability.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;sched.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt);}#define ERROR(...) error(__FILE__, __LINE__, __VA_ARGS__); exit(1)#define FAIL(...) error(__FILE__, __LINE__, __VA_ARGS__); return -1int raiseCap(int cap) { cap_value_t caplist[1]; cap_t capability = cap_get_proc(); if(capability == NULL) { FAIL(&quot;&quot;); } caplist[0] = cap; if(cap_set_flag(capability, CAP_EFFECTIVE, 1, caplist, CAP_SET) == -1) { cap_free(capability); FAIL(&quot;&quot;); } if(cap_set_proc(capability) == -1) { cap_free(capability); FAIL(&quot;&quot;); } if(cap_free(capability) == -1) { FAIL(&quot;&quot;); } return 0;}int main(int argc, char *argv[]) { if(raiseCap(CAP_SYS_NICE) == -1) { ERROR(&quot;&quot;);} int j, policy; struct sched_param sp; if(argc &lt; 3 || strrchr(&quot;rfo&quot;, argv[1][0]) == NULL) { ERROR(&quot;usage: %s policy priority pid...\\n&quot; &quot;\\tpolicy is r(RR), f(FIFO), &quot; #ifdef SCHED_BATCH &quot;b(BATCH), &quot; #endif #ifdef SCHED_IDLE &quot;i(IDLE), &quot; #endif &quot;or o(OTHER)&quot; , argv[0]); } switch (argv[1][0]) { case 'r': policy = SCHED_RR; break; case 'f': policy = SCHED_FIFO; break;#ifdef SCHED_BATCH case 'b': policy = SCHED_BATCH; break;#endif#ifdef SCHED_IDLE case 'i': policy = SCHED_IDLE; break;#endif case 'o': policy = SCHED_OTHER; break; default: ERROR(&quot;unsupported policy:%s\\n&quot;, argv[1]); break; } sp.sched_priority = atoi(argv[2]); for(int j = 3; j &lt; argc; j++) { pid_t pid = atoi(argv[j]); if(sched_setscheduler(pid, policy, &amp;sp) == -1) { ERROR(&quot;&quot;); } }} 12gcc practice39.1.c -o practice39.1 -lcapsudo setcap &quot;cap_sys_nice=pe&quot; practice39.1","link":"/home/2023/08/22/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha39/"},{"title":"cha42.共享库高级特性","text":"42.1 42.2 编写一个程序来验证当使用dlclose0关闭一个库时如果其中的符号还在被其他库使用的话将不会卸载这个库。 在程序清单42-1中的程序(dynload.c)中添加一个dladdr0调用以获取与dlsym返回的地址有关的信息。打印出返回的 DI inf 结构中各个字段的值并验证这些值是否与预期的值一样。 practice42.1.a.c1234567891011121314151617181920212223//// Created by root on 8/25/23.//#include &lt;stdio.h&gt;int foo(int a, int b) { printf(&quot;foo\\n&quot;); return a+b;}int bar(int a, int b) { printf(&quot;bar\\n&quot;); return a*b;}void __attribute__ ((constructor)) init() { printf(&quot;constructing\\n&quot;);}void __attribute__ ((destructor())) dest() { printf(&quot;destructing\\n&quot;);} practice42.1.b.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//// Created by root on 8/25/23.//#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt);}#define ERROR(...) do { error(__FILE__, __LINE__, __VA_ARGS__); exit(1); } while(0)#define FAIL(...) do { error(__FILE__, __LINE__, __VA_ARGS__); return -1; } while(0)int main(int argc, char **argv) { if(argc &lt; 1) { ERROR(&quot;Usage: %s shared-object&quot;, argv[0]); } void *libhandler = dlopen(argv[1], RTLD_NOW); if(libhandler == NULL) { ERROR(dlerror()); } void *libhandler1 = dlopen(argv[1], RTLD_NOW); if(libhandler1 == NULL) { ERROR(dlerror()); } int (*f)(int, int) = dlsym(libhandler, &quot;foo&quot;); if(f == NULL) { ERROR(dlerror()); } int (*f1)(int, int) = dlsym(libhandler1, &quot;bar&quot;); if(f1 == NULL) { ERROR(dlerror()); } Dl_info info; memset(&amp;info, 0, sizeof(Dl_info)); if(dladdr(f, &amp;info) == 0) { ERROR(dlerror()); } printf(&quot;addr=%p\\n\\tfname=%s\\n\\tfbase=%p\\n\\tsname=%s\\n\\tsaddr=%p\\n&quot;, f, info.dli_fname, info.dli_fbase, info.dli_sname, info.dli_saddr); memset(&amp;info, 0, sizeof(Dl_info)); if(dladdr(f1, &amp;info) == 0) { ERROR(dlerror()); } printf(&quot;addr=%p\\n\\tfname=%s\\n\\tfbase=%p\\n\\tsname=%s\\n\\tsaddr=%p\\n&quot;, f1, info.dli_fname, info.dli_fbase, info.dli_sname, info.dli_saddr); printf(&quot;%d, %d\\n&quot;, f(1,2), f1(2,3)); printf(&quot;dlclose libhandler\\n&quot;); dlclose(libhandler); printf(&quot;dlclose libhandler1\\n&quot;); dlclose(libhandler1);}","link":"/home/2023/08/25/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha42/"},{"title":"cha40.登录记账","text":"40-1 40-4 实现getlogin0。在40.5节中曾提到过当进程运行在一些软件终端模拟器下时getlogin0可能无法正确工作，在那种情况下就在虚拟控制台中进行测试。 实现一个简单的who(1)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//// Created by root on 8/23/23.//#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;utmpx.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;char *__getlogin() { static char login[__UT_NAMESIZE]; char *tty = ttyname(0); if(tty) tty++; tty=strchr(tty, '/'); if(tty) tty++; printf(&quot;tty=%s\\n&quot;, tty); size_t ttylen = strlen(tty); struct utmpx *ut; setutxent(); while((ut = getutxent()) != NULL) { printf(&quot;type:\\t%s\\nline:\\t%s\\nuser:\\t%s\\nhost:\\t%s\\ntime:\\t%s\\n\\n&quot;, ut-&gt;ut_type == EMPTY ? &quot;EMPTY&quot; : ut-&gt;ut_type == RUN_LVL ? &quot;RUN_LVL&quot; : ut-&gt;ut_type == BOOT_TIME ? &quot;BOOT_TIME&quot; : ut-&gt;ut_type == NEW_TIME ? &quot;NEW_TIME&quot; : ut-&gt;ut_type == OLD_TIME ? &quot;OLD_TIME&quot; : ut-&gt;ut_type == INIT_PROCESS ? &quot;INIT_PROCESS&quot; : ut-&gt;ut_type == USER_PROCESS ? &quot;USER_PROCESS&quot; : ut-&gt;ut_type == DEAD_PROCESS ? &quot;DEAD_PROCESS&quot; : ut-&gt;ut_type == LOGIN_PROCESS ? &quot;LOGIN_PROCESS&quot; : &quot;unknown&quot;, ut-&gt;ut_line, ut-&gt;ut_user, ut-&gt;ut_host, ctime((time_t *)&amp;ut-&gt;ut_tv.tv_sec) ); if(!strncmp(tty, ut-&gt;ut_line, ttylen) &amp;&amp; (ut-&gt;ut_type == INIT_PROCESS || ut-&gt;ut_type == USER_PROCESS || ut-&gt;ut_type == LOGIN_PROCESS)) { strcpy(login, ut-&gt;ut_user); } } endutxent(); return login;}int main() { printf(&quot;getlogin=%s\\n&quot;, getlogin()); printf(&quot;getlogin=%s\\n&quot;, __getlogin());} 40-2 40-3 修改程序清单40-3中的程序(utmpx loginc)使它除了更新utmp和wtmp文件之外还更新lastlog文件。 阅读login(3)、logout(3)以及logwtmp(3)的手册。实现这些函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166//// Created by root on 8/24/23.//#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;utmpx.h&gt;#include &lt;stdarg.h&gt;#include &lt;time.h&gt;#include &lt;paths.h&gt;#include &lt;wait.h&gt;#include &lt;lastlog.h&gt;#include &lt;pwd.h&gt;#include &lt;fcntl.h&gt;#include &lt;pwd.h&gt;#include &lt;crypt.h&gt;#include &lt;shadow.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt);}#define ERROR(...) do { error(__FILE__, __LINE__, __VA_ARGS__); exit(1); } while(0)#define FAIL(...) do { error(__FILE__, __LINE__, __VA_ARGS__); return -1; } while(0)char *alloc_sprintf(const char * __format, ...) { va_list fmt; va_start(fmt, __format); int len = vsnprintf(NULL, 0, __format, fmt); va_end(fmt); char *str = malloc(len+1); if(str == NULL) ERROR(&quot;&quot;); va_start(fmt, __format); vsnprintf(str, 0, __format, fmt); va_end(fmt); return str;}int tmpxlog(struct utmpx *ut, const char *user, const char *ttyName) { memset(ut, 0, sizeof(struct utmpx)); ut-&gt;ut_type = USER_PROCESS; strncpy(ut-&gt;ut_user, user, sizeof(ut-&gt;ut_user)); if(time((time_t *)&amp;ut-&gt;ut_tv.tv_sec) == -1) { ERROR(&quot;&quot;); } ut-&gt;ut_pid = getpid(); strcpy(ut-&gt;ut_line, ttyName + 5); strcpy(ut-&gt;ut_id, ttyName + 8); strcpy(ut-&gt;ut_host, &quot;meow-bash&quot;); setutxent(); if(pututxline(ut) == NULL) ERROR(&quot;&quot;); updwtmpx(_PATH_WTMP, ut); return 0;}int lastlog(uid_t uid, const char *ttyName) { struct lastlog lastlog = { .ll_host=&quot;meow-bash&quot; }; strcpy(lastlog.ll_line, ttyName + 5); if(time((time_t *)&amp;lastlog.ll_time) == -1) { ERROR(&quot;&quot;); } int lstlogfd = open(_PATH_LASTLOG, O_RDWR); if(lseek(lstlogfd, uid * sizeof(struct lastlog), SEEK_SET) == -1) ERROR(&quot;&quot;); if(write(lstlogfd, &amp;lastlog, sizeof(struct lastlog)) != sizeof(struct lastlog)) ERROR(&quot;&quot;); close(lstlogfd); return 0;}int tmpxlogout(struct utmpx *ut) { ut-&gt;ut_type = DEAD_PROCESS; if(time((time_t *)&amp;ut-&gt;ut_tv.tv_sec) == -1) { ERROR(&quot;&quot;); } strncpy(ut-&gt;ut_user, &quot;&quot;, sizeof(ut-&gt;ut_user)); setutxent(); if(pututxline(ut) == NULL) ERROR(&quot;&quot;); updwtmpx(_PATH_WTMP, ut); endutxent(); return 0;}int checkpwd(const char *username) { char *shadow = NULL; struct passwd *usrpwd; if((usrpwd = getpwnam(username)) == NULL) FAIL(&quot;username:%s not found&quot;, username); shadow = usrpwd-&gt;pw_passwd; char *pass = getpass(&quot;Password: &quot;); if(!strcmp(shadow, &quot;x&quot;)) { struct spwd *shadowpwd; if((shadowpwd = getspnam(username)) == NULL) FAIL(&quot;shadowpwd not found&quot;); shadow = shadowpwd-&gt;sp_pwdp; pass = crypt(pass, shadow); } if(strcmp(shadow, pass) == 0) FAIL(&quot;password not match!&quot;); return 0;}char *user = NULL;int init_check(int argc, char *argv[]) { if(argc &lt; 2) { user = malloc(2048); char hostname[2048]; gethostname(hostname, 2048); printf(&quot;%s login: &quot;, hostname); scanf(&quot;%s&quot;, user); } else { user = strdup(argv[1]); } if(getuid() != 0) { ERROR(&quot;uid must be 0\\n&quot;); }}int main(int argc, char *argv[]) { struct utmpx ut; char *homedir = NULL; uid_t uid; struct passwd *passwd = NULL; char *ttyName = ttyname(0); if(ttyName == NULL) { ERROR(&quot;&quot;); } init_check(argc, argv); if(checkpwd(user) == -1) ERROR(&quot;&quot;); passwd = getpwnam(user); uid = passwd-&gt;pw_uid; homedir = alloc_sprintf(&quot;%s/.bashrc&quot;, passwd-&gt;pw_dir); tmpxlog(&amp;ut, user, ttyName); lastlog(uid, ttyName); printf(&quot;meow-meow-bash login\\n&quot;); fflush(NULL); switch (fork()) { case -1: ERROR(&quot;&quot;); break; case 0: setuid(uid); if(execlp(&quot;/bin/bash&quot;, &quot;/bin/bash&quot;, &quot;--init-file&quot;, homedir, NULL) == -1) { ERROR(&quot;&quot;); } break; default: wait(NULL); break; } tmpxlogout(&amp;ut); printf(&quot;meow-meow-bash logout\\n&quot;); free(homedir); free(user);}","link":"/home/2023/08/24/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha40/"},{"title":"cha44.管道和FIFO","text":"管道和FIFO 通过pipe调用获取两个fd，fd[0]为管道的输入端，fd[1]为输出端，允许相关的进程之间通过管道相连 管道的使用的单项的，如果某些进程即读取管道又写入管道，可能会与其他读取/写入管道的进程产生竞态条件 对管道read时，如果管道另一端有进程打开且管道内没有内容，则会阻塞，直到另一端写入（此时读取到写入的数据），或另一端关闭（此时read返回EOF） 利用这一特性，可以作为进程间的同步机制 一般子进程要关闭不需要的另一端 当所有写入端都关闭时，从管道中读取，会返回EOF，帮助程序了解当前管道的使用状况 当所有读取端都关闭时，向管道内写入数据，系统会向进程发送SIGPIPE，默认杀死进程。若修改SIGPIPE默认行为，则write失败，错误为EPIPE。若对SIGPIPE使用了SA_RESTART，write另一端已经关闭的管道，write也不会重启 stdio对管道使用块缓冲 FIFO通过mkfifo或mknod创建，类似于管道，区别在于 通过文件名open后获取fd，open时指定read还是write open时没有使用O_NONBLOCK时，打开另一端关闭的FIFO时，会阻塞 open时使用O_NONBLOCK | O_WRONLY时，向另一侧关闭的FIFO中写入时，导致ENXIO错误，使用O_NONBLOCK | O_RDONLY则立刻成功 不使用O_NONBLOCK时read，情况等于管道，启用时，如果FIFO中没有数据，产生EAGAIN错误 write时读取端关闭，则产生SIGPIPE，返回EPIPE。其他情况比较复杂。 验证123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138//// Created by root on 8/29/23.//#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;wait.h&gt;#include &lt;signal.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt);}#define ERROR(...) do { error(__FILE__, __LINE__, __VA_ARGS__); exit(1); } while(0)#define ERROR_PRINT(...) error(__FILE__, __LINE__, __VA_ARGS__)#define FAIL(...) do { error(__FILE__, __LINE__, __VA_ARGS__); return -1; } while(0)char *alloc_sprintf(const char * __format, ...) { va_list fmt; va_start(fmt, __format); int len = vsnprintf(NULL, 0, __format, fmt); va_end(fmt); char *str = malloc(len+1); if(str == NULL) ERROR(&quot;&quot;); va_start(fmt, __format); vsnprintf(str, len+1, __format, fmt); va_end(fmt); return str;}#define safe_free(ptr) do { if(ptr) { free(ptr); ptr = NULL;} } while(0)char *fifo;void cleanup() { safe_free(fifo);}#define test(flag) do { \\ int fd = open(fifo, flag); \\ if(fd == -1) { \\ error(__FILE__, __LINE__, &quot;flag = %s&quot;,#flag); \\ } \\ close(fd); \\} while(0)void pipehandler(int sig) { char *content = alloc_sprintf(&quot;pid:%d, received signal:%d(%s)\\n&quot;, getpid(), sig, strsignal(sig)); write(STDOUT_FILENO, content, strlen(content)); safe_free(content);}int main(int argc, char **argv) { char buf[1024]; atexit(cleanup); fifo = alloc_sprintf(&quot;%s-fifo&quot;, argv[0]); printf(&quot;fifo=%s\\n&quot;, fifo); if(mkfifo(fifo, S_IRUSR | S_IWUSR | S_IWGRP) == -1 &amp;&amp; errno != EEXIST) { ERROR(&quot;&quot;); } // 非阻塞，打开没有写入端的FIFO test(O_RDONLY | O_NONBLOCK); // 非阻塞，打开没有读取端的FIFO test(O_WRONLY | O_NONBLOCK); int pipefd[2] = {0}; if(pipe(pipefd) == -1) ERROR(&quot;&quot;); if(sigaction(SIGPIPE, &amp;(struct sigaction) { .sa_flags=0, .sa_handler=pipehandler }, NULL) == -1) ERROR(&quot;&quot;); if(sigaction(SIGUSR1, &amp;(struct sigaction) { .sa_flags=SA_RESTART, .sa_handler=pipehandler }, NULL) == -1) ERROR(&quot;&quot;); if(sigaction(SIGUSR2, &amp;(struct sigaction) { .sa_flags=0, .sa_handler=pipehandler }, NULL) == -1) ERROR(&quot;&quot;); ssize_t readsize = 0; pid_t pid; if((pid = fork()) != 0) { if((readsize = read(pipefd[0], buf, 1024)) &lt; 0) { ERROR_PRINT(&quot;&quot;); } // SIGUSR1中断read，SIGUSR1有SA_RESTART，重启，成功读取 if(write(STDOUT_FILENO, buf, readsize) != readsize) { ERROR(&quot;&quot;); } kill(pid, SIGUSR1); readsize = 0; if((readsize = read(pipefd[0], buf, 1024)) &lt; 0) { ERROR_PRINT(&quot;&quot;); } // SIGUSR2中断read，SIGUSR2没有SA_RESTART，不重启，没有成功读取 if(write(STDOUT_FILENO, buf, readsize) != readsize) { ERROR(&quot;&quot;); } } else { close(pipefd[0]); kill(getppid(), SIGUSR1); sleep(1); write(pipefd[1], &amp;(char[]){'o', 'k', '!', '\\n'}, 4); pause(); sleep(1); kill(getppid(), SIGUSR2); sleep(1); write(pipefd[1], &amp;(char[]){'o', 'j', 'b', 'k', '!', '\\n'}, 6); close(pipefd[1]); exit(0); } wait(NULL); close(pipefd[0]); close(pipefd[1]); if(pipe(pipefd) == -1) ERROR(&quot;&quot;); close(pipefd[1]); if((readsize = read(pipefd[0], buf, 1024)) &lt; 0) { ERROR_PRINT(&quot;&quot;); } // 向写入端已经关闭的一端读取 printf(&quot;向写入端已经关闭的一端读取, readsize = %lu\\n&quot;, readsize); close(pipefd[0]); if(pipe(pipefd) == -1) ERROR(&quot;&quot;); close(pipefd[0]); if(write(pipefd[1], &quot;12345&quot;, 5) != 5) { ERROR_PRINT(&quot;&quot;); } // 向读取端已经关闭的一端写入,SIGPIPE有SA_RESTART但是此时不重启 close(pipefd[1]); return 0;} 书上有一些不清楚的地方，用这个代码可以验证一下 44.1编写一个程序使之使用两个管道来启用父进程和子进程之间的双向通信。父进程应该循环从标准输入中读取一个文本块并使用其中一个管道将文本发送给子进程，子进程将文本转换成大写并通过另一个管道将其传回给父进程。父进程读取从子进程过来的数据并在继续下一个循环之前将其反馈到标准输出上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136//// Created by root on 8/29/23.//#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt);}#define ERROR(...) do { error(__FILE__, __LINE__, __VA_ARGS__); exit(1); } while(0)#define ERROR_PRINT(...) error(__FILE__, __LINE__, __VA_ARGS__)#define FAIL(...) do { error(__FILE__, __LINE__, __VA_ARGS__); return -1; } while(0)#define safe_free(ptr) do { if(ptr) { free(ptr); ptr = NULL;} } while(0)void wPrintf(int fd, const char * format, ...) { va_list fmt; va_start(fmt, format); int len = vsnprintf(NULL, 0, format, fmt); char *str = malloc(len+1); va_end(fmt); va_start(fmt, format); if(str == NULL) ERROR(&quot;&quot;); vsnprintf(str, len+1, format, fmt); va_end(fmt); if(write(fd, str, len) != len) { ERROR(&quot;&quot;); } safe_free(str);}pid_t childpid = -1;#define BUFFER_SIZE 2048int main2child[2];int child2main[2];void cleanup() { wPrintf(STDOUT_FILENO, &quot;pid:%d, cleaning up\\n&quot;, getpid()); if(childpid &gt; 1) kill(childpid,SIGKILL);}void child_process() { char buf[BUFFER_SIZE]; ssize_t readsize; if(close(main2child[1]) == -1) ERROR(&quot;&quot;); if(close(child2main[0]) == -1) ERROR(&quot;&quot;); while ((readsize = read(main2child[0], buf, BUFFER_SIZE-1)) &gt; 0) { buf[readsize] = 0; wPrintf(STDOUT_FILENO, &quot;child read: %s\\n&quot;, buf); for(int i = 0; i &lt; readsize; i++) { if((buf[i] &gt;= 'a' &amp;&amp; buf[i] &lt;= 'z') ) { buf[i] += 'A' - 'a'; } else if((buf[i] &gt;= 'A' &amp;&amp; buf[i] &lt;= 'Z')) { buf[i] += 'a' - 'A'; } } if(write(child2main[1], buf, readsize) != readsize) { ERROR(&quot;&quot;); } } if(readsize &lt; 0) { ERROR(&quot;&quot;); } else { wPrintf(STDOUT_FILENO, &quot;main2child closed!\\n&quot;); } if(close(main2child[0]) == -1) ERROR(&quot;&quot;); if(close(child2main[1]) == -1) ERROR(&quot;&quot;);}void main_process() { char buf[BUFFER_SIZE]; ssize_t readsize; if(close(main2child[0]) == -1) ERROR(&quot;&quot;); if(close(child2main[1]) == -1) ERROR(&quot;&quot;); while ((readsize = read(STDIN_FILENO, buf, BUFFER_SIZE-1)) &gt; 0) { buf[readsize] = 0; wPrintf(STDOUT_FILENO, &quot;main read: %s\\n&quot;, buf); if(write(main2child[1], buf, readsize) != readsize) { ERROR(&quot;&quot;); } readsize = read(child2main[0], buf, BUFFER_SIZE-1); buf[readsize] = 0; if(readsize == 0) { wPrintf(STDOUT_FILENO, &quot;child2main closed!\\n&quot;); exit(0); } else if(readsize &lt; 0) { ERROR(&quot;&quot;); } else { wPrintf(STDOUT_FILENO, &quot;main read from child: %s\\n&quot;, buf); } } if(readsize &lt; 0) { ERROR(&quot;&quot;); } if(close(main2child[1]) == -1) ERROR(&quot;&quot;); if(close(child2main[0]) == -1) ERROR(&quot;&quot;);}void handler(int sig) { wPrintf(STDOUT_FILENO, &quot;pid:%d, received sig:%d(%s)\\n&quot;, getpid(), sig, strsignal(sig)); exit(1);}int main(int argc, char *argv[]) { atexit(cleanup); if(pipe(main2child) == -1) ERROR(&quot;&quot;); if(pipe(child2main) == -1) ERROR(&quot;&quot;); switch((childpid = fork())) { case -1: ERROR(&quot;&quot;); break; case 0: child_process(); return 0; break; default: if(signal(SIGINT, handler) == SIG_ERR) ERROR(&quot;&quot;); if(signal(SIGPIPE, handler) == SIG_ERR) ERROR(&quot;&quot;); main_process(); return 0; break; }} 44.2实现popen和pclose。尽管这些函数因无需完成在system实现(参见27.7节)中的信号处理而得到了简化，但需要小心地将管道两端正确绑定到各个进程的文件流上并确保关闭所有引用管道两端的未使用的描述符。由于通过多个 popen调用创建的子进程可能会同时运行，因此需要需要维护一个将 popen0分配的文件流与相应的子进程ID关联起来的数据结构。从这个结构中取得正确的进程ID使得pclose能够选择需等待的子进程。这个结构还满足了SUSv3的要求，即在新的子进程中必须要关闭所有通过之前的popen调用仍然打开着的文件流。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//// Created by root on 8/29/23.//#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt);}#define ERROR_EXIT(ret, msg...) do { error(__FILE__, __LINE__, msg); ret } while(0)#define ERROR(msg...) ERROR_EXIT(exit(1);, msg)#define FAIL(val, msg...) ERROR_EXIT(return val;, msg)#define PRINT_ERROR_STR(msg...) FAIL(, msg)#define safe_free(ptr) do { if(ptr) { free(ptr); ptr = NULL;} } while(0)void wPrintf(int fd, const char * format, ...) { va_list fmt; va_start(fmt, format); int len = vsnprintf(NULL, 0, format, fmt); char *str = malloc(len+1); va_end(fmt); va_start(fmt, format); if(str == NULL) ERROR(&quot;&quot;); vsnprintf(str, len+1, format, fmt); va_end(fmt); if(write(fd, str, len) != len) { ERROR(&quot;&quot;); } safe_free(str);}#include &lt;limits.h&gt;#include &lt;wait.h&gt;static pid_t *fd2pid = NULL;int _pclose(FILE *file) { if(fd2pid == NULL) { fd2pid = malloc(INT_MAX * sizeof(pid_t)); return -1; } int fd = fileno(file); if(fclose(file) == -1) FAIL(-1, &quot;&quot;);// if(close(fd) == -1) FAIL(-1, &quot;&quot;); // 不需要，fclose就会调用close if(waitpid(fd2pid[fd], NULL, 0) == -1) FAIL(-1, &quot;&quot;); return 0;}FILE *_popen(const char *command, const char *mode) { if(fd2pid == NULL) { fd2pid = malloc(INT_MAX * sizeof(pid_t)); } FILE *ret = NULL; int pipefd[2] = {0}; // retfd, dupfd int replacefd = -1; if(strcmp(&quot;r&quot;, mode) != 0 &amp;&amp; strcmp(&quot;w&quot;, mode) != 0) { FAIL(NULL, &quot;mode: r/w&quot;); } if(pipe(pipefd) == -1) FAIL(NULL, &quot;&quot;); if(mode[0] == 'r') { ret = fdopen(pipefd[0], &quot;r&quot;); if(ret == NULL) FAIL(NULL, &quot;&quot;); replacefd = STDOUT_FILENO; } else { ret = fdopen(pipefd[1], &quot;w&quot;); int fdt = pipefd[0]; pipefd[0] = pipefd[1]; pipefd[1] = fdt; replacefd = STDIN_FILENO; } pid_t pid; switch(pid = fork()) { case -1: FAIL(NULL, &quot;&quot;); break; case 0: if(close(pipefd[0]) == -1) FAIL(NULL, &quot;&quot;); if(dup2(pipefd[1], replacefd) == -1) { ERROR(&quot;&quot;); } system(command); if(close(pipefd[1]) == -1) FAIL(NULL, &quot;&quot;); exit(0); break; default: if(close(pipefd[1]) == -1) FAIL(NULL, &quot;&quot;); break; } fd2pid[pipefd[0]] = pid; return ret;}int main(int argc, char *argv[]) { FILE *f; f = _popen(&quot;tee &gt; abc.txt&quot;, &quot;w&quot;); for(int i = 0; i &lt; argc; i++) { fprintf(f, &quot;%s\\n&quot;, argv[i]); } _pclose(f); f = _popen(&quot;cat abc.txt&quot;, &quot;r&quot;); char buf[2048] = {0}; while (fgets(buf, 2048, f) != NULL) { printf(&quot;%s&quot;, buf); } _pclose(f);} 44.3 44.4 44.6在44.7的基础上改动： 加入功能：每次给client赋值时，都会与一个文件同步记录最新的数值，服务器启动时读取这个数值，并从这个数值开始提供服务 加入功能：在收到SIGINT, SIGTERM时删除服务器并终止 加入功能：防止恶意程序攻击（恶意程序创建但不打开自己的CLIENT_FIFO，导致server始终阻塞。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193//// Created by root on 8/29/23.//#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt);}#define ERROR_EXIT(ret, msg...) do { error(__FILE__, __LINE__, msg); ret } while(0)#define ERROR(msg...) ERROR_EXIT(exit(1);, msg)#define FAIL(ret, msg...) ERROR_EXIT(ret, msg)#define PRINT_ERROR_STR(msg...) FAIL(;, msg)#define safe_free(ptr) do { if(ptr) { free(ptr); ptr = NULL;} } while(0)char *alloc_sprintf(const char * __format, ...) { va_list fmt; va_start(fmt, __format); int len = vsnprintf(NULL, 0, __format, fmt); va_end(fmt); char *str = malloc(len+1); if(str == NULL) ERROR(&quot;&quot;); va_start(fmt, __format); vsnprintf(str, len+1, __format, fmt); va_end(fmt); return str;}char *__client_fifo = NULL;void __attribute__((destructor)) cleanup() { // atexit更合适 safe_free(__client_fifo);}#define SERVER_FIFO &quot;server-fifo&quot;#define CLIENT_FIFO (__client_fifo == NULL ? (__client_fifo = alloc_sprintf(&quot;client-fifo-%d&quot;, getpid())) : __client_fifo)#define GET_CLIENT_FIFO(pid) alloc_sprintf(&quot;client-fifo-%d&quot;, pid)#define GLOBAL_NUMBER_FILE &quot;global_number_file&quot;struct client_info { pid_t pid; int incr;};unsigned long long int number = 0;void sync_global(unsigned long long int *old, unsigned long long int *new) { unsigned long long int buf; int global_numberfd = open(GLOBAL_NUMBER_FILE, O_RDWR | O_SYNC | O_CREAT, 0666); if(global_numberfd == -1) FAIL(return;,&quot;&quot;); ssize_t readsize = read(global_numberfd, &amp;buf, sizeof(unsigned long long int)); if(readsize &lt; 0) PRINT_ERROR_STR(&quot;&quot;); lseek(global_numberfd, 0, SEEK_SET); if(old) { if(write(global_numberfd, old, sizeof(unsigned long long int)) != sizeof(unsigned long long int)) PRINT_ERROR_STR(&quot;&quot;); } if(readsize &gt; 0 &amp;&amp; new) *new = buf; close(global_numberfd);}int server_fd;int dummy_fd;void on_server_exit() { close(server_fd); close(dummy_fd); unlink(SERVER_FIFO); sync_global(&amp;number, NULL);}void handler(int sig) { printf(&quot;server, sig:%s\\n&quot;, strsignal(sig)); on_server_exit(); signal(sig, SIG_DFL); raise(sig);}void destroy(int sig) { printf(&quot;server, sig:%s\\n&quot;, strsignal(sig)); on_server_exit(); unlink(GLOBAL_NUMBER_FILE); _exit(0);}int server(int argc, char *argv[]) { atexit(on_server_exit); signal(SIGPIPE, handler); signal(SIGINT, destroy); signal(SIGTERM, destroy); signal(SIGHUP, handler); signal(19, handler); if(mkfifo(SERVER_FIFO, 0666) == -1) ERROR(&quot;&quot;); if((server_fd = open(SERVER_FIFO, O_RDONLY)) == -1) ERROR(&quot;&quot;); if((dummy_fd = open(SERVER_FIFO, O_WRONLY)) == -1) ERROR(&quot;&quot;); // dummy可以防止读取到EOF，防止cpu空转 struct client_info buf; ssize_t rd_size; sync_global(NULL, &amp;number); printf(&quot;number = %llu\\n&quot;, number); for(int i = 0 ;; i++) { // dummy可以防止cpu在这里空转 printf(&quot;i = %d\\n&quot;, i); while ((rd_size = read(server_fd, &amp;buf, sizeof(struct client_info))) &gt; 0) { printf(&quot;server: handling request from %d,%d\\n&quot;, buf.pid, buf.incr); char *client_fifo = GET_CLIENT_FIFO(buf.pid); if(access(client_fifo, F_OK | W_OK) != 0) ERROR_EXIT(goto cleanup_noaction;, &quot;&quot;); int client_fd; if ((client_fd = open(client_fifo, O_WRONLY | O_NONBLOCK)) == -1) ERROR_EXIT(goto cleanup_noaction;, &quot;&quot;); //防止阻塞 int flag; if((flag = fcntl(client_fd, F_GETFL)) == -1) ERROR_EXIT(goto cleanup;, &quot;&quot;); flag &amp;= ~O_NONBLOCK; // 去掉O_NONBLOCK if(fcntl(client_fd, F_SETFL, flag) == -1) ERROR_EXIT(goto cleanup;, &quot;&quot;); // write使用阻塞语义 sigset_t sigset, oldset; if(sigemptyset(&amp;sigset) == -1) ERROR_EXIT(goto cleanup_nomask;, &quot;&quot;); if(sigemptyset(&amp;oldset) == -1) ERROR_EXIT(goto cleanup_nomask;, &quot;&quot;); if(sigaddset(&amp;sigset, SIGPIPE) == -1) ERROR_EXIT(goto cleanup_nomask;, &quot;&quot;); if(sigprocmask(SIG_SETMASK, &amp;sigset, &amp;oldset) == -1) ERROR_EXIT(goto cleanup_nomask;, &quot;&quot;); //写入端没打开，产生SIGPIPE和EPIPE，屏蔽SIGPIPE if (write(client_fd, &amp;(unsigned long long int[1]) {number}, sizeof(unsigned long long int[1])) != sizeof(unsigned long long int[1])) ERROR_EXIT(goto cleanup;, &quot;&quot;); number += buf.incr; cleanup: if(sigprocmask(SIG_SETMASK, &amp;oldset, NULL) == -1) ERROR_EXIT(goto cleanup;, &quot;&quot;); // 还原 cleanup_nomask: sync_global(&amp;number, NULL); close(client_fd); cleanup_noaction: safe_free(client_fifo); } if(rd_size &lt; 0) ERROR(&quot;&quot;); } return 0;}int client(int argc, char *argv[]) { int client_fd; if((server_fd = open(SERVER_FIFO, O_WRONLY)) == -1) ERROR(&quot;&quot;); if(mkfifo(CLIENT_FIFO, 0666) == -1) ERROR(&quot;&quot;); struct client_info info = { .incr=atoi(argv[1]), .pid=getpid() }; printf(&quot;client write\\n&quot;); if(write(server_fd, &amp;info, sizeof(struct client_info)) != sizeof(struct client_info)) { ERROR(&quot;&quot;); } unsigned long long int n; printf(&quot;client read\\n&quot;); printf(&quot;client open1\\n&quot;); if((client_fd = open(CLIENT_FIFO, O_RDONLY)) == -1) ERROR(&quot;&quot;); if(read(client_fd, &amp;n, sizeof(unsigned long long int)) != sizeof(unsigned long long int)) { ERROR(&quot;&quot;); } printf(&quot;get id: %llu\\n&quot;, n); close(server_fd); close(client_fd); unlink(CLIENT_FIFO);}int malicious(int argc, char *argv[]) { if((server_fd = open(SERVER_FIFO, O_WRONLY)) == -1) ERROR(&quot;&quot;); if(mkfifo(CLIENT_FIFO, 0666) == -1) ERROR(&quot;&quot;); struct client_info info = { .incr=atoi(argv[1]), .pid=getpid() }; printf(&quot;client write\\n&quot;); if(write(server_fd, &amp;info, sizeof(struct client_info)) != sizeof(struct client_info)) { ERROR(&quot;&quot;); }}int main(int argc, char *argv[]) { argv++; argc--; if(!strcmp(&quot;server&quot;, argv[0])) { server(argc, argv); } else if(!strcmp(&quot;client&quot;, argv[0])) { client(argc, argv); } else if (!strcmp(&quot;malicious&quot;, argv[0])) { malicious(argc, argv); } return 0;} 44.5程序清单44-7中的服务器(fifoseqnum_server.c)在 FIFO上执行第二次带O_WRONLY标记的打开操作使之在从FIFO的读取描述符(serverFd)中读取数据时永远不会看到文件结束。除了这种做法之外，还可以尝试另一种方法:当服务器在读取描述符中看到文件结束时关闭这个描述符，然后再次打开 FIFO以便读取数据。(这个打开操作将会阻塞直到下一个客户端因写入而打开FIFO为止。这种方法错在哪里了? 增加不必要的系统调用，导致额外的系统开销 若server的优先级较低，open始终无法调用，则client也会阻塞在open上 在读到EOF与下一次open之间，可能有其他进程向FIFO中写入数据，导致这些进程无法得到服务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191//// Created by root on 8/29/23.//#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt);}#define ERROR_EXIT(ret, msg...) do { error(__FILE__, __LINE__, msg); ret } while(0)#define ERROR(msg...) ERROR_EXIT(exit(1);, msg)#define FAIL(ret, msg...) ERROR_EXIT(ret, msg)#define PRINT_ERROR_STR(msg...) FAIL(;, msg)#define safe_free(ptr) do { if(ptr) { free(ptr); ptr = NULL;} } while(0)char *alloc_sprintf(const char * __format, ...) { va_list fmt; va_start(fmt, __format); int len = vsnprintf(NULL, 0, __format, fmt); va_end(fmt); char *str = malloc(len+1); if(str == NULL) ERROR(&quot;&quot;); va_start(fmt, __format); vsnprintf(str, len+1, __format, fmt); va_end(fmt); return str;}char *__client_fifo = NULL;void __attribute__((destructor)) cleanup() { // atexit更合适 safe_free(__client_fifo);}#define SERVER_FIFO &quot;server-fifo&quot;#define CLIENT_FIFO (__client_fifo == NULL ? (__client_fifo = alloc_sprintf(&quot;client-fifo-%d&quot;, getpid())) : __client_fifo)#define GET_CLIENT_FIFO(pid) alloc_sprintf(&quot;client-fifo-%d&quot;, pid)#define GLOBAL_NUMBER_FILE &quot;global_number_file&quot;struct client_info { pid_t pid; int incr;};unsigned long long int number = 0;void sync_global(unsigned long long int *old, unsigned long long int *new) { unsigned long long int buf; int global_numberfd = open(GLOBAL_NUMBER_FILE, O_RDWR | O_SYNC | O_CREAT, 0666); if(global_numberfd == -1) FAIL(return;,&quot;&quot;); ssize_t readsize = read(global_numberfd, &amp;buf, sizeof(unsigned long long int)); if(readsize &lt; 0) PRINT_ERROR_STR(&quot;&quot;); lseek(global_numberfd, 0, SEEK_SET); if(old) { if(write(global_numberfd, old, sizeof(unsigned long long int)) != sizeof(unsigned long long int)) PRINT_ERROR_STR(&quot;&quot;); } if(readsize &gt; 0 &amp;&amp; new) *new = buf; close(global_numberfd);}int server_fd;int dummy_fd;void on_server_exit() { close(server_fd); close(dummy_fd); unlink(SERVER_FIFO); sync_global(&amp;number, NULL);}void handler(int sig) { printf(&quot;server, sig:%s\\n&quot;, strsignal(sig)); on_server_exit(); signal(sig, SIG_DFL); raise(sig);}void destroy(int sig) { printf(&quot;server, sig:%s\\n&quot;, strsignal(sig)); on_server_exit(); unlink(GLOBAL_NUMBER_FILE); _exit(0);}int server(int argc, char *argv[]) { atexit(on_server_exit); signal(SIGPIPE, handler); signal(SIGINT, destroy); signal(SIGTERM, destroy); signal(SIGHUP, handler); signal(19, handler); if(mkfifo(SERVER_FIFO, 0666) == -1) ERROR(&quot;&quot;);// if((server_fd = open(SERVER_FIFO, O_RDONLY)) == -1) ERROR(&quot;&quot;);// if((dummy_fd = open(SERVER_FIFO, O_WRONLY)) == -1) ERROR(&quot;&quot;); // dummy可以防止读取到EOF，防止cpu空转 struct client_info buf; ssize_t rd_size; sync_global(NULL, &amp;number); printf(&quot;number = %llu\\n&quot;, number); for(int i = 0 ;; i++) { // dummy可以防止cpu在这里空转 if((server_fd = open(SERVER_FIFO, O_RDONLY)) == -1) ERROR(&quot;&quot;); printf(&quot;i = %d\\n&quot;, i); while ((rd_size = read(server_fd, &amp;buf, sizeof(struct client_info))) &gt; 0) { printf(&quot;server: handling request from %d,%d\\n&quot;, buf.pid, buf.incr); char *client_fifo = GET_CLIENT_FIFO(buf.pid); if(access(client_fifo, F_OK | W_OK) != 0) ERROR_EXIT(goto cleanup_noaction;, &quot;&quot;); int client_fd; if ((client_fd = open(client_fifo, O_WRONLY | O_NONBLOCK)) == -1) ERROR_EXIT(goto cleanup_noaction;, &quot;&quot;); //防止阻塞 int flag; if((flag = fcntl(client_fd, F_GETFL)) == -1) ERROR_EXIT(goto cleanup;, &quot;&quot;); flag &amp;= ~O_NONBLOCK; // 去掉O_NONBLOCK if(fcntl(client_fd, F_SETFL, flag) == -1) ERROR_EXIT(goto cleanup;, &quot;&quot;); // write使用阻塞语义 sigset_t sigset, oldset; if(sigemptyset(&amp;sigset) == -1) ERROR_EXIT(goto cleanup_nomask;, &quot;&quot;); if(sigemptyset(&amp;oldset) == -1) ERROR_EXIT(goto cleanup_nomask;, &quot;&quot;); if(sigaddset(&amp;sigset, SIGPIPE) == -1) ERROR_EXIT(goto cleanup_nomask;, &quot;&quot;); if(sigprocmask(SIG_SETMASK, &amp;sigset, &amp;oldset) == -1) ERROR_EXIT(goto cleanup_nomask;, &quot;&quot;); //写入端没打开，产生SIGPIPE和EPIPE，屏蔽SIGPIPE if (write(client_fd, &amp;(unsigned long long int[1]) {number}, sizeof(unsigned long long int[1])) != sizeof(unsigned long long int[1])) ERROR_EXIT(goto cleanup;, &quot;&quot;); number += buf.incr; cleanup: if(sigprocmask(SIG_SETMASK, &amp;oldset, NULL) == -1) ERROR_EXIT(goto cleanup;, &quot;&quot;); // 还原 cleanup_nomask: sync_global(&amp;number, NULL); close(client_fd); cleanup_noaction: safe_free(client_fifo); } sleep(1); close(server_fd); if(rd_size &lt; 0) ERROR(&quot;&quot;); } return 0;}void clientdestroy(int sig) { printf(&quot;client %d, sig:%s\\n&quot;, getpid(), strsignal(sig)); unlink(CLIENT_FIFO); signal(sig, SIG_DFL); raise(sig);}int client(int argc, char *argv[]) { int client_fd; signal(SIGHUP, clientdestroy); setbuf(stdout, NULL); printf(&quot;client %d open\\n&quot;, getpid()); if((server_fd = open(SERVER_FIFO, O_WRONLY)) == -1) ERROR(&quot;&quot;); if(mkfifo(CLIENT_FIFO, 0666) == -1) ERROR(&quot;&quot;); struct client_info info = { .incr=atoi(argv[1]), .pid=getpid() }; printf(&quot;client %d write\\n&quot;, getpid()); if(write(server_fd, &amp;info, sizeof(struct client_info)) != sizeof(struct client_info)) { ERROR(&quot;&quot;); } unsigned long long int n; printf(&quot;client %d read\\n&quot;, getpid()); printf(&quot;client %d open1\\n&quot;, getpid()); if((client_fd = open(CLIENT_FIFO, O_RDONLY)) == -1) ERROR(&quot;&quot;); if(read(client_fd, &amp;n, sizeof(unsigned long long int)) != sizeof(unsigned long long int)) { ERROR(&quot;&quot;); } printf(&quot;client %d get id: %llu\\n&quot;, getpid(), n); close(server_fd); close(client_fd); unlink(CLIENT_FIFO);}int main(int argc, char *argv[]) { argv++; argc--; if(!strcmp(&quot;server&quot;, argv[0])) { server(argc, argv); } else if(!strcmp(&quot;client&quot;, argv[0])) { client(argc, argv); } return 0;} 123killall -HUP practice44.5../practice44.5 server &amp; &gt; logfor i in `seq 20`; do ../practice44.5 client $i &amp;&amp; hexdump global_number_file &amp; done &gt; log 通过分析log可以直到，client容易长期阻塞在对CLIENT_FIFO的open上，也就是server收到请求，但是client没有打开读取端，导致server没有写入返回数据，稍后client阻塞在第二个open上，等待server。","link":"/home/2023/08/30/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha44/"},{"title":"cha45.System V IPC","text":"45.1 45.2 编写一个程序来验证ftok0所采用的算法是否如45.2节中描述的那样使用了文件的i-node号、次要设备号以及proj值。(通过几个例子打印出所有这些值以及ftok的返回值的十六进制形式即可)。 实现ftok 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//// Created by root on 8/30/23.//#define _GNU_SOURCE /* See feature_test_macros(7) */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/ipc.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt);}#define ERROR_EXIT(ret, msg...) do { error(__FILE__, __LINE__, msg); ret } while(0)#define ERROR(msg...) ERROR_EXIT(exit(1);, msg)#define FAIL(ret, msg...) ERROR_EXIT(ret, msg)#define PRINT_ERROR_STR(msg...) FAIL(;, msg)key_t _ftok(const char *file, int proj) { struct statx filestat; int dirfd = open(&quot;.&quot;, O_RDONLY); if(statx(dirfd, file, 0, 0, &amp;filestat) == -1) FAIL(return -1;, &quot;&quot;); close(dirfd); return ((proj&amp;0xff) &lt;&lt; 24) | ((filestat.stx_dev_minor &amp; 0xff) &lt;&lt; 16) | ((filestat.stx_ino &amp; 0xffff));}int main(int argc, char **argv) { char *file = argv[1]; struct statx filestat; int dirfd = open(&quot;.&quot;, O_RDONLY); if(statx(dirfd, file, 0, 0, &amp;filestat) == -1) ERROR(&quot;&quot;); for(int proj = 1; proj &lt;= 255; proj++) { printf(&quot;proj:%02X, dev:%02X, i-node:%04X, &quot;, proj, filestat.stx_dev_minor &amp; 0xff, filestat.stx_ino &amp; 0xffff); printf(&quot;ftok:%08X\\n&quot;, ftok(file, proj)); printf(&quot;_ftok:%08X\\n&quot;, _ftok(file, proj)); } close(dirfd);} 45.3验证(通过实验)45.5节中有关用于生成System VIPC标识符的算法的声明。 1234567891011121314151617181920212223242526272829303132333435363738#define _GNU_SOURCE /* See feature_test_macros(7) */#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#define IPCMNI 32768int main(int argc, char *argv[]) { key_t key = ftok(argv[0], 0x6a); int id = msgget(key, IPC_CREAT | 0666), calid; struct msqid_ds msqidDs; msgctl(id, IPC_STAT, &amp;msqidDs); calid = msqidDs.msg_perm.__seq * IPCMNI; FILE *filemsg = fopen(&quot;/proc/sysvipc/msg&quot;, &quot;r&quot;); char msgline[2048]; int index = 0; fgets(msgline, 2048, filemsg); key_t keyi; do { char *nextline = fgets(msgline, 2048, filemsg); if (nextline == NULL) { break; } sscanf(nextline, &quot;%ld&quot;, &amp;keyi); index++; } while (keyi != key); calid += index; if (calid == id) { printf(&quot;true!\\n&quot;); } else { printf(&quot;false?\\n&quot;); } msgctl(id, IPC_RMID, &amp;msqidDs);} index获取的不对，没办法直接读内核内存中的那个数据 更新获取index的方法,msgctl的cmd使用IPC_INFO 12345678910111213141516171819202122232425#define _GNU_SOURCE /* See feature_test_macros(7) */#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#define IPCMNI 32768int main(int argc, char *argv[]) { key_t key = ftok(argv[0], 0x6a); int id = msgget(key, IPC_CREAT | 0666), calid; struct msqid_ds msqidDs; int index = msgctl(id, IPC_INFO, &amp;msqidDs); msgctl(id, IPC_STAT, &amp;msqidDs); calid = index + msqidDs.msg_perm.__seq * IPCMNI; if (calid == id) { printf(&quot;true!\\n&quot;); } else { printf(&quot;false?\\n&quot;); } msgctl(id, IPC_RMID, &amp;msqidDs);}","link":"/home/2023/08/30/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha45/"},{"title":"cha47.System V 信号量","text":"47.2 47.3 47.4 使用信号量，实现进程间的同步 验证SEM_UNDO是否会改变sempid 实现P V操作，实现testP（在程序清单47-l0给出的代码(binary_sems.c)中增加一个reserveSemNBO函数来使用PC_NOWAIT标记实现有条件的预留操作。）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdbool.h&gt;#include &lt;stddef.h&gt;#include &lt;syslog.h&gt;#include &lt;wait.h&gt;#define DEBUG_LEVEL LOG_DEBUG#ifndef DEBUG_LEVEL#define DEBUG_LEVEL LOG_INFO#endifFILE *logfile = NULL;bool syslog_enable = false;#define alloc_sprintf(__alloc_sprintf_str, __format...) do { \\ int __alloc_sprintf_len = snprintf(NULL, 0, __format); \\ (__alloc_sprintf_str) = malloc(__alloc_sprintf_len+1); \\ if(__alloc_sprintf_str != NULL) \\ snprintf(__alloc_sprintf_str, __alloc_sprintf_len+1, __format); \\} while(0)#define logger(level, msg...) do { \\ if(level &lt;= DEBUG_LEVEL) { \\ fprintf(logfile, msg); \\ fprintf(logfile, &quot;\\n&quot;); \\ } \\ if(syslog_enable) { \\ char *data; \\ alloc_sprintf(data, msg); \\ syslog(level, &quot;%s&quot;, data); \\ safe_free(data); \\ } \\} while(0)#define COND_RET(x, ret, msg...) \\ do { \\ if(!(x)) { \\ if(errno == 0)logger(LOG_ERR, &quot;%s:%d\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__, #x); \\ else logger(LOG_ERR, &quot;%s:%d\\nerror: %s\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__,strerror(errno), #x); \\ logger(LOG_ERR, msg); \\ logger(LOG_ERR, &quot;\\n&quot;); \\ ret \\ } \\ } while(0)#define CHECK(x, msg...) COND_RET(x, return -1;, msg)#define CHECK_EXIT(x, msg...) COND_RET(x, exit(EXIT_FAILURE);, msg)#define CHECK_LOG(x, msg...) COND_RET(x, ;, msg)#define safe_free(__safe_free_ptr) do { if(__safe_free_ptr) { free(__safe_free_ptr); (__safe_free_ptr) = NULL;} } while(0)#define BUFFER_SIZE 4096key_t sem_key = 0;int sem_id = 0;void rmsem() { CHECK_LOG(semctl(sem_id, 0, IPC_RMID) != -1, &quot;&quot;);}union semun { int val; struct semid_ds *buf; unsigned short *array;#if defined(__linux__) struct seminfo *__buf;#endif};pid_t taskid = 0;int safe_atoi(const char *num) { const char *ptr = num; while (ptr &amp;&amp; *ptr) { CHECK_EXIT(*ptr &gt;= '0' &amp;&amp; *ptr &lt;= '9', &quot;&quot;); ptr++; } return atoi(num);}int incrsem(int semnum, short incr, short flg) { struct sembuf sembuf; sembuf = (struct sembuf){ .sem_num=semnum, .sem_flg=flg, .sem_op=incr }; return semop(sem_id, &amp;sembuf, 1);}void siginthandler(int sig) { rmsem();}int initAvai(int semnum) { union semun arg; arg.val = 1; if(semctl(sem_id, semnum, SETVAL, arg) == -1) return -1; return incrsem(semnum, 1, 0);}int initInUse(int semnum) { union semun arg; arg.val = 0; if(semctl(sem_id, semnum, SETVAL, arg) == -1) return -1; return incrsem(semnum, 0, 0);}int P(int semnum) { int ret; do { ret = incrsem(semnum, -1, 0); } while (ret == -1 &amp;&amp; errno == EINTR); return ret;}int testP(int semnum) { // return 1 if sem would be blocked, return 0 if sem would not be blocked. int ret = incrsem(semnum, -1, IPC_NOWAIT); if(ret == -1) { if(errno == EAGAIN)return 1; else return ret; } return 0;}int V(int semnum) { return incrsem(semnum, 1, 0);}void init(int argc, char *argv[]) { logfile = stderr; sem_key = ftok(argv[0], 'x');// taskid = safe_atoi(argv[1]); // 1, 2 taskid = fork(); logger(LOG_INFO, &quot;PID = %ld, taskID = %d&quot;, (long)getpid(), taskid); CHECK_EXIT(taskid != -1, &quot;&quot;); union semun arg; if((sem_id = semget(sem_key, 3, IPC_CREAT | IPC_EXCL | 0666)) != -1) { atexit(rmsem); signal(SIGINT, siginthandler); arg.array = (unsigned short *)&amp;(unsigned short[]){0, 0, 0}; // sem[0] = 1, sem[1] = 0 CHECK_EXIT(semctl(sem_id, 0, SETALL, arg) != -1, &quot;&quot;); CHECK_EXIT(initInUse(1) != -1, &quot;&quot;); CHECK_EXIT(initAvai(0) != -1, &quot;&quot;); } else { if(errno != EEXIST) { CHECK_EXIT(false, &quot;&quot;); } sem_id = semget(sem_key, 3, 0666); } struct semid_ds ds; arg.buf = &amp;ds; CHECK_EXIT(semctl(sem_id, 0, IPC_STAT, arg) != -1, &quot;&quot;); while (ds.sem_otime == 0) { logger(LOG_INFO, &quot;waiting for sem init&quot;); sleep(1); CHECK_EXIT(semctl(sem_id, 0, IPC_STAT, arg) != -1, &quot;&quot;); } logger(LOG_INFO, &quot;finish init. PID = %ld, taskID = %d&quot;, (long)getpid(), taskid);}pid_t printsem(int semnum) { pid_t pid; CHECK_EXIT((pid = semctl(sem_id, semnum, GETPID)) != -1, &quot;&quot;); logger(LOG_INFO, &quot;semnum=%d, last semop pid=%ld&quot;, semnum, (long) pid); return pid;}int main(int argc, char *argv[]) { init(argc, argv); switch (taskid) { case 0: CHECK_EXIT(P(2) != -1, &quot;&quot;); CHECK_EXIT(incrsem(0, -1, SEM_UNDO) != -1, &quot;&quot;); CHECK_EXIT(V(1) != -1, &quot;&quot;); CHECK_EXIT(P(2) != -1, &quot;&quot;); break; default: printsem(0); CHECK_EXIT(V(2) != -1, &quot;&quot;); CHECK_EXIT(P(1) != -1, &quot;&quot;); printsem(0); CHECK_EXIT(incrsem(0, 1, 0) != -1, &quot;&quot;); printsem(0); CHECK_EXIT(V(2) != -1, &quot;&quot;); wait(NULL); pid_t lastpid = printsem(0); if(lastpid == taskid) { logger(LOG_INFO, &quot;IPC_UNDO will change last pid&quot;); } else if (lastpid == getpid()) { logger(LOG_INFO, &quot;IPC_UNDO will not change last pid&quot;); } else { logger(LOG_INFO, &quot;other process change sem&quot;); } break; }} 47.6使用命名管道实现一个二元信号量协议。提供函数来预留、释放以及有条件地预留信号量。 需要共享fd123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203//// Created by root on 9/13/23.//#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;stdbool.h&gt;#include &lt;stddef.h&gt;#include &lt;syslog.h&gt;#include &lt;wait.h&gt;#include &lt;sys/stat.h&gt;#define DEBUG_LEVEL LOG_DEBUG#ifndef DEBUG_LEVEL#define DEBUG_LEVEL LOG_INFO#endifFILE *logfile = NULL;bool syslog_enable = false;void __attribute__ ((constructor)) init() { logfile = stderr;}#define alloc_sprintf(__alloc_sprintf_str, __format...) do { \\ int __alloc_sprintf_len = snprintf(NULL, 0, __format); \\ (__alloc_sprintf_str) = malloc(__alloc_sprintf_len+1); \\ if(__alloc_sprintf_str != NULL) \\ snprintf(__alloc_sprintf_str, __alloc_sprintf_len+1, __format); \\} while(0)#define logger(level, msg...) do { \\ if(level &lt;= DEBUG_LEVEL) { \\ fprintf(logfile, msg); \\ fprintf(logfile, &quot;\\n&quot;); \\ } \\ if(syslog_enable) { \\ char *data; \\ alloc_sprintf(data, msg); \\ syslog(level, &quot;%s&quot;, data); \\ safe_free(data); \\ } \\} while(0)#define COND_RET(x, ret, msg...) \\ do { \\ if(!(x)) { \\ if(errno == 0)logger(LOG_ERR, &quot;%s:%d\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__, #x); \\ else logger(LOG_ERR, &quot;%s:%d\\nerror: %s\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__,strerror(errno), #x); \\ logger(LOG_ERR, msg); \\ logger(LOG_ERR, &quot;\\n&quot;); \\ ret \\ } \\ } while(0)#define CHECK(x, msg...) COND_RET(x, return -1;, msg)#define CHECK_EXIT(x, msg...) COND_RET(x, exit(EXIT_FAILURE);, msg)#define CHECK_LOG(x, msg...) COND_RET(x, ;, msg)#define safe_free(__safe_free_ptr) do { if(__safe_free_ptr) { free(__safe_free_ptr); (__safe_free_ptr) = NULL;} } while(0)#define BUFFER_SIZE 4096key_t sem_key = 0;int sem_id = 0;pid_t taskid = 0;int safe_atoi(const char *num) { const char *ptr = num; while (ptr &amp;&amp; *ptr) { CHECK_EXIT(*ptr &gt;= '0' &amp;&amp; *ptr &lt;= '9', &quot;&quot;); ptr++; } return atoi(num);}typedef struct { char id[L_tmpnam]; int rfd, wfd;}PvFifo_t;#include &lt;time.h&gt;PvFifo_t *newPvFifo() { PvFifo_t *pvFifo = malloc(sizeof(PvFifo_t)); char *id; alloc_sprintf(id, &quot;PvFifo%d&quot;, rand()); strcpy(pvFifo-&gt;id, id); pvFifo-&gt;rfd = pvFifo-&gt;wfd = -1; if(mkfifo(id, 0666) == -1) { CHECK_LOG(false, &quot;&quot;); return NULL; } logger(LOG_INFO, &quot;new fifo: %s&quot;, id); return pvFifo;}int P(PvFifo_t *pvFifo) { CHECK(pvFifo != NULL, &quot;pvFifo is NULL&quot;); pvFifo-&gt;wfd = open(pvFifo-&gt;id, O_WRONLY); close(pvFifo-&gt;wfd); close(pvFifo-&gt;rfd); pvFifo-&gt;wfd = -1; return 0;}int V(PvFifo_t *pvFifo) { CHECK(pvFifo != NULL, &quot;pvFifo is NULL&quot;); pvFifo-&gt;rfd = open(pvFifo-&gt;id, O_RDONLY | O_NONBLOCK); return 0;}PvFifo_t *initAvai() { PvFifo_t *pvFifo = newPvFifo(); if(!pvFifo) { CHECK_LOG(false, &quot;&quot;); } else if(V(pvFifo) != 0) { CHECK_LOG(false, &quot;&quot;); safe_free(pvFifo); } logger(LOG_INFO, &quot;init :%s&quot;, pvFifo-&gt;id); return pvFifo;}PvFifo_t *initInUse() { return newPvFifo();}int destroy(PvFifo_t *id) { if(id-&gt;rfd != -1) close(id-&gt;rfd); if(id-&gt;wfd != -1) close(id-&gt;wfd); return unlink(id-&gt;id);}#define CRITICAL_LEN 1024int critial_cnt = -1;int criticalArea[CRITICAL_LEN];PvFifo_t *id = NULL;void rmPvFifo() { if(id) destroy(id);}pthread_t producer_t, consumer_t;void exithandler(int sig) { pthread_kill(producer_t, SIGKILL); pthread_kill(consumer_t, SIGKILL); if(sig == SIGHUP)exit(0); else exit(1);}void *consumer(void *args) { while(1) { int n; bool ok = false; CHECK_EXIT(P(id) != -1, &quot;&quot;); if(critial_cnt &gt;= 0) { n = criticalArea[critial_cnt--]; ok = true; } CHECK_EXIT(V(id) != -1, &quot;&quot;); if(ok) logger(LOG_INFO, &quot;consume: %d&quot;, n); else sleep(1); }}void *producer(void *arg) { atexit(rmPvFifo); while(1) { int n; bool ok = false; CHECK_EXIT(P(id) != -1, &quot;&quot;); if(critial_cnt &lt; CRITICAL_LEN - 1) { critial_cnt++; n = critial_cnt; criticalArea[critial_cnt] = n; ok = true; } CHECK_EXIT(V(id) != -1, &quot;&quot;); if(ok) logger(LOG_INFO, &quot;produce: %d&quot;, n); else sleep(1); }}int main(int argc, char **argv) { srand(time(NULL)); logfile = stderr; id = initAvai(); CHECK_EXIT(id != NULL, &quot;&quot;); signal(SIGHUP, exithandler); signal(SIGTERM, exithandler); signal(SIGALRM, exithandler); alarm(10); pthread_create(&amp;producer_t, NULL, producer, NULL); pthread_create(&amp;consumer_t, NULL, consumer, NULL);// pthread_exit(NULL); pthread_join(producer_t, NULL); pthread_join(consumer_t, NULL);} 不需要共享fd123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235//// Created by root on 9/13/23.//#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;stdbool.h&gt;#include &lt;stddef.h&gt;#include &lt;syslog.h&gt;#include &lt;wait.h&gt;#include &lt;sys/stat.h&gt;#define DEBUG_LEVEL LOG_DEBUG#ifndef DEBUG_LEVEL#define DEBUG_LEVEL LOG_INFO#endifFILE *logfile = NULL;bool syslog_enable = false;void __attribute__ ((constructor)) init() { logfile = stderr;}#define alloc_sprintf(__alloc_sprintf_str, __format...) do { \\ int __alloc_sprintf_len = snprintf(NULL, 0, __format); \\ (__alloc_sprintf_str) = malloc(__alloc_sprintf_len+1); \\ if(__alloc_sprintf_str != NULL) \\ snprintf(__alloc_sprintf_str, __alloc_sprintf_len+1, __format); \\} while(0)#define logger(level, msg...) do { \\ if(level &lt;= DEBUG_LEVEL) { \\ fprintf(logfile, msg); \\ fprintf(logfile, &quot;\\n&quot;); \\ } \\ if(syslog_enable) { \\ char *__data; \\ alloc_sprintf(__data, msg); \\ syslog(level, &quot;%s&quot;, __data); \\ safe_free(__data); \\ } \\} while(0)#define COND_RET(x, ret, msg...) \\ do { \\ if(!(x)) { \\ if(errno == 0)logger(LOG_ERR, &quot;%s:%d\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__, #x); \\ else logger(LOG_ERR, &quot;%s:%d\\nerror: %s\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__,strerror(errno), #x); \\ logger(LOG_ERR, msg); \\ logger(LOG_ERR, &quot;\\n&quot;); \\ ret \\ } \\ } while(0)#define CHECK(x, msg...) COND_RET(x, return -1;, msg)#define CHECK_EXIT(x, msg...) COND_RET(x, exit(EXIT_FAILURE);, msg)#define CHECK_LOG(x, msg...) COND_RET(x, ;, msg)#define safe_free(__safe_free_ptr) do { if(__safe_free_ptr) { free(__safe_free_ptr); (__safe_free_ptr) = NULL;} } while(0)#define BUFFER_SIZE 4096key_t sem_key = 0;int sem_id = 0;pid_t taskid = 0;int safe_atoi(const char *num) { const char *ptr = num; while (ptr &amp;&amp; *ptr) { CHECK_EXIT(*ptr &gt;= '0' &amp;&amp; *ptr &lt;= '9', &quot;&quot;); ptr++; } return atoi(num);}typedef struct { char id[L_tmpnam]; int rfd, wfd;}PvFifo_t;int openPvfifo(char *id, int rw) { int fd = open(id, rw | O_NONBLOCK); CHECK(fd != -1, &quot;&quot;); int flag; if((flag = fcntl(fd, F_GETFL)) == -1) { CHECK_LOG(false, &quot;&quot;); close(fd); return -1; } flag &amp;= ~O_NONBLOCK; if(fcntl(fd, F_SETFL, flag) == -1) { CHECK_LOG(false, &quot;&quot;); close(fd); return -1; } return fd;}PvFifo_t *newPvFifo(char *id) { PvFifo_t *pvFifo = malloc(sizeof(PvFifo_t)); strcpy(pvFifo-&gt;id, id); if(mkfifo(id, 0666) == -1) { if(errno != EEXIST) { CHECK_LOG(false, &quot;&quot;); return NULL; } } pvFifo-&gt;rfd = openPvfifo(id, O_RDONLY); pvFifo-&gt;wfd = -1; logger(LOG_INFO, &quot;new fifo: %s&quot;, id); return pvFifo;}int P(PvFifo_t *pvFifo) { CHECK(pvFifo != NULL, &quot;pvFifo is NULL&quot;); int ret = 0; bool buf; if((ret = read(pvFifo-&gt;rfd, &amp;buf, sizeof(bool)) != sizeof(bool))) { CHECK_LOG(false, &quot;&quot;); } else ret = 0; return ret;}int V(PvFifo_t *pvFifo) { CHECK(pvFifo != NULL, &quot;pvFifo is NULL&quot;); pvFifo-&gt;wfd = openPvfifo(pvFifo-&gt;id, O_WRONLY); CHECK(pvFifo-&gt;wfd != -1, &quot;&quot;); int ret = 0; if((ret = write(pvFifo-&gt;wfd, &amp;(bool[]){true}, sizeof(bool)) != sizeof(bool))) { CHECK_LOG(false, &quot;&quot;); } else ret = 0; close(pvFifo-&gt;wfd); return ret;}PvFifo_t *initAvai(char *id) { PvFifo_t *pvFifo = newPvFifo(id); if(!pvFifo) { CHECK_LOG(false, &quot;&quot;); } else if(V(pvFifo) != 0) { CHECK_LOG(false, &quot;&quot;); safe_free(pvFifo); } logger(LOG_INFO, &quot;init :%s&quot;, pvFifo-&gt;id); return pvFifo;}PvFifo_t *initInUse(char *id) { return newPvFifo(id);}int destroy(PvFifo_t *id) { if(id-&gt;rfd != -1) close(id-&gt;rfd); if(id-&gt;wfd != -1) close(id-&gt;wfd); return unlink(id-&gt;id);}PvFifo_t *id = NULL;void rmPvFifo() { if(id) destroy(id);}char *fn = NULL;void exithandler(int sig) { if(fn) unlink(fn); if(sig == SIGHUP)exit(0); else exit(1);}int comm_file;#define MAX 65536void *consumer(void *args) { while(1) { CHECK_EXIT(P(id) != -1, &quot;&quot;); int offset; CHECK_EXIT(pread(comm_file, &amp;offset, sizeof(int), 0) == sizeof(int), &quot;&quot;); if(offset &gt; 1) { int data; CHECK_EXIT(pread(comm_file, &amp;data, sizeof(int), (offset - 1) * sizeof(int)) == sizeof(int), &quot;&quot;); logger(LOG_INFO, &quot;consume: %d&quot;, data); offset--; CHECK_EXIT(pwrite(comm_file, &amp;offset, sizeof(int), 0) == sizeof(int), &quot;&quot;); } else sleep(1); CHECK_EXIT(V(id) != -1, &quot;&quot;); }}void *producer(void *arg) { atexit(rmPvFifo); while(1) { int offset; CHECK_EXIT(P(id) != -1, &quot;&quot;); CHECK_EXIT(pread(comm_file, &amp;offset, sizeof(int), 0) == sizeof(int), &quot;&quot;); if(offset &lt; MAX) { int data = offset; CHECK_EXIT(pwrite(comm_file, &amp;data, sizeof(int), offset * sizeof(int)) == sizeof(int), &quot;&quot;); offset++; CHECK_EXIT(pwrite(comm_file, &amp;offset, sizeof(int), 0) == sizeof(int), &quot;&quot;); logger(LOG_INFO, &quot;produce: %d&quot;, data); } else sleep(1); CHECK_EXIT(V(id) != -1, &quot;&quot;); }}int main(int argc, char **argv) { CHECK_EXIT(argc &gt; 1, &quot;&quot;); id = initAvai(&quot;meoww&quot;); CHECK_EXIT(id != NULL, &quot;&quot;); signal(SIGHUP, exithandler); signal(SIGTERM, exithandler); signal(SIGINT, exithandler); signal(SIGALRM, exithandler); alloc_sprintf(fn, &quot;%s-comm&quot;, argv[0]); comm_file = open(fn, O_CREAT | O_EXCL | O_RDWR, 0666); if(comm_file == -1) { if(errno == EEXIST) { comm_file = open(fn, O_RDWR, 0666); } else { CHECK_LOG(false, &quot;&quot;); } } else { CHECK_EXIT(pwrite(comm_file, &amp;(int[]){1}, sizeof(int), 0) == sizeof(int), &quot;&quot;); } if(!strcmp(argv[1], &quot;producer&quot;)) { producer(NULL); } else { consumer(NULL); }} 47.5在VMS操作系统上，Digital提供了一种类似于二元信号量的同步方法，它被称为事件标记(event flag)。一个事件标记可以取两个值clear和set,并且在其之上可以执行下面4种操作：setEventFlag来设置标记；clearEventFlag来清除标记；waitForEventFlag阻塞直到标记被设置；getFlagState获取标记的当前状态。使用System V信号量为事件标记设计一种实现。这个实现要求上面每个函数都接收两个参数：一个是信号量标识符，一个是信号量序号。（在考虑waitForEventFlag操作时将会发现为clear和set状态取值不是一件容易的事情。) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349//// Created by root on 9/13/23.//#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;stdbool.h&gt;#include &lt;stddef.h&gt;#include &lt;syslog.h&gt;#include &lt;wait.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;#define DEBUG_LEVEL LOG_DEBUG#ifndef DEBUG_LEVEL#define DEBUG_LEVEL LOG_INFO#endif#define STRING_MSG &quot;MSG&quot;FILE *logfile = NULL;bool syslog_enable = false;void __attribute__ ((constructor)) init() { syslog_enable = false; logfile = stderr;}#define alloc_sprintf(__alloc_sprintf_str, __format...) do { \\ int __alloc_sprintf_len = snprintf(NULL, 0, __format); \\ (__alloc_sprintf_str) = malloc(__alloc_sprintf_len+1); \\ if(__alloc_sprintf_str != NULL) \\ snprintf(__alloc_sprintf_str, __alloc_sprintf_len+1, __format); \\} while(0)#define logger(level, msg...) do { \\ if(level &lt;= DEBUG_LEVEL) { \\ fprintf(logfile, &quot;[%ld] &quot;, (long) getpid()); \\ fprintf(logfile, msg); \\ fprintf(logfile, &quot;\\n&quot;); \\ } \\ if(syslog_enable) { \\ char *data; \\ alloc_sprintf(data, msg); \\ syslog(level, &quot;%s&quot;, data); \\ safe_free(data); \\ } \\} while(0)#define COND_RET(x, ret, msg...) \\ do { \\ if(!(x)) { \\ if(errno != 0) logger(LOG_ERR, &quot;Error(%d): %s&quot;, errno, strerror(errno)); \\ logger(LOG_ERR, &quot;%s:%d&quot;, __FILE__, __LINE__); \\ logger(LOG_ERR, &quot;unmet condition:\\&quot;%s\\&quot;&quot;, #x); \\ logger(LOG_ERR, msg); \\ ret; \\ } \\ errno = 0; \\ } while(0)#define CHECK(x, msg...) COND_RET(x, return -1;, msg)#define CHECK_EXIT(x, msg...) COND_RET(x, exit(EXIT_FAILURE);, msg)#define CHECK_LOG(x, msg...) COND_RET(x, ;, msg)#define safe_free(__safe_free_ptr) do { if(__safe_free_ptr) { free(__safe_free_ptr); (__safe_free_ptr) = NULL;} } while(0)#define BUFFER_SIZE 4096union semun { int val; struct semid_ds *buf; unsigned short *array;#if defined(__linux__) struct seminfo *__buf;#endif};typedef struct { int semid;}EventFlag_t;int incrsem(int sem_id, int semnum, short incr, short flg) { struct sembuf sembuf; sembuf = (struct sembuf){ .sem_num=semnum, .sem_flg=flg, .sem_op=incr }; return semop(sem_id, &amp;sembuf, 1);}int P(int sem_id) { return incrsem(sem_id, 0, -1, 0);}int V(int sem_id) { return incrsem(sem_id, 0, 1, 0);}int waitFor(int sem_id) { return incrsem(sem_id, 1, 0, 0);}int getsem(int sem_id, int semnum, short *n) { union semun arg; int ret = semctl(sem_id, semnum, GETVAL, arg); *n = ret; return ret;}int setsem(int sem_id, int semnum, short n) { union semun arg; arg.val = n; return semctl(sem_id, semnum, SETVAL, arg);}int notifyAll(int sem_id) { return setsem(sem_id, 1, 0);}EventFlag_t *newEventFlag(const char *file, char x) { EventFlag_t eventFlag; key_t key = ftok(file, x); eventFlag.semid = semget(key, 4, IPC_CREAT | IPC_EXCL | 0666); // sem[0] as mutex, sem[1] as notifier, sem[2]|sem[3] as flag union semun arg; if(eventFlag.semid == -1) { if(errno == EEXIST) { eventFlag.semid = semget(key, 4, 0666); COND_RET(eventFlag.semid != -1, return NULL, STRING_MSG); struct semid_ds ds; arg.buf = &amp;ds; COND_RET(semctl(eventFlag.semid, 0, IPC_STAT, arg) != -1, return NULL, STRING_MSG); while (ds.sem_otime == 0) { logger(LOG_INFO, &quot;waiting for sem init&quot;); sleep(1); COND_RET(semctl(eventFlag.semid, 0, IPC_STAT, arg) != -1, return NULL, STRING_MSG); } logger(LOG_INFO, &quot;semget get old&quot;); } else { CHECK_LOG(false, STRING_MSG); return NULL; } } else { arg.array = (unsigned short *)&amp;(unsigned short[]){0, 0, 0, 0}; // sem[0] = 1, sem[1] = 0 if(semctl(eventFlag.semid, 0, SETALL, arg) == -1) { CHECK_LOG(false, STRING_MSG); CHECK_LOG(semctl(eventFlag.semid, 0, IPC_RMID) != -1, STRING_MSG); return NULL; } if(incrsem(eventFlag.semid, 0,1,0) == -1) { CHECK_LOG(false, STRING_MSG); CHECK_LOG(semctl(eventFlag.semid, 0, IPC_RMID) != -1, STRING_MSG); return NULL; } logger(LOG_INFO, &quot;semget create new&quot;); } return memcpy(malloc(sizeof(EventFlag_t)), &amp;eventFlag, sizeof(EventFlag_t));}int setEventFlag(EventFlag_t *eventFlag, int flag) { CHECK(P(eventFlag-&gt;semid) != -1, STRING_MSG); short currentFlag; CHECK(getsem(eventFlag-&gt;semid, 2, &amp;currentFlag) != -1, STRING_MSG); CHECK(setsem(eventFlag-&gt;semid, 2, currentFlag | (flag &amp; 0xffff)) != -1, STRING_MSG); CHECK(getsem(eventFlag-&gt;semid, 3, &amp;currentFlag) != -1, STRING_MSG); CHECK(setsem(eventFlag-&gt;semid, 3, currentFlag | ((flag &gt;&gt; 16) &amp; 0xffff)) != -1, STRING_MSG); CHECK(notifyAll(eventFlag-&gt;semid) != -1, STRING_MSG); CHECK(V(eventFlag-&gt;semid) != -1, STRING_MSG); return 0;}int clearEventFlag(EventFlag_t *eventFlag, int flag) { CHECK(P(eventFlag-&gt;semid) != -1, STRING_MSG); short currentFlag; CHECK(getsem(eventFlag-&gt;semid, 2, &amp;currentFlag) != -1, STRING_MSG); CHECK(setsem(eventFlag-&gt;semid, 2, currentFlag &amp; ~(flag &amp; 0xffff)) != -1, STRING_MSG); CHECK(getsem(eventFlag-&gt;semid, 3, &amp;currentFlag) != -1, STRING_MSG); CHECK(setsem(eventFlag-&gt;semid, 3, currentFlag &amp; ~((flag &gt;&gt; 16) &amp; 0xffff)) != -1, STRING_MSG);// CHECK(notifyAll(eventFlag-&gt;semid) != -1, STRING_MSG); CHECK(V(eventFlag-&gt;semid) != -1, STRING_MSG); return 0;}int __getEventFlag(EventFlag_t *eventFlag, int *flag) { if(flag) { short currentFlag = 0; int ret = 0; CHECK(getsem(eventFlag-&gt;semid, 2, &amp;currentFlag) != -1, STRING_MSG); ret |= currentFlag; CHECK(getsem(eventFlag-&gt;semid, 3, &amp;currentFlag) != -1, STRING_MSG); ret |= currentFlag &lt;&lt; 16; *flag = ret; return 0; } return -1;}int getEventFlag(EventFlag_t *eventFlag, int *flag) { CHECK(P(eventFlag-&gt;semid) != -1, STRING_MSG); CHECK_LOG(__getEventFlag(eventFlag, flag) != -1, STRING_MSG); CHECK(V(eventFlag-&gt;semid) != -1, STRING_MSG); return 0;}#define waitForMethod(eventFlag, flag, method) do { \\ int currentFlag;\\ CHECK(P(eventFlag-&gt;semid) != -1, STRING_MSG);\\ __getEventFlag(eventFlag, &amp;currentFlag); \\ while (method) {\\ CHECK(V(eventFlag-&gt;semid) != -1, STRING_MSG);\\ CHECK(waitFor(eventFlag-&gt;semid) != -1, STRING_MSG);\\ CHECK(P(eventFlag-&gt;semid) != -1, STRING_MSG);\\ __getEventFlag(eventFlag, &amp;currentFlag); \\ }\\ CHECK(V(eventFlag-&gt;semid) != -1, STRING_MSG);\\} while(0)int waitForAny(EventFlag_t *eventFlag, int flag) { waitForMethod(eventFlag, flag, (currentFlag &amp; flag) == 0); return 0;}int waitForAll(EventFlag_t *eventFlag, int flag) { waitForMethod(eventFlag, flag, (currentFlag &amp; flag) != flag); return 0;}void destroyEventFlag(EventFlag_t **eventFlag) { if(eventFlag) { if(*eventFlag) { semctl((*eventFlag)-&gt;semid, 0, IPC_RMID); } safe_free(*eventFlag); }}EventFlag_t *eventFlag = NULL;int safe_atoi(const char *str) { if(!str) { CHECK_LOG(false, &quot;safe atoi, str is null&quot;); fflush(NULL); raise(SIGABRT); } const char *p = str; while(*p) { if(*p &gt; '9' || *p &lt; '0') { CHECK_LOG(false, &quot;safe atoi, not valid char: %c&quot;, *p); fflush(NULL); raise(SIGABRT); } p++; } return atoi(str);}void printFlag(int flag) { logger(LOG_INFO, &quot;printFlag&quot;); int mask = 1; if(mask &amp; flag) logger(LOG_INFO, &quot;%d&quot;, 0); for(int cnt = 1; cnt &lt; 32; cnt++) { mask &lt;&lt;= 1; if(mask &amp; flag) logger(LOG_INFO, &quot;%d&quot;, cnt); }}#define printINT(info, x) logger(LOG_INFO, &quot;(&quot;#info&quot;).&quot;#x&quot;: %d&quot;, (info).x)#define printUINT(info, x) logger(LOG_INFO, &quot;(&quot;#info&quot;).&quot;#x&quot;: %ld&quot;, (info).x)#define printTIME(ds, x) logger(LOG_INFO, &quot;(&quot;#ds&quot;).&quot;#x&quot;: %s&quot;, ctime(&amp;(ds).x))int printInfo(int id) { union semun arg; struct seminfo info; struct semid_ds ds; arg.__buf = &amp;info; CHECK(semctl(id, 0, SEM_INFO, arg) != -1, STRING_MSG); printINT(info, semmap); printINT(info, semmni); printINT(info, semmns); printINT(info, semmnu); printINT(info, semmsl); printINT(info, semopm); printINT(info, semume); printINT(info, semusz); printINT(info, semvmx); printINT(info, semaem); arg.buf = &amp;ds; CHECK(semctl(id, 0, IPC_STAT, arg) != -1, STRING_MSG); printUINT(ds, sem_nsems); printTIME(ds, sem_otime); printTIME(ds, sem_ctime); return 0;}int wrapPrintFlag(int flag, int (*func)(EventFlag_t *, int)) { int currentFlag = 0; CHECK_LOG(getEventFlag(eventFlag, &amp;currentFlag) != -1, STRING_MSG); printFlag(currentFlag); CHECK_LOG((*func)(eventFlag, flag) != -1, STRING_MSG); CHECK_LOG(getEventFlag(eventFlag, &amp;currentFlag) != -1, STRING_MSG); printFlag(currentFlag); return 0;}#define FLAG_RANGE(flg) ((16 &lt;= (flg) &amp;&amp; (flg) &lt; 31) || (0 &lt;= (flg) &amp;&amp; (flg) &lt; 15))#define XXSTRING(s) XSTRING(s) //与层数相关#define XSTRING(s) STRING(s)#define STRING(s) #sint main(int argc, char **argv) { CHECK_EXIT(argc &gt; 1, &quot;Usage: %s destroy|waitAny|waitAll|add|clear|get [flag]&quot;, argv[0]); eventFlag = newEventFlag(argv[0], 'x'); CHECK_EXIT(eventFlag != NULL, STRING_MSG); int flag = 0; for(int i = 2; i &lt; argc; i++) { int flg = safe_atoi(argv[i]); if(!FLAG_RANGE(flg)){ CHECK_LOG(false, &quot;Usage: %s&quot;, XXSTRING(FLAG_RANGE(flg))); continue; } flag |= (1 &lt;&lt; flg); } printInfo(eventFlag-&gt;semid); logger(LOG_INFO, &quot;start %s&quot;, argv[1]); if(!strcmp(argv[1], &quot;waitAny&quot;)) { CHECK_LOG(wrapPrintFlag(flag, waitForAny) != -1, STRING_MSG); } else if(!strcmp(argv[1], &quot;waitAll&quot;)) { CHECK_LOG(wrapPrintFlag(flag, waitForAll) != -1, STRING_MSG); } else if(!strcmp(argv[1], &quot;add&quot;)) { CHECK_LOG(wrapPrintFlag(flag, setEventFlag) != -1, STRING_MSG); } else if(!strcmp(argv[1], &quot;clear&quot;)) { CHECK_LOG(wrapPrintFlag(flag, clearEventFlag) != -1, STRING_MSG); } else if(!strcmp(argv[1], &quot;get&quot;)) { CHECK_LOG(getEventFlag(eventFlag, &amp;flag) != -1, STRING_MSG); printFlag(flag); } else if(!strcmp(argv[1], &quot;destroy&quot;)) { destroyEventFlag(&amp;eventFlag); } else { CHECK_EXIT(false, &quot;Usage: %s waitAny|waitAll|add|clear|get [flag]&quot;, argv[0]); } logger(LOG_INFO, &quot;end %s&quot;, argv[1]);}","link":"/home/2023/09/13/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha47/"},{"title":"cha49.内存映射","text":"读书笔记 文件映射 匿名映射 私有映射 老刘吃独食 (文件), 别人可以看 (读取同一块内存区域), 但是想吃 (修改, 写时复制)需要自己做一份一模一样的(修改不会反应到文件上) 老刘吃空气 (全0大块内存), 给儿子看, 儿子想吃需要自己做一份一样的 (写时复制), 不给老李家看, 不给老李家吃 共享映射 老刘吃饭 (文件), 给儿子吃 (子进程可访问 修改), 也给老李吃 (非相关进程也可访问 修改)(修改会反应到文件上) 老刘吃空气 (全0内存), 给儿子吃 (子进程可访问 修改), 不给老李家吃 (非相关进程不可访问 修改) 创建公共头文件为了减少每个练习中重复的定义，如logger, safe_free，定义一个头文件共所有程序使用 utils.hinclude/utils.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#ifndef __MEOW_UTILS__#define __MEOW_UTILS__//// Created by root on 9/14/23.//#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;stdbool.h&gt;#include &lt;stddef.h&gt;#include &lt;syslog.h&gt;#include &lt;wait.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/mman.h&gt;extern FILE *logfile;extern bool syslog_enable;#ifndef DEBUG_LEVEL#define DEBUG_LEVEL LOG_DEBUG#endif#define STRING_MSG &quot;ERROR OCCURED!&quot;#define alloc_sprintf(__alloc_sprintf_str, __format...) do { \\ int __alloc_sprintf_len = snprintf(NULL, 0, __format); \\ (__alloc_sprintf_str) = malloc(__alloc_sprintf_len+1); \\ if(__alloc_sprintf_str != NULL) \\ snprintf(__alloc_sprintf_str, __alloc_sprintf_len+1, __format); \\} while(0)#define logger(level, msg...) do { \\ if(level &lt;= DEBUG_LEVEL) { \\ fprintf(logfile, &quot;[%ld] &quot;, (long) getpid()); \\ fprintf(logfile, msg); \\ fprintf(logfile, &quot;\\n&quot;); \\ } \\ if(syslog_enable) { \\ char *__syslog_enable__data; \\ alloc_sprintf(__syslog_enable__data, msg); \\ syslog(level, &quot;%s&quot;, __syslog_enable__data); \\ safe_free(__syslog_enable__data); \\ } \\} while(0)#define CHECK_RET_MSG_IMPL(x, strx, ret, msg...) \\ logger(LOG_DEBUG, &quot;checking: \\&quot;%s\\&quot;&quot;, strx); \\ do { \\ if(!(x)) { \\ if(errno != 0) logger(LOG_ERR, &quot;Error(%d): %s&quot;, errno, strerror(errno)); \\ logger(LOG_ERR, &quot;%s:%d&quot;, __FILE__, __LINE__); \\ logger(LOG_ERR, &quot;unmet condition:\\&quot;%s\\&quot;&quot;, strx); \\ logger(LOG_ERR, msg); \\ ret; \\ } \\ errno = 0; \\ } while(0)#define CHECK_RET_MSG(x, ret, msg...) CHECK_RET_MSG_IMPL(x, #x, ret, msg...)#define CHECK_MSG(x, msg...) CHECK_RET_MSG_IMPL(x, #x, return -1;, msg)#define CHECK_EXIT_MSG(x, msg...) CHECK_RET_MSG_IMPL(x, #x, exit(EXIT_FAILURE);, msg)#define CHECK_LOG_MSG(x, msg...) CHECK_RET_MSG_IMPL(x, #x, ;, msg)#define CHECK_RET(x, ret) CHECK_RET_MSG_IMPL(x, #x, ret;, STRING_MSG)#define CHECK(x) CHECK_RET_MSG_IMPL(x, #x, return -1;, STRING_MSG)#define CHECK_EXIT(x) CHECK_RET_MSG_IMPL(x, #x, exit(EXIT_FAILURE);, STRING_MSG)#define CHECK_LOG(x) CHECK_RET_MSG_IMPL(x, #x, ;, STRING_MSG)int safe_atoi(const char *num, int *ret);#define safe_free(__safe_free_ptr) do { if(__safe_free_ptr) { free(__safe_free_ptr); (__safe_free_ptr) = NULL;} } while(0)#endif utils.cutils/utils.h12345678910111213141516171819#include &quot;utils.h&quot;FILE *logfile = NULL;bool syslog_enable = false;void __attribute__ ((constructor)) init() { syslog_enable = false; logfile = stderr;}int safe_atoi(const char *num, int *ret) { CHECK(ret != NULL); CHECK(num != NULL); const char *ptr = num; while (*ptr) { CHECK(*ptr &gt;= '0' &amp;&amp; *ptr &lt;= '9'); ptr++; } *ret = atoi(num); return 0;} 生成CMakeLists.txt并编译代码文件全部放入目录chaXX/src下，并且一个练习只用一个文件 build.sh12345678910111213141516171819202122OUTPUT=CMakeLists.txtfunction writer() { echo $@ | tee -a $OUTPUT}rm $OUTPUTwriter &quot;cmake_minimum_required(VERSION 3.25.0)&quot;writer &quot;aux_source_directory(../utils SRC_UTILS)&quot;writer &quot;include_directories(../include)&quot;for file in `ls src`; do out=`echo $file | awk ' { len=split($0, arr, &quot;.&quot;); printf arr[1];for(i = 2; i &lt; len; i++) printf &quot;.&quot;arr[i] } '` writer &quot;add_executable($out src/$file \\${SRC_UTILS})&quot;donefor arg in $@; do if [ ${arg:0:2} == &quot;-D&quot; ]; then writer &quot;ADD_DEFINITIONS($arg)&quot; fidonecmake .make 49.1使用mmap和memcpy调用(不是read0或write0)编写一个类似于cp的程序来将一个源文件复制到目标文件。使用 fstat获取输入文件的大小，然后可以使用这个大小来设置所需的内存映射的大小，使用 fruncate设置输出文件的大小。 12345678910111213141516171819202122232425262728//// Created by root on 9/14/23.//#include &quot;utils.h&quot;int main(int argc, char *argv[]) { CHECK_EXIT(argc == 3, &quot;Usage: %s src dest&quot;, argv[0]); int src_fd = open(argv[1], O_RDONLY); CHECK_EXIT(src_fd != -1, STRING_MSG); int dest_fd = open(argv[2], O_RDWR | O_CREAT, 0666); CHECK_EXIT(dest_fd != -1, STRING_MSG); struct stat src_stat; CHECK_EXIT(fstat(src_fd, &amp;src_stat) != -1, STRING_MSG); CHECK_EXIT(ftruncate(dest_fd, src_stat.st_size) != -1, STRING_MSG); void *src_map = mmap(NULL, src_stat.st_size, PROT_READ, MAP_SHARED, src_fd, 0); void *dest_map = mmap(NULL, src_stat.st_size, PROT_WRITE, MAP_SHARED, dest_fd, 0); memcpy(dest_map, src_map, src_stat.st_size); CHECK_EXIT(close(src_fd) != -1, STRING_MSG); CHECK_EXIT(close(dest_fd) != -1, STRING_MSG); CHECK_EXIT(munmap(src_map, src_stat.st_size) != -1, STRING_MSG); CHECK_EXIT(munmap(dest_map, src_stat.st_size) != -1, STRING_MSG); return 0;} 49.2重写程序清单48-2(svshm_xf_writer.c)和程序清单48-3(svshm xfr_reader.c)使它们使用共享内存映射来取代SystemV共享内存 创建pvutil工具include/pvutils.h123456789101112131415161718192021222324252627282930#ifndef __MEOW_PV_UTILS__#define __MEOW_PV_UTILS__#include &lt;sys/sem.h&gt;#include &lt;sys/ipc.h&gt;union semun { int val; struct semid_ds *buf; unsigned short *array;#if defined(__linux__) struct seminfo *__buf;#endif};int P(int semnum);int testP(int semnum);int V(int semnum);int initPVByFile(const char *filename, char x, int semcnt);int initPVByKey(key_t key, int semcnt);int initAvai(int semnum);int initInUse(int semnum);int rmPV();#endif utils/pvutils.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &quot;pvutils.h&quot;#include &quot;utils.h&quot;static key_t __sem_key = -1;static int __sem_id = -1;int rmPV() { int id = __sem_id; __sem_key = -1; __sem_id = -1; return semctl(id, 0, IPC_RMID);}int incrsem(int semnum, short incr, short flg) { struct sembuf sembuf; sembuf = (struct sembuf){ .sem_num=semnum, .sem_flg=flg, .sem_op=incr }; return semop(__sem_id, &amp;sembuf, 1);}int setVal(int n, int semnum) { union semun arg; arg.val = n; CHECK(semctl(__sem_id, semnum, SETVAL, arg) != -1); return 0;}int initAvai(int semnum) { CHECK(setVal(0, semnum) != -1); CHECK(incrsem(semnum, 1, 0) != -1); return 0;}int initInUse(int semnum) { CHECK(setVal(0, semnum) != -1); CHECK(incrsem(semnum, 0, 0) != -1); return 0;}int P(int semnum) { int ret; do { ret = incrsem(semnum, -1, 0); } while (ret == -1 &amp;&amp; errno == EINTR); return ret;}int testP(int semnum) { // return 1 if sem would be blocked, return 0 if sem would not be blocked. int ret = incrsem(semnum, -1, IPC_NOWAIT); if(ret == -1) { if(errno == EAGAIN)return 1; else return ret; } return 0;}int V(int semnum) { return incrsem(semnum, 1, 0);}int setAll(unsigned short *array) { union semun arg; arg.array = array; CHECK(semctl(__sem_id, 0, SETALL, arg) != -1); return 0;}int __initPV(int semcnt) { semcnt++; // sem[0] for waiting init, sem[1...n] for user if((__sem_id = semget(__sem_key, semcnt, IPC_CREAT | IPC_EXCL | 0666)) != -1) { unsigned short *array = malloc(semcnt * sizeof(unsigned short)); memset(array, 0, semcnt * sizeof(unsigned short)); CHECK(array != NULL); CHECK(setAll(array) != -1); CHECK(initInUse(0) != -1); free(array); } else { CHECK(errno == EEXIST); __sem_id = semget(__sem_key, semcnt, 0666); struct semid_ds ds; union semun arg; arg.buf = &amp;ds; CHECK(semctl(__sem_id, 0, IPC_STAT, arg) != -1); while (ds.sem_otime == 0) { logger(LOG_DEBUG, &quot;waiting for sem init&quot;); sleep(1); CHECK(semctl(__sem_id, 0, IPC_STAT, arg) != -1); } } logger(LOG_DEBUG, &quot;finish init. PID = %ld&quot;, (long)getpid());}int initPVByFile(const char *filename, char x, int semcnt) { __sem_key = ftok(filename, x); if(__initPV(semcnt) == -1) { rmPV(); return -1; } return 0;}int initPVByKey(key_t key, int semcnt) { __sem_key = key; if(__initPV(semcnt) == -1) { rmPV(); return -1; } return 0;} 主程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &quot;utils.h&quot;#include &quot;pvutils.h&quot;void handler(int sig) { logger(LOG_INFO, &quot;received signal(%d):%s&quot;, sig, strsignal(sig)); exit(0);}#define BUFFER_SIZE 2048struct MmapStruct { ssize_t len; char buf[BUFFER_SIZE];};void cleanupMmap(int status, void *buf) { CHECK_LOG(munmap(buf, sizeof(struct MmapStruct)) != -1);}void cleanupPV(int status, void *buf) { CHECK_LOG(rmPV() != -1);}int main(int argc, char *argv[]) { CHECK_EXIT_MSG(argc == 3, &quot;Usage: %s writer|reader file&quot;, argv[0]); char *outfile = argv[2]; int fd = open(outfile, O_RDWR | O_CREAT, 0666); CHECK_EXIT(ftruncate(fd, sizeof(struct MmapStruct)) != -1); CHECK_EXIT(fd != -1); CHECK_EXIT(initPVByFile(argv[1], 'a', 2) != -1); signal(SIGINT, handler); signal(SIGTERM, handler); signal(SIGHUP, handler); struct MmapStruct *mmapP = mmap(NULL, sizeof(struct MmapStruct), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);; CHECK_EXIT(mmapP != MAP_FAILED); CHECK_EXIT(close(fd) != -1); on_exit(cleanupMmap, mmapP); on_exit(cleanupPV, NULL); CHECK_EXIT(initAvai(1) != -1); if(!strcmp(argv[1], &quot;writer&quot;)) { size_t size = 0; bool stop = false; for(int i = 0; !stop ;i++) { CHECK_EXIT(P(1) != -1); logger(LOG_INFO, &quot;write start&quot;); CHECK_EXIT((mmapP-&gt;len = read(STDIN_FILENO, mmapP-&gt;buf, BUFFER_SIZE - sizeof(int))) &gt;= 0); size += mmapP-&gt;len; if(mmapP-&gt;len == 0) { stop = true; } CHECK_EXIT(V(2) != -1); logger(LOG_INFO, &quot;write end: i = %d, size = %lu&quot;, i, size); } } else { size_t size = 0; bool stop = false; for(int i = 0; !stop ;i++) { CHECK_EXIT(P(2) != -1); logger(LOG_INFO, &quot;read start&quot;); CHECK_EXIT(write(STDOUT_FILENO, mmapP-&gt;buf, mmapP-&gt;len) == mmapP-&gt;len); size += mmapP-&gt;len; if(mmapP-&gt;len == 0) { stop = true; } CHECK_EXIT(V(1) != -1); logger(LOG_INFO, &quot;read end: i = %d, size = %lu&quot;, i, size); } }} 49.3编写程序验证在49.4.3节中描述的情况下会产生SIGBUS和SIGSEGV信号 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &quot;utils.h&quot;#define BUFFER_SIZE 2048void handler(int sig) { logger(LOG_INFO, &quot;received: signal(%d):%s&quot;, sig, strsignal(sig)); CHECK_LOG(signal(sig, SIG_DFL) != SIG_ERR); fflush(NULL); raise(sig); return;}void testcase(const char *file, int filesize, int mmapsize, int access) { pid_t pid; CHECK_RET((pid = fork()) != -1, return;); if(!pid) { CHECK_EXIT(signal(SIGBUS, handler) != SIG_ERR); CHECK_EXIT(signal(SIGSEGV, handler) != SIG_ERR); logger(LOG_INFO, &quot;filesize=%d, mmapsize=%d, access=%d&quot;, filesize, mmapsize, access); int fd = open(file, O_RDWR | O_CREAT | O_SYNC, 0666); // CHECK_EXIT(ftruncate(fd, 0) != -1); // CHECK_EXIT(fsync(fd) != -1); CHECK_EXIT(ftruncate(fd, filesize) != -1); CHECK_EXIT(fsync(fd) != -1); CHECK_EXIT(fd != -1); char *mmapP = mmap(NULL, mmapsize, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); CHECK_EXIT(mmapP != MAP_FAILED); CHECK_EXIT(close(fd) != -1); logger(LOG_INFO, &quot;mmapP=%p, access:%p&quot;, mmapP, (mmapP + access)); mmapP[access] = 'b'; CHECK_LOG(munmap(mmapP, mmapsize) != -1); exit(0); } int status; CHECK_RET(waitpid(pid, &amp;status, 0) != -1, return;); logger(LOG_INFO, &quot;exit status=%d, exit sig=(%d)%s&quot;, WEXITSTATUS(status), WSTOPSIG(status), strsignal(WSTOPSIG(status)));}int main(int argc, char *argv[]) { setbuf(stderr, NULL); setbuf(stdout, NULL); if(argc == 2) { long pagesize = sysconf(_SC_PAGESIZE); logger(LOG_INFO, &quot;pagesize = %ld&quot;, pagesize); testcase(argv[1], pagesize*3, pagesize / 2+pagesize, 0); testcase(argv[1], pagesize*3, pagesize / 2+pagesize, pagesize / 2+pagesize); testcase(argv[1], pagesize*3, pagesize / 2+pagesize, pagesize*2); // sigsegv but do not receive it here testcase(argv[1], pagesize/2, pagesize*2, 0); testcase(argv[1], pagesize/2, pagesize*2, pagesize / 2); testcase(argv[1], pagesize/2, pagesize*2, pagesize); // sigbus testcase(argv[1], pagesize/2, pagesize*2, pagesize*2); // sigsegv but do not receive it here testcase(argv[1], pagesize/2, pagesize, pagesize); // sigsegv } else { CHECK_EXIT_MSG(argc == 5, &quot;Usage: %s filename filesize mmapsize access&quot;, argv[0]); int filesize, mmapsize, access; CHECK_EXIT_MSG(safe_atoi(argv[2], &amp;filesize) != -1, &quot;safe_atoi filesize=%s&quot;, argv[2]); CHECK_EXIT_MSG(safe_atoi(argv[3], &amp;mmapsize) != -1, &quot;safe_atoi mmapsize=%s&quot;, argv[3]); CHECK_EXIT_MSG(safe_atoi(argv[4], &amp;access) != -1, &quot;safe_atoi access=%s&quot;, argv[4]); testcase(argv[1], filesize, mmapsize, access); }} 不知道为什么，本应出现sigsegv的地方并没有收到信号，只有分配一个页面后越界的情况会产生sigsegv 2023年9月18日更新产生sigsegv的根本原因是试图访问无法访问的内存地址，现在的mmap实现可能为了速度与安全的考虑，会多分配一部分内存。只要分配时多分配一页，再将多分配的部分回收，就可以触发sigsegv了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &quot;utils.h&quot;#define BUFFER_SIZE 2048void handler(int sig) { logger(LOG_INFO, &quot;received: signal(%d):%s&quot;, sig, strsignal(sig)); CHECK_LOG(signal(sig, SIG_DFL) != SIG_ERR); fflush(NULL); raise(sig); return;}int offalign(int off, int size) { return (off%size &gt; 0 ? (size - off%size) : 0);} // 令off与size对其所需的调整量long pagesize;void testcase(const char *file, int filesize, int mmapsize, int access) { pid_t pid; CHECK_RET((pid = fork()) != -1, return;); if(!pid) { CHECK_EXIT(signal(SIGBUS, handler) != SIG_ERR); CHECK_EXIT(signal(SIGSEGV, handler) != SIG_ERR); logger(LOG_INFO, &quot;filesize=%d, mmapsize=%d, access=%d&quot;, filesize, mmapsize, access); int fd = open(file, O_RDWR | O_CREAT | O_SYNC, 0666); // CHECK_EXIT(ftruncate(fd, 0) != -1); // CHECK_EXIT(fsync(fd) != -1); CHECK_EXIT(ftruncate(fd, filesize) != -1); CHECK_EXIT(fsync(fd) != -1); CHECK_EXIT(fd != -1); char *mmapP = mmap(NULL, mmapsize+pagesize, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if(offalign(mmapsize,pagesize) &gt; 0) CHECK_LOG(munmap(mmapP+offalign(mmapsize,pagesize) + mmapsize, pagesize) != -1); //mmap多分配一页，然后把多分配的部分去掉 CHECK_EXIT(mmapP != MAP_FAILED); CHECK_EXIT(close(fd) != -1); logger(LOG_INFO, &quot;mmapP=%p, access:%p&quot;, mmapP, (mmapP + access)); mmapP[access] = 'b'; CHECK_LOG(munmap(mmapP, mmapsize) != -1); exit(0); } int status; CHECK_RET(waitpid(pid, &amp;status, 0) != -1, return;); logger(LOG_INFO, &quot;exit status=%d, exit sig=(%d)%s&quot;, WEXITSTATUS(status), WSTOPSIG(status), strsignal(WSTOPSIG(status)));}int main(int argc, char *argv[]) { setbuf(stderr, NULL); setbuf(stdout, NULL); pagesize = sysconf(_SC_PAGESIZE); if(argc == 2) { logger(LOG_INFO, &quot;pagesize = %ld&quot;, pagesize); testcase(argv[1], pagesize*3, pagesize / 2+pagesize, 0); testcase(argv[1], pagesize*3, pagesize / 2+pagesize, pagesize / 2+pagesize); testcase(argv[1], pagesize*3, pagesize / 2+pagesize, pagesize*2); // sigsegv but do not receive it here testcase(argv[1], pagesize/2, pagesize*2, 0); testcase(argv[1], pagesize/2, pagesize*2, pagesize / 2); testcase(argv[1], pagesize/2, pagesize*2, pagesize); // sigbus testcase(argv[1], pagesize/2, pagesize*2, pagesize*2); // sigsegv but do not receive it here testcase(argv[1], pagesize/2, pagesize, pagesize); // sigsegv } else { CHECK_EXIT_MSG(argc == 5, &quot;Usage: %s filename filesize mmapsize access&quot;, argv[0]); int filesize, mmapsize, access; CHECK_EXIT_MSG(safe_atoi(argv[2], &amp;filesize) != -1, &quot;safe_atoi filesize=%s&quot;, argv[2]); CHECK_EXIT_MSG(safe_atoi(argv[3], &amp;mmapsize) != -1, &quot;safe_atoi mmapsize=%s&quot;, argv[3]); CHECK_EXIT_MSG(safe_atoi(argv[4], &amp;access) != -1, &quot;safe_atoi access=%s&quot;, argv[4]); testcase(argv[1], filesize, mmapsize, access); }}","link":"/home/2023/09/16/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha49/"},{"title":"cha46.System V 消息队列","text":"46.2改造44.8节中的序号客户端-服务器应用程序使之使用System V消息队列。使用单个消息队列来传输客户端到服务器以及服务器到客户端之间的消息。使用 46.8节中介绍的消息类型规范。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdbool.h&gt;#include &lt;stddef.h&gt;#include &lt;syslog.h&gt;#include &lt;wait.h&gt;//#define DEBUG_LEVEL LOG_DEBUG#ifndef DEBUG_LEVEL#define DEBUG_LEVEL LOG_INFO#endifFILE *logfile = NULL;void logger(int level, const char *msg, ...) { if(level &lt;= DEBUG_LEVEL) { va_list fmt; va_start(fmt, msg); vfprintf(logfile, msg, fmt); va_end(fmt); fprintf(logfile, &quot;\\n&quot;); }}#define COND_RET(x, ret, msg...) \\ do { \\ errno = 0;\\ if(!(x)) { \\ if(errno == 0)logger(LOG_ERR, &quot;%s:%d\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__, #x); \\ else logger(LOG_ERR, &quot;%s:%d\\nerror: %s\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__,strerror(errno), #x); \\ logger(LOG_ERR, msg); \\ logger(LOG_ERR, &quot;\\n&quot;); \\ ret \\ } \\ } while(0)#define CHECK(x, msg...) COND_RET(x, return -1;, msg)#define CHECK_EXIT(x, msg...) COND_RET(x, exit(1);, msg)#define CHECK_LOG(x, msg...) COND_RET(x, ;, msg)#define safe_free(ptr) do { if(ptr) { free(ptr); ptr = NULL;} } while(0)char *alloc_sprintf(const char * __format, ...) { va_list fmt; va_start(fmt, __format); int len = vsnprintf(NULL, 0, __format, fmt); va_end(fmt); char *str = malloc(len+1); COND_RET(str != NULL, return NULL;, &quot;&quot;); va_start(fmt, __format); vsnprintf(str, len+1, __format, fmt); va_end(fmt); return str;}char *MSQ_KEY_FILE = NULL;#define BUFFER_SIZE 4096static pid_t SELF_PID = -1;static int MSG_ID = -1;#define SERVER_MSG_TYPE 1#define CLIENT_MSG_TYPE SELF_PID#define REQ_TOUCH 1#define REQ_RM 2#define REQ_CAT 3#define REQ_LS 4#define REQ_RDLK 5#define RET_MORE 0x0001#define RET_SUCCESS 0x0010struct ServerReturnType { long mtype; int msgType; char mcontent[BUFFER_SIZE];};struct ClientRequestType { long mtype; int msgType; pid_t pid; char mcontent[BUFFER_SIZE];};#define REQ_SIZE (offsetof(struct ClientRequestType, mcontent) - offsetof(struct ClientRequestType, msgType) + BUFFER_SIZE)#define RET_SIZE (offsetof(struct ServerReturnType, mcontent) - offsetof(struct ServerReturnType, msgType) + BUFFER_SIZE)void atexitCloseLogfile(void) { logger(LOG_DEBUG, &quot;SERVER: atexitCloseLogfile&quot;); CHECK_LOG(fclose(logfile) != -1, &quot;&quot;);}void atexitFreeKeyfile(void) { logger(LOG_DEBUG, &quot;SERVER: atexitFreeKeyfile&quot;); safe_free(MSQ_KEY_FILE);}void atexitRMID(void) { logger(LOG_DEBUG, &quot;SERVER: atexitRMID&quot;); CHECK_LOG(msgctl(MSG_ID, IPC_RMID, NULL) != -1, &quot;&quot;);}void client(const char *filename, int msgType) { struct ServerReturnType ret; struct ClientRequestType req; req.mtype = SERVER_MSG_TYPE; req.msgType = msgType; req.pid = SELF_PID; strcpy(req.mcontent, filename); ssize_t send = msgsnd(MSG_ID, &amp;req, REQ_SIZE, 0); CHECK_EXIT(send != -1, &quot;&quot;); do { ssize_t recv = msgrcv(MSG_ID, &amp;ret, RET_SIZE, CLIENT_MSG_TYPE, 0); CHECK_EXIT(recv != -1, &quot;&quot;); if(ret.msgType &amp; RET_SUCCESS) { printf(&quot;oJBk: &quot;); } else { printf(&quot;fail: &quot;); } printf(&quot;%s&quot;, ret.mcontent); } while (ret.msgType &amp; RET_MORE); printf(&quot;\\n&quot;);}void waitChild(int sig, siginfo_t *info, void *buf) { logger(LOG_DEBUG, &quot;SERVER: received sig:%d(%s)&quot;, sig, strsignal(sig)); if(sig == SIGCHLD)CHECK_LOG(waitpid(info-&gt;si_pid, NULL, 0) != -1, &quot;&quot;);}char *execute(char *cmd, bool *success) { *success = false; FILE *f = popen(cmd, &quot;r&quot;); if(!f) { logger(LOG_DEBUG, &quot;SERVER: execute, f is NULL&quot;); free(cmd); return NULL; } char content[BUFFER_SIZE] = {0}; char *ret = strdup(&quot;&quot;); while (fgets(content, BUFFER_SIZE-1, f) != NULL) { char *concat = alloc_sprintf(&quot;%s%s&quot;, ret, content); free(ret); ret = concat; } free(cmd); int status = pclose(f); *success = WIFEXITED(status) &amp;&amp; (WEXITSTATUS(status) == 0); logger(LOG_DEBUG, &quot;SERVER: execute success=%d, ret = %s&quot;, *success, ret); return ret;}char *touch(char *filename, bool *success) { char *cmd = alloc_sprintf(&quot;touch %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}char *rm(char *filename, bool *success) { char *cmd = alloc_sprintf(&quot;rm -rf %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}char *ls(char *filename, bool *success) { char *cmd = alloc_sprintf(&quot;ls %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}char *rdlk(char *filename, bool *success) { char *cmd = alloc_sprintf(&quot;readlink %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}char *cat(char *filename, bool *success) { char *cmd = alloc_sprintf(&quot;cat %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}void server_exit(int sig) { exit(0);}char *splitby(char *mcontent, const char *sep) { while (*sep) { char *ptr = strchr(mcontent, *sep); if(ptr) *ptr = '\\0'; sep++; } return mcontent;}void server() { struct sigaction action; struct ClientRequestType req; action.sa_flags = SA_RESTART; CHECK_EXIT(sigemptyset(&amp;action.sa_mask) != -1, &quot;&quot;); action.sa_sigaction = waitChild; CHECK_EXIT(sigaction(SIGCHLD, &amp;action, NULL) != -1, &quot;&quot;); CHECK_EXIT(atexit(atexitRMID) != -1, &quot;&quot;); CHECK_EXIT(signal(SIGHUP, server_exit) != SIG_ERR, &quot;&quot;); CHECK_EXIT(signal(SIGINT, server_exit) != SIG_ERR, &quot;&quot;); ssize_t msg_len; for(;;) { memset(&amp;req, 0, sizeof(struct ClientRequestType)); msg_len = msgrcv(MSG_ID, &amp;req, REQ_SIZE, SERVER_MSG_TYPE, 0); if(msg_len == -1) { if(errno == EINTR) continue; CHECK_EXIT(true, &quot;&quot;); } logger(LOG_DEBUG, &quot;read msg&quot;); struct ServerReturnType ret; sigset_t sigset; sigemptyset(&amp;sigset); sigaddset(&amp;sigset, SIGCHLD); switch (fork()) { case -1: CHECK_EXIT(false, &quot;&quot;); break; case 0: sigprocmask(SIG_SETMASK, &amp;sigset, NULL); // 防止pclose删除消息队列 memset(&amp;ret, 0, sizeof(struct ServerReturnType)); ret.mtype = req.pid; char *mcontent; bool success; splitby(req.mcontent, &quot;; |&gt;&amp;&quot;); switch (req.msgType) { case REQ_TOUCH: mcontent = touch(req.mcontent, &amp;success); break; case REQ_RM: mcontent = rm(req.mcontent, &amp;success); break; case REQ_CAT: mcontent = cat(req.mcontent, &amp;success); break; case REQ_LS: mcontent = ls(req.mcontent, &amp;success); break; case REQ_RDLK: mcontent = rdlk(req.mcontent, &amp;success); break; default: mcontent = alloc_sprintf(&quot;unsupported msgType:%d&quot;, req.msgType); success = false; break; } if(success) { ret.msgType = RET_SUCCESS; logger(LOG_DEBUG, &quot;SERVER: success&quot;); } else { ret.msgType = 0; logger(LOG_DEBUG, &quot;SERVER: fail&quot;); } size_t len = strlen(mcontent); char *tcontent = mcontent; ret.msgType |= RET_MORE; for(int i = 0; i &lt; len/BUFFER_SIZE; i++) { memcpy(ret.mcontent, mcontent, BUFFER_SIZE); CHECK_LOG(msgsnd(MSG_ID, &amp;ret, RET_SIZE, 0) != -1, &quot;&quot;); mcontent += BUFFER_SIZE; } memcpy(ret.mcontent, mcontent, len%BUFFER_SIZE); ret.msgType &amp;= ~RET_MORE; CHECK_LOG(msgsnd(MSG_ID, &amp;ret, RET_SIZE, 0) != -1, &quot;&quot;); safe_free(tcontent); fflush(NULL); _exit(0); // 不要执行atxite注册的函数 break; default: break; } }}int main(int argc, char **argv) { //处理参数 logfile = stderr; CHECK(argc &gt; 1, &quot;Usage: %s [server|client] argv...&quot;, argv[0]); MSQ_KEY_FILE = realpath(strdup(argv[0]), NULL); CHECK(atexit(atexitFreeKeyfile) != -1, &quot;&quot;); SELF_PID = getpid(); CHECK(SELF_PID != -1, &quot;&quot;); static key_t __MSG_KEY = -1; __MSG_KEY = ftok(MSQ_KEY_FILE, 't'); CHECK(__MSG_KEY != -1, &quot;&quot;); MSG_ID = msgget(__MSG_KEY, IPC_CREAT | 0666); CHECK(MSG_ID != -1, &quot;&quot;); if(!strcmp(&quot;client&quot;, argv[1])) { CHECK(argc &gt; 3, &quot;Usage: %s client filename cmd&quot;, argv[0]); int cmd; if(!strcmp(argv[3], &quot;touch&quot;)) { cmd = REQ_TOUCH; } else if(!strcmp(argv[3], &quot;ls&quot;)) { cmd = REQ_LS; } else if(!strcmp(argv[3], &quot;cat&quot;)) { cmd = REQ_CAT; } else if(!strcmp(argv[3], &quot;readlink&quot;)) { cmd = REQ_RDLK; } else if(!strcmp(argv[3], &quot;rm&quot;)) { cmd = REQ_RM; } else { cmd = -1; } client(argv[2], cmd); } else if(!strcmp(&quot;server&quot;, argv[1])) { CHECK(true, &quot;Usage: %s server [--daemon=] [--logfile=]&quot;, argv[0]); bool deamonlize = false; char *logfilename = NULL; for(int i = 2; i &lt; argc; i++) { if(!strncmp(&quot;--daemon=&quot;, argv[i], 9)) { if(!strcmp(argv[i] + 9, &quot;true&quot;)) { logger(LOG_DEBUG,&quot;SERVER: daemon&quot;); deamonlize = true; } else { logger(LOG_DEBUG,&quot;SERVER: non-daemon&quot;); } } else if(!strncmp(&quot;--logfile=&quot;, argv[i], 10)) { logfilename = argv[i] + 10; logger(LOG_DEBUG,&quot;SERVER: logfile: %s&quot;, logfilename); } else { logger(LOG_DEBUG, &quot;Unknown argv: %s&quot;, argv[i]); } } if(deamonlize) { CHECK(daemon(0,0) != -1, &quot;&quot;); } if(logfilename == NULL) { logfile = stderr; } else { int logfileFd; CHECK((logfileFd = open(logfilename, O_WRONLY | O_CREAT, 0600)) != -1, &quot;&quot;); logfile = fdopen(logfileFd, &quot;w&quot;); CHECK(logfile != NULL, &quot;&quot;); CHECK(dup2(logfileFd, STDERR_FILENO) != -1, &quot;&quot;); CHECK(dup2(logfileFd, STDOUT_FILENO) != -1, &quot;&quot;); CHECK(atexit(atexitCloseLogfile) != -1, &quot;&quot;); } server(); } else { CHECK(false, &quot;Usage: %s [server|client] argv...&quot;, argv[0]); }} 46.3在46.8节中的客户端-服务器应用程序中客户端为何在消息体(在clientId 字段中)中传递其消息队列的标识符，而不是在消息类型(mtype)中传递? clientid有可能为0，mtype不能为0 46.4 46.5对46.8节中的客户端-服务器应用程序做出下列变更。 使用IPC_PRIVATE创建，将标识符写入文件中，客户端读取这个文件 将错误输出到syslog daemon 使用信号SIGTERM和SIGINT创建干净的退出 处理客户端过早退出的情况（timer超时） 客户端考虑服务端可能出现的错误（如：消息队列满） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdbool.h&gt;#include &lt;stddef.h&gt;#include &lt;syslog.h&gt;#include &lt;wait.h&gt;#define DEBUG_LEVEL LOG_DEBUG#ifndef DEBUG_LEVEL#define DEBUG_LEVEL LOG_INFO#endifFILE *logfile = NULL;bool syslog_enable = false;#define alloc_sprintf(__alloc_sprintf_str, __format...) do { \\ int __alloc_sprintf_len = snprintf(NULL, 0, __format); \\ (__alloc_sprintf_str) = malloc(__alloc_sprintf_len+1); \\ if(__alloc_sprintf_str != NULL) \\ snprintf(__alloc_sprintf_str, __alloc_sprintf_len+1, __format); \\} while(0)#define logger(level, msg...) do { \\ if(level &lt;= DEBUG_LEVEL) { \\ fprintf(logfile, msg); \\ fprintf(logfile, &quot;\\n&quot;); \\ } \\ if(syslog_enable) { \\ char *data; \\ alloc_sprintf(data, msg); \\ syslog(level, &quot;%s&quot;, data); \\ safe_free(data); \\ } \\} while(0)#define COND_RET(x, ret, msg...) \\ do { \\ if(!(x)) { \\ if(errno == 0)logger(LOG_ERR, &quot;%s:%d\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__, #x); \\ else logger(LOG_ERR, &quot;%s:%d\\nerror: %s\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__,strerror(errno), #x); \\ logger(LOG_ERR, msg); \\ logger(LOG_ERR, &quot;\\n&quot;); \\ ret \\ } \\ } while(0)#define CHECK(x, msg...) COND_RET(x, return -1;, msg)#define CHECK_EXIT(x, msg...) COND_RET(x, exit(EXIT_FAILURE);, msg)#define CHECK_LOG(x, msg...) COND_RET(x, ;, msg)#define safe_free(__safe_free_ptr) do { if(__safe_free_ptr) { free(__safe_free_ptr); (__safe_free_ptr) = NULL;} } while(0)#define BUFFER_SIZE 4096static pid_t SELF_PID = -1;static int MSG_ID = -1;#define SERVER_MSG_TYPE 1#define CLIENT_MSG_TYPE SELF_PID#define REQ_TOUCH 1#define REQ_RM 2#define REQ_CAT 3#define REQ_LS 4#define REQ_RDLK 5#define RET_MORE 0x0001#define RET_SUCCESS 0x0010#define SERVER_MSG_FILE &quot;SERVER_MSG_FILE-Meow&quot;struct ServerReturnType { long mtype; int msgtype; char mcontent[BUFFER_SIZE];};struct ClientRequestType { long mtype; int msqid; char mcontent[BUFFER_SIZE];};#define REQ_SIZE (offsetof(struct ClientRequestType, mcontent) - offsetof(struct ClientRequestType, msqid) + BUFFER_SIZE)#define RET_SIZE (offsetof(struct ServerReturnType, mcontent) - offsetof(struct ServerReturnType, msgtype) + BUFFER_SIZE)void atexitWorker(int status, void *arg) { if(WIFEXITED(status) &amp;&amp; (WEXITSTATUS(status) == EXIT_SUCCESS)) return; struct ClientRequestType *req = arg; logger(DEBUG_LEVEL, &quot;worker atexitWorker&quot;); CHECK_LOG(msgctl(req-&gt;msqid, IPC_RMID, NULL) != -1, &quot;&quot;);}void atexitCloseLogfile(int status, void *arg) { if(!*(bool *)arg) return; logger(LOG_DEBUG, &quot;SERVER: atexitCloseLogfile&quot;); CHECK_LOG(fclose(logfile) != -1, &quot;&quot;); logfile = stderr;}void atexitCloseLog(int status, void *arg) { if(!*(bool *)arg) return; logger(LOG_DEBUG, &quot;SERVER: atexitCloseLog&quot;); closelog();}void atexitRMID(int status, void *arg) { if(!*(bool *)arg) return; logger(LOG_DEBUG, &quot;SERVER: atexitRMID&quot;); CHECK_LOG(unlink(SERVER_MSG_FILE) != -1, &quot;&quot;); CHECK_LOG(msgctl(MSG_ID, IPC_RMID, NULL) != -1, &quot;&quot;);}void clientAtexitRMID(int status, void *arg) { logger(LOG_DEBUG, &quot;CLIENT: atexitRMID&quot;); CHECK_LOG(msgctl(MSG_ID, IPC_RMID, NULL) != -1, &quot;&quot;);}void client(const char *filename, int msgType) { on_exit(clientAtexitRMID, NULL); int SERVER_MSG_ID = -1; int server_msg_id = open(SERVER_MSG_FILE, O_EXCL | O_RDONLY); CHECK_EXIT(server_msg_id != -1, &quot;&quot;); CHECK_EXIT(read(server_msg_id, &amp;SERVER_MSG_ID, sizeof(int)) == sizeof(int), &quot;&quot;); close(server_msg_id); struct ServerReturnType ret; struct ClientRequestType req; req.mtype = msgType; req.msqid = MSG_ID; strcpy(req.mcontent, filename); ssize_t send = msgsnd(SERVER_MSG_ID, &amp;req, REQ_SIZE, IPC_NOWAIT); CHECK_EXIT(send != -1, &quot;&quot;); do { ssize_t recv = msgrcv(MSG_ID, &amp;ret, RET_SIZE, 0, 0); CHECK_EXIT(recv != -1, &quot;&quot;); if(ret.msgtype &amp; RET_SUCCESS) { printf(&quot;oJBk: &quot;); } else { printf(&quot;fail: &quot;); } printf(&quot;%s&quot;, ret.mcontent); } while (ret.msgtype &amp; RET_MORE); printf(&quot;\\n&quot;);}void waitChild(int sig, siginfo_t *info, void *buf) { logger(LOG_DEBUG, &quot;SERVER: received sig:%d(%s)&quot;, sig, strsignal(sig)); int savedErrno = errno; if(sig == SIGCHLD)CHECK_LOG(waitpid(-1, NULL, WNOHANG) != -1, &quot;&quot;); // 等所有吧 errno = savedErrno;}char *execute(char *cmd, bool *success) { *success = false; FILE *f = popen(cmd, &quot;r&quot;); if(!f) { logger(LOG_DEBUG, &quot;SERVER: execute, f is NULL&quot;); free(cmd); return NULL; } char content[BUFFER_SIZE] = {0}; char *ret = strdup(&quot;&quot;); while (fgets(content, BUFFER_SIZE-1, f) != NULL) { char *concat; alloc_sprintf(concat, &quot;%s%s&quot;, ret, content); free(ret); ret = concat; } free(cmd); int status = pclose(f); *success = WIFEXITED(status) &amp;&amp; (WEXITSTATUS(status) == 0); logger(LOG_DEBUG, &quot;SERVER: execute success=%d, ret = %s&quot;, *success, ret); return ret;}char *touch(char *filename, bool *success) { char *cmd; alloc_sprintf(cmd, &quot;touch %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}char *rm(char *filename, bool *success) { char *cmd; alloc_sprintf(cmd, &quot;rm -rf %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}char *ls(char *filename, bool *success) { char *cmd; alloc_sprintf(cmd, &quot;ls %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}char *rdlk(char *filename, bool *success) { char *cmd; alloc_sprintf(cmd, &quot;readlink %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}char *cat(char *filename, bool *success) { char *cmd; alloc_sprintf(cmd, &quot;cat %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}void server_exit(int sig) { exit(0);}char *splitby(char *mcontent, const char *sep) { while (*sep) { char *ptr = strchr(mcontent, *sep); if(ptr) *ptr = '\\0'; sep++; } return mcontent;}bool is_server = false;int task_timeout = 20;void workerTimeout(int sig) { logger(LOG_DEBUG, &quot;WORKER: received sig:%d(%s), work timeout!&quot;, sig, strsignal(sig)); fflush(NULL); exit(EXIT_FAILURE);}void server() { is_server = true; int server_msg_id = open(SERVER_MSG_FILE, O_CREAT | O_EXCL | O_RDONLY | O_FSYNC | O_WRONLY, 0666); CHECK_EXIT(server_msg_id != -1, &quot;&quot;); CHECK_EXIT(write(server_msg_id, &amp;MSG_ID, sizeof(int)) == sizeof(int), &quot;&quot;); close(server_msg_id); struct sigaction action; struct ClientRequestType req; action.sa_flags = SA_RESTART; CHECK_EXIT(sigemptyset(&amp;action.sa_mask) != -1, &quot;&quot;); action.sa_sigaction = waitChild; CHECK_EXIT(sigaction(SIGCHLD, &amp;action, NULL) != -1, &quot;&quot;); CHECK_EXIT(on_exit(atexitRMID, &amp;is_server) != -1, &quot;&quot;); CHECK_EXIT(signal(SIGHUP, server_exit) != SIG_ERR, &quot;&quot;); CHECK_EXIT(signal(SIGINT, server_exit) != SIG_ERR, &quot;&quot;); CHECK_EXIT(signal(SIGTERM, server_exit) != SIG_ERR, &quot;&quot;); ssize_t msg_len; for(;;) { memset(&amp;req, 0, sizeof(struct ClientRequestType)); msg_len = msgrcv(MSG_ID, &amp;req, REQ_SIZE, 0, 0); if(msg_len == -1) { if(errno == EINTR) continue; CHECK_EXIT(false, &quot;&quot;); } logger(LOG_DEBUG, &quot;read msg&quot;); struct ServerReturnType ret; sigset_t sigset; sigemptyset(&amp;sigset); sigaddset(&amp;sigset, SIGCHLD); switch (fork()) { case -1: CHECK_EXIT(false, &quot;&quot;); break; case 0: is_server = false; sigprocmask(SIG_SETMASK, &amp;sigset, NULL); // 防止pclose删除消息队列 memset(&amp;ret, 0, sizeof(struct ServerReturnType)); ret.mtype = 1; char *mcontent; bool success; splitby(req.mcontent, &quot;; |&gt;&amp;&quot;); on_exit(atexitWorker, &amp;req); CHECK_EXIT(signal(SIGALRM, workerTimeout) != SIG_ERR, &quot;&quot;); CHECK_EXIT(alarm(task_timeout) != -1, &quot;&quot;); switch (req.mtype) { case REQ_TOUCH: mcontent = touch(req.mcontent, &amp;success); break; case REQ_RM: mcontent = rm(req.mcontent, &amp;success); break; case REQ_CAT: mcontent = cat(req.mcontent, &amp;success); break; case REQ_LS: mcontent = ls(req.mcontent, &amp;success); break; case REQ_RDLK: mcontent = rdlk(req.mcontent, &amp;success); break; default: alloc_sprintf(mcontent, &quot;unsupported msgType:%ld&quot;, req.mtype); success = false; break; } if(success) { ret.msgtype = RET_SUCCESS; logger(LOG_DEBUG, &quot;SERVER: success&quot;); } else { ret.msgtype = 0; logger(LOG_DEBUG, &quot;SERVER: fail&quot;); } size_t len = strlen(mcontent); char *tcontent = mcontent; ret.msgtype |= RET_MORE; for(int i = 0; i &lt; len/BUFFER_SIZE; i++) { memcpy(ret.mcontent, mcontent, BUFFER_SIZE); CHECK_LOG(msgsnd(req.msqid, &amp;ret, RET_SIZE, 0) != -1, &quot;&quot;); mcontent += BUFFER_SIZE; } memcpy(ret.mcontent, mcontent, len%BUFFER_SIZE); ret.msgtype &amp;= ~RET_MORE; CHECK_LOG(msgsnd(req.msqid, &amp;ret, RET_SIZE, 0) != -1, &quot;&quot;); CHECK_EXIT(alarm(0) != -1, &quot;&quot;); //cancel safe_free(tcontent); fflush(NULL); exit(EXIT_SUCCESS); break; default: break; } }}int main(int argc, char **argv) { //处理参数 logfile = stderr; CHECK(argc &gt; 1, &quot;Usage: %s [server|client] argv...&quot;, argv[0]); SELF_PID = getpid(); CHECK(SELF_PID != -1, &quot;&quot;); MSG_ID = msgget(IPC_PRIVATE, 0666); CHECK(MSG_ID != -1, &quot;&quot;); if(!strcmp(&quot;client&quot;, argv[1])) { CHECK(argc &gt; 3, &quot;Usage: %s client filename cmd&quot;, argv[0]); int cmd; if(!strcmp(argv[3], &quot;touch&quot;)) { cmd = REQ_TOUCH; } else if(!strcmp(argv[3], &quot;ls&quot;)) { cmd = REQ_LS; } else if(!strcmp(argv[3], &quot;cat&quot;)) { cmd = REQ_CAT; } else if(!strcmp(argv[3], &quot;readlink&quot;)) { cmd = REQ_RDLK; } else if(!strcmp(argv[3], &quot;rm&quot;)) { cmd = REQ_RM; } else { cmd = -1; } client(argv[2], cmd); } else if(!strcmp(&quot;server&quot;, argv[1])) { CHECK(true, &quot;Usage: %s server [--daemon=true|false] [--logfile=] [--syslog=true|false] [--timeout=number]&quot;, argv[0]); bool deamonlize = false; char *logfilename = NULL; for(int i = 2; i &lt; argc; i++) { if(!strncmp(&quot;--daemon=&quot;, argv[i], 9)) { if(!strcmp(argv[i] + 9, &quot;true&quot;)) { logger(LOG_DEBUG,&quot;SERVER: daemon&quot;); deamonlize = true; } else { logger(LOG_DEBUG,&quot;SERVER: non-daemon&quot;); } } else if(!strncmp(&quot;--logfile=&quot;, argv[i], 10)) { logfilename = argv[i] + 10; logger(LOG_DEBUG,&quot;SERVER: logfile: %s&quot;, logfilename); } else if(!strncmp(&quot;--syslog=&quot;, argv[i], 9)) { if(!strcmp(argv[i] + 9, &quot;true&quot;)) { syslog_enable = true; openlog(argv[0], LOG_CONS|LOG_PID, LOG_USER); on_exit(atexitCloseLog, &amp;is_server); logger(LOG_DEBUG,&quot;SERVER: enable-syslog&quot;); } else { logger(LOG_DEBUG,&quot;SERVER: disable-syslog&quot;); } } else if(!strncmp(&quot;--timeout=&quot;, argv[i], 10)) { logger(LOG_DEBUG, &quot;timeout: %s&quot;, argv[i]); task_timeout = atoi(argv[i] + 10); } else { logger(LOG_DEBUG, &quot;Unknown argv: %s&quot;, argv[i]); } } if(deamonlize) { CHECK(daemon(1,0) != -1, &quot;&quot;); } if(logfilename != NULL) { int logfileFd; if(access(logfilename, F_OK)) { unlink(logfilename); } CHECK((logfileFd = open(logfilename, O_WRONLY | O_CREAT | O_APPEND, 0600)) != -1, &quot;&quot;); logfile = fdopen(logfileFd, &quot;w&quot;); setlinebuf(logfile); CHECK(logfile != NULL, &quot;&quot;); CHECK(dup2(logfileFd, STDERR_FILENO) != -1, &quot;&quot;); CHECK(dup2(logfileFd, STDOUT_FILENO) != -1, &quot;&quot;); CHECK(on_exit(atexitCloseLogfile, &amp;is_server) != -1, &quot;&quot;); } server(); } else { CHECK(false, &quot;Usage: %s [server|client] argv...&quot;, argv[0]); }}","link":"/home/2023/09/02/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha46/"},{"title":"cha5.深入探究文件IO","text":"练习1 请使用标准文件IO系统调用(open()和lseek())和off_t数据类型修改程序清单5-3中的程序。将宏_FILE_OFFSET_BITS的值设置为64进行编译，并测试该程序是否能够成功创建一个大文件。 将xxx64改为xxx，off64_t改为off_t，可以创建大文件（使用 -m32编译） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// #define _LARGEFILE64_SOURCE#define _FILE_OFFSET_BITS 64#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;errno.h&gt;#include&lt;stdlib.h&gt;#define debug#ifdef debug#include&lt;stdio.h&gt;#endifvoid writeErr(const char* str);#ifdef _LARGEFILE64_SOURCEint main(int argc, char **argv) { #ifdef debug printf(&quot;sizeof(long) = %d, sizeof(long long) = %d, sizeof(off_t) = %d, sizeof(off64_t) = %d\\n&quot;, sizeof(long), sizeof(long long), sizeof(off_t), sizeof(off64_t)); #endif if(argc !=3 || strcmp(argv[1], &quot;--help&quot;) == 0) { writeErr(argv[0]); writeErr(&quot; pathname offset\\n&quot;); exit(3); } int fd = open64(argv[1], O_RDWR | O_CREAT, S_IRUSR|S_IWUSR); if(fd == -1) { writeErr(&quot;open64 fail&quot;); exit(2); } off64_t off = atoll(argv[2]); if(lseek64(fd, off, SEEK_SET) == -1) { writeErr(&quot;lseek64&quot;); exit(3); } if(write(fd, &quot;test&quot;, 4) == -1) { writeErr(&quot;write&quot;); exit(4); } return 0;}#endif#ifdef _FILE_OFFSET_BITSint main(int argc, char **argv) { #ifdef debug printf(&quot;sizeof(long) = %d, sizeof(long long) = %d, sizeof(off_t) = %d\\n&quot;, sizeof(long), sizeof(long long), sizeof(off_t)); #endif if(argc !=3 || strcmp(argv[1], &quot;--help&quot;) == 0) { writeErr(argv[0]); writeErr(&quot; pathname offset\\n&quot;); exit(3); } int fd = open(argv[1], O_RDWR | O_CREAT, S_IRUSR|S_IWUSR); if(fd == -1) { writeErr(&quot;open64 fail&quot;); exit(2); } off_t off = atoll(argv[2]); if(lseek(fd, off, SEEK_SET) == -1) { writeErr(&quot;lseek64&quot;); exit(3); } if(write(fd, &quot;test&quot;, 4) == -1) { writeErr(&quot;write&quot;); exit(4); } return 0;}#endifvoid writeErr(const char* str) { errno = 0; int writeSize = write(STDERR_FILENO, str, strlen(str)); if(writeSize == -1) { exit(1); }} 练习2 5-2.编写一个程序，使用O_APPEND标志并以写方式打开一个已存在的文件，且将文件偏移量置于文件起始处，再写入数据。数据会显示在文件中的哪个位置?为什么? 文件末尾，在write时，lseek失效了 练习3 本习题的设计目的在于展示为何以O_APPEND标志打开文件来保障操作的原子性是必要的。请编写一程序，可接收多达3个命令行参数: $ atomic_append filename num-bytes [x] 该程序应打开所指定的文件(如有必要，则创建之)，然后以每次调用write()写入一个字节的方式，向文件尾部追加num-bytes个字节。缺省情况下，程序使用O_APPEND标志打开文件，但若存在第三个命令行参数(x)，那么打开文件时将不再使用O_APPEND标志，代之以在每次调用write(前调用lseek(fd,0,SEEK_END))。同时运行该程序的两个实例，不带x参数，将100万个字节写入同一文件: 1$ atomic_append f1 10000oo &amp; atomic_append f1 1000000 重复上述操作，将数据写入另一文件，但运行时加入x参数: 1$ atomic_append f2 1000000 x &amp; atomic_append f2 1000000 x 使用ls-1命令检查文件f1和f2的大小，并解释两文件大小不同的原因, 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;errno.h&gt;#include&lt;stdlib.h&gt;#define debug#ifdef debug#include&lt;stdio.h&gt;#endifvoid writeErr(const char* str);ssize_t writeMeow(int __fd, const void *__buf, size_t __n, int argc);int main(int argc, char **argv) { if((argc !=4 &amp;&amp; argc != 5) || strcmp(argv[1], &quot;--help&quot;) == 0) { writeErr(argv[0]); writeErr(&quot; pathname string num [x]\\n&quot;); exit(3); } int fd = open(argv[1], O_RDWR | O_CREAT | (argc == 5 ? 0 : O_APPEND), S_IRUSR|S_IWUSR); if(fd == -1) { writeErr(&quot;open64 fail&quot;); exit(2); } long long off = atoll(argv[3]); int argv2len = strlen(argv[2]); for(int i = 0; i &lt; off; i++) if(writeMeow(fd, argv[2], argv2len, argc) == -1) { writeErr(&quot;writeMeow&quot;); exit(4); } return 0;}void writeErr(const char* str) { errno = 0; int writeSize = write(STDERR_FILENO, str, strlen(str)); if(writeSize == -1) { exit(1); }}ssize_t writeMeow(int __fd, const void *__buf, size_t __n, int argc) { if(argc == 5) lseek(__fd, 0, SEEK_END); write(__fd, __buf, __n);} 运行结果12345$ ./practice5.3 f5.3 &quot;Meow &quot; 1048576 &amp; ./practice5.3 f5.3 &quot;Woof &quot; 1048576$ ./practice5.3 f5.3x &quot;Meow &quot; 1048576 x &amp; ./practice5.3 f5.3x &quot;Woof &quot; 1048576 x$ ll -h-rw------- 1 root root 10M Mar 23 20:17 f5.3-rw------- 1 root root 5.9M Mar 23 20:17 f5.3x 解释原因不加x的10M，加x的5.9M 通过计算，如果所有数据正常写入，那么文件大小应该刚好是10M 加X的指针移动和写入不具有原子性，可能存在两个进程同时向同一偏移量处写入数据，相互覆盖，导致文件大小偏小。 不加X的具有原子性，指针移动和写入不会打断，不会在同一位置写入 练习4 使用fcntl()和 close()(若有必要)来实现 dupO和 dup2()。(对于某些错误，dup2()和fentl()返回的errno值并不相同，此处可不予考虑。)务必牢记dup2()需要处理的一种特殊情况，即 oldfd与 newfd相等。这时，应检查oldfd是否有效，测试fcntl(oldfd，F_GETFL)是否成功就能达到这一目的。若oldfd无效，则dup2()将返回-1，并将errno置为EBADF。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;errno.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdarg.h&gt;#define debug#ifdef debug#include&lt;stdio.h&gt;#endifvoid exitErr(int exitCode, const char *format, ...);int __dup(int oldfd);int __dup2(int oldfd, int newfd);int main(int argc, char **argv) { int dupStdout = __dup(STDOUT_FILENO); write(STDOUT_FILENO, &quot;Jingtianer\\n&quot;, strlen(&quot;Jingtianer\\n&quot;)); write(dupStdout, &quot;Jingtianer\\n&quot;, strlen(&quot;Jingtianer\\n&quot;)); dupStdout = __dup2(STDOUT_FILENO, dupStdout); write(STDOUT_FILENO, &quot;Jingtianer\\n&quot;, strlen(&quot;Jingtianer\\n&quot;)); write(dupStdout, &quot;Jingtianer\\n&quot;, strlen(&quot;Jingtianer\\n&quot;)); char tmpfile[] = &quot;JingtianTmpXXXXXX&quot;; int tmpfd = mkstemp(tmpfile); dupStdout = __dup2(STDOUT_FILENO, tmpfd); write(STDOUT_FILENO, &quot;Jingtianer\\n&quot;, strlen(&quot;Jingtianer\\n&quot;)); write(tmpfd, &quot;Jingtianer\\n&quot;, strlen(&quot;Jingtianer\\n&quot;)); unlink(tmpfile); close(tmpfd); return 0;}int __dup(int oldfd) { return fcntl(oldfd, F_DUPFD, oldfd);}int __dup2(int oldfd, int newfd) { if(oldfd != newfd) { close(newfd); } else if(fcntl(oldfd, F_GETFL) == -1) { errno = EBADF; return -1; } return fcntl(oldfd, F_DUPFD, newfd);}void exitErr(int exitCode, const char *format, ...) { va_list va; va_start(va, format); fprintf(stderr, format, va); va_end(va); exit(exitCode);} 练习5 编写一程序，验证文件描述符及其副本是否共享了文件偏移量和打开文件的状态标志。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;errno.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdarg.h&gt;#define bool char#define true '\\1'#define false '\\0'#define debug#ifdef debug#include&lt;stdio.h&gt;#endifvoid exitErr(int exitCode, const char *format, ...);bool check(int fd1, int fd2);void exitErr(int exitCode, const char *format, ...);#define bool2str(x) (x == true ? &quot;true&quot; : &quot;false&quot;)int main(int argc, const char **argv) { if(argc != 3) { exitErr(1, &quot;Usage: %s file1 file2\\n&quot;, argv[0]); } int fd1 = open(argv[1], O_CREAT | O_RDWR); int fd2 = open(argv[2], O_CREAT | O_RDWR); if(fd1 == -1 || fd2 == -1) { exitErr(2, &quot;open fail\\n&quot;); } int fd1dup = dup(fd1); bool check1 = check(fd1, fd1dup); //true bool check2 = check(fd1, fd2); // false #ifdef debug fprintf(stdout, &quot;check1 == %s, check2 == %s\\n&quot;, bool2str(check1), bool2str(check2)); #endif return check1 + check2 - 1;}bool check(int fd1, int fd2) { if(lseek(fd1, 0, SEEK_CUR) != lseek(fd2, 0, SEEK_CUR)) { return false; } else { lseek(fd1, 1, SEEK_CUR); if(lseek(fd1, 0, SEEK_CUR) != lseek(fd2, 0, SEEK_CUR)) { lseek(fd1, -1, SEEK_CUR); return false; } lseek(fd1, -1, SEEK_CUR); } if(fcntl(fd1, F_GETFL) != fcntl(fd2, F_GETFL)) { return false; } else { const int flag = fcntl(fd1, F_GETFL); fcntl(fd1, F_SETFL, 0); if(fcntl(fd1, F_GETFL) != fcntl(fd2, F_GETFL)) { fcntl(fd1, F_SETFL, flag); return false; } fcntl(fd1, F_SETFL, flag); } return true;}void exitErr(int exitCode, const char *format, ...) { #ifdef debug va_list va; va_start(va, format); fprintf(stderr, format, va); va_end(va); #endif exit(exitCode);} 练习6 说明下列代码中每次执行 write()后，输出文件的内容是什么，为什么。 12345678fd1 = open(file, O_RDNR | O_CREAT | O_TRUNC，S_IRUSR | S_IMUSR);fd2 = dup(fd1);fd3 = open(file，O_RDWR);write(fd1,&quot;Hello,&quot;，6); // Hellowrite(fd2,&quot;world&quot;, 6); // Helloworld fd2由fd1复制而来，共享文件指针，fd1write后，文件指针后移，fd2也后移lseek(fd2, 0, SEEK_SET);write(fd1,&quot;HELLO,&quot;，6); // HELLOworld fd2移动到文件开头，fd1也移动，共享文件指针和状态标志、inode指针write(fd3,&quot;Gidday&quot;， 6); // Giddayworld，fd3不是dup*而来，不共享指针，其指针还在0，写入0 练习7 使用read()、write()以及 malloc函数包（见7.1.2节）中的必要函数以实现readv()和 writev()功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;errno.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdarg.h&gt;#include&lt;sys/uio.h&gt; //iovec#define bool char#define true '\\1'#define false '\\0'#define debug#ifdef debug#include&lt;stdio.h&gt;#endifssize_t __writev(int fd, const struct iovec *iov, int iovcount);ssize_t __readv(int fd, const struct iovec *iov, int iovcount);int main(int argc, const char **argv) { int fdw = open(argv[1], O_CREAT | O_TRUNC | O_RDWR); int fdr = open(argv[1], O_CREAT | O_TRUNC | O_RDWR); int contentCount = argc - 2; struct iovec *vecArr = (struct iovec*)malloc(2 * contentCount * sizeof(struct iovec)); for(int i = 2; i &lt; argc; i++) { vecArr[2*(i-2)].iov_base = argv[i]; vecArr[2*(i-2)].iov_len = strlen(argv[i]); vecArr[2*(i-2)+1].iov_base = &quot;\\n&quot;; vecArr[2*(i-2)+1].iov_len = 1; } writev(fdw, vecArr, 2 * contentCount); free(vecArr); vecArr = (struct iovec*)malloc(contentCount * sizeof(struct iovec)); for(int i = 2; i &lt; argc; i++) { int size = strlen(argv[i])+1; vecArr[i-2].iov_base = malloc(size * sizeof(char) + 1); vecArr[i-2].iov_len = size; } errno=0; int read = readv(fdr, vecArr, contentCount); if(read == -1) { const char *err = strerror(errno); write(STDOUT_FILENO, err, strlen(err)); write(STDOUT_FILENO, &quot;\\n&quot;, 1); return read; } writev(STDOUT_FILENO, vecArr, contentCount); close(fdw); close(fdr); free(vecArr); return 0;}ssize_t __writev(int fd, const struct iovec *iov, int iovcount) { ssize_t writeSize = 0; for(int i = 0; i &lt; iovcount; i++) { ssize_t writeSize1 = write(fd, iov[i].iov_base, iov[i].iov_len); writeSize += writeSize1; if(writeSize1 == -1 || writeSize1 &lt; iov[i].iov_len) { return writeSize1; } } return iovcount;}ssize_t __readv(int fd, const struct iovec *iov, int iovcount) { ssize_t readSize = 0; for(int i = 0; i &lt; iovcount; i++) { ssize_t readSize1 = read(fd, iov[i].iov_base, iov[i].iov_len); readSize += readSize1; if(readSize1 == -1 || readSize1 &lt; iov[i].iov_len) { return readSize; } else if(readSize == 0) { return i+1; } } return iovcount;} 学习的read，write，readv，writev，preadv，pwritev，其输入输出的内容不必都是字符串，由iovec的定义以及他们的函数原型可见，写入读取数据的类型为void *或const void *，是不限制输入输出的数据类型的。 此外，pread*和pwrite*具有原子性，可以代替lseek + write/read的组合，防止多个进程相互读写同一文件时，出现读写位置出错的情况，如果常出现lseek + write/read的组合，使用pread*和pwrite*可以大量减少系统调用的使用，提高性能","link":"/home/2023/03/23/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha5/"},{"title":"cha48.System V 共享内存","text":"读书笔记shmat/mmap时可以指定虚拟内存地址，指定其位置，这个位置是需要提前malloc或sbrk创建出来的吗？ 48.1使用事件标记来替换程序清单48-2(svshm_xfr_writerc)和程序清单48-3(svshm_xfr_reader.c)中的二元信号量。(就是27节的event flag) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347//// Created by root on 9/14/23.//#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;stdbool.h&gt;#include &lt;stddef.h&gt;#include &lt;syslog.h&gt;#include &lt;wait.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/shm.h&gt;#define DEBUG_LEVEL LOG_DEBUG#ifndef DEBUG_LEVEL#define DEBUG_LEVEL LOG_INFO#endif#define STRING_MSG &quot;MSG&quot;FILE *logfile = NULL;bool syslog_enable = false;void __attribute__ ((constructor)) init() { syslog_enable = false; logfile = stderr;}#define alloc_sprintf(__alloc_sprintf_str, __format...) do { \\ int __alloc_sprintf_len = snprintf(NULL, 0, __format); \\ (__alloc_sprintf_str) = malloc(__alloc_sprintf_len+1); \\ if(__alloc_sprintf_str != NULL) \\ snprintf(__alloc_sprintf_str, __alloc_sprintf_len+1, __format); \\} while(0)#define logger(level, msg...) do { \\ if(level &lt;= DEBUG_LEVEL) { \\ fprintf(logfile, &quot;[%ld] &quot;, (long) getpid()); \\ fprintf(logfile, msg); \\ fprintf(logfile, &quot;\\n&quot;); \\ } \\ if(syslog_enable) { \\ char *data; \\ alloc_sprintf(data, msg); \\ syslog(level, &quot;%s&quot;, data); \\ safe_free(data); \\ } \\} while(0)#define COND_RET(x, ret, msg...) \\ do { \\ if(!(x)) { \\ if(errno != 0) logger(LOG_ERR, &quot;Error(%d): %s&quot;, errno, strerror(errno)); \\ logger(LOG_ERR, &quot;%s:%d&quot;, __FILE__, __LINE__); \\ logger(LOG_ERR, &quot;unmet condition:\\&quot;%s\\&quot;&quot;, #x); \\ logger(LOG_ERR, msg); \\ ret; \\ } \\ errno = 0; \\ } while(0)#define CHECK(x, msg...) COND_RET(x, return -1;, msg)#define CHECK_EXIT(x, msg...) COND_RET(x, exit(EXIT_FAILURE);, msg)#define CHECK_LOG(x, msg...) COND_RET(x, ;, msg)#define safe_free(__safe_free_ptr) do { if(__safe_free_ptr) { free(__safe_free_ptr); (__safe_free_ptr) = NULL;} } while(0)#define BUFFER_SIZE 4096union semun { int val; struct semid_ds *buf; unsigned short *array;#if defined(__linux__) struct seminfo *__buf;#endif};typedef struct { int semid;}EventFlag_t;int incrsem(int sem_id, int semnum, short incr, short flg) { struct sembuf sembuf; sembuf = (struct sembuf){ .sem_num=semnum, .sem_flg=flg, .sem_op=incr }; return semop(sem_id, &amp;sembuf, 1);}int P(int sem_id) { return incrsem(sem_id, 0, -1, 0);}int V(int sem_id) { return incrsem(sem_id, 0, 1, 0);}int waitFor(int sem_id) { return incrsem(sem_id, 1, 0, 0);}int getsem(int sem_id, int semnum, short *n) { union semun arg; int ret = semctl(sem_id, semnum, GETVAL, arg); *n = ret; return ret;}int setsem(int sem_id, int semnum, short n) { union semun arg; arg.val = n; return semctl(sem_id, semnum, SETVAL, arg);}int notifyAll(int sem_id) { return setsem(sem_id, 1, 0);}EventFlag_t *newEventFlag(const char *file, char x) { EventFlag_t eventFlag; key_t key = ftok(file, x); eventFlag.semid = semget(key, 4, IPC_CREAT | IPC_EXCL | 0666); // sem[0] as mutex, sem[1] as notifier, sem[2]|sem[3] as flag union semun arg; if(eventFlag.semid == -1) { if(errno == EEXIST) { eventFlag.semid = semget(key, 4, 0666); COND_RET(eventFlag.semid != -1, return NULL, STRING_MSG); struct semid_ds ds; arg.buf = &amp;ds; COND_RET(semctl(eventFlag.semid, 0, IPC_STAT, arg) != -1, return NULL, STRING_MSG); while (ds.sem_otime == 0) { logger(LOG_INFO, &quot;waiting for sem init&quot;); sleep(1); COND_RET(semctl(eventFlag.semid, 0, IPC_STAT, arg) != -1, return NULL, STRING_MSG); } logger(LOG_INFO, &quot;semget get old&quot;); } else { CHECK_LOG(false, STRING_MSG); return NULL; } } else { arg.array = (unsigned short *)&amp;(unsigned short[]){0, 0, 0, 0}; // sem[0] = 1, sem[1] = 0 if(semctl(eventFlag.semid, 0, SETALL, arg) == -1) { CHECK_LOG(false, STRING_MSG); CHECK_LOG(semctl(eventFlag.semid, 0, IPC_RMID) != -1, STRING_MSG); return NULL; } if(incrsem(eventFlag.semid, 0,1,0) == -1) { CHECK_LOG(false, STRING_MSG); CHECK_LOG(semctl(eventFlag.semid, 0, IPC_RMID) != -1, STRING_MSG); return NULL; } logger(LOG_INFO, &quot;semget create new&quot;); } return memcpy(malloc(sizeof(EventFlag_t)), &amp;eventFlag, sizeof(EventFlag_t));}int __setEventFlag(EventFlag_t *eventFlag, int flag) { short currentFlag; CHECK(getsem(eventFlag-&gt;semid, 2, &amp;currentFlag) != -1, STRING_MSG); CHECK(setsem(eventFlag-&gt;semid, 2, currentFlag | (flag &amp; 0xffff)) != -1, STRING_MSG); CHECK(getsem(eventFlag-&gt;semid, 3, &amp;currentFlag) != -1, STRING_MSG); CHECK(setsem(eventFlag-&gt;semid, 3, currentFlag | ((flag &gt;&gt; 16) &amp; 0xffff)) != -1, STRING_MSG); CHECK(notifyAll(eventFlag-&gt;semid) != -1, STRING_MSG);}int setEventFlag(EventFlag_t *eventFlag, int flag) { CHECK(P(eventFlag-&gt;semid) != -1, STRING_MSG); CHECK(__setEventFlag(eventFlag, flag) != -1, STRING_MSG); CHECK(V(eventFlag-&gt;semid) != -1, STRING_MSG); return 0;}int __clearEventFlag(EventFlag_t *eventFlag, int flag) { short currentFlag; CHECK(getsem(eventFlag-&gt;semid, 2, &amp;currentFlag) != -1, STRING_MSG); CHECK(setsem(eventFlag-&gt;semid, 2, currentFlag &amp; ~(flag &amp; 0xffff)) != -1, STRING_MSG); CHECK(getsem(eventFlag-&gt;semid, 3, &amp;currentFlag) != -1, STRING_MSG); CHECK(setsem(eventFlag-&gt;semid, 3, currentFlag &amp; ~((flag &gt;&gt; 16) &amp; 0xffff)) != -1, STRING_MSG);// CHECK(notifyAll(eventFlag-&gt;semid) != -1, STRING_MSG); return 0;}int clearEventFlag(EventFlag_t *eventFlag, int flag) { CHECK(P(eventFlag-&gt;semid) != -1, STRING_MSG); CHECK(__clearEventFlag(eventFlag, flag) != -1, STRING_MSG); CHECK(V(eventFlag-&gt;semid) != -1, STRING_MSG); return 0;}int __getEventFlag(EventFlag_t *eventFlag, int *flag) { if(flag) { short currentFlag = 0; int ret = 0; CHECK(getsem(eventFlag-&gt;semid, 2, &amp;currentFlag) != -1, STRING_MSG); ret |= currentFlag; CHECK(getsem(eventFlag-&gt;semid, 3, &amp;currentFlag) != -1, STRING_MSG); ret |= currentFlag &lt;&lt; 16; *flag = ret; return 0; } return -1;}int getEventFlag(EventFlag_t *eventFlag, int *flag) { CHECK(P(eventFlag-&gt;semid) != -1, STRING_MSG); CHECK_LOG(__getEventFlag(eventFlag, flag) != -1, STRING_MSG); CHECK(V(eventFlag-&gt;semid) != -1, STRING_MSG); return 0;}#define waitForMethod(eventFlag, flag, method) do { \\ int currentFlag;\\ CHECK(P(eventFlag-&gt;semid) != -1, STRING_MSG);\\ __getEventFlag(eventFlag, &amp;currentFlag); \\ while (method) {\\ CHECK(V(eventFlag-&gt;semid) != -1, STRING_MSG);\\ CHECK(waitFor(eventFlag-&gt;semid) != -1, STRING_MSG);\\ CHECK(P(eventFlag-&gt;semid) != -1, STRING_MSG);\\ __getEventFlag(eventFlag, &amp;currentFlag); \\ }\\ CHECK(V(eventFlag-&gt;semid) != -1, STRING_MSG);\\} while(0)int waitForAny(EventFlag_t *eventFlag, int flag) { waitForMethod(eventFlag, flag, (currentFlag &amp; flag) == 0); return 0;}int waitForAll(EventFlag_t *eventFlag, int flag) { waitForMethod(eventFlag, flag, (currentFlag &amp; flag) != flag); return 0;}int waitForAllAndClear(EventFlag_t *eventFlag, int flag) { int currentFlag; CHECK(P(eventFlag-&gt;semid) != -1, STRING_MSG); __getEventFlag(eventFlag, &amp;currentFlag); while ((currentFlag &amp; flag) != flag) { CHECK(V(eventFlag-&gt;semid) != -1, STRING_MSG); CHECK(waitFor(eventFlag-&gt;semid) != -1, STRING_MSG); CHECK(P(eventFlag-&gt;semid) != -1, STRING_MSG); __getEventFlag(eventFlag, &amp;currentFlag); } __clearEventFlag(eventFlag, flag); CHECK(V(eventFlag-&gt;semid) != -1, STRING_MSG); return 0;}void destroyEventFlag(EventFlag_t **eventFlag) { if(eventFlag) { if(*eventFlag) { semctl((*eventFlag)-&gt;semid, 0, IPC_RMID); } safe_free(*eventFlag); }}#define WRITE_FLAG 1#define READ_FLAG 2struct ShmStruct { ssize_t len; char buf[BUFFER_SIZE - sizeof(int)];};void onExitEventFlag(int status, void *arg) { destroyEventFlag((EventFlag_t **)&amp;arg); logger(LOG_INFO, &quot;onExitEventFlag, status = %d&quot;, status);}void onExitSHM(int status, void *id) { shmctl(*(int *)id, IPC_RMID, NULL); logger(LOG_INFO, &quot;onExitSHM, status = %d&quot;, status);}void onExitSHMdt(int status, void *ptr) { shmdt(ptr); logger(LOG_INFO, &quot;onExitSHMdt, status = %d&quot;, status);}void handler(int sig) { exit(0);}int main(int argc, char **argv) { CHECK_EXIT(argc == 2, &quot;Usage: %s writer|reader&quot;, argv[0]); signal(SIGINT, handler); signal(SIGTERM, handler); signal(SIGHUP, handler); EventFlag_t *eventFlag = newEventFlag(argv[0], 'a'); on_exit(onExitEventFlag, eventFlag); key_t key = ftok(argv[0], 'c'); CHECK_EXIT(key != -1, STRING_MSG); int shmid = shmget(key, BUFFER_SIZE, IPC_CREAT | IPC_EXCL | 0666); int savedErrno = errno; CHECK_EXIT(shmid != -1 || errno == EEXIST, STRING_MSG); if(shmid != -1) { setEventFlag(eventFlag, WRITE_FLAG); } else { if(savedErrno == EEXIST) { shmid = shmget(key, BUFFER_SIZE, 0666); } else { CHECK_EXIT(false, &quot;code will never reach&quot;); } } on_exit(onExitSHM, &amp;shmid); struct ShmStruct *shmp = shmat(shmid, NULL, 0); CHECK_EXIT(shmp != NULL, STRING_MSG); on_exit(onExitSHMdt, shmp); if(!strcmp(argv[1], &quot;writer&quot;)) { size_t size = 0; bool stop = false; for(int i = 0; !stop ;i++) { CHECK_EXIT(waitForAllAndClear(eventFlag, WRITE_FLAG) != -1, STRING_MSG); logger(LOG_INFO, &quot;write start&quot;); CHECK_EXIT((shmp-&gt;len = read(STDIN_FILENO, shmp-&gt;buf, BUFFER_SIZE - sizeof(int))) &gt;= 0, STRING_MSG); size += shmp-&gt;len; if(shmp-&gt;len == 0) { stop = true; } CHECK_EXIT(setEventFlag(eventFlag, READ_FLAG) != -1, STRING_MSG); logger(LOG_INFO, &quot;write end: i = %d, size = %lu&quot;, i, size); } } else { size_t size = 0; bool stop = false; for(int i = 0; !stop ;i++) { CHECK_EXIT(waitForAllAndClear(eventFlag, READ_FLAG) != -1, STRING_MSG); logger(LOG_INFO, &quot;read start&quot;); CHECK_EXIT(write(STDIN_FILENO, shmp-&gt;buf, shmp-&gt;len) == shmp-&gt;len, STRING_MSG); size += shmp-&gt;len; if(shmp-&gt;len == 0) { stop = true; } CHECK_EXIT(setEventFlag(eventFlag, WRITE_FLAG) != -1, STRING_MSG); logger(LOG_INFO, &quot;read end: i = %d, size = %lu&quot;, i, size); } }} 48.2解释为何程序清单48-3在 for 循环被修改成如下形式时会错误地报告了传输字节数。 123456for (xfrs =0,bytes = 0; shmp-&gt;cnt != 0; xfrs++,bytes += shmp-&gt;cnt) { reserveSem(semid,READ SEM); /*Wait for return*/ if(write(STDOUT_FILENO,shmp-&gt;buf,shmp-&gt;cnt) != shmp-&gt;cnt) fatal(&quot;write&quot;); releaseSem(semid,WRITE SEM); /*Give writer a return*/} 原版代码 1234567for (xfrs =0; shmp-&gt;cnt != 0; xfrs++) { reserveSem(semid,READ SEM); /*Wait for return*/ if(write(STDOUT_FILENO,shmp-&gt;buf,shmp-&gt;cnt) != shmp-&gt;cnt) fatal(&quot;write&quot;); bytes += shmp-&gt;cnt; releaseSem(semid,WRITE SEM); /*Give writer a return*/} 很显然，他将bytes的自增放在了Sem锁定区域之外，由于shmp指向的是共享内存，在releaseSem到bytes增加之间，shmp指向的区域内存中的值可能已经发生改变，造成统计不准确。 48.5编写一个目录服务使之使用一个共享内存段来发布名称-值对。程序需要提供一个API来允许调用者创建新名称、修改一个既有名称、删除一个既有名称以及获取与个名称相关联的值。使用信号量来确保一个执行共享内存段更新操作的进程能够互斥地访问段。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369//// Created by root on 9/14/23.//#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;stdbool.h&gt;#include &lt;stddef.h&gt;#include &lt;syslog.h&gt;#include &lt;wait.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/shm.h&gt;#define DEBUG_LEVEL LOG_DEBUG#ifndef DEBUG_LEVEL#define DEBUG_LEVEL LOG_INFO#endif#define STRING_MSG &quot;MSG&quot;FILE *logfile = NULL;bool syslog_enable = false;void __attribute__ ((constructor)) init() { syslog_enable = false; logfile = stderr;}#define alloc_sprintf(__alloc_sprintf_str, __format...) do { \\ int __alloc_sprintf_len = snprintf(NULL, 0, __format); \\ (__alloc_sprintf_str) = malloc(__alloc_sprintf_len+1); \\ if(__alloc_sprintf_str != NULL) \\ snprintf(__alloc_sprintf_str, __alloc_sprintf_len+1, __format); \\} while(0)#define logger(level, msg...) do { \\ if(level &lt;= DEBUG_LEVEL) { \\ fprintf(logfile, &quot;[%ld] &quot;, (long) getpid()); \\ fprintf(logfile, msg); \\ fprintf(logfile, &quot;\\n&quot;); \\ } \\ if(syslog_enable) { \\ char *__syslog_enable__data; \\ alloc_sprintf(__syslog_enable__data, msg); \\ syslog(level, &quot;%s&quot;, __syslog_enable__data); \\ safe_free(__syslog_enable__data); \\ } \\} while(0)#define COND_RET(x, ret, msg...) \\ do { \\ if(!(x)) { \\ if(errno != 0) logger(LOG_ERR, &quot;Error(%d): %s&quot;, errno, strerror(errno)); \\ logger(LOG_ERR, &quot;%s:%d&quot;, __FILE__, __LINE__); \\ logger(LOG_ERR, &quot;unmet condition:\\&quot;%s\\&quot;&quot;, #x); \\ logger(LOG_ERR, msg); \\ ret; \\ } \\ errno = 0; \\ } while(0)#define CHECK(x, msg...) COND_RET(x, return -1;, msg)#define CHECK_EXIT(x, msg...) COND_RET(x, exit(EXIT_FAILURE);, msg)#define CHECK_LOG(x, msg...) COND_RET(x, ;, msg)#define safe_free(__safe_free_ptr) do { if(__safe_free_ptr) { free(__safe_free_ptr); (__safe_free_ptr) = NULL;} } while(0)#define BUFFER_SIZE 4096*4096union semun { int val; struct semid_ds *buf; unsigned short *array;#if defined(__linux__) struct seminfo *__buf;#endif};int incrsem(int sem_id, int semnum, short incr, short flg) { struct sembuf sembuf; sembuf = (struct sembuf){ .sem_num=semnum, .sem_flg=flg, .sem_op=incr }; return semop(sem_id, &amp;sembuf, 1);}int P(int sem_id, int semnum) { return incrsem(sem_id, semnum, -1, 0);}int V(int sem_id, int semnum) { return incrsem(sem_id, semnum, 1, 0);}int getsem(int sem_id, int semnum, short *n) { union semun arg; int ret = semctl(sem_id, semnum, GETVAL); *n = ret; return ret;}int setsem(int sem_id, int semnum, short n) { union semun arg; arg.val = n; return semctl(sem_id, semnum, SETVAL, arg);}int newMutex(const char *file, char x, int semcnt) { key_t key = ftok(file, x); int semid = semget(key, semcnt, IPC_CREAT | IPC_EXCL | 0666); // sem[0] as mutex, sem[1] as notifier, sem[2]|sem[3] as flag union semun arg; if(semid == -1) { if(errno == EEXIST) { semid = semget(key, semcnt, 0666); CHECK(semid != -1, STRING_MSG); struct semid_ds ds; arg.buf = &amp;ds; CHECK(semctl(semid, 0, IPC_STAT, arg) != -1, STRING_MSG); while (ds.sem_otime == 0) { logger(LOG_INFO, &quot;waiting for sem init&quot;); sleep(1); CHECK(semctl(semid, 0, IPC_STAT, arg) != -1, STRING_MSG); } logger(LOG_INFO, &quot;semget get old: %d&quot;, semid); } else { CHECK_LOG(false, STRING_MSG); return -1; } } else { arg.array = (unsigned short *)malloc(sizeof(unsigned short) * semcnt); // sem[0] = 0, sem[1] = 1, sem[2] = 1, ... for(int i = 0; i &lt; semcnt; i++) { arg.array[i] = 1; } arg.array[0] = 0; if(semctl(semid, 0, SETALL, arg) == -1) { CHECK_LOG(false, STRING_MSG); CHECK_LOG(semctl(semid, 0, IPC_RMID) != -1, STRING_MSG); return -1; } safe_free(arg.array); if(incrsem(semid, 0,1,0) == -1) { CHECK_LOG(false, STRING_MSG); CHECK_LOG(semctl(semid, 0, IPC_RMID) != -1, STRING_MSG); return -1; } logger(LOG_INFO, &quot;semget create new: %d&quot;, semid); } return semid;}void handler(int sig) { logger(LOG_INFO, &quot;received signal(%d):%s&quot;, sig, strsignal(sig)); exit(0);}#define KVMax 1024*8#define KMax 1024#define VMax 1024struct KVData { char key[KMax]; char val[VMax];};void *initshm(int argc, char *argv[], int *shmid) { signal(SIGINT, handler); signal(SIGTERM, handler); signal(SIGHUP, handler); key_t key = ftok(argv[0], 'c'); CHECK_EXIT(key != -1, STRING_MSG); *shmid = shmget(key, BUFFER_SIZE, IPC_CREAT | IPC_EXCL | 0666); int savedErrno = errno; CHECK_EXIT(*shmid != -1 || errno == EEXIST, STRING_MSG); bool creator = false; if(*shmid == -1) { if(savedErrno == EEXIST) { *shmid = shmget(key, BUFFER_SIZE, 0666); } else { CHECK_EXIT(false, &quot;code will never reach&quot;); } } else { creator = true; } void *shmp = shmat(*shmid, NULL, 0); CHECK_EXIT(shmp != NULL, STRING_MSG); if(creator) memset(shmp, 0, BUFFER_SIZE); return shmp;}int getValue(int semid, char *head, char* key, char *value) { CHECK(head != NULL, &quot;head should not be null&quot;); CHECK(key != NULL, &quot;key should not be null&quot;); CHECK(value != NULL, &quot;value should not be null&quot;); bool ok = false; for(int i = 0; i &lt; KVMax &amp;&amp; !ok; i++) { CHECK(P(semid, i) != -1, STRING_MSG); struct KVData *data = (struct KVData *)head; if(!strcmp(key, data-&gt;key)) { logger(DEBUG_LEVEL, &quot;data-&gt;key = %s&quot;, data-&gt;key); logger(DEBUG_LEVEL, &quot;data-&gt;val = %s&quot;, data-&gt;val); strncpy(value, data-&gt;val, VMax); value[VMax-1] = 0; ok = true; } else { head += sizeof(struct KVData); } CHECK(V(semid, i) != -1, STRING_MSG); } if(!ok) return -1; return 0;}int setValue(int semid, char *head, char* key, char *value) { CHECK(head != NULL, &quot;head should not be null&quot;); CHECK(key != NULL, &quot;key should not be null&quot;); CHECK(value != NULL, &quot;value should not be null&quot;); bool ok = false; for(int i = 0; i &lt; KVMax &amp;&amp; !ok; i++) { CHECK(P(semid, i) != -1, STRING_MSG); struct KVData *data = (struct KVData *)head; logger(DEBUG_LEVEL, &quot;data = %p, key = %s, val = %s&quot;, data, data-&gt;key, data-&gt;val); if(!strcmp(key, data-&gt;key)) { strncpy(data-&gt;val, value, VMax); data-&gt;val[VMax-1] = 0; ok = true; } else { head += sizeof(struct KVData); } CHECK(V(semid, i) != -1, STRING_MSG); } if(!ok) return -1; return 0;}int addKV(int semid, char *head, char* key, char *value) { CHECK(head != NULL, &quot;head should not be null&quot;); CHECK(key != NULL, &quot;key should not be null&quot;); CHECK(value != NULL, &quot;value should not be null&quot;); bool ok = false; for(int i = 0; i &lt; KVMax &amp;&amp; !ok; i++) { CHECK(P(semid, i) != -1, STRING_MSG); struct KVData *data = (struct KVData *)head; if(!*data-&gt;key) { logger(DEBUG_LEVEL, &quot;i = %d, data = %p&quot;, i, data); strncpy(data-&gt;key, key, KMax); strncpy(data-&gt;val, value, VMax); data-&gt;key[KMax-1] = 0; data-&gt;val[VMax-1] = 0; ok = true; } else { head += sizeof(struct KVData); } CHECK(V(semid, i) != -1, STRING_MSG); } if(!ok) return -1; return 0;}int getAll(int semid, char *head, char *value) { CHECK(head != NULL, &quot;head should not be null&quot;); CHECK(value != NULL, &quot;value should not be null&quot;); char *ret = value; for(int i = 0; i &lt; KVMax; i++) { CHECK(P(semid, i) != -1, STRING_MSG); struct KVData *data = (struct KVData *)head; if(*data-&gt;key) { strncpy(ret, data-&gt;key, KMax); ret = strchr(ret, '\\0'); strcpy(ret, &quot;:&quot;); ret++; strncpy(ret, data-&gt;val, VMax); ret = strchr(ret, '\\0'); strcpy(ret, &quot;\\n&quot;); ret++; } head += sizeof(struct KVData); CHECK(V(semid, i) != -1, STRING_MSG); } return 0;}int rmKV(int semid, char *head, char* key, char *value) { CHECK(key != NULL, &quot;key should not be null&quot;); CHECK(head != NULL, &quot;head should not be null&quot;); CHECK(value != NULL, &quot;value should not be null&quot;); bool ok = false; for(int i = 0; i &lt; KVMax &amp;&amp; !ok; i++) { CHECK(P(semid, i) != -1, STRING_MSG); struct KVData *data = (struct KVData *)head; if(!strcmp(key, data-&gt;key)) { strncpy(value, data-&gt;val, VMax); value[VMax-1] = 0; data-&gt;key[0] = 0; data-&gt;val[0] = 0; ok = true; } else { head += sizeof(struct KVData); } CHECK(V(semid, i) != -1, STRING_MSG); } if(!ok) return -1; return 0;}int main(int argc, char *argv[]) { CHECK_EXIT(argc &gt; 1, &quot;Usage: %s add|get|set|getAll|rm|destroy&quot;, argv[0]); int shmid; char *shmp = initshm(argc, argv, &amp;shmid); int mutexid = newMutex(argv[0], 'a', KVMax+1); CHECK_EXIT(mutexid != -1, STRING_MSG); if(!strcmp(&quot;get&quot;, argv[1])) { CHECK_EXIT(argc &gt; 2, &quot;Usage: %s set [key]&quot;, argv[0]); char *value = malloc(VMax); for(int i = 2; i &lt; argc; i++) { getValue(mutexid, shmp, argv[i], value); logger(LOG_INFO, &quot;value for \\&quot;%s\\&quot; is %s&quot;, argv[i], value); } safe_free(value); } else if(!strcmp(&quot;set&quot;, argv[1])) { CHECK_EXIT(argc &gt; 2, &quot;Usage: %s set [key:value]&quot;, argv[0]); for(int i = 2; i &lt; argc; i++) { char *value = strchr(argv[i], ':'); if(!value) { CHECK_EXIT(false, &quot;Usage: %s set [key:value]&quot;, argv[0]); } *value = 0; value++; setValue(mutexid, shmp, argv[i], value); logger(LOG_INFO, &quot;value for \\&quot;%s\\&quot; is %s&quot;, argv[i], value); } } else if(!strcmp(&quot;add&quot;, argv[1])) { CHECK_EXIT(argc &gt; 2, &quot;Usage: %s add [key:value]&quot;, argv[0]); for(int i = 2; i &lt; argc; i++) { char *value = strchr(argv[i], ':'); if(!value) { CHECK_EXIT(false, &quot;Usage: %s set [key:value]&quot;, argv[0]); } *value = 0; value++; addKV(mutexid, shmp, argv[i], value); logger(LOG_INFO, &quot;value for \\&quot;%s\\&quot; is %s&quot;, argv[i], value); } } else if(!strcmp(&quot;rm&quot;, argv[1])) { CHECK_EXIT(argc &gt; 2, &quot;Usage: %s add [key:value]&quot;, argv[0]); char *value = malloc(VMax); for(int i = 2; i &lt; argc; i++) { rmKV(mutexid, shmp, argv[i], value); logger(LOG_INFO, &quot;value for \\&quot;%s\\&quot; is %s&quot;, argv[i], value); } safe_free(value); } else if(!strcmp(&quot;getAll&quot;, argv[1])) { char *value = malloc((VMax + KMax) * KVMax); getAll(mutexid, shmp, value); logger(LOG_INFO, &quot;getAll&quot;); logger(LOG_INFO, &quot;%s&quot;, value); safe_free(value); } else if(!strcmp(&quot;destroy&quot;, argv[1])) { CHECK_LOG(semctl(mutexid, 0, IPC_RMID) != -1, STRING_MSG); CHECK_LOG(shmctl(shmid, IPC_RMID, NULL) != -1, STRING_MSG); } else { CHECK_EXIT(false, &quot;unknown operator: %s&quot;, argv[1]); } return 0;}","link":"/home/2023/09/14/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha48/"},{"title":"cha50.虚拟内存操作","text":"50.1编写一个程序使其为RLIMITMEMLOCK资源限制设置一个值之后将数量超过这个限制的内存锁进内存来验证RLIMITMEMLOCK资源限制的作用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136//// Created by root on 7/18/23.//#include &lt;utils.h&gt;#include &lt;limits.h&gt;#include &lt;sys/resource.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;signal.h&gt;#define USER 10087void test(__rlimit_resource_t res, const char *name,void (*task)(__rlimit_resource_t res, struct rlimit *)) { logger(LOG_INFO, &quot;test: %d(%s)&quot;, res, name); pid_t pid; CHECK_RET((pid = fork()) != -1, return;); if(!pid) { struct rlimit lim; CHECK_RET(getrlimit(res, &amp;lim) != -1, return;); logger(LOG_INFO, &quot;soft=%lu, hard=%lu&quot;, lim.rlim_cur, lim.rlim_max); task(res, &amp;lim); logger(LOG_INFO, &quot;soft=%lu, hard=%lu&quot;, lim.rlim_cur, lim.rlim_max); exit(0); } int status; CHECK_RET(waitpid(pid, &amp;status, 0) != -1, return;); if(WIFSIGNALED(status)) logger(LOG_INFO, &quot;status:%d, coredump:%d, term sig:%s(%d)&quot;, WEXITSTATUS(status), WCOREDUMP(status), strsignal(WTERMSIG(status)), WTERMSIG(status)); else if(WIFSTOPPED(status)) logger(LOG_INFO, &quot;status:%d, coredump:%d, term sig:%s(%d)&quot;, WEXITSTATUS(status), WCOREDUMP(status), strsignal(WSTOPSIG(status)), WSTOPSIG(status)); else logger(LOG_INFO, &quot;status:%d, coredump:%d&quot;, WEXITSTATUS(status), WCOREDUMP(status)); CHECK_RET(WEXITSTATUS(status) != 0 || WCOREDUMP(status) || WIFSTOPPED(status) || WIFSIGNALED(status), return;);}#define invoke_test(res) test(res, #res, f##res)#define fun(name) void f##name(__rlimit_resource_t res, struct rlimit *lim)fun(RLIMIT_MEMLOCK) { long pagesize = sysconf(_SC_PAGESIZE); bool error_occured = false; lim-&gt;rlim_cur = lim-&gt;rlim_max = pagesize * 2; // = pagesize时，lock一个也会出错，可能已经默认有一页的内存被lock了（比如代码段，数据段 CHECK_EXIT(setrlimit(res, lim) != -1); CHECK_EXIT(setuid(USER) != -1); void *mem; mem = malloc(pagesize*2); CHECK_LOG(mem != NULL); if(mlock(mem, pagesize) == -1) { //success CHECK_LOG(false); error_occured = true; } CHECK_LOG(munlock(mem, pagesize) != -1); safe_free(mem); mem = malloc(pagesize*3); CHECK_LOG(mem != NULL); if(mlock(mem, pagesize*2) == -1) { //fail CHECK_LOG(false); error_occured = true; } CHECK_LOG(munlock(mem, pagesize *2) != -1); safe_free(mem); if((mem = mmap(NULL, pagesize *3, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS | MAP_LOCKED, -1, 0)) == MAP_FAILED) { //fail CHECK_LOG(false); error_occured = true; } else { CHECK_LOG(munmap(mem, pagesize *3) != -1); } CHECK_LOG((mem = mmap(NULL, pagesize *3, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0)) != MAP_FAILED); if(mlock(mem, pagesize*3) == -1) { //fail CHECK_LOG(false); error_occured = true; } CHECK_LOG(munmap(mem, pagesize *3) != -1); if(error_occured) { exit(1); } exit(0);}#define BUFFER_SIZE 2048struct msgType { long mtype; char mcontent[BUFFER_SIZE];};#define REQ_SIZE (BUFFER_SIZE)void on_exit_msg(int status, void *id) { CHECK_LOG(msgctl(*(int *)id, IPC_RMID, NULL) != -1);}void timeout(int sig) { logger(LOG_INFO, &quot;received sig(%d):%s&quot;, sig, strsignal(sig)); exit(1); // CHECK_LOG(signal(SIGALRM, SIG_DFL) != SIG_ERR); // raise(SIGALRM);}fun(RLIMIT_MSGQUEUE) { struct msgType msg; msg.mtype = 1; strcpy(msg.mcontent, &quot;Meow!!&quot;); int id; CHECK_EXIT((id = msgget(IPC_PRIVATE, IPC_CREAT | 0666)) != -1); CHECK_EXIT(msgsnd(id, &amp;msg, REQ_SIZE, 0) != -1); CHECK_EXIT(msgctl(id, IPC_RMID, NULL) != -1); lim-&gt;rlim_cur = lim-&gt;rlim_max = BUFFER_SIZE/2; CHECK_EXIT(setrlimit(res, lim) != -1); CHECK_EXIT(setuid(USER) != -1); on_exit(on_exit_msg, &amp;id); CHECK_EXIT(signal(SIGALRM, timeout) != SIG_ERR); CHECK_EXIT((id = msgget(IPC_PRIVATE, IPC_CREAT | 0666)) != -1); CHECK_EXIT(msgsnd(id, &amp;msg, REQ_SIZE, 0) != -1); CHECK_EXIT(msgsnd(id, &amp;msg, REQ_SIZE, 0) != -1); CHECK_EXIT(msgsnd(id, &amp;msg, REQ_SIZE, 0) != -1); CHECK_EXIT(msgsnd(id, &amp;msg, REQ_SIZE, 0) != -1); CHECK_EXIT(msgsnd(id, &amp;msg, REQ_SIZE, 0) != -1); CHECK_EXIT(msgsnd(id, &amp;msg, REQ_SIZE, 0) != -1); CHECK_EXIT(msgsnd(id, &amp;msg, REQ_SIZE, 0) != -1); CHECK_EXIT(msgsnd(id, &amp;msg, REQ_SIZE, 0) != -1); CHECK_EXIT(alarm(1) != -1); CHECK_EXIT(msgsnd(id, &amp;msg, REQ_SIZE, 0) != -1);}fun(RLIMIT_RSS);int main(int argc, char ** argv) { invoke_test(RLIMIT_MEMLOCK); //还没学 invoke_test(RLIMIT_MSGQUEUE); //还没学// invoke_test(RLIMIT_RSS); //linux没作用} 50.2写一个程序来验证madvise MADV DONTNEED操作在一个可写MAP_PRIVATE映射上的操作。 12345678910111213141516171819202122//// Created by root on 7/18/23.//#include &lt;utils.h&gt;#include &lt;limits.h&gt;#include &lt;sys/resource.h&gt;#include &lt;sys/mman.h&gt;int main(int argc, char ** argv) { long pagesize = sysconf(_SC_PAGESIZE); char *mem; CHECK_EXIT((mem = mmap(NULL, pagesize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)) != MAP_FAILED); memset(mem, 'a', pagesize); CHECK_EXIT(madvise(mem, pagesize, MADV_DONTNEED) != -1); for(int i = 0; i &lt; pagesize; i++) { if(mem[i] == 0) logger(LOG_INFO, &quot;mem:%p filled with '\\\\0'&quot;, mem); else if(mem[i] == 'a') logger(LOG_INFO, &quot;mem:%p remains to be 'a'&quot;, mem); else logger(LOG_INFO, &quot;mem:%p contains dirty data&quot;, mem); } CHECK_EXIT(munmap(mem, pagesize) != -1);}","link":"/home/2023/09/19/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha50/"},{"title":"cha7.内存分配","text":"7.1 修改程序清单7-1中的程序(free_and_sbrk.c)，在每次执行malloc后打印出 program break的当前值。指定一个较小的内存分配尺寸来运行该程序。这将证明malloc不会在每次被调用时都调用sbrk()来调整program break 的位置，而是周期性地分配大块内存，并从中将小片内存返回给调用者。 1// 与代码7.2main相同 7.2 (高级)实现 malloc()和 free()。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#define CHECK(x, code, message, ...) if(!(x)) {fprintf(stderr, &quot;%s:%d, error: %s\\t----\\t&quot;, __FILE__, __LINE__, strerror(errno)); fprintf(stderr, (const char*)message, ##__VA_ARGS__); exit(code); }#define ERR(code, format, ...) fprintf(stderr, (const char*)format, ##__VA_ARGS__); exit(code)#define UNUSED 0#define USED 1#define EXIT_SBRK_FAIL 1#define UNKNOWN_FAIL 2#define UNKNOWN_MEM_ERROR 3#define FREE_TWICE 4#define MAXALLOC 100000void *freeMem = NULL;unsigned long getBlockSize(void *mem) { return *((unsigned long *)mem - 1);}void setBlockSize(void *mem, size_t size) { *((unsigned long *)mem - 1) = size;}void *getNextFreeBlock(void *__free) { return (unsigned long*) *((unsigned long *)__free + 1);}void setNextFreeBlock(void *__free, void *__ptr) { *((unsigned long *)__free + 1) = (unsigned long)__ptr;}void *getPrevFreeBlock(void *__free) { return (unsigned long*) *(unsigned long *)__free;}void setPrevFreeBlock(void *__free, void *__ptr) { *(unsigned long *)__free = (unsigned long)__ptr;}char getUsed(void *__ptr) { return *((char *)__ptr - 1 - sizeof(void *));}void setUsed(void *__ptr, char used) { *((char *)__ptr - 1 - sizeof(void *)) = used;}void memInit(char used, void *__ptr, void *prev, void *next, size_t size) { setUsed(__ptr, used); setBlockSize(__ptr, size); setPrevFreeBlock(__ptr, prev); setNextFreeBlock(__ptr, next);}void *firstFit(size_t size) { void *move = freeMem; void *next = getNextFreeBlock(freeMem); while(next != NULL) { if(getBlockSize(next) &gt;= size) { break; } move = next; next = getNextFreeBlock(next); } return move;}void *__malloc(size_t size) { if(freeMem == NULL) { freeMem = sbrk(sizeof(void *) * 3 + 1); CHECK(freeMem != (void*)-1, EXIT_SBRK_FAIL, &quot;sbrk fail\\n&quot;); freeMem += sizeof(void *) + 1; memInit(UNUSED, freeMem, NULL, NULL, sizeof(void *) * 2); } void *__free = firstFit(size); void *newMem = NULL; CHECK(__free != NULL, UNKNOWN_FAIL, &quot;unknown error\\n&quot;); if(getNextFreeBlock(__free) == NULL) { size = size &gt; 2 * sizeof(void *) ? size : 2 * sizeof(void *); newMem = sbrk(1 + sizeof(void *) + size); CHECK(newMem != (void*)-1, EXIT_SBRK_FAIL, &quot;sbrk fail\\n&quot;); newMem += 1 + sizeof(void *); memInit(USED, newMem, NULL, NULL, size); } else { newMem = getNextFreeBlock(__free); setUsed(newMem, USED); setNextFreeBlock(__free, getNextFreeBlock(newMem)); } return newMem;}void __free(void * __ptr) { CHECK(freeMem != NULL, UNKNOWN_MEM_ERROR,&quot;memory: %p is not allocated by __mallo\\n&quot;, __ptr); CHECK(getUsed(__ptr) == USED, FREE_TWICE, &quot;trying to free memory %p twice\\n&quot;, __ptr); setUsed(__ptr, UNUSED); void *move = freeMem; void *next = getNextFreeBlock(freeMem); void *front = (char *)__ptr - 1 - sizeof(void *), *back = (char *)__ptr + getBlockSize(__ptr); while(next != NULL) { if((char *)next - 1 - sizeof(void *) &gt;= (char *)back) { break; } move = next; next = getNextFreeBlock(next); } if(front == (char *)move + getBlockSize(move)) { setBlockSize(move, (char *)back - (char *)move); __ptr = move; } else { setNextFreeBlock(__ptr, getNextFreeBlock(move)); setNextFreeBlock(move, __ptr); setPrevFreeBlock(__ptr, move); } if(next == NULL) return; if(back == (char *)next - 1 - sizeof(void *)) { setBlockSize(__ptr, (char *)next + getBlockSize(next) - (char *)__ptr); } else { setPrevFreeBlock(next, __ptr); } return;}void __printMemblock(void* ptr) { printf(&quot;------------Memory Block %p---------------\\n&quot;, ptr); printf(&quot;front = %p, back = %p\\n&quot;, (char *)ptr - 1 - sizeof(void *), (char *)ptr + getBlockSize(ptr)); int used = *((char *)ptr - 1 - sizeof(unsigned long)); printf(&quot;used\\t\\t=\\t%d\\n&quot;, used); printf(&quot;blocksize\\t=\\t%lu\\n&quot;, *((unsigned long *)ptr - 1)); if(!used) { printf(&quot;last free block\\t=\\t%p\\n&quot;, (unsigned long*) *(unsigned long *)ptr); printf(&quot;next free block\\t=\\t%p\\n&quot;, (unsigned long*) *((unsigned long *)ptr + 1)); } printf(&quot;Current brk = %p\\n&quot;, sbrk(0));}void __showFreeBlocks() { printf(&quot;show free blocks\\n&quot;); void *move = freeMem; while(move) { __printMemblock(move); move = getNextFreeBlock(move); }}int main(int argc, char *argv[]) { if(argc &lt; 3) { ERR(1, &quot;Usage: %s numalloc blocksize [freestep] [freemin] [freemax]\\n&quot;, argv[0]); } int numalloc = atoi(argv[1]); size_t blocksize = atoi(argv[2]); int freestep = argc &gt; 3 ? atoi(argv[3]) : 1; int freemin = argc &gt; 4 ? atoi(argv[4]) : 1; int freemax = argc &gt; 5 ? atoi(argv[5]) : numalloc; void *ptr[MAXALLOC]; if(numalloc &gt; MAXALLOC) { ERR(2, &quot;constraint: numalloc &lt;= %d\\n&quot;, MAXALLOC); } printf(&quot;sizeof(void *) = %lu\\n&quot;, sizeof(void *)); printf(&quot;Start to allocate mem, Current program break: %p\\n&quot;, sbrk(0)); for(int i = 0; i &lt; numalloc; i++) { ptr[i] = __malloc(blocksize); if(ptr[i] == NULL) { ERR(3, &quot;fail to __malloc loc: %d\\n&quot;, i); } printf(&quot;Current program break: %p\\n&quot;, sbrk(0)); __printMemblock(ptr[i]); } for(int i = 0; i &lt; numalloc; i++) { __printMemblock(ptr[i]); } __showFreeBlocks(); printf(&quot;Allocation finished, Current program break: %p\\n&quot;, sbrk(0)); for(int i = freemin-1; i &lt; freemax; i += freestep) { __free(ptr[i]); printf(&quot;Current program break: %p\\n&quot;, sbrk(0)); __printMemblock(ptr[i]); } printf(&quot;Mem __free finished, Current program break: %p\\n&quot;, sbrk(0)); for(int i = freemin-1; i &lt; freemax; i += freestep) { __printMemblock(ptr[i]); } __showFreeBlocks(); return 0;} size_t和unsigned long以及void *类型转换之间还在报warning 没有字节对齐 malloc找不到合适的块时，每次都会sbrk抬升program break 只实现了first fit bug fix freeMem为空时先抬升program break，作为链表头节点，但是对这块内存的分配，memInit(UNUSED, freeMem, NULL, NULL, 0);，最后一个参数不应该是0，而应该是 2 * sizeof(void *)。 一次性分配大块内存123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#define CHECK(x, code, message, ...) if(!(x)) {fprintf(stderr, &quot;%s:%d, error: %s\\t----\\t&quot;, __FILE__, __LINE__, strerror(errno)); fprintf(stderr, (const char*)message, ##__VA_ARGS__); exit(code); }#define ERR(code, format, ...) fprintf(stderr, (const char*)format, ##__VA_ARGS__); exit(code)#define UNUSED 0#define USED 1#define EXIT_SBRK_FAIL 1#define UNKNOWN_FAIL 2#define UNKNOWN_MEM_ERROR 3#define FREE_TWICE 4#define MAXALLOC 100000#define PAGE 0x010000void *freeMem = NULL;unsigned long getBlockSize(void *mem) { return *((unsigned long *)mem - 1);}void setBlockSize(void *mem, size_t size) { *((unsigned long *)mem - 1) = size;}void *getNextFreeBlock(void *__free) { return (unsigned long*) *((unsigned long *)__free + 1);}void setNextFreeBlock(void *__free, void *__ptr) { *((unsigned long *)__free + 1) = (unsigned long)__ptr;}void *getPrevFreeBlock(void *__free) { return (unsigned long*) *(unsigned long *)__free;}void setPrevFreeBlock(void *__free, void *__ptr) { *(unsigned long *)__free = (unsigned long)__ptr;}char getUsed(void *__ptr) { return *((char *)__ptr - 1 - sizeof(void *));}void setUsed(void *__ptr, char used) { *((char *)__ptr - 1 - sizeof(void *)) = used;}void memInit(char used, void *__ptr, void *prev, void *next, size_t size) { setUsed(__ptr, used); setBlockSize(__ptr, size); setPrevFreeBlock(__ptr, prev); setNextFreeBlock(__ptr, next);}void *firstFit(size_t size) { void *move = freeMem; void *next = getNextFreeBlock(freeMem); while(next != NULL) { if(getBlockSize(next) &gt;= size) { break; } move = next; next = getNextFreeBlock(next); } return move;}void *__malloc(size_t size) { if(freeMem == NULL) { freeMem = sbrk(PAGE); CHECK(freeMem != (void*)-1, EXIT_SBRK_FAIL, &quot;sbrk fail\\n&quot;); freeMem += sizeof(void *) + 1; memInit(UNUSED, freeMem, NULL, freeMem + sizeof(void *) * 3 + 1, sizeof(void *) * 2); memInit(UNUSED, freeMem + sizeof(void *) * 3 + 1, freeMem, NULL, PAGE - (1 + sizeof(void *) + 1 + 3*sizeof(void *))); } void *__free = firstFit(size); void *newMem = NULL; CHECK(__free != NULL, UNKNOWN_FAIL, &quot;unknown error\\n&quot;); if(getNextFreeBlock(__free) == NULL) { size = size &gt; 2 * sizeof(void *) ? size : 2 * sizeof(void *); size_t newSize = PAGE * (size / PAGE + 1) + 1 + sizeof(void *) + 1 + 3 * sizeof(void *); newMem = sbrk(newSize); // 按页分配，再加一个链表头，一个完整链表头 CHECK(newMem != (void*)-1, EXIT_SBRK_FAIL, &quot;sbrk fail\\n&quot;); newMem += 1 + sizeof(void *); memInit(USED, newMem, NULL, NULL, size); void *next_free = (char *)newMem + size + 1 + sizeof(void *); setNextFreeBlock(__free, next_free); memInit(UNUSED, next_free, __free, NULL, newSize - (size + 1 + sizeof(void *) + 1 + sizeof(void *))); } else { newMem = getNextFreeBlock(__free); setUsed(newMem, USED); setNextFreeBlock(__free, getNextFreeBlock(newMem)); if(getBlockSize(newMem) &gt;= size + 1 + 3 * sizeof(void *)) { memInit(UNUSED, newMem + size + 1 + sizeof(void *), __free, getNextFreeBlock(__free), getBlockSize(newMem) - size - 1 - sizeof(void *)); setNextFreeBlock(__free, newMem + size + 1 + sizeof(void *)); if(getNextFreeBlock(newMem)) setPrevFreeBlock(getNextFreeBlock(newMem), newMem + size + 1 + sizeof(void *)); setBlockSize(newMem, size); } // 当前块的大小大于本次分配需要的大小，且剩余部分仍能放的的下一个完整的链表头，则将该部分再次初始化一个空闲节点，插入原双向链表中 } return newMem;}void __free(void * __ptr) { CHECK(freeMem != NULL, UNKNOWN_MEM_ERROR,&quot;memory: %p is not allocated by __mallo\\n&quot;, __ptr); CHECK(getUsed(__ptr) == USED, FREE_TWICE, &quot;trying to free memory %p twice\\n&quot;, __ptr); setUsed(__ptr, UNUSED); void *move = freeMem; void *next = getNextFreeBlock(freeMem); void *front = (char *)__ptr - 1 - sizeof(void *), *back = (char *)__ptr + getBlockSize(__ptr); while(next != NULL) { if((char *)next - 1 - sizeof(void *) &gt;= (char *)back) { break; } move = next; next = getNextFreeBlock(next); } if(front == (char *)move + getBlockSize(move) &amp;&amp; move != freeMem) { // move不是头节点，头节点不参与到内存分配中，不与后面的空闲内存合并 setBlockSize(move, (char *)back - (char *)move); __ptr = move; } else { setNextFreeBlock(__ptr, getNextFreeBlock(move)); setNextFreeBlock(move, __ptr); setPrevFreeBlock(__ptr, move); } if(next == NULL) return; if(back == (char *)next - 1 - sizeof(void *)) { setBlockSize(__ptr, (char *)next + getBlockSize(next) - (char *)__ptr); setNextFreeBlock(__ptr, getNextFreeBlock(next)); if(getNextFreeBlock(next)) setPrevFreeBlock(getNextFreeBlock(next), __ptr); } else { setPrevFreeBlock(next, __ptr); setNextFreeBlock(__ptr, next); } return;}void __printMemblock(void* ptr) { printf(&quot;------------Memory Block %p---------------\\n&quot;, ptr); printf(&quot;front = %p, back = %p\\n&quot;, (char *)ptr - 1 - sizeof(void *), (char *)ptr + getBlockSize(ptr)); int used = *((char *)ptr - 1 - sizeof(unsigned long)); printf(&quot;used\\t\\t=\\t%d\\n&quot;, used); printf(&quot;blocksize\\t=\\t%lu\\n&quot;, *((unsigned long *)ptr - 1)); if(!used) { printf(&quot;last free block\\t=\\t%p\\n&quot;, (unsigned long*) *(unsigned long *)ptr); printf(&quot;next free block\\t=\\t%p\\n&quot;, (unsigned long*) *((unsigned long *)ptr + 1)); } printf(&quot;Current brk = %p\\n&quot;, sbrk(0));}void __showFreeBlocks() { printf(&quot;show free blocks\\n&quot;); void *move = freeMem; while(move) { __printMemblock(move); move = getNextFreeBlock(move); }}int main(int argc, char *argv[]) { if(argc &lt; 3) { ERR(1, &quot;Usage: %s numalloc blocksize [freestep] [freemin] [freemax]\\n&quot;, argv[0]); } int numalloc = atoi(argv[1]); size_t blocksize = atoi(argv[2]); int freestep = argc &gt; 3 ? atoi(argv[3]) : 1; int freemin = argc &gt; 4 ? atoi(argv[4]) : 1; int freemax = argc &gt; 5 ? atoi(argv[5]) : numalloc; void *ptr[MAXALLOC]; if(numalloc &gt; MAXALLOC) { ERR(2, &quot;constraint: numalloc &lt;= %d\\n&quot;, MAXALLOC); } printf(&quot;sizeof(void *) = %lu\\n&quot;, sizeof(void *)); printf(&quot;Start to allocate mem, Current program break: %p\\n&quot;, sbrk(0)); for(int i = 0; i &lt; numalloc; i++) { ptr[i] = __malloc(blocksize); if(ptr[i] == NULL) { ERR(3, &quot;fail to __malloc loc: %d\\n&quot;, i); } printf(&quot;Current program break: %p\\n&quot;, sbrk(0)); __printMemblock(ptr[i]); __showFreeBlocks(); } for(int i = 0; i &lt; numalloc; i++) { __printMemblock(ptr[i]); } __showFreeBlocks(); printf(&quot;Allocation finished, Current program break: %p\\n&quot;, sbrk(0)); for(int i = freemin-1; i &lt; freemax; i += freestep) { __free(ptr[i]); printf(&quot;Current program break: %p\\n&quot;, sbrk(0)); __printMemblock(ptr[i]); __showFreeBlocks(); } printf(&quot;Mem __free finished, Current program break: %p\\n&quot;, sbrk(0)); for(int i = freemin-1; i &lt; freemax; i += freestep) { __printMemblock(ptr[i]); } __showFreeBlocks(); return 0;} free时如果内存块的front和前一个块的back相同，先判断move是否为头节点，不是头节点再合并，头节点不参与内存分配 头节点为空/找不到合适的块时，抬升program break，一次性分配多个page，把剩余部分作为新的空闲内存节点，加入到双向链表中 应该还有很多地方没考虑到，比如判断一个内存块是否是__malloc分配的 当freeStep为1时，最后剩余内存链表只剩两个节点，一个长度为16的头节点，和一个完整的内存块，且该内存块的back与当前program break相同。","link":"/home/2023/04/09/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha7/"},{"title":"cha6.进程","text":"练习1 编译程序清单6-1中的程序(mem_segments.c)，使用1s-l命令显示可执行文件的大小。虽然该程序包含一个大约10MB的数组，但可执行文件大小要远小于此,为什么? 局部变量，分配在栈中，运行时分配 练习2 编写一个程序，观察当使用 longjmp()函数跳转到一个已经返回的函数时会发生什么? 开优化会无限递归，不开优化也有可能无限递归 练习3 使用getenv()函数、putenv()函数，必要时可直接修改environ，来实现setenv()函数和unsetenv()函数。此处的unsetenv()函数应检查是否对环境变量进行了多次定义，如果是多次定义则将移除对该变量的所有定义(glibc版本的unsetenv()函数实现了这-功能) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;errno.h&gt;extern char **environ;int __setenv(const char *, const char *, int overwrite);// overwrite = 0, 已存在则不改变, return 0/-1int __unsetenv(const char *);// return 0/-1#define setenv(a,b,c) errno = 0; \\if(__setenv(a, b, c) == -1) { \\ perror(&quot;setenv&quot;); \\ exit(1); \\}#define unsetenv(a) errno = 0; \\if(__unsetenv(a) == -1) { \\ perror(&quot;unsetenv&quot;); \\ exit(1); \\}// #define GETENVvoid printEnv();int main(int argc, char **argv) { clearenv(); environ = (char **)malloc(argc*sizeof(char *)); for(int i = 1; i &lt; argc; i++) { environ[i-1] = argv[i]; environ[i-1] = argv[i]; } environ[argc-1] = NULL; printEnv(); setenv(&quot;Jingtianer&quot;, &quot;pretty&quot;, 1); setenv(&quot;Jingtianer&quot;, &quot;handsome&quot;, 1); setenv(&quot;Meeow&quot;, &quot;handsome&quot;, 0); setenv(&quot;Meeow&quot;, &quot;pretty&quot;, 0); printEnv(); unsetenv(&quot;Meeow&quot;); unsetenv(&quot;Jingtianer&quot;); unsetenv(&quot;A&quot;); printEnv(); return 0;}void printEnv() { printf(&quot;environ=%p\\n&quot;, environ); if(environ != NULL) for(char **env=environ; *env; env++) { printf(&quot;%s\\n&quot;, *env); }}int __setenv(const char *name, const char *val, int overwrite) { #ifndef GETENV size_t nameLen = strlen(name); char **env=environ; if(env) for(; *env; env++) { if(strncmp(name, *env, nameLen) == 0) { if(overwrite == 0) return 0; else break; } } char * envstr = (char *) malloc((nameLen+strlen(val)+1+1)*sizeof(char)); sprintf(envstr, &quot;%s=%s&quot;, name, val); if(env != NULL &amp;&amp; *env != NULL) { *env = envstr; } else { return putenv(envstr); } return 0; #endif #ifdef GETENV char *env; if(env=getenv(name) != NULL &amp;&amp; overwrite == 0) { return 0; } size_t nameLen = strlen(name); char * envstr = (char *) malloc((nameLen+strlen(val)+1+1)*sizeof(char)); sprintf(envstr, &quot;%s=%s&quot;, name, val); return putenv(envstr); #endif}int __unsetenv(const char *name) { #ifndef GETENV if(environ == NULL) return 0; size_t nameLen = strlen(name); char **env=environ, **move = environ; for(; *env; env++) { if(strncmp(name, *env, nameLen) != 0) { *move = *env; move++; } } *move = NULL; return 0; #endif #ifdef GETENV char *env; if(env=getenv(name) != NULL) { return putenv(name); //并非标准实现 } #endif}","link":"/home/2023/03/25/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha6/"},{"title":"cha8.用户和组","text":"8.1运行下面代码，为什么输出会相同？ 12345678910#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;pwd.h&gt;int main() { struct passwd * p1 = getpwnam(&quot;redis&quot;); struct passwd * p2 = getpwnam(&quot;sshd&quot;); printf(&quot;getpwnam(\\&quot;redis\\&quot;)-&gt;pw_uid = %u, getpwnam(\\&quot;sshd\\&quot;)-&gt;pw_uid = %u\\n&quot;, p1-&gt;pw_uid, p2-&gt;pw_uid); printf(&quot;getpwnam(\\&quot;redis\\&quot;) = %p, getpwnam(\\&quot;sshd\\&quot;) = %p\\n&quot;, p1, p2); return 0;} getpwnam和getpwuid返回的指针指向由静态分配的的内存，地址都是相同的，所以会导致相同。 8.2用getpwent，setpwent，endpwent实现getpwnam 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;pwd.h&gt;#include &lt;string.h&gt;struct passwd getpwnamRet;struct passwd *__getpwnam(const char *name) { struct passwd *pwd = NULL; while((pwd = getpwent()) != NULL) { if(!strcmp(name, pwd-&gt;pw_name)) { break; } } endpwent(); if(pwd != NULL) { memcpy(&amp;getpwnamRet, pwd, sizeof(struct passwd)); return &amp;getpwnamRet; } return NULL;}void printpwd(struct passwd *pwd) { if(pwd == NULL) { printf(&quot;User not Found!\\n&quot;); return; } printf(&quot;Login name:\\t%s\\n&quot;, pwd-&gt;pw_name); printf(&quot;Login passwd:\\t%s\\n&quot;, pwd-&gt;pw_passwd); printf(&quot;User uid:\\t%u\\n&quot;, pwd-&gt;pw_uid); printf(&quot;User gid:\\t%u\\n&quot;, pwd-&gt;pw_gid); printf(&quot;User info:\\t%s\\n&quot;, pwd-&gt;pw_gecos); printf(&quot;Work dir:\\t%s\\n&quot;, pwd-&gt;pw_dir); printf(&quot;Login shell:\\t%s\\n&quot;, pwd-&gt;pw_shell);}int main(int argc, char *argv[]) { printpwd(__getpwnam(argv[1])); return 0;} 事实上，没有必要为了定义全局变量getpwnamRet，因为getpwent的返回值本身就是静态区的 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;pwd.h&gt;#include &lt;string.h&gt;struct passwd *__getpwnam(const char *name) { struct passwd *pwd = NULL; while((pwd = getpwent()) != NULL) { if(!strcmp(name, pwd-&gt;pw_name)) { break; } } endpwent(); return pwd;}void printpwd(struct passwd *pwd) { if(pwd == NULL) { printf(&quot;User not Found!\\n&quot;); return; } printf(&quot;Login name:\\t%s\\n&quot;, pwd-&gt;pw_name); printf(&quot;Login passwd:\\t%s\\n&quot;, pwd-&gt;pw_passwd); printf(&quot;User uid:\\t%u\\n&quot;, pwd-&gt;pw_uid); printf(&quot;User gid:\\t%u\\n&quot;, pwd-&gt;pw_gid); printf(&quot;User info:\\t%s\\n&quot;, pwd-&gt;pw_gecos); printf(&quot;Work dir:\\t%s\\n&quot;, pwd-&gt;pw_dir); printf(&quot;Login shell:\\t%s\\n&quot;, pwd-&gt;pw_shell);}int main(int argc, char *argv[]) { struct passwd *p1 = __getpwnam(argv[1]), *p2 = __getpwnam(argv[2]); printpwd(p1); printpwd(p2); return 0;}","link":"/home/2023/04/10/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha8/"},{"title":"cha9.进程凭证","text":"9.19-1.在下列每种情况中，假设进程用户ID的初始值分别为real(实际) = 1000、effective(有效）= 0、saved（保存）= 0、file-system（文件系统）= 0。当执行这些调用后，用户ID的状态如何? 12345setuid(2000);setreuid(-1, 2000);seteuid(2000);setfsuid(2000);setresuid(-1,2000,3000); 实验代码12345678910111213141516171819202122232425262728293031323334353637#define _GNU_SOURCE#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/fsuid.h&gt;int main(int argc, char *argv[]) { setresuid(1000, 0, 0); setfsuid(0); int test = atoi(argv[1]); uid_t r, e, s, fs; if(getresuid(&amp;r, &amp;e, &amp;s) == -1) return 1; fs = setfsuid(0); printf(&quot;real = %u, effective = %u, save = %u, fs = %u\\n&quot;, r, e, s, fs); switch (test) { case 1: printf(&quot;setuid(2000) = %d\\n&quot;, setuid(2000)); break; case 2: printf(&quot;setreuid(-1, 2000) = %d\\n&quot;, setreuid(-1, 2000)); break; case 3: printf(&quot;seteuid(2000) = %d\\n&quot;, seteuid(2000)); break; case 4: printf(&quot;setfsuid(2000) = %d\\n&quot;, setfsuid(2000)); break; case 5: printf(&quot;setresuid(-1, 2000, 3000) = %d\\n&quot;, setresuid(-1, 2000, 3000)); break; } if(getresuid(&amp;r, &amp;e, &amp;s) == -1) return 1; fs = setfsuid(0); printf(&quot;real = %u, effective = %u, save = %u, fs = %u\\n&quot;, r, e, s, fs); return 0;} 环境准备 登录root用户，创建用户 123useradd -m tmp -u 1000 -s /bin/bash # 创建tmp，创建home，指定登录shell# passwd tmp# usermod -a -G sudo tmp # sudo权限 编译程序，设置set-user-id标记 12345gcc practice9_1.c -o practice9_1for i in `seq 5`; do ./practice9_1 $i; donechmod +s practice9_1su tmpfor i in `seq 5`; do ./practice9_1 $i; done 恢复环境12userdel tmprm -rf /home/tmp 执行结果 root用户/普通(或root)用户有set-user-id-root标志（只有这些情况的初始状态为上所述） exec real effective save fs 解释 setuid(2000); 2000 2000 2000 2000 setuid会同时修改r,e,s setreuid(-1, 2000); 1000 2000 2000 2000 这里s也跟着变了，是因为满足了s改变的条件 seteuid(2000); 1000 2000 0 2000 fs会随着e改变，上面也是这样 setfsuid(2000); 1000 0 0 2000 只改变fs setresuid(-1,2000,3000); 1000 2000 3000 2000 很正常 9.2拥有如下用户ID的进程享有特权吗?请予解释。real=0 effective=1000 saved=1000 file-system=1000 没有，但是可以seteuid(0)，拥有权限 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#define _GNU_SOURCE#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/fsuid.h&gt;#include &lt;sys/wait.h&gt;#include &lt;errno.h&gt;int checkPermission() { pid_t pid; pid = fork(); int childret = 0; if(pid == 0) { char **argv = malloc(3 * sizeof(char *)); argv[0] = &quot;/usr/bin/ls&quot;; argv[1] = &quot;/root/&quot;; argv[2] = NULL; int ret; if((ret = execv(argv[0], argv)) == -1) { fprintf(stderr, &quot;fail to exec ls, error: %s, ret = %d\\n&quot;, strerror(errno), ret); } return ret; } else { if(wait(&amp;childret) != (pid_t)-1) { childret = WEXITSTATUS(childret); printf(&quot;child process stop, childret = %d\\n&quot;, childret); if(childret == 0) { printf(&quot;permission granted\\n&quot;); } else if(childret == WEXITSTATUS(-1)) { printf(&quot;exec fail\\n&quot;); } else { printf(&quot;no permission\\n&quot;); } } else { fprintf(stderr, &quot;wait, error: %s\\n&quot;, strerror(errno)); } } return 0;}void printres() { uid_t r, e, s, fs; if(getresuid(&amp;r, &amp;e, &amp;s) == -1) exit(-1); fs = setfsuid(0); printf(&quot;real = %u, effective = %u, save = %u, fs = %u\\n&quot;, r, e, s, fs); checkPermission();}int main(int argc, char *argv[]) { printres(); if(setresuid(0, 1000, 1000) == -1) return 1; printres(); if(setfsuid(1000) == -1) return 2; printres(); if(seteuid(0) == -1) return 3; printres(); return 0;} 创建子进程执行ls /root，没有特权会返回2，执行结果为0220 9.3使用setgroups()及库函数从密码文件、组文件（参见8.4节)中获取信息，以实现initgroups()。请注意，欲调用setgroups，进程必须享有特权。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#define _GNU_SOURCE#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;grp.h&gt;#include &lt;limits.h&gt;#include &lt;errno.h&gt;#define BUFFSIZE 0xffff// #define BUFFSIZE 2#define CHECK(x) if(!(x)) {fprintf(stderr, &quot;error: %s\\n&quot;, strerror(errno)); exit(errno); }char *strAllocCat(char *str1, const char *str2, int *len1, int len2) { char *ret = malloc((*len1 + len2 + 1) * sizeof(char)); strncpy(ret, str1, *len1); strncpy(ret + *len1, str2, len2); free(str1); *len1 += len2; return ret;} // 复制且分配内存，最后一位加上0，处理成c语言字符串，释放str1内存，更新字符串长度char *readline(int fileno, int *readsize) { static char buf[BUFFSIZE+1]; static char *off = buf; static int eof = 0; char *line = malloc(sizeof(char)); int lineSize = 0; char *move = off; if(off - buf &gt;= eof) { eof = read(fileno, buf, BUFFSIZE); if(eof == 0) { *readsize = 0; return NULL; } CHECK(eof != -1) buf[eof] = 0; off = buf; move=off; } while(*move &amp;&amp; *move != '\\n') { move++; } line = strAllocCat(line, off, &amp;lineSize, move - off); off = move+1; if(*move == 0) { int extrasize = 0; char *extra = readline(fileno, &amp;extrasize); line = strAllocCat(line, extra, &amp;lineSize, extrasize); } *readsize = lineSize; return line;} // 一次读一行gid_t parse_group(char *line, const char *user, const int usersize) { char *group_name = line; char *gpwd = strchr(line, ':'); *gpwd = 0;gpwd++; char *sgid = strchr(gpwd, ':'); *sgid = 0;sgid++; char *userlist = strchr(sgid, ':'); *userlist = 0;userlist++; // 处理groups里的数据，按照冒号分隔 while(strncmp(userlist, user, usersize) != 0) { userlist = strchr(userlist, ','); if(userlist == NULL) { return -1; } userlist++; } // 读userlist，有没有user if(userlist[usersize] != ',' &amp;&amp; userlist[usersize] != '\\0') return -1; // rootttt 与 root 比较的情况 return atol(sgid);}// 系统调用读行int __initgroups(const char *user, gid_t group) { int file_group = open(&quot;/etc/groups&quot;, O_CREAT | O_RDWR); CHECK(file_group != -1) int size = 0; char *line = NULL; gid_t groups[NGROUPS_MAX+1]; int groupscount = 0; groups[groupscount++] = group; // 参数group存入 int usersize = strlen(user); while((line = readline(file_group, &amp;size)) != NULL) { write(STDOUT_FILENO, &quot;read line: &quot;, strlen(&quot;read line: &quot;)); write(STDOUT_FILENO, line, size); write(STDOUT_FILENO, &quot;\\n&quot;, 1); gid_t isid = parse_group(line, user, usersize); if(isid != (gid_t)-1 &amp;&amp; isid != group) {// 存在且不是参数的gid，则存入 groups[groupscount++] = isid; printf(&quot;gid = %u contails user %s\\n&quot;, isid, user); if(groupscount &gt; NGROUPS_MAX) { return -1; // 总数超过limits } } } return setgroups(groupscount, groups);}// sscanf读行int ___initgroups(const char *user, gid_t group) { FILE *file_groups = fopen(&quot;/etc/groups&quot;, &quot;rw&quot;); char line[BUFFSIZE+1]; int usersize = strlen(user); gid_t groups[NGROUPS_MAX+1]; int groupscount = 0; groups[groupscount++] = group; while(fscanf(file_groups, &quot;%s\\n&quot;, line) != EOF) { printf(&quot;%s\\n&quot;, line); gid_t iuid = parse_group(line, user, usersize); if(iuid != (gid_t)-1 &amp;&amp; iuid != group) { groups[groupscount++] = iuid; printf(&quot;gid = %u contails user %s\\n&quot;, iuid, user); if(groupscount &gt; NGROUPS_MAX) { return -1; // 总数超过limits } } } return setgroups(groupscount, groups);}// 系统调用 getgrent setgrent endgrentint ____initgroups(const char *user, gid_t group) { struct group *grp = NULL; int usersize = strlen(user); gid_t groups[NGROUPS_MAX+1]; int groupscount = 0; groups[groupscount++] = group; while((grp = getgrent()) != NULL) { while(*grp-&gt;gr_mem) { if(strcmp(user, *grp-&gt;gr_mem) == 0 &amp;&amp; grp-&gt;gr_gid != group) { groups[groupscount++] = grp-&gt;gr_gid; printf(&quot;gid = %u contails user %s\\n&quot;, grp-&gt;gr_gid, user); if(groupscount &gt; NGROUPS_MAX) { return -1; // 总数超过limits } break; } grp-&gt;gr_mem++; } } endgrent(); return setgroups(groupscount, groups);}int main() { CHECK(____initgroups(getenv(&quot;USER&quot;), getgid()) != -1); gid_t groups[NGROUPS_MAX+1]; int size = getgroups(NGROUPS_MAX, groups); for(int i = 0; i &lt; size; i++) { struct group *g = getgrgid(groups[i]); printf(&quot;getgroups(%u): %s:%s:%u&quot;, groups[i], g-&gt;gr_name, g-&gt;gr_passwd, g-&gt;gr_gid); // 读取的是 groups，这里与前面不一样正常，gid一样就好 if(*g-&gt;gr_mem) { printf(&quot;:%s&quot;, *g-&gt;gr_mem); g-&gt;gr_mem++; } while(*g-&gt;gr_mem) { printf(&quot;,%s&quot;, *g-&gt;gr_mem); g-&gt;gr_mem++; } printf(&quot;\\n&quot;); }} 9.4假设某进程的所有用户标识均为X，执行了用户D为Y的set-user-ID程序，且Y为非0值,对进程凭证的设置如下: 123456789101112131415161718192021#define _GNU_SOURCE#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main() { uid_t r,e,s; getresuid(&amp;r, &amp;e, &amp;s); printf(&quot;r = %u, e = %u, s = %u\\n&quot;, r, e, s); seteuid(r); getresuid(&amp;r, &amp;e, &amp;s); printf(&quot;r = %u, e = %u, s = %u\\n&quot;, r, e, s); seteuid(s); getresuid(&amp;r, &amp;e, &amp;s); printf(&quot;r = %u, e = %u, s = %u\\n&quot;, r, e, s); setuid(r); getresuid(&amp;r, &amp;e, &amp;s); printf(&quot;r = %u, e = %u, s = %u\\n&quot;, r, e, s); return setuid(0); // 希望最后一个失败，返回255(-1)} 环境准备12345gcc practice9_4.c -o practice9_4sudo chown root practice9_4chmod u+s practice9_4su tmp./practice9_4 9.5root最后一句成功，非root最后一句不成功","link":"/home/2023/04/13/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha9/"},{"title":"6.824-lab1-Mapreduce","text":"Intro实验目的 实现一个MapReduce调度器(Coordinator) 准备工作 下载源码 1git clone git://g.csail.mit.edu/6.824-golabs-2021 6.824 串行运行 word-count123456cd ./6.824cd src/maingo build -race -buildmode=plugin ../mrapps/wc.gorm mr-out*go run -race mrsequential.go wc.so pg*.txtmore mr-out-0 我的任务修改mr/coordinator.go, mr/worker.go, mr/rpc.go，实现coordinator和worker 运行方式 编译并运行coordinator 123go build -race -buildmode=plugin ../mrapps/wc.go rm mr-out*go run -race mrcoordinator.go pg-*.txt 多开几个窗口跑worker 1go run -race mrworker.go wc.so 测试 1bash test-mr.sh 测试early exit1234567891011121314151617181920212223242526rm -f mr-*echo '***' Starting early exit test.timeout -k 2s 180s ../mrcoordinator ../pg*txt &amp;## give the coordinator time to create the sockets.sleep 1## start multiple workers.timeout -k 2s 180s ../mrworker ../../mrapps/early_exit.so &amp;timeout -k 2s 180s ../mrworker ../../mrapps/early_exit.so &amp;timeout -k 2s 180s ../mrworker ../../mrapps/early_exit.so &amp;## wait for any of the coord or workers to exit## `jobs` ensures that any completed old processes from other tests## are not waited uponjobs &amp;&gt; /dev/nullwait -n## 关键是这一行## a process has exited. this means that the output should be finalized## otherwise, either a worker or the coordinator exited earlysort mr-out* | grep . &gt; mr-wc-all-initial## wait for remaining workers and coordinator to exit.wait 这一行的作用是当上面任何一个线程中，第一个线程结束，则停止wait继续下面的脚本 也就是说，大家要一起退出，不能因为执行完任务了，也没有新任务了，就让worker结束12wait -n## 关键是这一行 一种可行的方法是当所有reduce任务结束后，直接退出，socket连接关闭，后面的worker心跳直接连接关闭的socket导致panic退出 但这样太不优雅 每个worker请求task时发送自己已经完成的reduce数如果coordinator收到了所有的reduce complete消息，维护一个变量reduce，此时每收到一个RequestTask消息reduce+=该客户端的reduce数，并发送finish消息，worker收到后立刻finishCoordinator的Done实现为，该reduce大于等于NReduce时，结束运行 job count test 检查某个job运行的次数是否正确 这个检测最初没有通过，就去看了测试脚本和源码 1234567891011121314151617181920212223echo '***' Starting job count test.rm -f mr-*timeout -k 2s 180s ../mrcoordinator ../pg*txt &amp;sleep 1timeout -k 2s 180s ../mrworker ../../mrapps/jobcount.so &amp;timeout -k 2s 180s ../mrworker ../../mrapps/jobcount.sotimeout -k 2s 180s ../mrworker ../../mrapps/jobcount.so &amp;timeout -k 2s 180s ../mrworker ../../mrapps/jobcount.soNT=`cat mr-out* | awk '{print $2}'`if [ &quot;$NT&quot; -ne &quot;8&quot; ]then echo '---' map jobs ran incorrect number of times &quot;($NT != 8)&quot; echo '---' job count test: FAIL failed_any=1else echo '---' job count test: PASSfiwait 简单分析可知，加载jobcount中的特殊map，reduce函数，使输出文件输出的是map的个数通过cat输出mr-out的所有文件，在使用awk输出mr-out的第二个参数(awk 'print $2') mrapps/crash.go12345678910111213141516171819202122232425262728var count intfunc Map(filename string, contents string) []mr.KeyValue { me := os.Getpid() f := fmt.Sprintf(&quot;mr-worker-jobcount-%d-%d&quot;, me, count) count++ err := ioutil.WriteFile(f, []byte(&quot;x&quot;), 0666) if err != nil { panic(err) } time.Sleep(time.Duration(2000+rand.Intn(3000)) * time.Millisecond) return []mr.KeyValue{mr.KeyValue{&quot;a&quot;, &quot;x&quot;}}}func Reduce(key string, values []string) string { files, err := ioutil.ReadDir(&quot;.&quot;) if err != nil { panic(err) } invocations := 0 for _, f := range files { // println(&quot;test, f =&quot;, f.Name(), strings.HasPrefix(f.Name(), &quot;mr-worker-jobcount&quot;)) if strings.HasPrefix(f.Name(), &quot;mr-worker-jobcount&quot;) { invocations++ } } return strconv.Itoa(invocations)} 分析这里的代码可知，每调用依次map，全局变量count就会++，并创建该worker的第count个文件在reduce中数当前目录下前缀为mr-worker-jobcount的文件个数就是map的个数 调试了自己的代码，map只调用了8次，reduce只调用了一次 注意到jobcount中使用了go已经弃用的ioutils包，改为os，问题解决 crash test12## mimic rpc.go's coordinatorSock()SOCKNAME=/var/tmp/824-mr-`id -u` 测试脚本要模仿Coordinator的Sock","link":"/home/2022/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.824/lab1/"},{"title":"MIT-6.824-notebook","text":"地址","link":"/home/2022/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.824/mit6.824notes/"}],"tags":[{"name":"Java基础","slug":"Java基础","link":"/home/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"Kotlin-Android 实习","slug":"Kotlin-Android-实习","link":"/home/tags/Kotlin-Android-%E5%AE%9E%E4%B9%A0/"},{"name":"projects","slug":"projects","link":"/home/tags/projects/"},{"name":"Kotlin-Android","slug":"Kotlin-Android","link":"/home/tags/Kotlin-Android/"},{"name":"LeetCode","slug":"LeetCode","link":"/home/tags/LeetCode/"},{"name":"LeetCode周赛","slug":"LeetCode周赛","link":"/home/tags/LeetCode%E5%91%A8%E8%B5%9B/"},{"name":"算法","slug":"算法","link":"/home/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode 101","slug":"LeetCode-101","link":"/home/tags/LeetCode-101/"},{"name":"动态规划","slug":"动态规划","link":"/home/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数据库","slug":"数据库","link":"/home/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"多线程","slug":"多线程","link":"/home/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"PAT-(Advanced-Level)-Practice","slug":"PAT-Advanced-Level-Practice","link":"/home/tags/PAT-Advanced-Level-Practice/"},{"name":"PAT-(Basic-Level)-Practice","slug":"PAT-Basic-Level-Practice","link":"/home/tags/PAT-Basic-Level-Practice/"},{"name":"排序","slug":"排序","link":"/home/tags/%E6%8E%92%E5%BA%8F/"},{"name":"gallery","slug":"gallery","link":"/home/tags/gallery/"},{"name":"hexo","slug":"hexo","link":"/home/tags/hexo/"},{"name":"C&#x2F;C++","slug":"C-C","link":"/home/tags/C-C/"},{"name":"git","slug":"git","link":"/home/tags/git/"},{"name":"linux","slug":"linux","link":"/home/tags/linux/"},{"name":"shell","slug":"shell","link":"/home/tags/shell/"},{"name":"misc","slug":"misc","link":"/home/tags/misc/"},{"name":"geth","slug":"geth","link":"/home/tags/geth/"},{"name":"blockchain","slug":"blockchain","link":"/home/tags/blockchain/"},{"name":"牛客","slug":"牛客","link":"/home/tags/%E7%89%9B%E5%AE%A2/"},{"name":"刷题","slug":"刷题","link":"/home/tags/%E5%88%B7%E9%A2%98/"},{"name":"OS","slug":"OS","link":"/home/tags/OS/"},{"name":"OI KIWI","slug":"OI-KIWI","link":"/home/tags/OI-KIWI/"},{"name":"Android FrameWork","slug":"Android-FrameWork","link":"/home/tags/Android-FrameWork/"},{"name":"Android面试查漏补缺","slug":"Android面试查漏补缺","link":"/home/tags/Android%E9%9D%A2%E8%AF%95%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"Android 高级开发瓶颈突破系列课","slug":"Android-高级开发瓶颈突破系列课","link":"/home/tags/Android-%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E7%93%B6%E9%A2%88%E7%AA%81%E7%A0%B4%E7%B3%BB%E5%88%97%E8%AF%BE/"},{"name":"Flutter","slug":"Flutter","link":"/home/tags/Flutter/"},{"name":"Android-官方源码","slug":"Android-官方源码","link":"/home/tags/Android-%E5%AE%98%E6%96%B9%E6%BA%90%E7%A0%81/"},{"name":"Android","slug":"Android","link":"/home/tags/Android/"},{"name":"gradle","slug":"gradle","link":"/home/tags/gradle/"},{"name":"fedfab","slug":"fedfab","link":"/home/tags/fedfab/"},{"name":"Android-官方文档","slug":"Android-官方文档","link":"/home/tags/Android-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"},{"name":"Linux&#x2F;UNIX系统编程手册","slug":"Linux-UNIX系统编程手册","link":"/home/tags/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/"},{"name":"6.824","slug":"6-824","link":"/home/tags/6-824/"}],"categories":[{"name":"Java基础","slug":"Java基础","link":"/home/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"Kotlin-Android","slug":"Kotlin-Android","link":"/home/categories/Kotlin-Android/"},{"name":"LeetCode","slug":"LeetCode","link":"/home/categories/LeetCode/"},{"name":"LeetCode周赛","slug":"LeetCode/LeetCode周赛","link":"/home/categories/LeetCode/LeetCode%E5%91%A8%E8%B5%9B/"},{"name":"算法","slug":"LeetCode/算法","link":"/home/categories/LeetCode/%E7%AE%97%E6%B3%95/"},{"name":"数据库","slug":"LeetCode/数据库","link":"/home/categories/LeetCode/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"多线程","slug":"LeetCode/多线程","link":"/home/categories/LeetCode/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"PAT-(Advanced-Level)-Practice","slug":"PAT-Advanced-Level-Practice","link":"/home/categories/PAT-Advanced-Level-Practice/"},{"name":"PAT-(Basic-Level)-Practice","slug":"PAT-Basic-Level-Practice","link":"/home/categories/PAT-Basic-Level-Practice/"},{"name":"gallery","slug":"gallery","link":"/home/categories/gallery/"},{"name":"misc","slug":"misc","link":"/home/categories/misc/"},{"name":"git","slug":"git","link":"/home/categories/git/"},{"name":"linux","slug":"linux","link":"/home/categories/linux/"},{"name":"牛客","slug":"牛客","link":"/home/categories/%E7%89%9B%E5%AE%A2/"},{"name":"OS","slug":"OS","link":"/home/categories/OS/"},{"name":"OI KIWI","slug":"OI-KIWI","link":"/home/categories/OI-KIWI/"},{"name":"刷题","slug":"牛客/刷题","link":"/home/categories/%E7%89%9B%E5%AE%A2/%E5%88%B7%E9%A2%98/"},{"name":"Android","slug":"Android","link":"/home/categories/Android/"},{"name":"算法","slug":"OI-KIWI/算法","link":"/home/categories/OI-KIWI/%E7%AE%97%E6%B3%95/"},{"name":"手撸Android源码","slug":"Android/手撸Android源码","link":"/home/categories/Android/%E6%89%8B%E6%92%B8Android%E6%BA%90%E7%A0%81/"},{"name":"gradle","slug":"Android/gradle","link":"/home/categories/Android/gradle/"},{"name":"fedfab","slug":"fedfab","link":"/home/categories/fedfab/"}],"pages":[{"title":"about","text":".Label, .label { border: max(1px, 0.0625rem) solid #30363d; border-radius: 2em; display: inline-block; font-size: 0.75rem; font-weight: 500; line-height: 18px; padding: 0 7px; white-space: nowrap; } .Label--secondary { border-color: #30363d; color: #7d8590; } 基本信息 项目 值 姓名 刘景天 昵称 刘喵喵 出生年月 2000/02 邮箱 jingtian.liu@foxmail.com qq 点击这里 教育经历 起始时间 结束时间 学校 专业 2018.09 2022.06 东北大学(秦皇岛) 计算机科学与技术 2022.09 2025.06(预计) 北京邮电大学 计算机技术(区块链方向) 项目信息fedml: deployment and modification to combine with Hyperledger fabric repo fabric: deployment and combination with fedml repo Yaml-Requests: read your yaml config file to generate python function repo Algorithm: notes for leetcode and other oj repo AFLGO挖掘项目【涉密】 对AFLGO修改，添加代码访问次数统计功能 keywords: llvm Privaterepo 对某些软件进行fuzz keywords: socket编程, pthread, asan 对AFLGO修改，添加目标块命中次数统计 keywords: 系统调用, I/O, llvm IR插装, 共享内存 Privaterepo 实习经历字节跳动 今日头条 部门: 今日头条-架构 负责基础组件的升级包括官方fragment,自研sdk leetcode题解 [hard] 1255. 得分最高的单词集合 状态压缩+剪枝 [Medium] 1073. 负二进制数相加 其他信息欢迎相互学习&amp;交流! 七聖召喚の鍾離先生のカードがかっこよすぎる件について#原神 #鍾離 #Zhongli pic.twitter.com/AOwV6ozK5e&mdash; celsior500 (@celsior500) May 19, 2023 🎁🎄Merry Christmas🐺 메리 크리스마스 ⛓️#Wriothesley 。゜・❄️・。・。 ・ 。。゜・。 ❅゜ ・。゜・ ❄️゜ ・。❄️゜ ゜ ・。゜ ・・❄️ ゜・ 。 ゜❅゜ ゜゜。 。 ゜・。 。゜ ・ 。 ❄️゜・ 。 ❅゜ ゜。・゜ ❄️。 ❅・。・。 ゜・ 。゜ ・ 。。゜。 ゜・ 。゜・ ❄️・ 。 ゜❅゜ ゜゜。 。 pic.twitter.com/5HSjrdZRBB&mdash; ✨NP✨ (@1231_0720) December 22, 2023 健身 动作 推荐哑铃大小 推荐重量（单只） 箭弓步 大 17.5kg 单臂划船 大 17.5kg 坐姿推举 大 17.5kg 哑铃深蹲 大 17.5kg 侧平举 小 7kg 二头弯举 小 7kg 飞鸟+俯卧撑 小 7kg 碎颅者 小 7kg 负重抬腿卷腹 小 7kg 2024年2月26日 （第一周） 动作 当前配重 是否能承受 箭弓步 2.5kg 能 单臂划船 2.5kg 能 坐姿推举 2.5kg 能 哑铃深蹲 2.5kg 能 侧平举 2.5kg 能 二头弯举 2.5kg 能 飞鸟+俯卧撑 2.5kg 能 碎颅者 2.5kg 能 负重抬腿卷腹 2.5kg 能 2024年3月4日 动作 当前配重 是否能承受 箭弓步 4kg 能 单臂划船 4kg 能 坐姿推举 4kg 能 哑铃深蹲 4kg 能 侧平举 4kg 极限 二头弯举 4kg 能 飞鸟+俯卧撑 4kg 能 碎颅者 4kg 刚好 负重抬腿卷腹 4kg 能","link":"/home/about/index.html"},{"title":"categories","text":"","link":"/home/categories/index.html"},{"title":"","text":"function copyToClipboard(text, callBack) { navigator.clipboard.writeText(text).then( value => { // fulfillment callBack() }, reason => { // rejection alert(\"fail: \" + reason) } ) } $(document).ready(function() { $(\".copy\").click(function() { copyCode(this) }) var buttons = document.getElementsByClassName(\"button\") for (let i = 0; i < buttons.length; i++) { if (buttons[i].getAttribute(\"title\") == \"RSS\") { var url = document.baseURI + \"atom.xml\" buttons[i].href = \"javascript:;\" buttons[i].target = \"_self\" buttons[i].setAttribute('onclick', \"copyToClipboard(\\\"\" + url + \"\\\", function() { alert(\\\"Copied to clipboard!\\\") })\") break } } }) function copyCode(element) { if (element instanceof Element) { var elemt = element while(elemt.tagName != \"FIGURE\") { elemt = elemt.parentElement } elemt = elemt.getElementsByClassName(\"code\")[0] var text =elemt.innerText copyToClipboard(text, function() { var node = $(element.childNodes[0]) node.attr('class', \"fa fa-check\") setTimeout(function () { node.attr('class', \"fas fa-copy\") } ,1000) }) } } function fadeOutAndIn(node, onShow, onHide) { node.fadeOut(200, function() { onHide() node.fadeIn(200, function () { onShow() }) }) }","link":"/home/js/clickClipBoard.js"},{"title":"","text":"import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs' function initMermaid() { mermaid.initialize( { startOnLoad: true, theme: \"neutral\", fontSize: '16px', look: \"handDrawn\", sequence: {showSequenceNumbers: true}, fontFamily: \"system-ui\", forceLegacyMathML: true } ) } initMermaid()","link":"/home/js/mermaidInitializer.js"},{"title":"","text":"(function fairyDustCursor() { var possibleColors = [\"#D61C59\", \"#E7D84B\", \"#1B8798\"] var width = window.innerWidth; var height = window.innerHeight; var cursor = { x: width / 2, y: width / 2 }; var particles = []; function init() { bindEvents(); loop(); } // Bind events that are needed function bindEvents() { document.addEventListener('mousemove', onMouseMove); document.addEventListener('touchmove', onTouchMove); document.addEventListener('touchstart', onTouchMove); window.addEventListener('resize', onWindowResize); } function onWindowResize(e) { width = window.innerWidth; height = window.innerHeight; } function onTouchMove(e) { if (e.touches.length > 0) { for (var i = 0; i < e.touches.length; i++) { addParticle(e.touches[i].clientX, e.touches[i].clientY, possibleColors[Math.floor(Math.random() * possibleColors.length)]); } } } function onMouseMove(e) { cursor.x = e.clientX; cursor.y = e.clientY; addParticle(cursor.x, cursor.y, possibleColors[Math.floor(Math.random() * possibleColors.length)]); } function addParticle(x, y, color) { var particle = new Particle(); particle.init(x, y, color); particles.push(particle); } function updateParticles() { for (var i = 0; i < particles.length; i++) { particles[i].update(); } for (var i = particles.length - 1; i >= 0; i--) { if (particles[i].lifeSpan < 0) { particles[i].die(); particles.splice(i, 1); } } } function loop() { requestAnimationFrame(loop); updateParticles(); } function Particle() { this.character = \"*\"; this.lifeSpan = 120; //ms this.initialStyles = { \"position\": \"fixed\", \"top\": \"0\", //必须加 \"display\": \"block\", \"pointerEvents\": \"none\", \"z-index\": \"10000000\", \"fontSize\": \"20px\", \"will-change\": \"transform\" }; this.init = function (x, y, color) { this.velocity = { x: (Math.random() < 0.5 ? -1 : 1) * (Math.random() / 2), y: 1 }; this.position = { x: x - 10, y: y - 20 }; this.initialStyles.color = color; // console.log(color); this.element = document.createElement('span'); this.element.innerHTML = this.character; applyProperties(this.element, this.initialStyles); this.update(); document.body.appendChild(this.element); }; this.update = function () { this.position.x += this.velocity.x; this.position.y += this.velocity.y; this.lifeSpan--; this.element.style.transform = \"translate3d(\" + this.position.x + \"px,\" + this.position.y + \"px,0) scale(\" + (this.lifeSpan / 120) + \")\"; } this.die = function () { this.element.parentNode.removeChild(this.element); } } function applyProperties(target, properties) { for (var key in properties) { target.style[key] = properties[key]; } } init(); })();","link":"/home/js/fairyDustCursor.js"},{"title":"","text":".text-popup { animation: textPopup 1s; user-select: none; white-space: nowrap; position: absolute; z-index: 99; } @keyframes textPopup { 0%, 100% { opacity: 0; } 5% { opacity: 1; } 100% { transform: translateY(-50px); } }","link":"/home/css/textPopup.css"},{"title":"","text":"var colors = new Array(\"#FF0000\",\"#FF7F00\",\" #FFFF00\",\"#00FF00\",\"#00FFFF\",\"#0000FF\",\"#8B00FF\",\"#FF0000\",\"#FF7F00\",\" #FFFF00\",\"#00FF00\",\"#00FFFF\",\"#0000FF\",\"#8B00FF\"); var fnTextPopup = function (arr, options) { // arr参数是必须的 if (!arr || !arr.length) { return; } // 主逻辑 var index = 0; document.documentElement.addEventListener('click', function (event) { var x = event.pageX, y = event.pageY; var eleText = document.createElement('span'); eleText.className = 'text-popup'; this.appendChild(eleText); if (arr[index]) { eleText.innerHTML = arr[index]; } else { index = 0; eleText.innerHTML = arr[0]; } // 动画结束后删除自己 eleText.addEventListener('animationend', function () { eleText.parentNode.removeChild(eleText); }); // 位置 eleText.style.left = (x - eleText.clientWidth / 2) + 'px'; eleText.style.top = (y - eleText.clientHeight) + 'px'; //设置颜色 eleText.style.color = colors[index%14] // index递增 index++; }); }; fnTextPopup(['富强', '民主', '文明', '和谐', '自由', '平等', '公正', '法治', '爱国', '敬业', '诚信', '友善']);","link":"/home/js/textPopup.js"},{"title":"search","text":"","link":"/home/search/index.html"}]}