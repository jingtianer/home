---
title: 实验-使用动态优先权的进程调度算法模拟
date: 2020-10-22 21:15:36
tags: OS
categories: OS
toc: true
language: zh-CN
---

## 1、实验目的
通过动态优先权算法的模拟加深对进程概念进程调度过程的理解。
## 2、实验内容
1. 用C语言来实现对N个进程采用动态优先权优先算法的进程调度。
2. 每个用来标识进程的进程控制块PCB用结构来描述，包括以下字段：
* 进程标识数 ID。
* 进程优先数 PRIORITY，并规定优先数越大的进程，其优先权越高。
* 进程已占用的CPU时间CPUTIME。
* 进程还需占用的CPU时间ALLTIME。当进程运行完毕时，ALLTIME变为0。•••• 进程的阻塞时间STARTBLOCK，表示当进程再运行STARTBLOCK个时间片后，将进入阻塞状态。
* 进程被阻塞的时间BLOCKTIME，表示已足赛的进程再等待BLOCKTIME个时间片后，将转换成就绪状态。
* 进程状态START。
* 队列指针NEXT，用来将PCB排成队列。
3. 优先数改变的原则：
* 进程在就绪队列中呆一个时间片，优先数加1。
* 进程每运行一个时间片，优先数减3。
4. 假设在调度前，系统中有5个进程，它们的初始状态如下：
```
ID	0	1	2	3	4
PRIORITY	9	38	30	29	0
CPUTIME	0	0	0	0	0
ALLTIME	3	3	6	3	4
STARTBLOCK	2	-1	-1	-1	-1
BLOCKTIME	3	0	0	0	0
STATE	READY	READY	READY	READY	READY
```
5. 为了清楚的观察各进程的调度过程，程序应将每个时间片内的情况显示出来，参照的具体格式如下：
```
RUNNING PROG：i
READY-QUEUE：-〉id1-〉id2
BLOCK-QUEUE：-〉id3-〉id4
= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = == = =
ID                           0		1		2		3		4
PRIORITY                     P0		P1		P2		P3		P4
CUPTIME                      C0		C1		C2		C3		C4
ALLTIME	                     A0		A1		A2		A3		A4
STARTBLOCK                   T0		T1		T2		T3		T4
BLOCKTIME                    B0		B1		B2		B3		B4
STATE				         S0		S1		S2		S3		S4
```
## 实验代码
```c++
#include<queue>
#include<iostream>
#include<iomanip> 
using namespace std;
typedef int ID;
typedef int Priority;
typedef int Time;

enum State {
	sready, sblocked, sruning, sstop
};
struct PCB{
	ID id;
	Priority priority;
	Time cpu_time;
	Time all_time;
	Time start_block;
	Time block_time;
	State state;
	public:
	PCB(
		ID id0,
		Priority priority0,
		Time cpu_time0,
		Time all_time0,
		Time start_block0,
		Time block_time0,
		State state0
	): id(id0), priority(priority0), cpu_time(cpu_time0), 
	all_time(all_time0), start_block(start_block0), 
	block_time(block_time0), state(state0) {
	}
};

struct cmp //��д�º���
{
    bool operator() (PCB* a, PCB* b) 
    {
        return a->priority < b->priority; //�󶥶�
    }
};
typedef priority_queue<PCB*, vector<PCB*>, cmp> mqueue;
const int width = 10;
void show_PCB(PCB* pcb) {
	string state = "";
	switch(pcb->state) {
		case sready: state = "ready"; break;
		case sblocked : state = "blocked";break;
		case sruning : state = "runing";break;
		case sstop: state = "stop";break;
		defalut:state="unknown";break;
	}
	cout 
	<< left << setw(width) << setfill(' ') << pcb->id << "|" 
	<< left << setw(width) << setfill(' ') << pcb->priority << "|" 
	<< left << setw(width) << setfill(' ') << pcb->cpu_time << "|" 
	<< left << setw(width) << setfill(' ') << pcb->all_time << "|" 
	<< left << setw(width) << setfill(' ') << pcb->start_block << "|" 
	<< left << setw(width) << setfill(' ') << pcb->block_time << "|" 
	<< left << setw(width) << setfill(' ') << state << "|" << endl; 
}
void show_queue(queue<PCB*> q){
	cout 
	<< left << setw(7*width+7) << setfill('-') << "" << "\n" 
	<< left << setw(width) << setfill(' ') << "id" << "|" 
	<< left << setw(width) << setfill(' ') << "priority" << "|" 
	<< left << setw(width) << setfill(' ') << "cpuTime" << "|" 
	<< left << setw(width) << setfill(' ') << "allTime" << "|" 
	<< left << setw(width) << setfill(' ') << "startBlock" << "|" 
	<< left << setw(width) << setfill(' ') << "blockTime" << "|" 
	<< left << setw(width) << setfill(' ') << "state" << "|" << endl; 
	while(!q.empty()) {
		PCB* t = q.front();
		q.pop();
		show_PCB(t);
	}
	cout << left << setw(7*width+7) << setfill('-') << "" << "\n";
}
void show_queue(mqueue q){
	cout 
	<< left << setw(7*width+7) << setfill('-') << "" << "\n" 
	<< left << setw(width) << setfill(' ') << "id" << "|" 
	<< left << setw(width) << setfill(' ') << "priority" << "|" 
	<< left << setw(width) << setfill(' ') << "cpuTime" << "|" 
	<< left << setw(width) << setfill(' ') << "allTime" << "|" 
	<< left << setw(width) << setfill(' ') << "startBlock" << "|" 
	<< left << setw(width) << setfill(' ') << "blockTime" << "|" 
	<< left << setw(width) << setfill(' ') << "state" << "|" << endl; 
	while(!q.empty()) {
		PCB* t = q.top();
		q.pop();
		show_PCB(t);
	}
	cout << left << setw(7*width+7) << setfill('-') << "" << "\n";
}
queue<PCB*> finished;
void run_a_time(mqueue& ready,mqueue& blocked,PCB* runing) {
	mqueue t_ready, t_blocked;
	
	runing = ready.top();
	ready.pop();
	runing->priority -= 3;
	runing->cpu_time += 1;
	runing->all_time -= 1;
	runing->start_block -= 1;
	if(runing->start_block == 0) {
		t_blocked.push(runing);
		runing->state = sruning;
	} else {
		if(runing->all_time > 0) {
			t_ready.push(runing);
		} else {
			finished.push(runing);
			runing->state = sstop;
		}
	}
	mqueue t_queue = blocked;
	
	while(!t_queue.empty()) {
		PCB* t = t_queue.top();
		t_queue.pop();
		t->block_time -= 1;
		if(t->block_time == 0) {
			t_ready.push(t);
			t->block_time = 0;
			t->start_block = -1;
			t->state = sready;
		} else {
			t_blocked.push(t);
			t->state = sblocked;
		}
	}
	t_queue = ready;
	while(!t_queue.empty()) {
		PCB* t = t_queue.top();
		t_queue.pop();
		t->priority += 1;
		t->start_block -= 1;
		if(t->start_block == 0) {
			t_blocked.push(t);
			t->state = sblocked;
		} else {
			t_ready.push(t);
			t->state = sready;
		}
	}
	ready = t_ready;
	blocked = t_blocked;
	
}
int main() {
	mqueue ready, blocked;
	PCB* runing = nullptr;
	PCB* pcbs[] = {
		new PCB(0,9,0,3,2,3, sready),
		new PCB(1,38,0,3,-1,0, sready),
		new PCB(2,30,0,6,-1,0, sready),
		new PCB(3,29,0,3,-1,0, sready),
		new PCB(4,0,0,4,-1,0, sready)
	};
	int pcb_num = sizeof(pcbs)/sizeof(PCB*);
	for(int i = 0; i < pcb_num; i++) {
		ready.push(pcbs[i]);
	}
	
	show_queue(ready);
	int clock_ = 1;
	while(!ready.empty() || !blocked.empty()) {
		cout << "clock = " << clock_ << endl;
		run_a_time(ready, blocked, runing);
		cout << "ready queue:" << endl; 
		show_queue(ready);
		cout << "blocked queue:" << endl; 
		show_queue(blocked);
		//system("pause");
		clock_++;
	}
	show_queue(finished);
	//delete
	for(int i = 0; i < pcb_num; i++) {
		delete pcbs[i];
	}
}
```

