---
title: PAT-Basic-1045
date: 2019-07-13 21:15:36
tags: PAT-(Basic-Level)-Practice
categories: PAT-(Basic-Level)-Practice
toc: true
language: zh-CN
---

## 题目

> 著名的快速排序算法里有一个经典的划分过程：我们通常采用某种方法取一个元素作为主元，通过交换，把比主元小的元素放到它的左边，比主元大的元素放到它的右边。 给定划分后的 N 个互不相同的正整数的排列，请问有多少个元素可能是划分前选取的主元？

> 例如给定 $N = 5$, 排列是1、3、2、4、5。则：
> 
> -   1 的左边没有元素，右边的元素都比它大，所以它可能是主元；
>     
> -   尽管 3 的左边元素都比它小，但其右边的 2 比它小，所以它不能是主元；
>     
> -   尽管 2 的右边元素都比它大，但其左边的 3 比它大，所以它不能是主元；
>     
> -   类似原因，4 和 5 都可能是主元。
>     

> 因此，有 3 个元素可能是主元。

#### 输入格式：

> 输入在第 1 行中给出一个正整数 N（≤105）； 第 2 行是空格分隔的 N 个不同的正整数，每个数不超过 109。

#### 输出格式：

> 在第 1 行中输出有可能是主元的元素个数；在第 2 行中按递增顺序输出这些元素，其间以 1 个空格分隔，行首尾不得有多余空格。

#### 输入样例：

```
5
1 3 2 4 5
```

#### 输出样例：

```
3
1 4 5
```

## 通过代码
 ```c++
#include <iostream>
#include <algorithm>
using namespace std;
int arr[1000000], brr[1000000], crr[1000000];
int main () {
	int n, m = 0;
	scanf ("%d", &n);
	for (int i = 0; i < n; i++) {
		scanf ("%d", &arr[i]);
		brr[i] = arr[i];
	}
	sort(brr, brr + n);
	int max = -999999;
	for (int i = 0; i < n; i++) {
		if (max < arr[i]) max = arr[i];
		if (arr[i] == brr[i] && max == arr[i]) {
			crr[m++] = arr[i];
		}
	}
	printf ("%d\n", m);
	if (m > 0) printf("%d", crr[0]);
	for (int i = 1; i < m ; i++) {
		printf (" %d", crr[i]);
	}
	printf ("\n");
	return 0;
}
```
## 思路与注意

1.  只要满足一个数的左边没有数或者数都比它小，右边没有元素或者都比它大，它就可能是主元。根据这个思路，写一个O(N^2)的算法肯定会超时
    
2.  根据快速排序的思想，挑选一个数作为主元，把比它小的数放左边，比它大的放右边，这样然后以主元为分界线，两边视为两个数组重新进行以上操作，直到不能再细分。排序完成。我们可以得到`主元在排序前后位置不变`且`左边的数都比它小`，这样，算法就变成了
    
    1.  对数组进行排序，比较那些元素的位置没有变
        
    2.  判断这个数是不是从左往右的最大值
        
3.  这样就O(N)了
    

## 反思与评价

-   [快速排序(25)](https://blog.csdn.net/gq_bob/article/details/49520161)参考了这个教程，希望以后能更多的独立思考，锻炼思考能力
-  加油小天天ヾ(◍°∇°◍)ﾉﾞ，你是最胖的！
