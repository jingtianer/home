---
title: 实习笔记-12
date: 2022-03-22 21:15:36
tags: Kotlin-Android 实习
categories: Kotlin-Android
toc: true
language: zh-CN
---

## PendingIntent认识
- PendIntent其实是Intent的封装
- 不是立刻执行某个行为，而是`满足某些条件或触发某些事件后`才执行指定的行为
- 我们的 Activity 如果设置了 `exported = false`，`其他应用`如果使用 Intent 就访问不到这个 Activity，但是使用 PendingIntent 是可以的。
- 即：PendingIntent将某个动作的触发时机交给其他应用；让那个应用代表自己去执行那个动作（权限都给他）

## 获取PendingIntent
```kotlin
getActivity()
getActivities()
getBroadcast()
getService()
getForegroundService()
```
```
参数:
Context - 上下文对象
requestCode - 请求码
Intent - 请求意图用以指明启动类及数据传递
flags -关键标志位
```
|flags||
|-|-|
|FLAG_CANCEL_CURRENT|先将当前已有的PendingIntent取消，然后重新生成一个PendingIntent对象。|
|FLAG_NO_CREATE|如果当前系统中不存在相同的PendingIntent对象，系统将返回null，否则返回已有对象|
|FLAG_ONE_SHOT|该PendingIntent只作用一次。在该PendingIntent对象通过send()方法触发过后，PendingIntent将自动调用cancel()进行销毁，那么如果你再调用send()方法的话，系统将会返回一个SendIntentException。|
|FLAG_UPDATE_CURRENT|更新之前PendingIntent中的Intent对象数据，例如更新Intent中的Extras|
|FLAG_IMMUTABLE|创建的PendingIntent是不可变的，使用send方法发送的附加Intent会被忽略|

### 原理
- A应用希望让B应用帮忙触发一个行为，这是跨应用的通信
- 需要 Android 系统作为中间人，这里的中间人就是 ActivityManager。 
- A应用创建建 PendingIntent，在创建 PendingIntent 的过程中，向 ActivityManager 注册了这个 PendingIntent，所以，即使A应用死了，当它再次苏醒时，只要提供相同的参数，还是可以获取到之前那个 PendingIntent 的。
- 当 A 将 PendingIntent 调用系统 API 比如 AlarmManager.set()，实际是将权限给了B应用，这时候， B应用可以根据参数信息，来从 ActivityManager 获取到 A 设置的 PendingIntent

## Canvas
- 相当于一个透明图层
- 每次调用canvas.drawXXXX系列函数来绘图，都会产生一个全新的Canvas画布。
- 如果在DrawXXX前，调用平移、旋转等函数来对Canvas进行了操作，那么这个操作是不可逆的！每次产生的画布最新位置都是这些操作后的位置。
- 在Canvas与屏幕合成时，超出屏幕范围的图像是不会显示出来的。
### rotate函数

![rotate前](./12.jpg)
```java
public class MyTextView extends TextView { 
    public MyTextView(Context context, AttributeSet attrs) { 
        super(context, attrs); 
    } 
    @Override 
    protected void onDraw(Canvas canvas) { 
        canvas.rotate(-90); 
        super.onDraw(canvas); 
    } 
}
```

![rotate后](./13.jpg)

### translate函数
```java
void translate(float dx, float dy)
// float dx：水平方向平移的距离，正数指向正方向（向右）平移的量，负数为向负方向（向左）平移的量
// float dy:  垂直方向平移的距离，正数指向正方向 (向下) 平移量，负数为向负方向 (向上) 平移量
```

### 扭曲（skew）
其实我觉得译成斜切更合适，在PS中的这个功能就差不多叫斜切。但这里还是直译吧，大家都是这个名字。看下它的构造函数：

```java
void skew (float sx, float sy)
//float sx:将画布在x方向上倾斜相应的角度，sx倾斜角度的tan值
//float sy:将画布在y轴方向上倾斜相应的角度，sy为倾斜角度的tan值
```

### save restore
每次save，将当前画布状态保存到一个状态栈中，restore从栈顶取出一个状态恢复到画布上

## SDCard
```java
Environment.MEDIA_UNMOUNTED // 用户手工到手机设置中卸载sd卡之后的状态 
Environment.MEDIA_REMOVED // 用户手动卸载，然后将sd卡从手机取出之后的状态 
Environment.MEDIA_BAD_REMOVAL // 用户未到手机设置中手动卸载sd卡，直接拨出之后的状态 
Environment.MEDIA_SHARED // 手机直接连接到电脑作为u盘使用之后的状态 
Environment.MEDIA_CHECKINGS // 手机正在扫描sd卡过程中的状态 
Environment.MEDIA_MOUNTED //挂载到挂载点上且有读写权限
```