---
title: 实习笔记-25
date: 2022-03-22 21:15:36
tags: Kotlin-Android 实习
categories: Kotlin-Android
toc: true
language: zh-CN
---

## 创建型
### [单例](https://www.runoob.com/design-pattern/singleton-pattern.html)
#### 优点
- 节省资源
  - 内存
  - 重对象中包含的io，文件指针
- 调用方便

#### 缺点
- 适用于昂贵对象，对于轻量对象，为了维护单例造成的同步等开销比创建一个对象更高。得不偿失
- 不方便mock，（可以把单例对象作为函数参数则可以mock），相较于静态方法更方便（静态方法需要代理的方式mock）
- 测试时常常并行测试，使用单例会降低效率
函数式编程，拷贝
云控，打点 Alex
静态工具方法，少用，不要有状态，确保永远不会变

### 建造者
- 构建一个参数非常复杂的对象，但是常用的组合很有限，写一个builder提供常用组合，builder内部自己填充其他的参数
- 与连续调用没有关系，可以链式调用的叫fluentApi
#### 优点
- 完整性 创建对象的合法性，在build时检查/默认值
- 灵活性
### 工厂
#### 静态工厂
线程池，collections
封装构造器，简化构造
#### 实例工厂
解耦时，不希望类持有不需要的类，使用factory持有该对象
#### 抽象工厂
返回抽象/接口，方便修改，选择不同实现



## 结构型
添加新需求，加判断，时尝试：
### 代理模式（构造器传入委托人）
- wrapper
- 快捷键，double shift， 搜 delegate method
## 静态代理（正常）
## 动态代理（反射）

### 装饰器（相互组合代理）
- wrapper
- 内部看为代理-委托
- 给执行包一层皮，每层皮实现一种功能（如对cloud加缓存、sdk模式），包的顺序不同，调用顺序也不同
### 组合模式（对象持有）
- wrapper
- eg 对方法计数，如果是继承（推荐默认final， kotlin默认final），子类的行为改变了父类的行为（父类调用自己计过数的方法），组合模式避免了这种情况
- 局限性，内部的特性无法访问
- 组合由于继承