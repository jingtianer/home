---
title: 实习笔记-1
date: 2022-03-22 21:15:36
tags: Kotlin-Android 实习
categories: Kotlin-Android
toc: true
language: zh-CN
---

## px dp sp 的区别
|||
|-|-|
|px|其实就是像素单位，比如我们通常说的手机分辨列表800*400都是px的单位|
|sp|同dp相似，还会根据用户的字体大小偏好来缩放|
|dp |虚拟像素，在不同的像素密度的设备上会自动适配|

## 隐藏状态栏任务栏
![](1.png)

### 在api30之前
``` java
getWindow().getDecorView().setSystemUIVisibility(View.SYSTEM_UI_FLAG_FULLSCREEN)
```
### api30后
```
WindowCompat.setDecorFitsSystemWindows(window, false)
WindowInsetsControllerCompat(window, window.decorView).let {
    it.hide(WindowInsetsCompat.Type.systemBars())
    //it.systemBarsBehavior = WindowInsetsControllerCompat.BEHAVIOR_SHOW_BARS_BY_TOUCH
}
```
- androidx.core 依赖的版本至少1.5

## 设置导航栏，状态栏颜色
```
window.statusBarColor = Color.TRANSPARENT
window.navigationBarColor = Color.TRANSPARENT
```

## fragment 生命周期
![](2.webp)
### onCreateView 与onActivityCreated 的区别
#### onCreateView
每次创建、绘制该Fragment的View组件时回调该方法，Fragment将会显示该方法返回的View组件。
#### onActivityCreated
当Fragment所在的Activity被启动完成后回调该方法。
- 保存view的状态的时候需要用onActivityCreated
- 访问父activity的view层的时候需要在onActivityCreated 方法里面做
- 如果view是静态的，就可以在onCreateView之后取得view进行操作
- 如果view是动态的，则需要在onActivityCreated后find
#### 1 静态布局
##### 1.1 View和ViewGroup
静态布局都是由View和ViewGroup继承而来。


##### 静态布局树状图
- View是所有的UI组件都要继承并实现的，一个View要在屏幕上占据一块矩形区域。
- ViewGroup是一个容器，可以将View添加进ViewGroup中，ViewGroup可以对其内的View进行布局，ViewGroup可以添加其他的ViewGroup。
- 所有的控件都是从View继承而来，ViewGroup是View的一个重要子类，绝大多数布局都是从ViewGroup继承而来。

##### 1.3 六大布局
##### 1.3.1 LinearLayout
line是线的意思，linear是线性的意思，这个布局就是线性布局。只能横着排，或者只能竖着排。
关键属性是orientation，这个是方向的意思。
这个有两个选项 vertical，horizontal。是不是觉得太长记不住呢，有一个简便的记忆方法，利用IDE的自动提示功能，只要记住第一个字母就可以了对吧，可以把h记作横（heng）这样就不会错了。

##### 1.3.2 RelativeLayout
relative是相对的意思，这个布局是相对布局。
相对布局就是依据父元素和某元素进行相对布局。
有三种类型的属性：

属性值是true或false
android:layout_centerHrizontal 水平居中
android:layout_centerVertical 垂直居中
android:layout_centerInparent 相对于父元素完全居中。
android:layout_alignParentBottom 位于父元素的下边缘
android:layout_alignParentTop 位于父元素的上边缘
android:layout_alignParentLeft 位于父元素的左边缘
android:layout_alignParentRight 位于父元素的右边缘
属性值是"@id/*“
android:layout_below 在某元素的下方
android:layout_above 在某元素的上方
andorid:layout_toRightOf 在某元素的右方
android:layout_toLeftOf 在某元素的左方
android:layout_alignBottom 和某元素下方对齐
android:layout_alignTop 和某元素上方对齐
android:layout_alignRight 和某元素右方对齐
android:layout_alignLeft 和某元素左方对齐
属性值是数值
android:layout_marginLeft 离某元素左边缘的距离
android:layout_marginRight 离某元素右边缘的距离
android:layout_marginTop 离某元素上边缘的距离
android:layout_marginBottom 离某元素下边缘的距离
上面这两种是最常用的两种布局，基本能完成一些基本的布局了。

##### 1.3.3 自定义布局
- 自定义是对ViewGroup进行继承，一般要实现以下方法：

- 重写onMeasure()方法对子View进行测量。在onMeasure中计算childView的测量值以及模式，以及设置自己的宽和高。
- 重写onLayout()方法确定子View的位置，对所有childView进行定位（设置childView的绘制区域）。
自定义ViewGroup是很有必要的，因为当官方给出的空间无法满足自己的需求时，就需要自己取定义一种布局了。

##### 1.3.4 FrameLayout
框架布局，第一个控件放在最底层的左上角，然后后面的控件在左上角一层一层的覆盖上去。类似于Ps图层的样子。



##### 1.3.5 TableLayout
表格布局，顾名思义，就是一个表格。
它遵循着以下结构：
```
<TableLayout>
    <TableRow>
    <!-在这里填充第一行的元素->
    </TableRow>
    <TableRow>
    <!-在这里填充第二行的元素->
    </TableRow>    
</TableLayout>
```
还有几个重要属性：

- 写在TableLayout中的属性
    - android:stretchColumns 设置第几列为伸展(0表示第一列)
    - ndroid:shrinkColumns 设置第几列为收缩
    - android:collapseColumns 设置第几列为隐藏
- 写在TableRow里的控件里的属性
    - android:layout_column 设置控件在第几列
    - android:layout_span 设置控件能跨多少列


#####  1.3.6 AbsoluteLayout
绝对布局，已经被淘汰了的布局。

所有控件都要设置x,y坐标，使用绝对的布局。

android:layout_x //控件x坐标
android:layout_y //控件y坐标
#####  1.4 控件

![](3.webp)

##### 1.4.1 android自带控件

##### 1.4.2 自定义控件
自定义控件有三种方法：

1. 对现有控件进行扩展，继承控件后重写onDraw()方法，在回调父类方法前实现自己的逻辑。
1.  通过组合来实现新的控件
1.  重写View来实现全新的控件
```
@Override
protected void onDraw(Canvas canvas){
    //在回调之前实现自己逻辑。
    super.onDraw(canvas);
    //在回调之后实现自己逻辑。
}
```

#### 2 动态布局
##### 2.1 用类修改xml
可以使用findViewById找到想要进行接管的控件，然后再修改其中的属性，然后达到动态的目的。

##### 2.2 动态生成
首先创建一个布局管理器，然后使用setContentView()将布局管理器绘制出来,之后再用addView()方法加入控件元素

## Drawable类及XMLDrawable的使用
### 一.性质
可直接使用.png、.jpg、.gif、9.png等图片作为资源,也可使用多种XML文件作为资源。（就是这些资源都能生成Drawable对象）。并对XML文件作出相关处理

### 二.XMLDrawable
#### 1.StateListDrawable(selector)
作用：StateListDrawable对象所显示的Drawable对象会随着目标组件状态的改变而改变

组成：
```xml
根元素<selector/>，子元素<item/>
子元素<item/>的属性：android:color或android:drawable
android:state_xxx:状态
```


#### 2.LayerDrawable(ps图层)
作用：可包含一个Drawable数组，系统会按照Drawable对象的数组顺序绘制，索引越大越被绘制在上层
```xml
根元素：<layer-list>  子元素：<item/>

子元素的属性：android:drawable 作为LayerDrawable的Drawable对象
android:id 为Drawable对象指定标识符
android:buttom|top...等 指定Drawable的绘制位置
```

3.ShapeDrawable
作用：设置一个基本的几何图形（矩形、圆形、线条灯）
```xml
根元素：<shape/>
根元素的属性：android:shape=["rectangle"|"oval"|"line"|"ring"]

子元素：
<corners/>：设置整体或者四个边角的弧度
<gradient/>:渐变（可选择渐变的角度但必须是45的倍数，默认为0，渐变的中心点，渐变的类型，渐变的半径和开始和终止的颜色）
<padding/>:内边距 （可以控制四周的边距）
<size/>:形状的大小 （设置形状的宽高）
<solid/>:单种颜色填充 
<stroke/>:绘制边框
```
```xml
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:dither=["true" | "false"]       //将在位图的像素配置与屏幕不同时（例如：ARGB 8888 位图和 RGB 565 屏幕）启用位图的抖动；值为“false”时则停用抖动。默认值为 true。
    android:shape=["rectangle" | "oval" | "line" | "ring"]//分别为矩形、椭圆、线、环。默认为矩形rectangle 
    android:innerRadius="integer"           // shape为ring时有效，内环半径
    android:innerRadiusRatio="float"        // shape为ring时有效，内环的厚度比，即环的图形宽度与内环半径的比例，按照这个比例计算内环半径，默认为3，可被innerRadius值覆盖
    android:thickness="integer"             // shape为ring时有效，环的厚度
    android:thicknessRatio="float"          // shape为ring时有效，环的厚度比，即环的图形宽度与环的厚度的比例，按照这个比例计算环的厚度，默认为9，可被thickness值覆盖
    android:tint="color"                    // 给shape着色
    android:tintMode=["src_in" | "src_atop" | "src_over" | "add" | "multiply" | "screen"] // 着色类型
    android:useLevel=["true" | "false"]     // 较少用，一般设为false，否则图形不显示。为true时可在LevelListDrawable使用
    android:visible=["true" | "false"] >
    <!-- 圆角 -->
    <corners
        android:radius="integer"            // 圆角半径，设置下面四个属性时，对应的位置属性会被覆盖
        android:topLeftRadius="integer"     // 左上角圆角半径
        android:topRightRadius="integer"    // 右上角圆角半径
        android:bottomLeftRadius="integer"  // 左下角圆角半径
        android:bottomRightRadius="integer" // 右下角圆角半径
        />
    <!-- 渐变 -->
    <gradient
        android:type=["linear" | "radial" | "sweep"]// 渐变类型，线性、放射性、扫描性；默认为线性
        android:angle="integer"             // 渐变角度，渐变类型为linear时有效；默认为0，从左至右渐变，角度逆时针方向计算，角度需要时45的整数倍数
        android:centerColor="integer"       // 渐变中间位置颜色
        android:startColor="color"          // 渐变开始位置颜色
        android:endColor="color"            // 渐变结束位置颜色
        android:centerX="float"             // 设置渐变中心的X坐标，取值区间[0,1]，默认为0.5，即中心位置
        android:centerY="float"             // 设置渐变中心的Y坐标，取值区间[0,1]，默认为0.5，即中心位置
        android:gradientRadius="integer"    // type为放射性渐变radial时有效，渐变的半径
        android:useLevel=["true" | "false"] // 与shape中该属性的一致
        />
    <!-- 内边距 -->
    <padding
        android:left="integer"              // 左边距
        android:top="integer"               // 上边距
        android:right="integer"             // 右边距
        android:bottom="integer"            // 下边距
        />
    <!-- 大小 -->
    <size
        android:width="integer"             // 图形宽度
        android:height="integer"            // 图形高度
        />
    <!-- 填充 -->
    <solid
        android:color="color"               // 图形的填充色
        />
    <!-- 描边 -->
    <stroke
        android:width="integer"             // 描边的宽度
        android:color="color"               // 描边的颜色
        android:dashWidth="integer"         // 虚线宽度
        android:dashGap="integer"           // 虚线间隔
        />
</shape>
```
- 可设置画笔的颜色和粗细并设置每画一条线的长度和间距且必须两者都设置才有效


 4.ClipDrawable
作用：从Drawable上截取一个"图片片段"
```xml
根元素：<clip>  不使用子元素。

根元素属性： 
android:drawable: 选定Drawable对象
android:clipOrientation:指定截取方向
android:gravity:从什么地方开始截取
```
- 总结：选定图片并选择方向与位置截取图片

- 使用：从java中获取ClipDrawable并用setLevel()改变截取大小 //setLevel()只能从0~10000

```xml
<!--res/drawable/test_clip.xml-->
<clip xmlns:android="http://schemas.android.com/apk/res/android"
    android:drawable="@mipmap/start"
    android:clipOrientation="horizontal"
    android:gravity="center">
</clip>
```
```xml
<!--res/layout/activity_main.xml-->
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context="com.chen.android.test.MainActivity">

    <ImageView
        android:id="@+id/imageView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:src="@drawable/test_clip"/>
</LinearLayout>
```
```java
/*实现图片渐渐展开的效果*/
public class MainActivity extends AppCompatActivity {
    int data = 0;
    int what = 0X11;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        ImageView img = (ImageView)findViewById(R.id.imageView);
        //ImageView.getDrawable()获取的是当前控件里的图片，返回的是Drawable类型,还有说明Drawable对象可随意变成子对象并调用子对象的方法
        final ClipDrawable clipDrawable = (ClipDrawable)img.getDrawable();
        //创建Handler等待计时器传送的信息，使图片扩展
        final Handler mHandler = new Handler(){

            @Override
            public void handleMessage(Message msg) {
                super.handleMessage(msg);
                if (msg.what == what){
                    clipDrawable.setLevel(data);//扩大截取的图片面积
                    data += 200;
                }

            }
        };
        //创建计时器
        final Timer timer = new Timer();
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                if (data >= 10000){
                    timer.cancel();
                }
                mHandler.obtainMessage(what).sendToTarget();
            }
        },0,300);
    }
}
```
5.AnimationDrawable
简介：放在res/anim下，支持逐帧动画和补间动画
```xml
根元素：<set>   根元素属性：android:interpolator="参数"
linear_interpolator：匀速变换 
accelerate_interpolar：加速变换
decelerate_interpolator：减速变换

android:shareInterpolator= "true|false" ：是否让资源的interpolator与根元素相同

android:duration="时间"：定义持续时间
子元素(同样可以设置duration)
<alpha>：设置开始和结束的透明度
<scale>：设置缩放的中心、开始的X，Y的尺寸和结束时X,Y的尺寸
<translate>：设置图片的开始位置和结束位置进行位移
<rotate>：设置旋转的中心、开始的角度和结束时候的角度
```

- 注意：利用android:fillAfter="true|false"：设置保留后的状态（哪个状态想保留就用这个，如果都像就放在set中）

- 使用：利用AnimationUtils的静态方法loadAninmation(Context context,int resId)

```xml
<!--在res/anim/test_animtaion中-->
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:interpolator="@android:anim/linear_interpolator"
    android:shareInterpolator="true"
    android:fillAfter="true">

    <alpha android:fromAlpha="50.0"
           android:toAlpha="100.0"
           />
    <scale android:pivotX="50%"
           android:pivotY="50%"
           android:fromXScale="1.0"
           android:fromYScale="1.0"
           android:toXScale="1.5"
           android:toYScale="1.5"
           android:duration="3000"
           />
    <translate android:fromXDelta="30"
               android:toXDelta="300"
               android:fromYDelta="40"
               android:toYDelta="90"
        android:duration="3000"/>

</set>
```
```java
/*实现动画*/
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        ImageView img = (ImageView)findViewById(R.id.imageView);

        /*利用工具类获取对象*/
        Animation animation= AnimationUtils.loadAnimation(this,R.anim.test_animation);
        /*将动画附加在图片上*/
        img.startAnimation(animation);
    }
}
```
<img src="4.png"/>