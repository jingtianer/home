---
title: 实习笔记-8
date: 2022-03-22 21:15:36
tags: Kotlin-Android 实习
categories: Kotlin-Android
toc: true
language: zh-CN
---

## 组件merge

## `类名.()`的写法
```kotlin
inline fun AppCompatActivity.fragmentTransaction(block: FragmentTransaction.() -> Unit): Boolean {
    kotlin.runCatching {
        val t = supportFragmentManager.beginTransaction()
        block.invoke(t)
        t.commitNowAllowingStateLoss()
        return true
    }
    return false
}
```

```kotlin
/* 新的协程job */
fun newWorkerThreadCoroutineJob(block: suspend CoroutineScope.() -> Unit): Job {
    return GlobalScope.launch(context = Dispatchers.IO, block = block)
}
```

## android-job庫
- [參考](https://www.jianshu.com/p/ce045698aca8)
## kotlin基礎
### kotlin 携程
- 顶层主协程?
- 协程是轻量级的线程
-  delay 是一个特殊的 挂起函数 ，它不会造成线程阻塞，但是会 挂起 协程，并且只能在协程中使用。
```kotlin
import kotlinx.coroutines.*

fun main() {
    GlobalScope.launch { // 在后台启动一个新的协程并继续
        delay(1000L) // 非阻塞的等待 1 秒钟（默认时间单位是毫秒）
        println("World!") // 在延迟后打印输出
    }
    println("Hello,") // 协程已在等待时主线程还在继续
    Thread.sleep(2000L) // 阻塞主线程 2 秒钟来保证 JVM 存活
}
```
delay是非阻塞的，sleep是阻塞的
- 抛棄sleep，使用runBlocking與delay
```kotlin
import kotlinx.coroutines.*

fun main() {
    GlobalScope.launch { // 在后台启动一个新的协程并继续
        delay(1000L)
        println("World!")
    }
    println("Hello,") // 主线程中的代码会立即执行
    runBlocking {     // 但是这个表达式阻塞了主线程
        delay(2000L)  // ……我们延迟 2 秒来保证 JVM 的存活
    } 
}
```
- 子協程的join方法
```kotlin
val job = GlobalScope.launch { // 启动一个新协程并保持对这个作业的引用
    delay(1000L)
    println("World!")
}
println("Hello,")
job.join() // 等待直到子协程执行结束
```
### suspend關鍵字

### object關鍵字
#### 能自動實現單例模式的class，不能被賦值
```kotlin
object Test {
    val a = 0;
}
```
對應的字節碼
```kotlin
public final class Test {
   private static final int a;
   @NotNull
   public static final Test INSTANCE;

   public final int getA() {
      return a;
   }

   private Test() {
   }

   static {
      Test var0 = new Test();
      INSTANCE = var0;
   }
}
```

#### 伴生對象
> 在 JVM 平台，如果使用 @JvmStatic 注解，你可以将伴生对象的成员生成为真正的静态方法和字段。更详细信息请参见[Java 互操作性](https://www.kotlincn.net/docs/reference/java-to-kotlin-interop.html#%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5)一节 。
## handler
讓子綫程結束后的結果傳遞給主綫程， 給主綫程更新界面
handler異步通信系統：`Handler`，`message`，Looper， MessageQueue
Looper:主綫程不斷從消息隊列中拿消息的東西
子綫程
--拿到主綫程的handler，sendMessage-->
主綫程的Handler系統
--從消息隊列中拿到消息，交給主綫程，handleMessage-->
主綫程

