---
title: 实习笔记-11
date: 2022-03-22 21:15:36
tags: Kotlin-Android 实习
categories: Kotlin-Android
toc: true
language: zh-CN
---

## Intent Action相关

### chooser
可自定义标题，弹出软件选择器
```java
Intent intent = new Intent();
intent.setAction(Intent.ACTION_SEND);
intent.setType("text/plain");
Intent intent2 = new Intent();
intent2.setAction(Intent.ACTION_CHOOSER);
intent2.putExtra(Intent.EXTRA_TITLE, "please selete a app");
//extra intent
intent2.putExtra(Intent.EXTRA_INTENT, intent);
startActivity(intent2);
```
方便起见，可以使用
```java
Intent.createChooser(Intent,CharSequence)
```

### ACTION_CONFIGURATION_CHANGED
设备的设置改变，orientation，locale等

## Configuration
```java
Configuration config = getResources().getConfiguration();
```

## requestedOrientation

更改此Activity的所需方向。如果 Activity 当前处于前台或以其他方式影响屏幕方向，则屏幕将立即更改（可能导致 Activity 重新启动）。否则，这将在下次Activity可见时使用。



```
landscape：限制界面为横屏，旋转屏幕也不会改变当前状态。
portrait：限制界面为竖屏，旋转屏幕也不会改变当前状态。
sensor:根据传感器定位方向，旋转手机90度，180,270,360，界面都会发生变化。
sensorLandscape：（横屏的旋转，不会出现竖屏的现象）根据传感器定位方向，旋转手机180度界面旋转。一般横屏游戏会是这个属性。
sensorPortrait：（竖屏的旋转，不会出现横屏的现象）根据传感器定位方向，旋转手机180度界面会旋转。
unspecified：由系统选择显示方向，不同的设备可能会有所不同。（旋转手机，界面会跟着旋转）
user:用户当前的首选方向。
nosensor：不由传感器确定方向。旋转设备的时候，界面不会跟着旋转。初始界面方向由系统提供。
```

## SystemClock
```java
1、public static long currentThreadTimeMillis ()   返在当前线程运行的毫秒数。

2、public static long elapsedRealtime ()   返回系统启动到现在的毫秒数，包含休眠时间。

3、public static long elapsedRealtimeNanos ()   返回系统启动到现在的纳秒数，包含休眠时间。

4、public static boolean setCurrentTimeMillis (long millis)    设置当前的"墙"时间，要求调用进程有许可权限。返回是否成功。

5、public static void sleep (long ms)    等待给定的时间。和Thread.sleep(millis)类似，但是它不会抛出InterruptedException异常。事件被推迟到下一个中断操作。该方法直到指定的时间过去才返回。

6、public static long uptimeMillis ()   返回系统启动到现在的毫秒数，不包含休眠时间。就是说统计系统启动到现在的非休眠期时间。
```

## Java 的强引用、弱引用、软引用、虚引用
- 1、强引用（StrongReference）
  - 强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。
  - 当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。

- 2、软引用（SoftReference）
  - 如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
  - 内存不足时才回收

- 3、弱引用（WeakReference）
  - 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。
  - 只要被gc扫描到，无论是否缺内存都回收

- 4、虚引用（PhantomReference）
  - “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。
  - 虚引用主要用来`跟踪对象被垃圾回收器回收的活动`。虚引用与软引用和弱引用的一个区别在于：`虚引用必须和引用队列 （ReferenceQueue）联合使用`。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。