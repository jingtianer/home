---
title: 十三周记录
date: 2023-4-8 12:15:37
tags: 
    - 组会 
categories: 组会
toc: true
language: zh-CN
---

## 完成aflgo修改的剩余部分

- 分别完成并实现了另外两种效果的Holder
- 在runOnModule中完成相关逻辑
- 使用bind9和dnsmasq编译测试了他的效果，可以挖出crash

## 完成dnsmasq的钩子编写

- dnsmasq并没有像bind一样提供一个`fuzz.c`，需要自己编写，编写的逻辑与bind9相似
- 创建线程读取输入+socket向自身发送数据+适当时机回调

### fuzz.c
```c
#include "fuzz.h"
#ifdef ENABLE_AFL
#include <errno.h>
#include <pthread.h>
#include <unistd.h>
#include <signal.h>
#include <stdlib.h>
#include <fcntl.h>
#include <pthread.h>

#include <stdio.h>
#include <string.h>

#include <sys/socket.h>
#include <netinet/in.h>

#define BUF_SIZE 65536
#define bool char
#define true 1
#define false 0

static pthread_cond_t cond;
static pthread_mutex_t mutex;
static bool ready;

static void *work_thread()
{
    // freopen ("logmasq", "w", stderr);
    INFO("fuzz thread startup successfully\n");
    char *host;
    char *port;
    struct sockaddr_in servaddr;
    int sockfd;
    void *buf;
    int inputfd;
    int loop = 0;

    host = getenv("FUZZ_SERVER_CONFIG");
    CHECK(host != NULL, "FUZZ_SERVER_CONFIG is not defined\n");
    host = strdup(host);
    CHECK(host != NULL, "host is null\n");
    port = strchr(host, ':');
    CHECK(port != NULL, "port is null\n");
    *port = 0;
    port++;
    INFO("port = %s, addr = %s\n", port, host);
    memset(&servaddr, 0, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    CHECK(inet_pton(AF_INET, host, &servaddr.sin_addr) == 1, "invalid port\n");
    servaddr.sin_port = htons(atoi(port));

    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    CHECK(sockfd != -1, "socket creation failed\n");

    buf = malloc(BUF_SIZE);
    CHECK(buf != NULL, "memory allocation failed\n");
    char *inputfile = getenv("FUZZ_INPUT_FILE");
    if (inputfile)
    {
        errno = 0;
        inputfd = open(inputfile, O_RDONLY);
        CHECK(inputfd != -1, "fail to open input file\n");
    }
    else
    {
        inputfd = open("/dev/fd/0", O_RDONLY);
    }
    free(host);
#ifdef __AFL_LOOP
    while (__AFL_LOOP(1000))
    {
        INFO("__AFL_LOOP(%d)\n", loop);
        loop++;
#else
    {
        INFO("NO AFL_LOOP\n");
#endif /* ifdef __AFL_LOOP */
        size_t length;
        size_t sendsize;

        errno = 0;
        length = read(inputfd, buf, BUF_SIZE);
        CHECK(length != -1, "fail to read input file\n");
        if (length == 0)
        {
#ifdef __AFL_LOOP
            continue;
#else
            goto next;
#endif /* ifdef __AFL_LOOP */
        }
        INFO("read from input = %s\n", buf);
        CHECK(pthread_mutex_lock(&mutex) == 0, "fail to get mutex\n");

        ready = false;

        length = sendto(sockfd, buf, length, 0,
                        (struct sockaddr *)&servaddr, sizeof(servaddr));
        CHECK(length == length, "fail to send\n");
        memset(buf, 0, BUF_SIZE);
        (void)recvfrom(sockfd, buf, 65536, MSG_DONTWAIT,
                       (struct sockaddr *)&servaddr, sizeof(servaddr));
        INFO("before wait, recv = %s\n", buf);
        while (!ready)
        {
            pthread_cond_wait(&cond, &mutex);
        }
        INFO("after wait\n");
        CHECK(pthread_mutex_unlock(&mutex) == 0, "fail to unlock mutex\n");
    next:;
    }
    INFO("finish afl, exit\n");
    free(buf);
    close(sockfd);
    fclose(stderr);
    exit(0);
    return (NULL);
}

void fuzz_notify()
{
    INFO("fuzz notify\n");
    CHECK(pthread_mutex_lock(&mutex) == 0, "notify fail to get mutex\n");

    ready = true;

    CHECK(pthread_cond_signal(&cond) == 0, "notify fail to signal work thread\n");
    CHECK(pthread_mutex_unlock(&mutex) == 0, "notify fail to unlock mutex\n");
    INFO("fuzz notify end, ready = %d\n", ready);
}

pthread_t fuzz_setup()
{
    pthread_t thread;
    if (getenv("AFL_PERSISTENT"))
    {
        CHECK(pthread_mutex_init(&mutex, NULL) == 0, "fail to init mutex\n");
        CHECK(pthread_cond_init(&cond, NULL) == 0, "fail to init cond\n");
        CHECK(pthread_create(&thread, NULL, work_thread, NULL) == 0, "fail to create work thread\n");
    }
    return thread;
}

#endif
```

### dnsmasq.c

> dnsmasq的main函数在这里，大致看了dnsmasq的代码，main函数做了参数解析和listener的初始化。退出的话应该都是直接`exit(code)/_exit(code)`

> 由此知道可以直接在main函数中启动线程，待线程将所有输入测试用例读取+发送+callback，就可以直接在线程中`exit(0)`

- 在main函数中有一个死循环，其中有一个check_dns_listeners
  - 对于tcp，这个函数实现了对所有listener调用accept，接收连接请求
  - 对于udp，这个函数调用了reply_query，这个函数里分别用recvfrom和sendto接收请求并发送回复

> 所以notify函数在check_dns_listeners执行完成后调用即可

```c
    check_dns_listeners(&rset, now); //这里有accept
#ifdef ENABLE_AFL
    fuzz_notify();
#endif
```


### 总结

- 大致看了aflnet的代码，他做的确实是在afl的基础上添加了很多网络相关的内容
  - 根据所选协议构造对应格式的数据包
  - 根据协议与服务端建立连接
  - 数据包收发
- 暂时没有找到aflnet如何判断server是否完成了数据的请求，在实际使用中发现
  - aflgo+编写钩子
    - 执行速度较快(500-1k/s)，对dnsmasq相同版本挖掘，aflgo只要20分钟就出crash了
    - 由于频繁的线程挂起和恢复，稳定性较差(< 10 %)。对于每个需要测试的服务器，都要阅读其源码，找到适当的线程启动，回调时机。
  - aflnet
    - 相对稳定(> 60 %)，不需要阅读源码，手写钩子
    - 执行速度较慢(8/s)，且非导向型挖掘