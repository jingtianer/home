---
title: 第12周记录
date: 2023-3-28 12:15:37
tags: 
    - 组会 
categories: 组会
toc: true
language: zh-CN
---

## aflgo参数添加

### 准备
aflgo使用的编译器是`afl-clang-fast`和`afl-clang-fast++`，代码文件位于`aflgo/llvm_mode`，该文件夹下共有三个文件

|文件名|作用|
|-|-|
|afl-clang-fast.c|包含main(), 程序入口，编辑输入参数，根据环境变量编辑参数。afl-clang的一层壳，处理好参数后调用afl-clang[++]*, 加载afl-llvm-pass.so|
|afl-llvm-pass.so.cc|在aflgo预处理模式下，读取cfg，生成计算distance所需的几个文件，在aflgo插桩模式下，根据gen_distance.py生成的距离文件，进行插桩|
|afl-llvm-rt.o.c|afl的一个库，防止用户没有安装afl|

### 参数定义
- -result_type, 效果类型，可选参数值有:
  - dns_disturbance, dns扰乱。另需传入四个参数:
    - -vulnerable, 易受攻击的函数集合（文件绝对路径）
    - -sink, sink函数集合（文件绝对路径），各种recv
    - -source, source函数集合（文件绝对路径），各种send
    - -blocking, 阻塞函数集合（文件绝对路径）（这里以后可以细化，有些函数是根据flag阻塞的，对于每条指令，拿到函数名后分析其参数判断是否真的阻塞）
  - privilege_escalation, 主机提权
    - [Jetset: Targeted Firmware Rehosting for
Embedded Systems](https://www.usenix.org/system/files/sec21-johnson.pdf)  主机提权 & cfg

  - dns_recored_falsify, dns记录篡改

### dns扰乱的实现

#### 参数编辑
文件: `afl-clang-fast.c`
在函数中处理参数的部分添加参数，当遇到自定义的参数时，在其前面添加`-mllvm`，表明该参数传送给llvm
```c
while (--argc) {
u8* cur = *(++argv);

if (!strncmp(cur, "-distance", 9)
    || !strncmp(cur, "-result_type", 12)
    || !strncmp(cur, "-vulnerable", 11)
    || !strncmp(cur, "-sink", 5)
    || !strncmp(cur, "-source", 7)
    || !strncmp(cur, "-blocking", 9)
    || !strncmp(cur, "-outdir", 7))
    cc_params[cc_par_cnt++] = "-mllvm";
    // ...其他参数的处理
    cc_params[cc_par_cnt++] = cur;
```

#### llvm中参数添加
文件: `afl-llvm-pass.so.cc`
在全局区使用llvm提供的工具对参数进行定义，参数会自动解析为对应类型
```c++
// 效果导向参数

cl::opt<std::string> ResultTypeOpt(
  "result_type",
  cl::desc("Specify the type result."),
  cl::value_desc("result_type"));

// 域名解析扰乱参数

cl::opt<std::string> VulnerableFile(
  "vulnerable",
  cl::desc("Input file containing the vulnerable funcions code. absolute path"),
  cl::value_desc("vulnerable"));

cl::opt<std::string> SinkFile(
  "sink",
  cl::desc("Input file containing the sink funcions code. absolute path"),
  cl::value_desc("sink"));


cl::opt<std::string> SourceFile(
  "source",
  cl::desc("Input file containing the source funcions code. absolute path"),
  cl::value_desc("source"));

cl::opt<std::string> BlockingFile(
  "blocking",
  cl::desc("Input file containing the blocking funcions code. absolute path"),
  cl::value_desc("blocking"));
```
- 在实现时注意，这个函数共三种状态:
  - 传统插桩（默认行为，当传入参数不满足aflgo的要求时，执行该行为。不能因为参数不符合aflgo的要求而中断此次编译，主要是会导致make阶段对编译工具的测试失败）
  - aflgo插桩
  - aflgo预处理


#### 功能实现
aflgo预处理/插桩的代码位于`af-llvm-pass.so.cc/bool AFLCoverage::runOnModule(Module& M)`

#### 定义ResultType
文件: `result/result.h`
```c++
enum class ResultType {
    DNS_DISTURB = 1, //"dns_disturbance"
    PRIVI_ESCA,// "privilege_escalation"
    DNS_RECORD_FALSIFY // = "dns_recored_falsify"
};

std::string operator*(ResultType r) {
    switch (r) {
    case ResultType::DNS_DISTURB:
    {
        return "dns_disturbance";
        break;
    }
    case ResultType::PRIVI_ESCA:
    {
        return "privilege_escalation";
        break;
    }
    case ResultType::DNS_RECORD_FALSIFY:
    {
        return "dns_recored_falsify";
        break;
    }
    }
    FATAL("r is not a ResultType\n");
    return "";
}
```
在`runOnModule`函数中定义一个该枚举变量，根据参数`ResultTypeOpt`指定该值，用于判断当前效果类型，后续其他效果沿用相同的设计

#### 定义DisturbHolder
这是一个类，意在持有dns服务扰乱效果下需要的各种变量，在`runOnModule`函数中只定义一个改类对象，而不扰乱其原有的命名空间，并在退出时对资源进行释放
```c++
class DisturbHolder {
private:
    std::ifstream vulnerable, sink, source, blocking;
    std::vector<std::string> vulF, sinkF, sourceF, blockF;
    std::string outDir;
    std::set<std::string> intrestedBB;
public:
    void initOutDirectory(std::string OutDirectory) {
        outDir = OutDirectory;
        if(outDir.back() == '/' || outDir.back() == '\\') {
            outDir.pop_back();
        }
        // SAYF("outdir = %s\n", outDir.c_str());
        
    }
    void initFiles(std::string pathv, std::string pathsi, std::string pathso, std::string pathb) {
        if (pathv.empty() || pathsi.empty() || pathso.empty() || pathb.empty()) {
            FATAL("'-vulnerable', '-sink', '-source' and '-blocking' are not specified");
        }
        vulnerable.open(pathv);
        sink.open(pathsi);
        source.open(pathso);
        blocking.open(pathb);
        if (!vulnerable.is_open()) {
            FATAL("vulnerable open failed\n");
        }
        if (!sink.is_open()) {
            FATAL("sink open failed\n");
        }
        if (!source.is_open()) {
            FATAL("source open failed\n");
        }
        if (!blocking.is_open()) {
            FATAL("blocking open failed\n");
        }

        std::string tmpstr;
        while (getline(vulnerable, tmpstr)) vulF.push_back(tmpstr);
        while (getline(sink, tmpstr)) sinkF.push_back(tmpstr);
        while (getline(source, tmpstr)) sourceF.push_back(tmpstr);
        while (getline(blocking, tmpstr)) blockF.push_back(tmpstr);

        vulnerable.close();
        sink.close();
        source.close();
        blocking.close();
    }

    bool isIntrestedF(const llvm::Function* F, std::string filename, int line) {
        std::string func = F->getName().str();
        // SAYF("checking if %s is isIntrestedF\n", func.c_str());
        bool ret =  std::find(vulF.begin(), vulF.end(), func) != vulF.end() ||
            std::find(sinkF.begin(), sinkF.end(), func) != sinkF.end() ||
            std::find(sourceF.begin(), sourceF.end(), func) != sourceF.end() ||
            std::find(blockF.begin(), blockF.end(), func) != blockF.end();
        if(ret)
            intrestedBB.insert(filename + ":" + std::to_string(line));
        return ret;
    }

    bool isSinkF(const llvm::Function* F) {
        std::string func = F->getName().str();
        return std::find(sinkF.begin(), sinkF.end(), func) != sinkF.end();
    }

    bool isSourceF(const llvm::Function* F) {
        std::string func = F->getName().str();
        return std::find(sourceF.begin(), sourceF.end(), func) != sourceF.end();
    }
    bool isSinkCapable(llvm::BasicBlock& bb, std::string&& bb_name) {
        bool flag = false;
        for (auto& I : bb) {
            if (auto* c = llvm::dyn_cast<llvm::CallInst>(&I)) { // 同时判空
                if (auto* CalledF = c->getCalledFunction()) {
                    if(isSinkF(CalledF)) {
                        flag = true;
                    } else if (isSourceF(CalledF)) {
                        return false;
                    }
                }
            }
        }
        if(flag) {
            intrestedBB.insert(bb_name);
        }
        return flag;
    }
    ~DisturbHolder() {
        if(!outDir.empty()) {
            std::ofstream bbtargets(outDir + "/BBtargets.txt", std::ofstream::out | std::ofstream::app);
            for(auto &F : intrestedBB) {
                bbtargets << F << std::endl;
            }
            bbtargets.close();
            // SAYF("write to outdir\n");
        }
    }
};
#endif
```

#### 其他修改
其他修改位于`runOnModule`，主要是根据参数初始化`Holder`、分析cfg找到感兴趣的BB等

#### 效果分析
修改后的aflgo不需要传入BBTargets.txt，直接根据效果类型在编译过程中生成。利用修改后的aflgo对`dns_rdata_fromwire_text`进行fuzz，也可以挖出crash，与aflgo的表现相似



## fuzz.c的debug

### 错误使用的环境变量

在named的main函数中，如果检测到`named_g_fuzz_type`不是`isc_fuzz_none`，即本次运行是要进行fuzz的，将会调用函数`named_fuzz_setup`。这个函数的作用是创建一个线程，根据fuzz任务的类型，指定一个函数`fn`，即该线程执行的函数。但是启动线程的条件是获取环境变量，需要环境中存在`__AFL_PERSISTENT`或`AFL_CMIN`。

问题是`__AFL_PERSISTENT`是用户手动强制开启persistent模式的，我们在fuzz named之前需要手动添加环境这个环境变量
```sh
export __AFL_PERSISTENT=FU_NAMED
```

### 未使用__AFL_LOOP()

__AFL_LOOP()是llvm中定义的一个宏，当其除第一次和最后一次执行时，会执行`raise(SIGSTOP)`，将进程挂起。不适用的话使用afl测试就会导致挂起无法退出。

代码中的循环使用的是普通的for循环，应该改成AFL_LOOP

```c
// for(int loop = 0; loop < 100000; loop++) {}
while(__AFL_LOOP(1000)) {
```

### -A resolver参数

在分析参数时使用了`strchr`来寻找分隔符`':'`，但是在分析到第四个参数时出现了第四个参数为空的情况

```c
sqtype = strdup(named_g_fuzz_addr);
RUNTIME_CHECK(sqtype != NULL);

shost = strchr(sqtype, ':');
RUNTIME_CHECK(shost != NULL);
*shost = 0;
shost++;

sport = strchr(shost, ':');
RUNTIME_CHECK(sport != NULL);
*sport = 0;
sport++;

rhost = strchr(sport, ':');
RUNTIME_CHECK(rhost != NULL);
*rhost = 0;
rhost++;

rport = strchr(rhost, ':');
RUNTIME_CHECK(rport != NULL);
*rport = 0;
rport++;`
```

问题出在，我们传入的参数是`resolver:<shost>:<sport>:<rhost>:<rport>`，但是参数传入这个函数后，前面的`resolver`已经没有了，他多找了一次冒号，导致最后一个参数为NULL，崩溃



实际上这个函数的参数应该是五个，第一个是dns协议的qtype，他在注释里写错了，代码本身没有bug

qtype就是dns查询中，查询的记录类型

```sh
A=0x01, //指定计算机 IP 地址。
NS=0x02, //指定用于命名区域的 DNS 名称服务器。
MD=0x03, //指定邮件接收站（此类型已经过时了，使用MX代替）
MF=0x04, //指定邮件中转站（此类型已经过时了，使用MX代替）
CNAME=0x05, //指定用于别名的规范名称。
SOA=0x06, //指定用于 DNS 区域的“起始授权机构”。
MB=0x07, //指定邮箱域名。
MG=0x08, //指定邮件组成员。
MR=0x09, //指定邮件重命名域名。
NULL=0x0A, //指定空的资源记录
WKS=0x0B, //描述已知服务。
PTR=0x0C, //如果查询是 IP 地址，则指定计算机名；否则指定指向其它信息的指针。
HINFO=0x0D, //指定计算机 CPU 以及操作系统类型。
MINFO=0x0E, //指定邮箱或邮件列表信息。
MX=0x0F, //指定邮件交换器。
TXT=0x10, //指定文本信息。 
AAAA=0x1c,//IPV6资源记录。
UINFO=0x64, //指定用户信息。
UID=0x65, //指定用户标识符。
GID=0x66, //指定组名的组标识符。
ANY=0xFF //指定所有数据类型。
```

### named_fuzz_notify的问题
在AFL_LOOP中，会向服务端发送DNS查询消息，并等待消息返回，等待过程中通过条件变量将AFL_LOOP挂起，当client收到消息后，调用该函数，将条件置为true，AFL_LOOP就可以继续读取下一个测试用例了。

但是在这个函数中使用了一个`raise(SIGSTOP)`，也就是收到一个返回消息后，就将该进程挂起了。这样做显然是不正确的。

### 导致进程无法kill的真正原因
1. 一是由于前面环境变量的问题，导致线程无法被创建

2. named_fuzz_notify中调用了raise(SIGSTOP)，虽然__AFL_LOOP()在除第一次调用和最后一次调用时也会发送同一个信号，但是如果使用`afl`而不是`afl-clang-fast`，就会导致其被挂起而无法退出

3. 多个进程同时监听同一个端口，导致本应由进程A接受的消息被进程B接受，导致A的fuzz线程被持续挂起

4. 当named不指定-g参数时，就会fork自己，并不清楚为什么会这样

对于resolver fuzz模式，需要在named的配置文件中配置`aaaaaaaaaa.example`的root zone，这是我之前读注释时没有读懂的

对于client的fuzz模式，fuzz线程会作为一个client运行，去查询参数中指定的`<addr>:<port>`的dns服务器的消息，之前一直没有理解，看了代码后才发现这个参数是要指定本进程的

### 漏洞挖掘
通过以上的debug过程，最终成功将named跑起来了

```sh
                        american fuzzy lop 2.57b (named)

┌─ process timing ─────────────────────────────────────┬─ overall results ─────┐
│        run time : 0 days, 0 hrs, 2 min, 50 sec       │  cycles done : 1      │
│   last new path : 0 days, 0 hrs, 0 min, 4 sec        │  total paths : 353    │
│ last uniq crash : none seen yet                      │ uniq crashes : 0      │
│  last uniq hang : none seen yet                      │   uniq hangs : 0      │
├─ cycle progress ────────────────────┬─ map coverage ─┴───────────────────────┤
│  now processing : 330* (93.48%)     │    map density : 0.02% / 19.74%        │
│ paths timed out : 0 (0.00%)         │ count coverage : 3.12 bits/tuple       │
├─ stage progress ────────────────────┼─ findings in depth ────────────────────┤
│  now trying : arith 8/8             │ favored paths : 3 (0.85%)              │
│ stage execs : 1518/3738 (40.61%)    │  new edges on : 60 (17.00%)            │
│ total execs : 1.20M                 │ total crashes : 0 (0 unique)           │
│  exec speed : 6939/sec              │  total tmouts : 0 (0 unique)           │
├─ fuzzing strategy yields ───────────┴───────────────┬─ path geometry ────────┤
│   bit flips : 5/17.4k, 4/17.4k, 2/17.2k             │    levels : 9          │
│  byte flips : 1/2176, 2/2121, 1/2024                │   pending : 299        │
│ arithmetics : 30/118k, 6/27.5k, 1/7641              │  pend fav : 0          │
│  known ints : 0/11.1k, 13/52.6k, 21/84.4k           │ own finds : 352        │
│  dictionary : 0/0, 0/0, 6/21.8k                     │  imported : n/a        │
│       havoc : 260/815k, 0/0                         │ stability : 0.08%      │
│        trim : 0.00%/681, 0.00%                      ├────────────────────────┘
└─────────────────────────────────────────────────────┘          [cpu000: 58%]

```

目前已经将dns_rdata_fromwire_text挖出的漏洞喂给named进行fuzz了

#### 脚本
运行
```sh

set -e
AFLGO=/home/ubuntu/dnsenv/aflgo/scripts/build/aflgo
SUBJECT=$PWD/bind9_fast

export AFL_PERSISTENT=1
export LD_LIBRARY_PATH=$SUBJECT/lib/isc/.libs:$SUBJECT/lib/dns/.libs:$SUBJECT/lib/isccc/.libs:$SUBJECT/lib/isccfg/.libs

export CC=$AFLGO/afl-clang-fast
export CXX=$AFLGO/afl-clang-fast++

export CFLAGS="-D ENABLE_AFL"
export CXXFLAGS="-D ENABLE_AFL"

pushd $SUBJECT
	autoreconf -fi
	./configure  --enable-fuzzing=afl
	sudo make -j
	sudo make install
popd

tee named.conf <<-'EOF'
options {
    directory    "$PWD/workdir";
    allow-query     { any; };
    listen-on port 2778 { any; };
};
EOF
pattern="s/\$PWD/$(echo `pwd` | sed "s/\//\\\\\//g")/g"
sed -i $pattern named.conf 
cat named.conf

cp -r in/working in/fast

if [ -d workdir ]; then
    rm -rf workdir;mkdir workdir
fi
if [ ! -d workdir ]; then
    mkdir workdir
fi

if [ ! -d out_fast ]; then
    mkdir out_fast
fi
cp in/working/* in/fast -r
$AFLGO/afl-fuzz -t 50000 -m none -i in/dns_name_fromwire.in -o out_fast -- $SUBJECT/bin/named/.libs/named -A client:127.0.0.1:2778 -g -c named.conf
```

> 相当于搭建了一个最简单的named服务器，持续将afl-fuzz的测试用例作为数据包发送给自身
> 种子文件我使用tcpdump抓取了一个dis查询的包

```sh
named -c named.conf -L named.log #监听端口2779 
sudo tcpdump -i lo udp port 2779 -c 1 -w out &
dig @localhost -p 2779 www.baidu.com
```