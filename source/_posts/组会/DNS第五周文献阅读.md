---
title: DNS第五周文献阅读
date: 2023-2-12 12:15:37
tags: 
    - 文献阅读
    - 组会 
categories: 组会
toc: true
language: zh-CN
---

## Alphuzz: Monte Carlo Search on Seed-Mutation Tree for Coverage-Guided

### abstract

在本研究中，我们发现种子之间的关系对于种子调度是有价值的。我们通过研究和利用种子之间的变异关系，设计并提出了一个"种子变异树"。利用"种子变异树"，我们进一步将种子调度问题建模为蒙特卡洛树搜索( MCTS )问题。即在MCTS估计的基础上，通过最优路径遍历"种子变异树"，选择下一个种子进行模糊处理。

### introduction

大量的种子调度策略被提出。一般来说，这些策略的目的是根据一定的标准为每个种子分配一个分数，然后选择分数最高的种子进行下一次的模糊迭代。例如，AFL偏好于具有最小尺寸和最短执行时间的种子。这些策略独立地对待这些种子，并没有明确地考虑种子之间的关系。

"种子变异树"的主要优点是有利于种子调度在利用式(即,反复锻炼一个高电位的种子和它的邻居)和探索式(即,尝试一个很少锻炼的种子)之间进行平衡，以获得最佳性能。如上所述，种子调度是指为探索其邻居路径而选择一条执行路径。利用种子之间的关系，我们可以进一步将每个种子对应的路径组织为一个树结构，记为执行树。

### 论文贡献
- 新见解。我们重点观察到种子之间的关系对于种子调度是有价值的。我们研究并利用种子变异关系来构建一个"种子变异树"，它是模糊测试执行树的近似，可以进一步帮助种子调度平衡利用和探索。
- 新的fuzzing技术。利用"种子变异树"，我们将种子调度问题建模为蒙特卡洛树搜索( MCTS )问题，并提出了基于MCTS的种子调度策略。由于MCTS算法的性质，该策略在利用和探索之间取得了平衡。

### 种子变异树

种子变异树被定义成一个三元组，T = (V, E, 𝛼),V是种子，E是边，𝛼是突变关系

- 最初，树由根节点和几个初始种子的节点构成
- 选择一个种子变异，生成新的测试用例。然后，将新生成的覆盖新路径的测试用例作为原始种子的子代加入到"种子变异树"中。
- 一些特殊的突变可能作用于两个种子。例如，AFL中剪接体的突变会将一个种子与第二个种子进行剪接，产生新的输入。在这种情况下，我们只在新节点和第一个种子对应的节点之间构造一条边，因为第一个种子是通过种子调度策略选择的，而第二个种子是随机选择的。

#### 三个挑战
- 搜索空间大且不断增大。因此，我们需要一个启发式算法来提供当前的最佳决策。
- 启发式算法的核心是给种子分配分数。然而，随着模糊测试对其相邻路径的探索越来越深入，种子覆盖路径的得分可能会下降。因此，在每次模糊迭代后更新树上所有种子的得分是必要的，但也是具有挑战性的。
- 很难平衡开发和利用。由于模糊测试本质上的随机化特性的影响，经过一次模糊测试迭代后计算出的种子评分会受到这种不确定性的影响。因此，如何在这些不确定因素下平衡开发和利用是一个挑战。

### 蒙特卡洛搜索

MCTS是一种通过基于随机抽样的顺序构建树进行最优决策的算法。该过程包括四个步骤：
- 选择。MCTS采用特定的树策略，从根节点R开始，递归地选择最优的子节点，直到达到一个叶节点L。
- 扩张。如果L不是终端节点，则MCTS创建一个或多个子节点。进一步，从这些子节点中选择一个节点C。在这一步中，子节点指的是来自L定义的状态的任何有效移动。
- 仿真。通过随机选择动作来执行，直到达到一个结果或预定义的状态。
- 反向传播。这一步回传从新节点C传播到根节点R，更新仿真结果。

树的置信上界（UCB）：UCB公式平衡了对已知奖励的利用和对相对未访问节点的探索，以获得最佳性能。

#### 基于蒙特卡洛的种子调度算法

MCTS从根节点开始，在每个层次上选择得分最高的下一个节点，直到达到一个叶节点。然后，模糊测试在监视新生成的输入的执行的同时随机变异所选的种子。由于并不是所有新生成的输入都提高了代码覆盖率，因此我们先进行仿真，只在树中添加提高代码覆盖率的输入。最后，我们在每次模糊迭代后更新种子的得分

#### 树的构建与扩展

"种子变异树"中，一个内部节点有两种不同的角色。首先，它指的是种子。其次，从树的结构来看，它也是子树的根节点。因此，一个内部节点即使有多个子节点也可以被选为种子。
作为种子，分数是指选择该种子的模糊度得分。作为子树的根节点，分数指的是选择子树中每个种子的摘要模糊度得分。

为了解决这种不相容性，我们通过为每个内部节点插入一个变异节点来更新"种子变异树"。内部节点指其子树的根节点，变体指其对应的种子。这样，变体将是内部节点的一个叶子节点。对于模糊得分，内部节点指子树中每个种子的模糊得分汇总。相比之下，变体是指对应种子的模糊度评分。

## Not All Coverage Measurements Are Equal: Fuzzing by Coverage Accounting for Input Prioritization

### 背景知识

> 论文中提到的，以及我个人需要读懂这篇论文，需要进行补充的背景知识

#### taint analysis

污点分析可以抽象成一个三元组<sources, sinks, sanitizers>的形式。sources：污点源，代表直接引入不受信任的数据或者机密数据到系统中。sink：污点汇聚点，代表直接产生安全敏感操作或者泄露隐私数据到外界。sanitizer：无害处理，代表通过数据加密或者移除危害操作等手段使数据传播不再对软件系统的信息安全产生危害。

污点分析就是分析程序中由污点源引入的数据是否能够不经无害处理,而直接传播到污点汇聚点.如果不能,说明系统是信息流安全的;否则,说明系统产生了隐私数据泄露或危险数据操作等安全问题。

污点分析的处理过程可以分成 3 个阶段: (1) 识别污点源和汇聚点; (2) 污点传播分析; (3) 无害处理.

#### 符号执行
- [参考](https://www.jianshu.com/p/2ba973c4b0cc/)
- [参考论文--SymQEMU:Compilation-based symbolic execution for binaries](https://www.baidu.com/s?wd=SymQEMU%3ACompilation-based%20symbolic%20execution%20for%20binaries)
符号执行 （Symbolic Execution）是一种程序分析技术，它可以通过分析程序来得到让特定代码区域执行的输入。顾名思义，使用符号执行分析一个程序时，该程序会使用符号值作为输入，而非一般执行程序时使用的具体值。在达到目标代码时，分析器可以得到相应的路径约束，然后通过约束求解器来得到可以触发目标代码的具体值。
在理想模型中，程序使用的每个符号变量均应该是一个有符号整数。

符号执行技术近年来大力发展，一种有效但是代价大的技术，其经常与fuzzing技术混合，并成为混合fuzzing，fuzzing用来探索容易到达的路径，而符号执行用来探索不易到达的路径。

针对符号执行技术的重要特征之一就是其是否需要提供源代码进行分析，而真实世界中的大多数程序(由于某些原因)是不提供源代码的。

#### 白盒测试（structure）

主要专注于测试系统内部的结构，因此需要尽可能的在测试中覆盖到所有必要的要素。

- statement coverage/node coverage: test case要确保尽可能覆盖到所有的node（每一个操作在控制流程图(CFG)中就是一个圆角方框即node）
- decision coverage/edge coverage: test case要确保尽可能覆盖到所有的edge，（即所有的箭头）
- condition coverage: 这是针对代码中测试的条件语句，每个条件要尽量cover到其所有正确或错误的结果，主要有两种写test case的方法
  - simple: 针对条件语句中所有的条件，每个条件都需要至少有一个T和一个F的情况包括在内（这个情况称为满足simple condition coverage），但是仅仅是针对一个语句里的子条件，整个条件语句的结果可能不会满足一定有T和F（这种情况为满足condition coverage）。
  - multiple: 这种方法就是不仅要满足每个子条件有T有F还要将所有可能的子条件的组合情况给列出来
- path coverage: 在test case中需要尽量包括所有的路径（即到每一个可能终点的可能路径），值得注意的是如果没有循环才可能cover到所有的情况，即使只有一个循环也无法cover到所有的情况
- loop coverage: 其实算是path coverage的一部分，其旨在测试代码中的循环。

#### anti-fuzzing techniques

反模糊化技术通过插入伪路径、在错误处理代码中添加延迟、模糊代码以减缓动态分析来欺骗模糊测试。

#### CGF(Coverage-guided Fuzzing)

fuzzing是一种自动生成和测试输入以发现软件漏洞的程序测试技术。它不需要对程序的理解，也不需要人工生成测试用例，具有灵活性，容易适用于不同的程序。

覆盖率引导的模糊测试以一个初始输入(种子)和一个目标程序作为输入，产生触发程序错误的输入作为输出。它重复选择一个输入，用输入运行目标程序，并根据当前输入及其运行结果生成新的输入。

### 文章贡献

- 提出了coverage accounting，输入优化的新方法
- 开发了TortoiseFuzz，基于coverage accounting的灰盒fuzzer

### coverage accounting

对edges度量，进行输入优化，通过对输入进行优先级排序，缩短发现漏洞的时间；为了抵御anti-fuzzing，不依赖于污点分析或者符号执行。

从函数调用，循环和基本块三个粒度分别对edge进行度量。

- 函数调用：从CVE以及其子页面中爬取数据，总结出一些易于出现问题的库函数的数据表。根据这些数据表，计算一个edge目的基本块中调用这些易于出现问题的库函数的函数个数
- 循环：若e是back edge（回边，其头是其尾的必经结点），则为1，否则为0
- 基本块：目的基本块中包含内存操作的指令个数

### TORTOISEFUZZ的设计

fuzzer的设计目的是结合coverage accounting，对更容易导致脆弱代码的输入进行优先级排序，同时保证优先输入覆盖足够的代码

- 由于内存操作是内存错误的先决条件，所以只有安全敏感的edges才是漏洞的关键，因此应该被选择的输入完全覆盖。
- 通过coverage accounting的计算，并设置一个域值，当超过域值时，认为是安全敏感的
- 在输入的选择上，输入越是命中安全敏感的edges，越有可能演化为触发漏洞

## 可疑基本块导向的定向模糊测试技术研究

### 核心内容

- 利用静态污点分析筛选出目标程序所有可疑基本块，再通过函数间控制流分析得出基本块之间的可达性，以提取可到达可疑基本块集合的所有基本块
  - 这篇文章分析了三种问题：缓冲区溢出、整形溢出、移位位数过大的特征，使用污点分析方法找到这些特征所在的代码块。
- 将可疑基本块以及可以到达这些块的块作为插桩对象，除此之外，无法到达该可疑基本块的块则不插桩，以此降低桩代码引入的额外开销。
- 计算所有基本块到可疑基本块集合的距离，根据该距离赋予基本块权重，距离越小权重越大
- 根据种子所触发路径上各基本块的权重计算其变异后漏洞发现概率，变异时优先选择漏洞发现概率更高的种子，借此优化种子选择过程，提高模糊测试漏洞挖掘效率。

